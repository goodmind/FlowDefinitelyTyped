declare module 'winrt-uwp' {
        declare var Windows: typeof npm$namespace$Windows;

      declare var npm$namespace$Windows: {
        
        
        
        
        Foundation: typeof npm$namespace$Windows$Foundation,
Media: typeof npm$namespace$Windows$Media,
Networking: typeof npm$namespace$Windows$Networking,
ApplicationModel: typeof npm$namespace$Windows$ApplicationModel,
Data: typeof npm$namespace$Windows$Data,
Devices: typeof npm$namespace$Windows$Devices,
Gaming: typeof npm$namespace$Windows$Gaming,
Globalization: typeof npm$namespace$Windows$Globalization,
Graphics: typeof npm$namespace$Windows$Graphics,
Management: typeof npm$namespace$Windows$Management,
Perception: typeof npm$namespace$Windows$Perception,
Security: typeof npm$namespace$Windows$Security,
Services: typeof npm$namespace$Windows$Services,
Storage: typeof npm$namespace$Windows$Storage,
System: typeof npm$namespace$Windows$System,
UI: typeof npm$namespace$Windows$UI,
Web: typeof npm$namespace$Windows$Web,
      }
declare type Windows$WinRTError = {
description: string,
number: number
} & Error


declare interface Windows$WinRTEvent<TSender> {
detail: any[],
target: TSender,
type: string
} 

declare interface Windows$IInspectable {} 


      declare var npm$namespace$Windows$Foundation: {
        
        
        AsyncStatus: typeof Windows$Foundation$AsyncStatus,
PropertyType: typeof Windows$Foundation$PropertyType,
        Deferral: typeof Windows$Foundation$Deferral,
MemoryBuffer: typeof Windows$Foundation$MemoryBuffer,
Uri: typeof Windows$Foundation$Uri,
WwwFormUrlDecoder: typeof Windows$Foundation$WwwFormUrlDecoder,
WwwFormUrlDecoderEntry: typeof Windows$Foundation$WwwFormUrlDecoderEntry,
        Diagnostics: typeof npm$namespace$Windows$Foundation$Diagnostics,
Metadata: typeof npm$namespace$Windows$Foundation$Metadata,
      }
declare type Windows$Foundation$IPromise<TResult> = {
then<U>(
success?: (value: TResult) => Windows$Foundation$IPromise<U>,
error?: (error: any) => Windows$Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Foundation$IPromise<U>,
then<U>(
success?: (value: TResult) => Windows$Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Foundation$IPromise<U>,
then<U>(
success?: (value: TResult) => U,
error?: (error: any) => Windows$Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Foundation$IPromise<U>,
then<U>(
success?: (value: TResult) => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Foundation$IPromise<U>,
done<U>(
success?: (value: TResult) => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void,
cancel(): void
} & PromiseLike<TResult>


declare type Windows$Foundation$IPromiseWithOperation<TResult, TOperation: Windows$Foundation$IAsyncAction> = {
operation: TOperation
} & Windows$Foundation$IPromise<TResult>


declare type Windows$Foundation$IPromiseWithIAsyncAction = Windows$Foundation$IPromiseWithOperation<void, Windows$Foundation$IAsyncAction>;

declare type Windows$Foundation$IPromiseWithIAsyncActionWithProgress<TProgress> = Windows$Foundation$IPromiseWithOperation<void, Windows$Foundation$IAsyncActionWithProgress<TProgress>>;

declare type Windows$Foundation$IPromiseWithIAsyncOperation<TResult> = Windows$Foundation$IPromiseWithOperation<TResult, Windows$Foundation$IAsyncOperation<TResult>>;

declare type Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<TResult, TProgress> = Windows$Foundation$IPromiseWithOperation<TResult, Windows$Foundation$IAsyncOperationWithProgress<TResult, TProgress>>;


      declare var npm$namespace$Windows$Foundation$Collections: {
        
        
        CollectionChange: typeof Windows$Foundation$Collections$CollectionChange,
        PropertySet: typeof Windows$Foundation$Collections$PropertySet,
StringMap: typeof Windows$Foundation$Collections$StringMap,
ValueSet: typeof Windows$Foundation$Collections$ValueSet,
        
      }
declare type Windows$Foundation$Collections$IVector<T> = {
indexOf(value: T, ...extra: any[]): {
index: number,
returnValue: boolean
},
indexOf(searchElement: T, fromIndex?: number): number,

/**
 * Appends an item to the end of the vector.
 * @param value The item to append to the vector.
 */
append(value: T): void,

/**
 * Removes all items from the vector.
 */
clear(): void,

/**
 * Returns the item at the specified index in the vector.
 * @param index The zero-based index of the item.
 * @return The item at the specified index.
 */
getAt(index: number): T,

/**
 * Retrieves the items that start at the specified index in the vector.
 * @param startIndex The zero-based index of the start of the items in the vector.
 */
getMany(startIndex: number): {
items: T,
returnValue: number
},

/**
 * Returns an immutable view of the vector.
 * @return The view of the vector.
 */
getView(): Windows$Foundation$Collections$IVectorView<T>,

/**
 * Retrieves the index of a specified item in the vector.
 * @param value The item to find in the vector.
 */
indexOf(value: T): {
index: number,
returnValue: boolean
},

/**
 * Inserts an item at a specified index in the vector.
 * @param index The zero-based index.
 * @param value The item to insert.
 */
insertAt(index: number, value: T): void,

/**
 * Removes the item at the specified index in the vector.
 * @param index The zero-based index of the vector item to remove.
 */
removeAt(index: number): void,

/**
 * Removes the last item from the vector.
 */
removeAtEnd(): void,

/**
 * Replaces all the items in the vector with the specified items.
 * @param items The collection of items to add to the vector.
 */
replaceAll(items: T): void,

/**
 * Sets the value at the specified index in the vector.
 * @param index The zero-based index at which to set the value.
 * @param value The item to set.
 */
setAt(index: number, value: T): void,

/**
 * Gets the number of items in the vector.
 */
size: number
} & Array<T>


declare type Windows$Foundation$Collections$IVectorView<T> = {
indexOf(value: T, ...extra: any[]): {
index: number,
returnValue: boolean
},
indexOf(searchElement: T, fromIndex?: number): number,

/**
 * Returns the item at the specified index in the vector view.
 * @param index The zero-based index of the item.
 * @return The item at the specified index.
 */
getAt(index: number): T,

/**
 * Retrieves the items that start at the specified index in the vector view.
 * @param startIndex The zero-based index of the start of the items in the vector view.
 */
getMany(startIndex: number): {
items: T,
returnValue: number
},

/**
 * Retrieves the index of a specified item in the vector view.
 * @param value The item to find in the vector view.
 */
indexOf(value: T): {
index: number,
returnValue: boolean
},

/**
 * Gets the number of items in the vector view.
 */
size: number
} & Array<T>



/**
 * Describes the action that causes a change to a collection.
 */

declare  var Windows$Foundation$Collections$CollectionChange: {|
  +reset: 0,// 0
+itemInserted: 1,// 1
+itemRemoved: 2,// 2
+itemChanged: 3,// 3

|};



/**
 * Represents a property set, which is a set of PropertyValue objects with string keys.
 */
declare class Windows$Foundation$Collections$PropertySet  {

/**
 * Creates and initializes a new instance of the property set.
 */
constructor(): this;

/**
 * Removes all items from the property set.
 */
clear(): void;

/**
 * Returns an iterator to enumerate the items in the property set.
 * @return The iterator. The current position of the iterator is index 0, or the end of the property set if the property set is empty.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Gets an immutable view of the property set.
 * @return The immutable view.
 */
getView(): Windows$Foundation$Collections$IMapView<string, any>;

/**
 * Indicates whether the property set has an item with the specified key.
 * @param key The key.
 * @return True if the property set has an item with the specified key; otherwise, false.
 */
hasKey(key: string): boolean;

/**
 * Adds an item to the property set.
 * @param key The key to insert.
 * @param value The value to insert.
 * @return True if the method replaces a value that already exists for the key; false if this is a new key.
 */
insert(key: string, value: any): boolean;

/**
 * Retrieves the value for the specified key.
 * @param key The key.
 * @return The value, if an item with the specified key exists; otherwise, null.
 */
lookup(key: string): any;

/**
 * Occurs when the observable map has changed.
 */
onmapchanged: Windows$Foundation$Collections$MapChangedEventHandler<string, any>;
addEventListener(
type: "mapchanged",
listener: Windows$Foundation$Collections$MapChangedEventHandler<string, any>): void;
removeEventListener(
type: "mapchanged",
listener: Windows$Foundation$Collections$MapChangedEventHandler<string, any>): void;

/**
 * Removes an item from the property set.
 * @param key The key.
 */
remove(key: string): void;

/**
 * Removes a specific item from the PropertySet .
 * @param key The key of the item to remove.
 * @return true if the item was removed, otherwise false.
 */
remove(key: string): boolean;

/**
 * Gets the number of items contained in the property set.
 */
size: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * An associative collection, also known as a map or a dictionary.
 */
declare class Windows$Foundation$Collections$StringMap  {

/**
 * Creates and initializes a new instance of the StringMap.
 */
constructor(): this;

/**
 * Removes all items from the map.
 */
clear(): void;

/**
 * Returns an iterator containing the items in the collection.
 * @return The items in the collection.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Returns an immutable view of the map.
 * @return The view of the map.
 */
getView(): Windows$Foundation$Collections$IMapView<string, string>;

/**
 * Determines whether the map contains the specified key.
 * @param key The key associated with the item to locate.
 * @return True if the key is found; otherwise, false.
 */
hasKey(key: string): boolean;

/**
 * Inserts or replaces an item in the map.
 * @param key The key associated with the item to insert.
 * @param value The item to insert.
 * @return True if an item with the specified key is an existing item that was replaced; otherwise, false.
 */
insert(key: string, value: string): boolean;

/**
 * Returns the item at the specified key in the map.
 * @param key The key associated with the item to locate.
 * @return The item associated with the specified key.
 */
lookup(key: string): string;

/**
 * Occurs when the contents of the map change.
 */
onmapchanged: Windows$Foundation$Collections$MapChangedEventHandler<string, string>;
addEventListener(
type: "mapchanged",
listener: Windows$Foundation$Collections$MapChangedEventHandler<string, string>): void;
removeEventListener(
type: "mapchanged",
listener: Windows$Foundation$Collections$MapChangedEventHandler<string, string>): void;

/**
 * Removes an item from the map.
 * @param key The key associated with the item to remove.
 */
remove(key: string): void;

/**
 * Gets the number of items in the map.
 */
size: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Implements a map with keys of type String and values of type Object . This class prevents non-serializable types from being put into the map.
 */
declare class Windows$Foundation$Collections$ValueSet  {

/**
 * Creates and initializes a new instance of the property set.
 */
constructor(): this;

/**
 * Removes all items from the value set.
 */
clear(): void;

/**
 * Returns an iterator to enumerate the items in the value set.
 * @return The iterator. The current position of the iterator is index 0, or the end of the value set if the value set is empty.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Gets an immutable view of the value set.
 * @return The immutable view.
 */
getView(): Windows$Foundation$Collections$IMapView<string, any>;

/**
 * Indicates whether the value set has an item with the specified key.
 * @param key The key.
 * @return True if the value set has an item with the specified key; otherwise, false.
 */
hasKey(key: string): boolean;

/**
 * Adds an item to the value set.
 * @param key The key to insert.
 * @param value The value to insert.
 * @return True if the method replaces a value that already exists for the key; false if this is a new key.
 */
insert(key: string, value: any): boolean;

/**
 * Retrieves the value for the specified key.
 * @param key The key.
 * @return The value, if an item with the specified key exists; otherwise, null.
 */
lookup(key: string): any;

/**
 * Occurs when the observable map has changed.
 */
onmapchanged: Windows$Foundation$Collections$MapChangedEventHandler<string, any>;
addEventListener(
type: "mapchanged",
listener: Windows$Foundation$Collections$MapChangedEventHandler<string, any>): void;
removeEventListener(
type: "mapchanged",
listener: Windows$Foundation$Collections$MapChangedEventHandler<string, any>): void;

/**
 * Removes a specific item from the ValueSet .
 * @param key The key of the item to remove.
 * @return true if the item was removed, otherwise false.
 */
remove(key: string): boolean;

/**
 * Removes an item from the value set.
 * @param key The key.
 */
remove(key: string): void;

/**
 * Gets the number of items contained in the value set.
 */
size: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Exposes an iterator that supports simple iteration over a collection of a specified type.
 */
declare interface Windows$Foundation$Collections$IIterable<T> {

/**
 * Returns an iterator for the items in the collection.
 * @return The iterator.
 */
first(): Windows$Foundation$Collections$IIterator<T>
} 


/**
 * Represents an immutable view into a map.
 */
declare type Windows$Foundation$Collections$IMapView<K, V> = {

/**
 * Determines whether the map view contains the specified key.
 * @param key The key to locate in the map view.
 * @return True if the key is found; otherwise, false.
 */
hasKey(key: K): boolean,

/**
 * Returns the item at the specified key in the map view.
 * @param key The key to locate in the map view.
 * @return The item associated with the specified key.
 */
lookup(key: K): V,

/**
 * Splits the map view into two views.
 */
split(
): {
first: Windows$Foundation$Collections$IMapView<K, V>,
second: Windows$Foundation$Collections$IMapView<K, V>
},

/**
 * Gets the number of elements in the map.
 */
size: number
} & Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>



/**
 * Represents a collection of key-value pairs, correlating several other collection interfaces.
 */
declare type Windows$Foundation$Collections$IPropertySet = {} & Windows$Foundation$Collections$IObservableMap<string, any> & Windows$Foundation$Collections$IMap<string, any> & Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>



/**
 * Represents an associative collection, also known as a map or a dictionary.
 */
declare type Windows$Foundation$Collections$IMap<K, V> = {

/**
 * Removes all items from the map.
 */
clear(): void,

/**
 * Returns an immutable view of the map.
 * @return The view of the map.
 */
getView(): Windows$Foundation$Collections$IMapView<K, V>,

/**
 * Determines whether the map contains the specified key.
 * @param key The key associated with the item to locate.
 * @return True if the key is found; otherwise, false.
 */
hasKey(key: K): boolean,

/**
 * Inserts or replaces an item in the map.
 * @param key The key associated with the item to insert.
 * @param value The item to insert.
 * @return True if an item with the specified key is an existing item that was replaced; otherwise, false.
 */
insert(key: K, value: V): boolean,

/**
 * Returns the item at the specified key in the map.
 * @param key The key associated with the item to locate.
 * @return The item associated with the specified key.
 */
lookup(key: K): V,

/**
 * Removes an item from the map.
 * @param key The key associated with the item to remove.
 */
remove(key: K): void,

/**
 * Gets the number of items in the map.
 */
size: number
} & Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>



/**
 * Supports simple iteration over a collection.
 */
declare interface Windows$Foundation$Collections$IIterator<T> {

/**
 * Retrieves all items in the collection.
 */
getMany(): {
items: T,
returnValue: number
},

/**
 * Advances the iterator to the next item in the collection.
 * @return True if the iterator refers to a valid item in the collection; false if the iterator passes the end of the collection.
 */
moveNext(): boolean,

/**
 * Gets the current item in the collection.
 */
current: T,

/**
 * Gets a value that indicates whether the iterator refers to a current item or is at the end of the collection.
 */
hasCurrent: boolean
} 


/**
 * Represents a key-value pair. This is typically used as a constraint type when you need to encapsulate two type parameters into one to satisfy the constraints of another generic interface.
 */
declare interface Windows$Foundation$Collections$IKeyValuePair<K, V> {

/**
 * Gets the key of the key-value pair.
 */
key: K,

/**
 * Gets the value of the key-value pair.
 */
value: V
} 


/**
 * Notifies listeners of dynamic changes to a map, such as when items are added or removed.
 */
declare type Windows$Foundation$Collections$IObservableMap<K, V> = {} & Windows$Foundation$Collections$IMap<K, V> & Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>



/**
 * Represents the method that handles the changed event of an observable map.
 */
declare type Windows$Foundation$Collections$MapChangedEventHandler<K, V> = (
ev: Windows$Foundation$Collections$IMapChangedEventArgs<K> & Windows$WinRTEvent<Windows$Foundation$Collections$IObservableMap<K, V>>) => void;


/**
 * Notifies listeners of changes to the vector.
 */
declare type Windows$Foundation$Collections$IObservableVector<T> = {} & Windows$Foundation$Collections$IVector<T> & Windows$Foundation$Collections$IIterable<T>



/**
 * Provides data for the changed event of a vector.
 */
declare interface Windows$Foundation$Collections$IVectorChangedEventArgs {

/**
 * Gets the type of change that occurred in the vector.
 */
collectionChange: $Values<typeof Windows$Foundation$Collections$CollectionChange>,

/**
 * Gets the position where the change occurred in the vector.
 */
index: number
} 


/**
 * Provides data for the changed event of a map collection.
 */
declare interface Windows$Foundation$Collections$IMapChangedEventArgs<K> {

/**
 * Gets the type of change that occurred in the map.
 */
collectionChange: $Values<typeof Windows$Foundation$Collections$CollectionChange>,

/**
 * Gets the key of the item that changed.
 */
key: K
} 


/**
 * Specifies the status of an asynchronous operation.
 */

declare  var Windows$Foundation$AsyncStatus: {|
  +canceled: 0,// 0
+completed: 1,// 1
+error: 2,// 2
+started: 3,// 3

|};



/**
 * Stores a DeferralCompletedHandler to be invoked upon completion of the deferral and manipulates the state of the deferral.
 */
declare class Windows$Foundation$Deferral  {

/**
 * Initializes a new Deferral object and specifies a DeferralCompletedHandler to be called upon completion of the deferral.
 * @param handler A DeferralCompletedHandler to be called upon completion of the deferral.
 */
constructor(handler: Windows$Foundation$DeferralCompletedHandler): this;

/**
 * If the DeferralCompletedHandler has not yet been invoked, this will call it and drop the reference to the delegate.
 */
close(): void;

/**
 * If the DeferralCompletedHandler has not yet been invoked, this will call it and drop the reference to the delegate.
 */
complete(): void
}


      declare var npm$namespace$Windows$Foundation$Diagnostics: {
        
        
        CausalityRelation: typeof Windows$Foundation$Diagnostics$CausalityRelation,
CausalitySource: typeof Windows$Foundation$Diagnostics$CausalitySource,
CausalitySynchronousWork: typeof Windows$Foundation$Diagnostics$CausalitySynchronousWork,
CausalityTraceLevel: typeof Windows$Foundation$Diagnostics$CausalityTraceLevel,
ErrorOptions: typeof Windows$Foundation$Diagnostics$ErrorOptions,
LoggingFieldFormat: typeof Windows$Foundation$Diagnostics$LoggingFieldFormat,
LoggingLevel: typeof Windows$Foundation$Diagnostics$LoggingLevel,
LoggingOpcode: typeof Windows$Foundation$Diagnostics$LoggingOpcode,
        AsyncCausalityTracer: typeof Windows$Foundation$Diagnostics$AsyncCausalityTracer,
ErrorDetails: typeof Windows$Foundation$Diagnostics$ErrorDetails,
FileLoggingSession: typeof Windows$Foundation$Diagnostics$FileLoggingSession,
LogFileGeneratedEventArgs: typeof Windows$Foundation$Diagnostics$LogFileGeneratedEventArgs,
LoggingActivity: typeof Windows$Foundation$Diagnostics$LoggingActivity,
LoggingChannel: typeof Windows$Foundation$Diagnostics$LoggingChannel,
LoggingChannelOptions: typeof Windows$Foundation$Diagnostics$LoggingChannelOptions,
LoggingFields: typeof Windows$Foundation$Diagnostics$LoggingFields,
LoggingOptions: typeof Windows$Foundation$Diagnostics$LoggingOptions,
LoggingSession: typeof Windows$Foundation$Diagnostics$LoggingSession,
RuntimeBrokerErrorSettings: typeof Windows$Foundation$Diagnostics$RuntimeBrokerErrorSettings,
TracingStatusChangedEventArgs: typeof Windows$Foundation$Diagnostics$TracingStatusChangedEventArgs,
        
      }

/**
 * Enables tracing control flow across asynchronous operations.
 */
declare class Windows$Foundation$Diagnostics$AsyncCausalityTracer  {

/**
 * Raised when a client starts listening to the causality trace.
 */
static ontracingstatuschanged: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "tracingstatuschanged",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "tracingstatuschanged",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Indicates that a previously created asynchronous operation has completed all of its asynchronous work.
 * @param traceLevel The trace level.
 * @param source The trace source.
 * @param platformId Identifier for the operation type.
 * @param operationId The identifier for the asynchronous operation that's unique within the platform for the operation's lifetime.
 * @param status The completion status of the asynchronous operation.
 */
static traceOperationCompletion(
traceLevel: $Values<typeof Windows$Foundation$Diagnostics$CausalityTraceLevel>,
source: $Values<typeof Windows$Foundation$Diagnostics$CausalitySource>,
platformId: string,
operationId: number,
status: $Values<typeof Windows$Foundation$AsyncStatus>): void;

/**
 * Logs the creation of an asynchronous operation.
 * @param traceLevel The trace level.
 * @param source The trace source.
 * @param platformId Identifier for the operation type.
 * @param operationId An identifier for the asynchronous operation that's unique within the platform for the operation's lifetime.
 * @param operationName A human-readable description of the asynchronous work.
 * @param relatedContext Additional information related to this operation.
 */
static traceOperationCreation(
traceLevel: $Values<typeof Windows$Foundation$Diagnostics$CausalityTraceLevel>,
source: $Values<typeof Windows$Foundation$Diagnostics$CausalitySource>,
platformId: string,
operationId: number,
operationName: string,
relatedContext: number): void;

/**
 * Logs the relation between the currently running synchronous work item and a specific asynchronous operation that it's related to.
 * @param traceLevel The trace level.
 * @param source The trace source.
 * @param platformId Identifier for the operation type.
 * @param operationId The identifier for the asynchronous operation that's unique within the platform for the operation's lifetime.
 * @param relation The relationship between the synchronous work item and asynchronous operation identified by operationId.
 */
static traceOperationRelation(
traceLevel: $Values<typeof Windows$Foundation$Diagnostics$CausalityTraceLevel>,
source: $Values<typeof Windows$Foundation$Diagnostics$CausalitySource>,
platformId: string,
operationId: number,
relation: $Values<typeof Windows$Foundation$Diagnostics$CausalityRelation>): void;

/**
 * Indicates that the most recently created synchronous work item running on the thread that the TraceSynchronousWorkCompletion method is called on has completed.
 * @param traceLevel The trace level.
 * @param source The trace source.
 * @param work Indicates the type of completion.
 */
static traceSynchronousWorkCompletion(
traceLevel: $Values<typeof Windows$Foundation$Diagnostics$CausalityTraceLevel>,
source: $Values<typeof Windows$Foundation$Diagnostics$CausalitySource>,
work: $Values<typeof Windows$Foundation$Diagnostics$CausalitySynchronousWork>): void;

/**
 * Indicates that the specified asynchronous operation is scheduling synchronous work on the thread that the TraceSynchronousWorkStart method is called on.
 * @param traceLevel The trace level.
 * @param source The trace source.
 * @param platformId Identifier for the operation type.
 * @param operationId The identifier for the asynchronous operation that's unique within the platform for the operation's lifetime.
 * @param work The relationship between the work item and the asynchronous operation.
 */
static traceSynchronousWorkStart(
traceLevel: $Values<typeof Windows$Foundation$Diagnostics$CausalityTraceLevel>,
source: $Values<typeof Windows$Foundation$Diagnostics$CausalitySource>,
platformId: string,
operationId: number,
work: $Values<typeof Windows$Foundation$Diagnostics$CausalitySynchronousWork>): void;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Tracks ways that synchronous work items may interact with asynchronous operations.
 */

declare  var Windows$Foundation$Diagnostics$CausalityRelation: {|
  +assignDelegate: 0,// 0
+join: 1,// 1
+choice: 2,// 2
+cancel: 3,// 3
+error: 4,// 4

|};



/**
 * Provides flags that listeners use to filter tracing events.
 */

declare  var Windows$Foundation$Diagnostics$CausalitySource: {|
  +application: 0,// 0
+library: 1,// 1
+system: 2,// 2

|};



/**
 * Indicates the relationship between a work item and an asynchronous operation.
 */

declare  var Windows$Foundation$Diagnostics$CausalitySynchronousWork: {|
  +completionNotification: 0,// 0
+progressNotification: 1,// 1
+execution: 2,// 2

|};



/**
 * Specifies a logging level that listeners can use for trace filtering.
 */

declare  var Windows$Foundation$Diagnostics$CausalityTraceLevel: {|
  +required: 0,// 0
+important: 1,// 1
+verbose: 2,// 2

|};



/**
 * Provides information about an error that occurred.
 */
declare class Windows$Foundation$Diagnostics$ErrorDetails  {

/**
 * Asynchronously creates an ErrorDetails object based on an HRESULT error code.
 * @param errorCode The unique code representing the error.
 * @return The newly created ErrorDetails object representing the error.
 */
static createFromHResultAsync(
errorCode: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Diagnostics$ErrorDetails>;

/**
 * Gets a short description of the error.
 */
description: string;

/**
 * Gets the address to a help page about the error.
 */
helpUri: Windows$Foundation$Uri;

/**
 * Gets a detailed description of the error.
 */
longDescription: string
}


/**
 * Specifies the type of diagnostic error reporting for a thread.
 */

declare  var Windows$Foundation$Diagnostics$ErrorOptions: {|
  +none: 0,// 0
+suppressExceptions: 1,// 1
+forceExceptions: 2,// 2
+useSetErrorInfo: 3,// 3
+suppressSetErrorInfo: 4,// 4

|};



/**
 * Represents the destination of logged messages from LoggingChannel instances.
 */
declare class Windows$Foundation$Diagnostics$FileLoggingSession  {

/**
 * Initializes a new instance of the FileLoggingSession class.
 * @param name The name of the logging session.
 */
constructor(name: string): this;

/**
 * Adds a logging channel to the current logging session. The logging channel only accepts events that have a logging level at or above the specified logging level.
 * @param loggingChannel The logging channel to add.
 * @param maxLevel The minimum logging level that an event must have to be accepted by the session.
 */
addLoggingChannel(
loggingChannel: Windows$Foundation$Diagnostics$ILoggingChannel,
maxLevel: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>): void;

/**
 * Adds a logging channel to the current logging session.
 * @param loggingChannel The logging channel to add.
 */
addLoggingChannel(loggingChannel: Windows$Foundation$Diagnostics$ILoggingChannel): void;

/**
 * Ends the current logging session.
 */
close(): void;

/**
 * Ends the current logging session and saves it to a file.
 * @return When this method completes, it returns the new file as a StorageFile . Returns NULL if there are no events in the session or if logging has just rolled over into a new file that doesn't contain events yet.
 */
closeAndSaveToFileAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Gets the name of the logging session.
 */
name: string;

/**
 * Raised when a log file is saved.
 */
onlogfilegenerated: Windows$Foundation$TypedEventHandler<Windows$Foundation$Diagnostics$IFileLoggingSession, Windows$Foundation$Diagnostics$LogFileGeneratedEventArgs>;
addEventListener(
type: "logfilegenerated",
listener: Windows$Foundation$TypedEventHandler<Windows$Foundation$Diagnostics$IFileLoggingSession, Windows$Foundation$Diagnostics$LogFileGeneratedEventArgs>): void;
removeEventListener(
type: "logfilegenerated",
listener: Windows$Foundation$TypedEventHandler<Windows$Foundation$Diagnostics$IFileLoggingSession, Windows$Foundation$Diagnostics$LogFileGeneratedEventArgs>): void;

/**
 * Removes the specified logging channel from the current logging session.
 * @param loggingChannel The logging channel to remove.
 */
removeLoggingChannel(loggingChannel: Windows$Foundation$Diagnostics$ILoggingChannel): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the LogFileGenerated event.
 */
declare class Windows$Foundation$Diagnostics$LogFileGeneratedEventArgs  {

/**
 * Gets the log file.
 */
file: Windows$Storage$StorageFile
}


/**
 * Creates Event Tracing for Windows (ETW) events that mark the start and end of a group of related events.
 */
declare class Windows$Foundation$Diagnostics$LoggingActivity  {

/**
 * Initializes a new instance of the LoggingActivity class for the specified LoggingChannel and LoggingLevel in Windows 8.1 compatibility mode.
 * @param activityName The name of the logging activity.
 * @param loggingChannel The logging channel.
 * @param level The logging level.
 */
constructor(activityName: string, loggingChannel: Windows$Foundation$Diagnostics$ILoggingChannel, level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>): this;

/**
 * Initializes a new instance of the LoggingActivity class for the specified LoggingChannel in Windows 8.1 compatibility mode.
 * @param activityName The name of the logging activity.
 * @param loggingChannel The logging channel.
 */
constructor(activityName: string, loggingChannel: Windows$Foundation$Diagnostics$ILoggingChannel): this;

/**
 * Returns the channel associated with this activity.
 */
channel: Windows$Foundation$Diagnostics$LoggingChannel;

/**
 * Ends the current logging activity.
 */
close(): void;

/**
 * Gets the identifier for the current logging activity.
 */
id: string;

/**
 * Indicates whether at least one session is listening for events with the specified level and keywords from the channel associated with this activity.
 * @param level The event severity level.
 * @param keywords The keywords. Each bit of the keywords value represents an event category.
 * @return Returns true if at least one session is listening for events with the specified level and keywords from the channel associated with this activity, and otherwise false.
 */
isEnabled(
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>,
keywords: number): boolean;

/**
 * Indicates whether at least one session is listening for events from the channel associated with this activity.
 * @return Returns true if at least one session is listening for events from the channel associated with this activity, and otherwise false.
 */
isEnabled(): boolean;

/**
 * Indicates whether at least one session is listening for events with the specified event severity level from the channel associated with this activity.
 * @param level The event severity level.
 * @return Returns true if at least one session is listening for events with the specified level from the channel associated with this activity, and otherwise false.
 */
isEnabled(level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>): boolean;

/**
 * Logs an event with the specified name.
 * @param eventName The name for this event.
 */
logEvent(eventName: string): void;

/**
 * Logs an event with the specified name, fields, and level.
 * @param eventName The name for this event.
 * @param fields The fields for this event. May be null.
 * @param level The severity level for this event.
 */
logEvent(
eventName: string,
fields: Windows$Foundation$Diagnostics$LoggingFields,
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>): void;

/**
 * Logs an event with the specified name and fields.
 * @param eventName The name for this event.
 * @param fields The fields for this event. May be null.
 */
logEvent(eventName: string, fields: Windows$Foundation$Diagnostics$LoggingFields): void;

/**
 * Logs an event with the specified name, fields, level, and options.
 * @param eventName The name for this event.
 * @param fields The fields for this event. May be null.
 * @param level The severity level for this event.
 * @param options The options for this event. Pass null to use the default options. The options are for advanced scenarios. The default values are designed to work well for most events.
 */
logEvent(
eventName: string,
fields: Windows$Foundation$Diagnostics$LoggingFields,
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>,
options: Windows$Foundation$Diagnostics$LoggingOptions): void;

/**
 * Gets the name of the current logging activity.
 */
name: string;

/**
 * Writes an activity start event with the specified fields and level and creates a LoggingActivity object.
 * @param startEventName The name for the start event.
 * @param fields The fields for this event. May be null .
 * @param level The level of detail for this event.
 * @return An object that represents the new activity.
 */
startActivity(
startEventName: string,
fields: Windows$Foundation$Diagnostics$LoggingFields,
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>): Windows$Foundation$Diagnostics$LoggingActivity;

/**
 * Writes an activity start event and creates a LoggingActivity object.
 * @param startEventName The name for the start event.
 * @return An object the represents the new activity.
 */
startActivity(startEventName: string): Windows$Foundation$Diagnostics$LoggingActivity;

/**
 * Writes an activity start event with fields and creates a LoggingActivity object.
 * @param startEventName The name for the start event.
 * @param fields The fields for this event.
 * @return An object that represents the new activity.
 */
startActivity(
startEventName: string,
fields: Windows$Foundation$Diagnostics$LoggingFields): Windows$Foundation$Diagnostics$LoggingActivity;

/**
 * Writes an activity start event with the specified fields, level, and options, and creates a LoggingActivity object.
 * @param startEventName The name for this event.
 * @param fields The fields for this event. May be null.
 * @param level The level of detail for this event.
 * @param options The options for this event. Pass null to use the default options. The options are for advanced scenarios. The default values are designed to work well for most events.
 * @return An object that represents the new activity.
 */
startActivity(
startEventName: string,
fields: Windows$Foundation$Diagnostics$LoggingFields,
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>,
options: Windows$Foundation$Diagnostics$LoggingOptions): Windows$Foundation$Diagnostics$LoggingActivity;

/**
 * Marks the activity as closed/disposed and generates a stop event with the specified event name, fields, and options.
 * @param stopEventName The name for the stop event.
 * @param fields The fields for this event. May be null.
 * @param options The options for this event. Pass null to use the default options. The options are for advanced scenarios. The default values are designed to work well for most events.
 */
stopActivity(
stopEventName: string,
fields: Windows$Foundation$Diagnostics$LoggingFields,
options: Windows$Foundation$Diagnostics$LoggingOptions): void;

/**
 * Marks the activity as closed/disposed and generates a stop event with the specified event name.
 * @param stopEventName The name for the stop event.
 */
stopActivity(stopEventName: string): void;

/**
 * Marks the activity as closed/disposed and generates a stop event with the specified event name and fields.
 * @param stopEventName The name for this event.
 * @param fields The fields for this event. May be null.
 */
stopActivity(
stopEventName: string,
fields: Windows$Foundation$Diagnostics$LoggingFields): void
}


/**
 * Represents a source of log messages.
 */
declare class Windows$Foundation$Diagnostics$LoggingChannel  {

/**
 * This constructor creates a LoggingChannel in Windows 8.1 compatibility mode.
 * @param name The name of the logging channel.
 */
constructor(name: string): this;

/**
 * Initializes a new instance of the LoggingChannel class with the specified options.
 * @param name The name of the logging channel.
 * @param options The channel options. Pass null to specify the default options.
 */
constructor(name: string, options: Windows$Foundation$Diagnostics$LoggingChannelOptions): this;

/**
 * Initializes a new instance of the LoggingChannel class with the specified options and channel ID.
 * @param name The name of the logging channel.
 * @param options The channel options. Pass null to specify the default options.
 * @param id The channel identifier to use instead of the automatically generated identifier.
 */
constructor(name: string, options: Windows$Foundation$Diagnostics$LoggingChannelOptions, id: string): this;

/**
 * Ends logging on the current logging channel.
 */
close(): void;

/**
 * Gets a value that indicates whether at least one session is logging events from this channel.
 */
enabled: boolean;

/**
 * Returns the provider identifier for this channel.
 */
id: string;

/**
 * Indicates whether at least one session is listening for events with the specified level and keywords from this channel.
 * @param level The event severity level.
 * @param keywords The keywords. Each bit of the keywords value represents an event category.
 * @return Returns true if at least one session is listening for events with the specified level and keywords from the channel, and otherwise false.
 */
isEnabled(
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>,
keywords: number): boolean;

/**
 * Indicates whether at least one session is listening for events from the channel.
 * @return Returns true if at least one session is listening for events from the channel, and otherwise false.
 */
isEnabled(): boolean;

/**
 * Indicates whether at least one session is listening for events with the specified event severity level from the channel.
 * @param level The event severity level.
 * @return Returns true if at least one session is listening for events with the specified level from the channel, and otherwise false.
 */
isEnabled(level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>): boolean;

/**
 * Gets the minimum level at which any session is listening to events from this channel.
 */
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>;

/**
 * Logs an event with the specified name.
 * @param eventName The name for this event.
 */
logEvent(eventName: string): void;

/**
 * Logs an event with the specified name, fields, and level.
 * @param eventName The name for this event.
 * @param fields The fields for this event. May be null.
 * @param level The level of detail for this event.
 */
logEvent(
eventName: string,
fields: Windows$Foundation$Diagnostics$LoggingFields,
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>): void;

/**
 * Logs an event with the specified name and fields.
 * @param eventName The name for this event.
 * @param fields The fields for this event. May be null.
 */
logEvent(eventName: string, fields: Windows$Foundation$Diagnostics$LoggingFields): void;

/**
 * Logs an event with the specified name, fields, level, and options.
 * @param eventName The name for this event.
 * @param fields The fields for this event. May be null.
 * @param level The level of detail for this event.
 * @param options The options for this event. Pass null to use the default options. The options are for advanced scenarios. The default values are designed to work well for most events.
 */
logEvent(
eventName: string,
fields: Windows$Foundation$Diagnostics$LoggingFields,
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>,
options: Windows$Foundation$Diagnostics$LoggingOptions): void;

/**
 * Logs a message to the current LoggingChannel .
 * @param eventString The message to log.
 */
logMessage(eventString: string): void;

/**
 * Logs a message to the current LoggingChannel with the specified LoggingLevel .
 * @param eventString The message to log.
 * @param level The logging level.
 */
logMessage(
eventString: string,
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>): void;

/**
 * Logs data to the current LoggingChannel with the specified LoggingLevel .
 * @param value1 The string to associate with value2.
 * @param value2 The value to associate with value1.
 * @param level The logging level.
 */
logValuePair(
value1: string,
value2: number,
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>): void;

/**
 * Logs data to the current LoggingChannel .
 * @param value1 The string to associate with value2.
 * @param value2 The value to associate with value1.
 */
logValuePair(value1: string, value2: number): void;

/**
 * Gets the name of the current LoggingChannel .
 */
name: string;

/**
 * Raised when the logging channel is attached to a LoggingSession or other event tracing and debugging tools.
 */
onloggingenabled: Windows$Foundation$TypedEventHandler<Windows$Foundation$Diagnostics$ILoggingChannel, any>;
addEventListener(
type: "loggingenabled",
listener: Windows$Foundation$TypedEventHandler<Windows$Foundation$Diagnostics$ILoggingChannel, any>): void;
removeEventListener(
type: "loggingenabled",
listener: Windows$Foundation$TypedEventHandler<Windows$Foundation$Diagnostics$ILoggingChannel, any>): void;

/**
 * Writes an activity start event with the specified fields and level, and creates a LoggingActivity object.
 * @param startEventName The name for this event.
 * @param fields The fields for this event. May be null .
 * @param level The level of detail for this event.
 * @return Returns an object that represents the new activity.
 */
startActivity(
startEventName: string,
fields: Windows$Foundation$Diagnostics$LoggingFields,
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>): Windows$Foundation$Diagnostics$LoggingActivity;

/**
 * Writes an activity start event and creates a LoggingActivity object.
 * @param startEventName The name for this event.
 * @return Returns an object that represents the new activity.
 */
startActivity(startEventName: string): Windows$Foundation$Diagnostics$LoggingActivity;

/**
 * Writes an activity start event with the specified fields and creates a LoggingActivity object.
 * @param startEventName The name for this event.
 * @param fields The fields for this event.
 * @return Returns an object that represents the new activity.
 */
startActivity(
startEventName: string,
fields: Windows$Foundation$Diagnostics$LoggingFields): Windows$Foundation$Diagnostics$LoggingActivity;

/**
 * Writes an activity start event with the specified fields, level, and options, and creates a LoggingActivity object.
 * @param startEventName The name for this event.
 * @param fields The fields for this event. May be null.
 * @param level The level of detail for this event.
 * @param options The options for this event. Pass null to use the default options. The options are for advanced scenarios. The default values are designed to work well for most events.
 * @return Returns an object that represents the new activity.
 */
startActivity(
startEventName: string,
fields: Windows$Foundation$Diagnostics$LoggingFields,
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>,
options: Windows$Foundation$Diagnostics$LoggingOptions): Windows$Foundation$Diagnostics$LoggingActivity;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents advanced settings that you can use to configure a LoggingChannel object.
 */
declare class Windows$Foundation$Diagnostics$LoggingChannelOptions  {

/**
 * Creates a LoggingChannelOptions object with all options set to default values.
 */
constructor(): this;

/**
 * Creates a LoggingChannelOptions object with all properties set to default values except for the specified group.
 * @param group The group identifier.
 */
constructor(group: string): this;

/**
 * Gets or sets the channel group identifier.
 */
group: string
}


/**
 * Specifies the format of an event field.
 */

declare  var Windows$Foundation$Diagnostics$LoggingFieldFormat: {|
  +default: 0,// 0
+hidden: 1,// 1
+string: 2,// 2
+boolean: 3,// 3
+hexadecimal: 4,// 4
+processId: 5,// 5
+threadId: 6,// 6
+port: 7,// 7
+ipv4Address: 8,// 8
+ipv6Address: 9,// 9
+socketAddress: 10,// 10
+xml: 11,// 11
+json: 12,// 12
+win32Error: 13,// 13
+ntStatus: 14,// 14
+hresult: 15,// 15
+fileTime: 16,// 16
+signed: 17,// 17
+unsigned: 18,// 18

|};



/**
 * Represents a sequence of event fields and provides methods for adding fields to the sequence.
 */
declare class Windows$Foundation$Diagnostics$LoggingFields  {

/**
 * Initializes a new LoggingFields instance.
 */
constructor(): this;

/**
 * Adds a boolean field with the specified field name, format, and tags.
 * @param name The name of the event field.
 * @param value The value of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addBoolean(
name: string,
value: boolean,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a boolean field with the specified field name and format.
 * @param name The name of the event field.
 * @param value The value of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addBoolean(
name: string,
value: boolean,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a boolean field with the specified field name.
 * @param name Name of the event field.
 * @param value Value of the event field.
 */
addBoolean(name: string, value: boolean): void;

/**
 * Adds a boolean array field with the specified field name.
 * @param name The name of the event field.
 * @param value The array values for the event field.
 */
addBooleanArray(name: string, value: boolean[]): void;

/**
 * Adds a boolean array field with the specified field name and format.
 * @param name The name of the event field.
 * @param value The array of values for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addBooleanArray(
name: string,
value: boolean[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a boolean array field with the specified field name, format, and tag.
 * @param name The name of the event field.
 * @param value The array of values for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addBooleanArray(
name: string,
value: boolean[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 16-bit character field with the specified field name.
 * @param name The name of the event field.
 * @param value The value of the event field.
 */
addChar16(name: string, value: string): void;

/**
 * Adds a 16-bit character field with the specified field name and format.
 * @param name The name of the event field.
 * @param value The value of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addChar16(
name: string,
value: string,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a 16-bit character field with the specified field name, format, and tag.
 * @param name The name of the event field.
 * @param value The value of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addChar16(
name: string,
value: string,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 16-bit character array field with the specified field name.
 * @param name The name of the event field.
 * @param value The array of values for the event field.
 */
addChar16Array(name: string, value: string[]): void;

/**
 * Adds a 16-bit character array field with the specified field name and format, and tags.
 * @param name The name of the event field.
 * @param value The array of values for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addChar16Array(
name: string,
value: string[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 16-bit character array field with the specified field name and format.
 * @param name The name of the event field.
 * @param value The array of values for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addChar16Array(
name: string,
value: string[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a DateTime field with the specified field name.
 * @param name The name of the event field.
 * @param value The value of the event field.
 */
addDateTime(name: string, value: Date): void;

/**
 * Adds a DateTime field with the specified field name, format, and tags.
 * @param name The name of the event field.
 * @param value The value of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addDateTime(
name: string,
value: Date,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a DateTime field with the specified field name and format.
 * @param name The name of the event field.
 * @param value The value of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addDateTime(
name: string,
value: Date,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a DateTime array field with the specified field name, format, and tags.
 * @param name The name of the event field.
 * @param value The array of values for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addDateTimeArray(
name: string,
value: Date[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a DateTime array field with the specified field name and format.
 * @param name The name of the event field.
 * @param value The array of values for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addDateTimeArray(
name: string,
value: Date[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a DateTime array field with the specified field name.
 * @param name The name of the event field.
 * @param value The array of values for the event field.
 */
addDateTimeArray(name: string, value: Date[]): void;

/**
 * Adds a Double field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value Value of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addDouble(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a Double field with the specified field name and format.
 * @param name Name of the event field.
 * @param value Value of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addDouble(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a Double field with the specified field name.
 * @param name Name of the event field.
 * @param value Value of the event field.
 */
addDouble(name: string, value: number): void;

/**
 * Adds a Double array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The array of values for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addDoubleArray(
name: string,
value: Float64Array,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a Double array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The array of values for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addDoubleArray(
name: string,
value: Float64Array,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a Double array field with the specified field name.
 * @param name Name of the event field.
 * @param value The array of values for the event field.
 */
addDoubleArray(name: string, value: Float64Array): void;

/**
 * Adds an empty field.
 * @param name Name of the event field.
 */
addEmpty(name: string): void;

/**
 * Adds an empty field.
 * @param name Name of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addEmpty(
name: string,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds an empty field.
 * @param name Name of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addEmpty(
name: string,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a GUID field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value Value of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addGuid(
name: string,
value: string,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a GUID field with the specified field name and format.
 * @param name Name of the event field.
 * @param value Value of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addGuid(
name: string,
value: string,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a GUID field with the specified field name.
 * @param name Name of the event field.
 * @param value Value of the event field.
 */
addGuid(name: string, value: string): void;

/**
 * Adds a GUID array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The array values for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addGuidArray(
name: string,
value: string[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a GUID array field with the specified field name and format
 * @param name Name of the event field.
 * @param value The array values for the event field.
 * @param format The format of the event field.
 */
addGuidArray(
name: string,
value: string[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a GUID array field with the specified field name.
 * @param name Name of the event field.
 * @param value The array values for the event field.
 */
addGuidArray(name: string, value: string[]): void;

/**
 * Adds a 16-bit integer field with the specified field name and format.
 * @param name Name of the event field.
 * @param value Value of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addInt16(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a 16-bit integer field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value Value of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addInt16(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 16-bit integer field with the specified field name.
 * @param name Name of the event field.
 * @param value Value of the event field.
 */
addInt16(name: string, value: number): void;

/**
 * Adds a 16-bit integer array field with the specified field name.
 * @param name Name of the event field.
 * @param value Value of the event field.
 */
addInt16Array(name: string, value: Int16Array): void;

/**
 * Adds a 16-bit integer array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value Value of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addInt16Array(
name: string,
value: Int16Array,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a 16-bit integer array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value Value of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addInt16Array(
name: string,
value: Int16Array,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 32-bit integer array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The array values for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addInt32(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 32-bit integer array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value Value of the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addInt32(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a 32-bit integer array field with the specified field name.
 * @param name Name of the event field.
 * @param value Value of the event field.
 */
addInt32(name: string, value: number): void;

/**
 * Adds a 32-bit integer array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The array values for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addInt32Array(
name: string,
value: Int32Array,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a 32-bit integer array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The array values for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addInt32Array(
name: string,
value: Int32Array,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 32-bit integer array field with the specified field name.
 * @param name Name of the event field.
 * @param value The array values for the event field.
 */
addInt32Array(name: string, value: Int32Array): void;

/**
 * Adds a 64-bit integer array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The array values for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addInt64(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a 64-bit integer field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addInt64(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 64-bit integer array field with the specified field name.
 * @param name Name of the event field.
 * @param value The array values for the event field.
 */
addInt64(name: string, value: number): void;

/**
 * Adds a 64-bit integer array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The array values for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addInt64Array(
name: string,
value: number[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 64-bit integer array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The array values for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addInt64Array(
name: string,
value: number[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a 64-bit integer array field with the specified field name.
 * @param name Name of the event field.
 * @param value The array values for the event field.
 */
addInt64Array(name: string, value: number[]): void;

/**
 * Adds a Point field with the specified name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addPoint(name: string, value: Windows$Foundation$Point): void;

/**
 * Adds a Point field with the specified name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addPoint(
name: string,
value: Windows$Foundation$Point,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a Point field with the specified name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addPoint(
name: string,
value: Windows$Foundation$Point,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a Point array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addPointArray(
name: string,
value: Windows$Foundation$Point,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a Point array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addPointArray(
name: string,
value: Windows$Foundation$Point,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a Point array field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addPointArray(name: string, value: Windows$Foundation$Point): void;

/**
 * Adds a Rect field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addRect(
name: string,
value: Windows$Foundation$Rect,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a Rect field with the specified field name, and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addRect(
name: string,
value: Windows$Foundation$Rect,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a Rect field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addRect(name: string, value: Windows$Foundation$Rect): void;

/**
 * Adds a Rect array field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addRectArray(name: string, value: Windows$Foundation$Rect): void;

/**
 * Adds a Rect array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The value for the event field.
 */
addRectArray(
name: string,
value: Windows$Foundation$Rect,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a Rect array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addRectArray(
name: string,
value: Windows$Foundation$Rect,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a Single field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addSingle(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a Single field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addSingle(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a Single field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addSingle(name: string, value: number): void;

/**
 * Adds a Single array field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addSingleArray(name: string, value: Float32Array): void;

/**
 * Adds a Single array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addSingleArray(
name: string,
value: Float32Array,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a Single array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addSingleArray(
name: string,
value: Float32Array,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a Size field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addSize(name: string, value: Windows$Foundation$Size): void;

/**
 * Adds a Size field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addSize(
name: string,
value: Windows$Foundation$Size,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a Size field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addSize(
name: string,
value: Windows$Foundation$Size,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a Size array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addSizeArray(
name: string,
value: Windows$Foundation$Size,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a Size array field with the specified field name.
 * @param name The name of the field.
 * @param value The value for the event field.
 */
addSizeArray(name: string, value: Windows$Foundation$Size): void;

/**
 * Adds a Size array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addSizeArray(
name: string,
value: Windows$Foundation$Size,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a String field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addString(name: string, value: string): void;

/**
 * Adds a String field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addString(
name: string,
value: string,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a String field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addString(
name: string,
value: string,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a String array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addStringArray(
name: string,
value: string[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a String array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addStringArray(
name: string,
value: string[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a String array field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addStringArray(name: string, value: string[]): void;

/**
 * Adds a time span field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addTimeSpan(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a time span field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addTimeSpan(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a time span field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addTimeSpan(name: string, value: number): void;

/**
 * Adds a time span array field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addTimeSpanArray(name: string, value: number[]): void;

/**
 * Adds a time span array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addTimeSpanArray(
name: string,
value: number[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a time span array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addTimeSpanArray(
name: string,
value: number[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 16-bit unsigned integer field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addUInt16(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 16-bit unsigned integer field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addUInt16(name: string, value: number): void;

/**
 * Adds a 16-bit unsigned integer field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addUInt16(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a16-bit unsigned integer field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field. The default format for the array is binary. See the remarks section for other formats that may be specified.
 */
addUInt16Array(name: string, value: Uint16Array): void;

/**
 * Adds a 16-bit unsigned integer array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field. The default format for the array is binary. See the remarks section for other formats that may be specified.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addUInt16Array(
name: string,
value: Uint16Array,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 16-bit unsigned integer array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field. The default format for the array is binary. See the remarks section for other formats that may be specified.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addUInt16Array(
name: string,
value: Uint16Array,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a 32-bit unsigned integer field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addUInt32(name: string, value: number): void;

/**
 * Adds a 32-bit unsigned integer field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addUInt32(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 32-bit unsigned integer field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addUInt32(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a 32-bit unsigned integer array field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addUInt32Array(name: string, value: Uint32Array): void;

/**
 * Adds a 32-bit unsigned integer array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addUInt32Array(
name: string,
value: Uint32Array,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 32-bit unsigned integer array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addUInt32Array(
name: string,
value: Uint32Array,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a 64-bit unsigned integer field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addUInt64(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds a 64-bit unsigned integer field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addUInt64(name: string, value: number): void;

/**
 * Adds a 64-bit unsigned integer field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addUInt64(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 64-bit unsigned integer array field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addUInt64Array(name: string, value: number[]): void;

/**
 * Adds a 64-bit unsigned integer array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addUInt64Array(
name: string,
value: number[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds a 64-bit unsigned integer array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addUInt64Array(
name: string,
value: number[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds an 8-bit unsigned integer field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field.
 */
addUInt8(name: string, value: number): void;

/**
 * Adds an 8-bit unsigned integer field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addUInt8(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Adds an 8-bit unsigned integer field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addUInt8(
name: string,
value: number,
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds an 8-bit unsigned integer array field with the specified field name.
 * @param name Name of the event field.
 * @param value The value for the event field. The format for the array is binary.
 */
addUInt8Array(name: string, value: number[]): void;

/**
 * Adds an 8-bit unsigned integer array field with the specified field name and format.
 * @param name Name of the event field.
 * @param value The value for the event field. The default format for the array is binary. See the remarks section for other formats that may be specified.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 */
addUInt8Array(
name: string,
value: number[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>): void;

/**
 * Adds an 8-bit unsigned integer array field with the specified field name, format, and tags.
 * @param name Name of the event field.
 * @param value The value for the event field. The default format for the array is binary. See the remarks section for other formats that may be specified.
 * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 */
addUInt8Array(
name: string,
value: number[],
format: $Values<typeof Windows$Foundation$Diagnostics$LoggingFieldFormat>,
tags: number): void;

/**
 * Begins a new structured field with the specified field name.
 * @param name Name of the structured field.
 */
beginStruct(name: string): void;

/**
 * Begins a new structured field with the specified field name and tags.
 * @param name Name of the structured field.
 * @param tags Specifies up to twenty-eight bits of user-defined field metadata. The top four bits are reserved and must be set to zero (0).
 */
beginStruct(name: string, tags: number): void;

/**
 * Removes all fields stored in the object and resets the object to its newly-constructed state.
 */
clear(): void;

/**
 * Ends a structured field.
 */
endStruct(): void
}


/**
 * Specifies the severity level of an event.
 */

declare  var Windows$Foundation$Diagnostics$LoggingLevel: {|
  +verbose: 0,// 0
+information: 1,// 1
+warning: 2,// 2
+error: 3,// 3
+critical: 4,// 4

|};



/**
 * Specifies an event opcode. Opcodes represent an operation within a component of an application and are used to logically group events.
 */

declare  var Windows$Foundation$Diagnostics$LoggingOpcode: {|
  +info: 0,// 0
+start: 1,// 1
+stop: 2,// 2
+reply: 3,// 3
+resume: 4,// 4
+suspend: 5,// 5
+send: 6,// 6

|};



/**
 * Represents advanced event settings.
 */
declare class Windows$Foundation$Diagnostics$LoggingOptions  {

/**
 * Initializes a new LoggingOptions instance with default option values.
 */
constructor(): this;

/**
 * Initializes a new LoggingOptions instance with the specified keyword value.
 * @param keywords The keyword value.
 */
constructor(keywords: number): this;

/**
 * Gets or sets the unique identifier associated with an activity.
 */
activityId: string;

/**
 * Gets or sets the keyword value that represents the different categories that an event belongs to.
 */
keywords: number;

/**
 * Gets or sets the operation code value for an event.
 */
opcode: $Values<typeof Windows$Foundation$Diagnostics$LoggingOpcode>;

/**
 * Gets or sets a value that uniquely identifies the parent activity to which this activity is related.
 */
relatedActivityId: string;

/**
 * Gets or sets the user-defined metadata value attached to an event.
 */
tags: number;

/**
 * Gets or sets the user-defined value that identifies a larger unit of work within an application or component.
 */
task: number
}


/**
 * Represents the destination of logged messages from LoggingChannel instances.
 */
declare class Windows$Foundation$Diagnostics$LoggingSession  {

/**
 * Initializes a new instance of the LoggingSession class.
 * @param name The name of the logging session.
 */
constructor(name: string): this;

/**
 * Adds a logging channel with the specified logging level to the current logging session.
 * @param loggingChannel The logging channel to add.
 * @param maxLevel The logging level for loggingChannel.
 */
addLoggingChannel(
loggingChannel: Windows$Foundation$Diagnostics$ILoggingChannel,
maxLevel: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>): void;

/**
 * Adds a logging channel to the current logging session.
 * @param loggingChannel The logging channel to add.
 */
addLoggingChannel(loggingChannel: Windows$Foundation$Diagnostics$ILoggingChannel): void;

/**
 * Ends the current logging session.
 */
close(): void;

/**
 * Gets the name of the logging session.
 */
name: string;

/**
 * Removes the specified logging channel from the current logging session.
 * @param loggingChannel The logging channel to remove.
 */
removeLoggingChannel(loggingChannel: Windows$Foundation$Diagnostics$ILoggingChannel): void;

/**
 * Saves the current logging session to a file.
 * @param folder The folder that contains the log file.
 * @param fileName The name of the log file.
 * @return When this method completes, it returns the new file as a StorageFile .
 */
saveToFileAsync(
folder: Windows$Storage$IStorageFolder,
fileName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>
}


/**
 * Represents diagnostic error reporting settings.
 */
declare class Windows$Foundation$Diagnostics$RuntimeBrokerErrorSettings  {

/**
 * Creates and initializes a new instance of the RuntimeBrokerErrorSettings .
 */
constructor(): this;

/**
 * Gets the type of error reporting for the error object.
 * @return One of the enumeration values.
 */
getErrorOptions(): $Values<typeof Windows$Foundation$Diagnostics$ErrorOptions>;

/**
 * Sets the type of error reporting for the error object.
 * @param value One of the enumeration values.
 */
setErrorOptions(value: $Values<typeof Windows$Foundation$Diagnostics$ErrorOptions>): void
}


/**
 * Provides data for the TracingStatusChanged event.
 */
declare class Windows$Foundation$Diagnostics$TracingStatusChangedEventArgs  {

/**
 * Gets a value that indicates whether tracing is active.
 */
enabled: boolean;

/**
 * Gets the trace level for the current tracing session.
 */
traceLevel: $Values<typeof Windows$Foundation$Diagnostics$CausalityTraceLevel>
}


/**
 * Represents a source of log messages.
 */
declare type Windows$Foundation$Diagnostics$ILoggingChannel = {

/**
 * Logs a message to the current LoggingChannel .
 * @param eventString The message to log.
 */
logMessage(eventString: string): void,

/**
 * Logs a message to the current LoggingChannel with the specified LoggingLevel .
 * @param eventString The message to log.
 * @param level The logging level.
 */
logMessage(
eventString: string,
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>): void,

/**
 * Logs data to the current LoggingChannel with the specified LoggingLevel .
 * @param value1 The string to associate with value2.
 * @param value2 The value to associate with value1.
 * @param level The logging level.
 */
logValuePair(
value1: string,
value2: number,
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>): void,

/**
 * Logs data to the current LoggingChannel .
 * @param value1 The string to associate with value2.
 * @param value2 The value to associate with value1.
 */
logValuePair(value1: string, value2: number): void,

/**
 * Gets a value that indicates whether messages are being logged on the current LoggingChannel .
 */
enabled: boolean,

/**
 * Gets the level of detail for messages from the current LoggingChannel .
 */
level: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>,

/**
 * Gets the name of the current LoggingChannel .
 */
name: string
} & Windows$Foundation$IClosable



/**
 * Represents the destination of logged messages from LoggingChannel instances.
 */
declare type Windows$Foundation$Diagnostics$IFileLoggingSession = {

/**
 * Adds a logging channel with the specified logging level to the current logging session.
 * @param loggingChannel The logging channel to add.
 * @param maxLevel The logging level for loggingChannel.
 */
addLoggingChannel(
loggingChannel: Windows$Foundation$Diagnostics$ILoggingChannel,
maxLevel: $Values<typeof Windows$Foundation$Diagnostics$LoggingLevel>): void,

/**
 * Adds a logging channel to the current logging session.
 * @param loggingChannel The logging channel to add.
 */
addLoggingChannel(loggingChannel: Windows$Foundation$Diagnostics$ILoggingChannel): void,

/**
 * Ends the current logging session and saves it to a file.
 * @return When this method completes, it returns the new file as a StorageFile .
 */
closeAndSaveToFileAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>,

/**
 * Removes the specified logging channel from the current logging session.
 * @param loggingChannel The logging channel to remove.
 */
removeLoggingChannel(loggingChannel: Windows$Foundation$Diagnostics$ILoggingChannel): void,

/**
 * Gets the name of the logging session.
 */
name: string
} & Windows$Foundation$IClosable



/**
 * Represents a reference counted memory buffer.
 */
declare class Windows$Foundation$MemoryBuffer  {

/**
 * Initializes a new MemoryBuffer instance with the specified capacity.
 * @param capacity The desired size of the new memory buffer.
 */
constructor(capacity: number): this;

/**
 * Disconnects this MemoryBuffer object from the actual memory buffer.
 */
close(): void;

/**
 * Returns a new managed object that implements the IMemoryBufferReference interface.
 * @return A new managed object that implements the IMemoryBufferReference interface.
 */
createReference(): Windows$Foundation$IMemoryBufferReference
}


      declare var npm$namespace$Windows$Foundation$Metadata: {
        
        
        AttributeTargets: typeof Windows$Foundation$Metadata$AttributeTargets,
CompositionType: typeof Windows$Foundation$Metadata$CompositionType,
DeprecationType: typeof Windows$Foundation$Metadata$DeprecationType,
GCPressureAmount: typeof Windows$Foundation$Metadata$GCPressureAmount,
MarshalingType: typeof Windows$Foundation$Metadata$MarshalingType,
Platform: typeof Windows$Foundation$Metadata$Platform,
ThreadingModel: typeof Windows$Foundation$Metadata$ThreadingModel,
        ActivatableAttribute: typeof Windows$Foundation$Metadata$ActivatableAttribute,
AllowForWebAttribute: typeof Windows$Foundation$Metadata$AllowForWebAttribute,
AllowMultipleAttribute: typeof Windows$Foundation$Metadata$AllowMultipleAttribute,
ApiContractAttribute: typeof Windows$Foundation$Metadata$ApiContractAttribute,
ApiInformation: typeof Windows$Foundation$Metadata$ApiInformation,
AttributeUsageAttribute: typeof Windows$Foundation$Metadata$AttributeUsageAttribute,
ComposableAttribute: typeof Windows$Foundation$Metadata$ComposableAttribute,
ContractVersionAttribute: typeof Windows$Foundation$Metadata$ContractVersionAttribute,
DefaultAttribute: typeof Windows$Foundation$Metadata$DefaultAttribute,
DefaultOverloadAttribute: typeof Windows$Foundation$Metadata$DefaultOverloadAttribute,
DeprecatedAttribute: typeof Windows$Foundation$Metadata$DeprecatedAttribute,
DualApiPartitionAttribute: typeof Windows$Foundation$Metadata$DualApiPartitionAttribute,
ExclusiveToAttribute: typeof Windows$Foundation$Metadata$ExclusiveToAttribute,
ExperimentalAttribute: typeof Windows$Foundation$Metadata$ExperimentalAttribute,
GCPressureAttribute: typeof Windows$Foundation$Metadata$GCPressureAttribute,
GuidAttribute: typeof Windows$Foundation$Metadata$GuidAttribute,
HasVariantAttribute: typeof Windows$Foundation$Metadata$HasVariantAttribute,
InternalAttribute: typeof Windows$Foundation$Metadata$InternalAttribute,
LengthIsAttribute: typeof Windows$Foundation$Metadata$LengthIsAttribute,
MarshalingBehaviorAttribute: typeof Windows$Foundation$Metadata$MarshalingBehaviorAttribute,
MetadataMarshalAttribute: typeof Windows$Foundation$Metadata$MetadataMarshalAttribute,
MuseAttribute: typeof Windows$Foundation$Metadata$MuseAttribute,
OverloadAttribute: typeof Windows$Foundation$Metadata$OverloadAttribute,
OverridableAttribute: typeof Windows$Foundation$Metadata$OverridableAttribute,
PlatformAttribute: typeof Windows$Foundation$Metadata$PlatformAttribute,
PreviousContractVersionAttribute: typeof Windows$Foundation$Metadata$PreviousContractVersionAttribute,
ProtectedAttribute: typeof Windows$Foundation$Metadata$ProtectedAttribute,
RangeAttribute: typeof Windows$Foundation$Metadata$RangeAttribute,
RemoteAsyncAttribute: typeof Windows$Foundation$Metadata$RemoteAsyncAttribute,
StaticAttribute: typeof Windows$Foundation$Metadata$StaticAttribute,
ThreadingAttribute: typeof Windows$Foundation$Metadata$ThreadingAttribute,
VariantAttribute: typeof Windows$Foundation$Metadata$VariantAttribute,
VersionAttribute: typeof Windows$Foundation$Metadata$VersionAttribute,
WebHostHiddenAttribute: typeof Windows$Foundation$Metadata$WebHostHiddenAttribute,
        
      }

/**
 * Indicates that the class is an activatable runtime class.
 */
declare class Windows$Foundation$Metadata$ActivatableAttribute  {}


/**
 * Enables developers to expose a native Universal Windows Platform (UWP) object as a global parameter in the context of the top-level document inside of a WebView . For a UWP object to be projected, it must implement IAgileObject and be decorated with the AllowForWebAttribute attribute.
 */
declare class Windows$Foundation$Metadata$AllowForWebAttribute  {}


/**
 * Indicates that multiple instances of a custom attribute can be applied to a target.
 */
declare class Windows$Foundation$Metadata$AllowMultipleAttribute  {}

declare class Windows$Foundation$Metadata$ApiContractAttribute  {}


/**
 * Enables you to detect whether a specified member, type, or API contract is present so that you can safely make API calls across a variety of devices.
 */
declare class Windows$Foundation$Metadata$ApiInformation  {

/**
 * Returns true or false to indicate whether the API contract with the specified name and major version number is present.
 * @param contractName The name of the API contract.
 * @param majorVersion The major version number of the API contract.
 * @return True if the specified API contract is present; otherwise, false.
 */
static isApiContractPresent(contractName: string, majorVersion: number): boolean;

/**
 * Returns true or false to indicate whether the API contract with the specified name and major and minor version number is present.
 * @param contractName The name of the API contract.
 * @param majorVersion The major version number of the API contract.
 * @param minorVersion The minor version number of the API contract.
 * @return True if the specified API contract is present; otherwise, false.
 */
static isApiContractPresent(contractName: string, majorVersion: number, minorVersion: number): boolean;

/**
 * Returns true or false to indicate whether a specified named constant is present for a specified enumeration.
 * @param enumTypeName The namespace-qualified name of the type.
 * @param valueName The name of the constant.
 * @return True if the specified constant is present; otherwise, false.
 */
static isEnumNamedValuePresent(enumTypeName: string, valueName: string): boolean;

/**
 * Returns true or false to indicate whether a specified event is present for a specified type.
 * @param typeName The namespace-qualified name of the type.
 * @param eventName The name of the event.
 * @return True if the specified event is present for the type; otherwise, false.
 */
static isEventPresent(typeName: string, eventName: string): boolean;

/**
 * Returns true or false to indicate whether a specified method is present for a specified type.
 * @param typeName The namespace-qualified name of the type.
 * @param methodName The name of the method.
 * @return True if the specified method is present for the type; otherwise, false.
 */
static isMethodPresent(typeName: string, methodName: string): boolean;

/**
 * Returns true or false to indicate whether a specified method overload with the specified number of input parameters is present for a specified type.
 * @param typeName The namespace-qualified name of the type.
 * @param methodName The name of the method.
 * @param inputParameterCount The number of input parameters for the overload.
 * @return True if the specified method is present for the type; otherwise, false.
 */
static isMethodPresent(typeName: string, methodName: string, inputParameterCount: number): boolean;

/**
 * Returns true or false to indicate whether a specified property (writeable or read-only) is present for a specified type.
 * @param typeName The namespace-qualified name of the type.
 * @param propertyName The name of the property.
 * @return True if the specified property is present for the type; otherwise, false.
 */
static isPropertyPresent(typeName: string, propertyName: string): boolean;

/**
 * Returns true or false to indicate whether a specified read-only property is present for a specified type.
 * @param typeName The namespace-qualified name of the type.
 * @param propertyName The name of the property.
 * @return True if the specified property is present for the type; otherwise, false.
 */
static isReadOnlyPropertyPresent(typeName: string, propertyName: string): boolean;

/**
 * Returns true or false to indicate whether a specified type is present.
 * @param typeName The namespace-qualified name of the type.
 * @return True if the specified type is present; otherwise, false.
 */
static isTypePresent(typeName: string): boolean;

/**
 * Returns true or false to indicate whether a specified writeable property is present for a specified type.
 * @param typeName The namespace-qualified name of the type.
 * @param propertyName The name of the property.
 * @return True if the specified property is present for the type; otherwise, false.
 */
static isWriteablePropertyPresent(typeName: string, propertyName: string): boolean
}


/**
 * Specifies the programming construct to which an attribute applies.
 */

declare  var Windows$Foundation$Metadata$AttributeTargets: {|
  +all: 0,// 0
+delegate: 1,// 1
+enum: 2,// 2
+event: 3,// 3
+field: 4,// 4
+interface: 5,// 5
+method: 6,// 6
+parameter: 7,// 7
+property: 8,// 8
+runtimeClass: 9,// 9
+struct: 10,// 10
+interfaceImpl: 11,// 11
+apiContract: 12,// 12

|};



/**
 * Specifies the use of another attribute.
 */
declare class Windows$Foundation$Metadata$AttributeUsageAttribute  {}


/**
 * Indicates how a programming element is composed.
 */
declare class Windows$Foundation$Metadata$ComposableAttribute  {}


/**
 * Specifies the visibility of a programming element for which the composable attribute is applied.
 */

declare  var Windows$Foundation$Metadata$CompositionType: {|
  +protected: 0,// 0
+public: 1,// 1

|};


declare class Windows$Foundation$Metadata$ContractVersionAttribute  {}


/**
 * Indicates the default interface for a runtime class.
 */
declare class Windows$Foundation$Metadata$DefaultAttribute  {}


/**
 * Indicates that a method is the default overload method. This attribute must be used with OverloadAttribute .
 */
declare class Windows$Foundation$Metadata$DefaultOverloadAttribute  {}


/**
 * Indicates that a type or member should be marked in metadata as deprecated. Compilers and other developer tools can read this attribute and provide info to the user about the deprecation type and possible alternates.
 */
declare class Windows$Foundation$Metadata$DeprecatedAttribute  {}


/**
 * Indicates a deprecation as Deprecate or Remove.
 */

declare  var Windows$Foundation$Metadata$DeprecationType: {|
  +deprecate: 0,// 0
+remove: 1,// 1

|};



/**
 * Indicates that the type is supported in desktop apps and in Windows Store apps.
 */
declare class Windows$Foundation$Metadata$DualApiPartitionAttribute  {}


/**
 * Indicates that the specified type is exclusive to this type.
 */
declare class Windows$Foundation$Metadata$ExclusiveToAttribute  {}


/**
 * Indicates that a type or member should be marked in metadata as experimental, and consequently may not be present in the final, released version of an SDK or library.
 */
declare class Windows$Foundation$Metadata$ExperimentalAttribute  {}


/**
 * Microsoft internal use only.
 */

declare  var Windows$Foundation$Metadata$GCPressureAmount: {|
  +low: 0,// 0
+medium: 1,// 1
+high: 2,// 2

|};


declare class Windows$Foundation$Metadata$GCPressureAttribute  {}


/**
 * Indicates the GUID for the interface or delegate.
 */
declare class Windows$Foundation$Metadata$GuidAttribute  {}


/**
 * Indicates that the type is an instance of a variant IInspectable. Applies to runtime classes, interfaces, and parameterized interfaces.
 */
declare class Windows$Foundation$Metadata$HasVariantAttribute  {}


/**
 * Indicates that a type or member should be marked in metadata as internal to the SDK or framework, and for consumption by system components only.
 */
declare class Windows$Foundation$Metadata$InternalAttribute  {}


/**
 * Indicates the number of array elements.
 */
declare class Windows$Foundation$Metadata$LengthIsAttribute  {}


/**
 * Indicates the marshaling behavior of a Windows Runtime component.
 */
declare class Windows$Foundation$Metadata$MarshalingBehaviorAttribute  {}


/**
 * Specifies the marshaling type for the class.
 */

declare  var Windows$Foundation$Metadata$MarshalingType: {|
  +none: 0,// 0
+agile: 1,// 1
+standard: 2,// 2
+invalidMarshaling: 3,// 3

|};



/**
 * Indicates that tools should create an entry for an interface when creating an application package.
 */
declare class Windows$Foundation$Metadata$MetadataMarshalAttribute  {}


/**
 * Indicates that a runtime class is compatible with Windows Store apps that are web browsers.
 */
declare class Windows$Foundation$Metadata$MuseAttribute  {}


/**
 * Identifies the method as an overload in a language that supports overloading.
 */
declare class Windows$Foundation$Metadata$OverloadAttribute  {}


/**
 * Indicates that the interface contains overridable methods.
 */
declare class Windows$Foundation$Metadata$OverridableAttribute  {}


/**
 * Specifies the platforms that a specified type should be supported in, as used by Windows Runtime attributes and metadata.
 */

declare  var Windows$Foundation$Metadata$Platform: {|
  +windows: 0,// 0
+windowsPhone: 1,// 1

|};



/**
 * Declares the platform that a type should be supported in, when platform-specific metadata is produced.
 */
declare class Windows$Foundation$Metadata$PlatformAttribute  {}

declare class Windows$Foundation$Metadata$PreviousContractVersionAttribute  {}


/**
 * Indicates that the interface contains protected methods.
 */
declare class Windows$Foundation$Metadata$ProtectedAttribute  {}


/**
 * Indicates the numeric range constraints for the value of a data field.
 */
declare class Windows$Foundation$Metadata$RangeAttribute  {}


/**
 * Indicates that an interface can be delivered using an asynchronous form of the Async pattern.
 */
declare class Windows$Foundation$Metadata$RemoteAsyncAttribute  {}


/**
 * Indicates an interface that contains only static methods.
 */
declare class Windows$Foundation$Metadata$StaticAttribute  {}


/**
 * Indicates the threading model of a Windows Runtime component.
 */
declare class Windows$Foundation$Metadata$ThreadingAttribute  {}


/**
 * Specifies the threading model.
 */

declare  var Windows$Foundation$Metadata$ThreadingModel: {|
  +sta: 0,// 0
+mta: 1,// 1
+both: 2,// 2
+invalidThreading: 3,// 3

|};



/**
 * Indicates that the item is an instance of a variant IInspectable. Applies to method parameters, properties, and return values of types.
 */
declare class Windows$Foundation$Metadata$VariantAttribute  {}


/**
 * Indicates the version of the type.
 */
declare class Windows$Foundation$Metadata$VersionAttribute  {}


/**
 * Identifies the type as one whose functionality is not projected into the specified target language.
 */
declare class Windows$Foundation$Metadata$WebHostHiddenAttribute  {}


/**
 * Describes a 4*4 floating point matrix.
 */
declare interface Windows$Foundation$Numerics$Matrix4x4 {

/**
 * The row one and column one element of the matrix.
 */
m11: number,

/**
 * The row one and column two element of the matrix.
 */
m12: number,

/**
 * The row one and column three element of the matrix.
 */
m13: number,

/**
 * The row one and column four element of the matrix.
 */
m14: number,

/**
 * The row two and column one element of the matrix.
 */
m21: number,

/**
 * The row two and column two element of the matrix.
 */
m22: number,

/**
 * The row two and column three element of the matrix.
 */
m23: number,

/**
 * The row two and column four element of the matrix.
 */
m24: number,

/**
 * The row three and column one element of the matrix.
 */
m31: number,

/**
 * The row three and column two element of the matrix.
 */
m32: number,

/**
 * The row three and column three element of the matrix.
 */
m33: number,

/**
 * The row three and column four element of the matrix.
 */
m34: number,

/**
 * The row four and column one element of the matrix.
 */
m41: number,

/**
 * The row four and column two element of the matrix.
 */
m42: number,

/**
 * The row four and column three element of the matrix.
 */
m43: number,

/**
 * The row four and column four element of the matrix.
 */
m44: number
} 


/**
 * Describes a vector of three floating-point components.
 */
declare interface Windows$Foundation$Numerics$Vector3 {

/**
 * The x component of the vector.
 */
x: number,

/**
 * The y component of the vector.
 */
y: number,

/**
 * The z component of the vector.
 */
z: number
} 


/**
 * Describes a quaternion (an axis about which a rotation occurs and a rotation amount about that axis).
 */
declare interface Windows$Foundation$Numerics$Quaternion {

/**
 * The w component that represents a rotation amount about the axis that is defined by the X, Y, and Z fields.
 */
w: number,

/**
 * The x component of the vector that represents the axis about which a rotation occurs.
 */
x: number,

/**
 * The y component of the vector that represents the axis about which a rotation occurs.
 */
y: number,

/**
 * The z component of the vector that represents the axis about which a rotation occurs.
 */
z: number
} 


/**
 * Describes a vector of two floating-point components.
 */
declare interface Windows$Foundation$Numerics$Vector2 {

/**
 * The x component of the vector.
 */
x: number,

/**
 * The y component of the vector.
 */
y: number
} 


/**
 * Describes a 3*2 floating point matrix.
 */
declare interface Windows$Foundation$Numerics$Matrix3x2 {

/**
 * The row one and column one element of the matrix.
 */
m11: number,

/**
 * The row one and column two element of the matrix.
 */
m12: number,

/**
 * The row two and column one element of the matrix.
 */
m21: number,

/**
 * The row two and column two element of the matrix.
 */
m22: number,

/**
 * The row three and column one element of the matrix.
 */
m31: number,

/**
 * The row three and column two element of the matrix.
 */
m32: number
} 


/**
 * Specifies property value types.
 */

declare  var Windows$Foundation$PropertyType: {|
  +empty: 0,// 0
+uint8: 1,// 1
+int16: 2,// 2
+uint16: 3,// 3
+int32: 4,// 4
+uint32: 5,// 5
+int64: 6,// 6
+uint64: 7,// 7
+single: 8,// 8
+double: 9,// 9
+char16: 10,// 10
+boolean: 11,// 11
+string: 12,// 12
+inspectable: 13,// 13
+dateTime: 14,// 14
+timeSpan: 15,// 15
+guid: 16,// 16
+point: 17,// 17
+size: 18,// 18
+rect: 19,// 19
+otherType: 20,// 20
+uint8Array: 21,// 21
+int16Array: 22,// 22
+uint16Array: 23,// 23
+int32Array: 24,// 24
+uint32Array: 25,// 25
+int64Array: 26,// 26
+uint64Array: 27,// 27
+singleArray: 28,// 28
+doubleArray: 29,// 29
+char16Array: 30,// 30
+booleanArray: 31,// 31
+stringArray: 32,// 32
+inspectableArray: 33,// 33
+dateTimeArray: 34,// 34
+timeSpanArray: 35,// 35
+guidArray: 36,// 36
+pointArray: 37,// 37
+sizeArray: 38,// 38
+rectArray: 39,// 39
+otherTypeArray: 40,// 40

|};



/**
 * Defines an object that represents a Uniform Resource Identifier (URI) value and parses it into components. The Uri object is used by many other Windows Runtime APIs that are not necessarily confined to web browser scenarios.
 */
declare class Windows$Foundation$Uri  {

/**
 * Converts a Uniform Resource Identifier (URI) string to its escaped representation.
 * @param toEscape The string to convert.
 * @return The escaped representation of toEscape.
 */
static escapeComponent(toEscape: string): string;

/**
 * Converts the specified string by replacing any escape sequences with their unescaped representation.
 * @param toUnescape The string to convert.
 * @return The unescaped representation of stringToUnescape.
 */
static unescapeComponent(toUnescape: string): string;

/**
 * Initializes a new Uri by combining a base Uniform Resource Identifier (URI) and a relative URI. Initializing the Uri also parses the combined string and populates the Uri properties that represent URI components.
 * @param baseUri The base URI.
 * @param relativeUri The relative URI.
 */
constructor(baseUri: string, relativeUri: string): this;

/**
 * Initializes a new Uri object from the specified Uniform Resource Identifier (URI) string. Initializing the Uri also parses the string and populates the Uri properties that represent URI components.
 * @param uri The string from which the new Uri object is created.
 */
constructor(uri: string): this;

/**
 * Gets a fully canonical RFC-compliant representation of the current URI.
 */
absoluteCanonicalUri: string;

/**
 * Gets the entire, non-canonical URI (It is non-canonical because it might actually be an IRI, per the Windows.Foundation.Uri encoding behavior; see Remarks.).
 */
absoluteUri: string;

/**
 * Adds the specified Uniform Resource Identifier (URI) to the current Uri .
 * @param relativeUri A relative URI specified as a string. This relative path is evaluated using the host/authority of the Uri instance where this method is called.
 * @return The combined Uri value.
 */
combineUri(relativeUri: string): Windows$Foundation$Uri;

/**
 * Gets the decoded unicode characters that make up the current URI.
 */
displayIri: string;

/**
 * Gets a representation of the Uniform Resource Identifier (URI) that can be used for display purposes.
 */
displayUri: string;

/**
 * Gets the domain name component, including top-level domain, from a Uniform Resource Identifier (URI).
 */
domain: string;

/**
 * Determines whether the specified Uri object is equal to the current Uri object.
 * @param pUri The Uri object to be compared.
 * @return true if the two Uri values are the same; otherwise, false.
 */
equals(pUri: Windows$Foundation$Uri): boolean;

/**
 * Gets the file name extension of the resource that is referenced in the Uri .
 */
extension: string;

/**
 * Gets the text following a fragment marker (#), including the fragment marker itself.
 */
fragment: string;

/**
 * Gets the fully qualified domain name.
 */
host: string;

/**
 * Gets the password component of the Uniform Resource Identifier (URI) as stored in this Uri instance.
 */
password: string;

/**
 * Gets the path and resource name component of the Uniform Resource Identifier (URI) as stored in this Uri instance.
 */
path: string;

/**
 * Gets the port number component of the Uniform Resource Identifier (URI) as stored in this Uri instance
 */
port: number;

/**
 * Gets the query string component of the Uniform Resource Identifier (URI) as stored in this Uri instance.
 */
query: string;

/**
 * Gets a parsed Uniform Resource Identifier (URI) query string.
 */
queryParsed: Windows$Foundation$WwwFormUrlDecoder;

/**
 * Gets the entire original Uniform Resource Identifier (URI) string as used to construct this Uri object, before parsing, and without any encoding applied.
 */
rawUri: string;

/**
 * Gets the protocol scheme name component of the Uniform Resource Identifier (URI) as stored in this Uri instance
 */
schemeName: string;

/**
 * Gets a value that indicates whether parsing determined that the Uniform Resource Identifier (URI) is not well-formed.
 */
suspicious: boolean;

/**
 * Gets the user name component of the Uniform Resource Identifier (URI) as stored in this Uri instance.
 */
userName: string
}


/**
 * Parses a URL query string, and exposes the results as a read-only vector (list) of name-value pairs from the query string.
 */
declare class Windows$Foundation$WwwFormUrlDecoder mixins Array<Windows$Foundation$IWwwFormUrlDecoderEntry> {

/**
 * Creates and initializes a new instance of the WwwFormUrlDecoder class.
 * @param query The URL to parse.
 */
constructor(query: string): this;

/**
 * Gets an iterator that represents the first name-value pair in the current URL query string.
 * @return The first name-value pair.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$IWwwFormUrlDecoderEntry>;

/**
 * Gets the name-value pair at the specified index in the current URL query string.
 * @param index The index of the name-value pair.
 * @return The name-value pair at the position specified by index.
 */
getAt(index: number): Windows$Foundation$IWwwFormUrlDecoderEntry;

/**
 * Gets the first name-value pair that has the specified name, as obtained from the constructing Uniform Resource Identifier (URI) query string.
 * @param name The name of the value to get.
 * @return The first value in list order that corresponds with name.
 */
getFirstValueByName(name: string): string;

/**
 * Gets name-value pairs starting at the specified index in the current URL query string.
 * @param startIndex The index to start getting name-value pairs at.
 */
getMany(
startIndex: number): {
items: Windows$Foundation$IWwwFormUrlDecoderEntry,
returnValue: number
};

/**
 * Gets a value indicating whether the specified IWwwFormUrlDecoderEntry is at the specified index in the current URL query string.
 * @param value The name-value pair to get the index of.
 */
indexOf(
value: Windows$Foundation$IWwwFormUrlDecoderEntry): {
index: number,
returnValue: boolean
};

/**
 * Gets the number of the name-value pairs in the current URL query string.
 */
size: number;
indexOf(
value: Windows$Foundation$IWwwFormUrlDecoderEntry,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Foundation$IWwwFormUrlDecoderEntry,
fromIndex?: number): number
}


/**
 * Represents a name-value pair in a URL query string. Use the IWwwFormUrlDecoderEntry interface instead; see Remarks.
 */
declare class Windows$Foundation$WwwFormUrlDecoderEntry  {

/**
 * Represents the name of a parameter in a URL query string. Use the IWwwFormUrlDecoderEntry interface version ( IWwwFormUrlDecoderEntry.Name ) instead; see Remarks.
 */
name: string;

/**
 * Represents a named value in a URL query string. Use the IWwwFormUrlDecoderEntry interface version ( IWwwFormUrlDecoderEntry.Value ) instead; see Remarks.
 */
value: string
}


/**
 * Represents a method that handles general events.
 */
declare type Windows$Foundation$EventHandler<T> = (ev: T & Windows$WinRTEvent<any>) => void;


/**
 * Contains number values that represent the location and size of a rectangle.
 */
declare interface Windows$Foundation$Rect {

/**
 * The height of the rectangle, in pixels.
 */
height: number,

/**
 * The width of the rectangle, in pixels.
 */
width: number,

/**
 * The x-coordinate of the upper-left corner of the rectangle.
 */
x: number,

/**
 * The y-coordinate of the upper-left corner of the rectangle.
 */
y: number
} 


/**
 * Represents a method that handles general events.
 */
declare type Windows$Foundation$TypedEventHandler<TSender, TResult> = (ev: TResult & Windows$WinRTEvent<TSender>) => void;


/**
 * Represents number values that specify a height and width.
 */
declare interface Windows$Foundation$Size {

/**
 * The height.
 */
height: number,

/**
 * The width.
 */
width: number
} 


/**
 * Represents an asynchronous operation, which returns a result upon completion. This is the return type for many Windows Runtime asynchronous methods that have results but don't report progress.
 */
declare type Windows$Foundation$IAsyncOperation<TResult> = {

/**
 * Returns the results of the operation.
 * @return The results of the operation.
 */
getResults(): TResult,

/**
 * Gets or sets the method that handles the operation completed notification.
 */
completed: Windows$Foundation$AsyncOperationCompletedHandler<TResult>
} & Windows$Foundation$IAsyncInfo



/**
 * Represents an asynchronous action. This is the return type for many Windows Runtime asynchronous methods that don't have a result object, and don't report ongoing progress.
 */
declare type Windows$Foundation$IAsyncAction = {

/**
 * Returns the results of the action.
 */
getResults(): void,

/**
 * Gets or sets the method that handles the action completed notification.
 */
completed: Windows$Foundation$AsyncActionCompletedHandler
} & Windows$Foundation$IAsyncInfo



/**
 * Represents an asynchronous operation that can report progress updates to callers. This is the return type for many Windows Runtime asynchronous methods that have results and also report progress.
 */
declare type Windows$Foundation$IAsyncOperationWithProgress<TResult, TProgress> = {

/**
 * Returns the results of the operation.
 * @return The results of the operation.
 */
getResults(): TResult,

/**
 * Gets or sets the method that handles the operation completed notification.
 */
completed: Windows$Foundation$AsyncOperationWithProgressCompletedHandler<TResult, TProgress>,

/**
 * Gets or sets the method that handles progress notifications.
 */
progress: Windows$Foundation$AsyncOperationProgressHandler<TResult, TProgress>
} & Windows$Foundation$IAsyncInfo



/**
 * Represents x- and y-coordinate values that define a point in a two-dimensional plane.
 */
declare interface Windows$Foundation$Point {

/**
 * The horizontal position of the point.
 */
x: number,

/**
 * The vertical position of the point.
 */
y: number
} 


/**
 * Represents a reference counted memory buffer.
 */
declare type Windows$Foundation$IMemoryBuffer = {

/**
 * Returns a new managed object that implements the IMemoryBufferReference interface.
 * @return A new managed object that implements the IMemoryBufferReference interface.
 */
createReference(): Windows$Foundation$IMemoryBufferReference
} & Windows$Foundation$IClosable



/**
 * Represents a method that handles the completed event of an asynchronous action.
 */
declare type Windows$Foundation$AsyncActionCompletedHandler = (
asyncInfo: Windows$Foundation$IAsyncAction,
asyncStatus: $Values<typeof Windows$Foundation$AsyncStatus>) => void;


/**
 * Represents a method that handles the completed event of an asynchronous operation.
 */
declare type Windows$Foundation$AsyncOperationCompletedHandler<TResult> = (
asyncInfo: Windows$Foundation$IAsyncOperation<TResult>,
asyncStatus: $Values<typeof Windows$Foundation$AsyncStatus>) => void;


/**
 * Represents a method that handles the completed event of an asynchronous operation that provides progress updates.
 */
declare type Windows$Foundation$AsyncOperationWithProgressCompletedHandler<TResult, TProgress> = (
asyncInfo: Windows$Foundation$IAsyncOperationWithProgress<TResult, TProgress>,
asyncStatus: $Values<typeof Windows$Foundation$AsyncStatus>) => void;


/**
 * Represents a method that handles progress update events of an asynchronous operation that provides progress updates.
 */
declare type Windows$Foundation$AsyncOperationProgressHandler<TResult, TProgress> = (
asyncInfo: Windows$Foundation$IAsyncOperationWithProgress<TResult, TProgress>,
progressInfo: TProgress) => void;


/**
 * Represents a method that handles the completed event of a deferred action.
 */
declare type Windows$Foundation$DeferralCompletedHandler = () => void;


/**
 * Represents a reference to an IMemoryBuffer object.
 */
declare type Windows$Foundation$IMemoryBufferReference = {

/**
 * Gets the size of the memory buffer in bytes.
 */
capacity: number
} & Windows$Foundation$IClosable



/**
 * Represents a name-value pair in a URL query string.
 */
declare interface Windows$Foundation$IWwwFormUrlDecoderEntry {

/**
 * Represents the name of a parameter in a URL query string.
 */
name: string,

/**
 * Represents a named value in a URL query string.
 */
value: string
} 


/**
 * Represents an asynchronous action that can report progress updates to callers. This is the return type for all Windows Runtime asynchronous methods that don't have a result object, but do report progress to callback listeners.
 */
declare type Windows$Foundation$IAsyncActionWithProgress<TProgress> = {

/**
 * Returns the results of the action.
 */
getResults(): void,

/**
 * Gets or sets the method that handles the action completed notification.
 */
completed: Windows$Foundation$AsyncActionWithProgressCompletedHandler<TProgress>,

/**
 * Gets or sets the callback method that receives progress notification.
 */
progress: Windows$Foundation$AsyncActionProgressHandler<TProgress>
} & Windows$Foundation$IAsyncInfo



/**
 * Supports asynchronous actions and operations. IAsyncInfo is a base interface for IAsyncAction , IAsyncActionWithProgress<TProgress> , IAsyncOperation<TResult> and IAsyncOperationWithProgress<TResult,TProgress> , each of which support combinations of return type and progress for an asynchronous method.
 */
declare interface Windows$Foundation$IAsyncInfo {

/**
 * Cancels the asynchronous operation.
 */
cancel(): void,

/**
 * Closes the asynchronous operation.
 */
close(): void,

/**
 * Gets a string that describes an error condition of the asynchronous operation.
 */
errorCode: Windows$WinRTError,

/**
 * Gets the handle of the asynchronous operation.
 */
id: number,

/**
 * Gets a value that indicates the status of the asynchronous operation.
 */
status: $Values<typeof Windows$Foundation$AsyncStatus>
} 


/**
 * Defines a method to release allocated resources.
 */
declare interface Windows$Foundation$IClosable {

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 */
close(): void
} 


/**
 * Represents a method that handles the completed event of an asynchronous action that provides progress updates.
 */
declare type Windows$Foundation$AsyncActionWithProgressCompletedHandler<TProgress> = (
asyncInfo: Windows$Foundation$IAsyncActionWithProgress<TProgress>,
asyncStatus: $Values<typeof Windows$Foundation$AsyncStatus>) => void;


/**
 * Represents a method that handles progress update events of an asynchronous action that provides progress updates.
 */
declare type Windows$Foundation$AsyncActionProgressHandler<TProgress> = (
asyncInfo: Windows$Foundation$IAsyncActionWithProgress<TProgress>,
progressInfo: TProgress) => void;


/**
 * Provides a way to represent the current object as a string.
 */
declare interface Windows$Foundation$IStringable {

/**
 * Gets a string that represents the current object.
 * @return A string that represents the current object.
 */
toString(): string
} 


      declare var npm$namespace$Windows$Media: {
        
        
        AudioBufferAccessMode: typeof Windows$Media$AudioBufferAccessMode,
AudioProcessing: typeof Windows$Media$AudioProcessing,
MediaPlaybackAutoRepeatMode: typeof Windows$Media$MediaPlaybackAutoRepeatMode,
MediaPlaybackStatus: typeof Windows$Media$MediaPlaybackStatus,
MediaPlaybackType: typeof Windows$Media$MediaPlaybackType,
SoundLevel: typeof Windows$Media$SoundLevel,
SystemMediaTransportControlsButton: typeof Windows$Media$SystemMediaTransportControlsButton,
SystemMediaTransportControlsProperty: typeof Windows$Media$SystemMediaTransportControlsProperty,
        AudioBuffer: typeof Windows$Media$AudioBuffer,
AudioFrame: typeof Windows$Media$AudioFrame,
AutoRepeatModeChangeRequestedEventArgs: typeof Windows$Media$AutoRepeatModeChangeRequestedEventArgs,
ImageDisplayProperties: typeof Windows$Media$ImageDisplayProperties,
MediaControl: typeof Windows$Media$MediaControl,
MediaExtensionManager: typeof Windows$Media$MediaExtensionManager,
MediaMarkerTypes: typeof Windows$Media$MediaMarkerTypes,
MediaProcessingTriggerDetails: typeof Windows$Media$MediaProcessingTriggerDetails,
MusicDisplayProperties: typeof Windows$Media$MusicDisplayProperties,
PlaybackPositionChangeRequestedEventArgs: typeof Windows$Media$PlaybackPositionChangeRequestedEventArgs,
PlaybackRateChangeRequestedEventArgs: typeof Windows$Media$PlaybackRateChangeRequestedEventArgs,
ShuffleEnabledChangeRequestedEventArgs: typeof Windows$Media$ShuffleEnabledChangeRequestedEventArgs,
SystemMediaTransportControls: typeof Windows$Media$SystemMediaTransportControls,
SystemMediaTransportControlsButtonPressedEventArgs: typeof Windows$Media$SystemMediaTransportControlsButtonPressedEventArgs,
SystemMediaTransportControlsDisplayUpdater: typeof Windows$Media$SystemMediaTransportControlsDisplayUpdater,
SystemMediaTransportControlsPropertyChangedEventArgs: typeof Windows$Media$SystemMediaTransportControlsPropertyChangedEventArgs,
SystemMediaTransportControlsTimelineProperties: typeof Windows$Media$SystemMediaTransportControlsTimelineProperties,
VideoDisplayProperties: typeof Windows$Media$VideoDisplayProperties,
VideoEffects: typeof Windows$Media$VideoEffects,
VideoFrame: typeof Windows$Media$VideoFrame,
        Audio: typeof npm$namespace$Windows$Media$Audio,
Capture: typeof npm$namespace$Windows$Media$Capture,
Casting: typeof npm$namespace$Windows$Media$Casting,
ClosedCaptioning: typeof npm$namespace$Windows$Media$ClosedCaptioning,
ContentRestrictions: typeof npm$namespace$Windows$Media$ContentRestrictions,
Devices: typeof npm$namespace$Windows$Media$Devices,
DialProtocol: typeof npm$namespace$Windows$Media$DialProtocol,
Editing: typeof npm$namespace$Windows$Media$Editing,
Effects: typeof npm$namespace$Windows$Media$Effects,
FaceAnalysis: typeof npm$namespace$Windows$Media$FaceAnalysis,
Import: typeof npm$namespace$Windows$Media$Import,
MediaProperties: typeof npm$namespace$Windows$Media$MediaProperties,
Ocr: typeof npm$namespace$Windows$Media$Ocr,
PlayTo: typeof npm$namespace$Windows$Media$PlayTo,
Playback: typeof npm$namespace$Windows$Media$Playback,
Playlists: typeof npm$namespace$Windows$Media$Playlists,
Protection: typeof npm$namespace$Windows$Media$Protection,
Render: typeof npm$namespace$Windows$Media$Render,
SpeechRecognition: typeof npm$namespace$Windows$Media$SpeechRecognition,
SpeechSynthesis: typeof npm$namespace$Windows$Media$SpeechSynthesis,
Streaming: typeof npm$namespace$Windows$Media$Streaming,
Transcoding: typeof npm$namespace$Windows$Media$Transcoding,
      }

      declare var npm$namespace$Windows$Media$Core: {
        
        
        FaceDetectionMode: typeof Windows$Media$Core$FaceDetectionMode,
MediaSourceState: typeof Windows$Media$Core$MediaSourceState,
MediaStreamSourceClosedReason: typeof Windows$Media$Core$MediaStreamSourceClosedReason,
MediaStreamSourceErrorStatus: typeof Windows$Media$Core$MediaStreamSourceErrorStatus,
MediaTrackKind: typeof Windows$Media$Core$MediaTrackKind,
TimedMetadataKind: typeof Windows$Media$Core$TimedMetadataKind,
TimedMetadataTrackErrorCode: typeof Windows$Media$Core$TimedMetadataTrackErrorCode,
TimedTextDisplayAlignment: typeof Windows$Media$Core$TimedTextDisplayAlignment,
TimedTextFlowDirection: typeof Windows$Media$Core$TimedTextFlowDirection,
TimedTextLineAlignment: typeof Windows$Media$Core$TimedTextLineAlignment,
TimedTextScrollMode: typeof Windows$Media$Core$TimedTextScrollMode,
TimedTextUnit: typeof Windows$Media$Core$TimedTextUnit,
TimedTextWeight: typeof Windows$Media$Core$TimedTextWeight,
TimedTextWrapping: typeof Windows$Media$Core$TimedTextWrapping,
TimedTextWritingMode: typeof Windows$Media$Core$TimedTextWritingMode,
VideoStabilizationEffectEnabledChangedReason: typeof Windows$Media$Core$VideoStabilizationEffectEnabledChangedReason,
        AudioStreamDescriptor: typeof Windows$Media$Core$AudioStreamDescriptor,
AudioTrack: typeof Windows$Media$Core$AudioTrack,
DataCue: typeof Windows$Media$Core$DataCue,
FaceDetectedEventArgs: typeof Windows$Media$Core$FaceDetectedEventArgs,
FaceDetectionEffect: typeof Windows$Media$Core$FaceDetectionEffect,
FaceDetectionEffectDefinition: typeof Windows$Media$Core$FaceDetectionEffectDefinition,
FaceDetectionEffectFrame: typeof Windows$Media$Core$FaceDetectionEffectFrame,
HighDynamicRangeControl: typeof Windows$Media$Core$HighDynamicRangeControl,
HighDynamicRangeOutput: typeof Windows$Media$Core$HighDynamicRangeOutput,
MediaBinder: typeof Windows$Media$Core$MediaBinder,
MediaBindingEventArgs: typeof Windows$Media$Core$MediaBindingEventArgs,
MediaCueEventArgs: typeof Windows$Media$Core$MediaCueEventArgs,
MediaSource: typeof Windows$Media$Core$MediaSource,
MediaSourceError: typeof Windows$Media$Core$MediaSourceError,
MediaSourceOpenOperationCompletedEventArgs: typeof Windows$Media$Core$MediaSourceOpenOperationCompletedEventArgs,
MediaSourceStateChangedEventArgs: typeof Windows$Media$Core$MediaSourceStateChangedEventArgs,
MediaStreamSample: typeof Windows$Media$Core$MediaStreamSample,
MediaStreamSamplePropertySet: typeof Windows$Media$Core$MediaStreamSamplePropertySet,
MediaStreamSampleProtectionProperties: typeof Windows$Media$Core$MediaStreamSampleProtectionProperties,
MediaStreamSource: typeof Windows$Media$Core$MediaStreamSource,
MediaStreamSourceClosedEventArgs: typeof Windows$Media$Core$MediaStreamSourceClosedEventArgs,
MediaStreamSourceClosedRequest: typeof Windows$Media$Core$MediaStreamSourceClosedRequest,
MediaStreamSourceSampleRequest: typeof Windows$Media$Core$MediaStreamSourceSampleRequest,
MediaStreamSourceSampleRequestDeferral: typeof Windows$Media$Core$MediaStreamSourceSampleRequestDeferral,
MediaStreamSourceSampleRequestedEventArgs: typeof Windows$Media$Core$MediaStreamSourceSampleRequestedEventArgs,
MediaStreamSourceStartingEventArgs: typeof Windows$Media$Core$MediaStreamSourceStartingEventArgs,
MediaStreamSourceStartingRequest: typeof Windows$Media$Core$MediaStreamSourceStartingRequest,
MediaStreamSourceStartingRequestDeferral: typeof Windows$Media$Core$MediaStreamSourceStartingRequestDeferral,
MediaStreamSourceSwitchStreamsRequest: typeof Windows$Media$Core$MediaStreamSourceSwitchStreamsRequest,
MediaStreamSourceSwitchStreamsRequestDeferral: typeof Windows$Media$Core$MediaStreamSourceSwitchStreamsRequestDeferral,
MediaStreamSourceSwitchStreamsRequestedEventArgs: typeof Windows$Media$Core$MediaStreamSourceSwitchStreamsRequestedEventArgs,
SceneAnalysisEffect: typeof Windows$Media$Core$SceneAnalysisEffect,
SceneAnalysisEffectDefinition: typeof Windows$Media$Core$SceneAnalysisEffectDefinition,
SceneAnalysisEffectFrame: typeof Windows$Media$Core$SceneAnalysisEffectFrame,
SceneAnalyzedEventArgs: typeof Windows$Media$Core$SceneAnalyzedEventArgs,
TimedMetadataTrack: typeof Windows$Media$Core$TimedMetadataTrack,
TimedMetadataTrackError: typeof Windows$Media$Core$TimedMetadataTrackError,
TimedMetadataTrackFailedEventArgs: typeof Windows$Media$Core$TimedMetadataTrackFailedEventArgs,
TimedTextCue: typeof Windows$Media$Core$TimedTextCue,
TimedTextLine: typeof Windows$Media$Core$TimedTextLine,
TimedTextRegion: typeof Windows$Media$Core$TimedTextRegion,
TimedTextSource: typeof Windows$Media$Core$TimedTextSource,
TimedTextSourceResolveResultEventArgs: typeof Windows$Media$Core$TimedTextSourceResolveResultEventArgs,
TimedTextStyle: typeof Windows$Media$Core$TimedTextStyle,
TimedTextSubformat: typeof Windows$Media$Core$TimedTextSubformat,
VideoStabilizationEffect: typeof Windows$Media$Core$VideoStabilizationEffect,
VideoStabilizationEffectDefinition: typeof Windows$Media$Core$VideoStabilizationEffectDefinition,
VideoStabilizationEffectEnabledChangedEventArgs: typeof Windows$Media$Core$VideoStabilizationEffectEnabledChangedEventArgs,
VideoStreamDescriptor: typeof Windows$Media$Core$VideoStreamDescriptor,
VideoTrack: typeof Windows$Media$Core$VideoTrack,
        
      }
declare interface Windows$Media$Core$MseStreamSource {} 


/**
 * Defines an audio media stream.
 */
declare class Windows$Media$Core$AudioStreamDescriptor  {

/**
 * Creates an instance of AudioStreamDescriptor class using the specified AudioEncodingProperties .
 * @param encodingProperties The encoding properties for the audio stream.
 */
constructor(encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties): this;

/**
 * The encoding properties of the stream.
 */
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Specifies whether the stream is currently in use by the MediaStreamSource .
 */
isSelected: boolean;

/**
 * Gets or sets the RFC-1766 language code for the stream.
 */
language: string;

/**
 * Gets or sets the name of the stream.
 */
name: string
}


/**
 * Represents an audio track.
 */
declare class Windows$Media$Core$AudioTrack  {

/**
 * Gets or sets the identifier for the audio track.
 */
id: string;

/**
 * Gets or sets the label for the audio track.
 */
label: string;

/**
 * Gets or sets a string indicating the language of the audio track.
 */
language: string;

/**
 * Gets a value indicating the type of data the track contains. For AudioTrack objects, this value is always MediaTrackKind::Audio .
 */
trackKind: $Values<typeof Windows$Media$Core$MediaTrackKind>
}


/**
 * Represents a data cue that can be included in a TimedMetadataTrack .
 */
declare class Windows$Media$Core$DataCue  {

/**
 * Initializes a new instance of the DataCue class.
 */
constructor(): this;

/**
 * Gets the data associated with the cue.
 */
data: Windows$Storage$Streams$IBuffer;

/**
 * Gets or sets the duration of the cue.
 */
duration: number;

/**
 * Gets the identifier for the timed metadata track.
 */
id: string;

/**
 * Gets the start time of the cue.
 */
startTime: number
}


/**
 * Provides data for the FaceDetected event.
 */
declare class Windows$Media$Core$FaceDetectedEventArgs  {

/**
 * Gets the FaceDetectionEffectFrame associated with a FaceDetected event.
 */
resultFrame: Windows$Media$Core$FaceDetectionEffectFrame
}


/**
 * Represents an effect that attempts to detect faces in a video stream.
 */
declare class Windows$Media$Core$FaceDetectionEffect  {

/**
 * Gets or sets the time span for which face detection should be performed.
 */
desiredDetectionInterval: number;

/**
 * Gets or sets a value indicating whether face detection is enabled.
 */
enabled: boolean;

/**
 * Occurs when a face is detected.
 */
onfacedetected: Windows$Foundation$TypedEventHandler<Windows$Media$Core$FaceDetectionEffect, Windows$Media$Core$FaceDetectedEventArgs>;
addEventListener(
type: "facedetected",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$FaceDetectionEffect, Windows$Media$Core$FaceDetectedEventArgs>): void;
removeEventListener(
type: "facedetected",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$FaceDetectionEffect, Windows$Media$Core$FaceDetectedEventArgs>): void;

/**
 * Sets properties on the IMediaExtension .
 * @param configuration The property set.
 */
setProperties(configuration: Windows$Foundation$Collections$IPropertySet): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the definition of a face detection video effect.
 */
declare class Windows$Media$Core$FaceDetectionEffectDefinition  {

/**
 * Initializes a new instance of the FaceDetectionEffectDefinition class.
 */
constructor(): this;

/**
 * Gets a string containing the activatable class ID of the face detection effect definition.
 */
activatableClassId: string;

/**
 * Gets or sets a value that prioritizes the speed of face detection and the quality of detection results.
 */
detectionMode: $Values<typeof Windows$Media$Core$FaceDetectionMode>;

/**
 * Gets the set of properties for configuring the FaceDetectionEffectDefinition object.
 */
properties: Windows$Foundation$Collections$IPropertySet;

/**
 * Gets or sets a value indicating whether synchronous face detection is enabled.
 */
synchronousDetectionEnabled: boolean
}


/**
 * Represents a video frame that includes a list of faces detected by the FaceDetectionEffect .
 */
declare class Windows$Media$Core$FaceDetectionEffectFrame  {

/**
 * Disposes of the object and associated resources.
 */
close(): void;

/**
 * Gets the list of objects representing the faces detected in the frame.
 */
detectedFaces: Windows$Foundation$Collections$IVectorView<Windows$Media$FaceAnalysis$DetectedFace>;

/**
 * Gets or sets the duration of the face detection effect frame.
 */
duration: number;

/**
 * Gets the extended property set which enables getting and setting properties on the media frame.
 */
extendedProperties: Windows$Foundation$Collections$IPropertySet;

/**
 * Gets or sets a value that indicates whether a video frame is the first frame after a gap in the stream.
 */
isDiscontinuous: boolean;

/**
 * Gets a value indicating whether the frame is read-only.
 */
isReadOnly: boolean;

/**
 * Gets or sets the relative time of the frame within the video stream.
 */
relativeTime: number;

/**
 * Gets or sets a timestamp that is relative to the system and is correlatable across multiple media sources on the same device.
 */
systemRelativeTime: number;

/**
 * Gets a string indicating the type of data the frame contains.
 */
type: string
}


/**
 * Specifies the mode used for face detection.
 */

declare  var Windows$Media$Core$FaceDetectionMode: {|
  +highPerformance: 0,// 0
+balanced: 1,// 1
+highQuality: 2,// 2

|};



/**
 * Provides the ability to enable and disable High Dynamic Range (HDR) analysis for the SceneAnalysisEffect .
 */
declare class Windows$Media$Core$HighDynamicRangeControl  {

/**
 * Gets or sets a value that specifies whether High Dynamic Range (HDR) analysis is enabled for the SceneAnalysisEffect .
 */
enabled: boolean
}


/**
 * Provides the results of a High Dynamic Range (HDR) analysis operation from the SceneAnalysisEffect .
 */
declare class Windows$Media$Core$HighDynamicRangeOutput  {

/**
 * Gets a value indicating the certainty of the results of the HDR analysis.
 */
certainty: number;

/**
 * Gets a set of FrameController objects representing the suggested frame controllers settings for capturing a variable photo sequence with the High Dynamic Range (HDR) technique.
 */
frameControllers: Windows$Foundation$Collections$IVectorView<Windows$Media$Devices$Core$FrameController>
}

declare class Windows$Media$Core$MediaBinder  {

/**
 * Initializes a new instance of the MediaBinder class.
 */
constructor(): this;

/**
 * Occurs when a media player is ready for the media content to be bound to a MediaSource . Use the handler for this to set the media content for the source by calling SetStream , SetStreamReference , or SetUri .
 */
onbinding: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaBinder, Windows$Media$Core$MediaBindingEventArgs>;
addEventListener(
type: "binding",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaBinder, Windows$Media$Core$MediaBindingEventArgs>): void;
removeEventListener(
type: "binding",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaBinder, Windows$Media$Core$MediaBindingEventArgs>): void;

/**
 * Gets the MediaSource object associated with the MediaBinder .
 */
source: Windows$Media$Core$MediaSource;

/**
 * Gets or sets an app-specified string that is used to identify the media content that the app should bind when the Binding event is raised.
 */
token: string;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}

declare class Windows$Media$Core$MediaBindingEventArgs  {

/**
 * Informs the system that the app might continue to perform work after the Binding event handler returns.
 * @return The requested deferral.
 */
getDeferral(): Windows$Foundation$Deferral;

/**
 * Gets the MediaBinder associated with the binding event.
 */
mediaBinder: Windows$Media$Core$MediaBinder;

/**
 * Occurs when the binding operation is cancelled.
 */
oncanceled: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaBindingEventArgs, any>;
addEventListener(
type: "canceled",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaBindingEventArgs, any>): void;
removeEventListener(
type: "canceled",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaBindingEventArgs, any>): void;

/**
 * Sets the media content to be bound to the MediaSource .
 * @param stream A stream containing the media content.
 * @param contentType A string specifying the content type of the media content.
 */
setStream(stream: Windows$Storage$Streams$IRandomAccessStream, contentType: string): void;

/**
 * Sets the media content to be bound to the MediaSource .
 * @param stream A stream reference containing the media content to be bound.
 * @param contentType A string specifying the content type of the media content.
 */
setStreamReference(
stream: Windows$Storage$Streams$IRandomAccessStreamReference,
contentType: string): void;

/**
 * Sets the URI of the media content to be bound to the MediaSource .
 * @param uri The URI of the media content to be bound.
 */
setUri(uri: Windows$Foundation$Uri): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the TimedMetadataTrack::CueEntered and TimedMetadataTrack::CueExited events.
 */
declare class Windows$Media$Core$MediaCueEventArgs  {

/**
 * Gets the cue that triggered the event.
 */
cue: Windows$Media$Core$IMediaCue
}


/**
 * Represents a media source. Provides a common way to reference media from different sources and exposes a common model for accessing media data regardless of the underlying media format.
 */
declare class Windows$Media$Core$MediaSource  {

/**
 * Creates an instance of MediaSource from the provided AdaptiveMediaSource .
 * @param mediaSource The AdaptiveMediaSource from which the MediaSource is created.
 * @return The new media source.
 */
static createFromAdaptiveMediaSource(
mediaSource: Windows$Media$Streaming$Adaptive$AdaptiveMediaSource): Windows$Media$Core$MediaSource;

/**
 * Creates an instance of MediaSource from the provided IMediaSource .
 * @param mediaSource The IMediaSource from which the MediaSource is created.
 * @return The new media source.
 */
static createFromIMediaSource(mediaSource: Windows$Media$Core$IMediaSource): Windows$Media$Core$MediaSource;

/**
 * Creates an instance of MediaSource from the provided MediaBinder .
 * @param binder The MediaBinder with which the MediaSource is associated.
 * @return The new media source.
 */
static createFromMediaBinder(binder: Windows$Media$Core$MediaBinder): Windows$Media$Core$MediaSource;

/**
 * Creates an instance of MediaSource from the provided MediaStreamSource .
 * @param mediaSource The MediaStreamSource from which the MediaSource is created.
 * @return The new media source.
 */
static createFromMediaStreamSource(
mediaSource: Windows$Media$Core$MediaStreamSource): Windows$Media$Core$MediaSource;

/**
 * Creates an instance of MediaSource from the provided MseStreamSource .
 * @param mediaSource The MediaStreamSource from which the MediaSource is created.
 * @return The new media source.
 */
static createFromMseStreamSource(
mediaSource: Windows$Media$Core$MseStreamSource): Windows$Media$Core$MediaSource;

/**
 * Creates an instance of MediaSource from the provided IStorageFile .
 * @param file The IStorageFile from which the MediaSource is created.
 * @return The new media source.
 */
static createFromStorageFile(file: Windows$Storage$IStorageFile): Windows$Media$Core$MediaSource;

/**
 * Creates an instance of MediaSource from the provided IRandomAccessStream .
 * @param stream The stream from which the MediaSource is created.
 * @param contentType The MIME type of the contents of the stream.
 * @return The new media source.
 */
static createFromStream(
stream: Windows$Storage$Streams$IRandomAccessStream,
contentType: string): Windows$Media$Core$MediaSource;

/**
 * Creates an instance of MediaSource from the provided IRandomAccessStreamReference .
 * @param stream The stream reference from which the MediaSource is created.
 * @param contentType The MIME type of the contents of the stream.
 * @return The new media source.
 */
static createFromStreamReference(
stream: Windows$Storage$Streams$IRandomAccessStreamReference,
contentType: string): Windows$Media$Core$MediaSource;

/**
 * Creates an instance of MediaSource from the provided Uri .
 * @param uri The URI from which the MediaSource is created.
 * @return The new media source.
 */
static createFromUri(uri: Windows$Foundation$Uri): Windows$Media$Core$MediaSource;

/**
 * Closes the MediaSource .
 */
close(): void;

/**
 * Gets a set of properties that can be used to associate app-specific data with a MediaSource .
 */
customProperties: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the duration of the content in the MediaSource .
 */
duration: number;

/**
 * A collection of external timed metadata tracks associated with the MediaSource .
 */
externalTimedMetadataTracks: Windows$Foundation$Collections$IObservableVector<Windows$Media$Core$TimedMetadataTrack>;

/**
 * A collection of external timed text sources associated with the MediaSource .
 */
externalTimedTextSources: Windows$Foundation$Collections$IObservableVector<Windows$Media$Core$TimedTextSource>;

/**
 * Gets a value indicating whether the media source is currently open.
 */
isOpen: boolean;

/**
 * Occurs when a MediaSource open operation completes.
 */
onopenoperationcompleted: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaSource, Windows$Media$Core$MediaSourceOpenOperationCompletedEventArgs>;
addEventListener(
type: "openoperationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaSource, Windows$Media$Core$MediaSourceOpenOperationCompletedEventArgs>): void;
removeEventListener(
type: "openoperationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaSource, Windows$Media$Core$MediaSourceOpenOperationCompletedEventArgs>): void;

/**
 * Occurs when the current state of the MediaSource changes.
 */
onstatechanged: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaSource, Windows$Media$Core$MediaSourceStateChangedEventArgs>;
addEventListener(
type: "statechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaSource, Windows$Media$Core$MediaSourceStateChangedEventArgs>): void;
removeEventListener(
type: "statechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaSource, Windows$Media$Core$MediaSourceStateChangedEventArgs>): void;

/**
 * Resets the internal state of the MediaSource .
 */
reset(): void;

/**
 * Gets the current state of the MediaSource .
 */
state: $Values<typeof Windows$Media$Core$MediaSourceState>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents an error that occurred with a MediaSource .
 */
declare class Windows$Media$Core$MediaSourceError  {

/**
 * Gets the extended error code for the MediaSourceError .
 */
extendedError: Windows$WinRTError
}


/**
 * Provides data for the MediaSource::MediaSourceOpenOperationCompleted event.
 */
declare class Windows$Media$Core$MediaSourceOpenOperationCompletedEventArgs  {

/**
 * Represents the error that occurred while asynchronously opening the MediaSource .
 */
error: Windows$Media$Core$MediaSourceError
}


/**
 * Specifies the state of a MediaSource .
 */

declare  var Windows$Media$Core$MediaSourceState: {|
  +initial: 0,// 0
+opening: 1,// 1
+opened: 2,// 2
+failed: 3,// 3
+closed: 4,// 4

|};


declare class Windows$Media$Core$MediaSourceStateChangedEventArgs  {

/**
 * Gets the new current state of the MediaSource .
 */
newState: $Values<typeof Windows$Media$Core$MediaSourceState>;

/**
 * Gets the previous state of the MediaSource before the state changed.
 */
oldState: $Values<typeof Windows$Media$Core$MediaSourceState>
}


/**
 * Represents a media sample used by the MediaStreamSource .
 */
declare class Windows$Media$Core$MediaStreamSample  {

/**
 * Creates a MediaStreamSample from an IBuffer .
 * @param buffer The buffer that contains the media data used to create the MediaStreamSample .
 * @param timestamp The presentation time of this sample.
 * @return The sample created from the data in buffer.
 */
static createFromBuffer(
buffer: Windows$Storage$Streams$IBuffer,
timestamp: number): Windows$Media$Core$MediaStreamSample;

/**
 * Asynchronously creates a MediaStreamSample from an IInputStream .
 * @param stream The stream that contains the media data used to create the MediaStreamSample .
 * @param count The length of the data in the sample. This is the number of bytes that will be read from stream.
 * @param timestamp The presentation time of this MediaStreamSample .
 * @return When this method completes, it returns the new file as a MediaStreamSample .
 */
static createFromStreamAsync(
stream: Windows$Storage$Streams$IInputStream,
count: number,
timestamp: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Core$MediaStreamSample>;

/**
 * Gets the buffer which encapsulates the MediaStreamSample data.
 */
buffer: Windows$Storage$Streams$Buffer;

/**
 * Gets and sets the decode timestamp for this MediaStreamSample .
 */
decodeTimestamp: number;

/**
 * Gets or sets a value to indicate that the previous MediaStreamSample in the sequence is missing.
 */
discontinuous: boolean;

/**
 * Gets the duration of the sample.
 */
duration: number;

/**
 * Gets the extended property set which enables getting and setting properties on the MediaStreamSample .
 */
extendedProperties: Windows$Media$Core$MediaStreamSamplePropertySet;

/**
 * Gets or sets a value that indicates the MediaStreamSample contains a keyframe.
 */
keyFrame: boolean;

/**
 * Occurs when the MediaStreamSample has been processed by the media pipeline.
 */
onprocessed: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSample, any>;
addEventListener(
type: "processed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSample, any>): void;
removeEventListener(
type: "processed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSample, any>): void;

/**
 * Gets a MediaStreamSampleProtectionProperties object, which is used for getting and setting properties that are specific to the Digital Rights Management (DRM) protection of the MediaStreamSample .
 */
protection: Windows$Media$Core$MediaStreamSampleProtectionProperties;

/**
 * Gets the time at which a sample should be rendered. This is also referred to as the presentation time.
 */
timestamp: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Contains properties for the MediaStreamSample .
 */
declare class Windows$Media$Core$MediaStreamSamplePropertySet  {

/**
 * Removes all items from the property set.
 */
clear(): void;

/**
 * Returns an iterator to enumerate the items in the property set.
 * @return The iterator. The current position of the iterator is index 0, or the end of the property set if the property set is empty.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Gets an immutable view of the property set.
 * @return The immutable view.
 */
getView(): Windows$Foundation$Collections$IMapView<string, any>;

/**
 * Indicates if the specified key exists in the property set.
 * @param key The key to check.
 * @return true if the key exists; otherwise, false.
 */
hasKey(key: string): boolean;

/**
 * Adds the specified key and value to the property set.
 * @param key The key to add.
 * @param value The value of the key.
 * @return True if the method replaces a value that already exists for the key; false if this is a new key.
 */
insert(key: string, value: any): boolean;

/**
 * Retrieves the value for the specified key.
 * @param key The key to retrieve the value for.
 * @return The value, if an item with the specified key exists; otherwise, null.
 */
lookup(key: string): any;

/**
 * Removes an item from the property set.
 * @param key The key to remove.
 */
remove(key: string): void;

/**
 * Gets the number of items contained in the property set.
 */
size: number
}


/**
 * Represents a collection properties that are specific to the Digital Rights Management (DRM) protection of the MediaStreamSample .
 */
declare class Windows$Media$Core$MediaStreamSampleProtectionProperties  {

/**
 * Gets the Digital Rights Management (DRM) initialization vector from the MediaStreamSample .
 * @return The initialization vector.
 */
getInitializationVector(): number[];

/**
 * Gets the Digital Rights Management (DRM) key identifier from the MediaStreamSample .
 * @return Receives the key identifier used to decrypt the data.
 */
getKeyIdentifier(): number[];

/**
 * Gets the Digital Rights Management (DRM) sub-sample mapping from the MediaStreamSample .
 * @return Receives the sub-sample mapping.
 */
getSubSampleMapping(): number[];

/**
 * Sets the Digital Rights Management (DRM) initialization vector for the MediaStreamSample .
 * @param value The value to set the DRM initialization vector to.
 */
setInitializationVector(value: number[]): void;

/**
 * Sets the Digital Rights Management (DRM) key identifier for the MediaStreamSample .
 * @param value The value to set the DRM key identifier to.
 */
setKeyIdentifier(value: number[]): void;

/**
 * Sets the Digital Rights Management (DRM) sub-sample mapping for the MediaStreamSample .
 * @param value The value to set the DRM sub-sample mapping to.
 */
setSubSampleMapping(value: number[]): void
}


/**
 * Represents a media source that delivers media samples directly to the media pipeline.
 */
declare class Windows$Media$Core$MediaStreamSource  {

/**
 * Creates an instance of MediaStreamSource from the specified IMediaStreamDescriptor .
 * @param descriptor The AudioStreamDescriptor or VideoStreamDescriptor to create the MediaStreamSource from.
 */
constructor(descriptor: Windows$Media$Core$IMediaStreamDescriptor): this;

/**
 * Creates an instance of MediaStreamSource from two IMediaStreamDescriptor objects.
 * @param descriptor The first AudioStreamDescriptor or VideoStreamDescriptor to create the MediaStreamSource from.
 * @param descriptor2 The second AudioStreamDescriptor or VideoStreamDescriptor to create the MediaStreamSource from.
 */
constructor(descriptor: Windows$Media$Core$IMediaStreamDescriptor, descriptor2: Windows$Media$Core$IMediaStreamDescriptor): this;

/**
 * Adds a Digital Rights Management (DRM) protection key which is used by the MediaProtectionManager to encrypt and decrypt the specified stream.
 * @param streamDescriptor The stream the key is used to encrypt and decrypt.
 * @param keyIdentifier The key used to encrypt and decrypt the stream.
 * @param licenseData The DRM licence for the media.
 */
addProtectionKey(
streamDescriptor: Windows$Media$Core$IMediaStreamDescriptor,
keyIdentifier: number[],
licenseData: number[]): void;

/**
 * Adds a new stream descriptor to the MediaStreamSource .
 * @param descriptor The descriptor to add.
 */
addStreamDescriptor(descriptor: Windows$Media$Core$IMediaStreamDescriptor): void;

/**
 * Gets or sets the amount of data that is buffered by the MediaStreamSource .
 */
bufferTime: number;

/**
 * Gets or sets whether or not the application supports changing its position in the media time-line.
 */
canSeek: boolean;

/**
 * Gets or sets the duration of the media time-line.
 */
duration: number;

/**
 * Gets or sets the Digital Rights Management (DRM) MediaProtectionManager used to protect the media.
 */
mediaProtectionManager: Windows$Media$Protection$MediaProtectionManager;

/**
 * Gets the music properties which are used for musicrelated metadata.
 */
musicProperties: Windows$Storage$FileProperties$MusicProperties;

/**
 * Notifies the MediaStreamSource that an error has occurred which is preventing the application from continuing to deliver data to the MediaStreamSource.
 * @param errorStatus The cause of the error.
 */
notifyError(
errorStatus: $Values<typeof Windows$Media$Core$MediaStreamSourceErrorStatus>): void;

/**
 * Occurs when the MediaStreamSource is shutting down.
 */
onclosed: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSource, Windows$Media$Core$MediaStreamSourceClosedEventArgs>;
addEventListener(
type: "closed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSource, Windows$Media$Core$MediaStreamSourceClosedEventArgs>): void;
removeEventListener(
type: "closed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSource, Windows$Media$Core$MediaStreamSourceClosedEventArgs>): void;

/**
 * Occurs when the MediaStreamSource is paused and stops requesting MediaStreamSample objects for an unspecified period of time, but is expected to resume requesting MediaStreamSample objects from the current position.
 */
onpaused: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSource, any>;
addEventListener(
type: "paused",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSource, any>): void;
removeEventListener(
type: "paused",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSource, any>): void;

/**
 * Occurs when the MediaStreamSource request a MediaStreamSample for a specified stream.
 */
onsamplerequested: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSource, Windows$Media$Core$MediaStreamSourceSampleRequestedEventArgs>;
addEventListener(
type: "samplerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSource, Windows$Media$Core$MediaStreamSourceSampleRequestedEventArgs>): void;
removeEventListener(
type: "samplerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSource, Windows$Media$Core$MediaStreamSourceSampleRequestedEventArgs>): void;

/**
 * Occurs when the MediaStreamSource is ready to start requesting MediaStreamSample objects. The event can specify a position in the media time-line from which the first MediaStreamSample should be delivered.
 */
onstarting: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSource, Windows$Media$Core$MediaStreamSourceStartingEventArgs>;
addEventListener(
type: "starting",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSource, Windows$Media$Core$MediaStreamSourceStartingEventArgs>): void;
removeEventListener(
type: "starting",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSource, Windows$Media$Core$MediaStreamSourceStartingEventArgs>): void;

/**
 * Occurs when the MediaStreamSource will stop requesting MediaStreamSample objects for a certain stream and will start requesting MediaStreamSample objects from a different stream instead.
 */
onswitchstreamsrequested: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSource, Windows$Media$Core$MediaStreamSourceSwitchStreamsRequestedEventArgs>;
addEventListener(
type: "switchstreamsrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSource, Windows$Media$Core$MediaStreamSourceSwitchStreamsRequestedEventArgs>): void;
removeEventListener(
type: "switchstreamsrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$MediaStreamSource, Windows$Media$Core$MediaStreamSourceSwitchStreamsRequestedEventArgs>): void;

/**
 * Sets the range of data that the application is currently buffering.
 * @param startOffset The smallest time stamp of a MediaStreamSample buffered by the application.
 * @param endOffset The largest time stamp of a MediaStreamSample buffered by the application.
 */
setBufferedRange(startOffset: number, endOffset: number): void;

/**
 * Gets or sets the thumbnail which is a reference to a stream for a video thumbnail image or music album art.
 */
thumbnail: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets the video properties which are used for video related metadata.
 */
videoProperties: Windows$Storage$FileProperties$VideoProperties;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the MediaStreamSource.Closed event.
 */
declare class Windows$Media$Core$MediaStreamSourceClosedEventArgs  {

/**
 * Gets the object that represents the notification that the MediaStreamSource has been closed.
 */
request: Windows$Media$Core$MediaStreamSourceClosedRequest
}


/**
 * Specifies the reason why a MediaStreamSource was closed.
 */

declare  var Windows$Media$Core$MediaStreamSourceClosedReason: {|
  +done: 0,// 0
+unknownError: 1,// 1
+appReportedError: 2,// 2
+unsupportedProtectionSystem: 3,// 3
+protectionSystemFailure: 4,// 4
+unsupportedEncodingFormat: 5,// 5
+missingSampleRequestedEventHandler: 6,// 6

|};



/**
 * Represents an object to be used by the MediaStreamSource.closed event to provide information to the application.
 */
declare class Windows$Media$Core$MediaStreamSourceClosedRequest  {

/**
 * Gets the reason why the media stream source was closed.
 */
reason: $Values<typeof Windows$Media$Core$MediaStreamSourceClosedReason>
}


/**
 * Specifies errors related to MediaStreamSource .
 */

declare  var Windows$Media$Core$MediaStreamSourceErrorStatus: {|
  +other: 0,// 0
+outOfMemory: 1,// 1
+failedToOpenFile: 2,// 2
+failedToConnectToServer: 3,// 3
+connectionToServerLost: 4,// 4
+unspecifiedNetworkError: 5,// 5
+decodeError: 6,// 6
+unsupportedMediaFormat: 7,// 7

|};



/**
 * Represents an object to be used by the MediaStreamSource.SampleRequest event to provide information to the application.
 */
declare class Windows$Media$Core$MediaStreamSourceSampleRequest  {

/**
 * Defers assigning a MediaStreamSample to MediaStreamSourceSampleRequest object.
 * @return The deferral.
 */
getDeferral(): Windows$Media$Core$MediaStreamSourceSampleRequestDeferral;

/**
 * Provides a status update to the MediaStreamSource while the application is temporarily unable to deliver a requested MediaStreamSample .
 * @param progress A value between 0 to 100 that indicates the progress towards being able to deliver the requested MediaStreamSample .
 */
reportSampleProgress(progress: number): void;

/**
 * Sets the MediaStreamSample requested by the MediaStreamSource . Applications deliver a MediaStreamSample to the MediaStreamSource by assigning a value to this property.
 */
sample: Windows$Media$Core$MediaStreamSample;

/**
 * Gets the IMediaStreamDescriptor interface of the stream for which a MediaStreamSample is being requested.
 */
streamDescriptor: Windows$Media$Core$IMediaStreamDescriptor
}


/**
 * Provides a way for the application to asynchronously report that it has completed retrieving the MediaStreamSample .
 */
declare class Windows$Media$Core$MediaStreamSourceSampleRequestDeferral  {

/**
 * Reports that the application has completed retrieving the MediaStreamSample .
 */
complete(): void
}


/**
 * Provides the data for the SampleRequested event.
 */
declare class Windows$Media$Core$MediaStreamSourceSampleRequestedEventArgs  {

/**
 * Gets the object that represents the request for a MediaStreamSample .
 */
request: Windows$Media$Core$MediaStreamSourceSampleRequest
}


/**
 * Provides data for the MediaStreamSource.Starting event.
 */
declare class Windows$Media$Core$MediaStreamSourceStartingEventArgs  {

/**
 * Gets the object that represents the request to start accumulating MediaStreamSample data.
 */
request: Windows$Media$Core$MediaStreamSourceStartingRequest
}


/**
 * Represents a request from the MediaStreamSource.Starting event for the application to start accumulating MediaStreamSample objects from a specific position in the media.
 */
declare class Windows$Media$Core$MediaStreamSourceStartingRequest  {

/**
 * Defers completing the MediaStreamSource.Starting event.
 * @return The deferral.
 */
getDeferral(): Windows$Media$Core$MediaStreamSourceStartingRequestDeferral;

/**
 * Specifies the starting position in the media time-line for subsequent MediaStreamSamples that will be delivered to the MediaStreamSource .
 * @param position The actual starting point in the media time-line chosen by the application.
 */
setActualStartPosition(position: number): void;

/**
 * Specifies a reference to a TimeSpan object which represents a time position in the media time-line from which the application should return MediaStreamSample objects.
 */
startPosition: number
}


/**
 * Provides a way for the application to asynchronously report that it has completed processing the MediaStreamSource.Starting event.
 */
declare class Windows$Media$Core$MediaStreamSourceStartingRequestDeferral  {

/**
 * Reports that the application has completed processing the Starting event.
 */
complete(): void
}


/**
 * Represents an object to be used by the MediaStreamSource.SwitchStreamsRequest event to provide information to the application.
 */
declare class Windows$Media$Core$MediaStreamSourceSwitchStreamsRequest  {

/**
 * Defers completing the MediaStreamSource.SwitchStreamsRequested event.
 * @return The deferral.
 */
getDeferral(): Windows$Media$Core$MediaStreamSourceSwitchStreamsRequestDeferral;

/**
 * Gets the stream descriptor for the stream that is now selected by the MediaStreamSource .
 */
newStreamDescriptor: Windows$Media$Core$IMediaStreamDescriptor;

/**
 * Gets the stream descriptor for the stream which is no longer selected by the MediaStreamSource .
 */
oldStreamDescriptor: Windows$Media$Core$IMediaStreamDescriptor
}


/**
 * Provides a way for the application to asynchronously report that it has completed the MediaStreamSource.SwitchStreamsRequested event.
 */
declare class Windows$Media$Core$MediaStreamSourceSwitchStreamsRequestDeferral  {

/**
 * Reports that the application has completed processing the MediaStreamSource.SwitchStreamsRequested event.
 */
complete(): void
}


/**
 * Provides data for the MediaStreamSource.SwitchStreamsRequested event.
 */
declare class Windows$Media$Core$MediaStreamSourceSwitchStreamsRequestedEventArgs  {

/**
 * Gets the object that represents the request to switch the streams.
 */
request: Windows$Media$Core$MediaStreamSourceSwitchStreamsRequest
}


/**
 * Specifies the type of a media track.
 */

declare  var Windows$Media$Core$MediaTrackKind: {|
  +audio: 0,// 0
+video: 1,// 1
+timedMetadata: 2,// 2

|};



/**
 * Represents an effect that analyzes video frames to determine if any of the supported variable photo sequence capture techniques may produce a higher-quality captured image.
 */
declare class Windows$Media$Core$SceneAnalysisEffect  {

/**
 * Gets or sets the duration of the time window during which video frames are analyzed.
 */
desiredAnalysisInterval: number;

/**
 * Gets or sets a HighDynamicRangeControl object that is used to enable or disable High Dynamic Range (HDR) analysis.
 */
highDynamicRangeAnalyzer: Windows$Media$Core$HighDynamicRangeControl;

/**
 * Raised when the scene analysis is complete.
 */
onsceneanalyzed: Windows$Foundation$TypedEventHandler<Windows$Media$Core$SceneAnalysisEffect, Windows$Media$Core$SceneAnalyzedEventArgs>;
addEventListener(
type: "sceneanalyzed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$SceneAnalysisEffect, Windows$Media$Core$SceneAnalyzedEventArgs>): void;
removeEventListener(
type: "sceneanalyzed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$SceneAnalysisEffect, Windows$Media$Core$SceneAnalyzedEventArgs>): void;

/**
 * Sets properties on the IMediaExtension .
 * @param configuration The property set.
 */
setProperties(configuration: Windows$Foundation$Collections$IPropertySet): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the definition of a scene analysis video effect.
 */
declare class Windows$Media$Core$SceneAnalysisEffectDefinition  {

/**
 * Initializes a new instance of the SceneAnalysisEffectDefinition class.
 */
constructor(): this;

/**
 * Gets a string containing the activatable class ID of the scene analysis effect definition.
 */
activatableClassId: string;

/**
 * Gets the set of properties for configuring the SceneAnalysisEffectDefinition object.
 */
properties: Windows$Foundation$Collections$IPropertySet
}


/**
 * Represents a video frame that includes the results of the scene analysis operation.
 */
declare class Windows$Media$Core$SceneAnalysisEffectFrame  {

/**
 * Disposes of the object and associated resources.
 */
close(): void;

/**
 * Gets or sets the duration of the scene analysis effect frame.
 */
duration: number;

/**
 * Gets the extended property set which enables getting and setting properties on the media frame.
 */
extendedProperties: Windows$Foundation$Collections$IPropertySet;

/**
 * Gets a CapturedFrameControlValues object that indicates the capture settings used for the frame.
 */
frameControlValues: Windows$Media$Capture$CapturedFrameControlValues;

/**
 * Gets a HighDynamicRangeOutput object that provides recommended FrameController objects and a value indicating the certainty of the HDR analysis.
 */
highDynamicRange: Windows$Media$Core$HighDynamicRangeOutput;

/**
 * Gets or sets a value that indicates whether a video frame is the first frame after a gap in the stream.
 */
isDiscontinuous: boolean;

/**
 * Gets a value indicating whether the frame is read-only.
 */
isReadOnly: boolean;

/**
 * Gets or sets the relative time of the frame within the video stream.
 */
relativeTime: number;

/**
 * Gets or sets a timestamp that is relative to the system and is correlatable across multiple media sources on the same device.
 */
systemRelativeTime: number;

/**
 * Gets a string indicating the type of data the frame contains.
 */
type: string
}


/**
 * Provides data for the SceneAnalysisEffect::SceneAnalyzed event.
 */
declare class Windows$Media$Core$SceneAnalyzedEventArgs  {

/**
 * Gets the result frame from the scene analysis operation.
 */
resultFrame: Windows$Media$Core$SceneAnalysisEffectFrame
}


/**
 * Specifies the types of metadata that may be present in a TimedMetadataTrack .
 */

declare  var Windows$Media$Core$TimedMetadataKind: {|
  +caption: 0,// 0
+chapter: 1,// 1
+custom: 2,// 2
+data: 3,// 3
+description: 4,// 4
+subtitle: 5,// 5

|};



/**
 * Represents a timed metadata track. The track contains a list of IMediaCue objects and raises events at the beginning and end of the time window of each cue.
 */
declare class Windows$Media$Core$TimedMetadataTrack  {

/**
 * Initializes a new instance of the TimedMetadataTrack class.
 * @param id An identifier for the new timed metadata track.
 * @param language A string indicating the language of the new timed metadata track.
 * @param kind A value indicating the kind of metadata contained in the new track.
 */
constructor(id: string, language: string, kind: $Values<typeof Windows$Media$Core$TimedMetadataKind>): this;

/**
 * Gets the list of media cues in the TimedMetadataTrack that are currently active. A cue is considered active after its StartTime has been reached until its Duration has been exceeded.
 */
activeCues: Windows$Foundation$Collections$IVectorView<Windows$Media$Core$IMediaCue>;

/**
 * Adds the specified media cue to the TimedMetadataTrack .
 * @param cue The media cue to add.
 */
addCue(cue: Windows$Media$Core$IMediaCue): void;

/**
 * Gets a read-only list of the media cues in the TimedMetadataTrack .
 */
cues: Windows$Foundation$Collections$IVectorView<Windows$Media$Core$IMediaCue>;

/**
 * Gets the custom string value containing routing information for cues.
 */
dispatchType: string;

/**
 * Gets the identifier for the timed metadata track.
 */
id: string;

/**
 * Gets or sets the label for the timed metadata track.
 */
label: string;

/**
 * Gets a string indicating the language of the timed metadata track.
 */
language: string;

/**
 * Occurs when a media time window of a media cue is entered. The time window is defined by the StartTime and Duration of the cue.
 */
oncueentered: Windows$Foundation$TypedEventHandler<Windows$Media$Core$TimedMetadataTrack, Windows$Media$Core$MediaCueEventArgs>;
addEventListener(
type: "cueentered",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$TimedMetadataTrack, Windows$Media$Core$MediaCueEventArgs>): void;
removeEventListener(
type: "cueentered",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$TimedMetadataTrack, Windows$Media$Core$MediaCueEventArgs>): void;

/**
 * Occurs when a media time window of a media cue is exited. The time window is defined by the StartTime and Duration of the cue.
 */
oncueexited: Windows$Foundation$TypedEventHandler<Windows$Media$Core$TimedMetadataTrack, Windows$Media$Core$MediaCueEventArgs>;
addEventListener(
type: "cueexited",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$TimedMetadataTrack, Windows$Media$Core$MediaCueEventArgs>): void;
removeEventListener(
type: "cueexited",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$TimedMetadataTrack, Windows$Media$Core$MediaCueEventArgs>): void;

/**
 * Raised when an error occurs with the TimedMetadataTrack .
 */
ontrackfailed: Windows$Foundation$TypedEventHandler<Windows$Media$Core$TimedMetadataTrack, Windows$Media$Core$TimedMetadataTrackFailedEventArgs>;
addEventListener(
type: "trackfailed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$TimedMetadataTrack, Windows$Media$Core$TimedMetadataTrackFailedEventArgs>): void;
removeEventListener(
type: "trackfailed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$TimedMetadataTrack, Windows$Media$Core$TimedMetadataTrackFailedEventArgs>): void;

/**
 * Removes the specified media cue from the TimedMetadataTrack .
 * @param cue The media cue to remove.
 */
removeCue(cue: Windows$Media$Core$IMediaCue): void;

/**
 * Gets a value indicating the kind of metadata contained in the track.
 */
timedMetadataKind: $Values<typeof Windows$Media$Core$TimedMetadataKind>;

/**
 * Gets a value specifying the type of the media track. For TimedMetadataTrack this value will always be MediaTrackKind::TimedMetadata .
 */
trackKind: $Values<typeof Windows$Media$Core$MediaTrackKind>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides information about an error that occurred with a timed metadata track.
 */
declare class Windows$Media$Core$TimedMetadataTrackError  {

/**
 * Gets the error code associated with the timed metadata track error.
 */
errorCode: $Values<typeof Windows$Media$Core$TimedMetadataTrackErrorCode>;

/**
 * Gets the extended error code for the TimedMetadataTrackError .
 */
extendedError: Windows$WinRTError
}


/**
 * Specifies the type of error that occurred with a TimedMetadataTrack .
 */

declare  var Windows$Media$Core$TimedMetadataTrackErrorCode: {|
  +none: 0,// 0
+dataFormatError: 1,// 1
+networkError: 2,// 2
+internalError: 3,// 3

|};



/**
 * Provides data for the TimedMetadataTrack::TrackFailed event.
 */
declare class Windows$Media$Core$TimedMetadataTrackFailedEventArgs  {

/**
 * Gets an object representing the error that occurred with the timed metadata track.
 */
error: Windows$Media$Core$TimedMetadataTrackError
}


/**
 * Represents a text cue in a TimedMetadataTrack .
 */
declare class Windows$Media$Core$TimedTextCue  {

/**
 * Initializes a new instance of the TimedTextCue class.
 */
constructor(): this;

/**
 * Gets or sets the TimedTextRegion of the cue, which defines the style of the rendering area for the cue.
 */
cueRegion: Windows$Media$Core$TimedTextRegion;

/**
 * Gets or sets the TimedTextStyle of the cue, which defines the style of the rendered text.
 */
cueStyle: Windows$Media$Core$TimedTextStyle;

/**
 * Gets or sets the duration of the cue.
 */
duration: number;

/**
 * Gets or sets an identifier for the cue.
 */
id: string;

/**
 * Gets the collection of TimedTextLine objects that convey the text of the cue.
 */
lines: Windows$Foundation$Collections$IVector<Windows$Media$Core$TimedTextLine>;

/**
 * Gets the start time of the cue.
 */
startTime: number
}


/**
 * Specifies the alignment of a TimedTextRegion relative to the video frame.
 */

declare  var Windows$Media$Core$TimedTextDisplayAlignment: {|
  +before: 0,// 0
+after: 1,// 1
+center: 2,// 2

|};



/**
 * Specifies the direction timed text is flowed.
 */

declare  var Windows$Media$Core$TimedTextFlowDirection: {|
  +leftToRight: 0,// 0
+rightToLeft: 1,// 1

|};



/**
 * Represents a line of text that is displayed with a TimedTextCue .
 */
declare class Windows$Media$Core$TimedTextLine  {

/**
 * Initializes a new instance of the TimedTextLine class.
 */
constructor(): this;

/**
 * Gets a list of TimedTextSubformat objects that provide formatting for substrings within the TimedTextLine .
 */
subformats: Windows$Foundation$Collections$IVector<Windows$Media$Core$TimedTextSubformat>;

/**
 * Gets or sets the text content of the TimedTextLine .
 */
text: string
}


/**
 * Specifies the alignment of a TimedTextLine relative to the TimedTextRegion in which it is displayed.
 */

declare  var Windows$Media$Core$TimedTextLineAlignment: {|
  +start: 0,// 0
+end: 1,// 1
+center: 2,// 2

|};



/**
 * Exposes properties for customizing the appearance of the rendering area of a TimedTextCue .
 */
declare class Windows$Media$Core$TimedTextRegion  {

/**
 * Initializes a new instance of the TimedTextRegion class.
 */
constructor(): this;

/**
 * Gets or sets the background color of the TimedTextRegion .
 */
background: Windows$UI$Color;

/**
 * Gets or sets the display alignment of the TimedTextRegion .
 */
displayAlignment: $Values<typeof Windows$Media$Core$TimedTextDisplayAlignment>;

/**
 * Gets or sets the extent of the TimedTextRegion , which is the rendered size of the region either in pixels or in percentage of available space.
 */
extent: Windows$Media$Core$TimedTextSize;

/**
 * Gets or sets a value indicating whether text overflowing the region is clipped.
 */
isOverflowClipped: boolean;

/**
 * Gets or sets a value that indicates the height of each line of content.
 */
lineHeight: Windows$Media$Core$TimedTextDouble;

/**
 * Gets or sets a string representing the name of the TimedTextRegion .
 */
name: string;

/**
 * Gets or sets a value that indicates the thickness of padding space between the boundaries of the content area and the content displayed by a TimedTextRegion .
 */
padding: Windows$Media$Core$TimedTextPadding;

/**
 * Gets or sets the position of the TimedTextRegion , relative to the top left corner of the video frame.
 */
position: Windows$Media$Core$TimedTextPoint;

/**
 * Gets a value indicating the method in which lines of text scroll through the region.
 */
scrollMode: $Values<typeof Windows$Media$Core$TimedTextScrollMode>;

/**
 * Gets or sets a value indicating whether text wraps when it reaches the edge of the TimedTextRegion .
 */
textWrapping: $Values<typeof Windows$Media$Core$TimedTextWrapping>;

/**
 * Gets or sets a value indicating the direction that text flows within the TimedTextRegion .
 */
writingMode: $Values<typeof Windows$Media$Core$TimedTextWritingMode>;

/**
 * Gets or sets the Z-order of the TimedTextRegion , relative to other active regions on the screen, in case they overlap.
 */
zindex: number
}


/**
 * Specifies the method in which lines of text scroll through the region.
 */

declare  var Windows$Media$Core$TimedTextScrollMode: {|
  +popon: 0,// 0
+rollup: 1,// 1

|};



/**
 * Represents a source of timed text data.
 */
declare class Windows$Media$Core$TimedTextSource  {

/**
 * Creates a new instance of TimedTextSource from the provided stream.
 * @param stream The stream from which the timed text source is created.
 * @return The new timed text source.
 */
static createFromStream(
stream: Windows$Storage$Streams$IRandomAccessStream): Windows$Media$Core$TimedTextSource;

/**
 * Creates a new instance of TimedTextSource with the specified default language from the provided stream.
 * @param stream The stream from which the timed text source is created.
 * @param defaultLanguage A string specifying the default language for the timed text source.
 * @return The new timed text source.
 */
static createFromStream(
stream: Windows$Storage$Streams$IRandomAccessStream,
defaultLanguage: string): Windows$Media$Core$TimedTextSource;

/**
 * Creates a new instance of TimedTextSource from the provided URI.
 * @param uri The URI from which the timed text source is created.
 * @return The new timed text source.
 */
static createFromUri(uri: Windows$Foundation$Uri): Windows$Media$Core$TimedTextSource;

/**
 * Creates a new instance of TimedTextSource with the specified default language from the provided URI.
 * @param uri The URI from which the timed text source is created.
 * @param defaultLanguage A string specifying the default language for the timed text source.
 * @return The new timed text source.
 */
static createFromUri(
uri: Windows$Foundation$Uri,
defaultLanguage: string): Windows$Media$Core$TimedTextSource;

/**
 * Occurs when the TimedTextSource is resolved.
 */
onresolved: Windows$Foundation$TypedEventHandler<Windows$Media$Core$TimedTextSource, Windows$Media$Core$TimedTextSourceResolveResultEventArgs>;
addEventListener(
type: "resolved",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$TimedTextSource, Windows$Media$Core$TimedTextSourceResolveResultEventArgs>): void;
removeEventListener(
type: "resolved",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$TimedTextSource, Windows$Media$Core$TimedTextSourceResolveResultEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the TimedTextSource::Resolved event.
 */
declare class Windows$Media$Core$TimedTextSourceResolveResultEventArgs  {

/**
 * Gets an object representing the asynchronous error that occurred when the TimedTextSource was resolved.
 */
error: Windows$Media$Core$TimedMetadataTrackError;

/**
 * Gets the list of TimedMetadataTrack objects resulting from resolving the TimedTextSource .
 */
tracks: Windows$Foundation$Collections$IVectorView<Windows$Media$Core$TimedMetadataTrack>
}


/**
 * Defines the style of the rendered text in a TimedTextCue . You can set the style of a substring within a TimedTextLine by using the Subformats property.
 */
declare class Windows$Media$Core$TimedTextStyle  {

/**
 * Initializes a new instance of the TimedTextStyle class.
 */
constructor(): this;

/**
 * Gets or sets the background color of timed text.
 */
background: Windows$UI$Color;

/**
 * Gets or sets a value indicating the direction that timed text is flowed.
 */
flowDirection: $Values<typeof Windows$Media$Core$TimedTextFlowDirection>;

/**
 * Gets or sets the font family of timed text.
 */
fontFamily: string;

/**
 * Gets or sets the font size of timed text.
 */
fontSize: Windows$Media$Core$TimedTextDouble;

/**
 * Gets or sets the weight of timed text.
 */
fontWeight: $Values<typeof Windows$Media$Core$TimedTextWeight>;

/**
 * Gets or sets the color of the timed text glyphs.
 */
foreground: Windows$UI$Color;

/**
 * Gets or sets a value indicating if the background color stays visible when no text is being displayed.
 */
isBackgroundAlwaysShown: boolean;

/**
 * Gets or sets the alignment of timed text lines.
 */
lineAlignment: $Values<typeof Windows$Media$Core$TimedTextLineAlignment>;

/**
 * Gets or sets the name of the timed text style.
 */
name: string;

/**
 * Gets or sets the outline color of timed text.
 */
outlineColor: Windows$UI$Color;

/**
 * Gets or sets the radius of the blur applied to outline of the timed text.
 */
outlineRadius: Windows$Media$Core$TimedTextDouble;

/**
 * Gets or sets the thickness of the outline of the timed text.
 */
outlineThickness: Windows$Media$Core$TimedTextDouble
}


/**
 * Defines a TimedTextStyle for a substring in a TimedTextLine . of the cue, which defines the style of the rendered text.
 */
declare class Windows$Media$Core$TimedTextSubformat  {

/**
 * Initializes a new instance of the TimedTextSubformat class.
 */
constructor(): this;

/**
 * Gets or sets the length of the substring to which the SubformatStyle applies.
 */
length: number;

/**
 * Gets or sets the staring index of the substring to which the SubformatStyle applies.
 */
startIndex: number;

/**
 * Gets or sets the TimedTextStyle object that conveys the formatting of a substring in a TimedTextLine .
 */
subformatStyle: Windows$Media$Core$TimedTextStyle
}


/**
 * Specifies the units in which timed a timed text style value is expressed.
 */

declare  var Windows$Media$Core$TimedTextUnit: {|
  +pixels: 0,// 0
+percentage: 1,// 1

|};



/**
 * Specifies the weight of timed text.
 */

declare  var Windows$Media$Core$TimedTextWeight: {|
  +normal: 0,// 0
+bold: 1,// 1

|};



/**
 * Specifies the wrapping behavior of timed text.
 */

declare  var Windows$Media$Core$TimedTextWrapping: {|
  +noWrap: 0,// 0
+wrap: 1,// 1

|};



/**
 * Specifies the direction timed text is written.
 */

declare  var Windows$Media$Core$TimedTextWritingMode: {|
  +leftRightTopBottom: 0,// 0
+rightLeftTopBottom: 1,// 1
+topBottomRightLeft: 2,// 2
+topBottomLeftRight: 3,// 3
+leftRight: 4,// 4
+rightLeft: 5,// 5
+topBottom: 6,// 6

|};



/**
 * Represents an effect that stabilizes a video stream.
 */
declare class Windows$Media$Core$VideoStabilizationEffect  {

/**
 * Gets or sets a value indicating whether video stabilization is enabled.
 */
enabled: boolean;

/**
 * Gets the recommended video stream configuration for video stabilization, given the specified video device controller and encoding properties.
 * @param controller The video device controller.
 * @param desiredProperties The encoding properties.
 * @return An object representing the optimal video stream configuration for video stabilization.
 */
getRecommendedStreamConfiguration(
controller: Windows$Media$Devices$VideoDeviceController,
desiredProperties: Windows$Media$MediaProperties$VideoEncodingProperties): Windows$Media$Capture$VideoStreamConfiguration;

/**
 * Occurs when the value of the VideoStabilizationEffect::Enabled property changes.
 */
onenabledchanged: Windows$Foundation$TypedEventHandler<Windows$Media$Core$VideoStabilizationEffect, Windows$Media$Core$VideoStabilizationEffectEnabledChangedEventArgs>;
addEventListener(
type: "enabledchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$VideoStabilizationEffect, Windows$Media$Core$VideoStabilizationEffectEnabledChangedEventArgs>): void;
removeEventListener(
type: "enabledchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$VideoStabilizationEffect, Windows$Media$Core$VideoStabilizationEffectEnabledChangedEventArgs>): void;

/**
 * Sets properties on the IMediaExtension .
 * @param configuration The property set.
 */
setProperties(configuration: Windows$Foundation$Collections$IPropertySet): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the definition of a video stabilization effect.
 */
declare class Windows$Media$Core$VideoStabilizationEffectDefinition  {

/**
 * Initializes a new instance of the VideoStabilizationEffectDefinition class.
 */
constructor(): this;

/**
 * Gets a string containing the activatable class ID of the video stabilization effect definition.
 */
activatableClassId: string;

/**
 * Gets the set of properties for configuring the VideoStabilizationEffectDefinition object.
 */
properties: Windows$Foundation$Collections$IPropertySet
}


/**
 * Provides data for the VideoStabilizationEffect::EnabledChanged event.
 */
declare class Windows$Media$Core$VideoStabilizationEffectEnabledChangedEventArgs  {

/**
 * Gets a value indicating the reason why the VideoStabilizationEffect::Enabled property changed.
 */
reason: $Values<typeof Windows$Media$Core$VideoStabilizationEffectEnabledChangedReason>
}


/**
 * Specifies the reason why the VideoStabilizationEffect::Enabled property changed.
 */

declare  var Windows$Media$Core$VideoStabilizationEffectEnabledChangedReason: {|
  +programmatic: 0,// 0
+pixelRateTooHigh: 1,// 1
+runningSlowly: 2,// 2

|};



/**
 * Defines an video media stream.
 */
declare class Windows$Media$Core$VideoStreamDescriptor  {

/**
 * Creates an instance of the VideoEncodingProperties class using the specified video encoding.
 * @param encodingProperties The encoding properties for the video stream.
 */
constructor(encodingProperties: Windows$Media$MediaProperties$VideoEncodingProperties): this;

/**
 * Gets the encoding properties on the video stream.
 */
encodingProperties: Windows$Media$MediaProperties$VideoEncodingProperties;

/**
 * Specifies whether the stream is currently in use by the MediaStreamSource .
 */
isSelected: boolean;

/**
 * Gets or sets the RFC-1766 language code for the stream.
 */
language: string;

/**
 * Gets or sets the name of the stream.
 */
name: string
}


/**
 * Represents a video track.
 */
declare class Windows$Media$Core$VideoTrack  {

/**
 * Gets or sets the identifier for the video track.
 */
id: string;

/**
 * Gets or sets the label for the video track.
 */
label: string;

/**
 * Gets or sets a string indicating the language of the video track.
 */
language: string;

/**
 * Gets a value indicating the type of data the track contains. For VideoTrack objects, this value is always MediaTrackKind::Video .
 */
trackKind: $Values<typeof Windows$Media$Core$MediaTrackKind>
}


/**
 * Represents a media source that delivers media samples to a media pipeline.
 */
declare interface Windows$Media$Core$IMediaSource {} 


/**
 * Defines the interface implemented by all media cues.
 */
declare interface Windows$Media$Core$IMediaCue {

/**
 * Gets or sets the duration of the media cue.
 */
duration: number,

/**
 * Gets or sets the identifier for the media cue.
 */
id: string,

/**
 * Gets or sets the start time of the media cue.
 */
startTime: number
} 


/**
 * Defines a media stream.
 */
declare interface Windows$Media$Core$IMediaStreamDescriptor {

/**
 * Specifies whether the stream is currently in use by the MediaStreamSource .
 */
isSelected: boolean,

/**
 * Gets or sets the RFC-1766 language code for the stream.
 */
language: string,

/**
 * Gets or sets the name of the stream.
 */
name: string
} 


/**
 * Represents a size that is used to convey the values of timed text style properties.
 */
declare interface Windows$Media$Core$TimedTextSize {

/**
 * The height.
 */
height: number,

/**
 * The units of the size, either pixels or percentage.
 */
unit: $Values<typeof Windows$Media$Core$TimedTextUnit>,

/**
 * The width.
 */
width: number
} 


/**
 * Represents a floating point value that is used to convey the values of timed text style properties.
 */
declare interface Windows$Media$Core$TimedTextDouble {

/**
 * The units of the value, either pixels or percentage.
 */
unit: $Values<typeof Windows$Media$Core$TimedTextUnit>,

/**
 * The value.
 */
value: number
} 


/**
 * Represents the size of padding around a timed text region.
 */
declare interface Windows$Media$Core$TimedTextPadding {

/**
 * The padding after the timed text region.
 */
after: number,

/**
 * The padding before the timed text region.
 */
before: number,

/**
 * The padding towards the end of the timed text.
 */
end: number,

/**
 * The padding towards the start of the timed text.
 */
start: number,

/**
 * The units in which the other members of the structure are expressed.
 */
unit: $Values<typeof Windows$Media$Core$TimedTextUnit>
} 


/**
 * Represents 2D coordinate that is used to convey the values of timed text style properties.
 */
declare interface Windows$Media$Core$TimedTextPoint {

/**
 * The units of the coordinates, either pixels or percentage.
 */
unit: $Values<typeof Windows$Media$Core$TimedTextUnit>,

/**
 * The X coordinate of the point.
 */
x: number,

/**
 * The Y coordinate of the point.
 */
y: number
} 


/**
 * Represents a media track list that allows a single item to be selected at a time.
 */
declare interface Windows$Media$Core$ISingleSelectMediaTrackList {

/**
 * Gets or set the currently selected media track in the list.
 */
selectedIndex: number
} 


      declare var npm$namespace$Windows$Media$Audio: {
        
        rame: typeof Windows$Media$Audio$rame,
rocessing: typeof Windows$Media$Audio$rocessing,
uffer: typeof Windows$Media$Audio$uffer,
ufferAccessMode: typeof Windows$Media$Audio$ufferAccessMode,
        AudioDeviceNodeCreationStatus: typeof Windows$Media$Audio$AudioDeviceNodeCreationStatus,
AudioFileNodeCreationStatus: typeof Windows$Media$Audio$AudioFileNodeCreationStatus,
AudioGraphCreationStatus: typeof Windows$Media$Audio$AudioGraphCreationStatus,
AudioGraphUnrecoverableError: typeof Windows$Media$Audio$AudioGraphUnrecoverableError,
QuantumSizeSelectionMode: typeof Windows$Media$Audio$QuantumSizeSelectionMode,
        AudioDeviceInputNode: typeof Windows$Media$Audio$AudioDeviceInputNode,
AudioDeviceOutputNode: typeof Windows$Media$Audio$AudioDeviceOutputNode,
AudioFileInputNode: typeof Windows$Media$Audio$AudioFileInputNode,
AudioFileOutputNode: typeof Windows$Media$Audio$AudioFileOutputNode,
AudioFrameCompletedEventArgs: typeof Windows$Media$Audio$AudioFrameCompletedEventArgs,
AudioFrameInputNode: typeof Windows$Media$Audio$AudioFrameInputNode,
AudioFrameOutputNode: typeof Windows$Media$Audio$AudioFrameOutputNode,
AudioGraph: typeof Windows$Media$Audio$AudioGraph,
AudioGraphConnection: typeof Windows$Media$Audio$AudioGraphConnection,
AudioGraphSettings: typeof Windows$Media$Audio$AudioGraphSettings,
AudioGraphUnrecoverableErrorOccurredEventArgs: typeof Windows$Media$Audio$AudioGraphUnrecoverableErrorOccurredEventArgs,
AudioSubmixNode: typeof Windows$Media$Audio$AudioSubmixNode,
CreateAudioDeviceInputNodeResult: typeof Windows$Media$Audio$CreateAudioDeviceInputNodeResult,
CreateAudioDeviceOutputNodeResult: typeof Windows$Media$Audio$CreateAudioDeviceOutputNodeResult,
CreateAudioFileInputNodeResult: typeof Windows$Media$Audio$CreateAudioFileInputNodeResult,
CreateAudioFileOutputNodeResult: typeof Windows$Media$Audio$CreateAudioFileOutputNodeResult,
CreateAudioGraphResult: typeof Windows$Media$Audio$CreateAudioGraphResult,
EchoEffectDefinition: typeof Windows$Media$Audio$EchoEffectDefinition,
EqualizerBand: typeof Windows$Media$Audio$EqualizerBand,
EqualizerEffectDefinition: typeof Windows$Media$Audio$EqualizerEffectDefinition,
FrameInputNodeQuantumStartedEventArgs: typeof Windows$Media$Audio$FrameInputNodeQuantumStartedEventArgs,
LimiterEffectDefinition: typeof Windows$Media$Audio$LimiterEffectDefinition,
ReverbEffectDefinition: typeof Windows$Media$Audio$ReverbEffectDefinition,
        
      }

/**
 * Represents an audio device input node.
 */
declare class Windows$Media$Audio$AudioDeviceInputNode  {

/**
 * Adds an outgoing connection with gain to the audio device input node.
 * @param destination The destination node for the connection.
 * @param gain A value indicating the gain associated with the connection.
 */
addOutgoingConnection(destination: Windows$Media$Audio$IAudioNode, gain: number): void;

/**
 * Adds an outgoing connection to the audio device input node.
 * @param destination The destination node for the connection.
 */
addOutgoingConnection(destination: Windows$Media$Audio$IAudioNode): void;

/**
 * Closes the audio device input node.
 */
close(): void;

/**
 * Gets or sets a value indicating if the audio device input node consumes input.
 */
consumeInput: boolean;

/**
 * Gets information about the audio device.
 */
device: Windows$Devices$Enumeration$DeviceInformation;

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to disable.
 */
disableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void;

/**
 * Gets the list of effect definitions for the audio device input node.
 */
effectDefinitions: Windows$Foundation$Collections$IVector<Windows$Media$Effects$IAudioEffectDefinition>;

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to enable.
 */
enableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void;

/**
 * Gets the encoding properties for the audio device input node.
 */
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Gets the list of outgoing connections from the audio device input node to other nodes in the audio graph.
 */
outgoingConnections: Windows$Foundation$Collections$IVectorView<Windows$Media$Audio$AudioGraphConnection>;

/**
 * Gets or sets the outgoing gain for the audio device input node.
 */
outgoingGain: number;

/**
 * Removes the outgoing connection for the audio device input node.
 * @param destination The destination for the outgoing connection.
 */
removeOutgoingConnection(destination: Windows$Media$Audio$IAudioNode): void;

/**
 * Resets the audio device input node.
 */
reset(): void;

/**
 * Starts the audio device input node.
 */
start(): void;

/**
 * Stops the audio device input node.
 */
stop(): void
}


/**
 * Defines status values for audio device node creation.
 */

declare  var Windows$Media$Audio$AudioDeviceNodeCreationStatus: {|
  +success: 0,// 0
+deviceNotAvailable: 1,// 1
+formatNotSupported: 2,// 2
+unknownFailure: 3,// 3
+accessDenied: 4,// 4

|};



/**
 * Represents an audio device output node.
 */
declare class Windows$Media$Audio$AudioDeviceOutputNode  {

/**
 * Closes the audio device output node.
 */
close(): void;

/**
 * Gets or sets a value indicating if the audio device output node consumes input.
 */
consumeInput: boolean;

/**
 * Gets information about the audio device.
 */
device: Windows$Devices$Enumeration$DeviceInformation;

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to disable.
 */
disableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void;

/**
 * Gets the list of effect definitions for the audio device output node.
 */
effectDefinitions: Windows$Foundation$Collections$IVector<Windows$Media$Effects$IAudioEffectDefinition>;

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to enable.
 */
enableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void;

/**
 * Gets the encoding properties for the audio device output node.
 */
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Gets or sets the outgoing gain for the audio device output node.
 */
outgoingGain: number;

/**
 * Resets the audio device output node.
 */
reset(): void;

/**
 * Starts the audio device output node.
 */
start(): void;

/**
 * Stops the audio device output node.
 */
stop(): void
}


/**
 * Represents an audio file input node.
 */
declare class Windows$Media$Audio$AudioFileInputNode  {

/**
 * Adds an outgoing connection with gain to the audio file input node.
 * @param destination The destination node for the connection.
 * @param gain A value indicating the gain associated with the connection.
 */
addOutgoingConnection(destination: Windows$Media$Audio$IAudioNode, gain: number): void;

/**
 * Adds an outgoing connection to the audio file input node.
 * @param destination The destination node for the connection.
 */
addOutgoingConnection(destination: Windows$Media$Audio$IAudioNode): void;

/**
 * Closes the audio file input node.
 */
close(): void;

/**
 * Gets or sets a value indicating if the audio file input node consumes input.
 */
consumeInput: boolean;

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to disable.
 */
disableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void;

/**
 * Gets the duration for the audio input file.
 */
duration: number;

/**
 * Gets the list of effect definitions for the audio file input node.
 */
effectDefinitions: Windows$Foundation$Collections$IVector<Windows$Media$Effects$IAudioEffectDefinition>;

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to enable.
 */
enableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void;

/**
 * Gets the encoding properties for the audio file input node.
 */
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Gets or sets the end time for the audio file input node.
 */
endTime: number;

/**
 * Gets or sets the loop count of the audio file input node.
 */
loopCount: number;

/**
 * Notifies of completion of the file associated with the audio file input node.
 */
onfilecompleted: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioFileInputNode, any>;
addEventListener(
type: "filecompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioFileInputNode, any>): void;
removeEventListener(
type: "filecompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioFileInputNode, any>): void;

/**
 * Gets the list of outgoing connections from the audio file input node to other nodes in the audio graph.
 */
outgoingConnections: Windows$Foundation$Collections$IVectorView<Windows$Media$Audio$AudioGraphConnection>;

/**
 * Gets or sets the outgoing gain for the audio file input node.
 */
outgoingGain: number;

/**
 * Gets or sets the playback speed factor for the audio file input node.
 */
playbackSpeedFactor: number;

/**
 * Gets the position of the audio file input node.
 */
position: number;

/**
 * Removes the outgoing connection for the audio file input node.
 * @param destination The destination for the outgoing connection.
 */
removeOutgoingConnection(destination: Windows$Media$Audio$IAudioNode): void;

/**
 * Resets the audio file input node.
 */
reset(): void;

/**
 * Moves the playback position of the node to the specified time within the audio input file.
 * @param position A value indicating the position to which the node should seek.
 */
seek(position: number): void;

/**
 * Gets the source audio file for the audio file input node.
 */
sourceFile: Windows$Storage$StorageFile;

/**
 * Starts the audio file input node.
 */
start(): void;

/**
 * Gets or sets the start time for the audio file input node.
 */
startTime: number;

/**
 * Stops the audio file input node.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Defines status values for audio file node creation.
 */

declare  var Windows$Media$Audio$AudioFileNodeCreationStatus: {|
  +success: 0,// 0
+fileNotFound: 1,// 1
+invalidFileType: 2,// 2
+formatNotSupported: 3,// 3
+unknownFailure: 4,// 4

|};



/**
 * Represents an audio file output node.
 */
declare class Windows$Media$Audio$AudioFileOutputNode  {

/**
 * Closes the audio file output node.
 */
close(): void;

/**
 * Gets or sets a value indicating if the audio file output node consumes input.
 */
consumeInput: boolean;

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to disable.
 */
disableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void;

/**
 * Gets the list of effect definitions for the audio file output node.
 */
effectDefinitions: Windows$Foundation$Collections$IVector<Windows$Media$Effects$IAudioEffectDefinition>;

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to enable.
 */
enableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void;

/**
 * Gets the encoding properties for the audio file output node.
 */
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Gets the file associated with the audio file output node.
 */
file: Windows$Storage$IStorageFile;

/**
 * Gets the file encoding profile supported by the audio file output node.
 */
fileEncodingProfile: Windows$Media$MediaProperties$MediaEncodingProfile;

/**
 * Finalizes the asynchronous operation of the audio file output node.
 * @return When this operation completes, a TranscodeFailureReason value is returned.
 */
finalizeAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Media$Transcoding$TranscodeFailureReason>>;

/**
 * Gets or sets the outgoing gain for the audio file output node.
 */
outgoingGain: number;

/**
 * Resets the audio file output node.
 */
reset(): void;

/**
 * Starts the audio file output node.
 */
start(): void;

/**
 * Stops the audio file output node.
 */
stop(): void
}


/**
 * Represents arguments for an AudioFrameCompleted event.
 */
declare class Windows$Media$Audio$AudioFrameCompletedEventArgs  {

/**
 * Gets the audio frame that was just completed by the AudioFrameInputNode . A frame is completed when all of the audio in the frame has been consumed by the audio graph.
 */
frame: Windows$Media$AudioFrame
}


/**
 * Represents an audio frame input node.
 */
declare class Windows$Media$Audio$AudioFrameInputNode  {

/**
 * Adds an audio frame to the audio frame input node.
 * @param frame An AudioFrame object representing the frame.
 */
addFrame(frame: Windows$Media$AudioFrame): void;

/**
 * Adds an outgoing connection with gain to the audio frame input node.
 * @param destination The destination node for the connection.
 * @param gain A value indicating the gain associated with the connection.
 */
addOutgoingConnection(destination: Windows$Media$Audio$IAudioNode, gain: number): void;

/**
 * Adds an outgoing connection to the audio frame input node.
 * @param destination The destination node for the connection.
 */
addOutgoingConnection(destination: Windows$Media$Audio$IAudioNode): void;

/**
 * Closes the audio frame input node.
 */
close(): void;

/**
 * Gets or sets a value indicating if the audio frame input node consumes input.
 */
consumeInput: boolean;

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to disable.
 */
disableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void;

/**
 * Removes queued frames from the audio frame input node.
 */
discardQueuedFrames(): void;

/**
 * Gets the list of effect definitions for the audio frame input node.
 */
effectDefinitions: Windows$Foundation$Collections$IVector<Windows$Media$Effects$IAudioEffectDefinition>;

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to enable.
 */
enableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void;

/**
 * Gets the encoding properties for the audio frame input node.
 */
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Notifies of a completed audio frame that has been submitted to the graph with a call to AddFrame .
 */
onaudioframecompleted: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioFrameInputNode, Windows$Media$Audio$AudioFrameCompletedEventArgs>;
addEventListener(
type: "audioframecompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioFrameInputNode, Windows$Media$Audio$AudioFrameCompletedEventArgs>): void;
removeEventListener(
type: "audioframecompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioFrameInputNode, Windows$Media$Audio$AudioFrameCompletedEventArgs>): void;

/**
 * Raised when the audio graph is ready to begin processing a new quantum of data.
 */
onquantumstarted: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioFrameInputNode, Windows$Media$Audio$FrameInputNodeQuantumStartedEventArgs>;
addEventListener(
type: "quantumstarted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioFrameInputNode, Windows$Media$Audio$FrameInputNodeQuantumStartedEventArgs>): void;
removeEventListener(
type: "quantumstarted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioFrameInputNode, Windows$Media$Audio$FrameInputNodeQuantumStartedEventArgs>): void;

/**
 * Gets the list of outgoing connections from the audio frame input node to other nodes in the audio graph.
 */
outgoingConnections: Windows$Foundation$Collections$IVectorView<Windows$Media$Audio$AudioGraphConnection>;

/**
 * Gets or sets the outgoing gain for the audio frame input node.
 */
outgoingGain: number;

/**
 * Gets or sets the playback speed factor for the audio frame input node.
 */
playbackSpeedFactor: number;

/**
 * Gets the queued sample count for the audio frame input node.
 */
queuedSampleCount: number;

/**
 * Removes an outgoing connection from the audio frame input node.
 * @param destination The destination for the outgoing connection.
 */
removeOutgoingConnection(destination: Windows$Media$Audio$IAudioNode): void;

/**
 * Resets the audio frame input node.
 */
reset(): void;

/**
 * Starts the audio frame input node.
 */
start(): void;

/**
 * Stops the audio frame input node.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents an audio frame output node.
 */
declare class Windows$Media$Audio$AudioFrameOutputNode  {

/**
 * Closes the audio frame output node.
 */
close(): void;

/**
 * Gets or sets a value indicating if the audio frame output node consumes input.
 */
consumeInput: boolean;

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to disable.
 */
disableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void;

/**
 * Gets the list of effect definitions for the audio frame output node.
 */
effectDefinitions: Windows$Foundation$Collections$IVector<Windows$Media$Effects$IAudioEffectDefinition>;

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to enable.
 */
enableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void;

/**
 * Gets the encoding properties for the audio frame output node.
 */
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Gets an audio frame containing all of the data accumulated by this node since the previous call to GetFrame. If GetFrame has not yet been called, the audio frame will contain all of the data accumulated since the node was created.
 * @return An AudioFrame object representing the frame.
 */
getFrame(): Windows$Media$AudioFrame;

/**
 * Gets or sets the outgoing gain for the audio frame output node.
 */
outgoingGain: number;

/**
 * Resets the audio frame output node.
 */
reset(): void;

/**
 * Starts the audio frame output node.
 */
start(): void;

/**
 * Stops the audio frame output node.
 */
stop(): void
}


/**
 * Represents an audio graph of connected input, output, and submix nodes that manipulate and route audio.
 */
declare class Windows$Media$Audio$AudioGraph  {

/**
 * Creates an audio graph with specific settings.
 * @param settings An AudioGraphSettings object representing the source audio file.
 * @return When this operation completes, a CreateAudioGraphResult object is returned.
 */
static createAsync(
settings: Windows$Media$Audio$AudioGraphSettings): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Audio$CreateAudioGraphResult>;

/**
 * Closes the audio graph.
 */
close(): void;

/**
 * Gets the completed quantum count for the audio graph.
 */
completedQuantumCount: number;

/**
 * Creates a device input node for the indicated media and audio encoding properties.
 * @param category An enumeration value indicating the media category.
 * @param encodingProperties An object representing the audio encoding properties for the device input node.
 * @return An asynchronous operation that returns a CreateAudioDeviceInputNodeResult on completion. This object exposes a Status property, that indicates either that the operation was successful or the reason why the operation failed. The DeviceInputNode property provides a reference to the created input node on success.
 */
createDeviceInputNodeAsync(
category: $Values<typeof Windows$Media$Capture$MediaCategory>,
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Audio$CreateAudioDeviceInputNodeResult>;

/**
 * Creates a device input node for the indicated media.
 * @param category An enumeration value indicating the media category.
 * @return An asynchronous operation that returns a CreateAudioDeviceInputNodeResult on completion. This object exposes a Status property, that indicates either that the operation was successful or the reason why the operation failed. The DeviceInputNode property provides a reference to the created input node on success.
 */
createDeviceInputNodeAsync(
category: $Values<typeof Windows$Media$Capture$MediaCategory>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Audio$CreateAudioDeviceInputNodeResult>;

/**
 * Creates a device input node for the indicated media, audio encoding properties, and device information.
 * @param category An enumeration value indicating the media category.
 * @param encodingProperties An object representing the audio encoding properties for the device input node.
 * @param device An object representing the device associated with the device input node.
 * @return An asynchronous operation that returns a CreateAudioDeviceInputNodeResult on completion. This object exposes a Status property, that indicates either that the operation was successful or the reason why the operation failed. The DeviceInputNode property provides a reference to the created input node on success.
 */
createDeviceInputNodeAsync(
category: $Values<typeof Windows$Media$Capture$MediaCategory>,
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties,
device: Windows$Devices$Enumeration$DeviceInformation): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Audio$CreateAudioDeviceInputNodeResult>;

/**
 * Creates a new device output node for the audio graph.
 * @return An asynchronous operation that returns a CreateAudioDeviceOutputNodeResult on completion. This object exposes a Status property, that indicates either that the operation was successful or the reason why the operation failed. The DeviceOutputNode property provides a reference to the created output node on success.
 */
createDeviceOutputNodeAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Audio$CreateAudioDeviceOutputNodeResult>;

/**
 * Creates a file input node for the audio graph.
 * @param file A IStorageFile object representing the file associated with the file input node.
 * @return When this operation completes, a CreateAudioFileInputNodeResult object is returned.
 */
createFileInputNodeAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Audio$CreateAudioFileInputNodeResult>;

/**
 * Creates a file output node for the indicated file.
 * @param file A StorageFile object representing the file.
 * @return When this operation completes, a CreateAudioFileOutputNodeResult object is returned.
 */
createFileOutputNodeAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Audio$CreateAudioFileOutputNodeResult>;

/**
 * Creates a file output node for the indicated file and media encoding profile.
 * @param file A StorageFile object representing the file.
 * @param fileEncodingProfile An objecting representing the media encoding profile.
 * @return When this operation completes, a CreateAudioFileOutputNodeResult object is returned.
 */
createFileOutputNodeAsync(
file: Windows$Storage$IStorageFile,
fileEncodingProfile: Windows$Media$MediaProperties$MediaEncodingProfile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Audio$CreateAudioFileOutputNodeResult>;

/**
 * Creates an audio frame input node from encoding properties.
 * @param encodingProperties An object representing encoding properties.
 * @return An audio frame input node.
 */
createFrameInputNode(
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties): Windows$Media$Audio$AudioFrameInputNode;

/**
 * Creates a simple audio frame input node for the audio graph.
 * @return An audio frame input node.
 */
createFrameInputNode(): Windows$Media$Audio$AudioFrameInputNode;

/**
 * Creates a frame output node from encoding properties.
 * @param encodingProperties An object representing audio encoding properties.
 * @return An audio frame output node.
 */
createFrameOutputNode(
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties): Windows$Media$Audio$AudioFrameOutputNode;

/**
 * Creates a simple frame output node for the audio graph.
 * @return An audio frame output node.
 */
createFrameOutputNode(): Windows$Media$Audio$AudioFrameOutputNode;

/**
 * Creates an audio graph submix node that mixes the output of one or more nodes into single output that can be connected to output nodes or other submix nodes.
 * @return An audio submix node.
 */
createSubmixNode(): Windows$Media$Audio$AudioSubmixNode;

/**
 * Creates an audio graph submix node that mixes the output of one or more nodes into single output that can be connected to output nodes or other submix nodes.
 * @param encodingProperties An object representing audio encoding properties.
 * @return An audio submix node.
 */
createSubmixNode(
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties): Windows$Media$Audio$AudioSubmixNode;

/**
 * Gets the encoding properties for the audio graph.
 */
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Gets the latency in samples that the audio graph supports.
 */
latencyInSamples: number;

/**
 * Notifies that the audio graph has processed the specified quantum.
 */
onquantumprocessed: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioGraph, any>;
addEventListener(
type: "quantumprocessed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioGraph, any>): void;
removeEventListener(
type: "quantumprocessed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioGraph, any>): void;

/**
 * Notifies that the audio graph has started processing a new quantum.
 */
onquantumstarted: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioGraph, any>;
addEventListener(
type: "quantumstarted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioGraph, any>): void;
removeEventListener(
type: "quantumstarted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioGraph, any>): void;

/**
 * Notifies of an unrecoverable audio error in audio graph operation.
 */
onunrecoverableerroroccurred: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioGraph, Windows$Media$Audio$AudioGraphUnrecoverableErrorOccurredEventArgs>;
addEventListener(
type: "unrecoverableerroroccurred",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioGraph, Windows$Media$Audio$AudioGraphUnrecoverableErrorOccurredEventArgs>): void;
removeEventListener(
type: "unrecoverableerroroccurred",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Audio$AudioGraph, Windows$Media$Audio$AudioGraphUnrecoverableErrorOccurredEventArgs>): void;

/**
 * Gets the primary render device for the audio graph.
 */
primaryRenderDevice: Windows$Devices$Enumeration$DeviceInformation;

/**
 * Gets a value that indicates the audio processing mode for the audio graph.
 */
renderDeviceAudioProcessing: $Values<typeof Windows$Media$AudioProcessing>;

/**
 * Resets all nodes in the audio graph.
 */
resetAllNodes(): void;

/**
 * Gets the number of samples per quantum at which the audio graph is currently operating.
 */
samplesPerQuantum: number;

/**
 * Starts the audio graph.
 */
start(): void;

/**
 * Stops the audio graph.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a connection within an audio graph.
 */
declare class Windows$Media$Audio$AudioGraphConnection  {

/**
 * Gets the destination node for the connection.
 */
destination: Windows$Media$Audio$IAudioNode;

/**
 * Gets the gain associated with the audio graph connection.
 */
gain: number
}


/**
 * Defines status values for audio graph creation.
 */

declare  var Windows$Media$Audio$AudioGraphCreationStatus: {|
  +success: 0,// 0
+deviceNotAvailable: 1,// 1
+formatNotSupported: 2,// 2
+unknownFailure: 3,// 3

|};



/**
 * Represents initialization settings for an audio graph. Set the properties of this object to your desired values and then call AudioGraph::CreateAsync to create a new audio graph instance with the specified settings.
 */
declare class Windows$Media$Audio$AudioGraphSettings  {

/**
 * Initializes a new instance of the AudioGraphSettings class with initial settings values optimized for the specified AudioRenderCategory .
 * @param audioRenderCategory The AudioRenderCategory that determines the initial settings values.
 */
constructor(audioRenderCategory: $Values<typeof Windows$Media$Render$AudioRenderCategory>): this;

/**
 * Gets or sets a value that indicates the audio render category setting for the audio graph.
 */
audioRenderCategory: $Values<typeof Windows$Media$Render$AudioRenderCategory>;

/**
 * Gets or sets a value that indicates the desired audio processing mode setting for the audio graph.
 */
desiredRenderDeviceAudioProcessing: $Values<typeof Windows$Media$AudioProcessing>;

/**
 * Gets or sets the desired number of samples per quantum defined for the audio graph.
 */
desiredSamplesPerQuantum: number;

/**
 * Gets or sets the audio encoding properties setting for the audio graph.
 */
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Gets or sets an object that represents the primary render device for the audio graph.
 */
primaryRenderDevice: Windows$Devices$Enumeration$DeviceInformation;

/**
 * Gets or sets the quantum size selection mode for the audio graph.
 */
quantumSizeSelectionMode: $Values<typeof Windows$Media$Audio$QuantumSizeSelectionMode>
}


/**
 * Defines unrecoverable errors for the audio graph.
 */

declare  var Windows$Media$Audio$AudioGraphUnrecoverableError: {|
  +none: 0,// 0
+audioDeviceLost: 1,// 1
+audioSessionDisconnected: 2,// 2
+unknownFailure: 3,// 3

|};



/**
 * Represents arguments for an UnrecoverableErrorOccurred event.
 */
declare class Windows$Media$Audio$AudioGraphUnrecoverableErrorOccurredEventArgs  {

/**
 * Gets the error associated with the event.
 */
error: $Values<typeof Windows$Media$Audio$AudioGraphUnrecoverableError>
}


/**
 * Represents an audio submix node that mixes the output of one or more nodes into single output that can be connected to output nodes or other submix nodes.
 */
declare class Windows$Media$Audio$AudioSubmixNode  {

/**
 * Adds an outgoing connection with gain to the audio submix node.
 * @param destination The destination node for the connection.
 * @param gain A value indicating the gain associated with the connection.
 */
addOutgoingConnection(destination: Windows$Media$Audio$IAudioNode, gain: number): void;

/**
 * Adds an outgoing connection to the audio submix node.
 * @param destination The destination node for the connection.
 */
addOutgoingConnection(destination: Windows$Media$Audio$IAudioNode): void;

/**
 * Closes the audio submix node.
 */
close(): void;

/**
 * Gets or sets a value indicating if the audio submix node consumes input.
 */
consumeInput: boolean;

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to disable.
 */
disableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void;

/**
 * Gets the list of effect definitions for the audio submix node.
 */
effectDefinitions: Windows$Foundation$Collections$IVector<Windows$Media$Effects$IAudioEffectDefinition>;

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to enable.
 */
enableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void;

/**
 * Gets the encoding properties for the audio device submix node.
 */
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Gets outgoing connections from the audio submix node to other nodes in the audio graph.
 */
outgoingConnections: Windows$Foundation$Collections$IVectorView<Windows$Media$Audio$AudioGraphConnection>;

/**
 * Gets or sets the outgoing gain for the audio submix node.
 */
outgoingGain: number;

/**
 * Removes an outgoing connection from the audio submix node.
 * @param destination The destination for the outgoing connection.
 */
removeOutgoingConnection(destination: Windows$Media$Audio$IAudioNode): void;

/**
 * Resets the audio submix node.
 */
reset(): void;

/**
 * Starts the audio submix node.
 */
start(): void;

/**
 * Stops the audio submix node.
 */
stop(): void
}


/**
 * Represents the result of creating an audio device input node.
 */
declare class Windows$Media$Audio$CreateAudioDeviceInputNodeResult  {

/**
 * Gets the audio device input node.
 */
deviceInputNode: Windows$Media$Audio$AudioDeviceInputNode;

/**
 * Gets the status of audio device input node creation.
 */
status: $Values<typeof Windows$Media$Audio$AudioDeviceNodeCreationStatus>
}


/**
 * Represents the result of creating an audio device output node.
 */
declare class Windows$Media$Audio$CreateAudioDeviceOutputNodeResult  {

/**
 * Gets the audio device output node.
 */
deviceOutputNode: Windows$Media$Audio$AudioDeviceOutputNode;

/**
 * Gets the status of audio device output node creation.
 */
status: $Values<typeof Windows$Media$Audio$AudioDeviceNodeCreationStatus>
}


/**
 * Represents the result of creating an audio file input node.
 */
declare class Windows$Media$Audio$CreateAudioFileInputNodeResult  {

/**
 * Gets the audio file input node.
 */
fileInputNode: Windows$Media$Audio$AudioFileInputNode;

/**
 * Gets the status of audio file input node creation.
 */
status: $Values<typeof Windows$Media$Audio$AudioFileNodeCreationStatus>
}


/**
 * Represents the result of creating an audio file output node.
 */
declare class Windows$Media$Audio$CreateAudioFileOutputNodeResult  {

/**
 * Gets the audio file output node.
 */
fileOutputNode: Windows$Media$Audio$AudioFileOutputNode;

/**
 * Gets the status of audio file output node creation.
 */
status: $Values<typeof Windows$Media$Audio$AudioFileNodeCreationStatus>
}


/**
 * Represents the result of creating an audio graph.
 */
declare class Windows$Media$Audio$CreateAudioGraphResult  {

/**
 * Gets the audio graph object.
 */
graph: Windows$Media$Audio$AudioGraph;

/**
 * Gets the status of audio graph creation.
 */
status: $Values<typeof Windows$Media$Audio$AudioGraphCreationStatus>
}


/**
 * Represents an echo effect definition supported by the audio graph.
 */
declare class Windows$Media$Audio$EchoEffectDefinition  {

/**
 * Creates an EchoEffectDefinition object.
 * @param audioGraph The AudioGraph with which the effect will be used. Using effects outside of the audio graph it was created with is not supported.
 */
constructor(audioGraph: Windows$Media$Audio$AudioGraph): this;

/**
 * Gets the activatable class ID for the echo effect definition object.
 */
activatableClassId: string;

/**
 * Gets or sets the delay supported by the echo effect definition.
 */
delay: number;

/**
 * Gets or sets the feedback included in the echo effect definition.
 */
feedback: number;

/**
 * Gets or sets the properties supported by the echo effect definition.
 */
properties: Windows$Foundation$Collections$IPropertySet;

/**
 * Gets or sets the wet-dry audio voice mix for the echo effect definition.
 */
wetDryMix: number
}


/**
 * Represents an equalizer band for the equalizer effect.
 */
declare class Windows$Media$Audio$EqualizerBand  {

/**
 * Gets or sets the bandwidth for the equalizer band.
 */
bandwidth: number;

/**
 * Gets or sets the frequency center for the equalizer band.
 */
frequencyCenter: number;

/**
 * Gets or sets the gain for the equalizer band.
 */
gain: number
}


/**
 * Represents an equalizer effect definition supported by the audio graph.
 */
declare class Windows$Media$Audio$EqualizerEffectDefinition  {

/**
 * Initializes a new instance of the EqualizerEffectDefinition class.
 * @param audioGraph The AudioGraph with which the effect will be used. Using effects outside of the audio graph it was created with is not supported.
 */
constructor(audioGraph: Windows$Media$Audio$AudioGraph): this;

/**
 * Gets the activatable class ID for the equalizer effect definition object.
 */
activatableClassId: string;

/**
 * Gets the bands included in the equalizer effect definition.
 */
bands: Windows$Foundation$Collections$IVectorView<Windows$Media$Audio$EqualizerBand>;

/**
 * Gets the properties supported by the equalizer effect definition.
 */
properties: Windows$Foundation$Collections$IPropertySet
}


/**
 * Provides data for the AudioFrameInputNode::QuantumStarted event. This event is raised when the audio graph containing the audio frame input node is ready to begin processing a new quantum of data.
 */
declare class Windows$Media$Audio$FrameInputNodeQuantumStartedEventArgs  {

/**
 * Gets the number of samples that the audio graph requires to fill the quantum with data.
 */
requiredSamples: number
}


/**
 * Represents a limiter effect definition supported by the audio graph.
 */
declare class Windows$Media$Audio$LimiterEffectDefinition  {

/**
 * Initializes a new instance of the LimiterEffectDefinition class.
 * @param audioGraph The AudioGraph with which the effect will be used. Using effects outside of the audio graph it was created with is not supported.
 */
constructor(audioGraph: Windows$Media$Audio$AudioGraph): this;

/**
 * Gets the activatable class ID for the limiter effect definition object.
 */
activatableClassId: string;

/**
 * Gets or sets the loudness included in the limiter effect definition.
 */
loudness: number;

/**
 * Gets the properties supported by the limiter effect definition.
 */
properties: Windows$Foundation$Collections$IPropertySet;

/**
 * Gets or sets the release included in the limiter effect definition.
 */
release: number
}


/**
 * Defines values used for quantum size selection.
 */

declare  var Windows$Media$Audio$QuantumSizeSelectionMode: {|
  +systemDefault: 0,// 0
+lowestLatency: 1,// 1
+closestToDesired: 2,// 2

|};



/**
 * Represents a reverberation effect definition supported by the audio graph.
 */
declare class Windows$Media$Audio$ReverbEffectDefinition  {

/**
 * Initializes a new instance of the ReverbffectDefinition class.
 * @param audioGraph The AudioGraph with which the effect will be used. Using effects outside of the audio graph it was created with is not supported.
 */
constructor(audioGraph: Windows$Media$Audio$AudioGraph): this;

/**
 * Gets the activatable class ID for the reverberation effect definition object.
 */
activatableClassId: string;

/**
 * Gets or sets the decay time supported by the reverberation effect definition.
 */
decayTime: number;

/**
 * Gets or sets the density included in the reverberation effect definition.
 */
density: number;

/**
 * Gets or sets a value indicating if the reverberation effect disables late fields.
 */
disableLateField: boolean;

/**
 * Gets or sets the early diffusion value for the reverberation effect definition.
 */
earlyDiffusion: number;

/**
 * Gets or sets the high equalization cutoff included in the reverberation effect definition.
 */
highEQCutoff: number;

/**
 * Gets or sets the high equalization gain included in the reverberation effect definition.
 */
highEQGain: number;

/**
 * Gets or sets the late diffusion included in the reverberation effect definition.
 */
lateDiffusion: number;

/**
 * Gets or sets the low equalization cutoff included in the reverberation effect definition.
 */
lowEQCutoff: number;

/**
 * Gets or sets the low equalization gain included in the reverberation effect definition.
 */
lowEQGain: number;

/**
 * Gets or sets the position left included in the reverberation effect definition.
 */
positionLeft: number;

/**
 * Gets or sets the matrix position left included in the reverberation effect definition.
 */
positionMatrixLeft: number;

/**
 * Gets or sets the matrix position right included in the reverberation effect definition.
 */
positionMatrixRight: number;

/**
 * Gets or sets the position right included in the reverberation effect definition.
 */
positionRight: number;

/**
 * Gets the properties supported by the reverberation effect definition.
 */
properties: Windows$Foundation$Collections$IPropertySet;

/**
 * Gets or sets the rear delay included in the reverberation effect definition.
 */
rearDelay: number;

/**
 * Gets or sets the reflections delay included in the reverberation effect definition.
 */
reflectionsDelay: number;

/**
 * Gets or sets the reflections gain included in the reverberation effect definition.
 */
reflectionsGain: number;

/**
 * Gets or sets the reverberation delay included in the reverberation effect definition.
 */
reverbDelay: number;

/**
 * Gets or sets the reverberation gain included in the reverberation effect definition.
 */
reverbGain: number;

/**
 * Gets or sets the room filter frequency included in the reverberation effect definition.
 */
roomFilterFreq: number;

/**
 * Gets or sets the room filter high frequency included in the reverberation effect definition.
 */
roomFilterHF: number;

/**
 * Gets or sets the main room filter included in the reverberation effect definition.
 */
roomFilterMain: number;

/**
 * Gets or sets the room size included in the reverberation effect definition.
 */
roomSize: number;

/**
 * Gets or sets the wet-dry audio voice mix for the reverberation effect definition.
 */
wetDryMix: number
}

declare var Windows$Media$Audio$rame: any;

declare var Windows$Media$Audio$rocessing: any;

declare var Windows$Media$Audio$uffer: any;

declare var Windows$Media$Audio$ufferAccessMode: any;


/**
 * Defines an audio node.
 */
declare type Windows$Media$Audio$IAudioNode = {

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to disable.
 */
disableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void,

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param definition The effect definition of the effects to enable.
 */
enableEffectsByDefinition(definition: Windows$Media$Effects$IAudioEffectDefinition): void,

/**
 * Resets the audio node.
 */
reset(): void,

/**
 * Starts the audio node.
 */
start(): void,

/**
 * Stops the audio node.
 */
stop(): void,

/**
 * Gets or sets a value indicating if the audio node consumes input.
 */
consumeInput: boolean,

/**
 * Gets the list of effect definitions for the audio node.
 */
effectDefinitions: Windows$Foundation$Collections$IVector<Windows$Media$Effects$IAudioEffectDefinition>,

/**
 * Gets the encoding properties for the audio node.
 */
encodingProperties: Windows$Media$MediaProperties$AudioEncodingProperties,

/**
 * Gets or sets the outgoing gain for the audio node.
 */
outgoingGain: number
} & Windows$Foundation$IClosable



/**
 * Represents a buffer containing audio data.
 */
declare class Windows$Media$AudioBuffer  {

/**
 * Gets the maximum number of bytes that the buffer can hold.
 */
capacity: number;

/**
 * Disposes of the object and associated resources.
 */
close(): void;

/**
 * Returns an IMemoryBufferReference representation of the audio buffer.
 * @return The IMemoryBufferReference representation of the audio buffer.
 */
createReference(): Windows$Foundation$IMemoryBufferReference;

/**
 * Gets or sets the number of bytes currently in use in the buffer.
 */
length: number
}


/**
 * Defines the access mode of an AudioBuffer returned by AudioFrame::LockBuffer .
 */

declare  var Windows$Media$AudioBufferAccessMode: {|
  +read: 0,// 0
+readWrite: 1,// 1
+write: 2,// 2

|};



/**
 * Represents a single frame of audio data.
 */
declare class Windows$Media$AudioFrame  {

/**
 * Initializes a new instance of the AudioFrame class.
 * @param capacity The maximum number of bytes that the buffer can hold.
 */
constructor(capacity: number): this;

/**
 * Disposes of the object and associated resources.
 */
close(): void;

/**
 * Gets or sets the duration of the audio frame.
 */
duration: number;

/**
 * Gets the extended property set which enables getting and setting properties on the AudioFrame .
 */
extendedProperties: Windows$Foundation$Collections$IPropertySet;

/**
 * Gets or sets a value that indicates whether an audio frame is the first frame after a gap in the stream.
 */
isDiscontinuous: boolean;

/**
 * Gets a value indicating whether the audio frame is read-only.
 */
isReadOnly: boolean;

/**
 * Gets a AudioBuffer object that allows you to operate directly on the software bitmap's pixel data.
 * @param mode A value indicating the access mode of the returned audio buffer.
 * @return The buffer containing pixel data.
 */
lockBuffer(
mode: $Values<typeof Windows$Media$AudioBufferAccessMode>): Windows$Media$AudioBuffer;

/**
 * Gets or sets the relative time of the frame within the audio stream.
 */
relativeTime: number;

/**
 * Gets or sets a timestamp that is relative to the system and is correlatable across multiple media sources on the same device.
 */
systemRelativeTime: number;

/**
 * Gets a string indicating the type of audio data the audio frame contains.
 */
type: string
}


/**
 * Defines the audio processing modes.
 */

declare  var Windows$Media$AudioProcessing: {|
  +default: 0,// 0
+raw: 1,// 1

|};



/**
 * Provides data for the AutoRepeatModeChangeRequested event.
 */
declare class Windows$Media$AutoRepeatModeChangeRequestedEventArgs  {

/**
 * Gets a value indicating the requested auto-repeat mode.
 */
requestedAutoRepeatMode: $Values<typeof Windows$Media$MediaPlaybackAutoRepeatMode>
}


      declare var npm$namespace$Windows$Media$Capture: {
        
        
        AppCaptureHistoricalBufferLengthUnit: typeof Windows$Media$Capture$AppCaptureHistoricalBufferLengthUnit,
AppCaptureVideoEncodingBitrateMode: typeof Windows$Media$Capture$AppCaptureVideoEncodingBitrateMode,
AppCaptureVideoEncodingResolutionMode: typeof Windows$Media$Capture$AppCaptureVideoEncodingResolutionMode,
CameraCaptureUIMaxPhotoResolution: typeof Windows$Media$Capture$CameraCaptureUIMaxPhotoResolution,
CameraCaptureUIMaxVideoResolution: typeof Windows$Media$Capture$CameraCaptureUIMaxVideoResolution,
CameraCaptureUIMode: typeof Windows$Media$Capture$CameraCaptureUIMode,
CameraCaptureUIPhotoFormat: typeof Windows$Media$Capture$CameraCaptureUIPhotoFormat,
CameraCaptureUIVideoFormat: typeof Windows$Media$Capture$CameraCaptureUIVideoFormat,
KnownVideoProfile: typeof Windows$Media$Capture$KnownVideoProfile,
MediaCaptureThermalStatus: typeof Windows$Media$Capture$MediaCaptureThermalStatus,
MediaCategory: typeof Windows$Media$Capture$MediaCategory,
MediaStreamType: typeof Windows$Media$Capture$MediaStreamType,
PhotoCaptureSource: typeof Windows$Media$Capture$PhotoCaptureSource,
PowerlineFrequency: typeof Windows$Media$Capture$PowerlineFrequency,
StreamingCaptureMode: typeof Windows$Media$Capture$StreamingCaptureMode,
VideoDeviceCharacteristic: typeof Windows$Media$Capture$VideoDeviceCharacteristic,
VideoRotation: typeof Windows$Media$Capture$VideoRotation,
        AdvancedCapturedPhoto: typeof Windows$Media$Capture$AdvancedCapturedPhoto,
AdvancedPhotoCapture: typeof Windows$Media$Capture$AdvancedPhotoCapture,
AppCapture: typeof Windows$Media$Capture$AppCapture,
AppCaptureAlternateShortcutKeys: typeof Windows$Media$Capture$AppCaptureAlternateShortcutKeys,
AppCaptureManager: typeof Windows$Media$Capture$AppCaptureManager,
AppCaptureSettings: typeof Windows$Media$Capture$AppCaptureSettings,
CameraCaptureUI: typeof Windows$Media$Capture$CameraCaptureUI,
CameraCaptureUIPhotoCaptureSettings: typeof Windows$Media$Capture$CameraCaptureUIPhotoCaptureSettings,
CameraCaptureUIVideoCaptureSettings: typeof Windows$Media$Capture$CameraCaptureUIVideoCaptureSettings,
CameraOptionsUI: typeof Windows$Media$Capture$CameraOptionsUI,
CapturedFrame: typeof Windows$Media$Capture$CapturedFrame,
CapturedFrameControlValues: typeof Windows$Media$Capture$CapturedFrameControlValues,
CapturedPhoto: typeof Windows$Media$Capture$CapturedPhoto,
LowLagMediaRecording: typeof Windows$Media$Capture$LowLagMediaRecording,
LowLagPhotoCapture: typeof Windows$Media$Capture$LowLagPhotoCapture,
LowLagPhotoSequenceCapture: typeof Windows$Media$Capture$LowLagPhotoSequenceCapture,
MediaCapture: typeof Windows$Media$Capture$MediaCapture,
MediaCaptureFailedEventArgs: typeof Windows$Media$Capture$MediaCaptureFailedEventArgs,
MediaCaptureFocusChangedEventArgs: typeof Windows$Media$Capture$MediaCaptureFocusChangedEventArgs,
MediaCaptureInitializationSettings: typeof Windows$Media$Capture$MediaCaptureInitializationSettings,
MediaCaptureSettings: typeof Windows$Media$Capture$MediaCaptureSettings,
MediaCaptureVideoProfile: typeof Windows$Media$Capture$MediaCaptureVideoProfile,
MediaCaptureVideoProfileMediaDescription: typeof Windows$Media$Capture$MediaCaptureVideoProfileMediaDescription,
OptionalReferencePhotoCapturedEventArgs: typeof Windows$Media$Capture$OptionalReferencePhotoCapturedEventArgs,
PhotoCapturedEventArgs: typeof Windows$Media$Capture$PhotoCapturedEventArgs,
PhotoConfirmationCapturedEventArgs: typeof Windows$Media$Capture$PhotoConfirmationCapturedEventArgs,
VideoStreamConfiguration: typeof Windows$Media$Capture$VideoStreamConfiguration,
        Core: typeof npm$namespace$Windows$Media$Capture$Core,
      }

/**
 * Represents a photo captured using system-provided computational photography techniques provided by the AdvancedPhotoCapture class.
 */
declare class Windows$Media$Capture$AdvancedCapturedPhoto  {

/**
 * Gets the app-defined context object associated with the advanced photo capture operation, if one was provided in the call to AdvancedPhotoCapture::CaptureAsync(Object) .
 */
context: any;

/**
 * Gets the captured frame containing the result of the advanced photo capture.
 */
frame: Windows$Media$Capture$CapturedFrame;

/**
 * Gets a value indicating the advanced capture mode with which the photo was captured.
 */
mode: $Values<typeof Windows$Media$Devices$AdvancedPhotoMode>
}


/**
 * Provides methods for capturing photos using system-provided computational photography techniques.
 */
declare class Windows$Media$Capture$AdvancedPhotoCapture  {

/**
 * Asynchronously performs an advanced photo capture.
 * @return An asynchronous operation that returns an AdvancedCapturedPhoto upon successful completion.
 */
captureAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Capture$AdvancedCapturedPhoto>;

/**
 * Asynchronously performs an advanced photo capture passing the provided app-defined context object to the result of the operation.
 * @param context An app-defined context object that passes context information to the result of the operation.
 * @return An asynchronous operation that returns an AdvancedCapturedPhoto upon successful completion.
 */
captureAsync(
context: any): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Capture$AdvancedCapturedPhoto>;

/**
 * Asynchronously releases the AdvancedPhotoCapture object and resources used by the advanced photo capture operation.
 * @return An asynchronous action.
 */
finishAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Occurs when all of the frames required for the advanced photo capture have been captured.
 */
onallphotoscaptured: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$AdvancedPhotoCapture, any>;
addEventListener(
type: "allphotoscaptured",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$AdvancedPhotoCapture, any>): void;
removeEventListener(
type: "allphotoscaptured",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$AdvancedPhotoCapture, any>): void;

/**
 * Raised when a reference photo for the advanced photo operation has been captured, on devices that support this feature.
 */
onoptionalreferencephotocaptured: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$AdvancedPhotoCapture, Windows$Media$Capture$OptionalReferencePhotoCapturedEventArgs>;
addEventListener(
type: "optionalreferencephotocaptured",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$AdvancedPhotoCapture, Windows$Media$Capture$OptionalReferencePhotoCapturedEventArgs>): void;
removeEventListener(
type: "optionalreferencephotocaptured",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$AdvancedPhotoCapture, Windows$Media$Capture$OptionalReferencePhotoCapturedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}

declare class Windows$Media$Capture$AppCapture  {
static getForCurrentView: any;
addEventListener: any;
isCapturingAudio: any;
isCapturingVideo: any;
oncapturingchanged: any;
removeEventListener: any
}


/**
 * Defines alternate shortcut keys for app capture.
 */
declare class Windows$Media$Capture$AppCaptureAlternateShortcutKeys  {

/**
 * Gets or sets the save historical video shortcut key.
 */
saveHistoricalVideoKey: $Values<typeof Windows$System$VirtualKey>;

/**
 * Gets or sets the save historical video shortcut key modifiers.
 */
saveHistoricalVideoKeyModifiers: $Values<typeof Windows$System$VirtualKeyModifiers>;

/**
 * Gets or sets the take screenshot shortcut key.
 */
takeScreenshotKey: $Values<typeof Windows$System$VirtualKey>;

/**
 * Gets or sets the take screenshot shortcut key modifiers.
 */
takeScreenshotKeyModifiers: $Values<typeof Windows$System$VirtualKeyModifiers>;

/**
 * Gets or sets the toggle game bar shortcut key.
 */
toggleGameBarKey: $Values<typeof Windows$System$VirtualKey>;

/**
 * Gets or sets the toggle game bar shortcut key modifiers.
 */
toggleGameBarKeyModifiers: $Values<typeof Windows$System$VirtualKeyModifiers>;
toggleMicrophoneCaptureKey: any;
toggleMicrophoneCaptureKeyModifiers: any;

/**
 * Gets or sets the toggle recording indicator shortcut key.
 */
toggleRecordingIndicatorKey: $Values<typeof Windows$System$VirtualKey>;

/**
 * Gets or sets the toggle recording indicator shortcut key modifiers.
 */
toggleRecordingIndicatorKeyModifiers: $Values<typeof Windows$System$VirtualKeyModifiers>;

/**
 * Gets or sets the toggle recording shortcut key.
 */
toggleRecordingKey: $Values<typeof Windows$System$VirtualKey>;

/**
 * Gets or sets the toggle recording shortcut key modifiers.
 */
toggleRecordingKeyModifiers: $Values<typeof Windows$System$VirtualKeyModifiers>
}


/**
 * Specifies the units of the app capture historical buffer.
 */

declare  var Windows$Media$Capture$AppCaptureHistoricalBufferLengthUnit: {|
  +megabytes: 0,// 0
+seconds: 1,// 1

|};



/**
 * Provides access to app capture settings.
 */
declare class Windows$Media$Capture$AppCaptureManager  {

/**
 * Applies app capture settings.
 * @param appCaptureSettings The settings to apply.
 */
static applySettings(appCaptureSettings: Windows$Media$Capture$AppCaptureSettings): void;

/**
 * Gets the current app capture settings.
 * @return The current app capture settings.
 */
static getCurrentSettings(): Windows$Media$Capture$AppCaptureSettings
}


/**
 * Represents app capture settings.
 */
declare class Windows$Media$Capture$AppCaptureSettings  {

/**
 * Gets the alternate shortcut key settings.
 */
alternateShortcutKeys: Windows$Media$Capture$AppCaptureAlternateShortcutKeys;

/**
 * Gets or sets the app capture destination folder.
 */
appCaptureDestinationFolder: Windows$Storage$StorageFolder;

/**
 * Gets or sets the audio encoding bitrate.
 */
audioEncodingBitrate: number;

/**
 * Gets or sets the custom video encoding bitrate.
 */
customVideoEncodingBitrate: number;

/**
 * Gets or sets the custom video encoding height.
 */
customVideoEncodingHeight: number;

/**
 * Gets the custom video encoding width.
 */
customVideoEncodingWidth: number;

/**
 * Gets a value indicating if the device has a hardware encoder.
 */
hasHardwareEncoder: boolean;

/**
 * Gets or sets the historical buffer length.
 */
historicalBufferLength: number;

/**
 * Gets or sets the units of the historical buffer length.
 */
historicalBufferLengthUnit: $Values<typeof Windows$Media$Capture$AppCaptureHistoricalBufferLengthUnit>;

/**
 * Gets or sets a value indicating if app capture is enabled.
 */
isAppCaptureEnabled: boolean;

/**
 * Gets or sets a value indicating whether audio capture is enabled.
 */
isAudioCaptureEnabled: boolean;

/**
 * Gets a value indicating if app capture is CPU-constrained.
 */
isCpuConstrained: boolean;

/**
 * Gets a value indicating if app capture is disabled by policy.
 */
isDisabledByPolicy: boolean;

/**
 * Gets a value indicating if app capture is GPU-constrained.
 */
isGpuConstrained: boolean;

/**
 * Gets or sets a value indicating if historical capture is enabled.
 */
isHistoricalCaptureEnabled: boolean;

/**
 * Gets or sets a value indicating whether historical capture is allowed while the device is on battery power.
 */
isHistoricalCaptureOnBatteryAllowed: boolean;

/**
 * Gets or sets a value indicating whether historical capture is allowed on wireless displays.
 */
isHistoricalCaptureOnWirelessDisplayAllowed: boolean;

/**
 * Gets a value indicating whether the device is memory-constrained.
 */
isMemoryConstrained: boolean;
isMicrophoneCaptureEnabled: any;

/**
 * Gets or sets the maximum recording length.
 */
maximumRecordLength: number;

/**
 * Gets or sets the screenshot destination folder.
 */
screenshotDestinationFolder: Windows$Storage$StorageFolder;

/**
 * Gets or sets the video encoding bitrate.
 */
videoEncodingBitrateMode: $Values<typeof Windows$Media$Capture$AppCaptureVideoEncodingBitrateMode>;

/**
 * Gets or sets the video encoding resolution mode.
 */
videoEncodingResolutionMode: $Values<typeof Windows$Media$Capture$AppCaptureVideoEncodingResolutionMode>
}


/**
 * Specifies the app capture video encoding bitrate mode.
 */

declare  var Windows$Media$Capture$AppCaptureVideoEncodingBitrateMode: {|
  +custom: 0,// 0
+high: 1,// 1
+standard: 2,// 2

|};



/**
 * Specifies the app capture video encoding resolution mode.
 */

declare  var Windows$Media$Capture$AppCaptureVideoEncodingResolutionMode: {|
  +custom: 0,// 0
+high: 1,// 1
+standard: 2,// 2

|};



/**
 * Provides a full window UI for capturing audio, video, and photos from a camera. As well as controls for trimming video, time delayed capture, and camera settings.
 */
declare class Windows$Media$Capture$CameraCaptureUI  {

/**
 * Create a new CameraCaptureUI object.
 */
constructor(): this;

/**
 * Launches the CameraCaptureUI user interface.
 * @param mode Specifies whether the user interface that will be shown allows the user to capture a photo, capture a video, or capture both photos and videos.
 * @return When this operation completes, a StorageFile object is returned.
 */
captureFileAsync(
mode: $Values<typeof Windows$Media$Capture$CameraCaptureUIMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Provides settings for capturing photos. The settings include aspect ratio, image size, format, resolution, and whether or not cropping is allowed by the user interface (UI).
 */
photoSettings: Windows$Media$Capture$CameraCaptureUIPhotoCaptureSettings;

/**
 * Provides settings for capturing videos. The settings include format, maximum resolution, maximum duration, and whether or not to allow trimming.
 */
videoSettings: Windows$Media$Capture$CameraCaptureUIVideoCaptureSettings
}


/**
 * Determines the highest resolution the user can select for capturing photos.
 */

declare  var Windows$Media$Capture$CameraCaptureUIMaxPhotoResolution: {|
  +highestAvailable: 0,// 0
+verySmallQvga: 1,// 1
+smallVga: 2,// 2
+mediumXga: 3,// 3
+large3M: 4,// 4
+veryLarge5M: 5,// 5

|};



/**
 * Determines the highest resolution the user can select for capturing video.
 */

declare  var Windows$Media$Capture$CameraCaptureUIMaxVideoResolution: {|
  +highestAvailable: 0,// 0
+lowDefinition: 1,// 1
+standardDefinition: 2,// 2
+highDefinition: 3,// 3

|};



/**
 * Determines whether the user interface for capturing from the attached camera allows capture of photos, videos, or both photos and videos.
 */

declare  var Windows$Media$Capture$CameraCaptureUIMode: {|
  +photoOrVideo: 0,// 0
+photo: 1,// 1
+video: 2,// 2

|};



/**
 * Provides settings for capturing photos. The settings include aspect ratio, image size, format, resolution, and whether or not cropping is allowed by the user interface (UI).
 */
declare class Windows$Media$Capture$CameraCaptureUIPhotoCaptureSettings  {

/**
 * Determines whether photo cropping will be enabled in the user interface for capture a photo.
 */
allowCropping: boolean;

/**
 * The aspect ratio of the captured photo.
 */
croppedAspectRatio: Windows$Foundation$Size;

/**
 * The exact size in pixels of the captured photo.
 */
croppedSizeInPixels: Windows$Foundation$Size;

/**
 * Determines the format that captured photos will be stored in.
 */
format: $Values<typeof Windows$Media$Capture$CameraCaptureUIPhotoFormat>;

/**
 * Determines the maximum resolution the user will be able to select.
 */
maxResolution: $Values<typeof Windows$Media$Capture$CameraCaptureUIMaxPhotoResolution>
}


/**
 * Determines the format for storing captured photos.
 */

declare  var Windows$Media$Capture$CameraCaptureUIPhotoFormat: {|
  +jpeg: 0,// 0
+png: 1,// 1
+jpegXR: 2,// 2

|};



/**
 * Provides settings for capturing videos. The settings include format, maximum resolution, maximum duration, and whether or not to allow trimming.
 */
declare class Windows$Media$Capture$CameraCaptureUIVideoCaptureSettings  {

/**
 * Determines whether or not the video trimming user interface will be enabled.
 */
allowTrimming: boolean;

/**
 * Determines the format for storing captured videos.
 */
format: $Values<typeof Windows$Media$Capture$CameraCaptureUIVideoFormat>;

/**
 * Determines the maximum duration of a video.
 */
maxDurationInSeconds: number;

/**
 * Determines the maximum resolution that the user can select.
 */
maxResolution: $Values<typeof Windows$Media$Capture$CameraCaptureUIMaxVideoResolution>
}


/**
 * Determines the format for saving captured videos.
 */

declare  var Windows$Media$Capture$CameraCaptureUIVideoFormat: {|
  +mp4: 0,// 0
+wmv: 1,// 1

|};



/**
 * Provides a method for displaying a UI, by which the UI contains options for the capture of photos, audio recordings and videos.
 */
declare class Windows$Media$Capture$CameraOptionsUI  {

/**
 * Displays a UI that contains options for the capture of photos, audio recordings and videos.
 * @param mediaCapture The MediaCapture object that provides methods for the capture of photos, audio recordings and videos.
 */
static show(mediaCapture: Windows$Media$Capture$MediaCapture): void
}


/**
 * Represents a captured video frame.
 */
declare class Windows$Media$Capture$CapturedFrame  {

/**
 * Gets a value that indicates if the captured frame can be read from.
 */
canRead: boolean;

/**
 * Gets a value that indicates if the captured frame can be written to.
 */
canWrite: boolean;

/**
 * Creates a copy of the stream.
 * @return The clone of the strem.
 */
cloneStream(): Windows$Storage$Streams$IRandomAccessStream;

/**
 * Closes the captured framed object.
 */
close(): void;

/**
 * Gets the content type of the captured frame.
 */
contentType: string;

/**
 * Asynchronously commits and flushes all of the data of the CapturedFrame .
 * @return When this method completes, a boolean value is returned which specifies true if the operation completed successfully; otherwise, false.
 */
flushAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets the input stream at the specified position.
 * @param position The position in the input stream.
 * @return The input stream.
 */
getInputStreamAt(position: number): Windows$Storage$Streams$IInputStream;

/**
 * Gets the output stream at the specified position.
 * @param position The position in the output stream.
 * @return The output stream.
 */
getOutputStreamAt(position: number): Windows$Storage$Streams$IOutputStream;

/**
 * Gets the height of the captured frame
 */
height: number;

/**
 * Gets the position of the captured frame.
 */
position: number;

/**
 * Returns an asynchronous byte reader object.
 * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param count The number of bytes to read that is less than or equal to the Capacity value.
 * @param options Specifies the type of the asynchronous read operation.
 * @return The asynchronous operation.
 */
readAsync(
buffer: Windows$Storage$Streams$IBuffer,
count: number,
options: $Values<typeof Windows$Storage$Streams$InputStreamOptions>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>;

/**
 * Seeks the stream to the specified position.
 * @param position The position in the stream to seek too.
 */
seek(position: number): void;

/**
 * Gets the size of the captured frame in bytes.
 */
size: number;

/**
 * Gets a SoftwareBitmap object representing the captured frame.
 */
softwareBitmap: Windows$Graphics$Imaging$SoftwareBitmap;

/**
 * Gets the width of the captured frame.
 */
width: number;

/**
 * Asynchronously writes the specified data to the stream.
 * @param buffer The data to write to the stream.
 * @return Represents an asynchronous operation that returns a result and reports progress.
 */
writeAsync(
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Provides information about the capture device settings that were used for a frame in a variable photo sequence.
 */
declare class Windows$Media$Capture$CapturedFrameControlValues  {

/**
 * Gets the exposure time used for a frame in a variable photo sequence.
 */
exposure: number;

/**
 * Gets the exposure compensation value used for a frame in a variable photo sequence.
 */
exposureCompensation: number;

/**
 * Gets the flash power used for a frame in a variable photo sequence.
 */
flashPowerPercent: number;

/**
 * Gets a value indicating if the flash was used for a frame in a variable photo sequence.
 */
flashed: boolean;

/**
 * Gets the focus lens position used for a frame in a variable photo sequence.
 */
focus: number;

/**
 * Gets the focus state for a frame in a variable photo sequence.
 */
focusState: $Values<typeof Windows$Media$Devices$MediaCaptureFocusState>;

/**
 * Gets the ISO analog gain used for a frame in a variable photo sequence.
 */
isoAnalogGain: number;

/**
 * Gets the ISO digital gain used for a frame in a variable photo sequence.
 */
isoDigitalGain: number;

/**
 * Gets the ISO speed used for a frame in a variable photo sequence.
 */
isoSpeed: number;

/**
 * Gets the scene mode used for a frame in a variable photo sequence.
 */
sceneMode: $Values<typeof Windows$Media$Devices$CaptureSceneMode>;

/**
 * Gets the sensor frame rate used for a frame in a variable photo sequence.
 */
sensorFrameRate: Windows$Media$MediaProperties$MediaRatio;

/**
 * Gets the white balance setting used for a frame in a variable photo sequence.
 */
whiteBalance: number;

/**
 * Gets the white balance gain used for a frame in a variable photo sequence.
 */
whiteBalanceGain: Windows$Media$Capture$WhiteBalanceGain;

/**
 * Gets the zoom factor used for a frame in a variable photo sequence.
 */
zoomFactor: number
}


/**
 * Represents a photo taken from a capture device such as a webcam attached.
 */
declare class Windows$Media$Capture$CapturedPhoto  {

/**
 * Gets the photo data, represented as CapturedFrame object, associated with the CapturedPhoto object.
 */
frame: Windows$Media$Capture$CapturedFrame;

/**
 * Represents a thumbnail image of the capture photo.
 */
thumbnail: Windows$Media$Capture$CapturedFrame
}


      declare var npm$namespace$Windows$Media$Capture$Core: {
        
        
        
        VariablePhotoCapturedEventArgs: typeof Windows$Media$Capture$Core$VariablePhotoCapturedEventArgs,
VariablePhotoSequenceCapture: typeof Windows$Media$Capture$Core$VariablePhotoSequenceCapture,
        
      }

/**
 * Provides data for the PhotoCaptured event.
 */
declare class Windows$Media$Capture$Core$VariablePhotoCapturedEventArgs  {

/**
 * Gets the time offset of the capture of the associated frame in a variable photo sequence.
 */
captureTimeOffset: number;

/**
 * Gets a CapturedFrameControlValues object that indicates the capture settings used for the associated frame in a variable photo sequence.
 */
capturedFrameControlValues: Windows$Media$Capture$CapturedFrameControlValues;

/**
 * Gets a CapturedFrame object representing a captured frame of a variable photo sequence.
 */
frame: Windows$Media$Capture$CapturedFrame;

/**
 * Gets an index value that indicates which element of the DesiredFrameControllers vector was used to specify the requested control values for the associated frame of a variable photo sequence.
 */
usedFrameControllerIndex: number
}


/**
 * Provides methods and events that enable the capture of variable photo sequences.
 */
declare class Windows$Media$Capture$Core$VariablePhotoSequenceCapture  {

/**
 * Asynchronously releases the VariablePhotoSequenceCapture object and resources used by the capture operation.
 * @return An asynchronous action.
 */
finishAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Occurs when a frame of a variable photo sequence is captured.
 */
onphotocaptured: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$Core$VariablePhotoSequenceCapture, Windows$Media$Capture$Core$VariablePhotoCapturedEventArgs>;
addEventListener(
type: "photocaptured",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$Core$VariablePhotoSequenceCapture, Windows$Media$Capture$Core$VariablePhotoCapturedEventArgs>): void;
removeEventListener(
type: "photocaptured",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$Core$VariablePhotoSequenceCapture, Windows$Media$Capture$Core$VariablePhotoCapturedEventArgs>): void;

/**
 * Occurs when the VariablePhotoSequenceCapture object stops capturing frames for a variable photo sequence.
 */
onstopped: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$Core$VariablePhotoSequenceCapture, any>;
addEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$Core$VariablePhotoSequenceCapture, any>): void;
removeEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$Core$VariablePhotoSequenceCapture, any>): void;

/**
 * Starts the capturing of variable photo sequence frames.
 * @return An asynchronous action.
 */
startAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Stops the capturing of variable photo sequence frames.
 * @return An asynchronous action.
 */
stopAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Updates the frame control values of the variable photo sequence.
 * @return An asynchronous action.
 */
updateSettingsAsync(): Windows$Foundation$IPromiseWithIAsyncAction;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies the names of video recording profiles that are known by the system.
 */

declare  var Windows$Media$Capture$KnownVideoProfile: {|
  +videoRecording: 0,// 0
+highQualityPhoto: 1,// 1
+balancedVideoAndPhoto: 2,// 2
+videoConferencing: 3,// 3
+photoSequence: 4,// 4

|};



/**
 * Provides methods for taking a low lag media recording.
 */
declare class Windows$Media$Capture$LowLagMediaRecording  {

/**
 * Asynchronously releases the LowLagMediaRecording object and resources used by the media recording operation.
 * @return Object that is used to control the asynchronous operation.
 */
finishAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Pauses an ongoing low lag media record operation
 * @param behavior A value indicating whether the media capture hardware resources should be preserved or released while recording is paused.
 * @return An asynchronous action.
 */
pauseAsync(
behavior: $Values<typeof Windows$Media$Devices$MediaCapturePauseBehavior>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Resumes a paused low lag recording operation.
 * @return An asynchronous action.
 */
resumeAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously starts the low lag media recording.
 * @return Object that is used to control the asynchronous operation.
 */
startAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously stops the low lag media recording.
 * @return Object that is used to control the asynchronous operation.
 */
stopAsync(): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Provides methods for taking a low shutter lag photo.
 */
declare class Windows$Media$Capture$LowLagPhotoCapture  {

/**
 * Asynchronously captures a low shutter lag photo.
 * @return When this method completes, a CapturedPhoto object is returned which contains the captured photo.
 */
captureAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Capture$CapturedPhoto>;

/**
 * Asynchronously releases the LowLagPhotoCapture object and resources used by the capture photo operation.
 * @return Object that is used to control the asynchronous operation.
 */
finishAsync(): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Provides methods for taking a rapid sequence of low shutter lag photos.
 */
declare class Windows$Media$Capture$LowLagPhotoSequenceCapture  {

/**
 * Asynchronously releases the LowLagPhotoSequenceCapture object and resources used by the photo sequence capture operation.
 * @return Object that is used to control the asynchronous operation.
 */
finishAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Occurs when a photo has been captured.
 */
onphotocaptured: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$LowLagPhotoSequenceCapture, Windows$Media$Capture$PhotoCapturedEventArgs>;
addEventListener(
type: "photocaptured",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$LowLagPhotoSequenceCapture, Windows$Media$Capture$PhotoCapturedEventArgs>): void;
removeEventListener(
type: "photocaptured",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$LowLagPhotoSequenceCapture, Windows$Media$Capture$PhotoCapturedEventArgs>): void;

/**
 * Asynchronously starts capturing photos.
 * @return Object that is used to control the asynchronous operation.
 */
startAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously stops capturing photos.
 * @return Object that is used to control the asynchronous operation.
 */
stopAsync(): Windows$Foundation$IPromiseWithIAsyncAction;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides functionality for capturing photos, audio, and videos from a capture device, such as a webcam.
 */
declare class Windows$Media$Capture$MediaCapture  {

/**
 * Retrieves the list of all video profiles supported by the specified video capture device.
 * @param videoDeviceId The identifier of the video device for which supported video profiles are queried. For information on getting the video device ID, see DeviceInformation::FindAllAsync .
 * @return The list of video profiles supported by the specified video capture device.
 */
static findAllVideoProfiles(
videoDeviceId: string): Windows$Foundation$Collections$IVectorView<Windows$Media$Capture$MediaCaptureVideoProfile>;

/**
 * Retrieves the list of video profiles supported by the specified video capture device that can be used while another profile is used on a different capture device.
 * @param videoDeviceId The identifier of the video device for which supported video profiles are queried. For information on getting the video device ID, see DeviceInformation::FindAllAsync .
 * @return The list of video profiles supported by the specified video capture device that support concurrency.
 */
static findConcurrentProfiles(
videoDeviceId: string): Windows$Foundation$Collections$IVectorView<Windows$Media$Capture$MediaCaptureVideoProfile>;

/**
 * Retrieves the list of all video profiles supported by the specified video capture device that match the specified KnownVideoProfile value.
 * @param videoDeviceId The identifier of the video device for which supported video profiles are queried. For information on getting the video device ID, see DeviceInformation::FindAllAsync .
 * @param name A value specifying one of the profile names known by the system.
 * @return The list of video profiles supported by the specified video capture device that match the specified known profile name.
 */
static findKnownVideoProfiles(
videoDeviceId: string,
name: $Values<typeof Windows$Media$Capture$KnownVideoProfile>): Windows$Foundation$Collections$IVectorView<Windows$Media$Capture$MediaCaptureVideoProfile>;

/**
 * Gets a boolean value indicating whether video profiles are supported by the specified video capture device.
 * @param videoDeviceId The identifier of the video device for which supported video profile support is queried. For information on getting the video device ID, see DeviceInformation::FindAllAsync .
 * @return True if video profiles are supported; otherwise, false.
 */
static isVideoProfileSupported(videoDeviceId: string): boolean;

/**
 * Creates a new instance of the MediaCapture object.
 */
constructor(): this;

/**
 * Adds an audio effect to the capture pipeline.
 * @param definition The object containing the definition of the effect to be added.
 * @return An asynchronous operation that returns an IMediaExtension upon successful completion.
 */
addAudioEffectAsync(
definition: Windows$Media$Effects$IAudioEffectDefinition): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$IMediaExtension>;

/**
 * Adds an audio or video effect.
 * @param mediaStreamType Specifies the streams to which the effect will be applied.
 * @param effectActivationID The class identifier of the activatable runtime class that implements the effect. The runtime class must implement the IMediaExtension interface.
 * @param effectSettings Configuration parameters for the effect.
 * @return Returns an IAsyncAction object that is used to control the asynchronous operation.
 */
addEffectAsync(
mediaStreamType: $Values<typeof Windows$Media$Capture$MediaStreamType>,
effectActivationID: string,
effectSettings: Windows$Foundation$Collections$IPropertySet): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Adds a video effect to the capture pipeline.
 * @param definition The object containing the definition of the effect to be added.
 * @param mediaStreamType Specifies the streams to which the effect will be applied.
 * @return An asynchronous operation that returns an IMediaExtension upon successful completion.
 */
addVideoEffectAsync(
definition: Windows$Media$Effects$IVideoEffectDefinition,
mediaStreamType: $Values<typeof Windows$Media$Capture$MediaStreamType>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$IMediaExtension>;

/**
 * Gets an object that controls settings for the microphone.
 */
audioDeviceController: Windows$Media$Devices$AudioDeviceController;

/**
 * Gets the current stream state of the camera stream.
 */
cameraStreamState: $Values<typeof Windows$Media$Devices$CameraStreamState>;

/**
 * Captures a photo to a storage file.
 * @param type The encoding properties for the output image.
 * @param file The storage file where the image is saved.
 * @return Returns an IAsyncAction object that is used to control the asynchronous operation.
 */
capturePhotoToStorageFileAsync(
type: Windows$Media$MediaProperties$ImageEncodingProperties,
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Captures a photo to a random-access stream.
 * @param type The encoding properties for the output image.
 * @param stream The stream where the image data is written.
 * @return Returns an IAsyncAction object that is used to control the asynchronous operation.
 */
capturePhotoToStreamAsync(
type: Windows$Media$MediaProperties$ImageEncodingProperties,
stream: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Removes all audio and video effects from a stream.
 * @param mediaStreamType The stream from which to remove the effects.
 * @return Returns a IAsyncAction object that is used to control the asynchronous operation.
 */
clearEffectsAsync(
mediaStreamType: $Values<typeof Windows$Media$Capture$MediaStreamType>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Closes the media capture object.
 */
close(): void;

/**
 * Gets the value of an encoding property.
 * @param mediaStreamType Specifies the stream to query for the encoding property.
 * @param propertyId The encoding property to retrieve.
 * @return Returns the value of the encoding property.
 */
getEncoderProperty(
mediaStreamType: $Values<typeof Windows$Media$Capture$MediaStreamType>,
propertyId: string): any;

/**
 * Gets a preview frame from the capture device.
 * @return An asynchronous operation that returns a VideoFrame on successful completion.
 */
getPreviewFrameAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$VideoFrame>;

/**
 * Gets a preview frame from the capture device, copied into the provided destination VideoFrame and converted into the destination frame's format.
 * @param destination The video frame into which the preview frame will be copied.
 * @return An asynchronous operation that returns a VideoFrame on successful completion.
 */
getPreviewFrameAsync(
destination: Windows$Media$VideoFrame): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$VideoFrame>;

/**
 * Queries whether the video stream is mirrored horizontally.
 * @return True if mirroring is enabled; false otherwise.
 */
getPreviewMirroring(): boolean;

/**
 * Gets the rotation of the video preview stream.
 * @return The amount by which the video preview stream is rotated.
 */
getPreviewRotation(): $Values<typeof Windows$Media$Capture$VideoRotation>;

/**
 * Gets the rotation of the recorded video.
 * @return The amount by which the recorded video is rotated.
 */
getRecordRotation(): $Values<typeof Windows$Media$Capture$VideoRotation>;

/**
 * Initializes the MediaCapture object, using default settings.
 * @return Returns a IAsyncAction object that is used to control the asynchronous operation.
 */
initializeAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Initializes the MediaCapture object.
 * @param mediaCaptureInitializationSettings The initialization settings.
 * @return Returns a IAsyncAction object that is used to control the asynchronous operation.
 */
initializeAsync(
mediaCaptureInitializationSettings: Windows$Media$Capture$MediaCaptureInitializationSettings): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the configuration settings for the MediaCapture object.
 */
mediaCaptureSettings: Windows$Media$Capture$MediaCaptureSettings;

/**
 * Occurs when the state of the camera stream changes.
 */
oncamerastreamstatechanged: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$MediaCapture, any>;
addEventListener(
type: "camerastreamstatechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$MediaCapture, any>): void;
removeEventListener(
type: "camerastreamstatechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$MediaCapture, any>): void;

/**
 * Raised when an error occurs during media capture.
 */
onfailed: Windows$Media$Capture$MediaCaptureFailedEventHandler;
addEventListener(
type: "failed",
listener: Windows$Media$Capture$MediaCaptureFailedEventHandler): void;
removeEventListener(
type: "failed",
listener: Windows$Media$Capture$MediaCaptureFailedEventHandler): void;

/**
 * Occurs when the capture device changes focus.
 */
onfocuschanged: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$MediaCapture, Windows$Media$Capture$MediaCaptureFocusChangedEventArgs>;
addEventListener(
type: "focuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$MediaCapture, Windows$Media$Capture$MediaCaptureFocusChangedEventArgs>): void;
removeEventListener(
type: "focuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$MediaCapture, Windows$Media$Capture$MediaCaptureFocusChangedEventArgs>): void;

/**
 * Occurs when a photo confirmation frame is captured.
 */
onphotoconfirmationcaptured: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$MediaCapture, Windows$Media$Capture$PhotoConfirmationCapturedEventArgs>;
addEventListener(
type: "photoconfirmationcaptured",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$MediaCapture, Windows$Media$Capture$PhotoConfirmationCapturedEventArgs>): void;
removeEventListener(
type: "photoconfirmationcaptured",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$MediaCapture, Windows$Media$Capture$PhotoConfirmationCapturedEventArgs>): void;

/**
 * Occurs when the record limit is exceeded.
 */
onrecordlimitationexceeded: Windows$Media$Capture$RecordLimitationExceededEventHandler;
addEventListener(
type: "recordlimitationexceeded",
listener: Windows$Media$Capture$RecordLimitationExceededEventHandler): void;
removeEventListener(
type: "recordlimitationexceeded",
listener: Windows$Media$Capture$RecordLimitationExceededEventHandler): void;

/**
 * Occurs when the thermal status of the capture device changes.
 */
onthermalstatuschanged: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$MediaCapture, any>;
addEventListener(
type: "thermalstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$MediaCapture, any>): void;
removeEventListener(
type: "thermalstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Capture$MediaCapture, any>): void;

/**
 * Pauses an ongoing record operation.
 * @param behavior A value indicating whether the media capture hardware resources should be preserved or released while recording is paused.
 * @return An asynchronous action.
 */
pauseRecordAsync(
behavior: $Values<typeof Windows$Media$Devices$MediaCapturePauseBehavior>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Initializes the advanced photo capture and provides the AdvancedPhotoCapture object used to manage the recording.
 * @param encodingProperties The encoding properties used for the resulting image.
 * @return An asynchronous operation that returns an AdvancedPhotoCapture object on successful completion.
 */
prepareAdvancedPhotoCaptureAsync(
encodingProperties: Windows$Media$MediaProperties$ImageEncodingProperties): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Capture$AdvancedPhotoCapture>;

/**
 * Initializes the low shutter lag photo capture and provides the LowLagPhotoCapture object used to manage the recording.
 * @param type The encoding profile used for the image.
 * @return When this method completes, a LowLagPhotoCapture object is returned which can be used to start the photo capture.
 */
prepareLowLagPhotoCaptureAsync(
type: Windows$Media$MediaProperties$ImageEncodingProperties): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Capture$LowLagPhotoCapture>;

/**
 * Initializes the low shutter lag photo sequence capture and provides the LowLagPhotoSequenceCapture object used to manage the recording.
 * @param type The encoding profile used for the image.
 * @return When this method completes, a LowLagPhotoSequenceCapture object is returned which can be used to start the photo sequence capture.
 */
prepareLowLagPhotoSequenceCaptureAsync(
type: Windows$Media$MediaProperties$ImageEncodingProperties): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Capture$LowLagPhotoSequenceCapture>;

/**
 * Initializes the low lag recording using the specified custom sink to store the recording. This method provides the LowLagMediaRecording object used to managed the capture.
 * @param encodingProfile The encoding profile to use for the recording.
 * @param customMediaSink The media extension for the custom media sink.
 * @return When this method completes, a LowLagMediaRecording object is returned which can be used to start the photo capture.
 */
prepareLowLagRecordToCustomSinkAsync(
encodingProfile: Windows$Media$MediaProperties$MediaEncodingProfile,
customMediaSink: Windows$Media$IMediaExtension): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Capture$LowLagMediaRecording>;

/**
 * Initializes the low lag recording using the specified custom sink to store the recording. This method provides the LowLagMediaRecording object used to managed the recording.
 * @param encodingProfile The encoding profile to use for the recording.
 * @param customSinkActivationId The activatable class ID of the media extension for the custom media sink.
 * @param customSinkSettings Contains properties of the media extension.
 * @return When this method completes, a LowLagMediaRecording object is returned which can be used to start the photo capture.
 */
prepareLowLagRecordToCustomSinkAsync(
encodingProfile: Windows$Media$MediaProperties$MediaEncodingProfile,
customSinkActivationId: string,
customSinkSettings: Windows$Foundation$Collections$IPropertySet): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Capture$LowLagMediaRecording>;

/**
 * Initializes the low lag recording using the specified file to store the recording. This method provides the LowLagMediaRecording object used to managed the recording.
 * @param encodingProfile The encoding profile for the recording.
 * @param file The storage file where the image is saved.
 * @return When this method completes, a LowLagMediaRecording object is returned which can be used to start the photo capture.
 */
prepareLowLagRecordToStorageFileAsync(
encodingProfile: Windows$Media$MediaProperties$MediaEncodingProfile,
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Capture$LowLagMediaRecording>;

/**
 * Initializes the low lag recording using the specified random-access stream to store the recording. This method provides the LowLagMediaRecording object used to managed the recording.
 * @param encodingProfile The encoding profile for the recording.
 * @param stream The stream where the image data is written.
 * @return When this method completes, a LowLagMediaRecording object is returned which can be used to start the photo capture.
 */
prepareLowLagRecordToStreamAsync(
encodingProfile: Windows$Media$MediaProperties$MediaEncodingProfile,
stream: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Capture$LowLagMediaRecording>;

/**
 * Initializes the variable photo sequence capture and provides the VariablePhotoSequenceCapture object used to manage the recording.
 * @param type The encoding profile used for the image.
 * @return When this method completes, a VariablePhotoSequenceCapture object is returned which can be used to start the photo sequence capture.
 */
prepareVariablePhotoSequenceCaptureAsync(
type: Windows$Media$MediaProperties$ImageEncodingProperties): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Capture$Core$VariablePhotoSequenceCapture>;

/**
 * Resumes a paused recording operation.
 * @return An asynchronous operation.
 */
resumeRecordAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Sets an encoding property.
 * @param mediaStreamType The type of media data the stream represents, such as video or audio.
 * @param propertyId The encoding property to set.
 * @param propertyValue The new value of the encoding property.
 */
setEncoderProperty(
mediaStreamType: $Values<typeof Windows$Media$Capture$MediaStreamType>,
propertyId: string,
propertyValue: any): void;

/**
 * Asynchronously sets the media encoding properties.
 * @param mediaStreamType The type of media data the stream represents, such as video or audio.
 * @param mediaEncodingProperties The properties for the media encoding.
 * @param encoderProperties The properties for the encoder.
 * @return Object that is used to control the asynchronous operation.
 */
setEncodingPropertiesAsync(
mediaStreamType: $Values<typeof Windows$Media$Capture$MediaStreamType>,
mediaEncodingProperties: Windows$Media$MediaProperties$IMediaEncodingProperties,
encoderProperties: Windows$Media$MediaProperties$MediaPropertySet): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Enables or disables horizontal mirroring of the video preview stream. This is not the preferred method for mirroring. See the Remarks section below for details.
 * @param value True to enable mirroring; false to disable mirroring.
 */
setPreviewMirroring(value: boolean): void;

/**
 * Rotates the video preview stream.
 * @param value The amount by which to rotate the video.
 */
setPreviewRotation(value: $Values<typeof Windows$Media$Capture$VideoRotation>): void;

/**
 * Rotates the recorded video.
 * @param value The amount by which to rotate the video.
 */
setRecordRotation(value: $Values<typeof Windows$Media$Capture$VideoRotation>): void;

/**
 * Start recording to a custom media sink using the specified encoding profile and sink settings.
 * @param encodingProfile The encoding profile to use for the recording.
 * @param customSinkActivationId The activatable class ID of the media extension for the custom media sink.
 * @param customSinkSettings Contains properties of the media extension.
 * @return Anobject that is used to control the asynchronous operation.
 */
startRecordToCustomSinkAsync(
encodingProfile: Windows$Media$MediaProperties$MediaEncodingProfile,
customSinkActivationId: string,
customSinkSettings: Windows$Foundation$Collections$IPropertySet): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Start recording to a custom media sink using the specified encoding profile.
 * @param encodingProfile The encoding profile to use for the recording.
 * @param customMediaSink The media extension for the custom media sink.
 * @return An object that is used to control the asynchronous operation.
 */
startRecordToCustomSinkAsync(
encodingProfile: Windows$Media$MediaProperties$MediaEncodingProfile,
customMediaSink: Windows$Media$IMediaExtension): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Starts recording asynchronously to a storage file.
 * @param encodingProfile The encoding profile for the recording.
 * @param file The storage file where the image is saved.
 * @return Returns a IAsyncAction object that is used to control the asynchronous operation.
 */
startRecordToStorageFileAsync(
encodingProfile: Windows$Media$MediaProperties$MediaEncodingProfile,
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Starts recording to a random-access stream.
 * @param encodingProfile The encoding profile for the recording.
 * @param stream The stream where the image data is written.
 * @return Returns a IAsyncAction object that is used to control the asynchronous operation.
 */
startRecordToStreamAsync(
encodingProfile: Windows$Media$MediaProperties$MediaEncodingProfile,
stream: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Stops recording.
 * @return Returns a IAsyncAction object that is used to control the asynchronous operation.
 */
stopRecordAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets a value that indicates the current thermal status of the capture device.
 */
thermalStatus: $Values<typeof Windows$Media$Capture$MediaCaptureThermalStatus>;

/**
 * Gets an object that controls settings for the video camera.
 */
videoDeviceController: Windows$Media$Devices$VideoDeviceController;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the MediaCapture.Failed event.
 */
declare class Windows$Media$Capture$MediaCaptureFailedEventArgs  {

/**
 * The error code of the error that caused the event.
 */
code: number;

/**
 * A message string for the error.
 */
message: string
}


/**
 * Provides data for the FocusChanged event.
 */
declare class Windows$Media$Capture$MediaCaptureFocusChangedEventArgs  {

/**
 * Gets the current focus state of the capture device.
 */
focusState: $Values<typeof Windows$Media$Devices$MediaCaptureFocusState>
}


/**
 * Contains initialization settings for the MediaCapture object which are passed to the MediaCapture.InitializeAsync method.
 */
declare class Windows$Media$Capture$MediaCaptureInitializationSettings  {

/**
 * Creates a new instance of the MediaCaptureInitializationSettings object.
 */
constructor(): this;

/**
 * Gets the DeviceInformation.Id of the microphone.
 */
audioDeviceId: string;

/**
 * Gets or sets a value that specifies the audio processing mode.
 */
audioProcessing: $Values<typeof Windows$Media$AudioProcessing>;

/**
 * Gets or sets the audio source for the capture operation.
 */
audioSource: Windows$Media$Core$IMediaSource;

/**
 * Gets or set the media category.
 */
mediaCategory: $Values<typeof Windows$Media$Capture$MediaCategory>;

/**
 * Gets or sets the stream that is used for photo capture.
 */
photoCaptureSource: $Values<typeof Windows$Media$Capture$PhotoCaptureSource>;

/**
 * Gets or sets the media description for photo capture.
 */
photoMediaDescription: Windows$Media$Capture$MediaCaptureVideoProfileMediaDescription;

/**
 * Gets or sets the media description for preview video.
 */
previewMediaDescription: Windows$Media$Capture$MediaCaptureVideoProfileMediaDescription;

/**
 * Gets or sets the media description for video recording.
 */
recordMediaDescription: Windows$Media$Capture$MediaCaptureVideoProfileMediaDescription;

/**
 * Gets or sets the streaming mode.
 */
streamingCaptureMode: $Values<typeof Windows$Media$Capture$StreamingCaptureMode>;

/**
 * Gets the DeviceInformation.Id of the video camera.
 */
videoDeviceId: string;

/**
 * Gets or sets the video profile which provides hints to the driver to allow it to optimize for different capture scenarios.
 */
videoProfile: Windows$Media$Capture$MediaCaptureVideoProfile;

/**
 * Gets or sets the video source for the capture operation.
 */
videoSource: Windows$Media$Core$IMediaSource
}


/**
 * Contains read-only configuration settings for the MediaCapture object.
 */
declare class Windows$Media$Capture$MediaCaptureSettings  {

/**
 * Gets the DeviceInformation.Id of the microphone.
 */
audioDeviceId: string;

/**
 * Gets the audio processing mode.
 */
audioProcessing: $Values<typeof Windows$Media$AudioProcessing>;

/**
 * Gets a value that indicates if the operating system will make a sound when the capture device takes a picture.
 */
cameraSoundRequiredForRegion: boolean;

/**
 * Gets a value that indicates if the capture device supports recording video and taking a photo sequence at the same time.
 */
concurrentRecordAndPhotoSequenceSupported: boolean;

/**
 * Gets a value that indicates if the capture device supports recording video and taking a photo at the same time.
 */
concurrentRecordAndPhotoSupported: boolean;

/**
 * Gets the horizontal 35mm equivalent focal length of the camera lens on the capture device.
 */
horizontal35mmEquivalentFocalLength: number;

/**
 * Gets the media category of the media.
 */
mediaCategory: $Values<typeof Windows$Media$Capture$MediaCategory>;

/**
 * Gets the stream that is used for photo capture.
 */
photoCaptureSource: $Values<typeof Windows$Media$Capture$PhotoCaptureSource>;

/**
 * Gets the pitch offset of the camera in degrees.
 */
pitchOffsetDegrees: number;

/**
 * Gets the streaming mode.
 */
streamingCaptureMode: $Values<typeof Windows$Media$Capture$StreamingCaptureMode>;

/**
 * Gets the vertical 35mm equivalent focal length of the camera lens on the capture device.
 */
vertical35mmEquivalentFocalLength: number;

/**
 * Gets a value that indicates which video streams are independent of each other.
 */
videoDeviceCharacteristic: $Values<typeof Windows$Media$Capture$VideoDeviceCharacteristic>;

/**
 * Gets the DeviceInformation.Id of the video camera.
 */
videoDeviceId: string
}


/**
 * Specifies the thermal status of a media capture device.
 */

declare  var Windows$Media$Capture$MediaCaptureThermalStatus: {|
  +normal: 0,// 0
+overheated: 1,// 1

|};



/**
 * Represents a video profile that indicates a configuration supported by the video capture device.
 */
declare class Windows$Media$Capture$MediaCaptureVideoProfile  {

/**
 * Gets the list of MediaCaptureVideoProfile objects that can be used concurrently with this video profile.
 * @return The list of MediaCaptureVideoProfile objects that can be used concurrently with this video profile.
 */
getConcurrency(
): Windows$Foundation$Collections$IVectorView<Windows$Media$Capture$MediaCaptureVideoProfile>;

/**
 * Gets the unique identifier of the video profile.
 */
id: string;

/**
 * Gets a list of MediaCaptureVideoProfileMediaDescription objects that represent supported video device settings for photo capture.
 */
supportedPhotoMediaDescription: Windows$Foundation$Collections$IVectorView<Windows$Media$Capture$MediaCaptureVideoProfileMediaDescription>;

/**
 * Gets a list of MediaCaptureVideoProfileMediaDescription objects that represent supported video device settings for video preview.
 */
supportedPreviewMediaDescription: Windows$Foundation$Collections$IVectorView<Windows$Media$Capture$MediaCaptureVideoProfileMediaDescription>;

/**
 * Gets a list of MediaCaptureVideoProfileMediaDescription objects that represent supported video device settings for video recording.
 */
supportedRecordMediaDescription: Windows$Foundation$Collections$IVectorView<Windows$Media$Capture$MediaCaptureVideoProfileMediaDescription>;

/**
 * Gets the device ID of the video device associated with the video profile.
 */
videoDeviceId: string
}


/**
 * Represents a description of media that is supported by a video profile.
 */
declare class Windows$Media$Capture$MediaCaptureVideoProfileMediaDescription  {

/**
 * Gets the frame rate of the media description.
 */
frameRate: number;

/**
 * Gets the height of the media description.
 */
height: number;

/**
 * Gets a value indicating if the media description includes HDR video support.
 */
isHdrVideoSupported: boolean;

/**
 * Gets a value indicating if the media description includes variable photo sequence support.
 */
isVariablePhotoSequenceSupported: boolean;

/**
 * Gets the height of the media description.
 */
width: number
}


/**
 * Defines values for types of media categories.
 */

declare  var Windows$Media$Capture$MediaCategory: {|
  +other: 0,// 0
+communications: 1,// 1
+media: 2,// 2
+gameChat: 3,// 3
+speech: 4,// 4

|};



/**
 * Specifies a type of stream on a media capture device.
 */

declare  var Windows$Media$Capture$MediaStreamType: {|
  +videoPreview: 0,// 0
+videoRecord: 1,// 1
+audio: 2,// 2
+photo: 3,// 3

|};



/**
 * Provides data for the AdvancedPhotoCapture::OptionalReferencePhotoCaptured event.
 */
declare class Windows$Media$Capture$OptionalReferencePhotoCapturedEventArgs  {

/**
 * Gets the app-defined context object associated with the advanced photo capture operation, if one was provided in the call to AdvancedPhotoCapture::CaptureAsync(Object) .
 */
context: any;

/**
 * Gets the captured frame containing the reference photo from the advanced photo capture.
 */
frame: Windows$Media$Capture$CapturedFrame
}


/**
 * Specifies which stream on a video camera is used to capture photos.
 */

declare  var Windows$Media$Capture$PhotoCaptureSource: {|
  +auto: 0,// 0
+videoPreview: 1,// 1
+photo: 2,// 2

|};



/**
 * Provides data for the photo sequence PhotoCaptured event.
 */
declare class Windows$Media$Capture$PhotoCapturedEventArgs  {

/**
 * Gets a value that indicates time offset in the photo sequence.
 */
captureTimeOffset: number;

/**
 * Gets the captured image associated with the event.
 */
frame: Windows$Media$Capture$CapturedFrame;

/**
 * Gets a thumbnail version of the captured image associated with the event.
 */
thumbnail: Windows$Media$Capture$CapturedFrame
}


/**
 * Provides data for the PhotoConfirmationCaptured event.
 */
declare class Windows$Media$Capture$PhotoConfirmationCapturedEventArgs  {

/**
 * Gets the time offset from when capture began to the capture of the frame associated with the event.
 */
captureTimeOffset: number;

/**
 * Gets the captured frame.
 */
frame: Windows$Media$Capture$CapturedFrame
}


/**
 * Specifies the local power line frequency.
 */

declare  var Windows$Media$Capture$PowerlineFrequency: {|
  +disabled: 0,// 0
+fiftyHertz: 1,// 1
+sixtyHertz: 2,// 2

|};



/**
 * Specifies the streaming mode for a media capture device.
 */

declare  var Windows$Media$Capture$StreamingCaptureMode: {|
  +audioAndVideo: 0,// 0
+audio: 1,// 1
+video: 2,// 2

|};



/**
 * Indicates which video streams are independent of each other.
 */

declare  var Windows$Media$Capture$VideoDeviceCharacteristic: {|
  +allStreamsIndependent: 0,// 0
+previewRecordStreamsIdentical: 1,// 1
+previewPhotoStreamsIdentical: 2,// 2
+recordPhotoStreamsIdentical: 3,// 3
+allStreamsIdentical: 4,// 4

|};



/**
 * Specifies the rotation of the video stream.
 */

declare  var Windows$Media$Capture$VideoRotation: {|
  +none: 0,// 0
+clockwise90Degrees: 1,// 1
+clockwise180Degrees: 2,// 2
+clockwise270Degrees: 3,// 3

|};



/**
 * Represents a set of input and output VideoEncodingProperties for a video stream
 */
declare class Windows$Media$Capture$VideoStreamConfiguration  {

/**
 * Gets a VideoEncodingProperties object representing an video stream input configuration.
 */
inputProperties: Windows$Media$MediaProperties$VideoEncodingProperties;

/**
 * Gets a VideoEncodingProperties object representing an video stream output configuration.
 */
outputProperties: Windows$Media$MediaProperties$VideoEncodingProperties
}


/**
 * Represents the red, green, and blue values of a white balance gain setting.
 */
declare interface Windows$Media$Capture$WhiteBalanceGain {

/**
 * The blue value of a white balance gain setting.
 */
b: number,

/**
 * The green value of a white balance gain setting.
 */
g: number,

/**
 * The red value of a white balance gain setting.
 */
r: number
} 


/**
 * Represents the method that will handle the MediaCapture.Failed event.
 */
declare type Windows$Media$Capture$MediaCaptureFailedEventHandler = (
ev: Windows$Media$Capture$MediaCaptureFailedEventArgs & Windows$WinRTEvent<Windows$Media$Capture$MediaCapture>) => void;


/**
 * Represents the method that will handle RecordLimitationExceeded and related events.
 */
declare type Windows$Media$Capture$RecordLimitationExceededEventHandler = (ev: Windows$WinRTEvent<Windows$Media$Capture$MediaCapture>) => void;


      declare var npm$namespace$Windows$Media$Casting: {
        
        
        CastingConnectionErrorStatus: typeof Windows$Media$Casting$CastingConnectionErrorStatus,
CastingConnectionState: typeof Windows$Media$Casting$CastingConnectionState,
CastingPlaybackTypes: typeof Windows$Media$Casting$CastingPlaybackTypes,
        CastingConnection: typeof Windows$Media$Casting$CastingConnection,
CastingConnectionErrorOccurredEventArgs: typeof Windows$Media$Casting$CastingConnectionErrorOccurredEventArgs,
CastingDevice: typeof Windows$Media$Casting$CastingDevice,
CastingDevicePicker: typeof Windows$Media$Casting$CastingDevicePicker,
CastingDevicePickerFilter: typeof Windows$Media$Casting$CastingDevicePickerFilter,
CastingDeviceSelectedEventArgs: typeof Windows$Media$Casting$CastingDeviceSelectedEventArgs,
CastingSource: typeof Windows$Media$Casting$CastingSource,
        
      }

/**
 * Represents the actual connection with a casting device.
 */
declare class Windows$Media$Casting$CastingConnection  {

/**
 * Closes the casting connection.
 */
close(): void;

/**
 * Gets the casting device with which a connection has been made.
 */
device: Windows$Media$Casting$CastingDevice;

/**
 * Terminates a casting connection. The content that was rendering remotely returns to the local element that you retrieved the casting source from.
 * @return The status of the termination.
 */
disconnectAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Media$Casting$CastingConnectionErrorStatus>>;

/**
 * Indicates an error occurred while attempting to make a casting connection.
 */
onerroroccurred: Windows$Foundation$TypedEventHandler<Windows$Media$Casting$CastingConnection, Windows$Media$Casting$CastingConnectionErrorOccurredEventArgs>;
addEventListener(
type: "erroroccurred",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Casting$CastingConnection, Windows$Media$Casting$CastingConnectionErrorOccurredEventArgs>): void;
removeEventListener(
type: "erroroccurred",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Casting$CastingConnection, Windows$Media$Casting$CastingConnectionErrorOccurredEventArgs>): void;

/**
 * Indicates a change in the State property.
 */
onstatechanged: Windows$Foundation$TypedEventHandler<Windows$Media$Casting$CastingConnection, any>;
addEventListener(
type: "statechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Casting$CastingConnection, any>): void;
removeEventListener(
type: "statechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Casting$CastingConnection, any>): void;

/**
 * Starts the process of casting to a casting device. When called, this method pairs the c sting device, if necessary, and verifies access to the casting device with the user. If the user denies the app access to the device, casting fails. Otherwise, a connection is established, and content is sent to the device. During this time, the connection state changes to connecting, then to connected. If a casting source is set, the state changes to rendering once playback begins.
 * @param value The content to be casted.
 * @return The status of the casting connection request.
 */
requestStartCastingAsync(
value: Windows$Media$Casting$CastingSource): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Media$Casting$CastingConnectionErrorStatus>>;

/**
 * Gets and sets the content source that is being casted through the connection to the casting device. The content can be set and changed at any time and doing so does not disconnect the connection.
 */
source: Windows$Media$Casting$CastingSource;

/**
 * Gets the current state of the connection.
 */
state: $Values<typeof Windows$Media$Casting$CastingConnectionState>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents arguments for the ErrorOccurred event from the CastingConnection
 */
declare class Windows$Media$Casting$CastingConnectionErrorOccurredEventArgs  {

/**
 * Gets the particular error that triggered the casting error event, ErrorOccurred .
 */
errorStatus: $Values<typeof Windows$Media$Casting$CastingConnectionErrorStatus>;

/**
 * Gets human-readable message to accompany the error status code, ErrorStatus .
 */
message: string
}


/**
 * Indicates the error status when starting or ending a casting connection.
 */

declare  var Windows$Media$Casting$CastingConnectionErrorStatus: {|
  +succeeded: 0,// 0
+deviceDidNotRespond: 1,// 1
+deviceError: 2,// 2
+deviceLocked: 3,// 3
+protectedPlaybackFailed: 4,// 4
+invalidCastingSource: 5,// 5
+unknown: 6,// 6

|};



/**
 * Indicates the current state of a casting connection. Rendering is used when actively playing content.
 */

declare  var Windows$Media$Casting$CastingConnectionState: {|
  +disconnected: 0,// 0
+connected: 1,// 1
+rendering: 2,// 2
+disconnecting: 3,// 3
+connecting: 4,// 4

|};



/**
 * Represents a physical device that is capable of supporting casting connections and rendering media content sent to it.
 */
declare class Windows$Media$Casting$CastingDevice  {

/**
 * Indicates whether the given device (a DeviceInformation object) supports casting.
 * @param device The device you want to know about.
 * @return True if the device supports casting; false otherwise.
 */
static deviceInfoSupportsCastingAsync(
device: Windows$Devices$Enumeration$DeviceInformation): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets a CastingDevice object for a given a device ID (acquired from a query using the Windows.Devices.Enumeration APIs).
 * @param value The device ID.
 * @return The object representing the casting device.
 */
static fromIdAsync(
value: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Casting$CastingDevice>;

/**
 * Gets an AQS filter string to be used with the Windows.Devices.Enumeration APIs for a given CastingPlaybackTypes .
 * @param type The casting playback type.
 * @return The AQS filter string.
 */
static getDeviceSelector(type: $Values<typeof Windows$Media$Casting$CastingPlaybackTypes>): string;

/**
 * Gets an AQS filter string to be used with the Windows.Devices.Enumeration APIs for a given CastingSource .
 * @param castingSource The casting source.
 * @return The AQS filter string.
 */
static getDeviceSelectorFromCastingSourceAsync(
castingSource: Windows$Media$Casting$CastingSource): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Creates a new CastingConnection object. This method does not establish a connection to the casting device.
 * @return The object that represents the casting connection.
 */
createCastingConnection(): Windows$Media$Casting$CastingConnection;

/**
 * A human-readable name for the device, retrieved from the device itself.
 */
friendlyName: string;

/**
 * Gets the media types supported by the device. containing
 * @return The media types, CastingPlaybackTypes , supported by the device.
 */
getSupportedCastingPlaybackTypesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Media$Casting$CastingPlaybackTypes>>;

/**
 * An icon representing the device.
 */
icon: Windows$Storage$Streams$IRandomAccessStreamWithContentType;

/**
 * The device ID. This is the same ID used with Windows.Devices.Enumeration APIs.
 */
id: string
}


/**
 * Represents a device picker that contains a list of casting devices for the user to choose from.
 */
declare class Windows$Media$Casting$CastingDevicePicker  {

/**
 * Creates a CastingDevicePicker object.
 */
constructor(): this;

/**
 * Gets the colors of the picker UI.
 */
appearance: Windows$Devices$Enumeration$DevicePickerAppearance;

/**
 * Gets the filter information for which devices to show in the picker.
 */
filter: Windows$Media$Casting$CastingDevicePickerFilter;

/**
 * Hides the device picker UI.
 */
hide(): void;

/**
 * Indicates that the user has dismissed the picker UI.
 */
oncastingdevicepickerdismissed: Windows$Foundation$TypedEventHandler<Windows$Media$Casting$CastingDevicePicker, any>;
addEventListener(
type: "castingdevicepickerdismissed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Casting$CastingDevicePicker, any>): void;
removeEventListener(
type: "castingdevicepickerdismissed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Casting$CastingDevicePicker, any>): void;

/**
 * Indicates that the user has selected a device from the picker.
 */
oncastingdeviceselected: Windows$Foundation$TypedEventHandler<Windows$Media$Casting$CastingDevicePicker, Windows$Media$Casting$CastingDeviceSelectedEventArgs>;
addEventListener(
type: "castingdeviceselected",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Casting$CastingDevicePicker, Windows$Media$Casting$CastingDeviceSelectedEventArgs>): void;
removeEventListener(
type: "castingdeviceselected",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Casting$CastingDevicePicker, Windows$Media$Casting$CastingDeviceSelectedEventArgs>): void;

/**
 * Shows the casting device picker UI, which flies out from the specified edge of the provided rectangle.
 * @param selection The rectangle from which the picker should fly out.
 * @param preferredPlacement The edge of the rectangle from which the picker should fly out.
 */
show(
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>): void;

/**
 * Shows the casting device picker UI, which flies out from an edge of the provided rectangle.
 * @param selection The rectangle from which the picker UI should fly out.
 */
show(selection: Windows$Foundation$Rect): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the filter used to determine which devices to show in a casting device picker UI. The filter parameters are OR-ed together to build the resulting filter. In other words, if SupportsAudio and SupportsVideo are both true, the picker will display Audio-only devices, video-only devices, and audio/video devices.
 */
declare class Windows$Media$Casting$CastingDevicePickerFilter  {

/**
 * Gets the casting sources supported.
 */
supportedCastingSources: Windows$Foundation$Collections$IVector<Windows$Media$Casting$CastingSource>;

/**
 * Gets and sets whether the devices in the device picker should support audio playback.
 */
supportsAudio: boolean;

/**
 * Gets and sets whether the devices in the device picker should support rending still images.
 */
supportsPictures: boolean;

/**
 * Gets and sets whether the devices in the device picker should support video playback.
 */
supportsVideo: boolean
}


/**
 * Represents the event arguments for the CastingDeviceSelected event on the CastingDevicePicker object.
 */
declare class Windows$Media$Casting$CastingDeviceSelectedEventArgs  {

/**
 * Represents the CastingDevice that has been selected by the user in a casting device picker.
 */
selectedCastingDevice: Windows$Media$Casting$CastingDevice
}


/**
 * Indicates the capabilities of a particular casting device.
 */

declare  var Windows$Media$Casting$CastingPlaybackTypes: {|
  +none: 0,// 0
+audio: 1,// 1
+video: 2,// 2
+picture: 3,// 3

|};



/**
 * Represents the media content that can be sent to another device.
 */
declare class Windows$Media$Casting$CastingSource  {

/**
 * Gets or sets an alternative URI for the content for use with DLNA ByRef.
 */
preferredSourceUri: Windows$Foundation$Uri
}


      declare var npm$namespace$Windows$Media$ClosedCaptioning: {
        
        
        ClosedCaptionColor: typeof Windows$Media$ClosedCaptioning$ClosedCaptionColor,
ClosedCaptionEdgeEffect: typeof Windows$Media$ClosedCaptioning$ClosedCaptionEdgeEffect,
ClosedCaptionOpacity: typeof Windows$Media$ClosedCaptioning$ClosedCaptionOpacity,
ClosedCaptionSize: typeof Windows$Media$ClosedCaptioning$ClosedCaptionSize,
ClosedCaptionStyle: typeof Windows$Media$ClosedCaptioning$ClosedCaptionStyle,
        ClosedCaptionProperties: typeof Windows$Media$ClosedCaptioning$ClosedCaptionProperties,
        
      }

/**
 * Specifies the color of closed caption UI elements.
 */

declare  var Windows$Media$ClosedCaptioning$ClosedCaptionColor: {|
  +default: 0,// 0
+white: 1,// 1
+black: 2,// 2
+red: 3,// 3
+green: 4,// 4
+blue: 5,// 5
+yellow: 6,// 6
+magenta: 7,// 7
+cyan: 8,// 8

|};



/**
 * Specifies the edge effect of closed caption text.
 */

declare  var Windows$Media$ClosedCaptioning$ClosedCaptionEdgeEffect: {|
  +default: 0,// 0
+none: 1,// 1
+raised: 2,// 2
+depressed: 3,// 3
+uniform: 4,// 4
+dropShadow: 5,// 5

|};



/**
 * Specifies the opacity of closed caption text.
 */

declare  var Windows$Media$ClosedCaptioning$ClosedCaptionOpacity: {|
  +default: 0,// 0
+oneHundredPercent: 1,// 1
+seventyFivePercent: 2,// 2
+twentyFivePercent: 3,// 3
+zeroPercent: 4,// 4

|};



/**
 * Exposes properties for retrieving the closed caption formatting settings that the user can set through the system's closed captioning settings page.
 */
declare class Windows$Media$ClosedCaptioning$ClosedCaptionProperties  {

/**
 * Gets the background color of lines of closed caption text.
 */
static backgroundColor: $Values<typeof Windows$Media$ClosedCaptioning$ClosedCaptionColor>;

/**
 * Gets the background opacity of lines of closed caption text.
 */
static backgroundOpacity: $Values<typeof Windows$Media$ClosedCaptioning$ClosedCaptionOpacity>;

/**
 * Gets the computed background color of lines of closed caption text.
 */
static computedBackgroundColor: Windows$UI$Color;

/**
 * Gets the computed font color for closed caption text.
 */
static computedFontColor: Windows$UI$Color;

/**
 * Gets the computed region color for closed caption text.
 */
static computedRegionColor: Windows$UI$Color;

/**
 * Gets the font color for closed caption text.
 */
static fontColor: $Values<typeof Windows$Media$ClosedCaptioning$ClosedCaptionColor>;

/**
 * Gets the font effect for closed caption text.
 */
static fontEffect: $Values<typeof Windows$Media$ClosedCaptioning$ClosedCaptionEdgeEffect>;

/**
 * Gets the font opacity for closed caption text.
 */
static fontOpacity: $Values<typeof Windows$Media$ClosedCaptioning$ClosedCaptionOpacity>;

/**
 * Gets the font size for closed caption text.
 */
static fontSize: $Values<typeof Windows$Media$ClosedCaptioning$ClosedCaptionSize>;

/**
 * Gets the font style for closed caption text.
 */
static fontStyle: $Values<typeof Windows$Media$ClosedCaptioning$ClosedCaptionStyle>;

/**
 * Gets the region color for closed caption text.
 */
static regionColor: $Values<typeof Windows$Media$ClosedCaptioning$ClosedCaptionColor>;

/**
 * Gets the region opacity for closed caption text.
 */
static regionOpacity: $Values<typeof Windows$Media$ClosedCaptioning$ClosedCaptionOpacity>
}


/**
 * Specifies the size of closed caption text.
 */

declare  var Windows$Media$ClosedCaptioning$ClosedCaptionSize: {|
  +default: 0,// 0
+fiftyPercent: 1,// 1
+oneHundredPercent: 2,// 2
+oneHundredFiftyPercent: 3,// 3
+twoHundredPercent: 4,// 4

|};



/**
 * Specifies the style of closed caption text.
 */

declare  var Windows$Media$ClosedCaptioning$ClosedCaptionStyle: {|
  +default: 0,// 0
+monospacedWithSerifs: 1,// 1
+proportionalWithSerifs: 2,// 2
+monospacedWithoutSerifs: 3,// 3
+proportionalWithoutSerifs: 4,// 4
+casual: 5,// 5
+cursive: 6,// 6
+smallCapitals: 7,// 7

|};



      declare var npm$namespace$Windows$Media$ContentRestrictions: {
        
        
        ContentAccessRestrictionLevel: typeof Windows$Media$ContentRestrictions$ContentAccessRestrictionLevel,
RatedContentCategory: typeof Windows$Media$ContentRestrictions$RatedContentCategory,
        ContentRestrictionsBrowsePolicy: typeof Windows$Media$ContentRestrictions$ContentRestrictionsBrowsePolicy,
RatedContentDescription: typeof Windows$Media$ContentRestrictions$RatedContentDescription,
RatedContentRestrictions: typeof Windows$Media$ContentRestrictions$RatedContentRestrictions,
        
      }

/**
 * Specifies how the content is treated, based on the user's content settings.
 */

declare  var Windows$Media$ContentRestrictions$ContentAccessRestrictionLevel: {|
  +allow: 0,// 0
+warn: 1,// 1
+block: 2,// 2
+hide: 3,// 3

|};



/**
 * Contains information used to filter an app's content catalog.
 */
declare class Windows$Media$ContentRestrictions$ContentRestrictionsBrowsePolicy  {

/**
 * Gets the region of the user's content restrictions.
 */
geographicRegion: string;

/**
 * Gets the maximum allowed age rating level to show in a content catalog. No content rated above this level should be displayed. For example, if the MaxBrowsableAgeRating is 13, MPAA:R rated movies should not be displayed.
 */
maxBrowsableAgeRating: number;

/**
 * Gets the maximum allowed rating level for content consumption.
 */
preferredAgeRating: number
}


/**
 * Specifies the type of a piece of content.
 */

declare  var Windows$Media$ContentRestrictions$RatedContentCategory: {|
  +general: 0,// 0
+application: 1,// 1
+game: 2,// 2
+movie: 3,// 3
+television: 4,// 4
+music: 5,// 5

|};



/**
 * Contains information about a piece of content. An app creates a RatedContentDescription object, for each piece of content to be used in the GetRestrictionLevelAsync and RequestContentAccessAsync methods.
 */
declare class Windows$Media$ContentRestrictions$RatedContentDescription  {

/**
 * Initializes a new instance of the RatedContentDescription class.
 * @param id The ID of the content, as specified by the app developer.
 * @param title The title of the content.
 * @param category Specifies the type of a piece of content, defined by RatedContentCategory .
 */
constructor(id: string, title: string, category: $Values<typeof Windows$Media$ContentRestrictions$RatedContentCategory>): this;

/**
 * Specifies the type of a piece of content, defined by RatedContentCategory .
 */
category: $Values<typeof Windows$Media$ContentRestrictions$RatedContentCategory>;

/**
 * The unique content ID of a piece of content, in the app's content catalog.
 */
id: string;

/**
 * The thumbnail image associated with the content.
 */
image: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Provides all existing third-party and Windows Store age ratings for a piece of content.
 */
ratings: Windows$Foundation$Collections$IVector<string>;

/**
 * The display title of a piece of content.
 */
title: string
}


/**
 * Contains all behavior and functionality related to a user's Family Safety content settings.
 */
declare class Windows$Media$ContentRestrictions$RatedContentRestrictions  {

/**
 * Initializes a new instance of the RatedContentRestrictions class.
 */
constructor(): this;

/**
 * Initializes a new instance of the RatedContentRestrictions class, with the specified age rating the app uses, to restrict content usage.
 * @param maxAgeRating The max age rating.
 */
constructor(maxAgeRating: number): this;

/**
 * Gets information that is used filter an app's content catalog.
 * @return Returns a ContentRestrictionsBrowsePolicy object.
 */
getBrowsePolicyAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$ContentRestrictions$ContentRestrictionsBrowsePolicy>;

/**
 * Gets the policy that applies to a piece of content, for content browsing and consumption.
 * @param RatedContentDescription The rated content info.
 * @return This method returns these values:
 */
getRestrictionLevelAsync(
RatedContentDescription: Windows$Media$ContentRestrictions$RatedContentDescription): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Media$ContentRestrictions$ContentAccessRestrictionLevel>>;

/**
 * An event handler to notify apps when there are changes to the user's content settings.
 */
onrestrictionschanged: Windows$Foundation$EventHandler<any>;
addEventListener(
type: "restrictionschanged",
listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(
type: "restrictionschanged",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Determines whether the user is allowed to consume a piece of content.
 * @param RatedContentDescription The rated content info.
 * @return Returns true, if the user can consume the content. Otherwise, returns false.
 */
requestContentAccessAsync(
RatedContentDescription: Windows$Media$ContentRestrictions$RatedContentDescription): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


      declare var npm$namespace$Windows$Media$Devices: {
        
        
        AdvancedPhotoMode: typeof Windows$Media$Devices$AdvancedPhotoMode,
AudioDeviceRole: typeof Windows$Media$Devices$AudioDeviceRole,
AutoFocusRange: typeof Windows$Media$Devices$AutoFocusRange,
CameraStreamState: typeof Windows$Media$Devices$CameraStreamState,
CaptureSceneMode: typeof Windows$Media$Devices$CaptureSceneMode,
CaptureUse: typeof Windows$Media$Devices$CaptureUse,
ColorTemperaturePreset: typeof Windows$Media$Devices$ColorTemperaturePreset,
FocusMode: typeof Windows$Media$Devices$FocusMode,
FocusPreset: typeof Windows$Media$Devices$FocusPreset,
HdrVideoMode: typeof Windows$Media$Devices$HdrVideoMode,
IsoSpeedPreset: typeof Windows$Media$Devices$IsoSpeedPreset,
ManualFocusDistance: typeof Windows$Media$Devices$ManualFocusDistance,
MediaCaptureFocusState: typeof Windows$Media$Devices$MediaCaptureFocusState,
MediaCaptureOptimization: typeof Windows$Media$Devices$MediaCaptureOptimization,
MediaCapturePauseBehavior: typeof Windows$Media$Devices$MediaCapturePauseBehavior,
OpticalImageStabilizationMode: typeof Windows$Media$Devices$OpticalImageStabilizationMode,
RegionOfInterestType: typeof Windows$Media$Devices$RegionOfInterestType,
TelephonyKey: typeof Windows$Media$Devices$TelephonyKey,
ZoomTransitionMode: typeof Windows$Media$Devices$ZoomTransitionMode,
        AdvancedPhotoCaptureSettings: typeof Windows$Media$Devices$AdvancedPhotoCaptureSettings,
AdvancedPhotoControl: typeof Windows$Media$Devices$AdvancedPhotoControl,
AudioDeviceController: typeof Windows$Media$Devices$AudioDeviceController,
CallControl: typeof Windows$Media$Devices$CallControl,
DefaultAudioCaptureDeviceChangedEventArgs: typeof Windows$Media$Devices$DefaultAudioCaptureDeviceChangedEventArgs,
DefaultAudioRenderDeviceChangedEventArgs: typeof Windows$Media$Devices$DefaultAudioRenderDeviceChangedEventArgs,
DialRequestedEventArgs: typeof Windows$Media$Devices$DialRequestedEventArgs,
ExposureCompensationControl: typeof Windows$Media$Devices$ExposureCompensationControl,
ExposureControl: typeof Windows$Media$Devices$ExposureControl,
ExposurePriorityVideoControl: typeof Windows$Media$Devices$ExposurePriorityVideoControl,
FlashControl: typeof Windows$Media$Devices$FlashControl,
FocusControl: typeof Windows$Media$Devices$FocusControl,
FocusSettings: typeof Windows$Media$Devices$FocusSettings,
HdrVideoControl: typeof Windows$Media$Devices$HdrVideoControl,
IsoSpeedControl: typeof Windows$Media$Devices$IsoSpeedControl,
KeypadPressedEventArgs: typeof Windows$Media$Devices$KeypadPressedEventArgs,
LowLagPhotoControl: typeof Windows$Media$Devices$LowLagPhotoControl,
LowLagPhotoSequenceControl: typeof Windows$Media$Devices$LowLagPhotoSequenceControl,
MediaDevice: typeof Windows$Media$Devices$MediaDevice,
MediaDeviceControl: typeof Windows$Media$Devices$MediaDeviceControl,
MediaDeviceControlCapabilities: typeof Windows$Media$Devices$MediaDeviceControlCapabilities,
OpticalImageStabilizationControl: typeof Windows$Media$Devices$OpticalImageStabilizationControl,
PhotoConfirmationControl: typeof Windows$Media$Devices$PhotoConfirmationControl,
RedialRequestedEventArgs: typeof Windows$Media$Devices$RedialRequestedEventArgs,
RegionOfInterest: typeof Windows$Media$Devices$RegionOfInterest,
RegionsOfInterestControl: typeof Windows$Media$Devices$RegionsOfInterestControl,
SceneModeControl: typeof Windows$Media$Devices$SceneModeControl,
TorchControl: typeof Windows$Media$Devices$TorchControl,
VideoDeviceController: typeof Windows$Media$Devices$VideoDeviceController,
WhiteBalanceControl: typeof Windows$Media$Devices$WhiteBalanceControl,
ZoomControl: typeof Windows$Media$Devices$ZoomControl,
ZoomSettings: typeof Windows$Media$Devices$ZoomSettings,
        Core: typeof npm$namespace$Windows$Media$Devices$Core,
      }

/**
 * Represents settings for an AdvancedPhotoControl object.
 */
declare class Windows$Media$Devices$AdvancedPhotoCaptureSettings  {

/**
 * Initializes a new instance of the AdvancedPhotoCaptureSettings class.
 */
constructor(): this;

/**
 * Gets or sets the advanced capture mode for which an AdvancedPhotoControl will be configured.
 */
mode: $Values<typeof Windows$Media$Devices$AdvancedPhotoMode>
}


/**
 * Provides functionality for controlling the advanced photo capture behavior on a capture device.
 */
declare class Windows$Media$Devices$AdvancedPhotoControl  {

/**
 * Configures the AdvancedPhotoControl object with the specified settings.
 * @param settings The object defining the configuration settings.
 */
configure(settings: Windows$Media$Devices$AdvancedPhotoCaptureSettings): void;

/**
 * Gets the current advanced capture mode of the AdvancedPhotoControl .
 */
mode: $Values<typeof Windows$Media$Devices$AdvancedPhotoMode>;

/**
 * Gets a value indicating whether the AdvancedPhotoControl is supported on the current capture device.
 */
supported: boolean;

/**
 * Gets a list of the advanced capture modes supported by the current capture device.
 */
supportedModes: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Media$Devices$AdvancedPhotoMode>>
}


/**
 * Defines the advanced photo capture modes.
 */

declare  var Windows$Media$Devices$AdvancedPhotoMode: {|
  +auto: 0,// 0
+standard: 1,// 1
+hdr: 2,// 2

|};



/**
 * Controls device settings on the microphone.
 */
declare class Windows$Media$Devices$AudioDeviceController  {

/**
 * Gets a list of the supported encoding properties for the device.
 * @param mediaStreamType The type of media stream for which to get the properties.
 * @return A list of the supported encoding properties.
 */
getAvailableMediaStreamProperties(
mediaStreamType: $Values<typeof Windows$Media$Capture$MediaStreamType>): Windows$Foundation$Collections$IVectorView<Windows$Media$MediaProperties$IMediaEncodingProperties>;

/**
 * Gets the encoding properties for the specified media stream type for the device.
 * @param mediaStreamType The type of media stream for which to get the properties.
 * @return The encoding properties.
 */
getMediaStreamProperties(
mediaStreamType: $Values<typeof Windows$Media$Capture$MediaStreamType>): Windows$Media$MediaProperties$IMediaEncodingProperties;

/**
 * Mutes or unmutes the microphone.
 */
muted: boolean;

/**
 * Sets the encoding properties asynchronously for the specified media stream type for the device.
 * @param mediaStreamType The type of media stream for which to set the properties.
 * @param mediaEncodingProperties The encoding properties to set.
 * @return An IAsyncAction object that is used to control the asynchronous operation.
 */
setMediaStreamPropertiesAsync(
mediaStreamType: $Values<typeof Windows$Media$Capture$MediaStreamType>,
mediaEncodingProperties: Windows$Media$MediaProperties$IMediaEncodingProperties): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets or sets the volume of the microphone.
 */
volumePercent: number
}


/**
 * Indicates the role of an audio device.
 */

declare  var Windows$Media$Devices$AudioDeviceRole: {|
  +default: 0,// 0
+communications: 1,// 1

|};



/**
 * Defines the options for auto focus range.
 */

declare  var Windows$Media$Devices$AutoFocusRange: {|
  +fullRange: 0,// 0
+macro: 1,// 1
+normal: 2,// 2

|};



/**
 * Represents the properties, commands and events for handling calls on a telephony related device.
 */
declare class Windows$Media$Devices$CallControl  {

/**
 * Returns a CallControl class that represents the audio communications device specified by the DeviceInformation ID being passed.
 * @param deviceId The DeviceInformation ID of the specified audio communications device.
 * @return A class that represents the specified audio communications device.
 */
static fromId(deviceId: string): Windows$Media$Devices$CallControl;

/**
 * Returns a CallControl class that represents the default audio communications device.
 * @return A class that represents the default audio communications device.
 */
static getDefault(): Windows$Media$Devices$CallControl;

/**
 * Ends the specified call.
 * @param callToken The unique identifier of the specified call.
 */
endCall(callToken: number): void;

/**
 * Indicates whether the telephony device has a built-in ringer.
 */
hasRinger: boolean;

/**
 * Indicates that the specified call is now active.
 * @param callToken The unique identifier of the specified call.
 */
indicateActiveCall(callToken: number): void;

/**
 * Informs the device that there is an incoming call.
 * @param enableRinger Specifies whether the device should activate its built-in ringer.
 * @param callerId A numeric string that specifies the incoming caller ID. This parameter can be null, and often is for many VoIP calls.
 * @return A call token that uniquely identifies this call.
 */
indicateNewIncomingCall(enableRinger: boolean, callerId: string): number;

/**
 * Updates device indicators to indicate an outgoing call.
 * @return A call token that uniquely identifies this call.
 */
indicateNewOutgoingCall(): number;

/**
 * Occurs when the device receives a request to answer a call.
 */
onanswerrequested: Windows$Media$Devices$CallControlEventHandler;
addEventListener(
type: "answerrequested",
listener: Windows$Media$Devices$CallControlEventHandler): void;
removeEventListener(
type: "answerrequested",
listener: Windows$Media$Devices$CallControlEventHandler): void;

/**
 * Occurs when the device receives a request for an audio transfer.
 */
onaudiotransferrequested: Windows$Media$Devices$CallControlEventHandler;
addEventListener(
type: "audiotransferrequested",
listener: Windows$Media$Devices$CallControlEventHandler): void;
removeEventListener(
type: "audiotransferrequested",
listener: Windows$Media$Devices$CallControlEventHandler): void;

/**
 * Occurs when a number is dialed from the device.
 */
ondialrequested: Windows$Media$Devices$DialRequestedEventHandler;
addEventListener(
type: "dialrequested",
listener: Windows$Media$Devices$DialRequestedEventHandler): void;
removeEventListener(
type: "dialrequested",
listener: Windows$Media$Devices$DialRequestedEventHandler): void;

/**
 * Occurs when the device receives a request to hang up a call.
 */
onhanguprequested: Windows$Media$Devices$CallControlEventHandler;
addEventListener(
type: "hanguprequested",
listener: Windows$Media$Devices$CallControlEventHandler): void;
removeEventListener(
type: "hanguprequested",
listener: Windows$Media$Devices$CallControlEventHandler): void;

/**
 * Occurs when a keypad button on the device has been pressed.
 */
onkeypadpressed: Windows$Media$Devices$KeypadPressedEventHandler;
addEventListener(
type: "keypadpressed",
listener: Windows$Media$Devices$KeypadPressedEventHandler): void;
removeEventListener(
type: "keypadpressed",
listener: Windows$Media$Devices$KeypadPressedEventHandler): void;

/**
 * Occurs when the device receives a request to redial.
 */
onredialrequested: Windows$Media$Devices$RedialRequestedEventHandler;
addEventListener(
type: "redialrequested",
listener: Windows$Media$Devices$RedialRequestedEventHandler): void;
removeEventListener(
type: "redialrequested",
listener: Windows$Media$Devices$RedialRequestedEventHandler): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Defines the state of a camera stream.
 */

declare  var Windows$Media$Devices$CameraStreamState: {|
  +notStreaming: 0,// 0
+streaming: 1,// 1
+blockedForPrivacy: 2,// 2
+shutdown: 3,// 3

|};



/**
 * Defines the possible capture scene modes.
 */

declare  var Windows$Media$Devices$CaptureSceneMode: {|
  +auto: 0,// 0
+manual: 1,// 1
+macro: 2,// 2
+portrait: 3,// 3
+sport: 4,// 4
+snow: 5,// 5
+night: 6,// 6
+beach: 7,// 7
+sunset: 8,// 8
+candlelight: 9,// 9
+landscape: 10,// 10
+nightPortrait: 11,// 11
+backlit: 12,// 12

|};



/**
 * Defines the values for the primary use of the capture device.
 */

declare  var Windows$Media$Devices$CaptureUse: {|
  +none: 0,// 0
+photo: 1,// 1
+video: 2,// 2

|};



/**
 * Defines the values for the possible color temperature presets.
 */

declare  var Windows$Media$Devices$ColorTemperaturePreset: {|
  +auto: 0,// 0
+manual: 1,// 1
+cloudy: 2,// 2
+daylight: 3,// 3
+flash: 4,// 4
+fluorescent: 5,// 5
+tungsten: 6,// 6
+candlelight: 7,// 7

|};



      declare var npm$namespace$Windows$Media$Devices$Core: {
        
        
        FrameFlashMode: typeof Windows$Media$Devices$Core$FrameFlashMode,
        CameraIntrinsics: typeof Windows$Media$Devices$Core$CameraIntrinsics,
FrameControlCapabilities: typeof Windows$Media$Devices$Core$FrameControlCapabilities,
FrameController: typeof Windows$Media$Devices$Core$FrameController,
FrameExposureCapabilities: typeof Windows$Media$Devices$Core$FrameExposureCapabilities,
FrameExposureCompensationCapabilities: typeof Windows$Media$Devices$Core$FrameExposureCompensationCapabilities,
FrameExposureCompensationControl: typeof Windows$Media$Devices$Core$FrameExposureCompensationControl,
FrameExposureControl: typeof Windows$Media$Devices$Core$FrameExposureControl,
FrameFlashCapabilities: typeof Windows$Media$Devices$Core$FrameFlashCapabilities,
FrameFlashControl: typeof Windows$Media$Devices$Core$FrameFlashControl,
FrameFocusCapabilities: typeof Windows$Media$Devices$Core$FrameFocusCapabilities,
FrameFocusControl: typeof Windows$Media$Devices$Core$FrameFocusControl,
FrameIsoSpeedCapabilities: typeof Windows$Media$Devices$Core$FrameIsoSpeedCapabilities,
FrameIsoSpeedControl: typeof Windows$Media$Devices$Core$FrameIsoSpeedControl,
VariablePhotoSequenceController: typeof Windows$Media$Devices$Core$VariablePhotoSequenceController,
        
      }

/**
 * Represents the intrinsics that describe the camera distortion model.
 */
declare class Windows$Media$Devices$Core$CameraIntrinsics  {

/**
 * Initializes a new instance of the CameraIntrinsics class.
 * @param focalLength The focal length of the camera.
 * @param principalPoint The principal point of the camera.
 * @param radialDistortion The radial distortion coefficient of the camera.
 * @param tangentialDistortion The tangential distortion coefficient of the camera.
 * @param imageWidth The image width of the camera, in pixels.
 * @param imageHeight The image height of the camera, in pixels.
 */
constructor(focalLength: Windows$Foundation$Numerics$Vector2, principalPoint: Windows$Foundation$Numerics$Vector2, radialDistortion: Windows$Foundation$Numerics$Vector3, tangentialDistortion: Windows$Foundation$Numerics$Vector2, imageWidth: number, imageHeight: number): this;

/**
 * Gets the focal length of the camera.
 */
focalLength: Windows$Foundation$Numerics$Vector2;

/**
 * Gets the image height of the camera, in pixels.
 */
imageHeight: number;

/**
 * Gets the image width of the camera, in pixels.
 */
imageWidth: number;

/**
 * Gets the principal point of the camera.
 */
principalPoint: Windows$Foundation$Numerics$Vector2;

/**
 * Projects an array of camera space points into screen space pixel coordinates.
 * @param coordinates The array of camera space points to project into screen space.
 * @return The array of screen space pixel coordinates.
 */
projectManyOntoFrame(coordinates: Windows$Foundation$Numerics$Vector3): Windows$Foundation$Point;

/**
 * Projects a camera space point into screen space pixel coordinates.
 * @param coordinate The camera space point to project into screen space.
 * @return The screen space pixel coordinates.
 */
projectOntoFrame(coordinate: Windows$Foundation$Numerics$Vector3): Windows$Foundation$Point;

/**
 * Gets the radial distortion coefficient of the camera.
 */
radialDistortion: Windows$Foundation$Numerics$Vector3;

/**
 * Gets the tangential distortion coefficient of the camera.
 */
tangentialDistortion: Windows$Foundation$Numerics$Vector2;

/**
 * Unprojects pixel coordinates into a camera space ray from the camera origin, expressed as a X, Y coordinates on the plane at Z = 1.0.
 * @param pixelCoordinate The pixel coordinates to unproject into camera space.
 * @return The X, Y coordinates of the unprojected pixel on the plane at Z = 1.0.
 */
unprojectAtUnitDepth(pixelCoordinate: Windows$Foundation$Point): Windows$Foundation$Numerics$Vector2;

/**
 * Unprojects an array pixel coordinates into a camera space rays from the camera origin, expressed as a X, Y coordinates on the plane at Z = 1.0.
 * @param pixelCoordinates The array of pixel coordinates to unproject into camera space.
 * @return The array of X, Y coordinates of the unprojected pixels on the plane at Z = 1.0.
 */
unprojectPixelsAtUnitDepth(
pixelCoordinates: Windows$Foundation$Point): Windows$Foundation$Numerics$Vector2
}


/**
 * Provides information about the variable photo sequence capabilities of the capture device.
 */
declare class Windows$Media$Devices$Core$FrameControlCapabilities  {

/**
 * Gets the exposure capabilities of the capture device for variable photo sequences.
 */
exposure: Windows$Media$Devices$Core$FrameExposureCapabilities;

/**
 * Gets the exposure compensation capabilities of the capture device for variable photo sequences.
 */
exposureCompensation: Windows$Media$Devices$Core$FrameExposureCompensationCapabilities;

/**
 * Gets the flash capabilities of the capture device for variable photo sequences.
 */
flash: Windows$Media$Devices$Core$FrameFlashCapabilities;

/**
 * Gets the focus capabilities of the capture device for variable photo sequences.
 */
focus: Windows$Media$Devices$Core$FrameFocusCapabilities;

/**
 * Gets the ISO speed capabilities of the capture device for variable photo sequences.
 */
isoSpeed: Windows$Media$Devices$Core$FrameIsoSpeedCapabilities;

/**
 * Gets whether the capture device supports photo confirmation for variable photo sequences.
 */
photoConfirmationSupported: boolean
}


/**
 * Represents the settings for a frame in a variable photo sequence.
 */
declare class Windows$Media$Devices$Core$FrameController  {

/**
 * Initializes a new instance of the FrameController class.
 */
constructor(): this;

/**
 * Gets the exposure compensation settings for a frame in a variable photo sequence.
 */
exposureCompensationControl: Windows$Media$Devices$Core$FrameExposureCompensationControl;

/**
 * Gets the exposure settings for a frame in a variable photo sequence.
 */
exposureControl: Windows$Media$Devices$Core$FrameExposureControl;

/**
 * Gets the flash settings for a frame in a variable photo sequence.
 */
flashControl: Windows$Media$Devices$Core$FrameFlashControl;

/**
 * Gets the focus settings for a frame in a variable photo sequence.
 */
focusControl: Windows$Media$Devices$Core$FrameFocusControl;

/**
 * Gets the ISO speed settings for a frame in a variable photo sequence.
 */
isoSpeedControl: Windows$Media$Devices$Core$FrameIsoSpeedControl;

/**
 * Gets or sets whether photo confirmation is enabled for a frame in a variable photo sequence.
 */
photoConfirmationEnabled: boolean
}


/**
 * Provides information about the exposure time capabilities of the capture device for frames in a variable photo sequences.
 */
declare class Windows$Media$Devices$Core$FrameExposureCapabilities  {

/**
 * Gets the maximum exposure time supported by the capture device.
 */
max: number;

/**
 * Gets the minimum exposure time supported by the capture device.
 */
min: number;

/**
 * Gets the smallest exposure time increment supported by the capture device.
 */
step: number;

/**
 * Gets a value that indicates if the capture device supports the exposure control for variable photo sequences.
 */
supported: boolean
}


/**
 * Provides information about the exposure compensation capabilities of the capture device for frames in a variable photo sequences.
 */
declare class Windows$Media$Devices$Core$FrameExposureCompensationCapabilities  {

/**
 * Gets the maximum exposure compensation supported by the capture device.
 */
max: number;

/**
 * Gets the minimum exposure compensation supported by the capture device.
 */
min: number;

/**
 * Gets the smallest exposure time compensation increment supported by the capture device.
 */
step: number;

/**
 * Gets a value that indicates if the capture device supports the frame exposure compensation control for frames in a variable photo sequence.
 */
supported: boolean
}


/**
 * Represents the exposure compensation settings for a frame in a variable photo sequence.
 */
declare class Windows$Media$Devices$Core$FrameExposureCompensationControl  {

/**
 * Gets or sets the exposure compensation time for a frame in a variable photo sequence.
 */
value: number
}


/**
 * Represents the exposure time settings for a frame in a variable photo sequence.
 */
declare class Windows$Media$Devices$Core$FrameExposureControl  {

/**
 * Gets or sets a value indicating whether auto exposure is enabled for a frame in a variable photo sequence.
 */
auto: boolean;

/**
 * Gets or sets the exposure time for a frame in a variable photo sequence.
 */
value: number
}


/**
 * Provides information about the flash capabilities of the capture device for frames in a variable photo sequences.
 */
declare class Windows$Media$Devices$Core$FrameFlashCapabilities  {

/**
 * Gets a value indicating whether flash power is supported for frames in a variable photo sequences.
 */
powerSupported: boolean;

/**
 * Gets a value indicating whether red eye reduction is supported for frames in a variable photo sequences.
 */
redEyeReductionSupported: boolean;

/**
 * Gets a value that indicates if the capture device supports the flash control for frames in a variable photo sequence.
 */
supported: boolean
}


/**
 * Represents the flash settings for a frame in a variable photo sequence.
 */
declare class Windows$Media$Devices$Core$FrameFlashControl  {

/**
 * Gets or sets a value indicating whether flash settings are automatically set for a frame in a variable photo sequence.
 */
auto: boolean;

/**
 * Gets or sets the flash mode for a frame in a variable photo sequence.
 */
mode: $Values<typeof Windows$Media$Devices$Core$FrameFlashMode>;

/**
 * Gets or sets the flash power for a frame in a variable photo sequence.
 */
powerPercent: number;

/**
 * Gets or sets a value indicating if red eye reduction is enabled for a frame in a variable photo sequence.
 */
redEyeReduction: boolean
}


/**
 * Specifies the flash mode for a frame in a variable photo sequence.
 */

declare  var Windows$Media$Devices$Core$FrameFlashMode: {|
  +disable: 0,// 0
+enable: 1,// 1
+global: 2,// 2

|};



/**
 * Provides information about the focus capabilities of the capture device for frames in a variable photo sequences.
 */
declare class Windows$Media$Devices$Core$FrameFocusCapabilities  {

/**
 * Gets the maximum focus length supported by the capture device for a frame in a variable photo sequence, specified in millimeters.
 */
max: number;

/**
 * Gets the minimum focus length supported by the capture device for a frame in a variable photo sequence, specified in millimeters.
 */
min: number;

/**
 * Gets the smallest focus increment supported by the capture device for a frame in a variable photo sequence, specified in millimeters.
 */
step: number;

/**
 * Gets a value that indicates if the capture device supports the focus control for frames in a variable photo sequence.
 */
supported: boolean
}


/**
 * Represents the focus settings for a frame in a variable photo sequence.
 */
declare class Windows$Media$Devices$Core$FrameFocusControl  {

/**
 * Gets or sets the focus value for a frame in a variable photo sequence.
 */
value: number
}


/**
 * Provides information about the ISO speed capabilities of the capture device for frames in a variable photo sequences.
 */
declare class Windows$Media$Devices$Core$FrameIsoSpeedCapabilities  {

/**
 * Gets the maximum ISO speed supported by the capture device for a frame in a variable photo sequence.
 */
max: number;

/**
 * The minimum ISO speed supported by the capture device for a frame in a variable photo sequence.
 */
min: number;

/**
 * Gets the smallest ISO speed increment supported by the capture device for a frame in a variable photo sequence, specified in millimeters.
 */
step: number;

/**
 * Gets a value that indicates if the capture device supports the ISO speed control for frames in a variable photo sequence.
 */
supported: boolean
}


/**
 * Represents the ISO speed settings for a frame in a variable photo sequence.
 */
declare class Windows$Media$Devices$Core$FrameIsoSpeedControl  {

/**
 * Gets or sets a value indicating whether ISO speed is automatically set for a frame in a variable photo sequence.
 */
auto: boolean;

/**
 * Gets or sets the ISO speed for a frame in a variable photo sequence.
 */
value: number
}


/**
 * Represents the settings for a variable photo sequence.
 */
declare class Windows$Media$Devices$Core$VariablePhotoSequenceController  {

/**
 * Gets the list of FrameController objects that determine the settings for each frame in a variable photo sequence.
 */
desiredFrameControllers: Windows$Foundation$Collections$IVector<Windows$Media$Devices$Core$FrameController>;

/**
 * Gets a FrameControlCapabilities object that provides information about the variable photo sequence capabilities of the capture device.
 */
frameCapabilities: Windows$Media$Devices$Core$FrameControlCapabilities;

/**
 * Gets the current frame rate at which pictures can be taken in a variable photo sequence.
 * @return The current frame rate at which pictures can be taken in a variable photo sequence.
 */
getCurrentFrameRate(): Windows$Media$MediaProperties$MediaRatio;

/**
 * Gets the highest frame rate supported when video and a variable photo sequence are being captured concurrently.
 * @param captureProperties The media encoding properties.
 * @return The highest supported concurrent frame rate.
 */
getHighestConcurrentFrameRate(
captureProperties: Windows$Media$MediaProperties$IMediaEncodingProperties): Windows$Media$MediaProperties$MediaRatio;

/**
 * Gets the maximum number of photos that can be taken per second in a variable photo sequence.
 */
maxPhotosPerSecond: number;

/**
 * Gets or sets the number of photos that are taken per second in a variable photo sequence.
 */
photosPerSecondLimit: number;

/**
 * Gets a value that indicates whether variable photo sequences are supported by the capture device.
 */
supported: boolean
}


/**
 * Contains information about a default audio capture device change event.
 */
declare class Windows$Media$Devices$DefaultAudioCaptureDeviceChangedEventArgs  {

/**
 * Gets the ID of the newly selected audio capture device that caused the change event.
 */
id: string;

/**
 * Gets the role of the newly selected audio capture device that caused the change event.
 */
role: $Values<typeof Windows$Media$Devices$AudioDeviceRole>
}


/**
 * Contains information about a default audio render device change event.
 */
declare class Windows$Media$Devices$DefaultAudioRenderDeviceChangedEventArgs  {

/**
 * Gets the ID of the newly selected default audio render device that caused the change event.
 */
id: string;

/**
 * Gets the role of the newly selected default audio render device that caused the change event.
 */
role: $Values<typeof Windows$Media$Devices$AudioDeviceRole>
}


/**
 * Contains information for the DialRequested event.
 */
declare class Windows$Media$Devices$DialRequestedEventArgs  {

/**
 * Returns the contact that was dialed.
 */
contact: any;

/**
 * Indicates that the DialRequested event has been handled.
 */
handled(): void
}


/**
 * Provides functionality for modifying exposure levels of captured photos.
 */
declare class Windows$Media$Devices$ExposureCompensationControl  {

/**
 * Gets the maximum exposure time.
 */
max: number;

/**
 * Gets the minimum exposure time.
 */
min: number;

/**
 * Asynchronously sets the exposure compensation.
 * @param value The exposure compensation level to set the Value property to. The minimum and maximum values are specified by Min and Max .
 * @return The object that is used to control the asynchronous operation.
 */
setValueAsync(value: number): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the smallest exposure compensation increment supported by the capture device.
 */
step: number;

/**
 * Gets a value that specifies if the capture device supports the exposure compensation control.
 */
supported: boolean;

/**
 * Gets the exposure compensation level.
 */
value: number
}


/**
 * Provides functionality for controlling the exposure settings on a capture device.
 */
declare class Windows$Media$Devices$ExposureControl  {

/**
 * Gets a value that indicates if auto exposure is enabled.
 */
auto: boolean;

/**
 * Gets the maximum exposure time.
 */
max: number;

/**
 * Gets the minimum exposure time.
 */
min: number;

/**
 * Asynchronously enables or disable auto exposure.
 * @param value Specifies whether or not to enable or disable auto exposure.
 * @return The object that is used to control the asynchronous operation.
 */
setAutoAsync(value: boolean): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously sets the exposure time.
 * @param shutterDuration The exposure time to set the Value property to. The minimum and maximum values are specified by Min and Max .
 * @return The object that is used to control the asynchronous operation.
 */
setValueAsync(shutterDuration: number): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the smallest exposure time increment supported by the capture device.
 */
step: number;

/**
 * Gets a value that specifies if the capture device supports the exposure control.
 */
supported: boolean;

/**
 * Gets the exposure time.
 */
value: number
}


/**
 * When supported, allows an app to specify whether the camera driver can dynamically adjust the frame rate of video capture in order to improve video quality in low-light conditions.
 */
declare class Windows$Media$Devices$ExposurePriorityVideoControl  {

/**
 * Gets or sets a value that specifies if ExposurePriorityVideoControl is enabled.
 */
enabled: boolean;

/**
 * Gets or sets a value that specifies if ExposurePriorityVideoControl is supported on the current device.
 */
supported: boolean
}


/**
 * Provides functionality for controlling the flash settings on a capture device.
 */
declare class Windows$Media$Devices$FlashControl  {

/**
 * Gets or sets a value indicating whether focus assist light is enabled on the capture device.
 */
assistantLightEnabled: boolean;

/**
 * Gets a value indicating whether focus assist light is supported by the capture device.
 */
assistantLightSupported: boolean;

/**
 * Gets or sets a value that specifies if flash is automatically set.
 */
auto: boolean;

/**
 * Gets a value that specifies if the flash on the capture device is enabled or disabled.
 */
enabled: boolean;

/**
 * Gets or sets the intensity of the flash.
 */
powerPercent: number;

/**
 * Gets a value that specifics if the device allows the torch LED power settings to be changed.
 */
powerSupported: boolean;

/**
 * Gets a value that specifies if the red eye reduction is enabled or disabled.
 */
redEyeReduction: boolean;

/**
 * Gets a value that specifies if the capture device supports red eye reduction.
 */
redEyeReductionSupported: boolean;

/**
 * Gets a value that specifies if the capture device supports the flash control.
 */
supported: boolean
}


/**
 * Provides functionality for controlling the focus settings on a capture device.
 */
declare class Windows$Media$Devices$FocusControl  {

/**
 * Configures the FocusControl object with values specified in the provided FocusSettings object.
 * @param settings The focus settings to use to configure the FocusControl object.
 */
configure(settings: Windows$Media$Devices$FocusSettings): void;

/**
 * Asynchronously focuses the device.
 * @return The object that is used to control the asynchronous operation.
 */
focusAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets a value that specifics if the capture device supports the FocusChanged event.
 */
focusChangedSupported: boolean;

/**
 * Gets a MediaCaptureFocusState value indicating the current focus state of the capture device.
 */
focusState: $Values<typeof Windows$Media$Devices$MediaCaptureFocusState>;

/**
 * Locks the capture device's focus.
 * @return An asynchronous action.
 */
lockAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the maximum focus length.
 */
max: number;

/**
 * Gets the minimum focus length.
 */
min: number;

/**
 * Gets the capture device's current focus mode.
 */
mode: $Values<typeof Windows$Media$Devices$FocusMode>;

/**
 * Gets the focus preset.
 */
preset: $Values<typeof Windows$Media$Devices$FocusPreset>;

/**
 * Asynchronously sets the focus Preset .
 * @param preset The focus preset to set the Preset property to.
 * @return The object that is used to control the asynchronous operation.
 */
setPresetAsync(
preset: $Values<typeof Windows$Media$Devices$FocusPreset>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously sets the focus Preset , specifying if the operation must complete before the device is focused.
 * @param preset The focus preset to set the Preset property to.
 * @param completeBeforeFocus Specifies if the asynchronous operation must complete before the device is focused.
 * @return The object that is used to control the asynchronous operation.
 */
setPresetAsync(
preset: $Values<typeof Windows$Media$Devices$FocusPreset>,
completeBeforeFocus: boolean): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously sets the focus Value .
 * @param focus The value to set the focus to. The minimum and maximum values are specified by Min and Max .
 * @return The object that is used to control the asynchronous operation.
 */
setValueAsync(focus: number): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the smallest focus increment supported by the capture device.
 */
step: number;

/**
 * Gets a value that specifies if the capture device supports the focus control.
 */
supported: boolean;

/**
 * Gets a list of values indicating the manual focus distances that are supported by the capture device.
 */
supportedFocusDistances: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Media$Devices$ManualFocusDistance>>;

/**
 * Gets a list of values indicating the focus modes that are supported by the capture device.
 */
supportedFocusModes: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Media$Devices$FocusMode>>;

/**
 * Gets a list of values indicating the auto focus ranges that are supported by the capture device.
 */
supportedFocusRanges: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Media$Devices$AutoFocusRange>>;

/**
 * Gets the focus presets that the capture device supports.
 */
supportedPresets: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Media$Devices$FocusPreset>>;

/**
 * Unlocks the capture device's focus if it has previously been locked with a call to LockAsync .
 * @return An asynchronous action.
 */
unlockAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the current value that the focus is set to.
 */
value: number;

/**
 * Gets a value that indicates whether WaitForFocus is supported by the capture device.
 */
waitForFocusSupported: boolean
}


/**
 * Defines the values for focus mode.
 */

declare  var Windows$Media$Devices$FocusMode: {|
  +auto: 0,// 0
+single: 1,// 1
+continuous: 2,// 2
+manual: 3,// 3

|};



/**
 * Defines the values for the possible focus presets.
 */

declare  var Windows$Media$Devices$FocusPreset: {|
  +auto: 0,// 0
+manual: 1,// 1
+autoMacro: 2,// 2
+autoNormal: 3,// 3
+autoInfinity: 4,// 4
+autoHyperfocal: 5,// 5

|};



/**
 * Represents settings for a FocusControl object.
 */
declare class Windows$Media$Devices$FocusSettings  {

/**
 * Initializes a new instance of the FocusSettings class.
 */
constructor(): this;

/**
 * Gets or sets a value indicating the auto focus range setting.
 */
autoFocusRange: $Values<typeof Windows$Media$Devices$AutoFocusRange>;

/**
 * Gets or sets a value that indicates to the driver if it should disable determining a focus position when the focus search fails.
 */
disableDriverFallback: boolean;

/**
 * Gets or sets a value indicating the manual focus distance setting.
 */
distance: $Values<typeof Windows$Media$Devices$ManualFocusDistance>;

/**
 * Gets or sets a value indicating the focus mode setting.
 */
mode: $Values<typeof Windows$Media$Devices$FocusMode>;

/**
 * Gets or sets the focus value setting.
 */
value: number;

/**
 * Gets or sets a value indicating whether the capture device should wait for focus before capturing.
 */
waitForFocus: boolean
}


/**
 * When supported, allows an app to enable High Dynamic Range (HDR) video recording on the capture device.
 */
declare class Windows$Media$Devices$HdrVideoControl  {

/**
 * Gets or sets a value indicating the current High Dynamic Range (HDR) video recording mode of the capture device.
 */
mode: $Values<typeof Windows$Media$Devices$HdrVideoMode>;

/**
 * Gets a value that indicates if the capture device supports the HdrVideoControl .
 */
supported: boolean;

/**
 * Gets the list of HdrVideoMode values indicating the modes supported by the capture device.
 */
supportedModes: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Media$Devices$HdrVideoMode>>
}


/**
 * Defines the High Dynamic Range (HDR) video modes.
 */

declare  var Windows$Media$Devices$HdrVideoMode: {|
  +off: 0,// 0
+on: 1,// 1
+auto: 2,// 2

|};



/**
 * Provides functionality for controlling the ISO film speed settings on a capture device.
 */
declare class Windows$Media$Devices$IsoSpeedControl  {

/**
 * Gets a value indicating whether auto ISO speed is enabled.
 */
auto: boolean;

/**
 * Gets the maximum ISO speed supported by the capture device.
 */
max: number;

/**
 * Gets the minimum ISO speed supported by the capture device.
 */
min: number;

/**
 * Gets the ISO film speed preset.
 */
preset: $Values<typeof Windows$Media$Devices$IsoSpeedPreset>;

/**
 * Sets the ISO speed to automatic.
 * @return An asynchronous action.
 */
setAutoAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously sets the ISO film speed Preset .
 * @param preset The ISO preset value to set the Preset property to.
 * @return The object that is used to control the asynchronous operation.
 */
setPresetAsync(
preset: $Values<typeof Windows$Media$Devices$IsoSpeedPreset>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Sets the ISO speed value.
 * @param isoSpeed The ISO speed value.
 * @return An asynchronous action.
 */
setValueAsync(isoSpeed: number): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the smallest ISO speed increment supported by the capture device.
 */
step: number;

/**
 * Gets a value the specifies if the capture device supports the ISO speed control.
 */
supported: boolean;

/**
 * Gets the ISO presets that the capture device supports.
 */
supportedPresets: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Media$Devices$IsoSpeedPreset>>;

/**
 * Gets the current ISO speed value.
 */
value: number
}


/**
 * Defines the possible values for ISO speed presets.
 */

declare  var Windows$Media$Devices$IsoSpeedPreset: {|
  +auto: 0,// 0
+iso50: 1,// 1
+iso80: 2,// 2
+iso100: 3,// 3
+iso200: 4,// 4
+iso400: 5,// 5
+iso800: 6,// 6
+iso1600: 7,// 7
+iso3200: 8,// 8
+iso6400: 9,// 9
+iso12800: 10,// 10
+iso25600: 11,// 11

|};



/**
 * Contains information for the KeypadPressed event.
 */
declare class Windows$Media$Devices$KeypadPressedEventArgs  {

/**
 * Returns the value of the keypad button on the device that was pressed.
 */
telephonyKey: $Values<typeof Windows$Media$Devices$TelephonyKey>
}


/**
 * Provides functionality for managing the low shutter lag photo capture mode on the capture device.
 */
declare class Windows$Media$Devices$LowLagPhotoControl  {

/**
 * Gets or sets the desired size for thumbnails, which is the largest length of the image, either width or height.
 */
desiredThumbnailSize: number;

/**
 * Gets the current frame rate at which pictures can be taken.
 * @return The current frame rate.
 */
getCurrentFrameRate(): Windows$Media$MediaProperties$MediaRatio;

/**
 * Gets the highest frame rate supported when video and photos are being captured concurrently.
 * @param captureProperties The media encoding properties.
 * @return The highest concurrent frames per second.
 */
getHighestConcurrentFrameRate(
captureProperties: Windows$Media$MediaProperties$IMediaEncodingProperties): Windows$Media$MediaProperties$MediaRatio;

/**
 * Gets a value that specifies if hardware acceleration is supported for thumbnails.
 */
hardwareAcceleratedThumbnailSupported: number;

/**
 * Gets a value that enables and disables thumbnail support.
 */
thumbnailEnabled: boolean;

/**
 * Gets or sets the media format for the thumbnails.
 */
thumbnailFormat: $Values<typeof Windows$Media$MediaProperties$MediaThumbnailFormat>
}


/**
 * Provides functionality for managing the low shutter lag photo sequence mode on the capture device.
 */
declare class Windows$Media$Devices$LowLagPhotoSequenceControl  {

/**
 * Gets or sets the desired size for thumbnails, which is the largest length of the image, either width or height.
 */
desiredThumbnailSize: number;

/**
 * Gets the current frame rate at which pictures can be taken.
 * @return The current frame rate.
 */
getCurrentFrameRate(): Windows$Media$MediaProperties$MediaRatio;

/**
 * Gets the highest frame rate supported when video and photos sequences are being captured concurrently.
 * @param captureProperties The media encoding properties.
 * @return The highest concurrent frames per second.
 */
getHighestConcurrentFrameRate(
captureProperties: Windows$Media$MediaProperties$IMediaEncodingProperties): Windows$Media$MediaProperties$MediaRatio;

/**
 * Gets a value that specifies if hardware acceleration is supported for thumbnails in photo sequence mode.
 */
hardwareAcceleratedThumbnailSupported: number;

/**
 * Gets the maximum number of past photos that can be stored.
 */
maxPastPhotos: number;

/**
 * Gets the maximum number of photos that can be taken per second.
 */
maxPhotosPerSecond: number;

/**
 * Gets or sets a value that specifies the number of past photos to store.
 */
pastPhotoLimit: number;

/**
 * Gets or sets the number of photos that are taken per second.
 */
photosPerSecondLimit: number;

/**
 * Gets a value that specifies if the capture device supports low shutter lag photo sequence mode.
 */
supported: boolean;

/**
 * Gets a value that enables and disables thumbnail support in photo sequence mode.
 */
thumbnailEnabled: boolean;

/**
 * Gets or sets the media format for the thumbnails.
 */
thumbnailFormat: $Values<typeof Windows$Media$MediaProperties$MediaThumbnailFormat>
}


/**
 * Defines the options for manual focus distance.
 */

declare  var Windows$Media$Devices$ManualFocusDistance: {|
  +infinity: 0,// 0
+hyperfocal: 1,// 1
+nearest: 2,// 2

|};



/**
 * Defines the different focus states the capture device can be in.
 */

declare  var Windows$Media$Devices$MediaCaptureFocusState: {|
  +uninitialized: 0,// 0
+lost: 1,// 1
+searching: 2,// 2
+focused: 3,// 3
+failed: 4,// 4

|};



/**
 * Defines the optimizations that the media capture device can use.
 */

declare  var Windows$Media$Devices$MediaCaptureOptimization: {|
  +default: 0,// 0
+quality: 1,// 1
+latency: 2,// 2
+power: 3,// 3
+latencyThenQuality: 4,// 4
+latencyThenPower: 5,// 5
+powerAndQuality: 6,// 6

|};



/**
 * Defines the behavior when media capture is paused with a call to PauseAsync or PauseRecordAsync .
 */

declare  var Windows$Media$Devices$MediaCapturePauseBehavior: {|
  +retainHardwareResources: 0,// 0
+releaseHardwareResources: 1,// 1

|};



/**
 * Provides methods used to select devices for capturing and rendering audio, and for capturing video.
 */
declare class Windows$Media$Devices$MediaDevice  {

/**
 * Returns the identifier string of a device for capturing audio.
 * @return The identifier string of the audio capture device.
 */
static getAudioCaptureSelector(): string;

/**
 * Returns the identifier string of a device for rendering audio.
 * @return The identifier string of the audio rendering device.
 */
static getAudioRenderSelector(): string;

/**
 * Returns the identifier string of the default device for capturing audio in the specified role.
 * @param role The specified audio device role (console, media, or communications).
 * @return The identifier string of the default device.
 */
static getDefaultAudioCaptureId(role: $Values<typeof Windows$Media$Devices$AudioDeviceRole>): string;

/**
 * Returns the identifier string of the default device for rendering audio in the specified role.
 * @param role The specified audio device role (console, media, or communications).
 * @return The identifier string of the default device.
 */
static getDefaultAudioRenderId(role: $Values<typeof Windows$Media$Devices$AudioDeviceRole>): string;

/**
 * Returns the identifier string of a device for capturing video.
 * @return The identifier string of the video capture device.
 */
static getVideoCaptureSelector(): string;

/**
 * Raised when the default audio capture device is changed.
 */
static ondefaultaudiocapturedevicechanged: Windows$Foundation$TypedEventHandler<any, Windows$Media$Devices$DefaultAudioCaptureDeviceChangedEventArgs>;
static addEventListener(
type: "defaultaudiocapturedevicechanged",
listener: Windows$Foundation$TypedEventHandler<any, Windows$Media$Devices$DefaultAudioCaptureDeviceChangedEventArgs>): void;
static removeEventListener(
type: "defaultaudiocapturedevicechanged",
listener: Windows$Foundation$TypedEventHandler<any, Windows$Media$Devices$DefaultAudioCaptureDeviceChangedEventArgs>): void;

/**
 * Raised when the default audio render device is changed.
 */
static ondefaultaudiorenderdevicechanged: Windows$Foundation$TypedEventHandler<any, Windows$Media$Devices$DefaultAudioRenderDeviceChangedEventArgs>;
static addEventListener(
type: "defaultaudiorenderdevicechanged",
listener: Windows$Foundation$TypedEventHandler<any, Windows$Media$Devices$DefaultAudioRenderDeviceChangedEventArgs>): void;
static removeEventListener(
type: "defaultaudiorenderdevicechanged",
listener: Windows$Foundation$TypedEventHandler<any, Windows$Media$Devices$DefaultAudioRenderDeviceChangedEventArgs>): void;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Gets or sets a device setting on a camera.
 */
declare class Windows$Media$Devices$MediaDeviceControl  {

/**
 * Gets the capabilities of the camera for this camera setting.
 */
capabilities: Windows$Media$Devices$MediaDeviceControlCapabilities;

/**
 * Indicates whether automatic adjustment of the camera setting is enabled.
 */
tryGetAuto(): {
value: boolean,
returnValue: boolean
};

/**
 * Gets the value of the camera setting.
 */
tryGetValue(): {
value: number,
returnValue: boolean
};

/**
 * Enables or disables automatic adjustment of the camera setting.
 * @param value True to enable automatic adjustment; or false to disable automatic adjustment. If false, call TrySetValue to adjust the setting.
 * @return Returns true if the method succeeds, or false otherwise.
 */
trySetAuto(value: boolean): boolean;

/**
 * Sets the camera setting.
 * @param value The new value of the camera setting. The units depend on the setting.
 * @return Returns true if the method succeeds, or false otherwise.
 */
trySetValue(value: number): boolean
}


/**
 * Gets the capabilities of a camera setting.
 */
declare class Windows$Media$Devices$MediaDeviceControlCapabilities  {

/**
 * Queries whether the camera supports automatic adjustment of the setting.
 */
autoModeSupported: boolean;

/**
 * Gets the default value of the camera setting.
 */
default: number;

/**
 * Sets the maximum value of the camera setting.
 */
max: number;

/**
 * Gets the minimum value of the camera setting.
 */
min: number;

/**
 * Ges the step size for the setting. The step size is the smallest increment by which the property can change.
 */
step: number;

/**
 * Indicates whether the camera supports this camera setting.
 */
supported: boolean
}


/**
 * When supported, allows an app to enable optical image stabilization on the capture device.
 */
declare class Windows$Media$Devices$OpticalImageStabilizationControl  {

/**
 * Gets or sets a value indicating the current optical image stabilization mode of the capture device.
 */
mode: $Values<typeof Windows$Media$Devices$OpticalImageStabilizationMode>;

/**
 * Gets a value that indicates if the capture device supports the OpticalImageStabilizationControl .
 */
supported: boolean;

/**
 * Gets the list of OpticalImageStabilizationMode values indicating the modes supported by the capture device.
 */
supportedModes: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Media$Devices$OpticalImageStabilizationMode>>
}


/**
 * Defines the optical image stabilization modes.
 */

declare  var Windows$Media$Devices$OpticalImageStabilizationMode: {|
  +off: 0,// 0
+on: 1,// 1
+auto: 2,// 2

|};



/**
 * Provides functionality for controlling the photo confirmation settings on a capture device.
 */
declare class Windows$Media$Devices$PhotoConfirmationControl  {

/**
 * Gets or sets a value indicating whether photo confirmation is enabled.
 */
enabled: boolean;

/**
 * Gets or sets the desired pixel format for photo confirmation frames.
 */
pixelFormat: $Values<typeof Windows$Media$MediaProperties$MediaPixelFormat>;

/**
 * Gets a value indicating whether photo confirmation is supported by the capture device.
 */
supported: boolean
}


/**
 * Contains information for the RedialRequested event.
 */
declare class Windows$Media$Devices$RedialRequestedEventArgs  {

/**
 * Indicates that the RedialRequested event has been handled.
 */
handled(): void
}


/**
 * Represents a region of interest which is a rectangular region on the image which is used for functions such as focus and exposure.
 */
declare class Windows$Media$Devices$RegionOfInterest  {

/**
 * Creates a new instance of the RegionOfInterest control.
 */
constructor(): this;

/**
 * Gets or sets a value that specifies if auto exposure is enabled.
 */
autoExposureEnabled: boolean;

/**
 * Gets or sets a value that specifies if auto focus is enabled.
 */
autoFocusEnabled: boolean;

/**
 * Gets or sets a value that specifies if auto white balance is enabled.
 */
autoWhiteBalanceEnabled: boolean;

/**
 * Gets or sets the rectangle that defines the region of focus.
 */
bounds: Windows$Foundation$Rect;

/**
 * Gets or sets a value indicating whether the Bounds Rect is in pixels or is mapped to a range of 0 to 1.0.
 */
boundsNormalized: boolean;

/**
 * Gets or sets the type of region represented by the RegionOfInterest object.
 */
type: $Values<typeof Windows$Media$Devices$RegionOfInterestType>;

/**
 * Gets or sets the weight of the region of interest.
 */
weight: number
}


/**
 * Defines the different types of regions of interest that can be detected the capture device.
 */

declare  var Windows$Media$Devices$RegionOfInterestType: {|
  +unknown: 0,// 0
+face: 1,// 1

|};



/**
 * Provides functionality to mange the regions of interest on a device.
 */
declare class Windows$Media$Devices$RegionsOfInterestControl  {

/**
 * Gets a value that specifies if auto exposure is supported on the capture device.
 */
autoExposureSupported: boolean;

/**
 * Gets a value that specifies if auto focus is supported on the capture device.
 */
autoFocusSupported: boolean;

/**
 * Gets a value that specifies if auto white balance is supported on the capture device.
 */
autoWhiteBalanceSupported: boolean;

/**
 * Asynchronously clears the regions of interests.
 * @return The object that is used to control the asynchronous operation.
 */
clearRegionsAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the maximum number of regions of interest that can be specified.
 */
maxRegions: number;

/**
 * Asynchronously sets the regions of interest.
 * @param regions The regions of interest.
 * @return The object that is used to control the asynchronous operation.
 */
setRegionsAsync(
regions: Windows$Foundation$Collections$IIterable<Windows$Media$Devices$RegionOfInterest>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously sets the regions of interest and specifies if the values should be locked.
 * @param regions The regions of interests.
 * @param lockValues Specifies if the values should be locked.
 * @return The object that is used to control the asynchronous operation.
 */
setRegionsAsync(
regions: Windows$Foundation$Collections$IIterable<Windows$Media$Devices$RegionOfInterest>,
lockValues: boolean): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Provides functionality for controlling the scene mode settings on a capture device.
 */
declare class Windows$Media$Devices$SceneModeControl  {

/**
 * Asynchronously sets the color temperature Value .
 * @param sceneMode The scene mode to set the Value property to.
 * @return The object that is used to control the asynchronous operation.
 */
setValueAsync(
sceneMode: $Values<typeof Windows$Media$Devices$CaptureSceneMode>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the scene modes supported on the capture device.
 */
supportedModes: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Media$Devices$CaptureSceneMode>>;

/**
 * Gets the current scene mod ethe capture device is set to.
 */
value: $Values<typeof Windows$Media$Devices$CaptureSceneMode>
}


/**
 * Indicates the keypad button that was pressed on a telephony device.
 */

declare  var Windows$Media$Devices$TelephonyKey: {|
  +d0: 0,// 0
+d1: 1,// 1
+d2: 2,// 2
+d3: 3,// 3
+d4: 4,// 4
+d5: 5,// 5
+d6: 6,// 6
+d7: 7,// 7
+d8: 8,// 8
+d9: 9,// 9
+star: 10,// 10
+pound: 11,// 11
+a: 12,// 12
+b: 13,// 13
+c: 14,// 14
+d: 15,// 15

|};



/**
 * Provides functionality for controlling the torch LED settings on a capture device.
 */
declare class Windows$Media$Devices$TorchControl  {

/**
 * Gets or sets a value that enables and disables the torch LED on the device.
 */
enabled: boolean;

/**
 * Gets or sets the intensity of the torch LED.
 */
powerPercent: number;

/**
 * Gets a value that specifics if the device allows the torch LED power settings to be changed.
 */
powerSupported: boolean;

/**
 * Gets a value that specifies if the capture device supports the torch control.
 */
supported: boolean
}


/**
 * Controls device settings on the camera.
 */
declare class Windows$Media$Devices$VideoDeviceController  {

/**
 * Gets the advanced photo capture control for this video device.
 */
advancedPhotoControl: Windows$Media$Devices$AdvancedPhotoControl;

/**
 * Specifies whether back-light compensation is enabled on the camera.
 */
backlightCompensation: Windows$Media$Devices$MediaDeviceControl;

/**
 * Gets or sets the brightness level on the camera.
 */
brightness: Windows$Media$Devices$MediaDeviceControl;

/**
 * Gets or sets the contrast level on the camera.
 */
contrast: Windows$Media$Devices$MediaDeviceControl;

/**
 * Gets or sets a value that indicates the optimizations the capture device should use to prioritize high quality picture, low latency, or low power consumption during video capture.
 */
desiredOptimization: $Values<typeof Windows$Media$Devices$MediaCaptureOptimization>;

/**
 * Gets or sets the camera's exposure time.
 */
exposure: Windows$Media$Devices$MediaDeviceControl;

/**
 * Gets the exposure compensation control for this video device.
 */
exposureCompensationControl: Windows$Media$Devices$ExposureCompensationControl;

/**
 * Gets the exposure control for this video device.
 */
exposureControl: Windows$Media$Devices$ExposureControl;

/**
 * Gets the ExposurePriorityVideoControl associated with the VideoDeviceController .
 */
exposurePriorityVideoControl: Windows$Media$Devices$ExposurePriorityVideoControl;

/**
 * Gets the flash control for this video device.
 */
flashControl: Windows$Media$Devices$FlashControl;

/**
 * Gets or sets the camera's focus setting.
 */
focus: Windows$Media$Devices$MediaDeviceControl;

/**
 * Gets the focus control for this video device.
 */
focusControl: Windows$Media$Devices$FocusControl;

/**
 * Gets a list of the supported encoding properties for the video device.
 * @param mediaStreamType The type of media stream for which to get the properties.
 * @return A list of the supported encoding properties.
 */
getAvailableMediaStreamProperties(
mediaStreamType: $Values<typeof Windows$Media$Capture$MediaStreamType>): Windows$Foundation$Collections$IVectorView<Windows$Media$MediaProperties$IMediaEncodingProperties>;

/**
 * Gets a property on the camera. You can use this method to query properties that are specific to a particular camera.
 * @param propertyId The property identifier.
 * @return The property value.
 */
getDeviceProperty(propertyId: string): any;

/**
 * Gets the encoding properties for the specified media stream type for the video device.
 * @param mediaStreamType The type of media stream for which to get the properties.
 * @return The encoding properties.
 */
getMediaStreamProperties(
mediaStreamType: $Values<typeof Windows$Media$Capture$MediaStreamType>): Windows$Media$MediaProperties$IMediaEncodingProperties;

/**
 * Gets the HdrVideoControl associated with the VideoDeviceController .
 */
hdrVideoControl: Windows$Media$Devices$HdrVideoControl;

/**
 * Gets or sets the camera's hue setting.
 */
hue: Windows$Media$Devices$MediaDeviceControl;

/**
 * Gets the ISO film speed control for this video device.
 */
isoSpeedControl: Windows$Media$Devices$IsoSpeedControl;

/**
 * Gets the low shutter lag photo control for this video device.
 */
lowLagPhoto: Windows$Media$Devices$LowLagPhotoControl;

/**
 * Gets the low shutter lag photo sequence control for this video device.
 */
lowLagPhotoSequence: Windows$Media$Devices$LowLagPhotoSequenceControl;

/**
 * Gets the OpticalImageStabilizationControl associated with the VideoDeviceController .
 */
opticalImageStabilizationControl: Windows$Media$Devices$OpticalImageStabilizationControl;

/**
 * Gets or sets the camera's pan setting.
 */
pan: Windows$Media$Devices$MediaDeviceControl;

/**
 * Gets the photo confirmation control for this video device.
 */
photoConfirmationControl: Windows$Media$Devices$PhotoConfirmationControl;

/**
 * Gets or sets the primary use for the device.
 */
primaryUse: $Values<typeof Windows$Media$Devices$CaptureUse>;

/**
 * Gets the regions of interest control for this video device.
 */
regionsOfInterestControl: Windows$Media$Devices$RegionsOfInterestControl;

/**
 * Gets or sets the camera's roll setting.
 */
roll: Windows$Media$Devices$MediaDeviceControl;

/**
 * Gets the scene mode control for this video device.
 */
sceneModeControl: Windows$Media$Devices$SceneModeControl;

/**
 * Sets a property on the device. You can use this method to set properties that are specific to a particular device.
 * @param propertyId The property identifier.
 * @param propertyValue The new value of the property.
 */
setDeviceProperty(propertyId: string, propertyValue: any): void;

/**
 * Sets the encoding properties asynchronously for the specified media stream type for the video device.
 * @param mediaStreamType The type of media stream for which to set the properties.
 * @param mediaEncodingProperties The encoding properties to set.
 * @return An IAsyncAction object that is used to control the asynchronous operation.
 */
setMediaStreamPropertiesAsync(
mediaStreamType: $Values<typeof Windows$Media$Capture$MediaStreamType>,
mediaEncodingProperties: Windows$Media$MediaProperties$IMediaEncodingProperties): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets or sets the camera's tilt setting.
 */
tilt: Windows$Media$Devices$MediaDeviceControl;

/**
 * Gets the torch control for this video device.
 */
torchControl: Windows$Media$Devices$TorchControl;

/**
 * Gets the local power line frequency.
 */
tryGetPowerlineFrequency(
): {
value: $Values<typeof Windows$Media$Capture$PowerlineFrequency>,
returnValue: boolean
};

/**
 * Sets the local power line frequency.
 * @param value The power line frequency.
 * @return Returns true if the method succeeded, or false otherwise.
 */
trySetPowerlineFrequency(value: $Values<typeof Windows$Media$Capture$PowerlineFrequency>): boolean;

/**
 * Gets the VariablePhotoSequenceController associated with the VideoDeviceController .
 */
variablePhotoSequenceController: Windows$Media$Devices$Core$VariablePhotoSequenceController;

/**
 * Gets or sets the white balance on the camera.
 */
whiteBalance: Windows$Media$Devices$MediaDeviceControl;

/**
 * Gets the white balance control for this video device.
 */
whiteBalanceControl: Windows$Media$Devices$WhiteBalanceControl;

/**
 * Gets and sets the camera's zoom setting.
 */
zoom: Windows$Media$Devices$MediaDeviceControl;

/**
 * Gets the ZoomControl associated with the VideoDeviceController .
 */
zoomControl: Windows$Media$Devices$ZoomControl
}


/**
 * Provides functionality for controlling the white balance settings on a capture device.
 */
declare class Windows$Media$Devices$WhiteBalanceControl  {

/**
 * Gets the maximum white balance value.
 */
max: number;

/**
 * Gets the minimum white balance value.
 */
min: number;

/**
 * Gets the color temperature preset.
 */
preset: $Values<typeof Windows$Media$Devices$ColorTemperaturePreset>;

/**
 * Asynchronously sets the color temperature Preset .
 * @param preset The color temperate preset to set the Preset property to.
 * @return The object that is used to control the asynchronous operation.
 */
setPresetAsync(
preset: $Values<typeof Windows$Media$Devices$ColorTemperaturePreset>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously sets the color temperature Value .
 * @param temperature The temperature value to set the Value property to.
 * @return The object that is used to control the asynchronous operation.
 */
setValueAsync(temperature: number): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the step value.
 */
step: number;

/**
 * Gets a value that specifies if the capture device supports the white balance control.
 */
supported: boolean;

/**
 * Gets the color temperature value.
 */
value: number
}


/**
 * Provides functionality for controlling the zoom settings on a capture device.
 */
declare class Windows$Media$Devices$ZoomControl  {

/**
 * Configures the zoom control with the provided zoom settings.
 * @param settings The zoom settings.
 */
configure(settings: Windows$Media$Devices$ZoomSettings): void;

/**
 * Gets the maximum zoom value supported by the capture device.
 */
max: number;

/**
 * Gets the minimum zoom value supported by the capture device.
 */
min: number;

/**
 * Gets a value indicating the current zoom transition mode.
 */
mode: $Values<typeof Windows$Media$Devices$ZoomTransitionMode>;

/**
 * Gets the smallest zoom value increment supported by the capture device.
 */
step: number;

/**
 * Gets a value indicating whether zoom control is supported by the capture device.
 */
supported: boolean;

/**
 * Gets the list of ZoomTransitionMode values indicating the modes supported by the capture device.
 */
supportedModes: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Media$Devices$ZoomTransitionMode>>;

/**
 * Gets or sets the zoom value to be used by the capture device.
 */
value: number
}


/**
 * Represents zoom settings that can be applied to the ZoomControl by calling the Configure method.
 */
declare class Windows$Media$Devices$ZoomSettings  {

/**
 * Initializes a new instance of the ZoomSettings class.
 */
constructor(): this;

/**
 * Gets or sets a ZoomTransitionMode value indicating how the capture device should transition to the new zoom value specified with the Value property.
 */
mode: $Values<typeof Windows$Media$Devices$ZoomTransitionMode>;

/**
 * Gets or sets the zoom value to which the ZoomControl will transition.
 */
value: number
}


/**
 * Defines the zoom transition modes.
 */

declare  var Windows$Media$Devices$ZoomTransitionMode: {|
  +auto: 0,// 0
+direct: 1,// 1
+smooth: 2,// 2

|};



/**
 * Handles the AnswerRequested and AudioTransferRequested events.
 */
declare type Windows$Media$Devices$CallControlEventHandler = (ev: Windows$WinRTEvent<Windows$Media$Devices$CallControl>) => void;


/**
 * Handles the DialRequested event.
 */
declare type Windows$Media$Devices$DialRequestedEventHandler = (
ev: Windows$Media$Devices$DialRequestedEventArgs & Windows$WinRTEvent<Windows$Media$Devices$CallControl>) => void;


/**
 * Handles the KeypadPressed event.
 */
declare type Windows$Media$Devices$KeypadPressedEventHandler = (
ev: Windows$Media$Devices$KeypadPressedEventArgs & Windows$WinRTEvent<Windows$Media$Devices$CallControl>) => void;


/**
 * Handles the RedialRequested event.
 */
declare type Windows$Media$Devices$RedialRequestedEventHandler = (
ev: Windows$Media$Devices$RedialRequestedEventArgs & Windows$WinRTEvent<Windows$Media$Devices$CallControl>) => void;


      declare var npm$namespace$Windows$Media$DialProtocol: {
        
        
        DialAppLaunchResult: typeof Windows$Media$DialProtocol$DialAppLaunchResult,
DialAppState: typeof Windows$Media$DialProtocol$DialAppState,
DialAppStopResult: typeof Windows$Media$DialProtocol$DialAppStopResult,
DialDeviceDisplayStatus: typeof Windows$Media$DialProtocol$DialDeviceDisplayStatus,
        DialApp: typeof Windows$Media$DialProtocol$DialApp,
DialAppStateDetails: typeof Windows$Media$DialProtocol$DialAppStateDetails,
DialDevice: typeof Windows$Media$DialProtocol$DialDevice,
DialDevicePicker: typeof Windows$Media$DialProtocol$DialDevicePicker,
DialDevicePickerFilter: typeof Windows$Media$DialProtocol$DialDevicePickerFilter,
DialDeviceSelectedEventArgs: typeof Windows$Media$DialProtocol$DialDeviceSelectedEventArgs,
DialDisconnectButtonClickedEventArgs: typeof Windows$Media$DialProtocol$DialDisconnectButtonClickedEventArgs,
        
      }

/**
 * Represents a DIAL application running on a remote device.
 */
declare class Windows$Media$DialProtocol$DialApp  {

/**
 * Gets the applications registered DIAL name.
 */
appName: string;

/**
 * Gets the current status of the application on the remote device.
 * @return The app status, a value from DialAppStateDetails .
 */
getAppStateAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$DialProtocol$DialAppStateDetails>;

/**
 * Initiates the launching of the app on the remote device. When this method is called, the DialDevice is paired if necessary, the user is prompted to allow access to the device, connection is established, app existence is validated on the device, and finally the application is launched with the provided argument.
 * @param appArgument Optional.
 * @return Indicates the result of attempting to launch the app.
 */
requestLaunchAsync(
appArgument: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Media$DialProtocol$DialAppLaunchResult>>;

/**
 * Stops the app on the remote device, if the remote device supports this functionality.
 * @return The result of sending the request to stop the app.
 */
stopAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Media$DialProtocol$DialAppStopResult>>
}


/**
 * The result of attempting to launch an app on a remote device.
 */

declare  var Windows$Media$DialProtocol$DialAppLaunchResult: {|
  +launched: 0,// 0
+failedToLaunch: 1,// 1
+notFound: 2,// 2
+networkFailure: 3,// 3

|};



/**
 * The state of the application on the remote device.
 */

declare  var Windows$Media$DialProtocol$DialAppState: {|
  +unknown: 0,// 0
+stopped: 1,// 1
+running: 2,// 2
+networkFailure: 3,// 3

|};



/**
 * Represents the state of the DIAL app.
 */
declare class Windows$Media$DialProtocol$DialAppStateDetails  {

/**
 * Gets the entire XML response that is provided by the app when state of the app was requested.
 */
fullXml: string;

/**
 * Gets the state of the application at the time the GetAppStateAsync was completed.
 */
state: $Values<typeof Windows$Media$DialProtocol$DialAppState>
}


/**
 * The result of attempting to stop an app from running on a remote device.
 */

declare  var Windows$Media$DialProtocol$DialAppStopResult: {|
  +stopped: 0,// 0
+stopFailed: 1,// 1
+operationNotSupported: 2,// 2
+networkFailure: 3,// 3

|};



/**
 * Represents the remote device capable of running DIAL apps.
 */
declare class Windows$Media$DialProtocol$DialDevice  {

/**
 * Indicates whether or not the device supports launching DIAL apps.
 * @param device The device you want to get information for.
 * @return True if app launching is supported; false, otherwise.
 */
static deviceInfoSupportsDialAsync(
device: Windows$Devices$Enumeration$DeviceInformation): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Returns a DialDevice object for a given a device ID (acquired from a query using the Windows.Devices.Enumeration APIs).
 * @param value The ID of the device you want a DialDevice object for.
 * @return The DialDevice object for the given device ID.
 */
static fromIdAsync(
value: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$DialProtocol$DialDevice>;

/**
 * Returns an AQS filter string to be used with the Windows.Devices.Enumeration APIs (such as the CreateWatcher API) for a given Dial app.
 * @param appName The name of the app.
 * @return The AQS filter.
 */
static getDeviceSelector(appName: string): string;

/**
 * Gets the friendly name for the DIAL device.
 */
friendlyName: string;

/**
 * Creates a new DialApp object. This method does not establish a connection to the device or validate that the app exists. That is done when any function is called on the resulting DialApp object.
 * @param appName The name of the app. This becomes the AppName property of the new object.
 * @return The DialApp object for the app.
 */
getDialApp(appName: string): Windows$Media$DialProtocol$DialApp;

/**
 * Gets the remote device's ID. You can use this ID with the Windows.Devices.Enumeration APIs as well.
 */
id: string;

/**
 * Gets a stream containing the thumbnail image for the DIAL device.
 */
thumbnail: Windows$Storage$Streams$IRandomAccessStreamReference
}


/**
 * The possible statuses a DIAL device can have in the DIAL device picker. You can use these to adjust the sub-status and other visual attributes for a particular device in the picker.
 */

declare  var Windows$Media$DialProtocol$DialDeviceDisplayStatus: {|
  +none: 0,// 0
+connecting: 1,// 1
+connected: 2,// 2
+disconnecting: 3,// 3
+disconnected: 4,// 4
+error: 5,// 5

|};



/**
 * Represents a picker flyout that contains a list of remote devices for the user to choose from.
 */
declare class Windows$Media$DialProtocol$DialDevicePicker  {

/**
 * Creates a new DialDevicePicker object.
 */
constructor(): this;

/**
 * Used to change the colors of the picker.
 */
appearance: Windows$Devices$Enumeration$DevicePickerAppearance;

/**
 * Gets the filter used to choose what devices to show in the picker.
 */
filter: Windows$Media$DialProtocol$DialDevicePickerFilter;

/**
 * Hides the picker.
 */
hide(): void;

/**
 * Indicates that the device picker was light dismissed, which means that the user clicked or touched anywhere other than the picker UI, and so the picker will be closed.
 */
ondialdevicepickerdismissed: Windows$Foundation$TypedEventHandler<Windows$Media$DialProtocol$DialDevicePicker, any>;
addEventListener(
type: "dialdevicepickerdismissed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$DialProtocol$DialDevicePicker, any>): void;
removeEventListener(
type: "dialdevicepickerdismissed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$DialProtocol$DialDevicePicker, any>): void;

/**
 * Indicates that the user selected a device from the picker.
 */
ondialdeviceselected: Windows$Foundation$TypedEventHandler<Windows$Media$DialProtocol$DialDevicePicker, Windows$Media$DialProtocol$DialDeviceSelectedEventArgs>;
addEventListener(
type: "dialdeviceselected",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$DialProtocol$DialDevicePicker, Windows$Media$DialProtocol$DialDeviceSelectedEventArgs>): void;
removeEventListener(
type: "dialdeviceselected",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$DialProtocol$DialDevicePicker, Windows$Media$DialProtocol$DialDeviceSelectedEventArgs>): void;

/**
 * Indicates that the user clicked on the disconnect button in the picker.
 */
ondisconnectbuttonclicked: Windows$Foundation$TypedEventHandler<Windows$Media$DialProtocol$DialDevicePicker, Windows$Media$DialProtocol$DialDisconnectButtonClickedEventArgs>;
addEventListener(
type: "disconnectbuttonclicked",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$DialProtocol$DialDevicePicker, Windows$Media$DialProtocol$DialDisconnectButtonClickedEventArgs>): void;
removeEventListener(
type: "disconnectbuttonclicked",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$DialProtocol$DialDevicePicker, Windows$Media$DialProtocol$DialDisconnectButtonClickedEventArgs>): void;

/**
 * Shows the picker. Call this method directly to show to show the picker, instead of showing it in response to an event.
 * @param selection The rectangle from which to show the picker.
 * @param preferredPlacement The edge of the rectangle from which to show the picker.
 * @return The DialDevice object selected.
 */
pickSingleDialDeviceAsync(
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$DialProtocol$DialDevice>;

/**
 * Shows the picker. Call this method directly to show to show the picker, instead of showing it in response to an event.
 * @param selection The rectangle from which to show the picker.
 * @return The device the user selected from the picker.
 */
pickSingleDialDeviceAsync(
selection: Windows$Foundation$Rect): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$DialProtocol$DialDevice>;

/**
 * Updates the picker UI to reflect the status fo a given remote device.
 * @param device The remote device whose status you want to display.
 * @param status The status you want displayed.
 */
setDisplayStatus(
device: Windows$Media$DialProtocol$DialDevice,
status: $Values<typeof Windows$Media$DialProtocol$DialDeviceDisplayStatus>): void;

/**
 * Displays the picker to the user. When called, the picker flies out from the specified edge of the provided rectangle.
 * @param selection The rectangle from which you want the picker to show.
 * @param preferredPlacement The edge from which you want the picker to show.
 */
show(
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>): void;

/**
 * Displays the picker to the user. When called, the picker flies out from an edge of the provided rectangle.
 * @param selection The rectangle from which you want the picker to show.
 */
show(selection: Windows$Foundation$Rect): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the filter used to determine which devices to show in a DialDevicePicker . The filter parameters are OR-ed together to build the resulting filter.
 */
declare class Windows$Media$DialProtocol$DialDevicePickerFilter  {

/**
 * Gets a list of DIAL apps supported by the remote devices. Defaults to an empty list (no filter). You can add one or more app names and filter the devices list to those that can launch one the supported apps.
 */
supportedAppNames: Windows$Foundation$Collections$IVector<string>
}


/**
 * Represents the event arguments for the DialDeviceSelected event on the DialDevicePicker object.
 */
declare class Windows$Media$DialProtocol$DialDeviceSelectedEventArgs  {

/**
 * Gets the DialDevice object that represents the remote device that has been selected by the user in a DialDevicePicker .
 */
selectedDialDevice: Windows$Media$DialProtocol$DialDevice
}


/**
 * Represents the event arguments for the DisconnectButtonClicked event on the DialDevicePicker object.
 */
declare class Windows$Media$DialProtocol$DialDisconnectButtonClickedEventArgs  {

/**
 * Gets the DialDevice object that represents the remote device that the user wants to disconnect.
 */
device: Windows$Media$DialProtocol$DialDevice
}


      declare var npm$namespace$Windows$Media$Editing: {
        
        
        MediaTrimmingPreference: typeof Windows$Media$Editing$MediaTrimmingPreference,
VideoFramePrecision: typeof Windows$Media$Editing$VideoFramePrecision,
        BackgroundAudioTrack: typeof Windows$Media$Editing$BackgroundAudioTrack,
EmbeddedAudioTrack: typeof Windows$Media$Editing$EmbeddedAudioTrack,
MediaClip: typeof Windows$Media$Editing$MediaClip,
MediaComposition: typeof Windows$Media$Editing$MediaComposition,
MediaOverlay: typeof Windows$Media$Editing$MediaOverlay,
MediaOverlayLayer: typeof Windows$Media$Editing$MediaOverlayLayer,
        
      }

/**
 * Represents a single audio track for accompanying a video clip.
 */
declare class Windows$Media$Editing$BackgroundAudioTrack  {

/**
 * Creates a background audio track object with audio content copied from an embedded audio track object.
 * @param embeddedAudioTrack An embedded audio track to use as the source audio for the background audio track.
 * @return A new background audio track object containing audio content copied from the embedded audio track.
 */
static createFromEmbeddedAudioTrack(
embeddedAudioTrack: Windows$Media$Editing$EmbeddedAudioTrack): Windows$Media$Editing$BackgroundAudioTrack;

/**
 * Creates a background audio track from an audio file.
 * @param file A StorageFile object representing the source audio file.
 * @return A new background audio track object containing the contents of the audio file.
 */
static createFromFileAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Editing$BackgroundAudioTrack>;

/**
 * Gets the list of audio effect definitions for processing the background audio track.
 */
audioEffectDefinitions: Windows$Foundation$Collections$IVector<Windows$Media$Effects$IAudioEffectDefinition>;

/**
 * Creates a BackgroundAudioTrack object that is identical to this instance.
 * @return A BackgroundAudioTrack object that is a copy of this instance.
 */
clone(): Windows$Media$Editing$BackgroundAudioTrack;

/**
 * Specifies how long to wait before starting background audio playback.
 */
delay: number;

/**
 * Gets the AudioEncodingProperties for the background audio track.
 * @return The AudioEncodingProperties for the background audio track.
 */
getAudioEncodingProperties(): Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Original playback time of the background audio track, without the effects of the TrimTimeFromStart and TrimTimeFromEnd properties.
 */
originalDuration: number;

/**
 * The amount of time to trim from the end of the background audio track.
 */
trimTimeFromEnd: number;

/**
 * The amount of time to trim from the beginning of the background audio track.
 */
trimTimeFromStart: number;

/**
 * Duration of the background audio track with TrimTimeFromStart and TrimTimeFromEnd applied to playback.
 */
trimmedDuration: number;

/**
 * An associative collection for storing custom properties associated with the background audio track.
 */
userData: Windows$Foundation$Collections$IMap<string, string>;

/**
 * Gets or sets the volume of the background audio track.
 */
volume: number
}


/**
 * Represents an audio track embedded in the media clip.
 */
declare class Windows$Media$Editing$EmbeddedAudioTrack  {

/**
 * Gets the AudioEncodingProperties for the embedded audio track.
 * @return The AudioEncodingProperties for the embedded audio track.
 */
getAudioEncodingProperties(): Windows$Media$MediaProperties$AudioEncodingProperties
}


/**
 * Represents a single media object.
 */
declare class Windows$Media$Editing$MediaClip  {

/**
 * Creates a solid color video clip that displays a single color for a specified length of time. Solid color video clips are typically used to create an explicit gap between video segments.
 * @param color The color to display in the video clip.
 * @param originalDuration How long to display the color in the video clip.
 * @return A new media clip object containing the color-based video clip.
 */
static createFromColor(
color: Windows$UI$Color,
originalDuration: number): Windows$Media$Editing$MediaClip;

/**
 * Creates a video clip from a video file.
 * @param file A StorageFile object representing the source video file.
 * @return A new media clip object containing a video clip of the video file.
 */
static createFromFileAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Editing$MediaClip>;

/**
 * Creates a video clip that displays a single image for a specified length of time.
 * @param file A StorageFile object representing the source image file.
 * @param originalDuration How long to display the image in the video clip.
 * @return A new media clip object containing the image-based video clip.
 */
static createFromImageFileAsync(
file: Windows$Storage$IStorageFile,
originalDuration: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Editing$MediaClip>;

/**
 * Creates a video clip from a Direct3D surface.
 * @param surface The Direct3D surface.
 * @param originalDuration The initial duration of the created video clip.
 * @return A new media clip object containing the video clip.
 */
static createFromSurface(
surface: Windows$Graphics$DirectX$Direct3D11$IDirect3DSurface,
originalDuration: number): Windows$Media$Editing$MediaClip;

/**
 * Gets the list of audio effect definitions for processing the media clip.
 */
audioEffectDefinitions: Windows$Foundation$Collections$IVector<Windows$Media$Effects$IAudioEffectDefinition>;

/**
 * Creates a MediaClip object that is identical to this instance.
 * @return A MediaClip object that is a copy of this instance.
 */
clone(): Windows$Media$Editing$MediaClip;

/**
 * The list of embedded audio tracks in this media clip.
 */
embeddedAudioTracks: Windows$Foundation$Collections$IVectorView<Windows$Media$Editing$EmbeddedAudioTrack>;

/**
 * The time when the media clip stops playing within a MediaComposition .
 */
endTimeInComposition: number;

/**
 * Gets the VideoEncodingProperties for the media clip.
 * @return The VideoEncodingProperties for the media clip.
 */
getVideoEncodingProperties(): Windows$Media$MediaProperties$VideoEncodingProperties;

/**
 * Original playback time of the media clip, without the effects of TrimTimeFromStart and TrimTimeFromEnd properties.
 */
originalDuration: number;

/**
 * The index of the audio track within the media clip that is used for playback.
 */
selectedEmbeddedAudioTrackIndex: number;

/**
 * The time when the media clip starts playing within a MediaComposition .
 */
startTimeInComposition: number;

/**
 * The amount of time to trim from the end of the media clip.
 */
trimTimeFromEnd: number;

/**
 * The amount of time to trim from the beginning of the media clip.
 */
trimTimeFromStart: number;

/**
 * Duration of the media clip with TrimTimeFromStart and TrimTimeFromEnd applied to playback.
 */
trimmedDuration: number;

/**
 * An associative collection for storing custom properties associated with the media clip.
 */
userData: Windows$Foundation$Collections$IMap<string, string>;

/**
 * Gets the list of video effect definitions for processing the media clip.
 */
videoEffectDefinitions: Windows$Foundation$Collections$IVector<Windows$Media$Effects$IVideoEffectDefinition>;

/**
 * Gets or sets the volume of the media clip.
 */
volume: number
}


/**
 * Represents a collection of media clips and background audio tracks.
 */
declare class Windows$Media$Editing$MediaComposition  {

/**
 * Asynchronously loads a MediaComposition from a StorageFile .
 * @param file The file from which to load the MediaComposition .
 * @return An async operation which can be used to track the success or failure of the operation.
 */
static loadAsync(
file: Windows$Storage$StorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Editing$MediaComposition>;

/**
 * Initializes a new instance of the MediaComposition class.
 */
constructor(): this;

/**
 * A collection of background audio tracks for playback in the media composition.
 */
backgroundAudioTracks: Windows$Foundation$Collections$IVector<Windows$Media$Editing$BackgroundAudioTrack>;

/**
 * A collection of media clips for playback in the media composition.
 */
clips: Windows$Foundation$Collections$IVector<Windows$Media$Editing$MediaClip>;

/**
 * Creates a MediaComposition object that is identical to this instance.
 * @return A MediaComposition object that is a copy of this instance.
 */
clone(): Windows$Media$Editing$MediaComposition;

/**
 * Create a new default media encoding profile which can be modified if necessary.
 * @return The newly created MediaEncodingProfile .
 */
createDefaultEncodingProfile(): Windows$Media$MediaProperties$MediaEncodingProfile;

/**
 * The total playback time of the media composition.
 */
duration: number;

/**
 * Creates a new MediaStreamSource using the specified MediaEncodingProfile .
 * @param encodingProfile The MediaEncodingProfile used to specify the encoding properties of the new MediaStreamSource .
 * @return The newly created MediaStreamSource .
 */
generateMediaStreamSource(
encodingProfile: Windows$Media$MediaProperties$MediaEncodingProfile): Windows$Media$Core$MediaStreamSource;

/**
 * Creates a new MediaStreamSource .
 * @return The newly created MediaStreamSource .
 */
generateMediaStreamSource(): Windows$Media$Core$MediaStreamSource;

/**
 * Creates a new MediaStreamSource used to preview the edited media.
 * @param scaledWidth The width of the preview media.
 * @param scaledHeight The height of the preview media.
 * @return The new MediaStreamSource used to preview the edited media.
 */
generatePreviewMediaStreamSource(
scaledWidth: number,
scaledHeight: number): Windows$Media$Core$MediaStreamSource;

/**
 * Asynchronously gets an image stream that represents a thumbnail of the media composition.
 * @param timeFromStart Specifies the point in the timeline of the MediaComposition from which to render the thumbnail, offset from the start of the MediaComposition.
 * @param scaledWidth Specifies the target width at which to render. The default is 0. scaledWidth and/or scaledHeight can be optional; see Remarks.
 * @param scaledHeight Specifies the target height at which to render. The default is 0. scaledWidth and/or scaledHeight can be optional; see Remarks.
 * @param framePrecision Specifies the frame precision algorithm to use when retrieving the thumbnail.
 * @return An image stream representing resulting thumbnail.
 */
getThumbnailAsync(
timeFromStart: number,
scaledWidth: number,
scaledHeight: number,
framePrecision: $Values<typeof Windows$Media$Editing$VideoFramePrecision>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$ImageStream>;

/**
 * Asynchronously gets a vector view of thumbnails of the media composition.
 * @param timesFromStart Specifies the points in the timeline of the MediaComposition from which to render the thumbnails, offset from the start of the MediaComposition.
 * @param scaledWidth Specifies the target width at which to render. The default is 0. scaledWidth and/or scaledHeight can be optional; see Remarks.
 * @param scaledHeight Specifies the target height at which to render. The default is 0. scaledWidth and/or scaledHeight can be optional; see Remarks.
 * @param framePrecision Specifies the frame precision algorithm to use when retrieving the thumbnails.
 * @return A vector view on the resulting thumbnails.
 */
getThumbnailsAsync(
timesFromStart: Windows$Foundation$Collections$IIterable<number>,
scaledWidth: number,
scaledHeight: number,
framePrecision: $Values<typeof Windows$Media$Editing$VideoFramePrecision>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the list of overlay layers for the media composition.
 */
overlayLayers: Windows$Foundation$Collections$IVector<Windows$Media$Editing$MediaOverlayLayer>;

/**
 * Asynchronously renders the MediaComposition to the specified file.
 * @param destination The file to which this MediaComposition is rendered.
 * @return An async operation which can be used to track the success or failure of the operation.
 */
renderToFileAsync(
destination: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<$Values<typeof Windows$Media$Transcoding$TranscodeFailureReason>, number>;

/**
 * Asynchronously renders the MediaComposition to a specified file using the indicated media trimming preference.
 * @param destination The file to which this MediaComposition is rendered.
 * @param trimmingPreference Specifies whether to be fast or precise when trimming the media.
 * @return An async operation which can be used to track the success or failure of the operation.
 */
renderToFileAsync(
destination: Windows$Storage$IStorageFile,
trimmingPreference: $Values<typeof Windows$Media$Editing$MediaTrimmingPreference>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<$Values<typeof Windows$Media$Transcoding$TranscodeFailureReason>, number>;

/**
 * Asynchronously renders the MediaComposition to a specified file using the indicated media trimming preference and encoding profile.
 * @param destination The file to which this MediaComposition is rendered.
 * @param trimmingPreference Specifies whether to be fast or precise when trimming the media.
 * @param encodingProfile Specifies the encoding profile to use for rendering the media.
 * @return An async operation which can be used to track the success or failure of the operation.
 */
renderToFileAsync(
destination: Windows$Storage$IStorageFile,
trimmingPreference: $Values<typeof Windows$Media$Editing$MediaTrimmingPreference>,
encodingProfile: Windows$Media$MediaProperties$MediaEncodingProfile): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<$Values<typeof Windows$Media$Transcoding$TranscodeFailureReason>, number>;

/**
 * Asynchronously serializes the MediaComposition to disk so that it can be loaded and modified in the future.
 * @param file The file to which the MediaComposition is saved.
 * @return An async action which can be used to track the success or failure of the operation.
 */
saveAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * An associative collection for storing custom properties associated with the media composition.
 */
userData: Windows$Foundation$Collections$IMap<string, string>
}


/**
 * Represents an overlay that can be used in a media composition.
 */
declare class Windows$Media$Editing$MediaOverlay  {

/**
 * Initializes a new instance of the MediaOverlay class.
 * @param clip The media clip to be used for the overlay.
 */
constructor(clip: Windows$Media$Editing$MediaClip): this;

/**
 * Initializes a new instance of the MediaOverlay class.
 * @param clip The media clip to be used for the overlay.
 * @param position The position of the overlay.
 * @param opacity The opacity of the overlay, in the range of 0.0 to 1.0, where 0.0 is completely transparent and 1.0 is completely opaque.
 */
constructor(clip: Windows$Media$Editing$MediaClip, position: Windows$Foundation$Rect, opacity: number): this;

/**
 * Gets or sets a value indicating whether audio is enabled for the MediaOverlay .
 */
audioEnabled: boolean;

/**
 * Gets the media clip to be used for the overlay.
 */
clip: Windows$Media$Editing$MediaClip;

/**
 * Creates a MediaOverlay object that is identical to this instance.
 * @return A MediaOverlay object that is a copy of this instance.
 */
clone(): Windows$Media$Editing$MediaOverlay;

/**
 * Gets or sets the time span from the start of the clip after which the media overlay should be rendered.
 */
delay: number;

/**
 * Gets the opacity of the overlay.
 */
opacity: number;

/**
 * Gets the position of the overlay.
 */
position: Windows$Foundation$Rect
}


/**
 * Represents a layer of a media overlay.
 */
declare class Windows$Media$Editing$MediaOverlayLayer  {

/**
 * Initializes a new instance of the MediaOverlayLayer class.
 */
constructor(): this;

/**
 * Initializes a new instance of the MediaOverlayLayer class.
 * @param compositorDefinition The definition of the custom compositor associated with the media overlay layer.
 */
constructor(compositorDefinition: Windows$Media$Effects$IVideoCompositorDefinition): this;

/**
 * Creates a MediaOverlayLayer object that is identical to this instance.
 * @return A MediaOverlayLayer object that is a copy of this instance.
 */
clone(): Windows$Media$Editing$MediaOverlayLayer;

/**
 * Gets the definition of the custom compositor associated with the media overlay layer, if there is one.
 */
customCompositorDefinition: Windows$Media$Effects$IVideoCompositorDefinition;

/**
 * Gets the list of overlays for this media overlay layer.
 */
overlays: Windows$Foundation$Collections$IVector<Windows$Media$Editing$MediaOverlay>
}


/**
 * Used to specify if media trimming should use a faster or a more precise algorithm during transcoding.
 */

declare  var Windows$Media$Editing$MediaTrimmingPreference: {|
  +fast: 0,// 0
+precise: 1,// 1

|};



/**
 * Used to specify the frame precision algorithm when retrieving a thumbnail.
 */

declare  var Windows$Media$Editing$VideoFramePrecision: {|
  +nearestFrame: 0,// 0
+nearestKeyFrame: 1,// 1

|};



      declare var npm$namespace$Windows$Media$Effects: {
        
        
        AudioEffectType: typeof Windows$Media$Effects$AudioEffectType,
MediaEffectClosedReason: typeof Windows$Media$Effects$MediaEffectClosedReason,
MediaMemoryTypes: typeof Windows$Media$Effects$MediaMemoryTypes,
        AudioCaptureEffectsManager: typeof Windows$Media$Effects$AudioCaptureEffectsManager,
AudioEffect: typeof Windows$Media$Effects$AudioEffect,
AudioEffectDefinition: typeof Windows$Media$Effects$AudioEffectDefinition,
AudioEffectsManager: typeof Windows$Media$Effects$AudioEffectsManager,
AudioRenderEffectsManager: typeof Windows$Media$Effects$AudioRenderEffectsManager,
CompositeVideoFrameContext: typeof Windows$Media$Effects$CompositeVideoFrameContext,
ProcessAudioFrameContext: typeof Windows$Media$Effects$ProcessAudioFrameContext,
ProcessVideoFrameContext: typeof Windows$Media$Effects$ProcessVideoFrameContext,
VideoCompositorDefinition: typeof Windows$Media$Effects$VideoCompositorDefinition,
VideoEffectDefinition: typeof Windows$Media$Effects$VideoEffectDefinition,
VideoTransformEffectDefinition: typeof Windows$Media$Effects$VideoTransformEffectDefinition,
        
      }

/**
 * Represent an audio capture effects manager which can be used to discover the audio processing chain on a device for a specific media category and audio processing mode.
 */
declare class Windows$Media$Effects$AudioCaptureEffectsManager  {

/**
 * Gets the list of audio effects on the device.
 * @return The list of audio effects.
 */
getAudioCaptureEffects(
): Windows$Foundation$Collections$IVectorView<Windows$Media$Effects$AudioEffect>;

/**
 * Occurs when audio process chain changes.
 */
onaudiocaptureeffectschanged: Windows$Foundation$TypedEventHandler<Windows$Media$Effects$AudioCaptureEffectsManager, any>;
addEventListener(
type: "audiocaptureeffectschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Effects$AudioCaptureEffectsManager, any>): void;
removeEventListener(
type: "audiocaptureeffectschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Effects$AudioCaptureEffectsManager, any>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents an audio effect.
 */
declare class Windows$Media$Effects$AudioEffect  {

/**
 * Gets the type of the audio effect.
 */
audioEffectType: $Values<typeof Windows$Media$Effects$AudioEffectType>
}


/**
 * Represents an audio effect definition.
 */
declare class Windows$Media$Effects$AudioEffectDefinition  {

/**
 * Creates a new AudioEffectDefinition object with the specified activatable class ID, configuring the object with the specified settings.
 * @param activatableClassId The activatable class ID of the audio effect definition.
 * @param props Configuration properties for the specified audio effect definition.
 */
constructor(activatableClassId: string, props: Windows$Foundation$Collections$IPropertySet): this;

/**
 * Creates a new AudioEffectDefinition object with the specified activatable class ID.
 * @param activatableClassId The activatable class ID of the audio effect definition.
 */
constructor(activatableClassId: string): this;

/**
 * The activatable class ID of the audio effect definition.
 */
activatableClassId: string;

/**
 * The set of properties for configuring an AudioEffectDefinition object.
 */
properties: Windows$Foundation$Collections$IPropertySet
}


/**
 * Defines values for audio effect types.
 */

declare  var Windows$Media$Effects$AudioEffectType: {|
  +other: 0,// 0
+acousticEchoCancellation: 1,// 1
+noiseSuppression: 2,// 2
+automaticGainControl: 3,// 3
+beamForming: 4,// 4
+constantToneRemoval: 5,// 5
+equalizer: 6,// 6
+loudnessEqualizer: 7,// 7
+bassBoost: 8,// 8
+virtualSurround: 9,// 9
+virtualHeadphones: 10,// 10
+speakerFill: 11,// 11
+roomCorrection: 12,// 12
+bassManagement: 13,// 13
+environmentalEffects: 14,// 14
+speakerProtection: 15,// 15
+speakerCompensation: 16,// 16
+dynamicRangeCompression: 17,// 17

|};



/**
 * Provides functionality for creating audio capture and render effects manager objects.
 */
declare class Windows$Media$Effects$AudioEffectsManager  {

/**
 * Creates a AudioCaptureEffectsManager object for the specified device for a specific media category.
 * @param deviceId The device id.
 * @param category The media category.
 * @return The new audio capture effects manager.
 */
static createAudioCaptureEffectsManager(
deviceId: string,
category: $Values<typeof Windows$Media$Capture$MediaCategory>): Windows$Media$Effects$AudioCaptureEffectsManager;

/**
 * Creates a AudioCaptureEffectsManager object for the specified device for a specific media category and audio processing mode.
 * @param deviceId The device id.
 * @param category The media category.
 * @param mode The audio processing mode.
 * @return The new audio capture effects manager.
 */
static createAudioCaptureEffectsManager(
deviceId: string,
category: $Values<typeof Windows$Media$Capture$MediaCategory>,
mode: $Values<typeof Windows$Media$AudioProcessing>): Windows$Media$Effects$AudioCaptureEffectsManager;

/**
 * Creates a AudioRenderEffectsManager object for the specified device for a specific media category.
 * @param deviceId The device id.
 * @param category The audio render category.
 * @param mode The audio precessing mode.
 * @return The new audio render effects manager.
 */
static createAudioRenderEffectsManager(
deviceId: string,
category: $Values<typeof Windows$Media$Render$AudioRenderCategory>,
mode: $Values<typeof Windows$Media$AudioProcessing>): Windows$Media$Effects$AudioRenderEffectsManager;

/**
 * Creates a AudioRenderEffectsManager object for the specified device for a specific media category and audio processing mode.
 * @param deviceId The device id.
 * @param category The audio render category.
 * @return The new audio render effects manager.
 */
static createAudioRenderEffectsManager(
deviceId: string,
category: $Values<typeof Windows$Media$Render$AudioRenderCategory>): Windows$Media$Effects$AudioRenderEffectsManager
}


/**
 * Represent an audio render effects manager which can be used to discover the audio processing chain on a device for a specific media category and audio processing mode.
 */
declare class Windows$Media$Effects$AudioRenderEffectsManager  {

/**
 * Gets the label that is associated with this audio effects provider setting.
 */
effectsProviderSettingsLabel: string;

/**
 * Gets the thumbnail image that is associated with this audio effects provider.
 */
effectsProviderThumbnail: Windows$Storage$Streams$IRandomAccessStreamWithContentType;

/**
 * Gets the list of audio effects on the device.
 * @return The list of audio effects.
 */
getAudioRenderEffects(
): Windows$Foundation$Collections$IVectorView<Windows$Media$Effects$AudioEffect>;

/**
 * Occurs when audio process chain changes.
 */
onaudiorendereffectschanged: Windows$Foundation$TypedEventHandler<Windows$Media$Effects$AudioRenderEffectsManager, any>;
addEventListener(
type: "audiorendereffectschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Effects$AudioRenderEffectsManager, any>): void;
removeEventListener(
type: "audiorendereffectschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Effects$AudioRenderEffectsManager, any>): void;

/**
 * Displays the audio effect settings page.
 */
showSettingsUI(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides context for performing a custom overlay operation within the CompositeFrame method.
 */
declare class Windows$Media$Effects$CompositeVideoFrameContext  {

/**
 * Gets the background frame for an overlay operation.
 */
backgroundFrame: Windows$Media$VideoFrame;

/**
 * Gets a MediaOverlay object for the provided Direct3D surface.
 * @param surfaceToOverlay The Direct3D surface.
 * @return The created MediaOverlay object.
 */
getOverlayForSurface(
surfaceToOverlay: Windows$Graphics$DirectX$Direct3D11$IDirect3DSurface): Windows$Media$Editing$MediaOverlay;

/**
 * Gets the output frame for an overlay operation.
 */
outputFrame: Windows$Media$VideoFrame;

/**
 * Gets the list of Direct3D surfaces to be used in an overlay operation.
 */
surfacesToOverlay: Windows$Foundation$Collections$IVectorView<Windows$Graphics$DirectX$Direct3D11$IDirect3DSurface>
}


/**
 * Specifies the reason why a media effect was closed.
 */

declare  var Windows$Media$Effects$MediaEffectClosedReason: {|
  +done: 0,// 0
+unknownError: 1,// 1
+unsupportedEncodingFormat: 2,// 2
+effectCurrentlyUnloaded: 3,// 3

|};



/**
 * Specifies the types of memory that can be used for a media operation.
 */

declare  var Windows$Media$Effects$MediaMemoryTypes: {|
  +gpu: 0,// 0
+cpu: 1,// 1
+gpuAndCpu: 2,// 2

|};



/**
 * Provides context for performing a custom audio effect operation within the ProcessFrame method.
 */
declare class Windows$Media$Effects$ProcessAudioFrameContext  {

/**
 * Gets the input frame for an audio effect operation.
 */
inputFrame: Windows$Media$AudioFrame;

/**
 * Gets the output frame for an audio effect operation.
 */
outputFrame: Windows$Media$AudioFrame
}


/**
 * Provides context for performing a custom video effect operation within the ProcessFrame method.
 */
declare class Windows$Media$Effects$ProcessVideoFrameContext  {

/**
 * Gets the input frame for a video effect operation.
 */
inputFrame: Windows$Media$VideoFrame;

/**
 * Gets the output frame for a video effect operation.
 */
outputFrame: Windows$Media$VideoFrame
}


/**
 * Represents the definition of a custom video compositor.
 */
declare class Windows$Media$Effects$VideoCompositorDefinition  {

/**
 * Initializes a new instance of the VideoCompositorDefinition class.
 * @param activatableClassId The activatable class ID of the video compositor.
 * @param props The set of properties for configuring the video compositor object.
 */
constructor(activatableClassId: string, props: Windows$Foundation$Collections$IPropertySet): this;

/**
 * Initializes a new instance of the VideoCompositorDefinition class.
 * @param activatableClassId The activatable class ID of the video compositor.
 */
constructor(activatableClassId: string): this;

/**
 * Gets the activatable class ID of the video compositor.
 */
activatableClassId: string;

/**
 * Gets the set of properties for configuring the video compositor object.
 */
properties: Windows$Foundation$Collections$IPropertySet
}


/**
 * Represents a video effect definition.
 */
declare class Windows$Media$Effects$VideoEffectDefinition  {

/**
 * Creates a new VideoEffectDefinition object with the specified activatable class ID, configuring the object with the specified settings.
 * @param activatableClassId The activatable class ID of the video effect definition.
 * @param props Configuration properties for the specified video effect definition.
 */
constructor(activatableClassId: string, props: Windows$Foundation$Collections$IPropertySet): this;

/**
 * Creates a new VideoEffectDefinition object with the specified activatable class ID.
 * @param activatableClassId The activatable class ID of the video effect definition.
 */
constructor(activatableClassId: string): this;

/**
 * Gets the activatable class ID of the video effect definition.
 */
activatableClassId: string;

/**
 * Gets the set of properties for configuring the VideoEffectDefinition object.
 */
properties: Windows$Foundation$Collections$IPropertySet
}


/**
 * Represents the definition of a video transform effect.
 */
declare class Windows$Media$Effects$VideoTransformEffectDefinition  {

/**
 * Initializes a new instance of the VideoTransformEffectDefinition class.
 */
constructor(): this;

/**
 * Gets the activatable class ID of the video transform effect definition.
 */
activatableClassId: string;

/**
 * Gets or sets the rectangle within which the video will be cropped, specified in pixels.
 */
cropRectangle: Windows$Foundation$Rect;

/**
 * Gets or sets the direction in which the video will be mirrored.
 */
mirror: $Values<typeof Windows$Media$MediaProperties$MediaMirroringOptions>;

/**
 * Gets or sets the output size of the video, in pixels.
 */
outputSize: Windows$Foundation$Size;

/**
 * Gets or sets the color that will be used to fill pixels in the frame that are not filled with video, such as when video is letterboxed.
 */
paddingColor: Windows$UI$Color;

/**
 * Gets or sets the media processing algorithm that is used for the video transform.
 */
processingAlgorithm: $Values<typeof Windows$Media$Transcoding$MediaVideoProcessingAlgorithm>;

/**
 * Gets the set of properties for configuring the VideoTransformEffectDefinition object.
 */
properties: Windows$Foundation$Collections$IPropertySet;

/**
 * Gets or sets the angle and direction in which the video will be rotated.
 */
rotation: $Values<typeof Windows$Media$MediaProperties$MediaRotation>
}


/**
 * Exposes the methods and properties of an AudioEffectDefinition object. Implement this interface when you create a custom audio effect definition.
 */
declare interface Windows$Media$Effects$IAudioEffectDefinition {

/**
 * The activatable class ID of the audio effect definition.
 */
activatableClassId: string,

/**
 * The set of properties for configuring an AudioEffectDefinition object.
 */
properties: Windows$Foundation$Collections$IPropertySet
} 


/**
 * Exposes the methods and properties of a VideoEffectDefinition object. Implement this interface when you create a custom video effect definition.
 */
declare interface Windows$Media$Effects$IVideoEffectDefinition {

/**
 * The activatable class ID of the video effect definition.
 */
activatableClassId: string,

/**
 * The set of properties for configuring the VideoEffectDefinition object.
 */
properties: Windows$Foundation$Collections$IPropertySet
} 


/**
 * The interface defining a custom video compositor definition.
 */
declare interface Windows$Media$Effects$IVideoCompositorDefinition {

/**
 * Gets the activatable class ID of the video compositor.
 */
activatableClassId: string,

/**
 * Gets the set of properties for configuring the video compositor object.
 */
properties: Windows$Foundation$Collections$IPropertySet
} 


      declare var npm$namespace$Windows$Media$FaceAnalysis: {
        
        
        
        DetectedFace: typeof Windows$Media$FaceAnalysis$DetectedFace,
FaceDetector: typeof Windows$Media$FaceAnalysis$FaceDetector,
FaceTracker: typeof Windows$Media$FaceAnalysis$FaceTracker,
        
      }

/**
 * Represents a face that was detected in a SoftwareBitmap or a VideoFrame .
 */
declare class Windows$Media$FaceAnalysis$DetectedFace  {

/**
 * Gets the bounds the detected face occupies in the SoftwareBitmap or VideoFrame .
 */
faceBox: Windows$Graphics$Imaging$BitmapBounds
}


/**
 * Detects faces in a SoftwareBitmap .
 */
declare class Windows$Media$FaceAnalysis$FaceDetector  {

/**
 * Creates a new instance of the FaceDetector class.
 * @return An asynchronous operation that returns a FaceDetector instance upon successful completion.
 */
static createAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$FaceAnalysis$FaceDetector>;

/**
 * Returns a list of the bitmap pixels formats supported by the FaceDetector on the current device.
 * @return A list of the bitmap pixels formats supported by the FaceDetector on the current device.
 */
static getSupportedBitmapPixelFormats(
): Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>>;

/**
 * Queries whether the specified bitmap pixel format is supported by the FaceDetector on the current device.
 * @param bitmapPixelFormat The bitmap pixel format for which support is queried.
 * @return True if the specified bitmap pixel format is supported; otherwise, false.
 */
static isBitmapPixelFormatSupported(
bitmapPixelFormat: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>): boolean;

/**
 * Gets a value indicating whether the FaceDetector class is supported on the current device.
 */
static isSupported: boolean;

/**
 * Asynchronously detects faces in the provided SoftwareBitmap .
 * @param image The image data to be processed for face detection.
 * @return An asynchronous operation that returns a list of DetectedFace objects upon successful completion.
 */
detectFacesAsync(
image: Windows$Graphics$Imaging$SoftwareBitmap): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVector<any>>;

/**
 * Asynchronously detects faces in the provided SoftwareBitmap within the specified search area.
 * @param image The image data to be processed for face detection.
 * @param searchArea The bounds within the SoftwareBitmap in which face detection will be performed.
 * @return An asynchronous operation that returns a list of DetectedFace objects upon successful completion.
 */
detectFacesAsync(
image: Windows$Graphics$Imaging$SoftwareBitmap,
searchArea: Windows$Graphics$Imaging$BitmapBounds): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVector<any>>;

/**
 * Gets or sets the maximum detectable face size, in pixels.
 */
maxDetectableFaceSize: Windows$Graphics$Imaging$BitmapSize;

/**
 * Gets or sets the minimum detectable face size, in pixels.
 */
minDetectableFaceSize: Windows$Graphics$Imaging$BitmapSize
}


/**
 * Detects faces in VideoFrame objects and tracks faces across subsequent video frames.
 */
declare class Windows$Media$FaceAnalysis$FaceTracker  {

/**
 * Creates a new instance of the FaceTracker class.
 * @return An asynchronous operation that returns a FaceTracker instance upon successful completion.
 */
static createAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$FaceAnalysis$FaceTracker>;

/**
 * Returns a list of the bitmap pixels formats supported by the FaceTracker on the current device.
 * @return A list of the bitmap pixels formats supported by the FaceTracker on the current device.
 */
static getSupportedBitmapPixelFormats(
): Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>>;

/**
 * Queries whether the specified bitmap pixel format is supported by the FaceTracker on the current device.
 * @param bitmapPixelFormat The bitmap pixel format for which support is queried.
 * @return True if the specified bitmap pixel format is supported; otherwise, false.
 */
static isBitmapPixelFormatSupported(
bitmapPixelFormat: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>): boolean;

/**
 * Gets a value indicating whether the FaceTracker class is supported on the current device.
 */
static isSupported: boolean;

/**
 * Gets or sets the maximum detectable face size, in pixels.
 */
maxDetectableFaceSize: Windows$Graphics$Imaging$BitmapSize;

/**
 * Gets or sets the minimum detectable face size, in pixels.
 */
minDetectableFaceSize: Windows$Graphics$Imaging$BitmapSize;

/**
 * Asynchronously processes a VideoFrame for face detection.
 * @param videoFrame The VideoFrame in which faces are detected or tracked.
 * @return An asynchronous operation that returns a list of DetectedFace objects upon successful completion.
 */
processNextFrameAsync(
videoFrame: Windows$Media$VideoFrame): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVector<any>>
}


/**
 * Provides properties for image information that is displayed by SystemMediaTransportControlsDisplayUpdater class.
 */
declare class Windows$Media$ImageDisplayProperties  {

/**
 * Gets or sets the subtitle of the image.
 */
subtitle: string;

/**
 * Gets or sets the title of the image.
 */
title: string
}


      declare var npm$namespace$Windows$Media$Import: {
        
        
        PhotoImportAccessMode: typeof Windows$Media$Import$PhotoImportAccessMode,
PhotoImportConnectionTransport: typeof Windows$Media$Import$PhotoImportConnectionTransport,
PhotoImportContentType: typeof Windows$Media$Import$PhotoImportContentType,
PhotoImportContentTypeFilter: typeof Windows$Media$Import$PhotoImportContentTypeFilter,
PhotoImportImportMode: typeof Windows$Media$Import$PhotoImportImportMode,
PhotoImportItemSelectionMode: typeof Windows$Media$Import$PhotoImportItemSelectionMode,
PhotoImportPowerSource: typeof Windows$Media$Import$PhotoImportPowerSource,
PhotoImportSourceType: typeof Windows$Media$Import$PhotoImportSourceType,
PhotoImportStage: typeof Windows$Media$Import$PhotoImportStage,
PhotoImportStorageMediumType: typeof Windows$Media$Import$PhotoImportStorageMediumType,
PhotoImportSubfolderCreationMode: typeof Windows$Media$Import$PhotoImportSubfolderCreationMode,
        PhotoImportDeleteImportedItemsFromSourceResult: typeof Windows$Media$Import$PhotoImportDeleteImportedItemsFromSourceResult,
PhotoImportFindItemsResult: typeof Windows$Media$Import$PhotoImportFindItemsResult,
PhotoImportImportItemsResult: typeof Windows$Media$Import$PhotoImportImportItemsResult,
PhotoImportItem: typeof Windows$Media$Import$PhotoImportItem,
PhotoImportItemImportedEventArgs: typeof Windows$Media$Import$PhotoImportItemImportedEventArgs,
PhotoImportManager: typeof Windows$Media$Import$PhotoImportManager,
PhotoImportOperation: typeof Windows$Media$Import$PhotoImportOperation,
PhotoImportSelectionChangedEventArgs: typeof Windows$Media$Import$PhotoImportSelectionChangedEventArgs,
PhotoImportSession: typeof Windows$Media$Import$PhotoImportSession,
PhotoImportSidecar: typeof Windows$Media$Import$PhotoImportSidecar,
PhotoImportSource: typeof Windows$Media$Import$PhotoImportSource,
PhotoImportStorageMedium: typeof Windows$Media$Import$PhotoImportStorageMedium,
PhotoImportVideoSegment: typeof Windows$Media$Import$PhotoImportVideoSegment,
        
      }

/**
 * Specifies the access mode with which photos are imported.
 */

declare  var Windows$Media$Import$PhotoImportAccessMode: {|
  +readWrite: 0,// 0
+readOnly: 1,// 1
+readAndDelete: 2,// 2

|};



/**
 * Specifies the connection transport used for photo import.
 */

declare  var Windows$Media$Import$PhotoImportConnectionTransport: {|
  +unknown: 0,// 0
+usb: 1,// 1
+ip: 2,// 2
+bluetooth: 3,// 3

|};



/**
 * Specifies the content type of an imported item.
 */

declare  var Windows$Media$Import$PhotoImportContentType: {|
  +unknown: 0,// 0
+image: 1,// 1
+video: 2,// 2

|};



/**
 * Specifies the content types that are included in a photo import operation.
 */

declare  var Windows$Media$Import$PhotoImportContentTypeFilter: {|
  +onlyImages: 0,// 0
+onlyVideos: 1,// 1
+imagesAndVideos: 2,// 2

|};



/**
 * Represents the result of a operation that deletes imported media items from the source.
 */
declare class Windows$Media$Import$PhotoImportDeleteImportedItemsFromSourceResult  {

/**
 * Gets a list of items that were deleted from the source.
 */
deletedItems: Windows$Foundation$Collections$IVectorView<Windows$Media$Import$PhotoImportItem>;

/**
 * Gets a value indicating whether the delete operation has succeeded.
 */
hasSucceeded: boolean;

/**
 * Gets the number of photos deleted in the operation.
 */
photosCount: number;

/**
 * Gets the size of the deleted photos, in bytes.
 */
photosSizeInBytes: number;

/**
 * Gets the photo import session associated with the delete operation.
 */
session: Windows$Media$Import$PhotoImportSession;

/**
 * Gets the number of sibling files deleted in the operation.
 */
siblingsCount: number;

/**
 * Gets the size of the deleted sibling files, in bytes.
 */
siblingsSizeInBytes: number;

/**
 * Gets the number of sidecar files deleted in the operation.
 */
sidecarsCount: number;

/**
 * Gets the size of the deleted sidecar files, in bytes.
 */
sidecarsSizeInBytes: number;

/**
 * Gets the total number of items deleted in the operation.
 */
totalCount: number;

/**
 * Gets the total size of the all deleted items, in bytes.
 */
totalSizeInBytes: number;

/**
 * Gets the number of videos deleted in the operation.
 */
videosCount: number;

/**
 * Gets the size of the deleted videos, in bytes.
 */
videosSizeInBytes: number
}


/**
 * Represents the result of a operation that finds media items on a source.
 */
declare class Windows$Media$Import$PhotoImportFindItemsResult  {

/**
 * Gets a list of items that were found on the source.
 */
foundItems: Windows$Foundation$Collections$IVectorView<Windows$Media$Import$PhotoImportItem>;

/**
 * Gets a value indicating whether the find operation has succeeded.
 */
hasSucceeded: boolean;

/**
 * Asynchronously imports the selected items from the source.
 * @return An asynchronous operation that returns a PhotoImportImportItemsResult on successful completion.
 */
importItemsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Media$Import$PhotoImportImportItemsResult, Windows$Media$Import$PhotoImportProgress>;

/**
 * Gets the photo import mode that determines which types of files are included in the ImportItemsAsync operation.
 */
importMode: $Values<typeof Windows$Media$Import$PhotoImportImportMode>;

/**
 * Occurs when an item is imported.
 */
onitemimported: Windows$Foundation$TypedEventHandler<Windows$Media$Import$PhotoImportFindItemsResult, Windows$Media$Import$PhotoImportItemImportedEventArgs>;
addEventListener(
type: "itemimported",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Import$PhotoImportFindItemsResult, Windows$Media$Import$PhotoImportItemImportedEventArgs>): void;
removeEventListener(
type: "itemimported",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Import$PhotoImportFindItemsResult, Windows$Media$Import$PhotoImportItemImportedEventArgs>): void;

/**
 * Occurs when the set of items selected to be included in the ImportItemsAsync operation changes.
 */
onselectionchanged: Windows$Foundation$TypedEventHandler<Windows$Media$Import$PhotoImportFindItemsResult, Windows$Media$Import$PhotoImportSelectionChangedEventArgs>;
addEventListener(
type: "selectionchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Import$PhotoImportFindItemsResult, Windows$Media$Import$PhotoImportSelectionChangedEventArgs>): void;
removeEventListener(
type: "selectionchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Import$PhotoImportFindItemsResult, Windows$Media$Import$PhotoImportSelectionChangedEventArgs>): void;

/**
 * Gets the number of photos found on the source.
 */
photosCount: number;

/**
 * Gets the size of the photos found on the source, in bytes.
 */
photosSizeInBytes: number;

/**
 * Selects all items found on the source to be included in the ImportItemsAsync operation.
 */
selectAll(): void;

/**
 * Selects all new items found on the source to be included in the ImportItemsAsync operation.
 * @return An asynchronous operation.
 */
selectNewAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Deselects all items found on the source, preventing them from being included in the ImportItemsAsync operation.
 */
selectNone(): void;

/**
 * Gets the number of photos that are currently selected to be included in the ImportItemsAsync operation.
 */
selectedPhotosCount: number;

/**
 * Gets the size of the photos that are currently selected to be included in the ImportItemsAsync operation, in bytes.
 */
selectedPhotosSizeInBytes: number;

/**
 * Gets the number of sibling files that are currently selected to be included in the ImportItemsAsync operation.
 */
selectedSiblingsCount: number;

/**
 * Gets the size of the sibling files that are currently selected to be included in the ImportItemsAsync operation, in bytes.
 */
selectedSiblingsSizeInBytes: number;

/**
 * Gets the number of sidecar files that are currently selected to be included in the ImportItemsAsync operation.
 */
selectedSidecarsCount: number;

/**
 * Gets the size of the sidecar files that are currently selected to be included in the ImportItemsAsync operation, in bytes.
 */
selectedSidecarsSizeInBytes: number;

/**
 * Gets the total number of items that are currently selected to be included in the ImportItemsAsync operation.
 */
selectedTotalCount: number;

/**
 * Gets the total size of the all items that are currently selected to be included in the ImportItemsAsync operation, in bytes.
 */
selectedTotalSizeInBytes: number;

/**
 * Gets the number of videos that are currently selected to be included in the ImportItemsAsync operation.
 */
selectedVideosCount: number;

/**
 * Gets the size of the videos that are currently selected to be included in the ImportItemsAsync operation, in bytes.
 */
selectedVideosSizeInBytes: number;

/**
 * Gets the photo import session associated with the find operation.
 */
session: Windows$Media$Import$PhotoImportSession;

/**
 * Sets the photo import mode that determines which types of files are included in the ImportItemsAsync operation.
 * @param value The photo import mode.
 */
setImportMode(value: $Values<typeof Windows$Media$Import$PhotoImportImportMode>): void;

/**
 * Gets the number of sibling files found on the source.
 */
siblingsCount: number;

/**
 * Gets the size of the found sibling files, in bytes.
 */
siblingsSizeInBytes: number;

/**
 * Gets the number of sidecar files found on the source.
 */
sidecarsCount: number;

/**
 * Gets the size of the found sidecar files, in bytes.
 */
sidecarsSizeInBytes: number;

/**
 * Gets the total number of items found on the source.
 */
totalCount: number;

/**
 * Gets the total size of all items found on the source, in bytes.
 */
totalSizeInBytes: number;

/**
 * Gets the number of videos found on the source.
 */
videosCount: number;

/**
 * Gets the size of the videos found on the source, in bytes.
 */
videosSizeInBytes: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the result of a operation that imports media items from the source.
 */
declare class Windows$Media$Import$PhotoImportImportItemsResult  {

/**
 * Asynchronously deletes the items that were imported from the source.
 * @return An asynchronous operation that returns a PhotoImportDeleteImportedItemsFromSourceResult on successful completion.
 */
deleteImportedItemsFromSourceAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Media$Import$PhotoImportDeleteImportedItemsFromSourceResult, number>;

/**
 * Gets a value indicating whether the import operation has succeeded.
 */
hasSucceeded: boolean;

/**
 * Gets a list of items that were imported from the source.
 */
importedItems: Windows$Foundation$Collections$IVectorView<Windows$Media$Import$PhotoImportItem>;

/**
 * Gets the number of photos imported in the operation.
 */
photosCount: number;

/**
 * Gets the size of the imported photos, in bytes.
 */
photosSizeInBytes: number;

/**
 * Gets the photo import session associated with the import operation.
 */
session: Windows$Media$Import$PhotoImportSession;

/**
 * Gets the number of sibling files imported in the operation.
 */
siblingsCount: number;

/**
 * Gets the size of the imported sidecar files, in bytes.
 */
siblingsSizeInBytes: number;

/**
 * Gets the number of sidecar files imported in the operation.
 */
sidecarsCount: number;

/**
 * Gets the size of the imported sidecar files, in bytes.
 */
sidecarsSizeInBytes: number;

/**
 * Gets the total number of items imported in the operation.
 */
totalCount: number;

/**
 * Gets the total size of the all imported items, in bytes.
 */
totalSizeInBytes: number;

/**
 * Gets the number of videos imported in the operation.
 */
videosCount: number;

/**
 * Gets the size of the imported videos, in bytes.
 */
videosSizeInBytes: number
}


/**
 * Specifies the types of files that are included in an import operation.
 */

declare  var Windows$Media$Import$PhotoImportImportMode: {|
  +importEverything: 0,// 0
+ignoreSidecars: 1,// 1
+ignoreSiblings: 2,// 2
+ignoreSidecarsAndSiblings: 3,// 3

|};



/**
 * Represents an media item that has been imported from a source.
 */
declare class Windows$Media$Import$PhotoImportItem  {

/**
 * Gets the content type of the imported item.
 */
contentType: $Values<typeof Windows$Media$Import$PhotoImportContentType>;

/**
 * Gets the creation date of the imported item.
 */
date: Date;

/**
 * Gets a list of the names of files associated with this item that were deleted.
 */
deletedFileNames: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets a list of the names of files associated with this item that were imported.
 */
importedFileNames: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets a value indicating whether the item is currently selected for import.
 */
isSelected: boolean;

/**
 * Gets the key used to identify the item.
 */
itemKey: number;

/**
 * Gets the name of the item.
 */
name: string;

/**
 * Gets the sibling file associated with the item, if one exists.
 */
sibling: Windows$Media$Import$PhotoImportSidecar;

/**
 * Gets the list of sidecar files associated with the item, if any exists.
 */
sidecars: Windows$Foundation$Collections$IVectorView<Windows$Media$Import$PhotoImportSidecar>;

/**
 * Gets the size of the item, in bytes.
 */
sizeInBytes: number;

/**
 * Gets a random access stream containing the thumbnail image associated with the item.
 */
thumbnail: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets the list of video segments associated with the item.
 */
videoSegments: Windows$Foundation$Collections$IVectorView<Windows$Media$Import$PhotoImportVideoSegment>
}


/**
 * Provides data for the PhotoImportFindItemsResult::ItemImported event.
 */
declare class Windows$Media$Import$PhotoImportItemImportedEventArgs  {

/**
 * Gets the imported item associated with the PhotoImportFindItemsResult::ItemImported event.
 */
importedItem: Windows$Media$Import$PhotoImportItem
}


/**
 * Specifies the initial selection state for items that are discovered using PhotoImportSession::FindItemsAsync .
 */

declare  var Windows$Media$Import$PhotoImportItemSelectionMode: {|
  +selectAll: 0,// 0
+selectNone: 1,// 1
+selectNew: 2,// 2

|};



/**
 * Provides APIs for determining if photo import is supported on the current device, finding sources from which to import photos, and getting references to any pending photo import operations.
 */
declare class Windows$Media$Import$PhotoImportManager  {

/**
 * Finds all currently available sources from which photos can be imported.
 * @return An asynchronous operation that returns a list of available sources on successful completion.
 */
static findAllSourcesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the list of all pending photo import operations.
 * @return The list of all pending photo operations.
 */
static getPendingOperations(
): Windows$Foundation$Collections$IVectorView<Windows$Media$Import$PhotoImportOperation>;

/**
 * Gets a value indicating if photo import is supported on the current device.
 * @return An asynchronous operation that returns true if photo import is supported. Otherwise, returns false.
 */
static isSupportedAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>
}


/**
 * Represents an in-progress photo import operation.
 */
declare class Windows$Media$Import$PhotoImportOperation  {

/**
 * Causes in-progress delete from source operations to continue.
 */
continueDeletingImportedItemsFromSourceAsync: Windows$Foundation$IAsyncOperationWithProgress<Windows$Media$Import$PhotoImportDeleteImportedItemsFromSourceResult, number>;

/**
 * Causes in-progress find operations to continue.
 */
continueFindingItemsAsync: Windows$Foundation$IAsyncOperationWithProgress<Windows$Media$Import$PhotoImportFindItemsResult, number>;

/**
 * Causes in-progress import items operations to continue.
 */
continueImportingItemsAsync: Windows$Foundation$IAsyncOperationWithProgress<Windows$Media$Import$PhotoImportImportItemsResult, Windows$Media$Import$PhotoImportProgress>;

/**
 * Gets the photo import session associated with the operation.
 */
session: Windows$Media$Import$PhotoImportSession;

/**
 * Gets the current stage of the in-progress operation.
 */
stage: $Values<typeof Windows$Media$Import$PhotoImportStage>
}


/**
 * Specifies the current power source of the source device containing items to be imported.
 */

declare  var Windows$Media$Import$PhotoImportPowerSource: {|
  +unknown: 0,// 0
+battery: 1,// 1
+external: 2,// 2

|};



/**
 * Provides data for the PhotoImportFindItemsResult::SelectionChanged event.
 */
declare class Windows$Media$Import$PhotoImportSelectionChangedEventArgs  {

/**
 * Gets a value indicating whether no items are selected after the selection has changed.
 */
isSelectionEmpty: boolean
}


/**
 * Represents a photo import session with a photo import source.
 */
declare class Windows$Media$Import$PhotoImportSession  {

/**
 * Gets or sets a value specifying whether the session date should be appended to the destination folder name.
 */
appendSessionDateToDestinationFolder: boolean;

/**
 * Closes the photo import session and releases associated resources.
 */
close(): void;

/**
 * Gets or sets the prefix for the destination file name.
 */
destinationFileNamePrefix: string;

/**
 * Gets or sets the destination folder for the photo import session.
 */
destinationFolder: Windows$Storage$IStorageFolder;

/**
 * Asynchronously finds items on the source device that are available for import.
 * @param contentTypeFilter A value indicating whether the find operation includes images, videos, or both in the results.
 * @param itemSelectionMode A value indicating whether all items, no items, or only new items in the results are initially marked as selected.
 * @return An asynchronous operation that returns a PhotoImportFindItemsResult on successful completion.
 */
findItemsAsync(
contentTypeFilter: $Values<typeof Windows$Media$Import$PhotoImportContentTypeFilter>,
itemSelectionMode: $Values<typeof Windows$Media$Import$PhotoImportItemSelectionMode>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Media$Import$PhotoImportFindItemsResult, number>;

/**
 * Gets a unique identifier for the import session.
 */
sessionId: string;

/**
 * Gets an object representing the source device associated with the photo import session.
 */
source: Windows$Media$Import$PhotoImportSource;

/**
 * Gets or sets a value indicating the method used for naming subfolders within the destination folder.
 */
subfolderCreationMode: $Values<typeof Windows$Media$Import$PhotoImportSubfolderCreationMode>
}


/**
 * Represents a sidecar file or a sibling file to a PhotoImportItem .
 */
declare class Windows$Media$Import$PhotoImportSidecar  {

/**
 * Gets the date of the sidecar or sibling file.
 */
date: Date;

/**
 * Gets the name of the sidecar or sibling file.
 */
name: string;

/**
 * Gets the size of the sidecar or sibling file, in bytes.
 */
sizeInBytes: number
}


/**
 * Represents the source device for a photo import session.
 */
declare class Windows$Media$Import$PhotoImportSource  {

/**
 * Creates a new instance of PhotoImportSource from the specified root folder.
 * @param sourceRootFolder The root folder from which the photo import source is created.
 * @return An asynchronous operation that returns a PhotoImportSource upon successful completion.
 */
static fromFolderAsync(
sourceRootFolder: Windows$Storage$IStorageFolder): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Import$PhotoImportSource>;

/**
 * Creates a new instance of PhotoImportSource from the specified device ID.
 * @param sourceId The root folder from which the photo import source is created.
 * @return An asynchronous operation that returns a PhotoImportSource upon successful completion.
 */
static fromIdAsync(
sourceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Import$PhotoImportSource>;

/**
 * The battery level of the source device.
 */
batteryLevelPercent: number;

/**
 * Gets the connection protocol that is being used to communicate with the source device.
 */
connectionProtocol: string;

/**
 * Gets a value indicating the transport mechanism that is being used for importing items from the source device.
 */
connectionTransport: $Values<typeof Windows$Media$Import$PhotoImportConnectionTransport>;

/**
 * Creates a new photo import session.
 * @return The new PhotoImportSession object.
 */
createImportSession(): Windows$Media$Import$PhotoImportSession;

/**
 * Gets the current date and time on the device.
 */
dateTime: Date;

/**
 * Gets a human-readable description of the source device.
 */
description: string;

/**
 * Gets the human-readable display name for the source device.
 */
displayName: string;

/**
 * Gets a unique 16-byte identifier that is common across multiple transports supported by the device.
 */
id: string;

/**
 * Gets a value indicating if the source device is locked.
 */
isLocked: boolean;

/**
 * Gets a value indicating if the source device is a mass storage device.
 */
isMassStorage: boolean;

/**
 * Gets the source device's human-readable manufacturer name.
 */
manufacturer: string;

/**
 * Gets the device model name.
 */
model: string;

/**
 * Gets a value indicating the type of power source being used by the source device, if it is known.
 */
powerSource: $Values<typeof Windows$Media$Import$PhotoImportPowerSource>;

/**
 * Gets the serial number of the device.
 */
serialNumber: string;

/**
 * Gets a list of objects representing the different storage media exposed by the source device.
 */
storageMedia: Windows$Foundation$Collections$IVectorView<Windows$Media$Import$PhotoImportStorageMedium>;

/**
 * Gets a reference to a stream containing the thumbnail image for the source device.
 */
thumbnail: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets a value indicating the type of the source device.
 */
type: $Values<typeof Windows$Media$Import$PhotoImportSourceType>
}


/**
 * Specifies the type of device that is being used as a photo import source.
 */

declare  var Windows$Media$Import$PhotoImportSourceType: {|
  +generic: 0,// 0
+camera: 1,// 1
+mediaPlayer: 2,// 2
+phone: 3,// 3
+video: 4,// 4
+personalInfoManager: 5,// 5
+audioRecorder: 6,// 6

|};



/**
 * Specifies the stages of the photo import process.
 */

declare  var Windows$Media$Import$PhotoImportStage: {|
  +notStarted: 0,// 0
+findingItems: 1,// 1
+importingItems: 2,// 2
+deletingImportedItemsFromSource: 3,// 3

|};



/**
 * Represents a storage medium exposed by a photo import source device.
 */
declare class Windows$Media$Import$PhotoImportStorageMedium  {

/**
 * Gets the available space on the storage medium, in bytes.
 */
availableSpaceInBytes: number;

/**
 * Gets the capacity of the storage media, in bytes.
 */
capacityInBytes: number;

/**
 * Gets a description of the storage medium.
 */
description: string;

/**
 * Gets the name of the storage medium.
 */
name: string;

/**
 * Refreshes the information about the storage medium.
 */
refresh(): void;

/**
 * Gets the serial number of the storage medium.
 */
serialNumber: string;

/**
 * Gets the type of the storage medium.
 */
storageMediumType: $Values<typeof Windows$Media$Import$PhotoImportStorageMediumType>;

/**
 * Gets a value indicating the access modes supported by the storage medium.
 */
supportedAccessMode: $Values<typeof Windows$Media$Import$PhotoImportAccessMode>
}


/**
 * Specifies the type of a storage medium.
 */

declare  var Windows$Media$Import$PhotoImportStorageMediumType: {|
  +undefined: 0,// 0
+fixed: 1,// 1
+removable: 2,// 2

|};



/**
 * Specifies the method used for naming subfolders within the destination folder.
 */

declare  var Windows$Media$Import$PhotoImportSubfolderCreationMode: {|
  +doNotCreateSubfolders: 0,// 0
+createSubfoldersFromFileDate: 1,// 1
+createSubfoldersFromExifDate: 2,// 2
+keepOriginalFolderStructure: 3,// 3

|};



/**
 * Represents an imported video segment.
 */
declare class Windows$Media$Import$PhotoImportVideoSegment  {

/**
 * Gets the date of the imported video segment.
 */
date: Date;

/**
 * Gets the name of the imported video segment.
 */
name: string;

/**
 * Gets the sibling file associated with the imported video segment.
 */
sibling: Windows$Media$Import$PhotoImportSidecar;

/**
 * Gets the sidecar file associated with the imported video segment.
 */
sidecars: Windows$Foundation$Collections$IVectorView<Windows$Media$Import$PhotoImportSidecar>;

/**
 * Gets the size of the imported video segment, in bytes.
 */
sizeInBytes: number
}


/**
 * The progress data for an asynchronous photo import operation.
 */
declare interface Windows$Media$Import$PhotoImportProgress {

/**
 * The number of bytes that have been imported.
 */
bytesImported: number,

/**
 * The current import progress, expressed as a floating point value from 0 to 1.
 */
importProgress: number,

/**
 * The number of items that have been imported.
 */
itemsImported: number,

/**
 * The total number of bytes to be imported.
 */
totalBytesToImport: number,

/**
 * The total number of items to be imported.
 */
totalItemsToImport: number
} 


/**
 * Describes the object that applications register with, to receive media focus and transport control notifications.
 */
declare class Windows$Media$MediaControl  {

/**
 * Gets or sets the path to the artwork for the album cover.
 */
static albumArt: Windows$Foundation$Uri;

/**
 * Gets or sets the name of the artist.
 */
static artistName: string;

/**
 * Gets or sets the state of the Play button.
 */
static isPlaying: boolean;

/**
 * Event raised when a ChannelDown command is issued to the application.
 */
static onchanneldownpressed: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "channeldownpressed",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "channeldownpressed",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Event raised when a ChannelUp command is issued to the application.
 */
static onchanneluppressed: Windows$Foundation$EventHandler<any>;
static addEventListener(type: "channeluppressed", listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: "channeluppressed", listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Event raised when a FastForward command is issued to the application.
 */
static onfastforwardpressed: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "fastforwardpressed",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "fastforwardpressed",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Event raised when a NextTrack command is issued to the application.
 */
static onnexttrackpressed: Windows$Foundation$EventHandler<any>;
static addEventListener(type: "nexttrackpressed", listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: "nexttrackpressed", listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Event raised when a Pause command is issued to the application.
 */
static onpausepressed: Windows$Foundation$EventHandler<any>;
static addEventListener(type: "pausepressed", listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: "pausepressed", listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Event raised when a PlayPauseToggle command is issued to the application.
 */
static onplaypausetogglepressed: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "playpausetogglepressed",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "playpausetogglepressed",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Event raised when a Play command is issued to the application.
 */
static onplaypressed: Windows$Foundation$EventHandler<any>;
static addEventListener(type: "playpressed", listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: "playpressed", listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Event raised when a PreviousTrack command is issued to the application.
 */
static onprevioustrackpressed: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "previoustrackpressed",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "previoustrackpressed",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Event raised when a Record command is issued to the application.
 */
static onrecordpressed: Windows$Foundation$EventHandler<any>;
static addEventListener(type: "recordpressed", listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: "recordpressed", listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Event raised when a Rewind command is issued to the application.
 */
static onrewindpressed: Windows$Foundation$EventHandler<any>;
static addEventListener(type: "rewindpressed", listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: "rewindpressed", listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Event raised when the sound level changes.
 */
static onsoundlevelchanged: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "soundlevelchanged",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "soundlevelchanged",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Event raised when a Stop command is issued to the application.
 */
static onstoppressed: Windows$Foundation$EventHandler<any>;
static addEventListener(type: "stoppressed", listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: "stoppressed", listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Gets the current sound level.
 */
static soundLevel: $Values<typeof Windows$Media$SoundLevel>;

/**
 * Gets or sets the track name.
 */
static trackName: string;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Registers a media parser or codec.
 */
declare class Windows$Media$MediaExtensionManager  {

/**
 * Creates a new MediaExtensionManager object that is used to register a media parser or codec.
 */
constructor(): this;

/**
 * Registers an audio decoder for the specified input and output media types.
 * @param activatableClassId The class identifier of the activatable runtime class of the audio decoder. The runtime class must implement the IMediaExtension interface.
 * @param inputSubtype The guid identifier of the media type that the audio decoder accepts as input.
 * @param outputSubtype The guid identifier of the media type that is output by the audio decoder.
 */
registerAudioDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;

/**
 * Registers an audio decoder for the specified input and output media types with an optional configuration parameter.
 * @param activatableClassId The class identifier of the activatable runtime class of the audio decoder. The runtime class must implement the IMediaExtension interface.
 * @param inputSubtype The guid identifier of the media type that the audio decoder accepts as input.
 * @param outputSubtype The guid identifier of the media type that is output by the audio decoder.
 * @param configuration An optional parameter that contains the configuration properties to be passed to the audio decoder.
 */
registerAudioDecoder(
activatableClassId: string,
inputSubtype: string,
outputSubtype: string,
configuration: Windows$Foundation$Collections$IPropertySet): void;

/**
 * Registers an audio encoder for the specified input and output media types with an optional configuration parameter.
 * @param activatableClassId The class identifier of the activatable runtime class of the audio encoder. The runtime class must implement the IMediaExtension interface.
 * @param inputSubtype The guid identifier of the media type that the audio encoder accepts as input.
 * @param outputSubtype The guid identifier of the media type that is output by the audio encoder.
 * @param configuration An optional parameter that contains the configuration properties to be passed to the audio encoder.
 */
registerAudioEncoder(
activatableClassId: string,
inputSubtype: string,
outputSubtype: string,
configuration: Windows$Foundation$Collections$IPropertySet): void;

/**
 * Registers an audio encoder for the specified input and output media types.
 * @param activatableClassId The class identifier of the activatable runtime class of the audio encoder. The runtime class must implement the IMediaExtension interface.
 * @param inputSubtype The guid identifier of the media type that the audio encoder accepts as input.
 * @param outputSubtype The guid identifier of the media type that is output by the audio encoder.
 */
registerAudioEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;

/**
 * Registers a byte-stream handler by file name extension and MIME type.
 * @param activatableClassId The class identifier of the activatable runtime class of the byte-stream handler. The runtime class must implement the IMediaExtension interface.
 * @param fileExtension The file name extension that is registered for this byte-stream handler.
 * @param mimeType The MIME type that is registered for this byte-stream handler.
 */
registerByteStreamHandler(activatableClassId: string, fileExtension: string, mimeType: string): void;

/**
 * Registers a byte-stream handler by file name extension and MIME type, with an optional configuration parameter.
 * @param activatableClassId The class identifier of the activatable runtime class of the byte-stream handler. The runtime class must implement the IMediaExtension interface.
 * @param fileExtension The file name extension that is registered for this byte-stream handler.
 * @param mimeType The MIME type that is registered for this byte-stream handler.
 * @param configuration An optional parameter that contains configuration properties for the byte-stream handler.
 */
registerByteStreamHandler(
activatableClassId: string,
fileExtension: string,
mimeType: string,
configuration: Windows$Foundation$Collections$IPropertySet): void;

/**
 * Registers a scheme handler for the specified URL scheme with an optional configuration parameter.
 * @param activatableClassId The class identifier of the activatable runtime class of the scheme handler. The runtime class must implement the IMediaExtension interface.
 * @param scheme The URL scheme that will be recognized to invoke the scheme handler. For example, "myscheme://".
 * @param configuration An optional parameter that contains configuration properties for the scheme handler.
 */
registerSchemeHandler(
activatableClassId: string,
scheme: string,
configuration: Windows$Foundation$Collections$IPropertySet): void;

/**
 * Registers a scheme handler for the specified URL scheme.
 * @param activatableClassId The class identifier of the activatable runtime class of the scheme handler. The runtime class must implement the IMediaExtension interface.
 * @param scheme The URL scheme that will be recognized to invoke the scheme handler. For example, "myscheme://".
 */
registerSchemeHandler(activatableClassId: string, scheme: string): void;

/**
 * Registers an video decoder for the specified input and output media types.
 * @param activatableClassId The class identifier of the activatable runtime class of the video decoder. The runtime class must implement the IMediaExtension interface.
 * @param inputSubtype The guid identifier of the media type that the video decoder accepts as input.
 * @param outputSubtype The guid identifier of the media type that is output by the video decoder.
 */
registerVideoDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;

/**
 * Registers a video decoder for the specified input and output media types with an optional configuration parameter.
 * @param activatableClassId The class identifier of the activatable runtime class of the video decoder. The runtime class must implement the IMediaExtension interface.
 * @param inputSubtype The guid identifier of the media type that the video decoder accepts as input.
 * @param outputSubtype The guid identifier of the media type that is output by the video decoder.
 * @param configuration An optional parameter that contains the configuration properties to be passed to the video decoder.
 */
registerVideoDecoder(
activatableClassId: string,
inputSubtype: string,
outputSubtype: string,
configuration: Windows$Foundation$Collections$IPropertySet): void;

/**
 * Registers a video encoder for the specified input and output media types.
 * @param activatableClassId The class identifier of the activatable runtime class of the video encoder. The runtime class must implement the IMediaExtension interface.
 * @param inputSubtype The guid identifier of the media type that the video encoder accepts as input.
 * @param outputSubtype The guid identifier of the media type that is output by the video encoder.
 */
registerVideoEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;

/**
 * Registers a video encoder for the specified input and output media types with an optional configuration parameter.
 * @param activatableClassId The class identifier of the activatable runtime class of the video encoder. The runtime class must implement the IMediaExtension interface.
 * @param inputSubtype The guid identifier of the media type that the video encoder accepts as input.
 * @param outputSubtype The guid identifier of the media type that is output by the video encoder.
 * @param configuration An optional parameter that contains the configuration properties to be passed to the video encoder.
 */
registerVideoEncoder(
activatableClassId: string,
inputSubtype: string,
outputSubtype: string,
configuration: Windows$Foundation$Collections$IPropertySet): void
}


/**
 * Provides a static list of media marker types.
 */
declare class Windows$Media$MediaMarkerTypes  {

/**
 * Gets the value of the Bookmark type which is returned as the string "Bookmark"
 */
static bookmark: string
}


/**
 * Specifies the auto repeat mode for media playback.
 */

declare  var Windows$Media$MediaPlaybackAutoRepeatMode: {|
  +none: 0,// 0
+track: 1,// 1
+list: 2,// 2

|};



/**
 * Defines values for the status of the media playback.
 */

declare  var Windows$Media$MediaPlaybackStatus: {|
  +closed: 0,// 0
+changing: 1,// 1
+stopped: 2,// 2
+playing: 3,// 3
+paused: 4,// 4

|};



/**
 * Defines values for the types of media playback.
 */

declare  var Windows$Media$MediaPlaybackType: {|
  +unknown: 0,// 0
+music: 1,// 1
+video: 2,// 2
+image: 3,// 3

|};



/**
 * Provides a media processing background task access to the set of arguments supplied in the call to MediaProcessingTrigger::RequestAsync .
 */
declare class Windows$Media$MediaProcessingTriggerDetails  {

/**
 * Gets a value set containing the arguments supplied in the call to MediaProcessingTrigger::RequestAsync .
 */
arguments: Windows$Foundation$Collections$ValueSet
}


      declare var npm$namespace$Windows$Media$MediaProperties: {
        
        
        AudioEncodingQuality: typeof Windows$Media$MediaProperties$AudioEncodingQuality,
MediaMirroringOptions: typeof Windows$Media$MediaProperties$MediaMirroringOptions,
MediaPixelFormat: typeof Windows$Media$MediaProperties$MediaPixelFormat,
MediaRotation: typeof Windows$Media$MediaProperties$MediaRotation,
MediaThumbnailFormat: typeof Windows$Media$MediaProperties$MediaThumbnailFormat,
VideoEncodingQuality: typeof Windows$Media$MediaProperties$VideoEncodingQuality,
        AudioEncodingProperties: typeof Windows$Media$MediaProperties$AudioEncodingProperties,
ContainerEncodingProperties: typeof Windows$Media$MediaProperties$ContainerEncodingProperties,
H264ProfileIds: typeof Windows$Media$MediaProperties$H264ProfileIds,
ImageEncodingProperties: typeof Windows$Media$MediaProperties$ImageEncodingProperties,
MediaEncodingProfile: typeof Windows$Media$MediaProperties$MediaEncodingProfile,
MediaEncodingSubtypes: typeof Windows$Media$MediaProperties$MediaEncodingSubtypes,
MediaPropertySet: typeof Windows$Media$MediaProperties$MediaPropertySet,
MediaRatio: typeof Windows$Media$MediaProperties$MediaRatio,
Mpeg2ProfileIds: typeof Windows$Media$MediaProperties$Mpeg2ProfileIds,
VideoEncodingProperties: typeof Windows$Media$MediaProperties$VideoEncodingProperties,
        
      }

/**
 * Describes the format of an audio stream.
 */
declare class Windows$Media$MediaProperties$AudioEncodingProperties  {

/**
 * Creates an instance of AudioEncodingProperties for Advanced Audio Coding (AAC) audio.
 * @param sampleRate The audio sampling rate.
 * @param channelCount The number of audio channels.
 * @param bitrate The audio bit rate.
 * @return The audio encoding properties.
 */
static createAac(
sampleRate: number,
channelCount: number,
bitrate: number): Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Creates an instance of AudioEncodingProperties for Advanced Audio Coding (AAC) audio in Audio Data Transport Stream (ADTS) format.
 * @param sampleRate The audio sampling rate.
 * @param channelCount The number of audio channels.
 * @param bitrate The audio bit rate.
 * @return The audio encoding properties.
 */
static createAacAdts(
sampleRate: number,
channelCount: number,
bitrate: number): Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Creates an instance of AudioEncodingProperties for MPEG Audio Layer-3 (MP3) audio.
 * @param sampleRate The audio sampling rate.
 * @param channelCount The number of audio channels.
 * @param bitrate The audio bit rate.
 * @return The audio encoding properties.
 */
static createMp3(
sampleRate: number,
channelCount: number,
bitrate: number): Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Creates an instance of AudioEncodingProperties for Pulse Code Modulation (PCM) audio.
 * @param sampleRate The audio sampling rate.
 * @param channelCount The number of audio channels.
 * @param bitsPerSample The audio bit depth.
 * @return The audio encoding properties.
 */
static createPcm(
sampleRate: number,
channelCount: number,
bitsPerSample: number): Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Creates an instance of AudioEncodingProperties for Windows Media Audio (WMA).
 * @param sampleRate The audio sampling rate.
 * @param channelCount The number of audio channels.
 * @param bitrate The audio bit rate.
 * @return The audio encoding properties.
 */
static createWma(
sampleRate: number,
channelCount: number,
bitrate: number): Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Creates a new instance of the AudioEncodingProperties class.
 */
constructor(): this;

/**
 * Gets or sets the audio bit rate.
 */
bitrate: number;

/**
 * Gets or sets the number of bits per audio sample.
 */
bitsPerSample: number;

/**
 * Gets or sets the number of audio channels.
 */
channelCount: number;

/**
 * Gets the media format user data.
 * @return Receives the media format data.
 */
getFormatUserData(): number[];

/**
 * Gets additional format properties for the audio stream.
 */
properties: Windows$Media$MediaProperties$MediaPropertySet;

/**
 * Gets or sets audio sampling rate.
 */
sampleRate: number;

/**
 * Sets the media format user data.
 * @param value The media data to set.
 */
setFormatUserData(value: number[]): void;

/**
 * Gets or sets the subtype of the format.
 */
subtype: string;

/**
 * Gets the format type.
 */
type: string
}


/**
 * Describes the level of quality of the audio encoding. The higher the quality, the better the audio fidelity, and the larger the resulting file.
 */

declare  var Windows$Media$MediaProperties$AudioEncodingQuality: {|
  +auto: 0,// 0
+high: 1,// 1
+medium: 2,// 2
+low: 3,// 3

|};



/**
 * Describes a media container format.
 */
declare class Windows$Media$MediaProperties$ContainerEncodingProperties  {

/**
 * Creates a new instance of the ContainerEncodingProperties class.
 */
constructor(): this;

/**
 * Gets additional format properties for the media container.
 */
properties: Windows$Media$MediaProperties$MediaPropertySet;

/**
 * Gets or sets the subtype of the media container.
 */
subtype: string;

/**
 * Gets the format type.
 */
type: string
}


/**
 * Provides properties for getting H.265 profile ids.
 */
declare class Windows$Media$MediaProperties$H264ProfileIds  {

/**
 * Gets the H.264 baseline profile.
 */
static baseline: number;

/**
 * Gets the H.264 constrained baseline profile.
 */
static constrainedBaseline: number;

/**
 * Gets the H.264 extended profile.
 */
static extended: number;

/**
 * Gets the H.264 high profile.
 */
static high: number;

/**
 * Gets the H.264 high 10 profile.
 */
static high10: number;

/**
 * Gets the H.264 high 4:2:2 profile.
 */
static high422: number;

/**
 * Gets the H.264 high 4:4:4 profile.
 */
static high444: number;

/**
 * Gets the H.264 main profile.
 */
static main: number;

/**
 * Gets the H.264 multiview profile.
 */
static multiviewHigh: number;

/**
 * Gets the H.264 stereo high profile.
 */
static stereoHigh: number
}


/**
 * Describes the format of an image stream.
 */
declare class Windows$Media$MediaProperties$ImageEncodingProperties  {

/**
 * Creates an instance of ImageEncodingProperties for a BMP image.
 * @return The image encoding properties.
 */
static createBmp(): Windows$Media$MediaProperties$ImageEncodingProperties;

/**
 * Creates an instance of ImageEncodingProperties for a JPEG image.
 * @return The properties for the image stream.
 */
static createJpeg(): Windows$Media$MediaProperties$ImageEncodingProperties;

/**
 * Creates an instance of ImageEncodingProperties for a JPEG XR image.
 * @return The properties for the image stream.
 */
static createJpegXR(): Windows$Media$MediaProperties$ImageEncodingProperties;

/**
 * Creates an instance of ImageEncodingProperties for a PNG image.
 * @return The properties for the image stream.
 */
static createPng(): Windows$Media$MediaProperties$ImageEncodingProperties;

/**
 * Creates an instance of ImageEncodingProperties for an uncompressed image.
 * @param format The media pixel format.
 * @return The image encoding properties.
 */
static createUncompressed(
format: $Values<typeof Windows$Media$MediaProperties$MediaPixelFormat>): Windows$Media$MediaProperties$ImageEncodingProperties;

/**
 * Creates a new instance of the ImageEncodingProperties class.
 */
constructor(): this;

/**
 * Gets or sets the image height.
 */
height: number;

/**
 * Gets additional format properties for the image stream.
 */
properties: Windows$Media$MediaProperties$MediaPropertySet;

/**
 * Gets or sets the subtype of the format.
 */
subtype: string;

/**
 * Gets the format type.
 */
type: string;

/**
 * Gets or sets the image width.
 */
width: number
}


/**
 * Describes the encoding profile for an audio or video file. The encoding profile includes descriptions of the audio and video encoding formats, and a description of the media container.
 */
declare class Windows$Media$MediaProperties$MediaEncodingProfile  {

/**
 * Creates an instance of MediaEncodingProfile for AVI.
 * @param quality The video quality.
 * @return The media encoding profile.
 */
static createAvi(
quality: $Values<typeof Windows$Media$MediaProperties$VideoEncodingQuality>): Windows$Media$MediaProperties$MediaEncodingProfile;

/**
 * Creates an encoding profile from an existing media file.
 * @param file The media file from which to create the profile.
 * @return An object that is used to control the asynchronous operation.
 */
static createFromFileAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$MediaProperties$MediaEncodingProfile>;

/**
 * Creates an encoding profile from a stream that contains media data.
 * @param stream The media stream from which to create the profile.
 * @return An object that is used to control the asynchronous operation.
 */
static createFromStreamAsync(
stream: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$MediaProperties$MediaEncodingProfile>;

/**
 * Creates an encoding profile for AAC audio.
 * @param quality Specifies whether to create a profile with a low bit rate, medium bit rate, or high bit rate.
 * @return Returns a media encoding profile.
 */
static createM4a(
quality: $Values<typeof Windows$Media$MediaProperties$AudioEncodingQuality>): Windows$Media$MediaProperties$MediaEncodingProfile;

/**
 * Creates an encoding profile for MP3 (MPEG-1 layer 3) audio.
 * @param quality Specifies whether to create a profile with a low bit rate, medium bit rate, or high bit rate.
 * @return Returns a media encoding profile.
 */
static createMp3(
quality: $Values<typeof Windows$Media$MediaProperties$AudioEncodingQuality>): Windows$Media$MediaProperties$MediaEncodingProfile;

/**
 * Creates an encoding profile for H.264 video.
 * @param quality Specifies the video resolution of the profile.
 * @return Returns a media encoding profile.
 */
static createMp4(
quality: $Values<typeof Windows$Media$MediaProperties$VideoEncodingQuality>): Windows$Media$MediaProperties$MediaEncodingProfile;

/**
 * Creates an instance of MediaEncodingProfile for WAV
 * @param quality The audio encoding quality.
 * @return The media encoding profile.
 */
static createWav(
quality: $Values<typeof Windows$Media$MediaProperties$AudioEncodingQuality>): Windows$Media$MediaProperties$MediaEncodingProfile;

/**
 * Creates an encoding profile for Windows Media Audio (WMA).
 * @param quality Specifies whether to create a profile with a low bit rate, medium bit rate, or high bit rate.
 * @return Returns a media encoding profile.
 */
static createWma(
quality: $Values<typeof Windows$Media$MediaProperties$AudioEncodingQuality>): Windows$Media$MediaProperties$MediaEncodingProfile;

/**
 * Creates an encoding profile for Windows Media Video (WMV).
 * @param quality Specifies the video resolution of the profile.
 * @return Returns a media encoding profile.
 */
static createWmv(
quality: $Values<typeof Windows$Media$MediaProperties$VideoEncodingQuality>): Windows$Media$MediaProperties$MediaEncodingProfile;

/**
 * Creates a new instance of the MediaEncodingProfile class.
 */
constructor(): this;

/**
 * Gets or sets the encoding properties for the audio stream.
 */
audio: Windows$Media$MediaProperties$AudioEncodingProperties;

/**
 * Gets or sets the properties of the media container.
 */
container: Windows$Media$MediaProperties$ContainerEncodingProperties;

/**
 * Gets or sets the encoding properties for the video stream.
 */
video: Windows$Media$MediaProperties$VideoEncodingProperties
}


/**
 * Provides properties for getting the standard names for media subtypes.
 */
declare class Windows$Media$MediaProperties$MediaEncodingSubtypes  {

/**
 * Gets the name for Advanced Audio Coding (AAC).
 */
static aac: string;

/**
 * Gets the name for Advanced Audio Coding (AAC) audio in Audio Data Transport Stream (ADTS) format.
 */
static aacAdts: string;

/**
 * Gets the name for Dolby Digital audio (AC-3).
 */
static ac3: string;

/**
 * Gets the name for Adaptive Multi-Rate (AmrNb).
 */
static amrNb: string;

/**
 * Gets the name for Adaptive Multi-Rate Wideband.
 */
static amrWb: string;

/**
 * Gets the name for RGB 32 with alpha channel.
 */
static argb32: string;

/**
 * Gets the name for Advanced Systems Format (ASF).
 */
static asf: string;

/**
 * Gets the name for Audio Video Interleave (AVI).
 */
static avi: string;

/**
 * Gets the name for BGRA8.
 */
static bgra8: string;

/**
 * Gets the name for BMP file format.
 */
static bmp: string;

/**
 * Gets the name Dolby Digital Plus (E-AC-3).
 */
static eac3: string;

/**
 * Gets the name for Uncompressed IEEE floating-point audio.
 */
static float: string;

/**
 * Gets the name for Graphics Interchange Format (GIF).
 */
static gif: string;

/**
 * Gets the name for H.263.
 */
static h263: string;

/**
 * The name for H.264.
 */
static h264: string;

/**
 * Get the name for H.264Es.
 */
static h264Es: string;

/**
 * Gets the name for High Efficiency Video Coding (HEVC).
 */
static hevc: string;

/**
 * Gets the name for HEVCES.
 */
static hevcEs: string;

/**
 * Gets the name for IYUV.
 */
static iyuv: string;

/**
 * Gets the name for JPEG.
 */
static jpeg: string;

/**
 * Gets the name for JPEG-XR.
 */
static jpegXr: string;

/**
 * Gets the name for Motion JPEG (MJPG).
 */
static mjpg: string;

/**
 * Gete the name for MPEG Audio Layer-3 (MP3).
 */
static mp3: string;

/**
 * Gets the name for MPEG.
 */
static mpeg: string;

/**
 * Gets the name for MPEG-1.
 */
static mpeg1: string;

/**
 * Gets the name for MPEG-2.
 */
static mpeg2: string;

/**
 * Gets the name for MPEG-4.
 */
static mpeg4: string;

/**
 * Gets the name for NV12.
 */
static nv12: string;

/**
 * Gets the name for PCM.
 */
static pcm: string;

/**
 * Gets the name for Portable Network Graphics (PNG).
 */
static png: string;

/**
 * Gets the name RGB 24.
 */
static rgb24: string;

/**
 * Gets the name for RGB 32.
 */
static rgb32: string;

/**
 * Gets the name for TIFF.
 */
static tiff: string;

/**
 * Gets the name for Waveform Audio File (WAVE).
 */
static wave: string;

/**
 * Gets the name for Windows Media Audio 8.
 */
static wma8: string;

/**
 * Gets the name for Windows Media Audio 8.
 */
static wma9: string;

/**
 * Gets the name for Windows Media Video 9.
 */
static wmv3: string;

/**
 * Gets the name for Windows Media Video 9 Advanced Profile.
 */
static wvc1: string;

/**
 * Gets the name for YUY2.
 */
static yuy2: string;

/**
 * Gets the name for YV12.
 */
static yv12: string
}


/**
 * Defines the direction in of a mirror transform.
 */

declare  var Windows$Media$MediaProperties$MediaMirroringOptions: {|
  +none: 0,// 0
+horizontal: 1,// 1
+vertical: 2,// 2

|};



/**
 * Defines values for media pixel formats.
 */

declare  var Windows$Media$MediaProperties$MediaPixelFormat: {|
  +nv12: 0,// 0
+bgra8: 1,// 1

|};



/**
 * Represents a set of media properties.
 */
declare class Windows$Media$MediaProperties$MediaPropertySet  {

/**
 * Creates an instance for MediaPropertySet .
 */
constructor(): this;

/**
 * Removes all items from the property set.
 */
clear(): void;

/**
 * Returns an iterator to enumerate the items in the property set.
 * @return The iterator. The current position of the iterator is index 0, or the end of the property set if the property set is empty.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Returns an immutable view of the property set.
 * @return The immutable view.
 */
getView(): Windows$Foundation$Collections$IMapView<string, any>;

/**
 * Indicates whether the property set has an item with the specified key.
 * @param key The key.
 * @return True if the property set has an item with the specified key; otherwise, false.
 */
hasKey(key: string): boolean;

/**
 * Adds an item to the property set.
 * @param key The key of the item to insert.
 * @param value The value of the item to insert.
 * @return True if the method replaced a value that already existed for the key; false if this is a new key.
 */
insert(key: string, value: any): boolean;

/**
 * Retrieves the value for the specified key.
 * @param key The key.
 * @return The value, if an item with the specified key exists. Otherwise, null.
 */
lookup(key: string): any;

/**
 * Removes an item from the property set.
 * @param key The key of the item to remove.
 */
remove(key: string): void;

/**
 * Removes a specific item from the MediaPropertySet .
 * @param key The key of the item to remove.
 * @return true if the item was removed, otherwise false.
 */
remove(key: string): boolean;

/**
 * Gets the number of items contained in the property set.
 */
size: number
}


/**
 * Represents ratios used in media operations.
 */
declare class Windows$Media$MediaProperties$MediaRatio  {

/**
 * The denominator of the MediaRatio.
 */
denominator: number;

/**
 * The numerator of the MediaRatio.
 */
numerator: number
}


/**
 * Defines the direction and angle of a media rotation transform.
 */

declare  var Windows$Media$MediaProperties$MediaRotation: {|
  +none: 0,// 0
+clockwise90Degrees: 1,// 1
+clockwise180Degrees: 2,// 2
+clockwise270Degrees: 3,// 3

|};



/**
 * Defines values for media formats for thumbnails.
 */

declare  var Windows$Media$MediaProperties$MediaThumbnailFormat: {|
  +bmp: 0,// 0
+bgra8: 1,// 1

|};



/**
 * Provides properties for getting MPEG-2 profile ids.
 */
declare class Windows$Media$MediaProperties$Mpeg2ProfileIds  {

/**
 * Gets the MPEG-2 high profile.
 */
static high: number;

/**
 * Gets the MPEG-2 main profile.
 */
static main: number;

/**
 * Gets the MPEG-2 signal to noise ratio scalable profile.
 */
static signalNoiseRatioScalable: number;

/**
 * Gets the MPEG-2 simple profile.
 */
static simple: number;

/**
 * Gets the MPEG-2 spatially scalable profile.
 */
static spatiallyScalable: number
}


/**
 * Describes the format of a video stream.
 */
declare class Windows$Media$MediaProperties$VideoEncodingProperties  {

/**
 * Creates an instance of VideoEncodingProperties for a H.263 video.
 * @return The video encoding properties.
 */
static createH264(): Windows$Media$MediaProperties$VideoEncodingProperties;

/**
 * Creates an instance of VideoEncodingProperties for a MPEG-2 video.
 * @return The video encoding properties.
 */
static createMpeg2(): Windows$Media$MediaProperties$VideoEncodingProperties;

/**
 * Creates an instance of VideoEncodingProperties for a uncompressed video.
 * @param subtype The media subtype of the format.
 * @param width The video image width.
 * @param height The video image height.
 * @return The video encoding properties.
 */
static createUncompressed(
subtype: string,
width: number,
height: number): Windows$Media$MediaProperties$VideoEncodingProperties;

/**
 * Creates a new instance of the VideoEncodingProperties class.
 */
constructor(): this;

/**
 * Gets or sets the video bit rate.
 */
bitrate: number;

/**
 * Gets or sets the video frame rate.
 */
frameRate: Windows$Media$MediaProperties$MediaRatio;

/**
 * Gets the media format user data.
 * @return Receives the media format data.
 */
getFormatUserData(): number[];

/**
 * Gets or sets the video image height.
 */
height: number;

/**
 * Gets or sets the pixel aspect ratio.
 */
pixelAspectRatio: Windows$Media$MediaProperties$MediaRatio;

/**
 * Gets or sets the media format profile.
 */
profileId: number;

/**
 * Gets additional format properties for the video stream.
 */
properties: Windows$Media$MediaProperties$MediaPropertySet;

/**
 * Sets the media format user data.
 * @param value The media data to set.
 */
setFormatUserData(value: number[]): void;

/**
 * Gets or sets the subtype of the format.
 */
subtype: string;

/**
 * Gets the format type.
 */
type: string;

/**
 * Gets or sets the video image width.
 */
width: number
}


/**
 * Determines the video encoding format.
 */

declare  var Windows$Media$MediaProperties$VideoEncodingQuality: {|
  +auto: 0,// 0
+hd1080p: 1,// 1
+hd720p: 2,// 2
+wvga: 3,// 3
+ntsc: 4,// 4
+pal: 5,// 5
+vga: 6,// 6
+qvga: 7,// 7

|};



/**
 * Describes the format of a media stream or media container.
 */
declare interface Windows$Media$MediaProperties$IMediaEncodingProperties {

/**
 * Gets additional format properties.
 */
properties: Windows$Media$MediaProperties$MediaPropertySet,

/**
 * Gets or sets the subtype of the format.
 */
subtype: string,

/**
 * Gets the format type.
 */
type: string
} 


/**
 * Provides properties for music information that is displayed by the SystemMediaTransportControlsDisplayUpdater class.
 */
declare class Windows$Media$MusicDisplayProperties  {

/**
 * Gets or sets the name of the album artist.
 */
albumArtist: string;

/**
 * Gets or sets the album title.
 */
albumTitle: string;

/**
 * Gets or set the name of the song artist.
 */
artist: string;

/**
 * Gets a modifiable list of strings representing genre names.
 */
genres: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets or set the title of the song.
 */
title: string;

/**
 * Gets or sets the track number.
 */
trackNumber: number
}


      declare var npm$namespace$Windows$Media$Ocr: {
        
        
        
        OcrEngine: typeof Windows$Media$Ocr$OcrEngine,
OcrLine: typeof Windows$Media$Ocr$OcrLine,
OcrResult: typeof Windows$Media$Ocr$OcrResult,
OcrWord: typeof Windows$Media$Ocr$OcrWord,
        
      }

/**
 * Provides optical character recognition (OCR) functionality.
 */
declare class Windows$Media$Ocr$OcrEngine  {

/**
 * Returns a collection of all available OCR languages on the device.
 */
static availableRecognizerLanguages: Windows$Foundation$Collections$IVectorView<Windows$Globalization$Language>;

/**
 * Returns true if a specified language can be resolved to any of the available OCR languages. See language matching for a further explanation of language resolving.
 * @param language The language being used for text recognition.
 * @return TRUE, if the specified language can be resolved to any of the available OCR languages; otherwise, FALSE.
 */
static isLanguageSupported(language: Windows$Globalization$Language): boolean;

/**
 * Gets the maximum image pixel dimensions supported by the OCR engine.
 */
static maxImageDimension: number;

/**
 * Creates a new instance of the OcrEngine class.
 * @param language The language being used for text recognition.
 * @return If the specified language can be resolved to any of the OCR languages available on the device, returns new instance of OcrEngine class, otherwise returns null. See language matching for a further explanation of language resolving.
 */
static tryCreateFromLanguage(language: Windows$Globalization$Language): Windows$Media$Ocr$OcrEngine;

/**
 * Creates a new instance of the OcrEngine class.
 * @return If any language from GlobalizationPreferences.Languages can be resolved to any of the available OCR languages returns new instance of OcrEngine class, otherwise returns null.
 */
static tryCreateFromUserProfileLanguages(): Windows$Media$Ocr$OcrEngine;

/**
 * Scans the specified image for text in the language specified by the RecognizerLanguage property.
 * @param bitmap Represents an uncompressed bitmap.
 * @return The result of the OCR that was initiated by the OcrEngine object.
 */
recognizeAsync(
bitmap: Windows$Graphics$Imaging$SoftwareBitmap): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Ocr$OcrResult>;

/**
 * Gets the language being used for text recognition.
 */
recognizerLanguage: Windows$Globalization$Language
}


/**
 * Represents a single line of text recognized by the OCR engine and returned as part of the OcrResult .
 */
declare class Windows$Media$Ocr$OcrLine  {

/**
 * Gets the text of the recognized line.
 */
text: string;

/**
 * Gets the collection of OcrWord objects that represents the words detected in the current line of text by the RecognizeAsync method.
 */
words: Windows$Foundation$Collections$IVectorView<Windows$Media$Ocr$OcrWord>
}


/**
 * Contains the results of Optical Character Recognition (OCR).
 */
declare class Windows$Media$Ocr$OcrResult  {

/**
 * Gets the collection of OcrLine objects that represents the lines of text detected in the image by the RecognizeAsync method.
 */
lines: Windows$Foundation$Collections$IVectorView<Windows$Media$Ocr$OcrLine>;

/**
 * Gets the recognized text.
 */
text: string;

/**
 * Gets the clockwise rotation of the recognized text, in degrees, around the center of the image.
 */
textAngle: number
}


/**
 * Represents a single word in a line of text recognized by the OCR engine and returned as part of the OcrLine .
 */
declare class Windows$Media$Ocr$OcrWord  {

/**
 * Gets the position and size in pixels of the recognized word from the top left corner of image when the value of TextAngle property is 0 (zero).
 */
boundingRect: Windows$Foundation$Rect;

/**
 * Gets the text of the recognized word.
 */
text: string
}


      declare var npm$namespace$Windows$Media$PlayTo: {
        
        
        PlayToConnectionError: typeof Windows$Media$PlayTo$PlayToConnectionError,
PlayToConnectionState: typeof Windows$Media$PlayTo$PlayToConnectionState,
        CurrentTimeChangeRequestedEventArgs: typeof Windows$Media$PlayTo$CurrentTimeChangeRequestedEventArgs,
MuteChangeRequestedEventArgs: typeof Windows$Media$PlayTo$MuteChangeRequestedEventArgs,
PlayToConnection: typeof Windows$Media$PlayTo$PlayToConnection,
PlayToConnectionErrorEventArgs: typeof Windows$Media$PlayTo$PlayToConnectionErrorEventArgs,
PlayToConnectionStateChangedEventArgs: typeof Windows$Media$PlayTo$PlayToConnectionStateChangedEventArgs,
PlayToConnectionTransferredEventArgs: typeof Windows$Media$PlayTo$PlayToConnectionTransferredEventArgs,
PlayToManager: typeof Windows$Media$PlayTo$PlayToManager,
PlayToReceiver: typeof Windows$Media$PlayTo$PlayToReceiver,
PlayToSource: typeof Windows$Media$PlayTo$PlayToSource,
PlayToSourceDeferral: typeof Windows$Media$PlayTo$PlayToSourceDeferral,
PlayToSourceRequest: typeof Windows$Media$PlayTo$PlayToSourceRequest,
PlayToSourceRequestedEventArgs: typeof Windows$Media$PlayTo$PlayToSourceRequestedEventArgs,
PlayToSourceSelectedEventArgs: typeof Windows$Media$PlayTo$PlayToSourceSelectedEventArgs,
PlaybackRateChangeRequestedEventArgs: typeof Windows$Media$PlayTo$PlaybackRateChangeRequestedEventArgs,
SourceChangeRequestedEventArgs: typeof Windows$Media$PlayTo$SourceChangeRequestedEventArgs,
VolumeChangeRequestedEventArgs: typeof Windows$Media$PlayTo$VolumeChangeRequestedEventArgs,
        
      }

/**
 * Provides information about the CurrentTimeChangeRequested event.
 */
declare class Windows$Media$PlayTo$CurrentTimeChangeRequestedEventArgs  {

/**
 * Gets the new time that the Play To source audio or video stream has been changed to.
 */
time: number
}


/**
 * Provides information about the MuteChangeRequested event.
 */
declare class Windows$Media$PlayTo$MuteChangeRequestedEventArgs  {

/**
 * Gets a value that indicates whether mute or unmute was requested.
 */
mute: boolean
}


/**
 * Provides information about a Play To connection.
 */
declare class Windows$Media$PlayTo$PlayToConnection  {

/**
 * Occurs when an error is encountered for the Play To connection.
 */
onerror: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToConnection, Windows$Media$PlayTo$PlayToConnectionErrorEventArgs>;
addEventListener(
type: "error",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToConnection, Windows$Media$PlayTo$PlayToConnectionErrorEventArgs>): void;
removeEventListener(
type: "error",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToConnection, Windows$Media$PlayTo$PlayToConnectionErrorEventArgs>): void;

/**
 * Occurs when the state of the Play To connection has changed.
 */
onstatechanged: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToConnection, Windows$Media$PlayTo$PlayToConnectionStateChangedEventArgs>;
addEventListener(
type: "statechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToConnection, Windows$Media$PlayTo$PlayToConnectionStateChangedEventArgs>): void;
removeEventListener(
type: "statechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToConnection, Windows$Media$PlayTo$PlayToConnectionStateChangedEventArgs>): void;

/**
 * Occurs when the Play To connection is transferred to the next Play To source.
 */
ontransferred: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToConnection, Windows$Media$PlayTo$PlayToConnectionTransferredEventArgs>;
addEventListener(
type: "transferred",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToConnection, Windows$Media$PlayTo$PlayToConnectionTransferredEventArgs>): void;
removeEventListener(
type: "transferred",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToConnection, Windows$Media$PlayTo$PlayToConnectionTransferredEventArgs>): void;

/**
 * Gets the state of the Play To connection.
 */
state: $Values<typeof Windows$Media$PlayTo$PlayToConnectionState>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Describes an error on a Play To connection.
 */

declare  var Windows$Media$PlayTo$PlayToConnectionError: {|
  +none: 0,// 0
+deviceNotResponding: 1,// 1
+deviceError: 2,// 2
+deviceLocked: 3,// 3
+protectedPlaybackFailed: 4,// 4

|};



/**
 * Provides information about the Error event.
 */
declare class Windows$Media$PlayTo$PlayToConnectionErrorEventArgs  {

/**
 * Gets the error code for a Play To connection error.
 */
code: $Values<typeof Windows$Media$PlayTo$PlayToConnectionError>;

/**
 * Gets the error message for a Play To connection error.
 */
message: string
}


/**
 * Describes the status of a Play To connection.
 */

declare  var Windows$Media$PlayTo$PlayToConnectionState: {|
  +disconnected: 0,// 0
+connected: 1,// 1
+rendering: 2,// 2

|};



/**
 * Provides information about the StateChanged event.
 */
declare class Windows$Media$PlayTo$PlayToConnectionStateChangedEventArgs  {

/**
 * Gets the current state after the Play To connection state has changed.
 */
currentState: $Values<typeof Windows$Media$PlayTo$PlayToConnectionState>;

/**
 * Gets the previous state before the Play To connection state was changed.
 */
previousState: $Values<typeof Windows$Media$PlayTo$PlayToConnectionState>
}


/**
 * Provides information about the Transferred event.
 */
declare class Windows$Media$PlayTo$PlayToConnectionTransferredEventArgs  {

/**
 * Gets the current Play To source that a connection was transferred to.
 */
currentSource: Windows$Media$PlayTo$PlayToSource;

/**
 * Gets the previous Play To source that a connection was transferred from.
 */
previousSource: Windows$Media$PlayTo$PlayToSource
}


/**
 * Provides access to Play To capabilities.
 */
declare class Windows$Media$PlayTo$PlayToManager  {

/**
 * Gets the Play To manager for the current view.
 * @return The Play To manager for the current view.
 */
static getForCurrentView(): Windows$Media$PlayTo$PlayToManager;

/**
 * Displays the Play To UI.
 */
static showPlayToUI(): void;

/**
 * Enables or disables the default source selection for Play To.
 */
defaultSourceSelection: boolean;

/**
 * Occurs when a user requests media to stream to a Play To target device.
 */
onsourcerequested: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToManager, Windows$Media$PlayTo$PlayToSourceRequestedEventArgs>;
addEventListener(
type: "sourcerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToManager, Windows$Media$PlayTo$PlayToSourceRequestedEventArgs>): void;
removeEventListener(
type: "sourcerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToManager, Windows$Media$PlayTo$PlayToSourceRequestedEventArgs>): void;

/**
 * Occurs when a Play To source element has been selected.
 */
onsourceselected: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToManager, Windows$Media$PlayTo$PlayToSourceSelectedEventArgs>;
addEventListener(
type: "sourceselected",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToManager, Windows$Media$PlayTo$PlayToSourceSelectedEventArgs>): void;
removeEventListener(
type: "sourceselected",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToManager, Windows$Media$PlayTo$PlayToSourceSelectedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a Play To target.
 */
declare class Windows$Media$PlayTo$PlayToReceiver  {

/**
 * Creates a new instance of a Play To receiver.
 */
constructor(): this;

/**
 * Gets or sets the display name of the Play To target.
 */
friendlyName: string;

/**
 * Notifies the Play To receiver that the duration of the audio or video playback has changed.
 * @param duration The new duration of the audio or video media.
 */
notifyDurationChange(duration: number): void;

/**
 * Notifies the Play To receiver that the audio or video playback has ended.
 */
notifyEnded(): void;

/**
 * Notifies the Play To receiver that an error has occurred in displaying or playing the media.
 */
notifyError(): void;

/**
 * Notifies the Play To receiver that metadata for the media has finished loading.
 */
notifyLoadedMetadata(): void;

/**
 * Notifies the Play To receiver that the audio or video playback has been paused.
 */
notifyPaused(): void;

/**
 * Notifies the Play To receiver that the audio or video playback has started.
 */
notifyPlaying(): void;

/**
 * Notifies the Play To receiver that the rate of the audio or video playback has changed.
 * @param rate The new value of the playback rate.
 */
notifyRateChange(rate: number): void;

/**
 * Notifies the Play To receiver that the audio or video playback element has started at a new playback location.
 */
notifySeeked(): void;

/**
 * Notifies the Play To receiver that the audio or video playback element is seeking a new playback location.
 */
notifySeeking(): void;

/**
 * Notifies the Play To receiver that the audio or video playback has stopped.
 */
notifyStopped(): void;

/**
 * Notifies the Play To receiver that the time location of the audio or video playback has changed.
 * @param currentTime The new time location of the playback.
 */
notifyTimeUpdate(currentTime: number): void;

/**
 * Notifies the Play To receiver that the volume of the audio or video playback has changed.
 * @param volume The new value for the volume.
 * @param mute True if the volume was muted; otherwise false.
 */
notifyVolumeChange(volume: number, mute: boolean): void;

/**
 * Occurs when the time location of the playback has changed.
 */
oncurrenttimechangerequested: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, Windows$Media$PlayTo$CurrentTimeChangeRequestedEventArgs>;
addEventListener(
type: "currenttimechangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, Windows$Media$PlayTo$CurrentTimeChangeRequestedEventArgs>): void;
removeEventListener(
type: "currenttimechangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, Windows$Media$PlayTo$CurrentTimeChangeRequestedEventArgs>): void;

/**
 * Occurs when the audio has been muted or unmuted.
 */
onmutechangerequested: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, Windows$Media$PlayTo$MuteChangeRequestedEventArgs>;
addEventListener(
type: "mutechangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, Windows$Media$PlayTo$MuteChangeRequestedEventArgs>): void;
removeEventListener(
type: "mutechangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, Windows$Media$PlayTo$MuteChangeRequestedEventArgs>): void;

/**
 * Occurs when audio or video playback has been paused.
 */
onpauserequested: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, any>;
addEventListener(
type: "pauserequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, any>): void;
removeEventListener(
type: "pauserequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, any>): void;

/**
 * Occurs when the rate of audio or video playback has changed.
 */
onplaybackratechangerequested: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, any>;
addEventListener(
type: "playbackratechangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, any>): void;
removeEventListener(
type: "playbackratechangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, any>): void;

/**
 * Occurs when audio or video playback starts.
 */
onplayrequested: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, any>;
addEventListener(
type: "playrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, any>): void;
removeEventListener(
type: "playrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, any>): void;

/**
 * Occurs when the source media for the Play To receiver have changed.
 */
onsourcechangerequested: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, Windows$Media$PlayTo$SourceChangeRequestedEventArgs>;
addEventListener(
type: "sourcechangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, Windows$Media$PlayTo$SourceChangeRequestedEventArgs>): void;
removeEventListener(
type: "sourcechangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, Windows$Media$PlayTo$SourceChangeRequestedEventArgs>): void;

/**
 * Occurs when a request has been made for the Play To receiver to stop playing the streamed media.
 */
onstoprequested: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, any>;
addEventListener(
type: "stoprequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, any>): void;
removeEventListener(
type: "stoprequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, any>): void;

/**
 * Occurs when the current playback position has changed.
 */
ontimeupdaterequested: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, any>;
addEventListener(
type: "timeupdaterequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, any>): void;
removeEventListener(
type: "timeupdaterequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, any>): void;

/**
 * Occurs when the volume for the source audio or video has changed.
 */
onvolumechangerequested: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, Windows$Media$PlayTo$VolumeChangeRequestedEventArgs>;
addEventListener(
type: "volumechangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, Windows$Media$PlayTo$VolumeChangeRequestedEventArgs>): void;
removeEventListener(
type: "volumechangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$PlayTo$PlayToReceiver, Windows$Media$PlayTo$VolumeChangeRequestedEventArgs>): void;

/**
 * Gets a set of custom properties for the Play To receiver.
 */
properties: Windows$Foundation$Collections$IPropertySet;

/**
 * Start receiving Play To commands.
 * @return An asynchronous handler that's called when the start operation is complete.
 */
startAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Stop receiving Play To commands.
 * @return An asynchronous handler that's called when the stop operation is complete.
 */
stopAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets or sets a value that indicates whether the Play To target supports audio.
 */
supportsAudio: boolean;

/**
 * Gets or sets a value that indicates whether the Play To target supports images.
 */
supportsImage: boolean;

/**
 * Gets or sets a value that indicates whether the Play To target supports video.
 */
supportsVideo: boolean;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a media element to connect to a Play To target.
 */
declare class Windows$Media$PlayTo$PlayToSource  {

/**
 * Gets the connection to the Play To target.
 */
connection: Windows$Media$PlayTo$PlayToConnection;

/**
 * Gets or sets the next Play To source element.
 */
next: Windows$Media$PlayTo$PlayToSource;

/**
 * Connects the next Play To source element to the Play To target.
 */
playNext(): void;

/**
 * Specifies a preferred Uniform Resource Identifier (URI) for the media stream, such as a cloud based media server, used is used for Play To by reference.
 */
preferredSourceUri: Windows$Foundation$Uri
}


/**
 * Represents a deferred operation when you're supplying a source media element for Play To.
 */
declare class Windows$Media$PlayTo$PlayToSourceDeferral  {

/**
 * Ends the deferral.
 */
complete(): void
}


/**
 * Represents a request to connect a media element with a Play To target.
 */
declare class Windows$Media$PlayTo$PlayToSourceRequest  {

/**
 * Gets the time limit to supply the Play To source element.
 */
deadline: Date;

/**
 * Displays an error message in the Play To UI.
 * @param errorString The error message to display in the Play To UI.
 */
displayErrorString(errorString: string): void;

/**
 * Defers connecting a media source to a Play To target.
 * @return A deferral object that you can use to identify when the deferral is complete.
 */
getDeferral(): Windows$Media$PlayTo$PlayToSourceDeferral;

/**
 * Sets the source element to connect to the Play To target.
 * @param value The source element to connect to the Play To target.
 */
setSource(value: Windows$Media$PlayTo$PlayToSource): void
}


/**
 * Provides information about the SourceRequested event.
 */
declare class Windows$Media$PlayTo$PlayToSourceRequestedEventArgs  {

/**
 * Gets the media object to connect to a Play To target.
 */
sourceRequest: Windows$Media$PlayTo$PlayToSourceRequest
}


/**
 * Provides information about the SourceSelected event.
 */
declare class Windows$Media$PlayTo$PlayToSourceSelectedEventArgs  {

/**
 * Gets the display name of the selected Play To source.
 */
friendlyName: string;

/**
 * Gets the display icon for the selected Play To source.
 */
icon: Windows$Storage$Streams$IRandomAccessStreamWithContentType;

/**
 * Gets a value that indicates whether the selected Play To source supports audio.
 */
supportsAudio: boolean;

/**
 * Gets a value that indicates whether the selected Play To source supports displaying images.
 */
supportsImage: boolean;

/**
 * Gets a value that indicates whether the selected Play To source supports video.
 */
supportsVideo: boolean
}


/**
 * Provides information about the PlaybackRateChangeRequested event.
 */
declare class Windows$Media$PlayTo$PlaybackRateChangeRequestedEventArgs  {

/**
 * Gets the new playback rate.
 */
rate: number
}


/**
 * Provides information about the SourceChangeRequested event.
 */
declare class Windows$Media$PlayTo$SourceChangeRequestedEventArgs  {

/**
 * Gets the name of the album that contains the song in the audio stream.
 */
album: string;

/**
 * Gets the author of the content in the media stream.
 */
author: string;

/**
 * Gets the date that the content in the media stream was published.
 */
date: Date;

/**
 * Gets the description of the content in the media stream.
 */
description: string;

/**
 * Gets the names of the genres that the content in the media stream belongs to.
 */
genre: string;

/**
 * Gets custom property names and values for the content in the media stream.
 */
properties: Windows$Foundation$Collections$IMapView<string, any>;

/**
 * Gets the rating for the content in the media stream.
 */
rating: number;

/**
 * Gets the media stream for the Play To receiver.
 */
stream: Windows$Storage$Streams$IRandomAccessStreamWithContentType;

/**
 * Gets the thumbnail image for the content in the media stream.
 */
thumbnail: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets the title of the content in the media stream.
 */
title: string
}


/**
 * Provides information about the VolumeChangeRequested event.
 */
declare class Windows$Media$PlayTo$VolumeChangeRequestedEventArgs  {

/**
 * Gets the new volume level.
 */
volume: number
}


      declare var npm$namespace$Windows$Media$Playback: {
        
        ateChangeRequestedEventArgs: typeof Windows$Media$Playback$ateChangeRequestedEventArgs,
ositionChangeRequestedEventArgs: typeof Windows$Media$Playback$ositionChangeRequestedEventArgs,
        MediaPlaybackItemErrorCode: typeof Windows$Media$Playback$MediaPlaybackItemErrorCode,
MediaPlayerAudioCategory: typeof Windows$Media$Playback$MediaPlayerAudioCategory,
MediaPlayerAudioDeviceType: typeof Windows$Media$Playback$MediaPlayerAudioDeviceType,
MediaPlayerError: typeof Windows$Media$Playback$MediaPlayerError,
MediaPlayerState: typeof Windows$Media$Playback$MediaPlayerState,
TimedMetadataTrackPresentationMode: typeof Windows$Media$Playback$TimedMetadataTrackPresentationMode,
        BackgroundMediaPlayer: typeof Windows$Media$Playback$BackgroundMediaPlayer,
CurrentMediaPlaybackItemChangedEventArgs: typeof Windows$Media$Playback$CurrentMediaPlaybackItemChangedEventArgs,
MediaPlaybackAudioTrackList: typeof Windows$Media$Playback$MediaPlaybackAudioTrackList,
MediaPlaybackItem: typeof Windows$Media$Playback$MediaPlaybackItem,
MediaPlaybackItemError: typeof Windows$Media$Playback$MediaPlaybackItemError,
MediaPlaybackItemFailedEventArgs: typeof Windows$Media$Playback$MediaPlaybackItemFailedEventArgs,
MediaPlaybackItemOpenedEventArgs: typeof Windows$Media$Playback$MediaPlaybackItemOpenedEventArgs,
MediaPlaybackList: typeof Windows$Media$Playback$MediaPlaybackList,
MediaPlaybackTimedMetadataTrackList: typeof Windows$Media$Playback$MediaPlaybackTimedMetadataTrackList,
MediaPlaybackVideoTrackList: typeof Windows$Media$Playback$MediaPlaybackVideoTrackList,
MediaPlayer: typeof Windows$Media$Playback$MediaPlayer,
MediaPlayerDataReceivedEventArgs: typeof Windows$Media$Playback$MediaPlayerDataReceivedEventArgs,
MediaPlayerFailedEventArgs: typeof Windows$Media$Playback$MediaPlayerFailedEventArgs,
MediaPlayerRateChangedEventArgs: typeof Windows$Media$Playback$MediaPlayerRateChangedEventArgs,
PlaybackMediaMarker: typeof Windows$Media$Playback$PlaybackMediaMarker,
PlaybackMediaMarkerReachedEventArgs: typeof Windows$Media$Playback$PlaybackMediaMarkerReachedEventArgs,
PlaybackMediaMarkerSequence: typeof Windows$Media$Playback$PlaybackMediaMarkerSequence,
TimedMetadataPresentationModeChangedEventArgs: typeof Windows$Media$Playback$TimedMetadataPresentationModeChangedEventArgs,
        
      }

/**
 * Provides access to the media player while it is running in the background.
 */
declare class Windows$Media$Playback$BackgroundMediaPlayer  {

/**
 * Gets the current instance of the background media player.
 */
static current: Windows$Media$Playback$MediaPlayer;

/**
 * Returns a Boolean value indicating if other media is currently playing on the device.
 * @return Boolean value indicating if other media is currently playing on the device.
 */
static isMediaPlaying(): boolean;

/**
 * Occurs when a message is received from the background task.
 */
static onmessagereceivedfrombackground: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "messagereceivedfrombackground",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "messagereceivedfrombackground",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Occurs when a message is received from the foreground task.
 */
static onmessagereceivedfromforeground: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "messagereceivedfromforeground",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "messagereceivedfromforeground",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Sends a message to the background media player.
 * @param value Set of values representing the message.
 */
static sendMessageToBackground(value: Windows$Foundation$Collections$ValueSet): void;

/**
 * Sends a message to the foreground task.
 * @param value Set of values representing the message.
 */
static sendMessageToForeground(value: Windows$Foundation$Collections$ValueSet): void;

/**
 * Shuts down the current background media player.
 */
static shutdown(): void;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the MediaPlaybackList::CurrentItemChanged event.
 */
declare class Windows$Media$Playback$CurrentMediaPlaybackItemChangedEventArgs  {

/**
 * Gets the new current MediaPlaybackItem .
 */
newItem: Windows$Media$Playback$MediaPlaybackItem;

/**
 * Gets the previous current MediaPlaybackItem .
 */
oldItem: Windows$Media$Playback$MediaPlaybackItem
}


/**
 * Represents a read-only list of audio tracks, of which a single track can be selected at one time.
 */
declare class Windows$Media$Playback$MediaPlaybackAudioTrackList mixins Array<Windows$Media$Core$AudioTrack> {

/**
 * Returns an iterator that iterates over the items in the collection.
 * @return The iterator.
 */
first(): Windows$Foundation$Collections$IIterator<Windows$Media$Core$AudioTrack>;

/**
 * Returns the audio track at the specified index.
 * @param index The zero-based index of the audio track.
 * @return The audio track at the specified index.
 */
getAt(index: number): Windows$Media$Core$AudioTrack;

/**
 * Retrieves the audio tracks that start at the specified index in the list.
 * @param startIndex The zero-based index of the start of the audio tracks in the list.
 */
getMany(
startIndex: number): {
items: Windows$Media$Core$AudioTrack,
returnValue: number
};

/**
 * Retrieves the index of a specified audio track in the list.
 * @param value The audio track to find in the vector view.
 */
indexOf(value: Windows$Media$Core$AudioTrack): {
index: number,
returnValue: boolean
};

/**
 * Occurs when the index of the currently selected audio track changes.
 */
onselectedindexchanged: Windows$Foundation$TypedEventHandler<Windows$Media$Core$ISingleSelectMediaTrackList, any>;
addEventListener(
type: "selectedindexchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$ISingleSelectMediaTrackList, any>): void;
removeEventListener(
type: "selectedindexchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$ISingleSelectMediaTrackList, any>): void;

/**
 * Gets or sets the index of the currently selected audio track in the list.
 */
selectedIndex: number;

/**
 * Gets the number of audio tracks in the list.
 */
size: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
indexOf(
value: Windows$Media$Core$AudioTrack,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(searchElement: Windows$Media$Core$AudioTrack, fromIndex?: number): number
}


/**
 * Represents a media item that can be played back. This class acts as a wrapper around a MediaSource that exposes the audio tracks, video tracks, and timed metadata tracks included in the media source.
 */
declare class Windows$Media$Playback$MediaPlaybackItem  {
static findFromMediaSource: any;

/**
 * Initializes a new instance of the MediaPlaybackItem class.
 * @param source The media source from which the MediaPlaybackItem is created.
 */
constructor(source: Windows$Media$Core$MediaSource): this;

/**
 * Gets a read-only list of audio tracks in the MediaSource associated with the MediaPlaybackItem .
 */
audioTracks: Windows$Media$Playback$MediaPlaybackAudioTrackList;

/**
 * Occurs when the list of audio tracks in the MediaSource associated with the MediaPlaybackItem changes.
 */
onaudiotrackschanged: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackItem, Windows$Foundation$Collections$IVectorChangedEventArgs>;
addEventListener(
type: "audiotrackschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackItem, Windows$Foundation$Collections$IVectorChangedEventArgs>): void;
removeEventListener(
type: "audiotrackschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackItem, Windows$Foundation$Collections$IVectorChangedEventArgs>): void;

/**
 * Occurs when the list of timed metadata tracks in the MediaSource associated with the MediaPlaybackItem changes.
 */
ontimedmetadatatrackschanged: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackItem, Windows$Foundation$Collections$IVectorChangedEventArgs>;
addEventListener(
type: "timedmetadatatrackschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackItem, Windows$Foundation$Collections$IVectorChangedEventArgs>): void;
removeEventListener(
type: "timedmetadatatrackschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackItem, Windows$Foundation$Collections$IVectorChangedEventArgs>): void;

/**
 * Occurs when the list of video tracks in the MediaSource associated with the MediaPlaybackItem changes.
 */
onvideotrackschanged: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackItem, Windows$Foundation$Collections$IVectorChangedEventArgs>;
addEventListener(
type: "videotrackschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackItem, Windows$Foundation$Collections$IVectorChangedEventArgs>): void;
removeEventListener(
type: "videotrackschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackItem, Windows$Foundation$Collections$IVectorChangedEventArgs>): void;

/**
 * Gets the MediaSource object associated with the MediaPlaybackItem .
 */
source: Windows$Media$Core$MediaSource;

/**
 * Gets a read-only list of timed metadata tracks in the MediaSource associated with the MediaPlaybackItem .
 */
timedMetadataTracks: Windows$Media$Playback$MediaPlaybackTimedMetadataTrackList;

/**
 * Gets a read-only list of video tracks in the MediaSource associated with the MediaPlaybackItem .
 */
videoTracks: Windows$Media$Playback$MediaPlaybackVideoTrackList;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents an error that occurred trying to resolve a MediaPlaybackItem .
 */
declare class Windows$Media$Playback$MediaPlaybackItemError  {

/**
 * Gets the error code associated with the playback item error.
 */
errorCode: $Values<typeof Windows$Media$Playback$MediaPlaybackItemErrorCode>;

/**
 * Gets the extended error code for the MediaPlaybackItem error.
 */
extendedError: Windows$WinRTError
}


/**
 * Specifies the type of error that occurred while opening a MediaPlaybackItem .
 */

declare  var Windows$Media$Playback$MediaPlaybackItemErrorCode: {|
  +none: 0,// 0
+aborted: 1,// 1
+networkError: 2,// 2
+decodeError: 3,// 3
+sourceNotSupportedError: 4,// 4
+encryptionError: 5,// 5

|};



/**
 * Provides data for the MediaPlaybackList::ItemFailed event.
 */
declare class Windows$Media$Playback$MediaPlaybackItemFailedEventArgs  {

/**
 * Gets a wrapper object for the MediaPlaybackItem error that provides high-level information about the cause of the error.
 */
error: Windows$Media$Playback$MediaPlaybackItemError;

/**
 * Gets the MediaPlaybackItem associated with the error.
 */
item: Windows$Media$Playback$MediaPlaybackItem
}


/**
 * Provides data for the MediaPlaybackList::ItemOpened event.
 */
declare class Windows$Media$Playback$MediaPlaybackItemOpenedEventArgs  {

/**
 * Gets the MediaPlaybackItem that was successfully opened.
 */
item: Windows$Media$Playback$MediaPlaybackItem
}


/**
 * Represents a list of MediaPlaybackItem objects that can be played back. Provides methods for switching the currently playing item and enabling looping and shuffling.
 */
declare class Windows$Media$Playback$MediaPlaybackList  {

/**
 * Initializes a new instance of the MediaPlaybackList class.
 */
constructor(): this;

/**
 * Gets or sets a value indicating whether the playback list will loop when the end of the list is reached.
 */
autoRepeatEnabled: boolean;

/**
 * Gets the currently playing MediaPlaybackItem .
 */
currentItem: Windows$Media$Playback$MediaPlaybackItem;

/**
 * Gets the index of the current item in the MediaPlaybackList .
 */
currentItemIndex: number;

/**
 * Gets an IObservableVector representation of the playback list.
 */
items: Windows$Foundation$Collections$IObservableVector<Windows$Media$Playback$MediaPlaybackItem>;

/**
 * Gets or sets the maximum time before a MediaPlaybackItem in the list is expected to play that the media content associated with the item is retrieved.
 */
maxPrefetchTime: number;

/**
 * Changes the current item of the MediaPlaybackList to the next item in the list.
 * @return The new current MediaPlaybackItem .
 */
moveNext(): Windows$Media$Playback$MediaPlaybackItem;

/**
 * Changes the current item of the MediaPlaybackList to the previous item in the list.
 * @return The new current MediaPlaybackItem .
 */
movePrevious(): Windows$Media$Playback$MediaPlaybackItem;

/**
 * Changes the current item of the MediaPlaybackList to the item with the specified index.
 * @param itemIndex The index of the item to make current.
 * @return The new current MediaPlaybackItem .
 */
moveTo(itemIndex: number): Windows$Media$Playback$MediaPlaybackItem;

/**
 * Occurs when the currently playing MediaPlaybackItem changes.
 */
oncurrentitemchanged: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackList, Windows$Media$Playback$CurrentMediaPlaybackItemChangedEventArgs>;
addEventListener(
type: "currentitemchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackList, Windows$Media$Playback$CurrentMediaPlaybackItemChangedEventArgs>): void;
removeEventListener(
type: "currentitemchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackList, Windows$Media$Playback$CurrentMediaPlaybackItemChangedEventArgs>): void;

/**
 * Occurs when an error is encountered with a MediaPlaybackItem in the playback list.
 */
onitemfailed: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackList, Windows$Media$Playback$MediaPlaybackItemFailedEventArgs>;
addEventListener(
type: "itemfailed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackList, Windows$Media$Playback$MediaPlaybackItemFailedEventArgs>): void;
removeEventListener(
type: "itemfailed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackList, Windows$Media$Playback$MediaPlaybackItemFailedEventArgs>): void;

/**
 * Occurs when a MediaPlaybackItem in the playback list is successfully opened.
 */
onitemopened: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackList, Windows$Media$Playback$MediaPlaybackItemOpenedEventArgs>;
addEventListener(
type: "itemopened",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackList, Windows$Media$Playback$MediaPlaybackItemOpenedEventArgs>): void;
removeEventListener(
type: "itemopened",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackList, Windows$Media$Playback$MediaPlaybackItemOpenedEventArgs>): void;

/**
 * Sets the list of MediaPlaybackItem objects that will be played in shuffle mode, in the order in which they will be played.
 * @param value The list of MediaPlaybackItem objects that will be played in shuffle mode.
 */
setShuffledItems(
value: Windows$Foundation$Collections$IIterable<Windows$Media$Playback$MediaPlaybackItem>): void;

/**
 * Gets or sets a value indicating whether the items in the playback list are played in a random order.
 */
shuffleEnabled: boolean;

/**
 * Gets a read-only list of of MediaPlaybackItem objects that will be played in shuffle mode, in the order in which they will be played.
 */
shuffledItems: Windows$Foundation$Collections$IVectorView<Windows$Media$Playback$MediaPlaybackItem>;

/**
 * Gets or sets the MediaPlaybackItem that will be played first.
 */
startingItem: Windows$Media$Playback$MediaPlaybackItem;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a read-only list of timed metadata tracks.
 */
declare class Windows$Media$Playback$MediaPlaybackTimedMetadataTrackList mixins Array<Windows$Media$Core$TimedMetadataTrack> {

/**
 * Returns an iterator that iterates over the items in the collection.
 * @return The iterator.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Media$Core$TimedMetadataTrack>;

/**
 * Returns the timed metadata track at the specified index.
 * @param index The zero-based index of the timed metadata track.
 * @return The timed metadata track at the specified index.
 */
getAt(index: number): Windows$Media$Core$TimedMetadataTrack;

/**
 * Retrieves the timed metadata tracks that start at the specified index in the list.
 * @param startIndex The zero-based index of the start of the timed metadata tracks in the list.
 */
getMany(
startIndex: number): {
items: Windows$Media$Core$TimedMetadataTrack,
returnValue: number
};

/**
 * Gets the presentation mode of the timed metadata track with the specified index.
 * @param index The index of the timed metadata track for which the presentation mode is queried.
 * @return The presentation mode.
 */
getPresentationMode(
index: number): $Values<typeof Windows$Media$Playback$TimedMetadataTrackPresentationMode>;

/**
 * Retrieves the index of a specified timed metadata track in the list.
 * @param value The timed metadata track to find in the vector view.
 */
indexOf(
value: Windows$Media$Core$TimedMetadataTrack): {
index: number,
returnValue: boolean
};

/**
 * Occurs when the presentation mode of the MediaPlaybackTimedMetadataTrackList changes.
 */
onpresentationmodechanged: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackTimedMetadataTrackList, Windows$Media$Playback$TimedMetadataPresentationModeChangedEventArgs>;
addEventListener(
type: "presentationmodechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackTimedMetadataTrackList, Windows$Media$Playback$TimedMetadataPresentationModeChangedEventArgs>): void;
removeEventListener(
type: "presentationmodechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlaybackTimedMetadataTrackList, Windows$Media$Playback$TimedMetadataPresentationModeChangedEventArgs>): void;

/**
 * Sets the presentation mode of the timed metadata track with the specified index.
 * @param index The index of the timed metadata track for which the presentation mode is set.
 * @param value The presentation mode to set.
 */
setPresentationMode(
index: number,
value: $Values<typeof Windows$Media$Playback$TimedMetadataTrackPresentationMode>): void;

/**
 * Gets the number of timed metadata tracks in the list.
 */
size: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
indexOf(
value: Windows$Media$Core$TimedMetadataTrack,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Media$Core$TimedMetadataTrack,
fromIndex?: number): number
}


/**
 * Represents a read-only list of video tracks, of which a single track can be selected at one time.
 */
declare class Windows$Media$Playback$MediaPlaybackVideoTrackList mixins Array<Windows$Media$Core$VideoTrack> {

/**
 * Returns an iterator that iterates over the items in the collection.
 * @return The iterator.
 */
first(): Windows$Foundation$Collections$IIterator<Windows$Media$Core$VideoTrack>;

/**
 * Returns the video track at the specified index.
 * @param index The zero-based index of the video track.
 * @return The video track at the specified index.
 */
getAt(index: number): Windows$Media$Core$VideoTrack;

/**
 * Retrieves the video tracks that start at the specified index in the list.
 * @param startIndex The zero-based index of the start of the video tracks in the list.
 */
getMany(
startIndex: number): {
items: Windows$Media$Core$VideoTrack,
returnValue: number
};

/**
 * Retrieves the index of a specified video track in the list.
 * @param value The video track to find in the vector view.
 */
indexOf(value: Windows$Media$Core$VideoTrack): {
index: number,
returnValue: boolean
};

/**
 * Occurs when the index of the currently selected video track changes.
 */
onselectedindexchanged: Windows$Foundation$TypedEventHandler<Windows$Media$Core$ISingleSelectMediaTrackList, any>;
addEventListener(
type: "selectedindexchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$ISingleSelectMediaTrackList, any>): void;
removeEventListener(
type: "selectedindexchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Core$ISingleSelectMediaTrackList, any>): void;

/**
 * Gets or sets the index of the currently selected video track in the list.
 */
selectedIndex: number;

/**
 * Gets the number of video tracks in the list.
 */
size: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
indexOf(
value: Windows$Media$Core$VideoTrack,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(searchElement: Windows$Media$Core$VideoTrack, fromIndex?: number): number
}


/**
 * Provides access to media playback functionality such as play, pause, fast-forward, rewind, and volume.
 */
declare class Windows$Media$Playback$MediaPlayer  {

/**
 * Adds an audio effect to the playback stream of the MediaPlayer .
 * @param activatableClassId The activatable class ID of the audio effect to add to the playback stream.
 * @param effectOptional A value indicating whether the effect is optional.
 * @param configuration A property set containing configuration settings for the specified audio effect.
 */
addAudioEffect(
activatableClassId: string,
effectOptional: boolean,
configuration: Windows$Foundation$Collections$IPropertySet): void;

/**
 * Gets or sets the type of audio that is currently being played.
 */
audioCategory: $Values<typeof Windows$Media$Playback$MediaPlayerAudioCategory>;

/**
 * Gets or sets a value that describes the primary usage of the device that is being used to play back audio.
 */
audioDeviceType: $Values<typeof Windows$Media$Playback$MediaPlayerAudioDeviceType>;

/**
 * Gets or sets a Boolean value indicating if playback automatically starts after the media is loaded.
 */
autoPlay: boolean;

/**
 * Gets the amount of buffering that is completed for the media content, expressed as a percentage.
 */
bufferingProgress: number;

/**
 * Gets a Boolean value indicating if the media can be paused.
 */
canPause: boolean;

/**
 * Gets a Boolean value indicating if the media supports seeking to a specific position.
 */
canSeek: boolean;

/**
 * Gets the current state of media playback.
 */
currentState: $Values<typeof Windows$Media$Playback$MediaPlayerState>;

/**
 * Gets or sets a Boolean value indicating if the media will playback in a repeating loop.
 */
isLoopingEnabled: boolean;

/**
 * Gets or sets a Boolean value indicating if the audio is muted.
 */
isMuted: boolean;

/**
 * Gets a Boolean value indicating if the content is protected by a digital rights management system.
 */
isProtected: boolean;

/**
 * Get the actual duration of the media without applying the PlaybackRate .
 */
naturalDuration: number;

/**
 * Occurs when buffering has finished.
 */
onbufferingended: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>;
addEventListener(
type: "bufferingended",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>): void;
removeEventListener(
type: "bufferingended",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>): void;

/**
 * Occurs when buffering has started.
 */
onbufferingstarted: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>;
addEventListener(
type: "bufferingstarted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>): void;
removeEventListener(
type: "bufferingstarted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>): void;

/**
 * Occurs when the state of the media player has changed.
 */
oncurrentstatechanged: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>;
addEventListener(
type: "currentstatechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>): void;
removeEventListener(
type: "currentstatechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>): void;

/**
 * Occurs when the media has finished playback.
 */
onmediaended: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>;
addEventListener(
type: "mediaended",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>): void;
removeEventListener(
type: "mediaended",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>): void;

/**
 * Occurs when an error is encountered.
 */
onmediafailed: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, Windows$Media$Playback$MediaPlayerFailedEventArgs>;
addEventListener(
type: "mediafailed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, Windows$Media$Playback$MediaPlayerFailedEventArgs>): void;
removeEventListener(
type: "mediafailed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, Windows$Media$Playback$MediaPlayerFailedEventArgs>): void;

/**
 * Occurs when the media is opened.
 */
onmediaopened: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>;
addEventListener(
type: "mediaopened",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>): void;
removeEventListener(
type: "mediaopened",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>): void;

/**
 * Occurs when the media playback rate has changed.
 */
onmediaplayerratechanged: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, Windows$Media$Playback$MediaPlayerRateChangedEventArgs>;
addEventListener(
type: "mediaplayerratechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, Windows$Media$Playback$MediaPlayerRateChangedEventArgs>): void;
removeEventListener(
type: "mediaplayerratechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, Windows$Media$Playback$MediaPlayerRateChangedEventArgs>): void;

/**
 * Occurs when a media marker has been reached during playback.
 */
onplaybackmediamarkerreached: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, Windows$Media$Playback$PlaybackMediaMarkerReachedEventArgs>;
addEventListener(
type: "playbackmediamarkerreached",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, Windows$Media$Playback$PlaybackMediaMarkerReachedEventArgs>): void;
removeEventListener(
type: "playbackmediamarkerreached",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, Windows$Media$Playback$PlaybackMediaMarkerReachedEventArgs>): void;

/**
 * Occurs when a seek operation has finished.
 */
onseekcompleted: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>;
addEventListener(
type: "seekcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>): void;
removeEventListener(
type: "seekcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>): void;

/**
 * Occurs when the volume of the audio has changed.
 */
onvolumechanged: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>;
addEventListener(
type: "volumechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>): void;
removeEventListener(
type: "volumechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Playback$MediaPlayer, any>): void;

/**
 * Pauses media playback.
 */
pause(): void;

/**
 * Starts media playback.
 */
play(): void;

/**
 * Gets the collection of timeline markers for the media.
 */
playbackMediaMarkers: Windows$Media$Playback$PlaybackMediaMarkerSequence;

/**
 * Gets or sets the playback rate, expressed as a percentage.
 */
playbackRate: number;

/**
 * Gets or sets the playback position within the media.
 */
position: number;

/**
 * Gets or sets the content protection manager for the media.
 */
protectionManager: Windows$Media$Protection$MediaProtectionManager;

/**
 * Removes all effects from the playback stream of the MediaPlayer .
 */
removeAllEffects(): void;

/**
 * Set the media source to a file.
 * @param file The media source file.
 */
setFileSource(file: Windows$Storage$IStorageFile): void;

/**
 * Sets the media source for playback.
 * @param source The media source for playback.
 */
setMediaSource(source: Windows$Media$Core$IMediaSource): void;

/**
 * Sets the media source to a stream.
 * @param stream The media source stream.
 */
setStreamSource(stream: Windows$Storage$Streams$IRandomAccessStream): void;

/**
 * Sets the path to the media.
 * @param value The path to the media.
 */
setUriSource(value: Windows$Foundation$Uri): void;

/**
 * Sets the playback source of the media player.
 */
source: Windows$Media$Playback$IMediaPlaybackSource;

/**
 * Gets an instance of the SystemMediaTransportControls class to enable user control of playback of the MediaPlayer and to allow the app to show information about the currently playing content in the system UI.
 */
systemMediaTransportControls: Windows$Media$SystemMediaTransportControls;

/**
 * Get or sets the audio volume for media playback.
 */
volume: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies the types of audio that can be played by a media player.
 */

declare  var Windows$Media$Playback$MediaPlayerAudioCategory: {|
  +other: 0,// 0
+communications: 1,// 1
+alerts: 2,// 2
+soundEffects: 3,// 3
+gameEffects: 4,// 4
+gameMedia: 5,// 5
+gameChat: 6,// 6
+speech: 7,// 7
+movie: 8,// 8
+media: 9,// 9

|};



/**
 * Describes the primary usage of the device that is being used to play back audio. This value is used by MediaPlayer::AudioDeviceType .
 */

declare  var Windows$Media$Playback$MediaPlayerAudioDeviceType: {|
  +console: 0,// 0
+multimedia: 1,// 1
+communications: 2,// 2

|};



/**
 * Provides data for the MessageReceivedFromBackground and MessageReceivedFromForeground events.
 */
declare class Windows$Media$Playback$MediaPlayerDataReceivedEventArgs  {

/**
 * Gets the data from the MessageReceivedFromBackground or MessageReceivedFromForeground event.
 */
data: Windows$Foundation$Collections$IMap<string, string>
}


/**
 * Indicates possible media player errors.
 */

declare  var Windows$Media$Playback$MediaPlayerError: {|
  +unknown: 0,// 0
+aborted: 1,// 1
+networkError: 2,// 2
+decodingError: 3,// 3
+sourceNotSupported: 4,// 4

|};



/**
 * Provides the data for MediaFailed events.
 */
declare class Windows$Media$Playback$MediaPlayerFailedEventArgs  {

/**
 * Gets the MediaPlayerError value for the error that triggered the event.
 */
error: $Values<typeof Windows$Media$Playback$MediaPlayerError>;

/**
 * Gets a string describing the error that occurred.
 */
errorMessage: string;

/**
 * Gets an HResult that indicates any extra data about the error that occurred.
 */
extendedErrorCode: Windows$WinRTError
}


/**
 * Provides the data for MediaPlayerRateChanged events.
 */
declare class Windows$Media$Playback$MediaPlayerRateChangedEventArgs  {

/**
 * Gets the new playback rate for the media.
 */
newRate: number
}


/**
 * Indicates the possible states that the player can be in.
 */

declare  var Windows$Media$Playback$MediaPlayerState: {|
  +closed: 0,// 0
+opening: 1,// 1
+buffering: 2,// 2
+playing: 3,// 3
+paused: 4,// 4
+stopped: 5,// 5

|};



/**
 * Represents a marker at specific location in a media stream time-line.
 */
declare class Windows$Media$Playback$PlaybackMediaMarker  {

/**
 * Initializes a new instance of the PlaybackMediaMarker class with the specified offset into the media timeline, type string, and text.
 * @param value The media marker's offset into the media timeline.
 * @param mediaMarketType The type of the media marker.
 * @param text The text of the media marker.
 */
constructor(value: number, mediaMarketType: string, text: string): this;

/**
 * Initializes a new instance of the PlaybackMediaMarker class with the specified offset into the media timeline.
 * @param value The media marker's offset into the media timeline.
 */
constructor(value: number): this;

/**
 * Gets the type of the media marker.
 */
mediaMarkerType: string;

/**
 * Gets the text associated with the marker.
 */
text: string;

/**
 * Gets the offset in the media timeline where the marker occurs.
 */
time: number
}


/**
 * Provides data for PlaybackMediaMarkerReached events.
 */
declare class Windows$Media$Playback$PlaybackMediaMarkerReachedEventArgs  {

/**
 * Gets the PlaybackMediaMarker that was reached.
 */
playbackMediaMarker: Windows$Media$Playback$PlaybackMediaMarker
}


/**
 * An ordered collection of PlaybackMediaMarker objects.
 */
declare class Windows$Media$Playback$PlaybackMediaMarkerSequence  {

/**
 * Initializes a new instance of the PlaybackMediaMarkerSequence class.
 */
constructor(): this;

/**
 * Removes all elements from the sequence.
 */
clear(): void;

/**
 * Gets an IIterator pointing at the first PlaybackMediaMarker in the sequence.
 * @return Iterator pointing at the first media marker in the sequence.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Media$Playback$PlaybackMediaMarker>;

/**
 * Adds a PlaybackMediaMarker to the sequence in it's ordered position.
 * @param value The media marker to insert into the sequence.
 */
insert(value: Windows$Media$Playback$PlaybackMediaMarker): void;

/**
 * Returns the number of items in the sequence.
 */
size: number
}


/**
 * Provides data for the MediaPlaybackTimedMetadataTrackList::PresentationModeChanged event.
 */
declare class Windows$Media$Playback$TimedMetadataPresentationModeChangedEventArgs  {

/**
 * Gets the new presentation mode.
 */
newPresentationMode: $Values<typeof Windows$Media$Playback$TimedMetadataTrackPresentationMode>;

/**
 * Gets the old presentation mode.
 */
oldPresentationMode: $Values<typeof Windows$Media$Playback$TimedMetadataTrackPresentationMode>;

/**
 * Gets the TimedMetadataTrack associated with the presentation mode change.
 */
track: Windows$Media$Core$TimedMetadataTrack
}


/**
 * Specifies the presentation mode of a timed metadata track.
 */

declare  var Windows$Media$Playback$TimedMetadataTrackPresentationMode: {|
  +disabled: 0,// 0
+hidden: 1,// 1
+applicationPresented: 2,// 2
+platformPresented: 3,// 3

|};


declare var Windows$Media$Playback$ateChangeRequestedEventArgs: any;

declare var Windows$Media$Playback$ositionChangeRequestedEventArgs: any;


/**
 * A marker interface that identifies the implementing class as a playback source.
 */
declare interface Windows$Media$Playback$IMediaPlaybackSource {} 


/**
 * Provides data for the PlaybackPositionChangeRequested event.
 */
declare class Windows$Media$PlaybackPositionChangeRequestedEventArgs  {

/**
 * Gets a value indicating the requested offset into the media item.
 */
requestedPlaybackPosition: number
}


/**
 * Provides data for the PlaybackRateChangeRequested event.
 */
declare class Windows$Media$PlaybackRateChangeRequestedEventArgs  {

/**
 * Gets the requested playback rate.
 */
requestedPlaybackRate: number
}


      declare var npm$namespace$Windows$Media$Playlists: {
        
        
        PlaylistFormat: typeof Windows$Media$Playlists$PlaylistFormat,
        Playlist: typeof Windows$Media$Playlists$Playlist,
        
      }

/**
 * Provides access to a media playlist.
 */
declare class Windows$Media$Playlists$Playlist  {

/**
 * Asynchronously loads files into a playlist.
 * @param file Represents the files to load.
 * @return Represents the asynchronous operation for loading the playlist. The GetResults method of this IAsyncOperation object returns the playlist.
 */
static loadAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Playlists$Playlist>;

/**
 * Creates a new instance of a Playlist object.
 */
constructor(): this;

/**
 * The set of media files that make up the playlist.
 */
files: Windows$Foundation$Collections$IVector<Windows$Storage$StorageFile>;

/**
 * Asynchronously saves the playlist to a specified file and folder, in a specified format.
 * @param saveLocation The folder in which to save the playlist.
 * @param desiredName The name of the playlist to save.
 * @param option The action to take if the playlist is saved to an existing file. One of the values of the NameCollisionOption enumeration.
 * @param playlistFormat The playlist format. One of the values of the PlaylistFormat enumeration.
 * @return Represents the asynchronous operation to save the playlist to a specified file and folder.
 */
saveAsAsync(
saveLocation: Windows$Storage$IStorageFolder,
desiredName: string,
option: $Values<typeof Windows$Storage$NameCollisionOption>,
playlistFormat: $Values<typeof Windows$Media$Playlists$PlaylistFormat>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Asynchronously saves the playlist to a specified file and folder.
 * @param saveLocation The folder in which to save the playlist.
 * @param desiredName The name of the playlist to save.
 * @param option The action to take if the playlist is saved to an existing file. One of the values of the NameCollisionOption enumeration.
 * @return Represents the asynchronous operation to save the playlist to a specified file and folder.
 */
saveAsAsync(
saveLocation: Windows$Storage$IStorageFolder,
desiredName: string,
option: $Values<typeof Windows$Storage$NameCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Asynchronously saves the playlist.
 * @return Represents the asynchronous action to save the playlist.
 */
saveAsync(): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Indicates the format of a playlist file.
 */

declare  var Windows$Media$Playlists$PlaylistFormat: {|
  +windowsMedia: 0,// 0
+zune: 1,// 1
+m3u: 2,// 2

|};



      declare var npm$namespace$Windows$Media$Protection: {
        
        
        RenewalStatus: typeof Windows$Media$Protection$RenewalStatus,
RevocationAndRenewalReasons: typeof Windows$Media$Protection$RevocationAndRenewalReasons,
        ComponentLoadFailedEventArgs: typeof Windows$Media$Protection$ComponentLoadFailedEventArgs,
ComponentRenewal: typeof Windows$Media$Protection$ComponentRenewal,
MediaProtectionManager: typeof Windows$Media$Protection$MediaProtectionManager,
MediaProtectionPMPServer: typeof Windows$Media$Protection$MediaProtectionPMPServer,
MediaProtectionServiceCompletion: typeof Windows$Media$Protection$MediaProtectionServiceCompletion,
ProtectionCapabilities: typeof Windows$Media$Protection$ProtectionCapabilities,
RevocationAndRenewalInformation: typeof Windows$Media$Protection$RevocationAndRenewalInformation,
RevocationAndRenewalItem: typeof Windows$Media$Protection$RevocationAndRenewalItem,
ServiceRequestedEventArgs: typeof Windows$Media$Protection$ServiceRequestedEventArgs,
        PlayReady: typeof npm$namespace$Windows$Media$Protection$PlayReady,
ProtectionCapabilityResult: typeof npm$namespace$Windows$Media$Protection$ProtectionCapabilityResult,
      }

/**
 * Contains event data for a MediaProtectionManager object when the load of binary data fails.
 */
declare class Windows$Media$Protection$ComponentLoadFailedEventArgs  {

/**
 * Returns an indication of the completion of the event.
 */
completion: Windows$Media$Protection$MediaProtectionServiceCompletion;

/**
 * Returns a list of components in the RevocationAndRenewalInformation object that need to be revoked and renewed with updated components.
 */
information: Windows$Media$Protection$RevocationAndRenewalInformation
}


/**
 * Enables applications to initiate renewal of components which need updating in order to play protected media content.
 */
declare class Windows$Media$Protection$ComponentRenewal  {

/**
 * Initiates updating of critical content protection components after prompting the user.
 * @param information Revocation and renewal information.
 * @return An object that is used to control the asynchronous operation.
 */
static renewSystemComponentsAsync(
information: Windows$Media$Protection$RevocationAndRenewalInformation): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<$Values<typeof Windows$Media$Protection$RenewalStatus>, number>
}


/**
 * Contains a content protection manager object, for an application that handles protected media content.
 */
declare class Windows$Media$Protection$MediaProtectionManager  {

/**
 * Initializes a new instance of the MediaProtectionManager class.
 */
constructor(): this;

/**
 * Fires when the load of binary data fails.
 */
oncomponentloadfailed: Windows$Media$Protection$ComponentLoadFailedEventHandler;
addEventListener(
type: "componentloadfailed",
listener: Windows$Media$Protection$ComponentLoadFailedEventHandler): void;
removeEventListener(
type: "componentloadfailed",
listener: Windows$Media$Protection$ComponentLoadFailedEventHandler): void;

/**
 * Fires when a reboot is needed after the component is renewed.
 */
onrebootneeded: Windows$Media$Protection$RebootNeededEventHandler;
addEventListener(
type: "rebootneeded",
listener: Windows$Media$Protection$RebootNeededEventHandler): void;
removeEventListener(
type: "rebootneeded",
listener: Windows$Media$Protection$RebootNeededEventHandler): void;

/**
 * Fires when a service is requested.
 */
onservicerequested: Windows$Media$Protection$ServiceRequestedEventHandler;
addEventListener(
type: "servicerequested",
listener: Windows$Media$Protection$ServiceRequestedEventHandler): void;
removeEventListener(
type: "servicerequested",
listener: Windows$Media$Protection$ServiceRequestedEventHandler): void;

/**
 * Gets a PropertySet object containing any properties attached to the protection manager.
 */
properties: Windows$Foundation$Collections$IPropertySet;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a Protected Media Path (PMP) server to enable playback of protected content using digital rights management (DRM).
 */
declare class Windows$Media$Protection$MediaProtectionPMPServer  {

/**
 * Initializes a new instance of the MediaProtectionPMPServer class with the specified properties.
 * @param pProperties The set of properties used to initialize the server.
 */
constructor(pProperties: Windows$Foundation$Collections$IPropertySet): this;

/**
 * Gets the property set for the MediaProtectionPMPServer .
 */
properties: Windows$Foundation$Collections$IPropertySet
}


/**
 * Contains a method that indicates whether a protection service has completed successfully.
 */
declare class Windows$Media$Protection$MediaProtectionServiceCompletion  {

/**
 * Indicates whether a protection service has completed successfully.
 * @param success Indicates the successful completion of a protection service.
 */
complete(success: boolean): void
}


      declare var npm$namespace$Windows$Media$Protection$PlayReady: {
        
        
        NDCertificateFeature: typeof Windows$Media$Protection$PlayReady$NDCertificateFeature,
NDCertificatePlatformID: typeof Windows$Media$Protection$PlayReady$NDCertificatePlatformID,
NDCertificateType: typeof Windows$Media$Protection$PlayReady$NDCertificateType,
NDClosedCaptionFormat: typeof Windows$Media$Protection$PlayReady$NDClosedCaptionFormat,
NDContentIDType: typeof Windows$Media$Protection$PlayReady$NDContentIDType,
NDMediaStreamType: typeof Windows$Media$Protection$PlayReady$NDMediaStreamType,
NDProximityDetectionType: typeof Windows$Media$Protection$PlayReady$NDProximityDetectionType,
NDStartAsyncOptions: typeof Windows$Media$Protection$PlayReady$NDStartAsyncOptions,
PlayReadyDecryptorSetup: typeof Windows$Media$Protection$PlayReady$PlayReadyDecryptorSetup,
PlayReadyEncryptionAlgorithm: typeof Windows$Media$Protection$PlayReady$PlayReadyEncryptionAlgorithm,
PlayReadyHardwareDRMFeatures: typeof Windows$Media$Protection$PlayReady$PlayReadyHardwareDRMFeatures,
PlayReadyITADataFormat: typeof Windows$Media$Protection$PlayReady$PlayReadyITADataFormat,
        NDClient: typeof Windows$Media$Protection$PlayReady$NDClient,
NDCustomData: typeof Windows$Media$Protection$PlayReady$NDCustomData,
NDDownloadEngineNotifier: typeof Windows$Media$Protection$PlayReady$NDDownloadEngineNotifier,
NDLicenseFetchDescriptor: typeof Windows$Media$Protection$PlayReady$NDLicenseFetchDescriptor,
NDStorageFileHelper: typeof Windows$Media$Protection$PlayReady$NDStorageFileHelper,
NDStreamParserNotifier: typeof Windows$Media$Protection$PlayReady$NDStreamParserNotifier,
NDTCPMessenger: typeof Windows$Media$Protection$PlayReady$NDTCPMessenger,
PlayReadyContentHeader: typeof Windows$Media$Protection$PlayReady$PlayReadyContentHeader,
PlayReadyContentResolver: typeof Windows$Media$Protection$PlayReady$PlayReadyContentResolver,
PlayReadyDomain: typeof Windows$Media$Protection$PlayReady$PlayReadyDomain,
PlayReadyDomainIterable: typeof Windows$Media$Protection$PlayReady$PlayReadyDomainIterable,
PlayReadyDomainIterator: typeof Windows$Media$Protection$PlayReady$PlayReadyDomainIterator,
PlayReadyDomainJoinServiceRequest: typeof Windows$Media$Protection$PlayReady$PlayReadyDomainJoinServiceRequest,
PlayReadyDomainLeaveServiceRequest: typeof Windows$Media$Protection$PlayReady$PlayReadyDomainLeaveServiceRequest,
PlayReadyITADataGenerator: typeof Windows$Media$Protection$PlayReady$PlayReadyITADataGenerator,
PlayReadyIndividualizationServiceRequest: typeof Windows$Media$Protection$PlayReady$PlayReadyIndividualizationServiceRequest,
PlayReadyLicense: typeof Windows$Media$Protection$PlayReady$PlayReadyLicense,
PlayReadyLicenseAcquisitionServiceRequest: typeof Windows$Media$Protection$PlayReady$PlayReadyLicenseAcquisitionServiceRequest,
PlayReadyLicenseIterable: typeof Windows$Media$Protection$PlayReady$PlayReadyLicenseIterable,
PlayReadyLicenseIterator: typeof Windows$Media$Protection$PlayReady$PlayReadyLicenseIterator,
PlayReadyLicenseManagement: typeof Windows$Media$Protection$PlayReady$PlayReadyLicenseManagement,
PlayReadyLicenseSession: typeof Windows$Media$Protection$PlayReady$PlayReadyLicenseSession,
PlayReadyMeteringReportServiceRequest: typeof Windows$Media$Protection$PlayReady$PlayReadyMeteringReportServiceRequest,
PlayReadyRevocationServiceRequest: typeof Windows$Media$Protection$PlayReady$PlayReadyRevocationServiceRequest,
PlayReadySecureStopIterable: typeof Windows$Media$Protection$PlayReady$PlayReadySecureStopIterable,
PlayReadySecureStopIterator: typeof Windows$Media$Protection$PlayReady$PlayReadySecureStopIterator,
PlayReadySecureStopServiceRequest: typeof Windows$Media$Protection$PlayReady$PlayReadySecureStopServiceRequest,
PlayReadySoapMessage: typeof Windows$Media$Protection$PlayReady$PlayReadySoapMessage,
PlayReadyStatics: typeof Windows$Media$Protection$PlayReady$PlayReadyStatics,
        
      }

/**
 * Indicates the PlayReady-ND feature to which the certificate controls access.
 */

declare  var Windows$Media$Protection$PlayReady$NDCertificateFeature: {|
  +transmitter: 0,// 0
+receiver: 1,// 1
+sharedCertificate: 2,// 2
+secureClock: 3,// 3
+antiRollBackClock: 4,// 4
+crls: 5,// 5
+playReady3Features: 6,// 6

|};



/**
 * Indicates the client platforms with which a PlayReady-ND certificate can be associated.
 */

declare  var Windows$Media$Protection$PlayReady$NDCertificatePlatformID: {|
  +windows: 0,// 0
+osx: 1,// 1
+windowsOnARM: 2,// 2
+windowsMobile7: 3,// 3
+iOSOnARM: 4,// 4
+xboxOnPPC: 5,// 5
+windowsPhone8OnARM: 6,// 6
+windowsPhone8OnX86: 7,// 7
+xboxOne: 8,// 8
+androidOnARM: 9,// 9
+windowsPhone81OnARM: 10,// 10
+windowsPhone81OnX86: 11,// 11

|};



/**
 * Indicates the type and purpose of a PlayReady-ND transmitter license.
 */

declare  var Windows$Media$Protection$PlayReady$NDCertificateType: {|
  +unknown: 0,// 0
+pc: 1,// 1
+device: 2,// 2
+domain: 3,// 3
+issuer: 4,// 4
+crlSigner: 5,// 5
+service: 6,// 6
+silverlight: 7,// 7
+application: 8,// 8
+metering: 9,// 9
+keyFileSigner: 10,// 10
+server: 11,// 11
+licenseSigner: 12,// 12

|};



/**
 * Creates PlayReady-ND sessions, coordinates with the download engine and the stream parser (for example, an MPEG-2 demuxer), manages the sample buffer, and listens to media stream source events.
 */
declare class Windows$Media$Protection$PlayReady$NDClient  {

/**
 * Creates a new instance of the NDClient class.
 * @param downloadEngine The download engine used to stream protected media content from a transmitter.
 * @param streamParser The stream parser used to parse data from a media stream.
 * @param pMessenger The messenger used to send messages between the PlayReady-ND receiver and transmitter.
 */
constructor(downloadEngine: Windows$Media$Protection$PlayReady$INDDownloadEngine, streamParser: Windows$Media$Protection$PlayReady$INDStreamParser, pMessenger: Windows$Media$Protection$PlayReady$INDMessenger): this;

/**
 * Closes the current playback session regardless of whether it is in the registration, proximity detection, license fetch, or play state.
 */
close(): void;

/**
 * Performs a license fetch between a client receiver and a transmitter.
 * @param licenseFetchDescriptor Descriptor for the license being fetched.
 * @return The result of the asynchronous license fetch call.
 */
licenseFetchAsync(
licenseFetchDescriptor: Windows$Media$Protection$PlayReady$INDLicenseFetchDescriptor): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Protection$PlayReady$INDLicenseFetchResult>;

/**
 * Notifies listeners that a closed caption acquisition operation has completed.
 */
onclosedcaptiondatareceived: Windows$Foundation$TypedEventHandler<Windows$Media$Protection$PlayReady$NDClient, Windows$Media$Protection$PlayReady$INDClosedCaptionDataReceivedEventArgs>;
addEventListener(
type: "closedcaptiondatareceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Protection$PlayReady$NDClient, Windows$Media$Protection$PlayReady$INDClosedCaptionDataReceivedEventArgs>): void;
removeEventListener(
type: "closedcaptiondatareceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Protection$PlayReady$NDClient, Windows$Media$Protection$PlayReady$INDClosedCaptionDataReceivedEventArgs>): void;

/**
 * Notifies listeners that a license fetch operation has completed.
 */
onlicensefetchcompleted: Windows$Foundation$TypedEventHandler<Windows$Media$Protection$PlayReady$NDClient, Windows$Media$Protection$PlayReady$INDLicenseFetchCompletedEventArgs>;
addEventListener(
type: "licensefetchcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Protection$PlayReady$NDClient, Windows$Media$Protection$PlayReady$INDLicenseFetchCompletedEventArgs>): void;
removeEventListener(
type: "licensefetchcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Protection$PlayReady$NDClient, Windows$Media$Protection$PlayReady$INDLicenseFetchCompletedEventArgs>): void;

/**
 * Notifies listeners that a proximity detection operation has completed.
 */
onproximitydetectioncompleted: Windows$Foundation$TypedEventHandler<Windows$Media$Protection$PlayReady$NDClient, Windows$Media$Protection$PlayReady$INDProximityDetectionCompletedEventArgs>;
addEventListener(
type: "proximitydetectioncompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Protection$PlayReady$NDClient, Windows$Media$Protection$PlayReady$INDProximityDetectionCompletedEventArgs>): void;
removeEventListener(
type: "proximitydetectioncompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Protection$PlayReady$NDClient, Windows$Media$Protection$PlayReady$INDProximityDetectionCompletedEventArgs>): void;

/**
 * Notifies listeners that a registration operation has completed.
 */
onregistrationcompleted: Windows$Foundation$TypedEventHandler<Windows$Media$Protection$PlayReady$NDClient, Windows$Media$Protection$PlayReady$INDRegistrationCompletedEventArgs>;
addEventListener(
type: "registrationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Protection$PlayReady$NDClient, Windows$Media$Protection$PlayReady$INDRegistrationCompletedEventArgs>): void;
removeEventListener(
type: "registrationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Protection$PlayReady$NDClient, Windows$Media$Protection$PlayReady$INDRegistrationCompletedEventArgs>): void;

/**
 * Notifies listeners that the app should start re-registration by calling the ReRegistrationAsync method.
 */
onreregistrationneeded: Windows$Foundation$TypedEventHandler<Windows$Media$Protection$PlayReady$NDClient, any>;
addEventListener(
type: "reregistrationneeded",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Protection$PlayReady$NDClient, any>): void;
removeEventListener(
type: "reregistrationneeded",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Protection$PlayReady$NDClient, any>): void;

/**
 * Performs a proximity detection and reregistration between a client receiver and a transmitter.
 * @param registrationCustomData Custom data for the registration request.
 * @return The result of the asynchronous reregistration call.
 */
reRegistrationAsync(
registrationCustomData: Windows$Media$Protection$PlayReady$INDCustomData): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Starts the registration, proximity detection, and license fetch procedures between a client receiver and a transmitter.
 * @param contentUrl The URL of the streamed content.
 * @param startAsyncOptions The asynchronous start options. See the NDStartAsyncOptions enumeration for a detailed description of these options.
 * @param registrationCustomData The custom data type identifier that is used for registration with the transmitter.
 * @param licenseFetchDescriptor The descriptor used for license fetching.
 * @return The result of the asynchronous start call.
 */
startAsync(
contentUrl: Windows$Foundation$Uri,
startAsyncOptions: number,
registrationCustomData: Windows$Media$Protection$PlayReady$INDCustomData,
licenseFetchDescriptor: Windows$Media$Protection$PlayReady$INDLicenseFetchDescriptor): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Protection$PlayReady$INDStartResult>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Indicates the type of format used for closed captions.
 */

declare  var Windows$Media$Protection$PlayReady$NDClosedCaptionFormat: {|
  +atsc: 0,// 0
+scte20: 1,// 1
+unknown: 2,// 2

|};



/**
 * Indicates the types of content that PlayReady can use in different scenarios.
 */

declare  var Windows$Media$Protection$PlayReady$NDContentIDType: {|
  +keyID: 0,// 0
+playReadyObject: 1,// 1
+custom: 2,// 2

|};



/**
 * Contains the custom data for one of the following PlayReady-ND messages: Registration Challenge, Registration Response, License Fetch Challenge, or License Fetch Response.
 */
declare class Windows$Media$Protection$PlayReady$NDCustomData  {

/**
 * Creates a new instance of the NDCustomData class.
 * @param customDataTypeIDBytes The type identifier for the custom data. Only a type identifier that is exactly 16 bytes in size is supported.
 * @param customDataBytes The custom data.
 */
constructor(customDataTypeIDBytes: number[], customDataBytes: number[]): this;

/**
 * Gets the custom data.
 */
customData: number;

/**
 * Gets the 16-byte type identifier for the custom data.
 */
customDataTypeID: number
}


/**
 * Contains methods that a download engine plug-in uses to send notifications to a PlayReady-ND client.
 */
declare class Windows$Media$Protection$PlayReady$NDDownloadEngineNotifier  {

/**
 * Creates a new instance of the NDDownloadEngineNotifier class.
 */
constructor(): this;

/**
 * Called by the download engine when a content identifier is received.
 * @param licenseFetchDescriptor The license from which the download engine receives the content identifier.
 */
onContentIDReceived(
licenseFetchDescriptor: Windows$Media$Protection$PlayReady$INDLicenseFetchDescriptor): void;

/**
 * Called by the download engine when it receives data.
 * @param dataBytes The byte array that holds the data.
 * @param bytesReceived The number of bytes received from the data stream.
 */
onDataReceived(dataBytes: number[], bytesReceived: number): void;

/**
 * Called by the download engine when it reaches the end of a PlayReady-ND media stream.
 */
onEndOfStream(): void;

/**
 * Called by the download engine if an error occurs during downloading.
 */
onNetworkError(): void;

/**
 * Called by the download engine once a PlayReady object is received.
 * @param dataBytes The byte array that holds the PlayReady object.
 */
onPlayReadyObjectReceived(dataBytes: number[]): void;

/**
 * Called by the download engine when a stream is opened.
 */
onStreamOpened(): void
}


/**
 * Retrieves and sets properties used for fetching a PlayReady-ND license.
 */
declare class Windows$Media$Protection$PlayReady$NDLicenseFetchDescriptor  {

/**
 * Creates a new instance of the NDLicenseFetchDescriptor class.
 * @param contentIDType The type of the content identifier.
 * @param contentIDBytes The content identifier.
 * @param licenseFetchChallengeCustomData The license fetch challenge custom data.
 */
constructor(contentIDType: $Values<typeof Windows$Media$Protection$PlayReady$NDContentIDType>, contentIDBytes: number[], licenseFetchChallengeCustomData: Windows$Media$Protection$PlayReady$INDCustomData): this;

/**
 * Gets the content identifer.
 */
contentID: number;

/**
 * Gets the type of the content identifier.
 */
contentIDType: $Values<typeof Windows$Media$Protection$PlayReady$NDContentIDType>;

/**
 * Gets or sets custom data for a license fetch challenge.
 */
licenseFetchChallengeCustomData: Windows$Media$Protection$PlayReady$INDCustomData
}


/**
 * Indicates the type of a protected media stream.
 */

declare  var Windows$Media$Protection$PlayReady$NDMediaStreamType: {|
  +audio: 0,// 0
+video: 1,// 1

|};



/**
 * Indicates the transport protocol that the proximity detection process uses.
 */

declare  var Windows$Media$Protection$PlayReady$NDProximityDetectionType: {|
  +udp: 0,// 0
+tcp: 1,// 1
+transportAgnostic: 2,// 2

|};



/**
 * Indicates the asynchronous start options. This enumeration is a bitwise OR and is used by the StartAsync method.
 */

declare  var Windows$Media$Protection$PlayReady$NDStartAsyncOptions: {|
  +mutualAuthentication: 0,// 0
+waitForLicenseDescriptor: 1,// 1

|};



/**
 * Manages PlayReady-ND storage files.
 */
declare class Windows$Media$Protection$PlayReady$NDStorageFileHelper  {

/**
 * Creates a new instance of the NDStorageFileHelper class.
 */
constructor(): this;

/**
 * Gets transmitter settings from the URLs associated with a StorageFile object if the URLs contain PlayReady-ND metadata.
 * @param file A storage file object that a media server has discovered.
 * @return The transmitter settings found in the storage file.
 */
getFileURLs(
file: Windows$Storage$IStorageFile): Windows$Foundation$Collections$IVector<string>
}


/**
 * Contains methods that a stream parser plug-in uses to send notifications to a PlayReady-ND client.
 */
declare class Windows$Media$Protection$PlayReady$NDStreamParserNotifier  {

/**
 * Creates a new instance of the NDStreamParserNotifier class.
 */
constructor(): this;

/**
 * Called by the stream parser when it requests a setup decryptor.
 * @param descriptor The descriptor of the media stream being decrypted.
 * @param keyID The key identifier used for decryption.
 * @param proBytes The data for the setup decryptor.
 */
onBeginSetupDecryptor(
descriptor: Windows$Media$Core$IMediaStreamDescriptor,
keyID: string,
proBytes: number[]): void;

/**
 * Called by a stream parser when it receives the content identifier.
 * @param licenseFetchDescriptor The license fetch descriptor containing the content identifier.
 */
onContentIDReceived(
licenseFetchDescriptor: Windows$Media$Protection$PlayReady$INDLicenseFetchDescriptor): void;

/**
 * Called by the stream parser when the media stream descriptor is created.
 * @param audioStreamDescriptors An array of audio stream descriptors that are part of the media stream descriptor.
 * @param videoStreamDescriptors An array of video stream descriptors that are part of the media stream descriptor.
 */
onMediaStreamDescriptorCreated(
audioStreamDescriptors: Windows$Foundation$Collections$IVector<Windows$Media$Core$AudioStreamDescriptor>,
videoStreamDescriptors: Windows$Foundation$Collections$IVector<Windows$Media$Core$VideoStreamDescriptor>): void;

/**
 * Called when the stream parser parses a sample from the media stream.
 * @param streamID The identifier for the media stream that is being parsed.
 * @param streamType The type of the media stream. This value can be Audio or Video.
 * @param streamSample The array of stream samples.
 * @param pts The presentation timestamp that indicates when to play the sample, in milliseconds. This value is relative to previous samples in the presentation. For example, if a given sample has a presentation time stamp of 1000 and some later sample has a presentation time stamp of 2000, the later sample occurs one second (1000ms) after the given sample.
 * @param ccFormat The closed caption format. This value can be ATSC, SCTE20, or Unknown.
 * @param ccDataBytes An array that contains the closed caption data.
 */
onSampleParsed(
streamID: number,
streamType: $Values<typeof Windows$Media$Protection$PlayReady$NDMediaStreamType>,
streamSample: Windows$Media$Core$MediaStreamSample,
pts: number,
ccFormat: $Values<typeof Windows$Media$Protection$PlayReady$NDClosedCaptionFormat>,
ccDataBytes: number[]): void
}


/**
 * Sends PlayReady-ND messages and challenges using the TCP network protocol.
 */
declare class Windows$Media$Protection$PlayReady$NDTCPMessenger  {

/**
 * Creates a new instance of the NDTCPMessenger class.
 * @param remoteHostName The IP address of the remote host that will receive messages. The format is either an IPv4 address in dotted-decimal notation or an IPv6 address in colon-hex notation.
 * @param remoteHostPort The TCP port of the remote host that will receive messages.
 */
constructor(remoteHostName: string, remoteHostPort: number): this;

/**
 * Sends the specified data in an asynchronous license fetch request message.
 * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param challengeDataBytes The data for the challenge message.
 * @return The result of the license fetch request.
 */
sendLicenseFetchRequestAsync(
sessionIDBytes: number[],
challengeDataBytes: number[]): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Protection$PlayReady$INDSendResult>;

/**
 * Sends the specified data in an asynchronous proximity detection response message.
 * @param pdType The type of proximity detection operation. This value can be UDP, TCP, or Transport-Agnostic.
 * @param transmitterChannelBytes The transmitter channel data.
 * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param responseDataBytes The data for the response message.
 * @return The result of the proximity detection response operation.
 */
sendProximityDetectionResponseAsync(
pdType: $Values<typeof Windows$Media$Protection$PlayReady$NDProximityDetectionType>,
transmitterChannelBytes: number[],
sessionIDBytes: number[],
responseDataBytes: number[]): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Protection$PlayReady$INDSendResult>;

/**
 * Sends the specified data in an asynchronous proximity detection start message.
 * @param pdType The type of proximity detection operation. This value can be UDP, TCP, or Transport-Agnostic.
 * @param transmitterChannelBytes The transmitter channel data.
 * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param challengeDataBytes The data for the challenge message.
 * @return The result of the proximity detection start operation.
 */
sendProximityDetectionStartAsync(
pdType: $Values<typeof Windows$Media$Protection$PlayReady$NDProximityDetectionType>,
transmitterChannelBytes: number[],
sessionIDBytes: number[],
challengeDataBytes: number[]): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Protection$PlayReady$INDSendResult>;

/**
 * Sends the specified data in an asynchronous registration request message.
 * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param challengeDataBytes The data for the challenge message.
 * @return The result of the registration request.
 */
sendRegistrationRequestAsync(
sessionIDBytes: number[],
challengeDataBytes: number[]): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Protection$PlayReady$INDSendResult>
}


/**
 * Represents the information in a PlayReady content header.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyContentHeader  {

/**
 * Initializes a new instance of the PlayReadyContentHeader class.
 * @param contentKeyId Identifier of the content encryption key.
 * @param contentKeyIdString String representation of the content key. If the contentKeyId parameter is specified, then this parameter is ignored.
 * @param contentEncryptionAlgorithm Encryption algorithm type used to encrypt the content.
 * @param licenseAcquisitionUrl The URL for the silent (no user interaction) license acquisition Web service.
 * @param licenseAcquisitionUserInterfaceUrl The URL for a non-silent license acquisition Web page.
 * @param customAttributes Contains custom data used by the content provider. The content author can add arbitrary XML inside this element. Microsoft code does not act on any data contained inside this element.
 * @param domainServiceId Service identifier for the domain service.
 */
constructor(contentKeyId: string, contentKeyIdString: string, contentEncryptionAlgorithm: $Values<typeof Windows$Media$Protection$PlayReady$PlayReadyEncryptionAlgorithm>, licenseAcquisitionUrl: Windows$Foundation$Uri, licenseAcquisitionUserInterfaceUrl: Windows$Foundation$Uri, customAttributes: string, domainServiceId: string): this;

/**
 * Initializes a new instance of the PlayReadyContentHeader class.
 * @param headerBytes Raw data bytes representing a legacy WMDRM header.
 * @param licenseAcquisitionUrl The URL for the silent (no user interaction) license acquisition Web service.
 * @param licenseAcquisitionUserInterfaceUrl The URL for a non-silent license acquisition Web page.
 * @param customAttributes Contains custom data used by the content provider. The content author can add arbitrary XML inside this element. Microsoft code does not act on any data contained inside this element.
 * @param domainServiceId Service identifier for the domain service.
 */
constructor(headerBytes: number[], licenseAcquisitionUrl: Windows$Foundation$Uri, licenseAcquisitionUserInterfaceUrl: Windows$Foundation$Uri, customAttributes: string, domainServiceId: string): this;

/**
 * Initializes a new instance of the PlayReadyContentHeader class.
 * @param dwFlags Reserved. Set to 0.
 * @param contentKeyIds Identifiers of the content encryption keys.
 * @param contentKeyIdStrings String representations of the content keys. Each string must be a Base-64 encoded 16 byte value.
 * @param contentEncryptionAlgorithm Encryption algorithm type used to encrypt the content.
 * @param licenseAcquisitionUrl The URL for the silent (no user interaction) license acquisition Web service.
 * @param licenseAcquisitionUserInterfaceUrl The URL for a non-silent license acquisition Web page.
 * @param customAttributes Contains custom data used by the content provider. The content author can add arbitrary XML inside this element. Microsoft code does not act on any data contained inside this element.
 * @param domainServiceId Service identifier for the domain service.
 */
constructor(dwFlags: number, contentKeyIds: string[], contentKeyIdStrings: string[], contentEncryptionAlgorithm: $Values<typeof Windows$Media$Protection$PlayReady$PlayReadyEncryptionAlgorithm>, licenseAcquisitionUrl: Windows$Foundation$Uri, licenseAcquisitionUserInterfaceUrl: Windows$Foundation$Uri, customAttributes: string, domainServiceId: string): this;

/**
 * Initializes a new instance of the PlayReadyContentHeader class.
 * @param headerBytes Raw data bytes representing a PlayReady content header.
 */
constructor(headerBytes: number[]): this;

/**
 * Gets the custom data used by the content provider.
 */
customAttributes: string;

/**
 * Gets the decryptor setup value in the header if it is set.
 */
decryptorSetup: $Values<typeof Windows$Media$Protection$PlayReady$PlayReadyDecryptorSetup>;

/**
 * Gets the domain service identifier in the header if it is set.
 */
domainServiceId: string;

/**
 * Gets the content encryption type in the header if it is set.
 */
encryptionType: $Values<typeof Windows$Media$Protection$PlayReady$PlayReadyEncryptionAlgorithm>;

/**
 * Retrieves the full PlayReady object as a byte array.
 * @return The header containing the full PlayReady object.
 */
getSerializedHeader(): number[];

/**
 * Gets a new content header that contains any embedded license updates that were available.
 */
headerWithEmbeddedUpdates: Windows$Media$Protection$PlayReady$PlayReadyContentHeader;

/**
 * Gets the content key identifier value if it is set.
 */
keyId: string;

/**
 * Gets the content key identifier string value if it is set.
 */
keyIdString: string;

/**
 * Gets the content key identifier string values if they are set.
 */
keyIdStrings: string;

/**
 * Gets the content key identifier values if they are set.
 */
keyIds: string;

/**
 * Gets the license acquisition URL in the header if it is set.
 */
licenseAcquisitionUrl: Windows$Foundation$Uri;

/**
 * Gets the license acquisition user interface URL in the header if it is set.
 */
licenseAcquisitionUserInterfaceUrl: Windows$Foundation$Uri
}


/**
 * Receives multiple service request objects that are necessary to enable the playback ability for a given content header.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyContentResolver  {

/**
 * Proactively initiates the service request chain for a given content header.
 * @param contentHeader Content header for the content the app wants to resolve all necessary service request operations.
 * @return The first service request operation required to resolve the content.
 */
static serviceRequest(
contentHeader: Windows$Media$Protection$PlayReady$PlayReadyContentHeader): Windows$Media$Protection$PlayReady$IPlayReadyServiceRequest
}


/**
 * Defines decryptor setup requirements indicating when to acquire licenses for the content.
 */

declare  var Windows$Media$Protection$PlayReady$PlayReadyDecryptorSetup: {|
  +uninitialized: 0,// 0
+onDemand: 1,// 1

|};



/**
 * Provides access to metadata about a domain to which the current system is a member.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyDomain  {

/**
 * Gets the current domain account identifier property.
 */
accountId: string;

/**
 * Gets the URL used to join the domain.
 */
domainJoinUrl: Windows$Foundation$Uri;

/**
 * Gets the current domain friendly name.
 */
friendlyName: string;

/**
 * Gets the current domain revision number.
 */
revision: number;

/**
 * Gets the current domain service identifier property.
 */
serviceId: string
}


/**
 * Exposes the PlayReady PlayReadyDomain class iterator.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyDomainIterable  {

/**
 * Initializes a new instance of the PlayReadyDomainIterable class using the domain account identifier.
 * @param domainAccountId The domain account identifier.
 */
constructor(domainAccountId: string): this;

/**
 * Returns an iterator that iterates over the items in the PlayReady domain collection.
 * @return The PlayReady domain iterator.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Media$Protection$PlayReady$IPlayReadyDomain>
}


/**
 * Provides for iteration of the PlayReadyDomain class.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyDomainIterator  {

/**
 * Gets the current item in the PlayReady domain collection.
 */
current: Windows$Media$Protection$PlayReady$IPlayReadyDomain;

/**
 * Retrieves all items in the PlayReady domain collection.
 */
getMany(
): {
items: Windows$Media$Protection$PlayReady$IPlayReadyDomain,
returnValue: number
};

/**
 * Gets a value that indicates whether there is a current item or the iterator is at the end of the PlayReady domain collection.
 */
hasCurrent: boolean;

/**
 * Advances the enumerator to the next item in the collection.
 * @return true if the iterator refers to a valid item that is in the collection or false if the iterator is at the end of the collection.
 */
moveNext(): boolean
}


/**
 * Provides the service methods for joining a PlayReady domain.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyDomainJoinServiceRequest  {

/**
 * Initializes a new instance of the PlayReadyDomainJoinServiceRequest class.
 */
constructor(): this;

/**
 * Begins an asynchronous service request operation.
 * @return The asynchronous service action.
 */
beginServiceRequest(): Windows$Foundation$IAsyncAction;

/**
 * Gets or sets the custom data of the request challenge.
 */
challengeCustomData: string;

/**
 * Gets or sets the current domain account identifier property.
 */
domainAccountId: string;

/**
 * Gets or sets the current domain friendly name property.
 */
domainFriendlyName: string;

/**
 * Gets or sets the current domain service identifier property.
 */
domainServiceId: string;

/**
 * Begins the process of manually enabling.
 * @return The SOAP message to be used in a manual license acquisition challenge request.
 */
generateManualEnablingChallenge(): Windows$Media$Protection$PlayReady$PlayReadySoapMessage;

/**
 * Returns a new service request interface.
 * @return The new service request interface.
 */
nextServiceRequest(): Windows$Media$Protection$PlayReady$IPlayReadyServiceRequest;

/**
 * Process the raw binary result of a manual enabling challenge.
 * @param responseBytes The response result to be processed.
 * @return If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
 */
processManualEnablingResponse(responseBytes: number[]): Windows$WinRTError;

/**
 * Gets the vendor content protection system identifier.
 */
protectionSystem: string;

/**
 * Gets the custom data that was returned in the response from the service.
 */
responseCustomData: string;

/**
 * Gets the GUID for the type of operation that the PlayReady domain join service request performs.
 */
type: string;

/**
 * Gets or sets the URI used to perform a service request action.
 */
uri: Windows$Foundation$Uri
}


/**
 * Provides the service methods for leaving a PlayReady domain.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyDomainLeaveServiceRequest  {

/**
 * Initializes a new instance of the PlayReadyDomainLeaveServiceRequest class.
 */
constructor(): this;

/**
 * Begins an asynchronous service request operation.
 * @return The asynchronous service action.
 */
beginServiceRequest(): Windows$Foundation$IAsyncAction;

/**
 * Gets or sets the custom data of the request challenge.
 */
challengeCustomData: string;

/**
 * Gets or sets the current domain account identifier property.
 */
domainAccountId: string;

/**
 * Gets or sets the current domain account identifier.
 */
domainServiceId: string;

/**
 * Begins the process of manually enabling.
 * @return The SOAP message to be used in a manual license acquisition challenge request.
 */
generateManualEnablingChallenge(): Windows$Media$Protection$PlayReady$PlayReadySoapMessage;

/**
 * Returns a new service request interface.
 * @return The new service request interface.
 */
nextServiceRequest(): Windows$Media$Protection$PlayReady$IPlayReadyServiceRequest;

/**
 * Process the raw binary result of a manual enabling challenge.
 * @param responseBytes The response result to be processed.
 * @return If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
 */
processManualEnablingResponse(responseBytes: number[]): Windows$WinRTError;

/**
 * Gets the vendor content protection system identifier.
 */
protectionSystem: string;

/**
 * Gets the custom data that was returned in the response from the service.
 */
responseCustomData: string;

/**
 * Gets the GUID for the type of operation that the PlayReady domain leave service request performs.
 */
type: string;

/**
 * Gets or sets the URI used to perform a service request action.
 */
uri: Windows$Foundation$Uri
}


/**
 * Indicates the type of encryption algorithm specified in a PlayReady content header.
 */

declare  var Windows$Media$Protection$PlayReady$PlayReadyEncryptionAlgorithm: {|
  +unprotected: 0,// 0
+aes128Ctr: 1,// 1
+cocktail: 2,// 2
+uninitialized: 3,// 3

|};



/**
 * Indicates the valid list of hardware digital rights management (DRM) feature values that can be queried.
 */

declare  var Windows$Media$Protection$PlayReady$PlayReadyHardwareDRMFeatures: {|
  +hardwareDRM: 0,// 0
+hevc: 1,// 1

|};



/**
 * Specifies the format for the ITA serialized data.
 */

declare  var Windows$Media$Protection$PlayReady$PlayReadyITADataFormat: {|
  +serializedProperties: 0,// 0
+serializedProperties_WithContentProtectionWrapper: 1,// 1

|};



/**
 * Creates the PlayReady ITA-specific serialized initialization data.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyITADataGenerator  {

/**
 * Initializes a new instance of the PlayReadyITADataGenerator class.
 */
constructor(): this;

/**
 * Returns a serialized blob of the specified IPropertySet data that the PlayReady ITA can consume if wrapped in a content protection instantiation format.
 * @param guidCPSystemId The content protection system GUID.
 * @param countOfStreams The stream count.
 * @param configuration The data to be returned as a serialized blob.
 * @param format The format for the ITA serialized data.
 * @return The serialized blob. See Remarks.
 */
generateData(
guidCPSystemId: string,
countOfStreams: number,
configuration: Windows$Foundation$Collections$IPropertySet,
format: $Values<typeof Windows$Media$Protection$PlayReady$PlayReadyITADataFormat>): number[]
}


/**
 * Provides the service methods for requesting platform individualization.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyIndividualizationServiceRequest  {

/**
 * Initializes a new instance of the PlayReadyIndividualizationServiceRequest class.
 */
constructor(): this;

/**
 * Begins an asynchronous service request operation.
 * @return The asynchronous service action.
 */
beginServiceRequest(): Windows$Foundation$IAsyncAction;

/**
 * Gets or sets the custom data of the request challenge. This property is not supported in this class.
 */
challengeCustomData: string;

/**
 * Begins the process of manually enabling. This method is not supported in this class.
 * @return This method always returns 0x80070032 (the request is not supported).
 */
generateManualEnablingChallenge(): Windows$Media$Protection$PlayReady$PlayReadySoapMessage;

/**
 * Returns a new service request interface.
 * @return The new service request interface.
 */
nextServiceRequest(): Windows$Media$Protection$PlayReady$IPlayReadyServiceRequest;

/**
 * Process the raw binary result of a manual enabling challenge. This method is not supported in this class.
 * @param responseBytes The response result to be processed.
 * @return This method always returns 0x80070032 (the request is not supported).
 */
processManualEnablingResponse(responseBytes: number[]): Windows$WinRTError;

/**
 * Gets the vendor content protection system identifier.
 */
protectionSystem: string;

/**
 * Gets the custom data that was returned in the response from the service. This property is not supported in this class.
 */
responseCustomData: string;

/**
 * Gets the GUID for the type of operation that the PlayReady individualization service request performs.
 */
type: string;

/**
 * Gets or sets the URI used to perform a service request action. This property is not supported in this class.
 */
uri: Windows$Foundation$Uri
}


/**
 * Represents the properties of a PlayReady license.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyLicense  {

/**
 * Gets the chain depth of the license chain represented by the current PlayReadyLicense class.
 */
chainDepth: number;

/**
 * Gets the domain account identifier to which this license is bound.
 */
domainAccountID: string;

/**
 * Gets the expiration date of the current license.
 */
expirationDate: Date;

/**
 * Gets the amount of time, in seconds, before the current license expires after the media is first played.
 */
expireAfterFirstPlay: number;

/**
 * Gets the state of the license.
 */
fullyEvaluated: boolean;

/**
 * Gets the key identifier (KID) of the license at the specified chain depth.
 * @param chainDepth The depth of the license in the chain for which to retrieve the KID. This value is a 0-based index.
 * @return The KID of the license. This return value is sensitive to the underlying platform's endianness. Carefully test your app on all platforms you intend to support to ensure that correct endianness is used on each platform.
 */
getKIDAtChainDepth(chainDepth: number): string;

/**
 * Gets whether this license is usable for playback.
 */
usableForPlay: boolean
}


/**
 * Provides the service methods for obtaining PlayReady licenses.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyLicenseAcquisitionServiceRequest  {

/**
 * Initializes a new instance of the PlayReadyLicenseAcquisitionServiceRequest class.
 */
constructor(): this;

/**
 * Begins an asynchronous service request operation.
 * @return The asynchronous service action.
 */
beginServiceRequest(): Windows$Foundation$IAsyncAction;

/**
 * Gets or sets the custom data of the request challenge.
 */
challengeCustomData: string;

/**
 * Gets or sets the current content header property.
 */
contentHeader: Windows$Media$Protection$PlayReady$PlayReadyContentHeader;

/**
 * Gets or sets the current domain service identifier property that overrides a service identifier in the content header.
 */
domainServiceId: string;

/**
 * Begins the process of manually enabling.
 * @return The SOAP message to be used in a manual license acquisition challenge request.
 */
generateManualEnablingChallenge(): Windows$Media$Protection$PlayReady$PlayReadySoapMessage;

/**
 * Returns a new service request interface.
 * @return The new service request interface.
 */
nextServiceRequest(): Windows$Media$Protection$PlayReady$IPlayReadyServiceRequest;

/**
 * Process the raw binary result of a manual enabling challenge.
 * @param responseBytes The response result to be processed.
 * @return If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
 */
processManualEnablingResponse(responseBytes: number[]): Windows$WinRTError;

/**
 * Gets the vendor content protection system identifier.
 */
protectionSystem: string;

/**
 * Gets the custom data that was returned in the response from the service.
 */
responseCustomData: string;

/**
 * Gets the GUID for the type of operation that the PlayReady license acquisition service request performs.
 */
type: string;

/**
 * Gets or sets the URI used to perform a service request action.
 */
uri: Windows$Foundation$Uri
}


/**
 * Exposes the PlayReadyLicense class iterator.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyLicenseIterable  {

/**
 * Initializes a new instance of the PlayReadyLicenseIterable class.
 * @param contentHeader The content header used to locate associated licenses.
 * @param fullyEvaluated Indicates whether evaluated license chains should be enumerated or if all licenses (including those that are unusable) should be enumerated. This parameter is true if evaluated license chains should be enumerated, or false if all licenses should be enumerated.
 */
constructor(contentHeader: Windows$Media$Protection$PlayReady$PlayReadyContentHeader, fullyEvaluated: boolean): this;

/**
 * Initializes a new instance of the PlayReadyLicenseIterable class.
 */
constructor(): this;

/**
 * Returns an iterator that iterates over the items in the PlayReady license collection.
 * @return The PlayReady license iterator.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Media$Protection$PlayReady$IPlayReadyLicense>
}


/**
 * Provides for iteration of the PlayReadyLicense class.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyLicenseIterator  {

/**
 * Gets the current item in the PlayReady license collection.
 */
current: Windows$Media$Protection$PlayReady$IPlayReadyLicense;

/**
 * Retrieves all items in the PlayReady license collection.
 */
getMany(
): {
items: Windows$Media$Protection$PlayReady$IPlayReadyLicense,
returnValue: number
};

/**
 * Gets a value that indicates whether there is a current item or the iterator is at the end of the PlayReady license collection.
 */
hasCurrent: boolean;

/**
 * Advances the enumerator to the next item in the collection.
 * @return true if the iterator refers to a valid item that is in the collection or false if the iterator is at the end of the collection.
 */
moveNext(): boolean
}


/**
 * Performs license management operations.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyLicenseManagement  {

/**
 * Deletes licenses that match the specified content header.
 * @param contentHeader Content header with a key identifier with which to match licenses.
 * @return The asynchronous operation performing the deletion.
 */
static deleteLicenses(
contentHeader: Windows$Media$Protection$PlayReady$PlayReadyContentHeader): Windows$Foundation$IAsyncAction
}


/**
 * Creates a media session and binds license acquisition to that media session.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyLicenseSession  {

/**
 * Initializes a new instance of the PlayReadyLicenseSession class.
 * @param configuration The configuration data for the license session.
 */
constructor(configuration: Windows$Foundation$Collections$IPropertySet): this;

/**
 * Updates the media protection manger with the appropriate settings so the media foundation can be used for playback.
 * @param mpm The media protection manager to be updated.
 */
configureMediaProtectionManager(mpm: Windows$Media$Protection$MediaProtectionManager): void;

/**
 * Creates a license acquisition service request whose license will be tied to the media session.
 * @return The license acquisition service request.
 */
createLAServiceRequest(
): Windows$Media$Protection$PlayReady$IPlayReadyLicenseAcquisitionServiceRequest
}


/**
 * Provides the service methods for content metering operations.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyMeteringReportServiceRequest  {

/**
 * Initializes a new instance of the PlayReadyMeteringReportServiceRequest class.
 */
constructor(): this;

/**
 * Begins an asynchronous service request operation.
 * @return The asynchronous service action.
 */
beginServiceRequest(): Windows$Foundation$IAsyncAction;

/**
 * Gets or sets the custom data of the request challenge.
 */
challengeCustomData: string;

/**
 * Begins the process of manually enabling.
 * @return The SOAP message to be used in a manual license acquisition challenge request.
 */
generateManualEnablingChallenge(): Windows$Media$Protection$PlayReady$PlayReadySoapMessage;

/**
 * Gets or sets the current metering certificate property.
 */
meteringCertificate: number;

/**
 * Returns a new service request interface.
 * @return The new service request interface.
 */
nextServiceRequest(): Windows$Media$Protection$PlayReady$IPlayReadyServiceRequest;

/**
 * Process the raw binary result of a manual enabling challenge.
 * @param responseBytes The response result to be processed.
 * @return If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
 */
processManualEnablingResponse(responseBytes: number[]): Windows$WinRTError;

/**
 * Gets the vendor content protection system identifier.
 */
protectionSystem: string;

/**
 * Gets the custom data that was returned in the response from the service.
 */
responseCustomData: string;

/**
 * Gets the GUID for the type of operation that the PlayReady metering report service request performs.
 */
type: string;

/**
 * Gets or sets the URI used to perform a service request action.
 */
uri: Windows$Foundation$Uri
}


/**
 * Updates the revocation data required by PlayReady.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyRevocationServiceRequest  {

/**
 * Initializes a new instance of the PlayReadyRevocationServiceRequest class.
 */
constructor(): this;

/**
 * Begins an asynchronous service request operation.
 * @return The asynchronous service action.
 */
beginServiceRequest(): Windows$Foundation$IAsyncAction;

/**
 * Gets or sets the custom data of the request challenge. This property is not supported in this class.
 */
challengeCustomData: string;

/**
 * Begins the process of manually enabling. This method is not supported in this class.
 * @return This method always returns 0x80070032 (the request is not supported).
 */
generateManualEnablingChallenge(): Windows$Media$Protection$PlayReady$PlayReadySoapMessage;

/**
 * Returns a new service request interface.
 * @return The new service request interface.
 */
nextServiceRequest(): Windows$Media$Protection$PlayReady$IPlayReadyServiceRequest;

/**
 * Process the raw binary result of a manual enabling challenge. This method is not supported in this class.
 * @param responseBytes The response result to be processed.
 * @return This method always returns 0x80070032 (the request is not supported).
 */
processManualEnablingResponse(responseBytes: number[]): Windows$WinRTError;

/**
 * Gets the vendor content protection system identifier.
 */
protectionSystem: string;

/**
 * Gets the custom data that was returned in the response from the service. This property is not supported in this class.
 */
responseCustomData: string;

/**
 * Gets the GUID for the type of operation that the PlayReady revocation service request performs.
 */
type: string;

/**
 * Gets or sets the URI used to perform a service request action. This property is not supported in this class.
 */
uri: Windows$Foundation$Uri
}


/**
 * Enumerates PlayReady secure stop service requests.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadySecureStopIterable  {

/**
 * Initializes a new instance of the PlayReadySecureStopIterable class.
 * @param publisherCertBytes The raw binary body of the publisher certificate.
 */
constructor(publisherCertBytes: number[]): this;

/**
 * Returns an iterator that iterates over the items in the PlayReady secure stop collection.
 * @return The PlayReady secure stop iterator.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Media$Protection$PlayReady$IPlayReadySecureStopServiceRequest>
}


/**
 * Provides for iteration of the IPlayReadySecureStopServiceRequest interface.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadySecureStopIterator  {

/**
 * Gets the current item in the PlayReady secure stop collection.
 */
current: Windows$Media$Protection$PlayReady$IPlayReadySecureStopServiceRequest;

/**
 * Retrieves all items in the PlayReady secure stop collection.
 */
getMany(
): {
items: Windows$Media$Protection$PlayReady$IPlayReadySecureStopServiceRequest,
returnValue: number
};

/**
 * Gets a value that indicates whether there is a current item or the iterator is at the end of the PlayReady secure stop collection.
 */
hasCurrent: boolean;

/**
 * Advances the enumerator to the next item in the collection.
 * @return true if the iterator refers to a valid item that is in the collection or false if the iterator is at the end of the collection.
 */
moveNext(): boolean
}


/**
 * Manages secure stop messages.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadySecureStopServiceRequest  {

/**
 * Initializes a new instance of the PlayReadySecureStopServiceRequest class for the specified secure stop session.
 * @param sessionID The secure stop session identifier.
 * @param publisherCertBytes The raw binary body of the publisher certificate.
 */
constructor(sessionID: string, publisherCertBytes: number[]): this;

/**
 * Initializes a new instance of the PlayReadySecureStopServiceRequest class to include all secure stop sessions.
 * @param publisherCertBytes The raw binary body of the publisher certificate.
 */
constructor(publisherCertBytes: number[]): this;

/**
 * Begins an asynchronous service request operation.
 * @return The asynchronous service action.
 */
beginServiceRequest(): Windows$Foundation$IAsyncAction;

/**
 * Gets or sets the custom data of the request challenge.
 */
challengeCustomData: string;

/**
 * Begins the process of manually enabling.
 * @return The SOAP message to be used in a manual license acquisition challenge request.
 */
generateManualEnablingChallenge(): Windows$Media$Protection$PlayReady$PlayReadySoapMessage;

/**
 * Returns a new service request interface.
 * @return The new service request interface.
 */
nextServiceRequest(): Windows$Media$Protection$PlayReady$IPlayReadyServiceRequest;

/**
 * Process the raw binary result of a manual enabling challenge.
 * @param responseBytes The response result to be processed.
 * @return If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
 */
processManualEnablingResponse(responseBytes: number[]): Windows$WinRTError;

/**
 * Gets the vendor content protection system identifier.
 */
protectionSystem: string;

/**
 * Gets the current publisher certificate property.
 */
publisherCertificate: number;

/**
 * Gets the custom data that was returned in the response from the service.
 */
responseCustomData: string;

/**
 * Gets the session identifier property.
 */
sessionID: string;

/**
 * Gets the secure stop session's start time property.
 */
startTime: Date;

/**
 * Gets the secure stop session's stopped flag property which indicates whether the secure stop session for this request was cleanly shut down.
 */
stopped: boolean;

/**
 * Gets the GUID for the type of operation that the PlayReady secure stop service request performs.
 */
type: string;

/**
 * Gets the secure stop session's update/stop time property.
 */
updateTime: Date;

/**
 * Gets or sets the URI used to perform a service request action.
 */
uri: Windows$Foundation$Uri
}


/**
 * Contains a SOAP message used in manual challenge requests.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadySoapMessage  {

/**
 * Retrieves the contents of the SOAP message.
 * @return The contents of the SOAP message.
 */
getMessageBody(): number[];

/**
 * Gets a collection of the SOAP headers applied to the current SOAP request or SOAP response.
 */
messageHeaders: Windows$Foundation$Collections$IPropertySet;

/**
 * Gets the base URL of the XML Web service.
 */
uri: Windows$Foundation$Uri
}


/**
 * Provides support for returning static or constant data.
 */
declare class Windows$Media$Protection$PlayReady$PlayReadyStatics  {

/**
 * Queries whether the specified hardware digital rights management (DRM) feature is supported on the system.
 * @param hwdrmFeature The hardware DRM feature to query.
 * @return true if the hardware DRM feature is supported, otherwise false.
 */
static checkSupportedHardware(
hwdrmFeature: $Values<typeof Windows$Media$Protection$PlayReady$PlayReadyHardwareDRMFeatures>): boolean;

/**
 * Gets the type of a PlayReady domain join service request.
 */
static domainJoinServiceRequestType: string;

/**
 * Gets the type of a PlayReady domain leave service request.
 */
static domainLeaveServiceRequestType: string;

/**
 * Gets the type of a PlayReady individualization service request.
 */
static individualizationServiceRequestType: string;

/**
 * Gets the type of a PlayReady license acquisition service request.
 */
static licenseAcquirerServiceRequestType: string;

/**
 * Gets the PlayReady media protection system identifier.
 */
static mediaProtectionSystemId: string;

/**
 * Gets the type of a PlayReady metering service request.
 */
static meteringReportServiceRequestType: string;

/**
 * Gets the current certificate security level.
 */
static playReadyCertificateSecurityLevel: number;

/**
 * Gets the PlayReady runtime security version.
 */
static playReadySecurityVersion: number;

/**
 * Gets the type of a PlayReady revocation service request.
 */
static revocationServiceRequestType: string;

/**
 * Gets the type of a PlayReady secure stop service request.
 */
static secureStopServiceRequestType: string
}


/**
 * Retrieves and sets properties used for fetching a PlayReady-ND license.
 */
declare interface Windows$Media$Protection$PlayReady$INDLicenseFetchDescriptor {

/**
 * Gets the content identifier used for fetching a license.
 */
contentID: number,

/**
 * Gets the type of the content identifier used for fetching a license.
 */
contentIDType: $Values<typeof Windows$Media$Protection$PlayReady$NDContentIDType>,

/**
 * Gets or sets custom data for a license fetch challenge.
 */
licenseFetchChallengeCustomData: Windows$Media$Protection$PlayReady$INDCustomData
} 


/**
 * Provides the result of the PlayReady-ND license fetch.
 */
declare interface Windows$Media$Protection$PlayReady$INDLicenseFetchResult {

/**
 * Gets the custom data from a license fetch response.
 */
responseCustomData: Windows$Media$Protection$PlayReady$INDCustomData
} 


/**
 * Specifies arguments for a PlayReady-ND ClosedCaptionDataReceived event.
 */
declare interface Windows$Media$Protection$PlayReady$INDClosedCaptionDataReceivedEventArgs {

/**
 * Gets the closed caption data.
 */
closedCaptionData: number,

/**
 * Gets the format of the closed caption data.
 */
closedCaptionDataFormat: $Values<typeof Windows$Media$Protection$PlayReady$NDClosedCaptionFormat>,

/**
 * Gets the timestamp of the closed caption data.
 */
presentationTimestamp: number
} 


/**
 * Gets custom data from a PlayReady-ND license fetch operation. This custom data is an argument from a PlayReady-ND LicenseFetchCompleted event.
 */
declare interface Windows$Media$Protection$PlayReady$INDLicenseFetchCompletedEventArgs {

/**
 * Gets custom data from a license fetch response.
 */
responseCustomData: Windows$Media$Protection$PlayReady$INDCustomData
} 


/**
 * Provides arguments for the PlayReady-ND ProximityDetectionCompleted event. Apps fire this event after they complete the proximity detection process.
 */
declare interface Windows$Media$Protection$PlayReady$INDProximityDetectionCompletedEventArgs {

/**
 * Gets the number of retries that occurred during a proximity detection operation.
 */
proximityDetectionRetryCount: number
} 


/**
 * Provides arguments for the PlayReady-ND RegistrationCompleted event.
 */
declare interface Windows$Media$Protection$PlayReady$INDRegistrationCompletedEventArgs {

/**
 * Gets custom data from a registration response.
 */
responseCustomData: Windows$Media$Protection$PlayReady$INDCustomData,

/**
 * Gets or sets whether to accept or reject a transmitter's certificate.
 */
transmitterCertificateAccepted: boolean,

/**
 * Gets transmitter properties from the transmitter's certificate to verify the transmitter.
 */
transmitterProperties: Windows$Media$Protection$PlayReady$INDTransmitterProperties
} 


/**
 * Contains the custom data for one of the following PlayReady-ND messages: Registration Challenge, Registration Response, License Fetch Challenge, or License Fetch Response.
 */
declare interface Windows$Media$Protection$PlayReady$INDCustomData {

/**
 * Gets the custom data.
 */
customData: number,

/**
 * Gets the 16-byte type identifier for the custom data.
 */
customDataTypeID: number
} 


/**
 * Provides the StartAsync result that contains the created PlayReady-ND MediaStreamSource instance.
 */
declare interface Windows$Media$Protection$PlayReady$INDStartResult {

/**
 * Gets the MediaStreamSource object for the data that the transmitter streams.
 */
mediaStreamSource: Windows$Media$Core$MediaStreamSource
} 


/**
 * Provides the PlayReady-ND download engine used to stream protected media content from a transmitter.
 */
declare interface Windows$Media$Protection$PlayReady$INDDownloadEngine {

/**
 * Notifies the download engine to stop downloading and disconnect from the remote server.
 */
close(): void,

/**
 * Notifies the download engine to open the content specified by a URL.
 * @param uri The URI from which the download engine gets content.
 * @param sessionIDBytes The session identifier used to identify the session. The session identifier must be 16 bytes.
 */
open(uri: Windows$Foundation$Uri, sessionIDBytes: Array<number>): void,

/**
 * Notifies the download engine to pause downloading.
 */
pause(): void,

/**
 * Notifies the download engine to resume a paused download.
 */
resume(): void,

/**
 * Notifies the download engine to go to a specified time position in the media stream.
 * @param startPosition The position within the media stream to which to seek.
 */
seek(startPosition: number): void,

/**
 * Gets the maximum threshold of the sample buffer.
 */
bufferFullMaxThresholdInSamples: number,

/**
 * Gets the minimum number of samples a sample buffer can hold before a download engine resumes downloading.
 */
bufferFullMinThresholdInSamples: number,

/**
 * Gets whether the download engine supports seeking.
 */
canSeek: boolean,

/**
 * Gets the download engine notifier that will provide notification of download stream events from the transmitter.
 */
notifier: Windows$Media$Protection$PlayReady$NDDownloadEngineNotifier
} 


/**
 * Parses data from a PlayReady-ND media stream.
 */
declare interface Windows$Media$Protection$PlayReady$INDStreamParser {

/**
 * Notifies a PlayReady-ND stream parser to be ready for the beginning of a new media stream.
 */
beginOfStream(): void,

/**
 * Notifies a PlayReady-ND stream parser that the end of a media stream has been reached.
 */
endOfStream(): void,

/**
 * Retrieves the stream type (audio or video) and stream identifier of the media stream descriptor.
 * @param descriptor The media stream from which this method gets information.
 */
getStreamInformation(
descriptor: Windows$Media$Core$IMediaStreamDescriptor): {
streamType: $Values<typeof Windows$Media$Protection$PlayReady$NDMediaStreamType>,
returnValue: number
},

/**
 * Parses samples from a PlayReady-ND media stream.
 * @param dataBytes The data to be parsed.
 */
parseData(dataBytes: Array<number>): void,

/**
 * Gets the stream parser notifier that will provide notification of stream parser events from the transmitter.
 */
notifier: Windows$Media$Protection$PlayReady$NDStreamParserNotifier
} 


/**
 * Sends registration, proximity detection, and license fetch messages between PlayReady-ND receivers and transmitters.
 */
declare interface Windows$Media$Protection$PlayReady$INDMessenger {

/**
 * Sends the specified data in an asynchronous license fetch request message.
 * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param challengeDataBytes The data for the challenge message.
 * @return The result of the license fetch request.
 */
sendLicenseFetchRequestAsync(
sessionIDBytes: Array<number>,
challengeDataBytes: Array<number>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Protection$PlayReady$INDSendResult>,

/**
 * Sends the specified data in an asynchronous proximity detection response message.
 * @param pdType The type of proximity detection operation. This value can be UDP, TCP, or Transport-Agnostic.
 * @param transmitterChannelBytes The transmitter channel data.
 * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param responseDataBytes The data for the response message.
 * @return The result of the proximity detection response operation.
 */
sendProximityDetectionResponseAsync(
pdType: $Values<typeof Windows$Media$Protection$PlayReady$NDProximityDetectionType>,
transmitterChannelBytes: Array<number>,
sessionIDBytes: Array<number>,
responseDataBytes: Array<number>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Protection$PlayReady$INDSendResult>,

/**
 * Sends the specified data in an asynchronous proximity detection start message.
 * @param pdType The type of proximity detection operation. This value can be UDP, TCP, or Transport-Agnostic.
 * @param transmitterChannelBytes The transmitter channel data.
 * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param challengeDataBytes The data for the challenge message.
 * @return The result of the proximity detection start operation.
 */
sendProximityDetectionStartAsync(
pdType: $Values<typeof Windows$Media$Protection$PlayReady$NDProximityDetectionType>,
transmitterChannelBytes: Array<number>,
sessionIDBytes: Array<number>,
challengeDataBytes: Array<number>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Protection$PlayReady$INDSendResult>,

/**
 * Sends the specified data in an asynchronous registration request message.
 * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param challengeDataBytes The data for the challenge message.
 * @return The result of the license fetch request.
 */
sendRegistrationRequestAsync(
sessionIDBytes: Array<number>,
challengeDataBytes: Array<number>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Protection$PlayReady$INDSendResult>
} 


/**
 * Provides the result, in the form of a response message, from the PlayReady-ND messenger.
 */
declare interface Windows$Media$Protection$PlayReady$INDSendResult {

/**
 * Gets the response message from a messenger.
 */
response: number
} 


/**
 * Base interface for all service request interfaces.
 */
declare type Windows$Media$Protection$PlayReady$IPlayReadyServiceRequest = {

/**
 * Begins an asynchronous service request operation.
 * @return The asynchronous service action.
 */
beginServiceRequest(): Windows$Foundation$IAsyncAction,

/**
 * Begins the process of manually enabling.
 * @return Begins the process of manually enabling.
 */
generateManualEnablingChallenge(): Windows$Media$Protection$PlayReady$PlayReadySoapMessage,

/**
 * Returns a new service request interface.
 * @return The new service request interface.
 */
nextServiceRequest(): Windows$Media$Protection$PlayReady$IPlayReadyServiceRequest,

/**
 * Processes the raw binary result of a manual enabling challenge.
 * @param responseBytes The response result to be processed.
 * @return If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
 */
processManualEnablingResponse(responseBytes: Array<number>): Windows$WinRTError,

/**
 * Gets or sets the custom data of the request challenge.
 */
challengeCustomData: string,

/**
 * Gets the custom data that was returned in the response from the service.
 */
responseCustomData: string,

/**
 * Gets or sets the URI used to perform a service request action.
 */
uri: Windows$Foundation$Uri
} & Windows$Media$Protection$IMediaProtectionServiceRequest



/**
 * Provides access to metadata about a domain to which the current system is a member.
 */
declare interface Windows$Media$Protection$PlayReady$IPlayReadyDomain {

/**
 * Gets the current domain account identifier property.
 */
accountId: string,

/**
 * Gets the URL used to join the domain.
 */
domainJoinUrl: Windows$Foundation$Uri,

/**
 * Gets the current domain friendly name.
 */
friendlyName: string,

/**
 * Gets the current domain revision number.
 */
revision: number,

/**
 * Gets the current domain service identifier property.
 */
serviceId: string
} 


/**
 * Contains information about a PlayReady license.
 */
declare interface Windows$Media$Protection$PlayReady$IPlayReadyLicense {

/**
 * Gets the key identifier (KID) of the license at the specified chain depth.
 * @param chainDepth The depth of the license in the chain for which to retrieve the KID. This value is a 0-based index.
 * @return The KID of the license. This return value is sensitive to the underlying platform's endianness. Carefully test your app on all platforms you intend to support to ensure that correct endianness is used on each platform.
 */
getKIDAtChainDepth(chainDepth: number): string,

/**
 * Gets the chain depth of the license chain represented by the current IPlayReadyLicense interface.
 */
chainDepth: number,

/**
 * Gets the domain account identifier to which this license is bound.
 */
domainAccountID: string,

/**
 * Gets the expiration date of the current license.
 */
expirationDate: Date,

/**
 * Gets the amount of time, in seconds, before the current license expires after the media is first played.
 */
expireAfterFirstPlay: number,

/**
 * Gets the state of the license.
 */
fullyEvaluated: boolean,

/**
 * Gets whether this license is usable for playback.
 */
usableForPlay: boolean
} 


/**
 * Performs a license acquisition process.
 */
declare type Windows$Media$Protection$PlayReady$IPlayReadyLicenseAcquisitionServiceRequest = {

/**
 * Gets the current content header property.
 */
contentHeader: Windows$Media$Protection$PlayReady$PlayReadyContentHeader,

/**
 * Gets the current domain service identifier property that overrides a service identifier in the content header.
 */
domainServiceId: string
} & Windows$Media$Protection$PlayReady$IPlayReadyServiceRequest & Windows$Media$Protection$IMediaProtectionServiceRequest



/**
 * Manages secure stop messages.
 */
declare type Windows$Media$Protection$PlayReady$IPlayReadySecureStopServiceRequest = {

/**
 * Gets the current publisher certificate property.
 */
publisherCertificate: number,

/**
 * Gets the secure stop session identifier property.
 */
sessionID: string,

/**
 * Gets the secure stop session's start time property.
 */
startTime: Date,

/**
 * Gets the secure stop session's stopped flag property which indicates whether the secure stop session for this request was cleanly shut down.
 */
stopped: boolean,

/**
 * Gets the secure stop session's update/stop time property.
 */
updateTime: Date
} & Windows$Media$Protection$PlayReady$IPlayReadyServiceRequest & Windows$Media$Protection$IMediaProtectionServiceRequest



/**
 * Provides the property values for a PlayReady-ND transmitter certificate.
 */
declare interface Windows$Media$Protection$PlayReady$INDTransmitterProperties {

/**
 * Gets the certificate type for the transmitter.
 */
certificateType: $Values<typeof Windows$Media$Protection$PlayReady$NDCertificateType>,

/**
 * Gets the client identifier from the transmitter certificate.
 */
clientID: number,

/**
 * Gets the expiration date and time from the transmitter certificate.
 */
expirationDate: Date,

/**
 * Gets the model digest from a transmitter certificate.
 */
modelDigest: number,

/**
 * Gets the model manufacturer name from a transmitter certificate.
 */
modelManufacturerName: string,

/**
 * Gets the model name from a transmitter certificate.
 */
modelName: string,

/**
 * Gets the model number from a transmitter certificate.
 */
modelNumber: string,

/**
 * Gets the platform identifier from a transmitter certificate.
 */
platformIdentifier: $Values<typeof Windows$Media$Protection$PlayReady$NDCertificatePlatformID>,

/**
 * Gets the security level from a transmitter certificate.
 */
securityLevel: number,

/**
 * Gets the security version from a transmitter certificate.
 */
securityVersion: number,

/**
 * Gets the list of supported features from the transmitter certificate.
 */
supportedFeatures: $Values<typeof Windows$Media$Protection$PlayReady$NDCertificateFeature>
} 

declare class Windows$Media$Protection$ProtectionCapabilities  {
isTypeSupported: any
}


      declare var npm$namespace$Windows$Media$Protection$ProtectionCapabilityResult: {
        
        notSupported: typeof Windows$Media$Protection$ProtectionCapabilityResult$notSupported,
maybe: typeof Windows$Media$Protection$ProtectionCapabilityResult$maybe,
probably: typeof Windows$Media$Protection$ProtectionCapabilityResult$probably,
        
        
        
      }
declare var Windows$Media$Protection$ProtectionCapabilityResult$notSupported: any;

declare var Windows$Media$Protection$ProtectionCapabilityResult$maybe: any;

declare var Windows$Media$Protection$ProtectionCapabilityResult$probably: any;


/**
 * Defines the possible values returned from RenewSystemComponentsAsync .
 */

declare  var Windows$Media$Protection$RenewalStatus: {|
  +notStarted: 0,// 0
+updatesInProgress: 1,// 1
+userCancelled: 2,// 2
+appComponentsMayNeedUpdating: 3,// 3
+noComponentsFound: 4,// 4

|};



/**
 * Contains information about components that need to be revoked and renewed.
 */
declare class Windows$Media$Protection$RevocationAndRenewalInformation  {

/**
 * Returns a list of components that need to be revoked and renewed with updated components.
 */
items: Windows$Foundation$Collections$IVector<Windows$Media$Protection$RevocationAndRenewalItem>
}


/**
 * Represents a component that is being revoked and renewed with a trusted component.
 */
declare class Windows$Media$Protection$RevocationAndRenewalItem  {

/**
 * Returns the header hash for the component being revoked.
 */
headerHash: string;

/**
 * Returns the name for the component being revoked.
 */
name: string;

/**
 * Returns the public key hash for the component.
 */
publicKeyHash: string;

/**
 * Returns the reason for revocation of component.
 */
reasons: $Values<typeof Windows$Media$Protection$RevocationAndRenewalReasons>;

/**
 * Returns the GUID for the renewal object.
 */
renewalId: string
}


/**
 * Defines reasons for the revocation and renewal of a certificate for a media component.
 */

declare  var Windows$Media$Protection$RevocationAndRenewalReasons: {|
  +userModeComponentLoad: 0,// 0
+kernelModeComponentLoad: 1,// 1
+appComponent: 2,// 2
+globalRevocationListLoadFailed: 3,// 3
+invalidGlobalRevocationListSignature: 4,// 4
+globalRevocationListAbsent: 5,// 5
+componentRevoked: 6,// 6
+invalidComponentCertificateExtendedKeyUse: 7,// 7
+componentCertificateRevoked: 8,// 8
+invalidComponentCertificateRoot: 9,// 9
+componentHighSecurityCertificateRevoked: 10,// 10
+componentLowSecurityCertificateRevoked: 11,// 11
+bootDriverVerificationFailed: 12,// 12
+componentSignedWithTestCertificate: 13,// 13
+encryptionFailure: 14,// 14

|};



/**
 * Contains event data for a MediaProtectionManager object when a service is requested.
 */
declare class Windows$Media$Protection$ServiceRequestedEventArgs  {

/**
 * Returns an indication of the completion of the service request.
 */
completion: Windows$Media$Protection$MediaProtectionServiceCompletion;

/**
 * Gets the MediaPlaybackItem associated with the service request.
 */
mediaPlaybackItem: Windows$Media$Playback$MediaPlaybackItem;

/**
 * Contains the service request.
 */
request: Windows$Media$Protection$IMediaProtectionServiceRequest
}


/**
 * Represents the method that handles the data passed by the MediaProtectionManager when a load of binary data fails.
 */
declare type Windows$Media$Protection$ComponentLoadFailedEventHandler = (
ev: Windows$Media$Protection$ComponentLoadFailedEventArgs & Windows$WinRTEvent<Windows$Media$Protection$MediaProtectionManager>) => void;


/**
 * Represents the method that handles the data passed by the MediaProtectionManager that requires a reboot.
 */
declare type Windows$Media$Protection$RebootNeededEventHandler = (
ev: Windows$WinRTEvent<Windows$Media$Protection$MediaProtectionManager>) => void;


/**
 * Represents the method that handles the data passed by the MediaProtectionManager when the resume operation is completed.
 */
declare type Windows$Media$Protection$ServiceRequestedEventHandler = (
ev: Windows$Media$Protection$ServiceRequestedEventArgs & Windows$WinRTEvent<Windows$Media$Protection$MediaProtectionManager>) => void;


/**
 * Allows a content enabler object to be exposed directly to an application rather than through a wrapper supplied by the ContentEnabler object.
 */
declare interface Windows$Media$Protection$IMediaProtectionServiceRequest {

/**
 * Allows the application to identify the content protection system being used and therefore how to interpret the protection task.
 */
protectionSystem: string,

/**
 * Retrieves the GUID for the type of operation that the IMediaProtectionServiceRequest performs.
 */
type: string
} 


      declare var npm$namespace$Windows$Media$Render: {
        
        
        AudioRenderCategory: typeof Windows$Media$Render$AudioRenderCategory,
        
        
      }

/**
 * Describes the purpose of the audio information in an audio stream.
 */

declare  var Windows$Media$Render$AudioRenderCategory: {|
  +other: 0,// 0
+foregroundOnlyMedia: 1,// 1
+backgroundCapableMedia: 2,// 2
+communications: 3,// 3
+alerts: 4,// 4
+soundEffects: 5,// 5
+gameEffects: 6,// 6
+gameMedia: 7,// 7
+gameChat: 8,// 8
+speech: 9,// 9
+movie: 10,// 10
+media: 11,// 11

|};



/**
 * Provides data for the ShuffleEnabledChangeRequested event.
 */
declare class Windows$Media$ShuffleEnabledChangeRequestedEventArgs  {

/**
 * Gets a value indicating whether the request is to enable or disable shuffle.
 */
requestedShuffleEnabled: boolean
}


/**
 * Specifies the sound level of the capture or render stream.
 */

declare  var Windows$Media$SoundLevel: {|
  +muted: 0,// 0
+low: 1,// 1
+full: 2,// 2

|};



      declare var npm$namespace$Windows$Media$SpeechRecognition: {
        
        
        SpeechContinuousRecognitionMode: typeof Windows$Media$SpeechRecognition$SpeechContinuousRecognitionMode,
SpeechRecognitionAudioProblem: typeof Windows$Media$SpeechRecognition$SpeechRecognitionAudioProblem,
SpeechRecognitionConfidence: typeof Windows$Media$SpeechRecognition$SpeechRecognitionConfidence,
SpeechRecognitionConstraintProbability: typeof Windows$Media$SpeechRecognition$SpeechRecognitionConstraintProbability,
SpeechRecognitionConstraintType: typeof Windows$Media$SpeechRecognition$SpeechRecognitionConstraintType,
SpeechRecognitionResultStatus: typeof Windows$Media$SpeechRecognition$SpeechRecognitionResultStatus,
SpeechRecognitionScenario: typeof Windows$Media$SpeechRecognition$SpeechRecognitionScenario,
SpeechRecognizerState: typeof Windows$Media$SpeechRecognition$SpeechRecognizerState,
        SpeechContinuousRecognitionCompletedEventArgs: typeof Windows$Media$SpeechRecognition$SpeechContinuousRecognitionCompletedEventArgs,
SpeechContinuousRecognitionResultGeneratedEventArgs: typeof Windows$Media$SpeechRecognition$SpeechContinuousRecognitionResultGeneratedEventArgs,
SpeechContinuousRecognitionSession: typeof Windows$Media$SpeechRecognition$SpeechContinuousRecognitionSession,
SpeechRecognitionCompilationResult: typeof Windows$Media$SpeechRecognition$SpeechRecognitionCompilationResult,
SpeechRecognitionGrammarFileConstraint: typeof Windows$Media$SpeechRecognition$SpeechRecognitionGrammarFileConstraint,
SpeechRecognitionHypothesis: typeof Windows$Media$SpeechRecognition$SpeechRecognitionHypothesis,
SpeechRecognitionHypothesisGeneratedEventArgs: typeof Windows$Media$SpeechRecognition$SpeechRecognitionHypothesisGeneratedEventArgs,
SpeechRecognitionListConstraint: typeof Windows$Media$SpeechRecognition$SpeechRecognitionListConstraint,
SpeechRecognitionQualityDegradingEventArgs: typeof Windows$Media$SpeechRecognition$SpeechRecognitionQualityDegradingEventArgs,
SpeechRecognitionResult: typeof Windows$Media$SpeechRecognition$SpeechRecognitionResult,
SpeechRecognitionSemanticInterpretation: typeof Windows$Media$SpeechRecognition$SpeechRecognitionSemanticInterpretation,
SpeechRecognitionTopicConstraint: typeof Windows$Media$SpeechRecognition$SpeechRecognitionTopicConstraint,
SpeechRecognitionVoiceCommandDefinitionConstraint: typeof Windows$Media$SpeechRecognition$SpeechRecognitionVoiceCommandDefinitionConstraint,
SpeechRecognizer: typeof Windows$Media$SpeechRecognition$SpeechRecognizer,
SpeechRecognizerStateChangedEventArgs: typeof Windows$Media$SpeechRecognition$SpeechRecognizerStateChangedEventArgs,
SpeechRecognizerTimeouts: typeof Windows$Media$SpeechRecognition$SpeechRecognizerTimeouts,
SpeechRecognizerUIOptions: typeof Windows$Media$SpeechRecognition$SpeechRecognizerUIOptions,
        
      }

/**
 * Contains event data for the SpeechContinuousRecognitionSession.Completed event.
 */
declare class Windows$Media$SpeechRecognition$SpeechContinuousRecognitionCompletedEventArgs  {

/**
 * Gets the result of a speech recognition session, or the result of a grammar constraint compilation.
 */
status: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionResultStatus>
}


/**
 * Specifies the behavior of the speech recognizer during a continuous recognition session.
 */

declare  var Windows$Media$SpeechRecognition$SpeechContinuousRecognitionMode: {|
  +default: 0,// 0
+pauseOnRecognition: 1,// 1

|};



/**
 * Contains event data for the SpeechContinuousRecognitionSession.ResultGenerated event.
 */
declare class Windows$Media$SpeechRecognition$SpeechContinuousRecognitionResultGeneratedEventArgs  {

/**
 * Gets the complete recognition result returned by the speech recognizer at the end of a dictation session ( SpeechRecognitionResultStatus is set to Success).
 */
result: Windows$Media$SpeechRecognition$SpeechRecognitionResult
}


/**
 * Manages speech input for free-form dictation, or an arbitrary sequence of words or phrases that are defined in a grammar set.
 */
declare class Windows$Media$SpeechRecognition$SpeechContinuousRecognitionSession  {

/**
 * Gets or sets the time threshold at which the continuous recognition session ends due to lack of audio input.
 */
autoStopSilenceTimeout: number;

/**
 * Asynchronously cancel the continuous speech recognition session and discard all pending recognition results.
 * @return An asynchronous handler called when the operation is complete.
 */
cancelAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Occurs when a continuous recognition session ends.
 */
oncompleted: Windows$Foundation$TypedEventHandler<Windows$Media$SpeechRecognition$SpeechContinuousRecognitionSession, Windows$Media$SpeechRecognition$SpeechContinuousRecognitionCompletedEventArgs>;
addEventListener(
type: "completed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SpeechRecognition$SpeechContinuousRecognitionSession, Windows$Media$SpeechRecognition$SpeechContinuousRecognitionCompletedEventArgs>): void;
removeEventListener(
type: "completed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SpeechRecognition$SpeechContinuousRecognitionSession, Windows$Media$SpeechRecognition$SpeechContinuousRecognitionCompletedEventArgs>): void;

/**
 * Occurs when the speech recognizer returns the result from a continuous recognition session.
 */
onresultgenerated: Windows$Foundation$TypedEventHandler<Windows$Media$SpeechRecognition$SpeechContinuousRecognitionSession, Windows$Media$SpeechRecognition$SpeechContinuousRecognitionResultGeneratedEventArgs>;
addEventListener(
type: "resultgenerated",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SpeechRecognition$SpeechContinuousRecognitionSession, Windows$Media$SpeechRecognition$SpeechContinuousRecognitionResultGeneratedEventArgs>): void;
removeEventListener(
type: "resultgenerated",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SpeechRecognition$SpeechContinuousRecognitionSession, Windows$Media$SpeechRecognition$SpeechContinuousRecognitionResultGeneratedEventArgs>): void;

/**
 * Asynchronously pause a continuous speech recognition session.
 * @return An asynchronous handler called when the operation is complete.
 */
pauseAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Resumes a continuous speech recognition session, if paused.
 */
resume(): void;

/**
 * Overload
 * @param mode The speech recognition behavior.
 * @return An asynchronous handler called when the operation is complete.
 */
startAsync(
mode: $Values<typeof Windows$Media$SpeechRecognition$SpeechContinuousRecognitionMode>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Overload
 * @return An asynchronous handler called when the operation is complete.
 */
startAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously end a continuous speech recognition session and pass all pending recognition results to the ResultGenerated event.
 * @return An asynchronous handler called when the operation is complete.
 */
stopAsync(): Windows$Foundation$IPromiseWithIAsyncAction;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies the type of audio problem detected.
 */

declare  var Windows$Media$SpeechRecognition$SpeechRecognitionAudioProblem: {|
  +none: 0,// 0
+tooNoisy: 1,// 1
+noSignal: 2,// 2
+tooLoud: 3,// 3
+tooQuiet: 4,// 4
+tooFast: 5,// 5
+tooSlow: 6,// 6

|};



/**
 * The result of compiling the constraints set for a SpeechRecognizer object.
 */
declare class Windows$Media$SpeechRecognition$SpeechRecognitionCompilationResult  {

/**
 * Gets the result state ( SpeechRecognitionResultStatus ) from the compiling of grammar constraints.
 */
status: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionResultStatus>
}


/**
 * Specifies confidence levels that indicate how accurately a spoken phrase was matched to a phrase in an active constraint.
 */

declare  var Windows$Media$SpeechRecognition$SpeechRecognitionConfidence: {|
  +high: 0,// 0
+medium: 1,// 1
+low: 2,// 2
+rejected: 3,// 3

|};



/**
 * Specifies the weighted value of a constraint for speech recognition.
 */

declare  var Windows$Media$SpeechRecognition$SpeechRecognitionConstraintProbability: {|
  +default: 0,// 0
+min: 1,// 1
+max: 2,// 2

|};



/**
 * Specifies the type of pre-defined grammar constraint used for speech recognition.
 */

declare  var Windows$Media$SpeechRecognition$SpeechRecognitionConstraintType: {|
  +topic: 0,// 0
+list: 1,// 1
+grammar: 2,// 2
+voiceCommandDefinition: 3,// 3

|};



/**
 * A constraint for a SpeechRecognizer object based on a Speech Recognition Grammar Specification (SRGS) file.
 */
declare class Windows$Media$SpeechRecognition$SpeechRecognitionGrammarFileConstraint  {

/**
 * Creates an instance of the SpeechRecognitionGrammarFileConstraint class from a file object.
 * @param file An object representing a SRGS grammar file.
 */
constructor(file: Windows$Storage$StorageFile): this;

/**
 * Creates an instance of the SpeechRecognitionGrammarFileConstraint class from a file object and a tag.
 * @param file An object representing a SRGS grammar file.
 * @param tag The tag to assign to the constraint.
 */
constructor(file: Windows$Storage$StorageFile, tag: string): this;

/**
 * Gets the StorageFile object representing the Speech Recognition Grammar Specification (SRGS) grammar file.
 */
grammarFile: Windows$Storage$StorageFile;

/**
 * Gets or sets whether the constraint can be used by the speech recognizer to perform recognition.
 */
isEnabled: boolean;

/**
 * Gets or sets the weighted value of the constraint.
 */
probability: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionConstraintProbability>;

/**
 * Gets or sets a tag that can be useful for identifying the constraint.
 */
tag: string;

/**
 * Gets the type of the constraint.
 */
type: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionConstraintType>
}


/**
 * A recognition result fragment returned by the speech recognizer during an ongoing dictation session.
 */
declare class Windows$Media$SpeechRecognition$SpeechRecognitionHypothesis  {

/**
 * Gets the text of the hypothesis, or recognition result fragment, returned by the speech recognizer during an ongoing dictation session.
 */
text: string
}


/**
 * Contains event data for the SpeechRecognizer.HypothesisGenerated event.
 */
declare class Windows$Media$SpeechRecognition$SpeechRecognitionHypothesisGeneratedEventArgs  {

/**
 * Gets a recognition result fragment returned by the speech recognizer during an ongoing dictation session.
 */
hypothesis: Windows$Media$SpeechRecognition$SpeechRecognitionHypothesis
}


/**
 * A constraint for a SpeechRecognizer object based on a list of words or phrases. When initialized, this object is added to the Constraints collection.
 */
declare class Windows$Media$SpeechRecognition$SpeechRecognitionListConstraint  {

/**
 * Creates an instance of the SpeechRecognitionListConstraint class from an array of words or phrases.
 * @param commands A string array of words or phrases that make up the constraint.
 */
constructor(commands: Windows$Foundation$Collections$IIterable<string>): this;

/**
 * Creates an instance of the SpeechRecognitionListConstraint class from an array of words or phrases and a tag.
 * @param commands A string array of words or phrases that make up the constraint.
 * @param tag The tag to assign to the constraint.
 */
constructor(commands: Windows$Foundation$Collections$IIterable<string>, tag: string): this;

/**
 * Gets the array of words or phrases that make up the constraint.
 */
commands: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets or sets whether the constraint can be used by the speech recognizer to perform recognition.
 */
isEnabled: boolean;

/**
 * Gets or sets the weighted value of the constraint.
 */
probability: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionConstraintProbability>;

/**
 * Gets or sets a tag that can be useful for identifying the constraint.
 */
tag: string;

/**
 * Gets the type of the constraint.
 */
type: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionConstraintType>
}


/**
 * Provides data for the SpeechRecognitionQualityDegradingEvent event.
 */
declare class Windows$Media$SpeechRecognition$SpeechRecognitionQualityDegradingEventArgs  {

/**
 * Gets the audio problem that occurred.
 */
problem: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionAudioProblem>
}


/**
 * The result of a speech recognition session.
 */
declare class Windows$Media$SpeechRecognition$SpeechRecognitionResult  {

/**
 * Gets a value that indicates the confidence of the speech recognizer in the recognition result.
 */
confidence: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionConfidence>;

/**
 * Gets the constraint that was triggered to return the recognized phrase.
 */
constraint: Windows$Media$SpeechRecognition$ISpeechRecognitionConstraint;

/**
 * Gets a collection of recognition result alternatives, ordered by RawConfidence from most likely to least likely. The first item in the collection is the recognition result indicated by the parent object.
 * @param maxAlternates The maximum number of speech recognition results to return in the collection.
 * @return A collection of speech recognition results, ordered by confidence from most likely to least likely.
 */
getAlternates(
maxAlternates: number): Windows$Foundation$Collections$IVectorView<Windows$Media$SpeechRecognition$SpeechRecognitionResult>;

/**
 * Gets the amount of time required for the utterance.
 */
phraseDuration: number;

/**
 * Gets the start time of the utterance.
 */
phraseStartTime: Date;

/**
 * Gets a value that indicates the relative confidence of the SpeechRecognitionResult when compared with a collection of alternatives returned with the recognition result.
 */
rawConfidence: number;

/**
 * Gets the hierarchy of rule elements that were triggered to return the recognized phrase.
 */
rulePath: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets an interpretation object containing the semantic properties of a recognized phrase in a Speech Recognition Grammar Specification (SRGS) grammar.
 */
semanticInterpretation: Windows$Media$SpeechRecognition$SpeechRecognitionSemanticInterpretation;

/**
 * Gets the result state ( SpeechRecognitionResultStatus ) of a speech recognition session.
 */
status: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionResultStatus>;

/**
 * Gets the recognized phrase of the speech recognition session.
 */
text: string
}


/**
 * Specifies the possible result states of a speech recognition session or from the compiling of grammar constraints.
 */

declare  var Windows$Media$SpeechRecognition$SpeechRecognitionResultStatus: {|
  +success: 0,// 0
+topicLanguageNotSupported: 1,// 1
+grammarLanguageMismatch: 2,// 2
+grammarCompilationFailure: 3,// 3
+audioQualityFailure: 4,// 4
+userCanceled: 5,// 5
+unknown: 6,// 6
+timeoutExceeded: 7,// 7
+pauseLimitExceeded: 8,// 8
+networkFailure: 9,// 9
+microphoneUnavailable: 10,// 10

|};



/**
 * Specifies the scenario used to optimize speech recognition for a web-service constraint (created through a SpeechRecognitionTopicConstraint object).
 */

declare  var Windows$Media$SpeechRecognition$SpeechRecognitionScenario: {|
  +webSearch: 0,// 0
+dictation: 1,// 1
+formFilling: 2,// 2

|};



/**
 * Represents the semantic properties of a recognized phrase in a Speech Recognition Grammar Specification (SRGS) grammar.
 */
declare class Windows$Media$SpeechRecognition$SpeechRecognitionSemanticInterpretation  {

/**
 * Gets a dictionary of the semantic properties.
 */
properties: Windows$Foundation$Collections$IMapView<string, Windows$Foundation$Collections$IVectorView<any>>
}


/**
 * A pre-defined grammar constraint (specifed by SpeechRecognitionScenario ) provided through a web service.
 */
declare class Windows$Media$SpeechRecognition$SpeechRecognitionTopicConstraint  {

/**
 * Creates an instance of the SpeechRecognitionTopicConstraint class by using a pre-defined scenario type, context, and an identifier.
 * @param scenario A predefined scenario type.
 * @param topicHint A subject, or context hint, used to optimize recognition.
 * @param tag Identifier for the constraint.
 */
constructor(scenario: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionScenario>, topicHint: string, tag: string): this;

/**
 * Creates an instance of the SpeechRecognitionTopicConstraint class by using a pre-defined scenario type and context.
 * @param scenario A predefined scenario type.
 * @param topicHint A subject, or context hint, used to optimize recognition.
 */
constructor(scenario: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionScenario>, topicHint: string): this;

/**
 * Gets or sets whether the constraint can be used by the SpeechRecognizer object to perform recognition.
 */
isEnabled: boolean;

/**
 * Gets or sets the weighted value of the constraint.
 */
probability: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionConstraintProbability>;

/**
 * Gets the predefined scenario type for the constraint.
 */
scenario: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionScenario>;

/**
 * Gets or sets a tag that can be useful for identifying the constraint.
 */
tag: string;

/**
 * Gets the topic hint for the constraint.
 */
topicHint: string;

/**
 * Gets the type of the constraint.
 */
type: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionConstraintType>
}


/**
 * A constraint for a SpeechRecognizer object based on a Voice Command Definition (VCD) file.
 */
declare class Windows$Media$SpeechRecognition$SpeechRecognitionVoiceCommandDefinitionConstraint  {

/**
 * Gets or sets whether the constraint can be used by the SpeechRecognizer object to perform recognition.
 */
isEnabled: boolean;

/**
 * Gets or sets the weighted value of the constraint.
 */
probability: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionConstraintProbability>;

/**
 * Gets or sets a tag that can be useful for identifying the constraint.
 */
tag: string;

/**
 * Gets the type of the constraint.
 */
type: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionConstraintType>
}


/**
 * Enables speech recognition with either a default or a custom graphical user interface (GUI).
 */
declare class Windows$Media$SpeechRecognition$SpeechRecognizer  {

/**
 * Gets the collection of languages supported by the custom grammars of the SpeechRecognitionGrammarFileConstraint and SpeechRecognitionListConstraint objects specified in the Constraints property.
 */
static supportedGrammarLanguages: Windows$Foundation$Collections$IVectorView<Windows$Globalization$Language>;

/**
 * Gets the collection of languages supported by the pre-defined, web-service grammars of the SpeechRecognitionTopicConstraint objects specified in the Constraints property.
 */
static supportedTopicLanguages: Windows$Foundation$Collections$IVectorView<Windows$Globalization$Language>;

/**
 * Gets the language of the device specified in Settings > Time & Language > Speech.
 */
static systemSpeechLanguage: Windows$Globalization$Language;

/**
 * Creates a new instance of the SpeechRecognizer class.
 */
constructor(): this;

/**
 * Creates a new instance of the SpeechRecognizer class with a language specifier.
 * @param language The spoken language to use for recognition.
 */
constructor(language: Windows$Globalization$Language): this;

/**
 * Disposes the speech recognizer by freeing, releasing, or resetting allocated resources.
 */
close(): void;

/**
 * Asynchronously compile all constraints specified by the Constraints property.
 * @return The result of the constraints compilation as a SpeechRecognitionCompilationResult object.
 */
compileConstraintsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$SpeechRecognition$SpeechRecognitionCompilationResult>;

/**
 * Gets the collection of constraint objects that are associated with the SpeechRecognizer object.
 */
constraints: Windows$Foundation$Collections$IVector<Windows$Media$SpeechRecognition$ISpeechRecognitionConstraint>;

/**
 * Gets the continuous recognition session object ( SpeechContinuousRecognitionSession ) associated with this SpeechRecognizer .
 */
continuousRecognitionSession: Windows$Media$SpeechRecognition$SpeechContinuousRecognitionSession;

/**
 * Gets the language used for speech recognition.
 */
currentLanguage: Windows$Globalization$Language;

/**
 * Occurs during an ongoing dictation session when a recognition result fragment is returned by the speech recognizer.
 */
onhypothesisgenerated: Windows$Foundation$TypedEventHandler<Windows$Media$SpeechRecognition$SpeechRecognizer, Windows$Media$SpeechRecognition$SpeechRecognitionHypothesisGeneratedEventArgs>;
addEventListener(
type: "hypothesisgenerated",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SpeechRecognition$SpeechRecognizer, Windows$Media$SpeechRecognition$SpeechRecognitionHypothesisGeneratedEventArgs>): void;
removeEventListener(
type: "hypothesisgenerated",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SpeechRecognition$SpeechRecognizer, Windows$Media$SpeechRecognition$SpeechRecognitionHypothesisGeneratedEventArgs>): void;

/**
 * This event is raised when an audio problem is detected that might affect recognition accuracy.
 */
onrecognitionqualitydegrading: Windows$Foundation$TypedEventHandler<Windows$Media$SpeechRecognition$SpeechRecognizer, Windows$Media$SpeechRecognition$SpeechRecognitionQualityDegradingEventArgs>;
addEventListener(
type: "recognitionqualitydegrading",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SpeechRecognition$SpeechRecognizer, Windows$Media$SpeechRecognition$SpeechRecognitionQualityDegradingEventArgs>): void;
removeEventListener(
type: "recognitionqualitydegrading",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SpeechRecognition$SpeechRecognizer, Windows$Media$SpeechRecognition$SpeechRecognitionQualityDegradingEventArgs>): void;

/**
 * This event is raised when a change occurs to the State property during audio capture.
 */
onstatechanged: Windows$Foundation$TypedEventHandler<Windows$Media$SpeechRecognition$SpeechRecognizer, Windows$Media$SpeechRecognition$SpeechRecognizerStateChangedEventArgs>;
addEventListener(
type: "statechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SpeechRecognition$SpeechRecognizer, Windows$Media$SpeechRecognition$SpeechRecognizerStateChangedEventArgs>): void;
removeEventListener(
type: "statechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SpeechRecognition$SpeechRecognizer, Windows$Media$SpeechRecognition$SpeechRecognizerStateChangedEventArgs>): void;

/**
 * Begins a speech recognition session for a SpeechRecognizer object.
 * @return The result of the speech recognition session that was initiated by the SpeechRecognizer object.
 */
recognizeAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$SpeechRecognition$SpeechRecognitionResult>;

/**
 * Asynchronously starts a speech recognition session that includes additional UI mechanisms, including prompts, examples, text-to-speech (TTS), and confirmations.
 * @return The result of the speech recognition session as a SpeechRecognitionResult object.
 */
recognizeWithUIAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$SpeechRecognition$SpeechRecognitionResult>;

/**
 * Gets the state of the speech recognizer.
 */
state: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognizerState>;

/**
 * Asynchronously ends the speech recognition session.
 * @return No object or value is returned when this method completes.
 */
stopRecognitionAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets how long a speech recognizer ignores silence or unrecognizable sounds (babble) and continues listening for speech input.
 */
timeouts: Windows$Media$SpeechRecognition$SpeechRecognizerTimeouts;

/**
 * Gets the UI settings for the RecognizeWithUIAsync method.
 */
uiOptions: Windows$Media$SpeechRecognition$SpeechRecognizerUIOptions;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies the state of the speech recognizer.
 */

declare  var Windows$Media$SpeechRecognition$SpeechRecognizerState: {|
  +idle: 0,// 0
+capturing: 1,// 1
+processing: 2,// 2
+soundStarted: 3,// 3
+soundEnded: 4,// 4
+speechDetected: 5,// 5
+paused: 6,// 6

|};



/**
 * Provides data for the SpeechRecognizer.StateChangedEvent event.
 */
declare class Windows$Media$SpeechRecognition$SpeechRecognizerStateChangedEventArgs  {

/**
 * Gets the audio capture state.
 */
state: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognizerState>
}


/**
 * The timespan that a speech recognizer ignores silence or unrecognizable sounds (babble) and continues listening for speech input.
 */
declare class Windows$Media$SpeechRecognition$SpeechRecognizerTimeouts  {

/**
 * Gets and sets the length of time that a SpeechRecognizer continues to listen while receiving unrecognizable sounds (babble) before it assumes speech input has ended and finalizes the recognition operation.
 */
babbleTimeout: number;

/**
 * Gets and sets the length of time, after recognition results have been generated, that a SpeechRecognizer detects silence and assumes speech input has ended.
 */
endSilenceTimeout: number;

/**
 * Gets and sets the length of time, before any recognition results have been generated, that a SpeechRecognizer detects silence and assumes speech input has ended.
 */
initialSilenceTimeout: number
}


/**
 * Specifies the UI settings for the SpeechRecognizer.RecognizeWithUIAsync method.
 */
declare class Windows$Media$SpeechRecognition$SpeechRecognizerUIOptions  {

/**
 * Gets or sets the heading text that is displayed on the Listening screen. The default is "Listening...".
 */
audiblePrompt: string;

/**
 * Gets or sets the example text shown on the Listening screen.
 */
exampleText: string;

/**
 * Gets or sets whether the recognized text is spoken back to the user on the Heard you say screen.
 */
isReadBackEnabled: boolean;

/**
 * Gets or sets whether a Heard you say screen is shown to the user after speech recognition is completed.
 */
showConfirmation: boolean
}


/**
 * Represents a constraint for a SpeechRecognizer object.
 */
declare interface Windows$Media$SpeechRecognition$ISpeechRecognitionConstraint {

/**
 * Gets or sets whether the constraint can be used by the SpeechRecognizer object to perform recognition.
 */
isEnabled: boolean,

/**
 * Gets or sets the weighted value of the constraint.
 */
probability: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionConstraintProbability>,

/**
 * Gets or sets a tag that can be useful for identifying the constraint.
 */
tag: string,

/**
 * Gets the type of the constraint.
 */
type: $Values<typeof Windows$Media$SpeechRecognition$SpeechRecognitionConstraintType>
} 


      declare var npm$namespace$Windows$Media$SpeechSynthesis: {
        
        
        VoiceGender: typeof Windows$Media$SpeechSynthesis$VoiceGender,
        SpeechSynthesisStream: typeof Windows$Media$SpeechSynthesis$SpeechSynthesisStream,
SpeechSynthesizer: typeof Windows$Media$SpeechSynthesis$SpeechSynthesizer,
VoiceInformation: typeof Windows$Media$SpeechSynthesis$VoiceInformation,
        
      }

/**
 * Supports reading and writing audio data generated by the speech synthesis engine (voice) to/from a random access stream.
 */
declare class Windows$Media$SpeechSynthesis$SpeechSynthesisStream  {

/**
 * Gets whether SpeechSynthesisStream can be read from.
 */
canRead: boolean;

/**
 * Gets a value that indicates whether SpeechSynthesisStream can be written to.
 */
canWrite: boolean;

/**
 * Creates a copy of SpeechSynthesisStream that references the same bytes as the original stream.
 * @return The new stream.
 */
cloneStream(): Windows$Storage$Streams$IRandomAccessStream;

/**
 * Releases system resources that are exposed by SpeechSynthesisStream .
 */
close(): void;

/**
 * Gets the MIME type of the content of SpeechSynthesisStream .
 */
contentType: string;

/**
 * Flushes data asynchronously in a sequential stream.
 * @return An asynchronous operation. For more information, see FlushAsync method.
 */
flushAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Retrieves an input stream at a specified location in SpeechSynthesisStream .
 * @param position The location in the stream at which to begin.
 * @return The input stream.
 */
getInputStreamAt(position: number): Windows$Storage$Streams$IInputStream;

/**
 * Retrieves an output stream at a specified location in SpeechSynthesisStream .
 * @param position The location in the stream at which to begin.
 * @return The output stream.
 */
getOutputStreamAt(position: number): Windows$Storage$Streams$IOutputStream;

/**
 * Gets the collection of timeline markers associated with SpeechSynthesisStream .
 */
markers: Windows$Foundation$Collections$IVectorView<Windows$Media$IMediaMarker>;

/**
 * Gets the position within SpeechSynthesisStream .
 */
position: number;

/**
 * Reads data asynchronously in a sequential stream.
 * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param count The number of bytes to read that is less than or equal to the Capacity value.
 * @param options Specifies the type of the asynchronous read operation.
 * @return An asynchronous operation that includes progress updates. For more information, see ReadAsync method.
 */
readAsync(
buffer: Windows$Storage$Streams$IBuffer,
count: number,
options: $Values<typeof Windows$Storage$Streams$InputStreamOptions>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>;

/**
 * Goes to the specified position within SpeechSynthesisStream .
 * @param position The desired position within the stream.
 */
seek(position: number): void;

/**
 * Gets or sets the size of the SpeechSynthesisStream .
 */
size: number;

/**
 * Writes data asynchronously in a sequential stream.
 * @param buffer The buffer into which the asynchronous writer operation places the bytes to write.
 * @return An asynchronous operation that includes progress updates. For more information, see WriteAsync method.
 */
writeAsync(
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Provides access to the functionality of an installed speech synthesis engine (voice).
 */
declare class Windows$Media$SpeechSynthesis$SpeechSynthesizer  {

/**
 * Gets a collection of all installed speech synthesis engines (voices).
 */
static allVoices: Windows$Foundation$Collections$IVectorView<Windows$Media$SpeechSynthesis$VoiceInformation>;

/**
 * Gets the default speech synthesis engine (voice).
 */
static defaultVoice: Windows$Media$SpeechSynthesis$VoiceInformation;

/**
 * Initializes a new instance of a SpeechSynthesizer object.
 */
constructor(): this;

/**
 * Closes the SpeechSynthesizer and releases system resources.
 */
close(): void;

/**
 * Asynchronously generate speech output from a string containing Speech Synthesis Markup Language (SSML).
 * @param Ssml The SSML-modified text to speak.
 * @return A SpeechSynthesisStream that represents the speech generated from the Speech Synthesis Markup Language (SSML).
 */
synthesizeSsmlToStreamAsync(
Ssml: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$SpeechSynthesis$SpeechSynthesisStream>;

/**
 * Asynchronously generate speech output from a string.
 * @param text The text to speak.
 * @return A SpeechSynthesisStream that represents the speech generated from the text.
 */
synthesizeTextToStreamAsync(
text: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$SpeechSynthesis$SpeechSynthesisStream>;

/**
 * Gets or sets the speech synthesis engine (voice).
 */
voice: Windows$Media$SpeechSynthesis$VoiceInformation
}


/**
 * Specifies the gender settings for an installed speech synthesis engine (voice).
 */

declare  var Windows$Media$SpeechSynthesis$VoiceGender: {|
  +male: 0,// 0
+female: 1,// 1

|};



/**
 * Provides info about an installed speech synthesis engine (voice).
 */
declare class Windows$Media$SpeechSynthesis$VoiceInformation  {

/**
 * Gets the description of the speech synthesis engine (voice).
 */
description: string;

/**
 * Gets the display name associated with the speech synthesis engine (voice).
 */
displayName: string;

/**
 * Gets the gender setting of the speech synthesis engine (voice).
 */
gender: $Values<typeof Windows$Media$SpeechSynthesis$VoiceGender>;

/**
 * Gets the unique ID of the speech synthesis engine (voice).
 */
id: string;

/**
 * Gets the normalized BCP-47 language tag of the speech synthesis engine (voice).
 */
language: string
}


      declare var npm$namespace$Windows$Media$Streaming: {
        
        
        
        
        Adaptive: typeof npm$namespace$Windows$Media$Streaming$Adaptive,
      }

      declare var npm$namespace$Windows$Media$Streaming$Adaptive: {
        
        
        AdaptiveMediaSourceCreationStatus: typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceCreationStatus,
AdaptiveMediaSourceResourceType: typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceResourceType,
        AdaptiveMediaSource: typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSource,
AdaptiveMediaSourceAdvancedSettings: typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceAdvancedSettings,
AdaptiveMediaSourceCreationResult: typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceCreationResult,
AdaptiveMediaSourceDownloadBitrateChangedEventArgs: typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadBitrateChangedEventArgs,
AdaptiveMediaSourceDownloadCompletedEventArgs: typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadCompletedEventArgs,
AdaptiveMediaSourceDownloadFailedEventArgs: typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadFailedEventArgs,
AdaptiveMediaSourceDownloadRequestedDeferral: typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadRequestedDeferral,
AdaptiveMediaSourceDownloadRequestedEventArgs: typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadRequestedEventArgs,
AdaptiveMediaSourceDownloadResult: typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadResult,
AdaptiveMediaSourcePlaybackBitrateChangedEventArgs: typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSourcePlaybackBitrateChangedEventArgs,
        
      }

/**
 * Represents the source of adaptive streaming content.
 */
declare class Windows$Media$Streaming$Adaptive$AdaptiveMediaSource  {

/**
 * Asynchronously creates a AdaptiveMediaSource object from the provided input stream.
 * @param stream The input stream from which the AdaptiveMediaSource is created.
 * @param uri The URI of the source. This is used by the AdaptiveMediaSource to resolve relative URIs.
 * @param contentType A string that identifies the MIME content type of the source. This can be an Http Live Streaming (HLS) or a Dynamic Adaptive Streaming over HTTP (DASH) content type.
 * @param httpClient The HttpClient instance that the AdaptiveMediaSource should use for downloading resources. This allows you to specify custom HTTP headers for the requests.
 * @return Returns an AdaptiveMediaSourceCreationResult upon successful completion.
 */
static createFromStreamAsync(
stream: Windows$Storage$Streams$IInputStream,
uri: Windows$Foundation$Uri,
contentType: string,
httpClient: Windows$Web$Http$HttpClient): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceCreationResult>;

/**
 * Asynchronously creates a AdaptiveMediaSource object from the provided input stream.
 * @param stream The input stream from which the AdaptiveMediaSource is created.
 * @param uri The URI of the source. This is used by the AdaptiveMediaSource to resolve relative URIs.
 * @param contentType A string that identifies the MIME content type of the source. This can be an Http Live Streaming (HLS) or a Dynamic Adaptive Streaming over HTTP (DASH) content type.
 * @return Returns an AdaptiveMediaSourceCreationResult upon successful completion.
 */
static createFromStreamAsync(
stream: Windows$Storage$Streams$IInputStream,
uri: Windows$Foundation$Uri,
contentType: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceCreationResult>;

/**
 * Asynchronously creates a AdaptiveMediaSource object from the Uniform Resource Identifier (URI) of the source.
 * @param uri T he URI of the source.
 * @return Returns an AdaptiveMediaSourceCreationResult upon successful completion.
 */
static createFromUriAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceCreationResult>;

/**
 * Asynchronously creates a AdaptiveMediaSource object from the Uniform Resource Identifier (URI) of the source.
 * @param uri T he URI of the source.
 * @param httpClient The HttpClient instance that the AdaptiveMediaSource should use for downloading resources. This allows you to specify custom HTTP headers for the requests.
 * @return Returns an AdaptiveMediaSourceCreationResult upon successful completion.
 */
static createFromUriAsync(
uri: Windows$Foundation$Uri,
httpClient: Windows$Web$Http$HttpClient): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceCreationResult>;

/**
 * Determines whether the content type of the source is supported.
 * @param contentType A string that identifies the content type of the source. Can be a Http Live Streaming (HLS) or Dynamic Adaptive Streaming over HTTP (DASH) content type.
 * @return Returns a value that indicates whether the content type of the source is supported. true if supported; otherwise, false.
 */
static isContentTypeSupported(contentType: string): boolean;
advancedSettings: any;

/**
 * Gets a value indicating if the content streamed by the media source contains only audio.
 */
audioOnlyPlayback: boolean;

/**
 * Gets the available adaptive bit rates of the adaptive streaming manifest that is the source of the adaptive streaming object.
 */
availableBitrates: Windows$Foundation$Collections$IVectorView<number>;

/**
 * Gets a value indicating the current download bitrate for the media source.
 */
currentDownloadBitrate: number;

/**
 * Gets a value indicating the current playback bitrate for the media source.
 */
currentPlaybackBitrate: number;

/**
 * Gets or sets the desired starting offset for the live playback of the media source.
 */
desiredLiveOffset: number;

/**
 * Gets or sets the desired maximum bitrate for the media source.
 */
desiredMaxBitrate: number;

/**
 * Gets or sets the desired minimum bitrate for the media source.
 */
desiredMinBitrate: number;

/**
 * Gets a value indicating the inbound bits per second statistic over the time window specified by the InboundBitsPerSecondWindow property.
 */
inboundBitsPerSecond: number;

/**
 * Gets or sets the time span over which the InboundBitsPerSecond property is calculated.
 */
inboundBitsPerSecondWindow: number;

/**
 * Gets and sets the initial bit rate to use for playback of the media source.
 */
initialBitrate: number;

/**
 * Gets a value that indicates whether the media source is live.
 */
isLive: boolean;

/**
 * Occurs when the CurrentDownloadBitrate changes.
 */
ondownloadbitratechanged: Windows$Foundation$TypedEventHandler<Windows$Media$Streaming$Adaptive$AdaptiveMediaSource, Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadBitrateChangedEventArgs>;
addEventListener(
type: "downloadbitratechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Streaming$Adaptive$AdaptiveMediaSource, Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadBitrateChangedEventArgs>): void;
removeEventListener(
type: "downloadbitratechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Streaming$Adaptive$AdaptiveMediaSource, Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadBitrateChangedEventArgs>): void;

/**
 * Occurs when a resource download operation completes
 */
ondownloadcompleted: Windows$Foundation$TypedEventHandler<Windows$Media$Streaming$Adaptive$AdaptiveMediaSource, Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadCompletedEventArgs>;
addEventListener(
type: "downloadcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Streaming$Adaptive$AdaptiveMediaSource, Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadCompletedEventArgs>): void;
removeEventListener(
type: "downloadcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Streaming$Adaptive$AdaptiveMediaSource, Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadCompletedEventArgs>): void;

/**
 * Occurs when a resource download operation fails.
 */
ondownloadfailed: Windows$Foundation$TypedEventHandler<Windows$Media$Streaming$Adaptive$AdaptiveMediaSource, Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadFailedEventArgs>;
addEventListener(
type: "downloadfailed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Streaming$Adaptive$AdaptiveMediaSource, Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadFailedEventArgs>): void;
removeEventListener(
type: "downloadfailed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Streaming$Adaptive$AdaptiveMediaSource, Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadFailedEventArgs>): void;

/**
 * Occurs when a resource download operation is requested.
 */
ondownloadrequested: Windows$Foundation$TypedEventHandler<Windows$Media$Streaming$Adaptive$AdaptiveMediaSource, Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadRequestedEventArgs>;
addEventListener(
type: "downloadrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Streaming$Adaptive$AdaptiveMediaSource, Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadRequestedEventArgs>): void;
removeEventListener(
type: "downloadrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Streaming$Adaptive$AdaptiveMediaSource, Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadRequestedEventArgs>): void;

/**
 * Occurs when the CurrentPlaybackBitrate changes.
 */
onplaybackbitratechanged: Windows$Foundation$TypedEventHandler<Windows$Media$Streaming$Adaptive$AdaptiveMediaSource, Windows$Media$Streaming$Adaptive$AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>;
addEventListener(
type: "playbackbitratechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Streaming$Adaptive$AdaptiveMediaSource, Windows$Media$Streaming$Adaptive$AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>): void;
removeEventListener(
type: "playbackbitratechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$Streaming$Adaptive$AdaptiveMediaSource, Windows$Media$Streaming$Adaptive$AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}

declare class Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceAdvancedSettings  {
allSegmentsIndependent: any;
bitrateDowngradeTriggerRatio: any;
desiredBitrateHeadroomRatio: any
}


/**
 * Represents the result of the creation of a AdaptiveMediaSource object.
 */
declare class Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceCreationResult  {

/**
 * Gets the HTTP response message, if any, returned from an attempt to create a AdaptiveMediaSource object.
 */
httpResponseMessage: Windows$Web$Http$HttpResponseMessage;

/**
 * Gets the AdaptiveMediaSource object that represents the source of adaptive streaming content.
 */
mediaSource: Windows$Media$Streaming$Adaptive$AdaptiveMediaSource;

/**
 * Gets the status of an attempt to create a AdaptiveMediaSource object.
 */
status: $Values<typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceCreationStatus>
}


/**
 * Specifies the result of an attempt to create a AdaptiveMediaSource object.
 */

declare  var Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceCreationStatus: {|
  +success: 0,// 0
+manifestDownloadFailure: 1,// 1
+manifestParseFailure: 2,// 2
+unsupportedManifestContentType: 3,// 3
+unsupportedManifestVersion: 4,// 4
+unsupportedManifestProfile: 5,// 5
+unknownFailure: 6,// 6

|};



/**
 * Provides data for the DownloadBitrateChanged event.
 */
declare class Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadBitrateChangedEventArgs  {

/**
 * Gets a value indicating the new download bitrate for the media source.
 */
newValue: number;

/**
 * Gets a value indicating the previous download bitrate for the media source.
 */
oldValue: number
}


/**
 * Provides data for the DownloadCompleted event.
 */
declare class Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadCompletedEventArgs  {

/**
 * Gets the http response message, if any, returned from the completed media download request.
 */
httpResponseMessage: Windows$Web$Http$HttpResponseMessage;

/**
 * Gets the byte range length of the completed media download request.
 */
resourceByteRangeLength: number;

/**
 * Gets the byte range offset of the completed media download request.
 */
resourceByteRangeOffset: number;

/**
 * Gets the resource type of the completed media download request.
 */
resourceType: $Values<typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceResourceType>;

/**
 * Gets the resource URI of the completed media download request.
 */
resourceUri: Windows$Foundation$Uri
}


/**
 * Provides data for the DownloadFailed event.
 */
declare class Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadFailedEventArgs  {

/**
 * Gets the http response message, if any, returned from the failed media download request.
 */
httpResponseMessage: Windows$Web$Http$HttpResponseMessage;

/**
 * Gets the byte range length of the failed media download request.
 */
resourceByteRangeLength: number;

/**
 * Gets the byte range offset of the failed media download request.
 */
resourceByteRangeOffset: number;

/**
 * Gets the resource type of the failed media download request.
 */
resourceType: $Values<typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceResourceType>;

/**
 * Gets the resource URI of the failed media download request.
 */
resourceUri: Windows$Foundation$Uri
}


/**
 * Represents a deferral that can be used to defer the completion of the DownloadRequested event so that the app can asynchronously download media content.
 */
declare class Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadRequestedDeferral  {

/**
 * Informs the system that an asynchronous operation associated with a DownloadRequested event has finished.
 */
complete(): void
}


/**
 * Provides data for the DownloadRequested event.
 */
declare class Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadRequestedEventArgs  {

/**
 * Gets a deferral that can be used to defer the completion of the DownloadRequested event so that the app can asynchronously download media content.
 * @return A deferral that can be used to defer the completion of the DownloadRequested event.
 */
getDeferral(
): Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadRequestedDeferral;

/**
 * Gets the byte range length of the media download request.
 */
resourceByteRangeLength: number;

/**
 * Gets the byte range offset of the media download request.
 */
resourceByteRangeOffset: number;

/**
 * Gets the resource type of the media download request.
 */
resourceType: $Values<typeof Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceResourceType>;

/**
 * Gets the resource URI of the media download request.
 */
resourceUri: Windows$Foundation$Uri;

/**
 * Gets an AdaptiveMediaSourceDownloadResult object representing the result of the media download request.
 */
result: Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadResult
}


/**
 * Represents the results of a resource download operation.
 */
declare class Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceDownloadResult  {

/**
 * Gets or sets a buffer containing the downloaded resource.
 */
buffer: Windows$Storage$Streams$IBuffer;

/**
 * Gets or sets a string that identifies the MIME content type of the downloaded resource.
 */
contentType: string;

/**
 * Gets or sets an integer value that represents extended status information about the resource download operation.
 */
extendedStatus: number;

/**
 * Gets or sets an input stream containing the downloaded resource.
 */
inputStream: Windows$Storage$Streams$IInputStream;

/**
 * Gets or sets the Uniform Resource Identifier (URI) of the downloaded resource.
 */
resourceUri: Windows$Foundation$Uri
}


/**
 * Provides data for the PlaybackBitrateChanged event.
 */
declare class Windows$Media$Streaming$Adaptive$AdaptiveMediaSourcePlaybackBitrateChangedEventArgs  {

/**
 * Gets a value indicating whether the media source contains only audio data.
 */
audioOnly: boolean;

/**
 * Gets the new playback bitrate.
 */
newValue: number;

/**
 * Gets the old playback bitrate.
 */
oldValue: number
}


/**
 * Specifies the type of an adaptive media resource.
 */

declare  var Windows$Media$Streaming$Adaptive$AdaptiveMediaSourceResourceType: {|
  +manifest: 0,// 0
+initializationSegment: 1,// 1
+mediaSegment: 2,// 2
+key: 3,// 3
+initializationVector: 4,// 4

|};



/**
 * Represents an object that enables integrate with the system media transport controls and support for media commands.
 */
declare class Windows$Media$SystemMediaTransportControls  {

/**
 * The system transport controls for the current view.
 * @return The system transport controls for the current view.
 */
static getForCurrentView(): Windows$Media$SystemMediaTransportControls;

/**
 * Gets or sets a value representing the current auto-repeat mode of the SystemMediaTransportControls .
 */
autoRepeatMode: $Values<typeof Windows$Media$MediaPlaybackAutoRepeatMode>;

/**
 * Gets the display updater for the SystemMediaTransportControls which enable updating the information displayed about the currently playing song.
 */
displayUpdater: Windows$Media$SystemMediaTransportControlsDisplayUpdater;

/**
 * Gets or sets a value that specifies if the channel down button is supported.
 */
isChannelDownEnabled: boolean;

/**
 * Gets or sets a value that specifies if the channel up button is supported.
 */
isChannelUpEnabled: boolean;

/**
 * Enables and disables the system media transport controls for the app.
 */
isEnabled: boolean;

/**
 * Gets or sets a value that specifies if the fast forward button is supported.
 */
isFastForwardEnabled: boolean;

/**
 * Gets or sets a value that specifies if the next button is supported.
 */
isNextEnabled: boolean;

/**
 * Gets or sets a value that specifies if the pause button is supported. true if the pause button is supported; otherwise, false.
 */
isPauseEnabled: boolean;

/**
 * Gets or sets a value that specifies if the play button is supported.
 */
isPlayEnabled: boolean;

/**
 * Gets or sets a value that specifies if the previous button is supported.
 */
isPreviousEnabled: boolean;

/**
 * Gets or sets a value that specifies if the record button is supported. true if the record button is supported; otherwise, false.
 */
isRecordEnabled: boolean;

/**
 * Gets or sets a value that specifies if the rewind button is supported.
 */
isRewindEnabled: boolean;

/**
 * Gets or sets a value that specifies if the stop button is supported.
 */
isStopEnabled: boolean;

/**
 * Occurs when the user modifies the SystemMediaTransportControls auto-repeat mode.
 */
onautorepeatmodechangerequested: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, Windows$Media$AutoRepeatModeChangeRequestedEventArgs>;
addEventListener(
type: "autorepeatmodechangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, Windows$Media$AutoRepeatModeChangeRequestedEventArgs>): void;
removeEventListener(
type: "autorepeatmodechangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, Windows$Media$AutoRepeatModeChangeRequestedEventArgs>): void;

/**
 * Occurs when a button is pressed on the SystemMediaTransportControls .
 */
onbuttonpressed: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, Windows$Media$SystemMediaTransportControlsButtonPressedEventArgs>;
addEventListener(
type: "buttonpressed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, Windows$Media$SystemMediaTransportControlsButtonPressedEventArgs>): void;
removeEventListener(
type: "buttonpressed",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, Windows$Media$SystemMediaTransportControlsButtonPressedEventArgs>): void;

/**
 * Occurs when the user modifies the playback position of the SystemMediaTransportControls .
 */
onplaybackpositionchangerequested: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, Windows$Media$PlaybackPositionChangeRequestedEventArgs>;
addEventListener(
type: "playbackpositionchangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, Windows$Media$PlaybackPositionChangeRequestedEventArgs>): void;
removeEventListener(
type: "playbackpositionchangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, Windows$Media$PlaybackPositionChangeRequestedEventArgs>): void;

/**
 * Occurs when the user modifies the SystemMediaTransportControls playback rate.
 */
onplaybackratechangerequested: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, any>;
addEventListener(
type: "playbackratechangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, any>): void;
removeEventListener(
type: "playbackratechangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, any>): void;

/**
 * Occurs when a property on the SystemMediaTransportControls has changed.
 */
onpropertychanged: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, Windows$Media$SystemMediaTransportControlsPropertyChangedEventArgs>;
addEventListener(
type: "propertychanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, Windows$Media$SystemMediaTransportControlsPropertyChangedEventArgs>): void;
removeEventListener(
type: "propertychanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, Windows$Media$SystemMediaTransportControlsPropertyChangedEventArgs>): void;

/**
 * Occurs when the user modifies the SystemMediaTransportControls shuffle state.
 */
onshuffleenabledchangerequested: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, Windows$Media$ShuffleEnabledChangeRequestedEventArgs>;
addEventListener(
type: "shuffleenabledchangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, Windows$Media$ShuffleEnabledChangeRequestedEventArgs>): void;
removeEventListener(
type: "shuffleenabledchangerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Media$SystemMediaTransportControls, Windows$Media$ShuffleEnabledChangeRequestedEventArgs>): void;

/**
 * Gets or sets the playback rate of the SystemMediaTransportControls .
 */
playbackRate: number;

/**
 * Gets the playback status of the media.
 */
playbackStatus: $Values<typeof Windows$Media$MediaPlaybackStatus>;

/**
 * Gets or sets a value representing the current shuffle state of the SystemMediaTransportControls .
 */
shuffleEnabled: boolean;

/**
 * Gets the sound level of the media for the capture and render streams.
 */
soundLevel: $Values<typeof Windows$Media$SoundLevel>;

/**
 * Updates the SystemMediaTransportControls timeline properties with the values in the provided object.
 * @param timelineProperties The object representing the new timeline property values.
 */
updateTimelineProperties(
timelineProperties: Windows$Media$SystemMediaTransportControlsTimelineProperties): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Defines values for the buttons on the SystemMediaTransportControls .
 */

declare  var Windows$Media$SystemMediaTransportControlsButton: {|
  +play: 0,// 0
+pause: 1,// 1
+stop: 2,// 2
+record: 3,// 3
+fastForward: 4,// 4
+rewind: 5,// 5
+next: 6,// 6
+previous: 7,// 7
+channelUp: 8,// 8
+channelDown: 9,// 9

|};



/**
 * Provides data for the SystemMediaTransportControls.ButtonPressed event.
 */
declare class Windows$Media$SystemMediaTransportControlsButtonPressedEventArgs  {

/**
 * Gets the button on the SystemMediaTransportControls that was pressed.
 */
button: $Values<typeof Windows$Media$SystemMediaTransportControlsButton>
}


/**
 * Provides functionality to update the music information that is displayed on the SystemMediaTransportControls .
 */
declare class Windows$Media$SystemMediaTransportControlsDisplayUpdater  {

/**
 * Gets or sets the media id of the app.
 */
appMediaId: string;

/**
 * Clears out all of the media metadata.
 */
clearAll(): void;

/**
 * Initialize the media properties using the specified file.
 * @param type The type of media.
 * @param source The file to initialize the media properties.
 * @return When this method completes, it returns a boolean value that indicates true if the operation succeeded; otherwise, false.
 */
copyFromFileAsync(
type: $Values<typeof Windows$Media$MediaPlaybackType>,
source: Windows$Storage$StorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets the image properties associated with the currently playing media.
 */
imageProperties: Windows$Media$ImageDisplayProperties;

/**
 * Gets the music properties associated with the currently playing media.
 */
musicProperties: Windows$Media$MusicDisplayProperties;

/**
 * Gets or sets thumbnail image associated with the currently playing media.
 */
thumbnail: Windows$Storage$Streams$RandomAccessStreamReference;

/**
 * Gets or sets the type of media.
 */
type: $Values<typeof Windows$Media$MediaPlaybackType>;

/**
 * Updates the metadata for the currently playing media.
 */
update(): void;

/**
 * Gets the video properties associated with the currently playing media.
 */
videoProperties: Windows$Media$VideoDisplayProperties
}


/**
 * Defines values for the properties on the SystemMediaTransportControls .
 */

declare  var Windows$Media$SystemMediaTransportControlsProperty: {|
  +soundLevel: 0,// 0

|};



/**
 * Occurs when a property is changed on the SystemMediaTransportControls .
 */
declare class Windows$Media$SystemMediaTransportControlsPropertyChangedEventArgs  {

/**
 * The property that was changed on the SystemMediaTransportControls .
 */
property: $Values<typeof Windows$Media$SystemMediaTransportControlsProperty>
}


/**
 * Represents timeline properties of the SystemMediaTransportControls . Pass an instance of this class to the UpdateTimelineProperties method to update the properties.
 */
declare class Windows$Media$SystemMediaTransportControlsTimelineProperties  {

/**
 * Initializes a new instance of the SystemMediaTransportControlsTimelineProperties class.
 */
constructor(): this;

/**
 * Gets or sets a value representing the end time of the currently playing media item.
 */
endTime: number;

/**
 * Gets or sets a value indicating the latest time within the currently playing media item to which the user can seek.
 */
maxSeekTime: number;

/**
 * Gets or sets a value indicating the earliest time within the currently playing media item to which the user can seek.
 */
minSeekTime: number;

/**
 * Gets or sets a value representing the current playback position within the currently playing media item.
 */
position: number;

/**
 * Gets or sets a value representing the start time of the currently playing media item.
 */
startTime: number
}


      declare var npm$namespace$Windows$Media$Transcoding: {
        
        
        MediaVideoProcessingAlgorithm: typeof Windows$Media$Transcoding$MediaVideoProcessingAlgorithm,
TranscodeFailureReason: typeof Windows$Media$Transcoding$TranscodeFailureReason,
        MediaTranscoder: typeof Windows$Media$Transcoding$MediaTranscoder,
PrepareTranscodeResult: typeof Windows$Media$Transcoding$PrepareTranscodeResult,
        
      }

/**
 * Transcodes audio and video files.
 */
declare class Windows$Media$Transcoding$MediaTranscoder  {

/**
 * Creates a new instance of the MediaTranscoder class.
 */
constructor(): this;

/**
 * Adds the specified audio effect with configuration properties, and indicates whether the effect is required.
 * @param activatableClassId The identifier of the audio effect.
 * @param effectRequired Indicates whether the audio effect is required.
 * @param configuration Configuration properties for the audio effect.
 */
addAudioEffect(
activatableClassId: string,
effectRequired: boolean,
configuration: Windows$Foundation$Collections$IPropertySet): void;

/**
 * Adds the specified audio effect.
 * @param activatableClassId The identifier of the audio effect.
 */
addAudioEffect(activatableClassId: string): void;

/**
 * Adds the specified video effect.
 * @param activatableClassId The identifier of the video effect.
 */
addVideoEffect(activatableClassId: string): void;

/**
 * Adds the specified video effect with configuration properties and indicates whether the effect is required.
 * @param activatableClassId The identifier of the video effect.
 * @param effectRequired Indicates whether the video effect is required.
 * @param configuration Configuration properties for the video effect.
 */
addVideoEffect(
activatableClassId: string,
effectRequired: boolean,
configuration: Windows$Foundation$Collections$IPropertySet): void;

/**
 * Specifies whether the media transcoder always re-encodes the source.
 */
alwaysReencode: boolean;

/**
 * Removes all audio and video effects from the transcode session.
 */
clearEffects(): void;

/**
 * Specifies whether hardware acceleration is enabled.
 */
hardwareAccelerationEnabled: boolean;

/**
 * Asynchronously initializes the trancode operation on the specified file and returns a PrepareTranscodeResult object which can be used to start the transcode operation.
 * @param source The source file.
 * @param destination The destination file.
 * @param profile The profile to use for the operation.
 * @return When this method completes, a PrepareTranscodeResult object is returned which can be used to start the transcode.
 */
prepareFileTranscodeAsync(
source: Windows$Storage$IStorageFile,
destination: Windows$Storage$IStorageFile,
profile: Windows$Media$MediaProperties$MediaEncodingProfile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Transcoding$PrepareTranscodeResult>;

/**
 * Asynchronously initializes the trancode operation on the specified media source and returns a PrepareTranscodeResult object which can be used to start the transcode operation.
 * @param source The media source to perform the transcode operation on.
 * @param destination The destination stream for the transcoded media data.
 * @param profile The profile to use for the operation.
 * @return When this method completes, a PrepareTranscodeResult object is returned which can be used to start the transcode.
 */
prepareMediaStreamSourceTranscodeAsync(
source: Windows$Media$Core$IMediaSource,
destination: Windows$Storage$Streams$IRandomAccessStream,
profile: Windows$Media$MediaProperties$MediaEncodingProfile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Transcoding$PrepareTranscodeResult>;

/**
 * Asynchronously initializes the trancode operation on the specified stream and returns a PrepareTranscodeResult object which can be used to start the transcode operation.
 * @param source The source stream.
 * @param destination The destination stream.
 * @param profile The profile to use for the operation.
 * @return When this method completes, a PrepareTranscodeResult object is returned which can be used to start the transcode.
 */
prepareStreamTranscodeAsync(
source: Windows$Storage$Streams$IRandomAccessStream,
destination: Windows$Storage$Streams$IRandomAccessStream,
profile: Windows$Media$MediaProperties$MediaEncodingProfile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Media$Transcoding$PrepareTranscodeResult>;

/**
 * Gets or sets the time interval to trim from the start of the output.
 */
trimStartTime: number;

/**
 * Gets or sets the time interval to trim from the end of the output.
 */
trimStopTime: number;

/**
 * Gets or sets the video processing algorithm which will be used for transcoding.
 */
videoProcessingAlgorithm: $Values<typeof Windows$Media$Transcoding$MediaVideoProcessingAlgorithm>
}


/**
 * Defines the available algorithms used by the Transcode Video Processor (XVP).
 */

declare  var Windows$Media$Transcoding$MediaVideoProcessingAlgorithm: {|
  +default: 0,// 0
+mrfCrf444: 1,// 1

|};



/**
 * Represents an asynchronous media transcode deferral operation which can be used to start the transcode operation.
 */
declare class Windows$Media$Transcoding$PrepareTranscodeResult  {

/**
 * Indicates whether the trancode operation can be performed successfully.
 */
canTranscode: boolean;

/**
 * Specifies the reason for the transcode failure.
 */
failureReason: $Values<typeof Windows$Media$Transcoding$TranscodeFailureReason>;

/**
 * Creates an object to perform an asynchronous media transcode operation on media data.
 * @return An object that is used to control the asynchronous operation.
 */
transcodeAsync(): Windows$Foundation$IPromiseWithIAsyncActionWithProgress<number>
}


/**
 * Specifies the reason the transcode operation failed.
 */

declare  var Windows$Media$Transcoding$TranscodeFailureReason: {|
  +none: 0,// 0
+unknown: 1,// 1
+invalidProfile: 2,// 2
+codecNotFound: 3,// 3

|};



/**
 * Provides properties for video information that is displayed by SystemMediaTransportControlsDisplayUpdater class.
 */
declare class Windows$Media$VideoDisplayProperties  {

/**
 * Gets a modifiable list of strings representing genre names.
 */
genres: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets or sets the subtitle of the video.
 */
subtitle: string;

/**
 * Gets or sets the title of the video.
 */
title: string
}


/**
 * Provides video-related effects.
 */
declare class Windows$Media$VideoEffects  {

/**
 * Represents a video stabilization effect which can be used on a video object to reduce the shakiness in the video.
 */
static videoStabilization: string
}


/**
 * Represents a single frame of video data.
 */
declare class Windows$Media$VideoFrame  {

/**
 * Initializes a new instance of the VideoFrame class.
 * @param format The pixel format of the video frame.
 * @param width The width of the video frame, in pixels.
 * @param height The height of the video frame, in pixels.
 * @param alpha The alpha mode of the video frame.
 */
constructor(format: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>, width: number, height: number, alpha: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>): this;

/**
 * Initializes a new instance of the VideoFrame class.
 * @param format The pixel format of the video frame.
 * @param width The width of the video frame, in pixels.
 * @param height The height of the video frame, in pixels.
 */
constructor(format: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>, width: number, height: number): this;

/**
 * Disposes of the object and associated resources.
 */
close(): void;

/**
 * Copies the current VideoFrame into a provided VideoFrame object.
 * @param frame The target video frame into which the current frame will be copied.
 * @return An asynchronous action.
 */
copyToAsync(frame: Windows$Media$VideoFrame): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the IDirect3DSurface object containing the pixel data of the video frame, when one is present.
 */
direct3DSurface: Windows$Graphics$DirectX$Direct3D11$IDirect3DSurface;

/**
 * Gets or sets the duration of the video frame.
 */
duration: number;

/**
 * Gets the extended property set which enables getting and setting properties on the media frame.
 */
extendedProperties: Windows$Foundation$Collections$IPropertySet;

/**
 * Gets or sets a value that indicates whether an video frame is the first frame after a gap in the stream.
 */
isDiscontinuous: boolean;

/**
 * Gets a value indicating whether the video frame is read-only.
 */
isReadOnly: boolean;

/**
 * Gets or sets the relative time of the frame within the video stream.
 */
relativeTime: number;

/**
 * Gets the SoftwareBitmap object containing the pixel data of the video frame, when one is present.
 */
softwareBitmap: Windows$Graphics$Imaging$SoftwareBitmap;

/**
 * Gets or sets a timestamp that is relative to the system and is correlatable across multiple media sources on the same device.
 */
systemRelativeTime: number;

/**
 * Gets a string indicating the type of video data the video frame contains.
 */
type: string
}


/**
 * Encapsulates the method needed to set the configuration properties on a registered media parser or codec.
 */
declare interface Windows$Media$IMediaExtension {

/**
 * Sets the configuration properties that were supplied when the media parser or codec was registered.
 * @param configuration The configuration properties for the media parser or codec.
 */
setProperties(configuration: Windows$Foundation$Collections$IPropertySet): void
} 


/**
 * Represents a marker at specific location in a media stream time-line.
 */
declare interface Windows$Media$IMediaMarker {

/**
 * Gets the type of the media marker.
 */
mediaMarkerType: string,

/**
 * Gets the text associated with the marker.
 */
text: string,

/**
 * Gets the offset in the media time-line that the marker occurs.
 */
time: number
} 


      declare var npm$namespace$Windows$Networking: {
        
        
        DomainNameType: typeof Windows$Networking$DomainNameType,
HostNameSortOptions: typeof Windows$Networking$HostNameSortOptions,
HostNameType: typeof Windows$Networking$HostNameType,
        EndpointPair: typeof Windows$Networking$EndpointPair,
HostName: typeof Windows$Networking$HostName,
        BackgroundTransfer: typeof npm$namespace$Windows$Networking$BackgroundTransfer,
Connectivity: typeof npm$namespace$Windows$Networking$Connectivity,
NetworkOperators: typeof npm$namespace$Windows$Networking$NetworkOperators,
Proximity: typeof npm$namespace$Windows$Networking$Proximity,
PushNotifications: typeof npm$namespace$Windows$Networking$PushNotifications,
ServiceDiscovery: typeof npm$namespace$Windows$Networking$ServiceDiscovery,
Vpn: typeof npm$namespace$Windows$Networking$Vpn,
XboxLive: typeof npm$namespace$Windows$Networking$XboxLive,
      }

      declare var npm$namespace$Windows$Networking$Sockets: {
        
        
        SocketActivityConnectedStandbyAction: typeof Windows$Networking$Sockets$SocketActivityConnectedStandbyAction,
SocketActivityKind: typeof Windows$Networking$Sockets$SocketActivityKind,
SocketActivityTriggerReason: typeof Windows$Networking$Sockets$SocketActivityTriggerReason,
SocketErrorStatus: typeof Windows$Networking$Sockets$SocketErrorStatus,
SocketMessageType: typeof Windows$Networking$Sockets$SocketMessageType,
SocketProtectionLevel: typeof Windows$Networking$Sockets$SocketProtectionLevel,
SocketQualityOfService: typeof Windows$Networking$Sockets$SocketQualityOfService,
SocketSslErrorSeverity: typeof Windows$Networking$Sockets$SocketSslErrorSeverity,
        DatagramSocket: typeof Windows$Networking$Sockets$DatagramSocket,
DatagramSocketControl: typeof Windows$Networking$Sockets$DatagramSocketControl,
DatagramSocketInformation: typeof Windows$Networking$Sockets$DatagramSocketInformation,
DatagramSocketMessageReceivedEventArgs: typeof Windows$Networking$Sockets$DatagramSocketMessageReceivedEventArgs,
MessageWebSocket: typeof Windows$Networking$Sockets$MessageWebSocket,
MessageWebSocketControl: typeof Windows$Networking$Sockets$MessageWebSocketControl,
MessageWebSocketInformation: typeof Windows$Networking$Sockets$MessageWebSocketInformation,
MessageWebSocketMessageReceivedEventArgs: typeof Windows$Networking$Sockets$MessageWebSocketMessageReceivedEventArgs,
SocketActivityContext: typeof Windows$Networking$Sockets$SocketActivityContext,
SocketActivityInformation: typeof Windows$Networking$Sockets$SocketActivityInformation,
SocketActivityTriggerDetails: typeof Windows$Networking$Sockets$SocketActivityTriggerDetails,
SocketError: typeof Windows$Networking$Sockets$SocketError,
StreamSocket: typeof Windows$Networking$Sockets$StreamSocket,
StreamSocketControl: typeof Windows$Networking$Sockets$StreamSocketControl,
StreamSocketInformation: typeof Windows$Networking$Sockets$StreamSocketInformation,
StreamSocketListener: typeof Windows$Networking$Sockets$StreamSocketListener,
StreamSocketListenerConnectionReceivedEventArgs: typeof Windows$Networking$Sockets$StreamSocketListenerConnectionReceivedEventArgs,
StreamSocketListenerControl: typeof Windows$Networking$Sockets$StreamSocketListenerControl,
StreamSocketListenerInformation: typeof Windows$Networking$Sockets$StreamSocketListenerInformation,
StreamWebSocket: typeof Windows$Networking$Sockets$StreamWebSocket,
StreamWebSocketControl: typeof Windows$Networking$Sockets$StreamWebSocketControl,
StreamWebSocketInformation: typeof Windows$Networking$Sockets$StreamWebSocketInformation,
WebSocketClosedEventArgs: typeof Windows$Networking$Sockets$WebSocketClosedEventArgs,
WebSocketError: typeof Windows$Networking$Sockets$WebSocketError,
        
      }
declare interface Windows$Networking$Sockets$IWebSocket {
close(): void,

/**
 * Closes the IWebSocket .
 * @param code Status code indicating the reason for closure.
 * @param reason Optional UTF-8-encoded data with additional information about the closure.
 */
close(code: number, reason: string): void,

/**
 * Starts an asynchronous operation to connect to a remote network destination on a IWebSocket object.
 * @param uri An absolute Uri for the server to connect to.
 * @return An asynchronous connect operation on a IWebSocket object.
 */
connectAsync(uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncAction,

/**
 * Adds an HTTP request header to the HTTP request message used in the WebSocket protocol handshake by the IWebSocket object.
 * @param headerName The name of the request header.
 * @param headerValue The value of the request header.
 */
setRequestHeader(headerName: string, headerValue: string): void,

/**
 * Gets the output stream to write to the remote network destination on a IWebSocket object.
 */
outputStream: Windows$Storage$Streams$IOutputStream
} 


/**
 * Supports network communication using a UDP datagram socket.
 */
declare class Windows$Networking$Sockets$DatagramSocket  {

/**
 * Gets a list of EndpointPair objects based on a remote hostname and remote service name and the sort order to be used.
 * @param remoteHostName The remote hostname or IP address.
 * @param remoteServiceName The remote service name or UDP port.
 * @param sortOptions The sort order to use when returning the list.
 * @return A list of EndpointPair objects.
 */
static getEndpointPairsAsync(
remoteHostName: Windows$Networking$HostName,
remoteServiceName: string,
sortOptions: $Values<typeof Windows$Networking$HostNameSortOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets a list of EndpointPair objects based on a remote hostname and remote service name that can be used to send datagrams to a remote network destination.
 * @param remoteHostName The remote hostname or IP address.
 * @param remoteServiceName The remote service name or UDP port.
 * @return A list of EndpointPair objects.
 */
static getEndpointPairsAsync(
remoteHostName: Windows$Networking$HostName,
remoteServiceName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Creates a new DatagramSocket object.
 */
constructor(): this;

/**
 * Starts a bind operation on a DatagramSocket to a local hostname and a local service name.
 * @param localHostName The local hostname or IP address on which to bind the DatagramSocket object.
 * @param localServiceName The local service name or UDP port on which to bind the DatagramSocket object.
 * @return An asynchronous bind operation on a DatagramSocket object.
 */
bindEndpointAsync(
localHostName: Windows$Networking$HostName,
localServiceName: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Starts a bind operation on a DatagramSocket to a local service name.
 * @param localServiceName The local service name or UDP port on which to bind the DatagramSocket object.
 * @return An asynchronous bind operation on a DatagramSocket object.
 */
bindServiceNameAsync(localServiceName: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Starts a bind operation on a DatagramSocket to a local service name and specific network interface.
 * @param localServiceName The local service name or UDP port on which to bind the DatagramSocket object.
 * @param adapter The network adapter on which to bind the DatagramSocket object.
 * @return An asynchronous bind operation on a DatagramSocket object.
 */
bindServiceNameAsync(
localServiceName: string,
adapter: Windows$Networking$Connectivity$NetworkAdapter): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Cancels pending reads and writes over a DatagramSocket object.
 * @return An asynchronous cancel operation on a DatagramSocket object.
 */
cancelIOAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Closes the DatagramSocket object and aborts any pending operation on the DatagramSocket.
 */
close(): void;

/**
 * Starts a connect operation on a DatagramSocket to a remote destination specified by a remote hostname and a remote service name.
 * @param remoteHostName The hostname or IP address of the remote network destination.
 * @param remoteServiceName The service name or UDP port of the remote network destination.
 * @return An asynchronous connect operation on a DatagramSocket object.
 */
connectAsync(
remoteHostName: Windows$Networking$HostName,
remoteServiceName: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Starts a connect operation on a DatagramSocket to a remote network destination specified as an EndpointPair object.
 * @param endpointPair An EndpointPair object that specifies local hostname or IP address, local service name or UDP port, the remote hostname or remote IP address, and the remote service name or remote UDP port for the remote network destination.
 * @return An asynchronous connect operation on a DatagramSocket object.
 */
connectAsync(
endpointPair: Windows$Networking$EndpointPair): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets socket control data on a DatagramSocket object.
 */
control: Windows$Networking$Sockets$DatagramSocketControl;

/**
 * Enables your app's background task to be triggered by the socket broker when traffic for this DatagramSocket arrives while the app is not active.
 * @param taskId The IBackgroundTaskRegistration.TaskId of the background task that will be triggered by the socket broker when traffic arrives for this DatagramSocket .
 */
enableTransferOwnership(taskId: string): void;

/**
 * Enables your app's background task to be triggered by the socket broker when traffic for this DatagramSocket arrives while the system is in connected standby.
 * @param taskId The IBackgroundTaskRegistration.TaskId of the background task that will be triggered by the socket broker when traffic arrives for this DatagramSocket .
 * @param connectedStandbyAction Specifies whether to enable or disable the activation of the background task when traffic arrives.
 */
enableTransferOwnership(
taskId: string,
connectedStandbyAction: $Values<typeof Windows$Networking$Sockets$SocketActivityConnectedStandbyAction>): void;

/**
 * Starts an operation to get an IOutputStream to a remote destination specified by a remote hostname and a remote service name that can then be used to send network data.
 * @param remoteHostName The remote hostname or remote IP address.
 * @param remoteServiceName The remote service name or remote UDP port.
 * @return An IOutputStream that representing the asynchronous operation.
 */
getOutputStreamAsync(
remoteHostName: Windows$Networking$HostName,
remoteServiceName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IOutputStream>;

/**
 * Starts an operation to get an IOutputStream to a remote network destination specified by an EndpointPair object that can then be used to send network data.
 * @param endpointPair An endpoint pair that represents the local hostname or local IP address, the local service name or local UDP port, the remote hostname or remote IP address, and the remote service name or remote UDP port.
 * @return An IOutputStream that represents the asynchronous operation.
 */
getOutputStreamAsync(
endpointPair: Windows$Networking$EndpointPair): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IOutputStream>;

/**
 * Gets socket information on the local and remote hostnames and local and remote service names for the DatagramSocket object.
 */
information: Windows$Networking$Sockets$DatagramSocketInformation;

/**
 * Joins a DatagramSocket object to a multicast group.
 * @param host The hostname or IP address for the multicast group.
 */
joinMulticastGroup(host: Windows$Networking$HostName): void;

/**
 * An event that indicates that a message was received on the DatagramSocket object.
 */
onmessagereceived: Windows$Foundation$TypedEventHandler<Windows$Networking$Sockets$DatagramSocket, Windows$Networking$Sockets$DatagramSocketMessageReceivedEventArgs>;
addEventListener(
type: "messagereceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Sockets$DatagramSocket, Windows$Networking$Sockets$DatagramSocketMessageReceivedEventArgs>): void;
removeEventListener(
type: "messagereceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Sockets$DatagramSocket, Windows$Networking$Sockets$DatagramSocketMessageReceivedEventArgs>): void;

/**
 * Gets the output stream to write to the remote host.
 */
outputStream: Windows$Storage$Streams$IOutputStream;

/**
 * Transfers ownership of the DatagramSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
 * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
 */
transferOwnership(socketId: string): void;

/**
 * Transfers ownership of the DatagramSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
 * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
 * @param data Use the SocketActivityContext to pass context information through the socket broker. When your app is notified by the broker of activity, this SocketActivityContext will be provided to your app to help establish the context in which you should handle the notification.
 */
transferOwnership(socketId: string, data: Windows$Networking$Sockets$SocketActivityContext): void;

/**
 * Transfers ownership of the DatagramSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
 * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
 * @param data Use the SocketActivityContext to pass context information through the socket broker. When your app is notified by the broker of activity, this SocketActivityContext will be provided to your app to help establish the context in which you should handle the notification.
 * @param keepAliveTime How long the socket brokering service should monitor the socket for activity.
 */
transferOwnership(
socketId: string,
data: Windows$Networking$Sockets$SocketActivityContext,
keepAliveTime: number): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides socket control data on a DatagramSocket object.
 */
declare class Windows$Networking$Sockets$DatagramSocketControl  {

/**
 * Gets or sets a Boolean value that specifies whether the DatagramSocket allows IP datagrams for UDP to be fragmented.
 */
dontFragment: boolean;

/**
 * Gets or sets the size, in bytes, of the buffer used for receiving data on the DatagramSocket object.
 */
inboundBufferSizeInBytes: number;

/**
 * Gets or sets a Boolean value that specifies whether the DatagramSocket is able to coexist with other Win32 or WinRT multicast sockets bound to the same address/port.
 */
multicastOnly: boolean;

/**
 * Gets or sets the hop limit on an outbound packet sent to a unicast IP address by the DatagramSocket object.
 */
outboundUnicastHopLimit: number;

/**
 * Gets or sets the quality of service on a DatagramSocket object.
 */
qualityOfService: $Values<typeof Windows$Networking$Sockets$SocketQualityOfService>
}


/**
 * Provides socket information on a DatagramSocket object.
 */
declare class Windows$Networking$Sockets$DatagramSocketInformation  {

/**
 * The local IP address associated with a DatagramSocket object.
 */
localAddress: Windows$Networking$HostName;

/**
 * The local service name or UDP port number associated with a DatagramSocket .
 */
localPort: string;

/**
 * The IP address of the remote network destination associated with a DatagramSocket object.
 */
remoteAddress: Windows$Networking$HostName;

/**
 * The UDP port number of the remote network destination associated with a DatagramSocket object.
 */
remotePort: string
}


/**
 * Provides data for a MessageReceived event on a DatagramSocket .
 */
declare class Windows$Networking$Sockets$DatagramSocketMessageReceivedEventArgs  {

/**
 * Gets a DataReader object to read incoming data received from the remote network destination on a DatagramSocket object.
 * @return A DataReader object to read incoming data received from the remote network destination on a DatagramSocket object.
 */
getDataReader(): Windows$Storage$Streams$DataReader;

/**
 * Gets an IInputStream object that represents a sequential stream of bytes to be read as a message from the remote network destination on a DatagramSocket object.
 * @return An IInputStream object that represents a sequential stream of bytes to be read as a message.
 */
getDataStream(): Windows$Storage$Streams$IInputStream;

/**
 * Gets the local IP address associated with a DatagramSocket when a message was received.
 */
localAddress: Windows$Networking$HostName;

/**
 * Gets the IP address of the remote sender of the datagram on the DatagramSocket when a message is received.
 */
remoteAddress: Windows$Networking$HostName;

/**
 * Gets the UDP port number of the remote sender of the datagram received on the DatagramSocket .
 */
remotePort: string
}


/**
 * Supports network communication that allows reading and writing whole messages using a WebSocket.
 */
declare class Windows$Networking$Sockets$MessageWebSocket  {

/**
 * Creates a new MessageWebSocket object.
 */
constructor(): this;

/**
 * Closes the MessageWebSocket object and sends an empty close frame to the server.
 */
close(): void;

/**
 * Closes the MessageWebSocket object and indicates a reason for the closure.
 * @param code Status code indicating the reason for closure.
 * @param reason Optional UTF-8-encoded data with additional information about the closure.
 */
close(code: number, reason: string): void;

/**
 * Starts an asynchronous operation to connect to a remote network destination on a MessageWebSocket object.
 * @param uri An absolute Uri for the server to connect to.
 * @return An asynchronous connect operation on a MessageWebSocket object.
 */
connectAsync(uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets socket control data on a MessageWebSocket object.
 */
control: Windows$Networking$Sockets$MessageWebSocketControl;

/**
 * Gets socket information on a MessageWebSocket object.
 */
information: Windows$Networking$Sockets$MessageWebSocketInformation;

/**
 * Occurs when a close frame is received on the MessageWebSocket object as part of the close handshake.
 */
onclosed: Windows$Foundation$TypedEventHandler<Windows$Networking$Sockets$IWebSocket, Windows$Networking$Sockets$WebSocketClosedEventArgs>;
addEventListener(
type: "closed",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Sockets$IWebSocket, Windows$Networking$Sockets$WebSocketClosedEventArgs>): void;
removeEventListener(
type: "closed",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Sockets$IWebSocket, Windows$Networking$Sockets$WebSocketClosedEventArgs>): void;

/**
 * An event that indicates that a message was received on the MessageWebSocket object.
 */
onmessagereceived: Windows$Foundation$TypedEventHandler<Windows$Networking$Sockets$MessageWebSocket, Windows$Networking$Sockets$MessageWebSocketMessageReceivedEventArgs>;
addEventListener(
type: "messagereceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Sockets$MessageWebSocket, Windows$Networking$Sockets$MessageWebSocketMessageReceivedEventArgs>): void;
removeEventListener(
type: "messagereceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Sockets$MessageWebSocket, Windows$Networking$Sockets$MessageWebSocketMessageReceivedEventArgs>): void;

/**
 * Gets the output stream to write to the remote network destination on a MessageWebSocket object.
 */
outputStream: Windows$Storage$Streams$IOutputStream;

/**
 * Adds an HTTP request header to the HTTP request message used in the WebSocket protocol handshake by the MessageWebSocket object.
 * @param headerName The name of the request header.
 * @param headerValue The value of the request header.
 */
setRequestHeader(headerName: string, headerValue: string): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides socket control data on a MessageWebSocket .
 */
declare class Windows$Networking$Sockets$MessageWebSocketControl  {

/**
 * The maximum message size, in bytes, for a WebSocket message to be configured on the MessageWebSocket object.
 */
maxMessageSize: number;

/**
 * The WebSocket message type to be configured on a MessageWebSocket object for write operations.
 */
messageType: $Values<typeof Windows$Networking$Sockets$SocketMessageType>;

/**
 * The size, in bytes, of the send buffer to be used for sending data on a MessageWebSocket object.
 */
outboundBufferSizeInBytes: number;

/**
 * The credential to use to authenticate to the proxy server through HTTP header authentication using a MessageWebSocket object.
 */
proxyCredential: Windows$Security$Credentials$PasswordCredential;

/**
 * The credential to use to authenticate to the WebSocket server through HTTP header authentication using a MessageWebSocket object.
 */
serverCredential: Windows$Security$Credentials$PasswordCredential;

/**
 * Gets a collection that can be used to add a list of supported sub-protocols that will be advertised to the server during the connect handshake.
 */
supportedProtocols: Windows$Foundation$Collections$IVector<string>
}


/**
 * Provides socket information on a MessageWebSocket .
 */
declare class Windows$Networking$Sockets$MessageWebSocketInformation  {

/**
 * Gets bandwidth information for network data transfer on a MessageWebSocket object.
 */
bandwidthStatistics: Windows$Networking$Sockets$BandwidthStatistics;

/**
 * Gets the IP address associated with a MessageWebSocket object.
 */
localAddress: Windows$Networking$HostName;

/**
 * Gets the WebSocket sub-protocol negotiated with the server during WebSocket handshake on a MessageWebSocket object.
 */
protocol: string
}


/**
 * Provides data for a message received event on a MessageWebSocket .
 */
declare class Windows$Networking$Sockets$MessageWebSocketMessageReceivedEventArgs  {

/**
 * Gets a DataReader object to read incoming data received from the remote network destination on a MessageWebSocket .
 * @return A DataReader object to read incoming data received from the remote network destination on a MessageWebSocket .
 */
getDataReader(): Windows$Storage$Streams$DataReader;

/**
 * Gets an IInputStream object (a message represented as a sequential stream of bytes) from the remote network destination on a MessageWebSocket object.
 * @return A message represented as a sequential stream of bytes.
 */
getDataStream(): Windows$Storage$Streams$IInputStream;

/**
 * Gets the type of the message received by a MessageWebSocket object.
 */
messageType: $Values<typeof Windows$Networking$Sockets$SocketMessageType>
}


/**
 * Indicates whether an app that uses the socket brokering service can receive packets when the system goes to connected stand by.
 */

declare  var Windows$Networking$Sockets$SocketActivityConnectedStandbyAction: {|
  +doNotWake: 0,// 0
+wake: 1,// 1

|};



/**
 * The context associated with a socket while transferring ownership of the socket between an app and the socket brokering service.
 */
declare class Windows$Networking$Sockets$SocketActivityContext  {

/**
 * Constructs a new SocketActivityContext object with given context data.
 * @param data Context data to be used when the socket broker notifies the app of socket activity.
 */
constructor(data: Windows$Storage$Streams$IBuffer): this;

/**
 * Get the serialized data to associate the app context to a transferred socket.
 */
data: Windows$Storage$Streams$IBuffer
}


/**
 * Provides information on the transferred socket from the Socket Broker.
 */
declare class Windows$Networking$Sockets$SocketActivityInformation  {

/**
 * Gets a list of all the sockets transferred to the socket brokering service by this app.
 */
static allSockets: Windows$Foundation$Collections$IMapView<string, Windows$Networking$Sockets$SocketActivityInformation>;

/**
 * Get the context associated while transferring ownership of the socket.
 */
context: Windows$Networking$Sockets$SocketActivityContext;

/**
 * Based on the socket type, the app can reclaim the ownership of the appropriate DatagramSocket .
 */
datagramSocket: Windows$Networking$Sockets$DatagramSocket;

/**
 * A unique string for this app used to identify the transferred socket. This is passed by the app while transferring the socket ownership to the service.
 */
id: string;

/**
 * Gets a SocketActivityKind enumeration value that identifies socket kind.
 */
socketKind: $Values<typeof Windows$Networking$Sockets$SocketActivityKind>;

/**
 * Based on the socket type, the app can reclaim the ownership of the appropriate StreamSocket .
 */
streamSocket: Windows$Networking$Sockets$StreamSocket;

/**
 * Based on the socket type, the app can reclaim the ownership of the appropriate StreamSocketListener .
 */
streamSocketListener: Windows$Networking$Sockets$StreamSocketListener;

/**
 * The background task ID used while transferring ownership of the socket.
 */
taskId: string
}


/**
 * Describes the kind of socket object being transferred to or from the socket broker.
 */

declare  var Windows$Networking$Sockets$SocketActivityKind: {|
  +none: 0,// 0
+streamSocketListener: 1,// 1
+datagramSocket: 2,// 2
+streamSocket: 3,// 3

|};



/**
 * A object instantiated by the background broker infrastructure and used by an app to retrieve details when a SocketActivityTrigger occurs.
 */
declare class Windows$Networking$Sockets$SocketActivityTriggerDetails  {

/**
 * Get the reason the SocketActivityTrigger occurred.
 */
reason: $Values<typeof Windows$Networking$Sockets$SocketActivityTriggerReason>;

/**
 * Get the SocketActivityInformation object for socket that caused the SocketActivityTrigger to occur.
 */
socketInformation: Windows$Networking$Sockets$SocketActivityInformation
}


/**
 * The reason why a SocketActivityTrigger occurred.
 */

declare  var Windows$Networking$Sockets$SocketActivityTriggerReason: {|
  +none: 0,// 0
+socketActivity: 1,// 1
+connectionAccepted: 2,// 2
+keepAliveTimerExpired: 3,// 3
+socketClosed: 4,// 4

|};



/**
 * Provides socket error status for operations on a DatagramSocket , StreamSocket , or StreamSocketListener .
 */
declare class Windows$Networking$Sockets$SocketError  {

/**
 * Gets a SocketErrorStatus value based on an error encountered by a socket operation.
 * @param hresult The error encountered by a socket operation represented as an HRESULT.
 * @return The socket error status value for a socket operation.
 */
static getStatus(hresult: number): $Values<typeof Windows$Networking$Sockets$SocketErrorStatus>
}


/**
 * Specifies status values for a socket operation.
 */

declare  var Windows$Networking$Sockets$SocketErrorStatus: {|
  +unknown: 0,// 0
+operationAborted: 1,// 1
+httpInvalidServerResponse: 2,// 2
+connectionTimedOut: 3,// 3
+addressFamilyNotSupported: 4,// 4
+socketTypeNotSupported: 5,// 5
+hostNotFound: 6,// 6
+noDataRecordOfRequestedType: 7,// 7
+nonAuthoritativeHostNotFound: 8,// 8
+classTypeNotFound: 9,// 9
+addressAlreadyInUse: 10,// 10
+cannotAssignRequestedAddress: 11,// 11
+connectionRefused: 12,// 12
+networkIsUnreachable: 13,// 13
+unreachableHost: 14,// 14
+networkIsDown: 15,// 15
+networkDroppedConnectionOnReset: 16,// 16
+softwareCausedConnectionAbort: 17,// 17
+connectionResetByPeer: 18,// 18
+hostIsDown: 19,// 19
+noAddressesFound: 20,// 20
+tooManyOpenFiles: 21,// 21
+messageTooLong: 22,// 22
+certificateExpired: 23,// 23
+certificateUntrustedRoot: 24,// 24
+certificateCommonNameIsIncorrect: 25,// 25
+certificateWrongUsage: 26,// 26
+certificateRevoked: 27,// 27
+certificateNoRevocationCheck: 28,// 28
+certificateRevocationServerOffline: 29,// 29
+certificateIsInvalid: 30,// 30

|};



/**
 * Specifies the type of a message for a MessageWebSocket object.
 */

declare  var Windows$Networking$Sockets$SocketMessageType: {|
  +binary: 0,// 0
+utf8: 1,// 1

|};



/**
 * Specifies the level of encryption to use on a StreamSocket object.
 */

declare  var Windows$Networking$Sockets$SocketProtectionLevel: {|
  +plainSocket: 0,// 0
+ssl: 1,// 1
+sslAllowNullEncryption: 2,// 2
+bluetoothEncryptionAllowNullAuthentication: 3,// 3
+bluetoothEncryptionWithAuthentication: 4,// 4
+ssl3AllowWeakEncryption: 5,// 5
+tls10: 6,// 6
+tls11: 7,// 7
+tls12: 8,// 8

|};



/**
 * Specifies the quality of service for a DatagramSocket or StreamSocket object.
 */

declare  var Windows$Networking$Sockets$SocketQualityOfService: {|
  +normal: 0,// 0
+lowLatency: 1,// 1

|};



/**
 * The category of error that occurs on an SSL connection.
 */

declare  var Windows$Networking$Sockets$SocketSslErrorSeverity: {|
  +none: 0,// 0
+ignorable: 1,// 1
+fatal: 2,// 2

|};



/**
 * Supports network communication using a stream socket over TCP or Bluetooth RFCOMM in Windows Store apps.
 */
declare class Windows$Networking$Sockets$StreamSocket  {

/**
 * Creates a new StreamSocket object.
 */
constructor(): this;

/**
 * Cancels pending reads and writes over a StreamSocket object.
 * @return An asynchronous cancel operation on a StreamSocket object.
 */
cancelIOAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Closes the StreamSocket object.
 */
close(): void;

/**
 * Starts an asynchronous operation on a StreamSocket object to connect to a remote network destination specified by a remote hostname and a remote service name.
 * @param remoteHostName The hostname or IP address of the remote network destination. For Bluetooth RFCOMM, this is a MAC address.
 * @param remoteServiceName The service name or TCP port number of the remote network destination. For Bluetooth RFCOMM, this is the Bluetooth address.
 * @return An asynchronous connect operation on a StreamSocket object.
 */
connectAsync(
remoteHostName: Windows$Networking$HostName,
remoteServiceName: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Starts an asynchronous operation on a StreamSocket object to connect to a remote destination specified by a remote hostname, a remote service name, and a SocketProtectionLevel .
 * @param remoteHostName The hostname or IP address of the remote network destination. For Bluetooth RFCOMM, this is a MAC address.
 * @param remoteServiceName The service name or TCP port number of the remote network destination. For Bluetooth RFCOMM, this is the Bluetooth address.
 * @param protectionLevel The protection level that represents the integrity and encryption for the StreamSocket object.
 * @return An asynchronous connect operation on a StreamSocket object.
 */
connectAsync(
remoteHostName: Windows$Networking$HostName,
remoteServiceName: string,
protectionLevel: $Values<typeof Windows$Networking$Sockets$SocketProtectionLevel>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Starts an asynchronous operation on a StreamSocket object to connect to a remote network destination specified as an EndpointPair object and a SocketProtectionLevel enumeration. This method is not callable from JavaScript.
 * @param endpointPair An EndpointPair object that specifies local hostname or IP address, local service name or TCP port, the remote hostname or remote IP address, and the remote service name or remote TCP port for the remote network destination.
 * @param protectionLevel The protection level that represents the integrity and encryption for a StreamSocket object.
 * @return An asynchronous connect operation on a StreamSocket object.
 */
connectAsync(
endpointPair: Windows$Networking$EndpointPair,
protectionLevel: $Values<typeof Windows$Networking$Sockets$SocketProtectionLevel>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Starts an asynchronous operation on a StreamSocket object to connect to a remote network destination specified as an EndpointPair object.
 * @param endpointPair An EndpointPair object that specifies the local hostname or IP address, the local service name or TCP port, the remote hostname or remote IP address, and the remote service name or remote TCP port for the remote network destination.
 * @return An asynchronous connect operation on a StreamSocket object.
 */
connectAsync(
endpointPair: Windows$Networking$EndpointPair): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Starts an asynchronous operation on a StreamSocket object on a specified local network adapter to connect to a remote destination specified by a remote hostname, a remote service name, and a SocketProtectionLevel .
 * @param remoteHostName The hostname or IP address of the remote network destination. For Bluetooth RFCOMM, this is a MAC address.
 * @param remoteServiceName The service name or TCP port number of the remote network destination. For Bluetooth RFCOMM, this is the Bluetooth address.
 * @param protectionLevel The protection level that represents the integrity and encryption for the StreamSocket object.
 * @param adapter The local network adapter to use for the connect operation on the StreamSocket object.
 * @return An asynchronous connect operation on a StreamSocket object.
 */
connectAsync(
remoteHostName: Windows$Networking$HostName,
remoteServiceName: string,
protectionLevel: $Values<typeof Windows$Networking$Sockets$SocketProtectionLevel>,
adapter: Windows$Networking$Connectivity$NetworkAdapter): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets socket control data on a StreamSocket object.
 */
control: Windows$Networking$Sockets$StreamSocketControl;

/**
 * Enables your app's background task to be triggered by the socket broker when traffic for this StreamSocket arrives while the app is not active.
 * @param taskId The IBackgroundTaskRegistration.TaskId of the background task that will be triggered by the socket broker when traffic arrives for this StreamSocket .
 */
enableTransferOwnership(taskId: string): void;

/**
 * Enables or disables the ability of your app's background task to be triggered by the socket broker when traffic for this StreamSocket arrives while the system is in connected standby.
 * @param taskId The IBackgroundTaskRegistration.TaskId of the background task being enabled or disabled.
 * @param connectedStandbyAction Specifies whether to enable or disable the activation of the background task when traffic arrives.
 */
enableTransferOwnership(
taskId: string,
connectedStandbyAction: $Values<typeof Windows$Networking$Sockets$SocketActivityConnectedStandbyAction>): void;

/**
 * Gets socket information on a StreamSocket object.
 */
information: Windows$Networking$Sockets$StreamSocketInformation;

/**
 * Gets the input stream to read from the remote destination on a StreamSocket object.
 */
inputStream: Windows$Storage$Streams$IInputStream;

/**
 * Gets the output stream to write to the remote host on a StreamSocket object.
 */
outputStream: Windows$Storage$Streams$IOutputStream;

/**
 * Transfers ownership of the StreamSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
 * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
 */
transferOwnership(socketId: string): void;

/**
 * Transfers ownership of the StreamSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity. Specifies a new SocketActivityContext for the socket.
 * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
 * @param data Use the SocketActivityContext to pass context information through the socket broker. When your app is notified by the broker of activity, this SocketActivityContext will be provided to your app to help establish the context in which you should handle the notification.
 */
transferOwnership(socketId: string, data: Windows$Networking$Sockets$SocketActivityContext): void;

/**
 * Transfers ownership of the StreamSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity. Specifies a new SocketActivityContext and a keep alive time for the socket.
 * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
 * @param data Use the SocketActivityContext to pass context information through the socket broker. When your app is notified by the broker of activity, this SocketActivityContext will be provided to your app to help establish the context in which you should handle the notification.
 * @param keepAliveTime How long the socket brokering service should monitor the socket for activity.
 */
transferOwnership(
socketId: string,
data: Windows$Networking$Sockets$SocketActivityContext,
keepAliveTime: number): void;

/**
 * Starts an asynchronous operation to upgrade a connected socket to use SSL on a StreamSocket object.
 * @param protectionLevel The protection level that represents the integrity and encryption on the StreamSocket object.
 * @param validationHostName The hostname of the remote network destination that is used for validation when upgrading to SSL.
 * @return An asynchronous operation to upgrade to use SSL on a StreamSocket object.
 */
upgradeToSslAsync(
protectionLevel: $Values<typeof Windows$Networking$Sockets$SocketProtectionLevel>,
validationHostName: Windows$Networking$HostName): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Provides socket control data on a StreamSocket object.
 */
declare class Windows$Networking$Sockets$StreamSocketControl  {

/**
 * Gets or sets the client SSL/TLS certificate that will be sent to the server if the server requests a client certificate.
 */
clientCertificate: Windows$Security$Cryptography$Certificates$Certificate;

/**
 * Get a vector of SSL server errors to ignore when making an SSL connection with a StreamSocket .
 */
ignorableServerCertificateErrors: Windows$Foundation$Collections$IVector<$Values<typeof Windows$Security$Cryptography$Certificates$ChainValidationResult>>;

/**
 * A value that indicates whether keep-alive packets are sent to the remote destination on a StreamSocket object.
 */
keepAlive: boolean;

/**
 * A value that indicates whether the Nagle algorithm is used on a StreamSocket object.
 */
noDelay: boolean;

/**
 * The size, in bytes, of the send buffer to be used for sending data on a StreamSocket object.
 */
outboundBufferSizeInBytes: number;

/**
 * The hop limit on an outbound packet sent to a unicast IP address by the StreamSocket object.
 */
outboundUnicastHopLimit: number;

/**
 * The quality of service on a StreamSocket object.
 */
qualityOfService: $Values<typeof Windows$Networking$Sockets$SocketQualityOfService>;

/**
 * A value that indicates whether, when multiple connection attempts are being made, the attempts are made in parallel or serially.
 */
serializeConnectionAttempts: boolean
}


/**
 * Provides socket information on a StreamSocket object.
 */
declare class Windows$Networking$Sockets$StreamSocketInformation  {

/**
 * Gets bandwidth information for network data transfer on a StreamSocket object.
 */
bandwidthStatistics: Windows$Networking$Sockets$BandwidthStatistics;

/**
 * Gets the local IP address associated with a StreamSocket object.
 */
localAddress: Windows$Networking$HostName;

/**
 * Get the TCP port number associated with a StreamSocket .
 */
localPort: string;

/**
 * Gets the protection level that represents the integrity and encryption set on a StreamSocket object.
 */
protectionLevel: $Values<typeof Windows$Networking$Sockets$SocketProtectionLevel>;

/**
 * Get the IP address or hostname of the remote network destination associated with a StreamSocket object.
 */
remoteAddress: Windows$Networking$HostName;

/**
 * Get the hostname or IP address of the remote network destination associated with a StreamSocket object.
 */
remoteHostName: Windows$Networking$HostName;

/**
 * Get the TCP port number or service name of the remote network destination associated with a StreamSocket object.
 */
remotePort: string;

/**
 * Get the service name or TCP port number of the remote network destination associated with a StreamSocket object.
 */
remoteServiceName: string;

/**
 * Gets round trip time information for a StreamSocket object.
 */
roundTripTimeStatistics: Windows$Networking$Sockets$RoundTripTimeStatistics;

/**
 * Gets the certificate from the server when making an SSL connection with a StreamSocket .
 */
serverCertificate: Windows$Security$Cryptography$Certificates$Certificate;

/**
 * Gets the category of an error that occurred making an SSL connection with a StreamSocket .
 */
serverCertificateErrorSeverity: $Values<typeof Windows$Networking$Sockets$SocketSslErrorSeverity>;

/**
 * Gets the list of errors that occurred making an SSL connection with a StreamSocket .
 */
serverCertificateErrors: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Security$Cryptography$Certificates$ChainValidationResult>>;

/**
 * Gets the intermediate certificates sent by the server during SSL negotiation when making an SSL connection with a StreamSocket .
 */
serverIntermediateCertificates: Windows$Foundation$Collections$IVectorView<Windows$Security$Cryptography$Certificates$Certificate>;

/**
 * Get a byte array that represents the private shared secret exchanged by proximity devices.
 */
sessionKey: Windows$Storage$Streams$IBuffer
}


/**
 * Supports listening for an incoming network connection using a TCP stream socket or Bluetooth RFCOMM.
 */
declare class Windows$Networking$Sockets$StreamSocketListener  {

/**
 * Creates a new StreamSocketListener object.
 */
constructor(): this;

/**
 * Starts a bind operation on a StreamSocketListener to a local hostname and a local service name.
 * @param localHostName The local hostname or IP address on which to bind the StreamSocketListener object.
 * @param localServiceName The local service name or TCP port on which to bind the StreamSocketListener object.
 * @return An asynchronous bind operation on a StreamSocketListener object.
 */
bindEndpointAsync(
localHostName: Windows$Networking$HostName,
localServiceName: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Starts a bind operation on a StreamSocketListener to a local service name.
 * @param localServiceName The local service name or TCP port on which to bind the StreamSocketListener object. For Bluetooth RFCOMM, this parameter is the Bluetooth Service ID.
 * @return The asynchronous bind operation on a StreamSocketListener object.
 */
bindServiceNameAsync(localServiceName: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Starts a socket bind operation on a StreamSocketListener to a local service name on a specified network adapter with a specified SocketProtectionLevel to set on any bound sockets.
 * @param localServiceName The local service name or TCP port on which to bind the StreamSocketListener object. For Bluetooth RFCOMM, this parameter is the Bluetooth Service ID.
 * @param protectionLevel The protection level for encryption to set on any bound sockets.
 * @param adapter The network adapter on which to bind the StreamSocketListener object.
 * @return The asynchronous bind operation on a StreamSocketListener object.
 */
bindServiceNameAsync(
localServiceName: string,
protectionLevel: $Values<typeof Windows$Networking$Sockets$SocketProtectionLevel>,
adapter: Windows$Networking$Connectivity$NetworkAdapter): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Starts a bind operation on a StreamSocketListener to a local service name with a specified SocketProtectionLevel to set on any bound sockets.
 * @param localServiceName The local service name or TCP port on which to bind the StreamSocketListener object. For Bluetooth RFCOMM, this parameter is the Bluetooth Service ID.
 * @param protectionLevel The protection level for encryption to set on any bound sockets.
 * @return The asynchronous bind operation on a StreamSocketListener object.
 */
bindServiceNameAsync(
localServiceName: string,
protectionLevel: $Values<typeof Windows$Networking$Sockets$SocketProtectionLevel>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Cancels pending reads and writes over a StreamSocketListener object.
 * @return An asynchronous cancel operation on a StreamSocketListener object.
 */
cancelIOAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Closes the StreamSocketListener object.
 */
close(): void;

/**
 * Gets socket control data on a StreamSocketListener object.
 */
control: Windows$Networking$Sockets$StreamSocketListenerControl;

/**
 * Enables your app's background task to be triggered by the socket broker when traffic for this StreamSocketListener arrives while the app is not active.
 * @param taskId The IBackgroundTaskRegistration.TaskId of the background task that will be triggered by the socket broker when traffic arrives for this StreamSocketListener .
 */
enableTransferOwnership(taskId: string): void;

/**
 * Enables your app's background task to be triggered by the socket broker when traffic for this StreamSocketListener arrives while the system is in connected standby.
 * @param taskId The IBackgroundTaskRegistration.TaskId of the background task that will be triggered by the socket broker when traffic arrives for this StreamSocketListener .
 * @param connectedStandbyAction Specifies whether to enable or disable the activation of the background task when traffic arrives.
 */
enableTransferOwnership(
taskId: string,
connectedStandbyAction: $Values<typeof Windows$Networking$Sockets$SocketActivityConnectedStandbyAction>): void;

/**
 * Gets socket information for the StreamSocketListener object.
 */
information: Windows$Networking$Sockets$StreamSocketListenerInformation;

/**
 * An event that indicates that a connection was received on the StreamSocketListener object.
 */
onconnectionreceived: Windows$Foundation$TypedEventHandler<Windows$Networking$Sockets$StreamSocketListener, Windows$Networking$Sockets$StreamSocketListenerConnectionReceivedEventArgs>;
addEventListener(
type: "connectionreceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Sockets$StreamSocketListener, Windows$Networking$Sockets$StreamSocketListenerConnectionReceivedEventArgs>): void;
removeEventListener(
type: "connectionreceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Sockets$StreamSocketListener, Windows$Networking$Sockets$StreamSocketListenerConnectionReceivedEventArgs>): void;

/**
 * Transfers ownership of the StreamSocketListener to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
 * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
 */
transferOwnership(socketId: string): void;

/**
 * Transfers ownership of the StreamSocketListener to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
 * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
 * @param data Use the SocketActivityContext to pass context information through the socket broker. When your app is notified by the broker of activity, this SocketActivityContext will be provided to your app to help establish the context in which you should handle the notification.
 */
transferOwnership(socketId: string, data: Windows$Networking$Sockets$SocketActivityContext): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for a ConnectionReceived event on a StreamSocketListener object.
 */
declare class Windows$Networking$Sockets$StreamSocketListenerConnectionReceivedEventArgs  {

/**
 * The StreamSocket object created when a connection is received by the StreamSocketListener object.
 */
socket: Windows$Networking$Sockets$StreamSocket
}


/**
 * Provides socket control data on a StreamSocketListener object.
 */
declare class Windows$Networking$Sockets$StreamSocketListenerControl  {

/**
 * A value that indicates whether keep-alive packets should be sent on a StreamSocket object created when a connection is received by the StreamSocketListener object.
 */
keepAlive: boolean;

/**
 * A value that indicates whether the Nagle algorithm is used on a StreamSocket object created when a connection is received by the StreamSocketListener object.
 */
noDelay: boolean;

/**
 * The size, in bytes, of the send buffer to be used for sending data on a StreamSocket object created when a connection is received by the StreamSocketListener object.
 */
outboundBufferSizeInBytes: number;

/**
 * The hop limit on an outbound packet sent to a unicast IP address by the StreamSocket object created when a connection is received by the StreamSocketListener object.
 */
outboundUnicastHopLimit: number;

/**
 * The quality of service to be set on a StreamSocket object created when a connection is received by the StreamSocketListener object.
 */
qualityOfService: $Values<typeof Windows$Networking$Sockets$SocketQualityOfService>
}


/**
 * Provides socket information on a StreamSocketListener object.
 */
declare class Windows$Networking$Sockets$StreamSocketListenerInformation  {

/**
 * Get the local TCP port number associated with a StreamSocketListener object.
 */
localPort: string
}


/**
 * Supports network communication that allows reading and writing streams using a WebSocket.
 */
declare class Windows$Networking$Sockets$StreamWebSocket  {

/**
 * Creates a new StreamWebSocket object.
 */
constructor(): this;

/**
 * Closes the StreamWebSocket and sends an empty close frame to the server.
 */
close(): void;

/**
 * Closes the StreamWebSocket and indicates a reason for the closure.
 * @param code Status code indicating the reason for closure.
 * @param reason Optional UTF-8-encoded data with additional information about the closure.
 */
close(code: number, reason: string): void;

/**
 * Starts an asynchronous operation to connect to a remote network destination on a StreamWebSocket object.
 * @param uri An absolute Uri for the server to connect to.
 * @return An asynchronous connect operation on a StreamWebSocket object.
 */
connectAsync(uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets socket control data on a StreamWebSocket object.
 */
control: Windows$Networking$Sockets$StreamWebSocketControl;

/**
 * Gets socket information on a StreamWebSocket object.
 */
information: Windows$Networking$Sockets$StreamWebSocketInformation;

/**
 * Gets the input stream to read from the remote destination on a StreamWebSocket object.
 */
inputStream: Windows$Storage$Streams$IInputStream;

/**
 * Occurs when a close frame is received on the StreamWebSocket object as part of the close handshake.
 */
onclosed: Windows$Foundation$TypedEventHandler<Windows$Networking$Sockets$IWebSocket, Windows$Networking$Sockets$WebSocketClosedEventArgs>;
addEventListener(
type: "closed",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Sockets$IWebSocket, Windows$Networking$Sockets$WebSocketClosedEventArgs>): void;
removeEventListener(
type: "closed",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Sockets$IWebSocket, Windows$Networking$Sockets$WebSocketClosedEventArgs>): void;

/**
 * Gets the output stream to write to the remote network destination on a StreamWebSocket object.
 */
outputStream: Windows$Storage$Streams$IOutputStream;

/**
 * Adds an HTTP request header to the HTTP request message used in the WebSocket protocol handshake by the StreamWebSocket object.
 * @param headerName The name of the request header.
 * @param headerValue The value of the request header.
 */
setRequestHeader(headerName: string, headerValue: string): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides socket control data on a StreamWebSocket object.
 */
declare class Windows$Networking$Sockets$StreamWebSocketControl  {

/**
 * A value that indicates whether the Nagle algorithm is used on a StreamWebSocket object.
 */
noDelay: boolean;

/**
 * The size, in bytes, of the send buffer to be used for sending data on a StreamWebSocket object.
 */
outboundBufferSizeInBytes: number;

/**
 * The credential to use to authenticate to the proxy server through HTTP header authentication using a StreamWebSocket object.
 */
proxyCredential: Windows$Security$Credentials$PasswordCredential;

/**
 * The credential to use to authenticate to the WebSocket server through HTTP header authentication using a StreamWebSocket object.
 */
serverCredential: Windows$Security$Credentials$PasswordCredential;

/**
 * Gets a collection that can be used to add a list of supported sub-protocols that will be advertised to the server during the connect handshake.
 */
supportedProtocols: Windows$Foundation$Collections$IVector<string>
}


/**
 * Provides socket information on a StreamWebSocket object.
 */
declare class Windows$Networking$Sockets$StreamWebSocketInformation  {

/**
 * Gets bandwidth information for network data transfer on a StreamWebSocket object.
 */
bandwidthStatistics: Windows$Networking$Sockets$BandwidthStatistics;

/**
 * Gets the IP address associated with a StreamWebSocket object.
 */
localAddress: Windows$Networking$HostName;

/**
 * Gets the WebSocket sub-protocol negotiated with the server during WebSocket handshake on a StreamWebSocket object.
 */
protocol: string
}


/**
 * Provides data for a closed event on a MessageWebSocket , StreamWebSocket , or IWebSocket object.
 */
declare class Windows$Networking$Sockets$WebSocketClosedEventArgs  {

/**
 * Gets information about the reason that a WebSocket object was closed.
 */
code: number;

/**
 * Gets additional details about the reason that a WebSocket object was closed.
 */
reason: string
}


/**
 * Provides socket error status on a MessageWebSocket or StreamWebSocket object.
 */
declare class Windows$Networking$Sockets$WebSocketError  {

/**
 * Gets a WebErrorStatus value based on an error encountered by a WebSocket operation.
 * @param hresult The error encountered by a WebSocket operation represented as an HRESULT.
 * @return The socket error status value for a WebSocket operation.
 */
static getStatus(hresult: number): $Values<typeof Windows$Web$WebErrorStatus>
}


/**
 * Represents bandwidth information for network data transfer using a StreamSocket , StreamWebSocket , or MessageWebSocket object.
 */
declare interface Windows$Networking$Sockets$BandwidthStatistics {} 


/**
 * Represents round trip time information for a StreamSocket object.
 */
declare interface Windows$Networking$Sockets$RoundTripTimeStatistics {} 


      declare var npm$namespace$Windows$Networking$BackgroundTransfer: {
        
        
        BackgroundTransferBehavior: typeof Windows$Networking$BackgroundTransfer$BackgroundTransferBehavior,
BackgroundTransferCostPolicy: typeof Windows$Networking$BackgroundTransfer$BackgroundTransferCostPolicy,
BackgroundTransferPriority: typeof Windows$Networking$BackgroundTransfer$BackgroundTransferPriority,
BackgroundTransferStatus: typeof Windows$Networking$BackgroundTransfer$BackgroundTransferStatus,
        BackgroundDownloader: typeof Windows$Networking$BackgroundTransfer$BackgroundDownloader,
BackgroundTransferCompletionGroup: typeof Windows$Networking$BackgroundTransfer$BackgroundTransferCompletionGroup,
BackgroundTransferCompletionGroupTriggerDetails: typeof Windows$Networking$BackgroundTransfer$BackgroundTransferCompletionGroupTriggerDetails,
BackgroundTransferContentPart: typeof Windows$Networking$BackgroundTransfer$BackgroundTransferContentPart,
BackgroundTransferError: typeof Windows$Networking$BackgroundTransfer$BackgroundTransferError,
BackgroundTransferGroup: typeof Windows$Networking$BackgroundTransfer$BackgroundTransferGroup,
BackgroundUploader: typeof Windows$Networking$BackgroundTransfer$BackgroundUploader,
ContentPrefetcher: typeof Windows$Networking$BackgroundTransfer$ContentPrefetcher,
DownloadOperation: typeof Windows$Networking$BackgroundTransfer$DownloadOperation,
ResponseInformation: typeof Windows$Networking$BackgroundTransfer$ResponseInformation,
UnconstrainedTransferRequestResult: typeof Windows$Networking$BackgroundTransfer$UnconstrainedTransferRequestResult,
UploadOperation: typeof Windows$Networking$BackgroundTransfer$UploadOperation,
        
      }

/**
 * Used to configure downloads prior to the actual creation of the download operation using CreateDownload . For an overview of Background Transfer capabilities, see Transferring data in the background. Download the Background Transfer sample for examples in JavaScript, C#, and C++.
 */
declare class Windows$Networking$BackgroundTransfer$BackgroundDownloader  {

/**
 * Returns a collection of pending downloads that are not associated with a group.
 * @return A collection of pending downloads for the current application instance.
 */
static getCurrentDownloadsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Returns a collection of pending downloads for a specific Group .
 * @param group A string indicating a specific group of transfers.
 * @return A collection of pending downloads for the specific group.
 */
static getCurrentDownloadsAsync(
group: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets all downloads associated with the provided BackgroundTransferGroup .
 * @param group Contains information used to identify a group of downloads.
 * @return A list of downloads currently associated with the specified group.
 */
static getCurrentDownloadsForTransferGroupAsync(
group: Windows$Networking$BackgroundTransfer$BackgroundTransferGroup): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Used to request an unconstrained download operation. When this method is called the user is provided with a UI prompt that they can use to indicate their consent for an unconstrained operation.
 * @param operations The download operation to run unconstrained.
 * @return Indicates if the operations will run unconstrained.
 */
static requestUnconstrainedDownloadsAsync(
operations: Windows$Foundation$Collections$IIterable<Windows$Networking$BackgroundTransfer$DownloadOperation>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$BackgroundTransfer$UnconstrainedTransferRequestResult>;

/**
 * Creates a new BackgroundDownloader object.
 */
constructor(): this;

/**
 * Creates a new BackgroundDownloader object with a BackgroundTransferCompletionGroup .
 * @param completionGroup The completion group to associate with this BackgroundDownloader object.
 */
constructor(completionGroup: Windows$Networking$BackgroundTransfer$BackgroundTransferCompletionGroup): this;

/**
 * Gets the BackgroundTransferCompletionGroup associated with the BackgroundDownloader .
 */
completionGroup: Windows$Networking$BackgroundTransfer$BackgroundTransferCompletionGroup;

/**
 * Gets or sets the cost policy for the background download operation.
 */
costPolicy: $Values<typeof Windows$Networking$BackgroundTransfer$BackgroundTransferCostPolicy>;

/**
 * Initializes a DownloadOperation object that contains the specified Uri and the file that the response is written to.
 * @param uri The location of the resource.
 * @param resultFile The file that the response will be written to.
 * @return The resultant download operation.
 */
createDownload(
uri: Windows$Foundation$Uri,
resultFile: Windows$Storage$IStorageFile): Windows$Networking$BackgroundTransfer$DownloadOperation;

/**
 * Initializes a DownloadOperation object with the resource Uri , the file that the response is written to, and the request entity body.
 * @param uri The location of the resource.
 * @param resultFile The file that the response will be written to.
 * @param requestBodyFile A file that represents the request entity body, which contains additional data the server requires before the download can begin. The file this object points to must be valid for the duration of the download.
 * @return The resultant download operation.
 */
createDownload(
uri: Windows$Foundation$Uri,
resultFile: Windows$Storage$IStorageFile,
requestBodyFile: Windows$Storage$IStorageFile): Windows$Networking$BackgroundTransfer$DownloadOperation;

/**
 * Creates an asynchronous download operation that includes a URI, the file that the response will be written to, and the IInputStream object from which the file contents are read.
 * @param uri The location of the resource.
 * @param resultFile Represents the file that the response will be written to.
 * @param requestBodyStream A stream that represents the request entity body.
 * @return The resultant asynchronous download operation.
 */
createDownloadAsync(
uri: Windows$Foundation$Uri,
resultFile: Windows$Storage$IStorageFile,
requestBodyStream: Windows$Storage$Streams$IInputStream): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$BackgroundTransfer$DownloadOperation>;

/**
 * Gets or sets the TileNotification used to define the visuals, identification tag, and expiration time of a tile notification used to update the app tile when indicating failure of a download to the user.
 */
failureTileNotification: Windows$UI$Notifications$TileNotification;

/**
 * Gets or sets the ToastNotification that defines the content, associated metadata, and events used in a toast notification to indicate failure of a download to the user.
 */
failureToastNotification: Windows$UI$Notifications$ToastNotification;

/**
 * Gets or sets a string value (e.g. a GUID) indicating the group the transfer will belong to. A download operation with a group ID will only appear in operation enumerations using GetCurrentDownloadsAsync(String) with the specific group string value.
 */
group: string;

/**
 * Gets or sets the HTTP method used for the background download. The default method used for download operations is GET.
 */
method: string;

/**
 * Gets or sets the proxy credentials for the background transfer.
 */
proxyCredential: Windows$Security$Credentials$PasswordCredential;

/**
 * Gets or sets the credentials to use to authenticate with the origin server.
 */
serverCredential: Windows$Security$Credentials$PasswordCredential;

/**
 * Used to set an HTTP request header.
 * @param headerName The header name.
 * @param headerValue The header value.
 */
setRequestHeader(headerName: string, headerValue: string): void;

/**
 * Gets or sets the TileNotification used to define the visuals, identification tag, and expiration time of a tile notification used to update the app tile when indicating success of a download to the user.
 */
successTileNotification: Windows$UI$Notifications$TileNotification;

/**
 * Gets or sets the ToastNotification that defines the content, associated metadata, and events used in a toast notification to indicate success of a download to the user.
 */
successToastNotification: Windows$UI$Notifications$ToastNotification;

/**
 * Gets or sets the group that a download operation will belong to.
 */
transferGroup: Windows$Networking$BackgroundTransfer$BackgroundTransferGroup
}


/**
 * Defines values used to indicate if downloads and uploads within a BackgroundTransferGroup run in simultaneously or in serial.
 */

declare  var Windows$Networking$BackgroundTransfer$BackgroundTransferBehavior: {|
  +parallel: 0,// 0
+serialized: 1,// 1

|};



/**
 * Represents a set of background transfer operations ( DownloadOperation or UploadOperation objects) that trigger a background task once all the operations are done (if the operations completed successfully) or fail with an error.
 */
declare class Windows$Networking$BackgroundTransfer$BackgroundTransferCompletionGroup  {

/**
 * Creates a new BackgroundTransferCompletionGroup object.
 */
constructor(): this;

/**
 * Indicates that the BackgroundTransferCompletionGroup is complete and no more background transfer operations ( DownloadOperation or UploadOperation objects) will be added t the completion group.
 */
enable(): void;

/**
 * Gets a value that indicates if Enable method on a BackgroundTransferCompletionGroup has already been called.
 */
isEnabled: boolean;

/**
 * Gets the IBackgroundTrigger used to set up the background task associated with the BackgroundTransferCompletionGroup .
 */
trigger: Windows$ApplicationModel$Background$IBackgroundTrigger
}


/**
 * Contains information about a BackgroundTransferCompletionGroup that can be only accessed from the Run method on the IBackgroundTask .
 */
declare class Windows$Networking$BackgroundTransfer$BackgroundTransferCompletionGroupTriggerDetails  {

/**
 * Gets the list of DownloadOperation objects associated with the BackgroundTransferCompletionGroup .
 */
downloads: Windows$Foundation$Collections$IVectorView<Windows$Networking$BackgroundTransfer$DownloadOperation>;

/**
 * Gets the list of UploadOperation objects associated with the BackgroundTransferCompletionGroup .
 */
uploads: Windows$Foundation$Collections$IVectorView<Windows$Networking$BackgroundTransfer$UploadOperation>
}


/**
 * Represents a content part of a multi-part transfer request. Each BackgroundTransferContentPart object can represent either a single string of text content or a single file payload, but not both.
 */
declare class Windows$Networking$BackgroundTransfer$BackgroundTransferContentPart  {

/**
 * Creates a BackgroundTransferContentPart object.
 */
constructor(): this;

/**
 * Creates a BackgroundTransferContentPart object that identifies the file content and the name of the file that it represents.
 * @param name Identifies the content.
 * @param fileName The fully qualified file name, including the local path.
 */
constructor(name: string, fileName: string): this;

/**
 * Creates a BackgroundTransferContentPart object that identifies the content it represents.
 * @param name Identifies the content.
 */
constructor(name: string): this;

/**
 * Sets the source file for a BackgroundTransferContentPart containing the file for upload.
 * @param value The source file.
 */
setFile(value: Windows$Storage$IStorageFile): void;

/**
 * Sets content disposition header values that indicate the nature of the information that this BackgroundTransferContentPart represents.
 * @param headerName The header name.
 * @param headerValue The header value.
 */
setHeader(headerName: string, headerValue: string): void;

/**
 * Use this method to set text information that the BackgroundTransferContentPart represents.
 * @param value A string value used to represent text information. (e.g. api_sig, api_key, auth_token, etc...)
 */
setText(value: string): void
}


/**
 * Defines values used to specify whether transfers can occur on metered networks.
 */

declare  var Windows$Networking$BackgroundTransfer$BackgroundTransferCostPolicy: {|
  +default: 0,// 0
+unrestrictedOnly: 1,// 1
+always: 2,// 2

|};



/**
 * Used to provide errors encountered during a transfer operation.
 */
declare class Windows$Networking$BackgroundTransfer$BackgroundTransferError  {

/**
 * Gets the specific error using the returned HRESULT value. Possible values are defined by WebErrorStatus .
 * @param hresult An HRESULT returned during the operation.
 * @return The error encountered.
 */
static getStatus(hresult: number): $Values<typeof Windows$Web$WebErrorStatus>
}


/**
 * A named group used to associate multiple download or upload operations. This class makes it easy for your app to create these groups and to complete downloads and uploads simultaneously, in serial, or based on priority.
 */
declare class Windows$Networking$BackgroundTransfer$BackgroundTransferGroup  {

/**
 * Creates a transfer group using the provided group name.
 * @param name The name of the group. If a group with the this name already exists, this method will return a reference to the existing group object.
 * @return The new BackgroundTransferGroup .
 */
static createGroup(name: string): Windows$Networking$BackgroundTransfer$BackgroundTransferGroup;

/**
 * Gets the name of the group.
 */
name: string;

/**
 * Gets or sets the property used to specify if transfers within this group run simultaneously or in serial. Possible values are defined by BackgroundTransferBehavior .
 */
transferBehavior: $Values<typeof Windows$Networking$BackgroundTransfer$BackgroundTransferBehavior>
}


/**
 * Defines the values used to indicate the priority of a download or upload operation when within a BackgroundTransferGroup .
 */

declare  var Windows$Networking$BackgroundTransfer$BackgroundTransferPriority: {|
  +default: 0,// 0
+high: 1,// 1

|};



/**
 * Defines transfer operation status values.
 */

declare  var Windows$Networking$BackgroundTransfer$BackgroundTransferStatus: {|
  +idle: 0,// 0
+running: 1,// 1
+pausedByApplication: 2,// 2
+pausedCostedNetwork: 3,// 3
+pausedNoNetwork: 4,// 4
+completed: 5,// 5
+canceled: 6,// 6
+error: 7,// 7
+pausedSystemPolicy: 8,// 8

|};



/**
 * Used to configure upload prior to the actual creation of the upload operation using CreateUpload . For an overview of Background Transfer capabilities, see Transferring data in the background. Download the Background Transfer sample for examples in JavaScript, C#, and C++.
 */
declare class Windows$Networking$BackgroundTransfer$BackgroundUploader  {

/**
 * Returns a collection of pending uploads for a specific Group .
 * @param group A string indicating a specific group of uploads.
 * @return A collection of pending uploads for the specific group.
 */
static getCurrentUploadsAsync(
group: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Returns a collection of pending uploads that are not associated with a group.
 * @return A collection of pending uploads for the current application instance.
 */
static getCurrentUploadsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets all uploads associated with the provided BackgroundTransferGroup .
 * @param group Contains information used to identify a group of uploads.
 * @return A list of uploads currently associated with the specified group.
 */
static getCurrentUploadsForTransferGroupAsync(
group: Windows$Networking$BackgroundTransfer$BackgroundTransferGroup): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Used to request an unconstrained upload operation. When this method is called the user is provided with a UI prompt that they can use to indicate their consent for an unconstrained operation.
 * @param operations The upload operation to run unconstrained.
 * @return Indicates if the operations will run unconstrained.
 */
static requestUnconstrainedUploadsAsync(
operations: Windows$Foundation$Collections$IIterable<Windows$Networking$BackgroundTransfer$UploadOperation>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$BackgroundTransfer$UnconstrainedTransferRequestResult>;

/**
 * Instantiates a new BackgroundUploader object.
 */
constructor(): this;

/**
 * Instantiates a new BackgroundUploader object as a member of a completion group.
 * @param completionGroup The completion group that the created BackgroundUploader instance is to be a member of.
 */
constructor(completionGroup: Windows$Networking$BackgroundTransfer$BackgroundTransferCompletionGroup): this;

/**
 * Gets the BackgroundTransferCompletionGroup associated with the BackgroundUploader .
 */
completionGroup: Windows$Networking$BackgroundTransfer$BackgroundTransferCompletionGroup;

/**
 * Gets or sets the cost policy for the background upload operation.
 */
costPolicy: $Values<typeof Windows$Networking$BackgroundTransfer$BackgroundTransferCostPolicy>;

/**
 * Initializes an UploadOperation that indicates the location for and file for upload.
 * @param uri The location for the upload.
 * @param sourceFile The file for upload.
 * @return The resultant upload operation.
 */
createUpload(
uri: Windows$Foundation$Uri,
sourceFile: Windows$Storage$IStorageFile): Windows$Networking$BackgroundTransfer$UploadOperation;

/**
 * Returns an asynchronous operation that, on completion, returns an UploadOperation with the specified URI and one or more BackgroundTransferContentPart objects.
 * @param uri The location for the upload.
 * @param parts One or more BackgroundTransferContentPart objects.
 * @return The resultant asynchronous UploadOperation
 */
createUploadAsync(
uri: Windows$Foundation$Uri,
parts: Windows$Foundation$Collections$IIterable<Windows$Networking$BackgroundTransfer$BackgroundTransferContentPart>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$BackgroundTransfer$UploadOperation>;

/**
 * Returns an asynchronous operation that, on completion, returns an UploadOperation with the specified URI, multipart subtype, one or more BackgroundTransferContentPart objects, and the delimiter boundary value used to separate each part.
 * @param uri The location for the upload.
 * @param parts One or more BackgroundTransferContentPart objects.
 * @param subType The multipart subtype. For example, "related" for content of type "multipart/ related".
 * @param boundary A string that is used to identify the delimiter used to indicate separation between provided content parts.
 * @return The resultant asynchronous UploadOperation
 */
createUploadAsync(
uri: Windows$Foundation$Uri,
parts: Windows$Foundation$Collections$IIterable<Windows$Networking$BackgroundTransfer$BackgroundTransferContentPart>,
subType: string,
boundary: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$BackgroundTransfer$UploadOperation>;

/**
 * Returns an asynchronous operation that, on completion, returns an UploadOperation with the specified URI, one or more BackgroundTransferContentPart objects, and the multipart subtype.
 * @param uri The location for the upload.
 * @param parts One or more BackgroundTransferContentPart objects.
 * @param subType The multipart subtype. For example, "related" for content of type "multipart/ related".
 * @return The resultant asynchronous UploadOperation .
 */
createUploadAsync(
uri: Windows$Foundation$Uri,
parts: Windows$Foundation$Collections$IIterable<Windows$Networking$BackgroundTransfer$BackgroundTransferContentPart>,
subType: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$BackgroundTransfer$UploadOperation>;

/**
 * Returns an asynchronous operation that, on completion, returns an UploadOperation with the specified URI and the source stream.
 * @param uri The URI associated with the resource.
 * @param sourceStream Represents the source stream.
 * @return The resultant asynchronous upload operation.
 */
createUploadFromStreamAsync(
uri: Windows$Foundation$Uri,
sourceStream: Windows$Storage$Streams$IInputStream): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$BackgroundTransfer$UploadOperation>;

/**
 * Gets and sets the TileNotification used to define the visuals, identification tag, and expiration time of a tile notification used to update the app tile when indicating failure of an upload to the user.
 */
failureTileNotification: Windows$UI$Notifications$TileNotification;

/**
 * Gets or sets the ToastNotification that defines the content, associated metadata, and events used in a toast notification to indicate failure of an upload to the user.
 */
failureToastNotification: Windows$UI$Notifications$ToastNotification;

/**
 * Gets or sets a string value (e.g. a GUID) indicating the group the upload will belong to. An upload operation with a group ID will only appear in operation enumerations using GetCurrentDownloadsAsync(String) with the specific group string value.
 */
group: string;

/**
 * Gets or sets the HTTP method used for the upload. The default method used for upload operations is POST.
 */
method: string;

/**
 * Gets or sets the proxy credentials for the upload.
 */
proxyCredential: Windows$Security$Credentials$PasswordCredential;

/**
 * Gets or sets the credentials to use to authenticate with the origin server.
 */
serverCredential: Windows$Security$Credentials$PasswordCredential;

/**
 * Used to set an HTTP request header.
 * @param headerName The header name.
 * @param headerValue The header value.
 */
setRequestHeader(headerName: string, headerValue: string): void;

/**
 * Gets and sets the TileNotification used to define the visuals, identification tag, and expiration time of a tile notification used to update the app tile when indicating success of an upload to the user.
 */
successTileNotification: Windows$UI$Notifications$TileNotification;

/**
 * Gets or sets the ToastNotification that defines the content, associated metadata, and events used in a toast notification to indicate success of an upload to the user.
 */
successToastNotification: Windows$UI$Notifications$ToastNotification;

/**
 * Gets or sets the group that an upload operation will belong to.
 */
transferGroup: Windows$Networking$BackgroundTransfer$BackgroundTransferGroup
}


/**
 * Provides properties for specifying web resources to be prefetched. Windows will use heuristics to attempt to download the specified resources in advance of your app being launched by the user.
 */
declare class Windows$Networking$BackgroundTransfer$ContentPrefetcher  {

/**
 * Array of URIs to download when prefetch is performed for the app.
 */
static contentUris: Windows$Foundation$Collections$IVector<Windows$Foundation$Uri>;

/**
 * Specifies the location of a well-formed XML file that contains a list of resources to be prefetched.
 */
static indirectContentUri: Windows$Foundation$Uri;

/**
 * Gets the date and time of the last successful content prefetch operation.
 */
static lastSuccessfulPrefetchTime: Date
}


/**
 * Performs an asynchronous download operation. The Background Transfer sample demonstrates this functionality. For an overview of Background Transfer capabilities, see Transferring data in the background. Download the Background Transfer sample for examples in JavaScript, C#, and C++.
 */
declare class Windows$Networking$BackgroundTransfer$DownloadOperation  {

/**
 * Returns an asynchronous operation that can be used to monitor progress and completion of the attached download. Calling this method allows an app to attach download operations that were started in a previous app instance.
 * @return Download operation with callback.
 */
attachAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Networking$BackgroundTransfer$DownloadOperation, Windows$Networking$BackgroundTransfer$DownloadOperation>;

/**
 * Gets and sets the cost policy for the download.
 */
costPolicy: $Values<typeof Windows$Networking$BackgroundTransfer$BackgroundTransferCostPolicy>;

/**
 * Gets the response information.
 * @return Contains the data returned by a server response.
 */
getResponseInformation(): Windows$Networking$BackgroundTransfer$ResponseInformation;

/**
 * Gets the partially downloaded response at the specified position.
 * @param position The position at which to start reading.
 * @return The result stream.
 */
getResultStreamAt(position: number): Windows$Storage$Streams$IInputStream;

/**
 * Gets a string value indicating the group the transfer belongs to.
 */
group: string;

/**
 * This is a unique identifier for a specific download operation. A GUID associated to a download operation will not change for the duration of the download.
 */
guid: string;

/**
 * Gets the method to use for the download.
 */
method: string;

/**
 * Pauses a download operation.
 */
pause(): void;

/**
 * Gets or sets the transfer priority of this download operation when within a BackgroundTransferGroup . Possible values are defined by BackgroundTransferPriority .
 */
priority: $Values<typeof Windows$Networking$BackgroundTransfer$BackgroundTransferPriority>;

/**
 * Gets the current progress of the upload operation.
 */
progress: Windows$Networking$BackgroundTransfer$BackgroundDownloadProgress;

/**
 * Gets the URI from which to download the file.
 */
requestedUri: Windows$Foundation$Uri;

/**
 * Returns the IStorageFile object provided by the caller when creating the DownloadOperation object using CreateDownload .
 */
resultFile: Windows$Storage$IStorageFile;

/**
 * Resumes a paused download operation.
 */
resume(): void;

/**
 * Starts an asynchronous download operation.
 * @return An asynchronous download operation that includes progress updates.
 */
startAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Networking$BackgroundTransfer$DownloadOperation, Windows$Networking$BackgroundTransfer$DownloadOperation>;

/**
 * Gets the group that this download operation belongs to.
 */
transferGroup: Windows$Networking$BackgroundTransfer$BackgroundTransferGroup
}


/**
 * Represents data that is returned by a server response.
 */
declare class Windows$Networking$BackgroundTransfer$ResponseInformation  {

/**
 * Gets the URI that contains the requested data.
 */
actualUri: Windows$Foundation$Uri;

/**
 * Gets all response headers sent by the server.
 */
headers: Windows$Foundation$Collections$IMapView<string, string>;

/**
 * Gets a value that specifies whether the download is resumable.
 */
isResumable: boolean;

/**
 * Gets the status code returned by the server.
 */
statusCode: number
}


/**
 * Represents the result a request for unconstrained transfers from a BackgroundDownloader or BackgroundUploader object.
 */
declare class Windows$Networking$BackgroundTransfer$UnconstrainedTransferRequestResult  {

/**
 * Gets a value that indicates if the download or upload operations will run without the resource restrictions normally associated with background network operations while a device running on battery.
 */
isUnconstrained: boolean
}


/**
 * Performs an asynchronous upload operation. For an overview of Background Transfer capabilities, see Transferring data in the background. Download the Background Transfer sample for examples in JavaScript, C#, and C++.
 */
declare class Windows$Networking$BackgroundTransfer$UploadOperation  {

/**
 * Returns an asynchronous operation that can be used to monitor progress and completion of the attached upload. Calling this method allows an app to attach upload operations that were started in a previous app instance.
 * @return Upload operation with callback.
 */
attachAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Networking$BackgroundTransfer$UploadOperation, Windows$Networking$BackgroundTransfer$UploadOperation>;

/**
 * Gets and sets the cost policy for the upload.
 */
costPolicy: $Values<typeof Windows$Networking$BackgroundTransfer$BackgroundTransferCostPolicy>;

/**
 * Gets the response information.
 * @return Contains the data returned by a server response.
 */
getResponseInformation(): Windows$Networking$BackgroundTransfer$ResponseInformation;

/**
 * Gets the partially uploaded response at the specified location.
 * @param position The position at which to start reading.
 * @return The result stream.
 */
getResultStreamAt(position: number): Windows$Storage$Streams$IInputStream;

/**
 * Gets a string value indicating the group the upload belongs to.
 */
group: string;

/**
 * This is a unique identifier for a specific upload operation. A GUID associated to a upload operation will not change for the duration of the upload.
 */
guid: string;

/**
 * Gets the method to use for the upload.
 */
method: string;

/**
 * Gets or sets the transfer priority of this upload operation when within a BackgroundTransferGroup . Possible values are defined by BackgroundTransferPriority .
 */
priority: $Values<typeof Windows$Networking$BackgroundTransfer$BackgroundTransferPriority>;

/**
 * Gets the current progress of the upload operation.
 */
progress: Windows$Networking$BackgroundTransfer$BackgroundUploadProgress;

/**
 * Gets the URI to upload from.
 */
requestedUri: Windows$Foundation$Uri;

/**
 * Specifies the IStorageFile to upload.
 */
sourceFile: Windows$Storage$IStorageFile;

/**
 * Starts an asynchronous upload operation.
 * @return An asynchronous upload operation that includes progress updates.
 */
startAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Networking$BackgroundTransfer$UploadOperation, Windows$Networking$BackgroundTransfer$UploadOperation>;

/**
 * Gets the group that this upload operation belongs to.
 */
transferGroup: Windows$Networking$BackgroundTransfer$BackgroundTransferGroup
}


/**
 * Contains status information about the download operation.
 */
declare interface Windows$Networking$BackgroundTransfer$BackgroundDownloadProgress {

/**
 * The total number of bytes received. This value does not include bytes received as response headers.
 */
bytesReceived: number,

/**
 * true if the download request response has changed; otherwise, false.
 */
hasResponseChanged: boolean,

/**
 * true if a data transfer operation has restarted; otherwise false.
 */
hasRestarted: boolean,

/**
 * The current status of the download operation.
 */
status: $Values<typeof Windows$Networking$BackgroundTransfer$BackgroundTransferStatus>,

/**
 * The total number of bytes of data to download. If this number is unknown, this value is set to 0.
 */
totalBytesToReceive: number
} 


/**
 * Contains status information about the upload operation.
 */
declare interface Windows$Networking$BackgroundTransfer$BackgroundUploadProgress {

/**
 * The total number of bytes received. This value does not include bytes received as part of response headers. If the upload operation has restarted, this value may be smaller than in the previous progress report.
 */
bytesReceived: number,

/**
 * The total number of bytes sent. If the upload operation has restarted, this value may be smaller than in the previous progress report.
 */
bytesSent: number,

/**
 * TRUE if the upload request response has changed; otherwise, FALSE.
 */
hasResponseChanged: boolean,

/**
 * true if a upload transfer operation has restarted; otherwise false.
 */
hasRestarted: boolean,

/**
 * The current status of the upload operation.
 */
status: $Values<typeof Windows$Networking$BackgroundTransfer$BackgroundTransferStatus>,

/**
 * The total number of bytes of data to upload. If this number is unknown, this value is set to 0.
 */
totalBytesToReceive: number,

/**
 * The total number of bytes to upload.
 */
totalBytesToSend: number
} 


      declare var npm$namespace$Windows$Networking$Connectivity: {
        
        
        CellularApnAuthenticationType: typeof Windows$Networking$Connectivity$CellularApnAuthenticationType,
DataUsageGranularity: typeof Windows$Networking$Connectivity$DataUsageGranularity,
DomainConnectivityLevel: typeof Windows$Networking$Connectivity$DomainConnectivityLevel,
NetworkAuthenticationType: typeof Windows$Networking$Connectivity$NetworkAuthenticationType,
NetworkConnectivityLevel: typeof Windows$Networking$Connectivity$NetworkConnectivityLevel,
NetworkCostType: typeof Windows$Networking$Connectivity$NetworkCostType,
NetworkEncryptionType: typeof Windows$Networking$Connectivity$NetworkEncryptionType,
NetworkTypes: typeof Windows$Networking$Connectivity$NetworkTypes,
RoamingStates: typeof Windows$Networking$Connectivity$RoamingStates,
TriStates: typeof Windows$Networking$Connectivity$TriStates,
WwanDataClass: typeof Windows$Networking$Connectivity$WwanDataClass,
WwanNetworkRegistrationState: typeof Windows$Networking$Connectivity$WwanNetworkRegistrationState,
        AttributedNetworkUsage: typeof Windows$Networking$Connectivity$AttributedNetworkUsage,
CellularApnContext: typeof Windows$Networking$Connectivity$CellularApnContext,
ConnectionCost: typeof Windows$Networking$Connectivity$ConnectionCost,
ConnectionProfile: typeof Windows$Networking$Connectivity$ConnectionProfile,
ConnectionProfileFilter: typeof Windows$Networking$Connectivity$ConnectionProfileFilter,
ConnectionSession: typeof Windows$Networking$Connectivity$ConnectionSession,
ConnectivityInterval: typeof Windows$Networking$Connectivity$ConnectivityInterval,
ConnectivityManager: typeof Windows$Networking$Connectivity$ConnectivityManager,
DataPlanStatus: typeof Windows$Networking$Connectivity$DataPlanStatus,
DataPlanUsage: typeof Windows$Networking$Connectivity$DataPlanUsage,
DataUsage: typeof Windows$Networking$Connectivity$DataUsage,
IPInformation: typeof Windows$Networking$Connectivity$IPInformation,
LanIdentifier: typeof Windows$Networking$Connectivity$LanIdentifier,
LanIdentifierData: typeof Windows$Networking$Connectivity$LanIdentifierData,
NetworkAdapter: typeof Windows$Networking$Connectivity$NetworkAdapter,
NetworkInformation: typeof Windows$Networking$Connectivity$NetworkInformation,
NetworkItem: typeof Windows$Networking$Connectivity$NetworkItem,
NetworkSecuritySettings: typeof Windows$Networking$Connectivity$NetworkSecuritySettings,
NetworkStateChangeEventDetails: typeof Windows$Networking$Connectivity$NetworkStateChangeEventDetails,
NetworkUsage: typeof Windows$Networking$Connectivity$NetworkUsage,
ProxyConfiguration: typeof Windows$Networking$Connectivity$ProxyConfiguration,
RoutePolicy: typeof Windows$Networking$Connectivity$RoutePolicy,
WlanConnectionProfileDetails: typeof Windows$Networking$Connectivity$WlanConnectionProfileDetails,
WwanConnectionProfileDetails: typeof Windows$Networking$Connectivity$WwanConnectionProfileDetails,
        
      }

/**
 * Provides access to property values containing information on current usage of the attributed network connection.
 */
declare class Windows$Networking$Connectivity$AttributedNetworkUsage  {

/**
 * Gets the Id of the of the app.
 */
attributionId: string;

/**
 * Gets the name of the app.
 */
attributionName: string;

/**
 * Gets the thumbnail of the app.
 */
attributionThumbnail: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets the number of bytes received by the app over the network.
 */
bytesReceived: number;

/**
 * Gets the number of bytes sent by the app over the network.
 */
bytesSent: number
}


/**
 * Defines values that indicate the authentication type used for a APN. These values are referenced when providing APN details using a CellularApnContext object.
 */

declare  var Windows$Networking$Connectivity$CellularApnAuthenticationType: {|
  +none: 0,// 0
+pap: 1,// 1
+chap: 2,// 2
+mschapv2: 3,// 3

|};



/**
 * This class contains properties used to specify an Access Point Name (APN) for a 3GPP based cellular Data Connection (PDP context). A CellularApnContext object is passed with a AcquireConnectionAsync call to establish a connection to a specific access point.
 */
declare class Windows$Networking$Connectivity$CellularApnContext  {

/**
 * Creates an instance of CellularApnContext .
 */
constructor(): this;

/**
 * Indicates the name of the access point to establish a connection with.
 */
accessPointName: string;

/**
 * Indicates the authentication method, as defined by CellularApnAuthenticationType , that is used by the access point.
 */
authenticationType: $Values<typeof Windows$Networking$Connectivity$CellularApnAuthenticationType>;

/**
 * Indicates if data compression will be used at the data link for header and data transfer.
 */
isCompressionEnabled: boolean;

/**
 * Indicates the password used to authenticate when connecting to the access point.
 */
password: string;

/**
 * Indicates the provider ID associated with the access point.
 */
providerId: string;

/**
 * Indicates the user name used to authenticate when connecting to the access point.
 */
userName: string
}


/**
 * Provides access to property values that indicate the current cost of a network connection.
 */
declare class Windows$Networking$Connectivity$ConnectionCost  {

/**
 * Gets a value that indicates if a connection is approaching the data usage allowance specified by the data plan.
 */
approachingDataLimit: boolean;

/**
 * Gets a value that indicates whether background data usage has been restricted.
 */
backgroundDataUsageRestricted: boolean;

/**
 * Gets a value that indicates the current network cost for a connection.
 */
networkCostType: $Values<typeof Windows$Networking$Connectivity$NetworkCostType>;

/**
 * Gets a value that indicates if the connection has exceeded the data usage allowance specified by the data plan.
 */
overDataLimit: boolean;

/**
 * Gets a value that indicates whether the connection is connected to a network outside of the home provider.
 */
roaming: boolean
}


/**
 * Represents a network connection, which includes either the currently connected network or prior network connections. Provides information about the connection status and connectivity statistics.
 */
declare class Windows$Networking$Connectivity$ConnectionProfile  {

/**
 * Gets network usage data for each individual application. This method is only supported in a Windows Phone Store app.
 * @param startTime The start time of the usage window.
 * @param endTime The end time of the usage window.
 * @param states The state of the connection profile for which usage data should be returned.
 * @return When the method completes, it returns a list of AttributedNetworkUsage objects, which indicate the sent and received values, in bytes, and the total amount of time the app was connected during the corresponding time interval.
 */
getAttributedNetworkUsageAsync(
startTime: Date,
endTime: Date,
states: Windows$Networking$Connectivity$NetworkUsageStates): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the cost information for the connection.
 * @return The cost information for the connection.
 */
getConnectionCost(): Windows$Networking$Connectivity$ConnectionCost;

/**
 * Gets a list of ConnectivityInterval objects, which indicate the timestamp for when the network connection began, and a time-span for the duration of that connection.
 * @param startTime The start time over which to retrieve data. Can be no more than 60 days prior to the current time.
 * @param endTime The end time over which to retrieve data.
 * @param states The state of the connection profile for which usage data should be returned.
 * @return When the method completes, it returns a list of ConnectivityInterval objects, which indicate the start time and duration for the current or prior connections.
 */
getConnectivityIntervalsAsync(
startTime: Date,
endTime: Date,
states: Windows$Networking$Connectivity$NetworkUsageStates): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the current status of the data plan associated with the connection.
 * @return Current data plan status information.
 */
getDataPlanStatus(): Windows$Networking$Connectivity$DataPlanStatus;

/**
 * Gets the current domain authentication status for a network connection. Possible values are defined by DomainConnectivityLevel .
 * @return A value indicating the authentication status for a connection to a network domain.
 */
getDomainConnectivityLevel(): $Values<typeof Windows$Networking$Connectivity$DomainConnectivityLevel>;

/**
 * Gets the estimated data usage for a connection over a specific period of time and roaming state.
 * @param StartTime The start date/time for the usage data request.
 * @param EndTime The end date/time for the usage data request.
 * @param States The roaming state to scope the request to.
 * @return The requested local data usage information.
 */
getLocalUsage(
StartTime: Date,
EndTime: Date,
States: $Values<typeof Windows$Networking$Connectivity$RoamingStates>): Windows$Networking$Connectivity$DataUsage;

/**
 * Gets the estimated data usage for a connection during over a specific period of time.
 * @param StartTime The start date/time for the usage data request.
 * @param EndTime The end date/time for the usage data request.
 * @return The requested local data usage information.
 */
getLocalUsage(StartTime: Date, EndTime: Date): Windows$Networking$Connectivity$DataUsage;

/**
 * Gets the network connectivity level for this connection. This value indicates what network resources, if any, are currently available.
 * @return The level of network connectivity.
 */
getNetworkConnectivityLevel(): $Values<typeof Windows$Networking$Connectivity$NetworkConnectivityLevel>;

/**
 * Retrieves names associated with the network with which the connection is currently established.
 * @return An array of string values representing friendly names used to identify the local endpoint.
 */
getNetworkNames(): Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets a list of the estimated data traffic and connection duration over a specified period of time, for a specific network usage state.
 * @param startTime The start time over which to retrieve data. Can be no more than 60 days prior to the current time. If the specified granularity is PerMinute, the start time can be no more than 120 minutes prior to the current time.
 * @param endTime The end time over which to retrieve data.
 * @param granularity The desired granularity of the returned usage statistics. Each elements in the list corresponds to the network usage per the specified granularity, e.g., usage per hour.
 * @param states The state of the connection profile for which usage data should be returned.
 * @return When the method completes, it returns a list of NetworkUsage objects, which indicate the sent and received values, in bytes, and the total amount of time the profile was connected during the corresponding time interval.
 */
getNetworkUsageAsync(
startTime: Date,
endTime: Date,
granularity: $Values<typeof Windows$Networking$Connectivity$DataUsageGranularity>,
states: Windows$Networking$Connectivity$NetworkUsageStates): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets a value that indicates the current number of signal bars displayed by the Windows UI for the connection.
 * @return An integer value within a range of 0-5 that corresponds to the number of signal bars displayed by the UI.
 */
getSignalBars(): number;

/**
 * Gets a value that indicates if connection profile is a WLAN (WiFi) connection. This determines whether or not WlanConnectionProfileDetails is null.
 */
isWlanConnectionProfile: boolean;

/**
 * Gets a value that indicates if connection profile is a WWAN (mobile) connection. This determines whether or not WwanConnectionProfileDetails is null.
 */
isWwanConnectionProfile: boolean;

/**
 * Gets the object representing the network adapter providing connectivity for the connection.
 */
networkAdapter: Windows$Networking$Connectivity$NetworkAdapter;

/**
 * Retrieves the security settings for the network.
 */
networkSecuritySettings: Windows$Networking$Connectivity$NetworkSecuritySettings;

/**
 * Gets the name of the connection profile.
 */
profileName: string;

/**
 * Gets the ID of the network operator who provisioned the connection profile.
 */
serviceProviderGuid: string;

/**
 * Gets a WlanConnectionProfileDetails object that provides a method for retrieving information specific to a WLAN (WiFi) connection.
 */
wlanConnectionProfileDetails: Windows$Networking$Connectivity$WlanConnectionProfileDetails;

/**
 * Gets a WwanConnectionProfileDetails object containing the properties and methods used to retrieve information specific to mobile broadband connections.
 */
wwanConnectionProfileDetails: Windows$Networking$Connectivity$WwanConnectionProfileDetails
}


/**
 * The ConnectionProfileFilter class defines a set of properties that are used to improve the relevance of FindConnectionProfilesAsync results.
 */
declare class Windows$Networking$Connectivity$ConnectionProfileFilter  {

/**
 * Creates an instance of ConnectionProfileFilter , which contains a set of properties that are used to improve the relevance of FindConnectionProfilesAsync results.
 */
constructor(): this;

/**
 * Gets or sets whether background data usage is restricted by this connection profile filter.
 */
isBackgroundDataUsageRestricted: boolean;

/**
 * Indicates if connection profiles that represent currently established connections are included in query results.
 */
isConnected: boolean;

/**
 * Gets or sets whether the data limit has been exceeded under the current connection profile filter.
 */
isOverDataLimit: boolean;

/**
 * Gets or sets whether roaming is active in the connection profile filter.
 */
isRoaming: boolean;

/**
 * Indicates if connection profiles that represent WLAN (WiFi) connections are included in query results.
 */
isWlanConnectionProfile: boolean;

/**
 * Indicates if connection profiles that represent WWAN (mobile) connections are included in query results.
 */
isWwanConnectionProfile: boolean;

/**
 * Defines a specific NetworkCostType value to query for.
 */
networkCostType: $Values<typeof Windows$Networking$Connectivity$NetworkCostType>;

/**
 * Gets available data as raw data.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Indicates a specific network operator ID to query for.
 */
serviceProviderGuid: string
}


/**
 * The ConnectionSession class is used to represent a connection to an access point established with AcquireConnectionAsync .
 */
declare class Windows$Networking$Connectivity$ConnectionSession  {

/**
 * Closes the connection to the access point.
 */
close(): void;

/**
 * Retrieves the ConnectionProfile associated with the connection session.
 */
connectionProfile: Windows$Networking$Connectivity$ConnectionProfile
}


/**
 * Provides the start time and duration for an established or prior connection.
 */
declare class Windows$Networking$Connectivity$ConnectivityInterval  {

/**
 * Indicates the duration of connectivity.
 */
connectionDuration: number;

/**
 * Indicates when the connection was initially established.
 */
startTime: Date
}


/**
 * Methods defined by the ConnectivityManager class enable enforcement of traffic routing on a specific network adapter for the specified destination suffix. Once a policy is set using AddHttpRoutePolicy , traffic that matches the policy will either be routed or dropped.
 */
declare class Windows$Networking$Connectivity$ConnectivityManager  {

/**
 * Establishes a connection to a specific access point on a network. The request is defined using a CellularApnContext object.
 * @param CellularApnContext Provides specific details about the APN.
 * @return The established APN connection.
 */
static acquireConnectionAsync(
CellularApnContext: Windows$Networking$Connectivity$CellularApnContext): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$Connectivity$ConnectionSession>;

/**
 * Specifies a RoutePolicy that the Http stack (WinInet) will follow when routing traffic.
 * @param RoutePolicy Indicates the policy for traffic routing.
 */
static addHttpRoutePolicy(RoutePolicy: Windows$Networking$Connectivity$RoutePolicy): void;

/**
 * Removes a previously specified RoutePolicy from the Http stack (WinInet).
 * @param RoutePolicy The RoutePolicy to remove.
 */
static removeHttpRoutePolicy(RoutePolicy: Windows$Networking$Connectivity$RoutePolicy): void
}


/**
 * Represents the current status information for the data plan associated with a connection.
 */
declare class Windows$Networking$Connectivity$DataPlanStatus  {

/**
 * Gets a value indicating the maximum data transfer allowance for a connection within each billing cycle, as defined by the data plan.
 */
dataLimitInMegabytes: number;

/**
 * Gets a DataPlanUsage object that indicates the amount of data transferred over the connection, in megabytes, and the last time this value was refreshed.
 */
dataPlanUsage: Windows$Networking$Connectivity$DataPlanUsage;

/**
 * Gets a value indicating the nominal rate of the inbound data transfer occurring on the connection.
 */
inboundBitsPerSecond: number;

/**
 * Gets a value indicates the maximum size of a transfer that is allowed without user consent on a metered network.
 */
maxTransferSizeInMegabytes: number;

/**
 * Gets a value indicating the date and time of the next billing cycle.
 */
nextBillingCycle: Date;

/**
 * Gets a value indicating the nominal rate of the outbound data transfer.
 */
outboundBitsPerSecond: number
}


/**
 * Represents data plan specific data usage information for a connection.
 */
declare class Windows$Networking$Connectivity$DataPlanUsage  {

/**
 * Gets a DateTime object indicating the date and time when the MegabytesUsed property was last updated.
 */
lastSyncTime: Date;

/**
 * Gets a value indicating the total amount of data transferred, in megabytes, over the connection.
 */
megabytesUsed: number
}


/**
 * Represents data usage information returned by the ConnectionProfile.GetLocalUsage method.
 */
declare class Windows$Networking$Connectivity$DataUsage  {

/**
 * Gets a value indicating the number of bytes received by a connection over a specific period of time.
 */
bytesReceived: number;

/**
 * Gets a value indicating the number of bytes sent by the connection over a specific period of time.
 */
bytesSent: number
}


/**
 * Defines levels of granularity used when retrieving data usage statistics with GetNetworkUsageAsync .
 */

declare  var Windows$Networking$Connectivity$DataUsageGranularity: {|
  +perMinute: 0,// 0
+perHour: 1,// 1
+perDay: 2,// 2
+total: 3,// 3

|};



/**
 * Defines the domain authentication status for a network connection.
 */

declare  var Windows$Networking$Connectivity$DomainConnectivityLevel: {|
  +none: 0,// 0
+unauthenticated: 1,// 1
+authenticated: 2,// 2

|};



/**
 * Represents the association between an IP address and an adapter on the network.
 */
declare class Windows$Networking$Connectivity$IPInformation  {

/**
 * Retrieves the network adapter associated with the IP address.
 */
networkAdapter: Windows$Networking$Connectivity$NetworkAdapter;

/**
 * Retrieves the length of the prefix, or network part of the IP address.
 */
prefixLength: number
}


/**
 * Represents physical identification data for a specific NetworkAdapter object.
 */
declare class Windows$Networking$Connectivity$LanIdentifier  {

/**
 * Gets a LanIdentifierData object containing locality identification information for the network adapter's connection.
 */
infrastructureId: Windows$Networking$Connectivity$LanIdentifierData;

/**
 * Gets the adapter GUID that identifies the network adapter to associate with the locality information.
 */
networkAdapterId: string;

/**
 * Gets a LanIdentifierData object containing the port ID from the Link Layer Discovery Protocol (LLDP) locality information for an Ethernet type network adapter.
 */
portId: Windows$Networking$Connectivity$LanIdentifierData
}


/**
 * Represents the port specific data that enables LAN locality capabilities.
 */
declare class Windows$Networking$Connectivity$LanIdentifierData  {

/**
 * Gets a value indicating the type of data stored in the value field of the LanIdentifierData object according to the Link Layer Discovery Protocol (LLDP) protocol.
 */
type: number;

/**
 * Gets the serialized value.
 */
value: Windows$Foundation$Collections$IVectorView<number>
}


/**
 * Represents a network adapter.
 */
declare class Windows$Networking$Connectivity$NetworkAdapter  {

/**
 * Gets the connection profile currently associated with the network adapter.
 * @return The connection profile associated with this network adapter.
 */
getConnectedProfileAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$Connectivity$ConnectionProfile>;

/**
 * Gets a value indicating the network interface type as defined by the Internet Assigned Names Authority (IANA) for the NetworkAdapter .
 */
ianaInterfaceType: number;

/**
 * Gets a value indicating the maximum inbound data transfer rate in bits per second.
 */
inboundMaxBitsPerSecond: number;

/**
 * Gets the network adapter ID.
 */
networkAdapterId: string;

/**
 * Gets the NetworkItem object that represents the connected network.
 */
networkItem: Windows$Networking$Connectivity$NetworkItem;

/**
 * Gets a value indicating the maximum outbound speed in bits per second.
 */
outboundMaxBitsPerSecond: number
}


/**
 * Defines values that indicate the type of authentication used by the network.
 */

declare  var Windows$Networking$Connectivity$NetworkAuthenticationType: {|
  +none: 0,// 0
+unknown: 1,// 1
+open80211: 2,// 2
+sharedKey80211: 3,// 3
+wpa: 4,// 4
+wpaPsk: 5,// 5
+wpaNone: 6,// 6
+rsna: 7,// 7
+rsnaPsk: 8,// 8
+ihv: 9,// 9

|};



/**
 * Defines the level of connectivity currently available.
 */

declare  var Windows$Networking$Connectivity$NetworkConnectivityLevel: {|
  +none: 0,// 0
+localAccess: 1,// 1
+constrainedInternetAccess: 2,// 2
+internetAccess: 3,// 3

|};



/**
 * Defines the network cost types.
 */

declare  var Windows$Networking$Connectivity$NetworkCostType: {|
  +unknown: 0,// 0
+unrestricted: 1,// 1
+fixed: 2,// 2
+variable: 3,// 3

|};



/**
 * Defines values that indicate the type of encryption used for authentication.
 */

declare  var Windows$Networking$Connectivity$NetworkEncryptionType: {|
  +none: 0,// 0
+unknown: 1,// 1
+wep: 2,// 2
+wep40: 3,// 3
+wep104: 4,// 4
+tkip: 5,// 5
+ccmp: 6,// 6
+wpaUseGroup: 7,// 7
+rsnUseGroup: 8,// 8
+ihv: 9,// 9

|};



/**
 * Provides access to network connection information for the local machine.
 */
declare class Windows$Networking$Connectivity$NetworkInformation  {

/**
 * Returns an array of ConnectionProfile objects that match the filtering criteria defined by ConnectionProfileFilter .
 * @param pProfileFilter Provides the filtering criteria.
 * @return An array of ConnectionProfile objects.
 */
static findConnectionProfilesAsync(
pProfileFilter: Windows$Networking$Connectivity$ConnectionProfileFilter): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets a list of profiles for connections, active or otherwise, on the local machine.
 * @return An array of ConnectionProfile objects.
 */
static getConnectionProfiles(
): Windows$Foundation$Collections$IVectorView<Windows$Networking$Connectivity$ConnectionProfile>;

/**
 * Gets a list of host names associated with the local machine.
 * @return An array of host names for the local machine.
 */
static getHostNames(): Windows$Foundation$Collections$IVectorView<Windows$Networking$HostName>;

/**
 * Gets the connection profile associated with the internet connection currently used by the local machine.
 * @return The profile for the connection currently used to connect the machine to the Internet, or null if there is no connection profile with a suitable connection.
 */
static getInternetConnectionProfile(): Windows$Networking$Connectivity$ConnectionProfile;

/**
 * Gets an array of LanIdentifier objects that contain locality information for each NetworkAdapter object that currently connected to a network.
 * @return An array of LanIdentifier objects.
 */
static getLanIdentifiers(
): Windows$Foundation$Collections$IVectorView<Windows$Networking$Connectivity$LanIdentifier>;

/**
 * Gets proxy configuration for a connection using the specified URI.
 * @param uri The proxy configuration URI.
 * @return Information about the connection proxy.
 */
static getProxyConfigurationAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$Connectivity$ProxyConfiguration>;

/**
 * Gets a sorted list of EndpointPair objects.
 * @param destinationList A list of EndpointPair objects to be sorted.
 * @param sortOptions Indicates sorting options for the returned array.
 * @return A sorted array of EndpointPair objects.
 */
static getSortedEndpointPairs(
destinationList: Windows$Foundation$Collections$IIterable<Windows$Networking$EndpointPair>,
sortOptions: $Values<typeof Windows$Networking$HostNameSortOptions>): Windows$Foundation$Collections$IVectorView<Windows$Networking$EndpointPair>;

/**
 * Occurs when the network status changes for a connection.
 */
static onnetworkstatuschanged: Windows$Networking$Connectivity$NetworkStatusChangedEventHandler;
static addEventListener(
type: "networkstatuschanged",
listener: Windows$Networking$Connectivity$NetworkStatusChangedEventHandler): void;
static removeEventListener(
type: "networkstatuschanged",
listener: Windows$Networking$Connectivity$NetworkStatusChangedEventHandler): void;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a connected network.
 */
declare class Windows$Networking$Connectivity$NetworkItem  {

/**
 * Gets a NetworkTypes value indicating the network type for a NetworkItem .
 * @return The type of a network.
 */
getNetworkTypes(): $Values<typeof Windows$Networking$Connectivity$NetworkTypes>;

/**
 * Gets the network ID.
 */
networkId: string
}


/**
 * Represents the current network security settings.
 */
declare class Windows$Networking$Connectivity$NetworkSecuritySettings  {

/**
 * Retrieves the type of authentication used by the network.
 */
networkAuthenticationType: $Values<typeof Windows$Networking$Connectivity$NetworkAuthenticationType>;

/**
 * Retrieves the type of encryption used by the network.
 */
networkEncryptionType: $Values<typeof Windows$Networking$Connectivity$NetworkEncryptionType>
}


/**
 * Indicates which properties of a network have changed after a network state change background trigger.
 */
declare class Windows$Networking$Connectivity$NetworkStateChangeEventDetails  {

/**
 * Indicates if a connected network has a new connection cost.
 */
hasNewConnectionCost: boolean;

/**
 * Indicates a connected network has a new domain connectivity level.
 */
hasNewDomainConnectivityLevel: boolean;

/**
 * Indicates if the list of host names returned by GetHostNames has changed.
 */
hasNewHostNameList: boolean;

/**
 * Indicates if the local machine has a new connection profile associated with the current internet connection.
 */
hasNewInternetConnectionProfile: boolean;

/**
 * Indicates if the network connectivity level for any connection profiles has changed.
 */
hasNewNetworkConnectivityLevel: boolean;

/**
 * Gets a value indicating whether the network state change event shows a new tethering client count.
 */
hasNewTetheringClientCount: boolean;

/**
 * Gets a value that indicates whether the tethering operational state has changed.
 */
hasNewTetheringOperationalState: boolean;

/**
 * Indicates if the network state change event represents a change to the registration state of a WWAN connection. The current registration state can be retrieved from WwanConnectionProfileDetails.GetNetworkRegistrationState .
 */
hasNewWwanRegistrationState: boolean
}


/**
 * Defines the network connection types.
 */

declare  var Windows$Networking$Connectivity$NetworkTypes: {|
  +none: 0,// 0
+internet: 1,// 1
+privateNetwork: 2,// 2

|};



/**
 * Represents network usage statistics returned by the ConnectionProfile . GetNetworkUsageAsync method.
 */
declare class Windows$Networking$Connectivity$NetworkUsage  {

/**
 * Indicates the number of bytes received by the connection of a specific period of time.
 */
bytesReceived: number;

/**
 * Indicates the number of bytes sent by a connection over a specific period of time.
 */
bytesSent: number;

/**
 * Indicates the duration of connectivity.
 */
connectionDuration: number
}


/**
 * Represents the proxy configuration for the current user.
 */
declare class Windows$Networking$Connectivity$ProxyConfiguration  {

/**
 * Gets a value that indicates if this configuration can connect directly.
 */
canConnectDirectly: boolean;

/**
 * Gets a list of URIs for the proxies from the proxy configuration.
 */
proxyUris: Windows$Foundation$Collections$IVectorView<Windows$Foundation$Uri>
}


/**
 * Defines the roaming states.
 */

declare  var Windows$Networking$Connectivity$RoamingStates: {|
  +none: 0,// 0
+notRoaming: 1,// 1
+roaming: 2,// 2

|};



/**
 * The RoutePolicy class is used to represent the traffic routing policy for a special PDP Context/APN.
 */
declare class Windows$Networking$Connectivity$RoutePolicy  {

/**
 * Creates an instance of RoutePolicy using the defined connection profile and host name values.
 * @param connectionProfile The connection profile
 * @param hostName The host name for the route policy to the special PDP context.
 * @param type The domain type of hostName when the HostNameType value indicates a domain name.
 */
constructor(connectionProfile: Windows$Networking$Connectivity$ConnectionProfile, hostName: Windows$Networking$HostName, type: $Values<typeof Windows$Networking$DomainNameType>): this;

/**
 * Retrieves the connection profile for an access point connection.
 */
connectionProfile: Windows$Networking$Connectivity$ConnectionProfile;

/**
 * Provides the host name for the route policy to the special PDP context.
 */
hostName: Windows$Networking$HostName;

/**
 * Indicates if the HostName is a suffix or a fully qualified domain name reference. Possible values are defined by DomainNameType .
 */
hostNameType: $Values<typeof Windows$Networking$DomainNameType>
}


/**
 * Used with the NetworkUsageStates structure to define the desired roaming state and shared state of a network connection.
 */

declare  var Windows$Networking$Connectivity$TriStates: {|
  +doNotCare: 0,// 0
+no: 1,// 1
+yes: 2,// 2

|};



/**
 * Used to access information specific to a WLAN connection.
 */
declare class Windows$Networking$Connectivity$WlanConnectionProfileDetails  {

/**
 * Retrieves the Service Set Identifier (SSID) for a WLAN connection.
 * @return The service set identifier (SSID).
 */
getConnectedSsid(): string
}


/**
 * Used to access information specific to a WWAN connection.
 */
declare class Windows$Networking$Connectivity$WwanConnectionProfileDetails  {

/**
 * Indicates the name of the access point used to establish the WWAN connection.
 */
accessPointName: string;

/**
 * Indicates the class of data service offered by the network currently in use for the WWAN connection.
 * @return The class of data service currently provided.
 */
getCurrentDataClass(): $Values<typeof Windows$Networking$Connectivity$WwanDataClass>;

/**
 * Retrieves the current network registration state for the WWAN connection.
 * @return The current network registration state.
 */
getNetworkRegistrationState(): $Values<typeof Windows$Networking$Connectivity$WwanNetworkRegistrationState>;

/**
 * Indicates the Home Network Provider ID.
 */
homeProviderId: string
}


/**
 * Defines values used to indicate the class of data service provided by a WWAN network connection.
 */

declare  var Windows$Networking$Connectivity$WwanDataClass: {|
  +none: 0,// 0
+gprs: 1,// 1
+edge: 2,// 2
+umts: 3,// 3
+hsdpa: 4,// 4
+hsupa: 5,// 5
+lteAdvanced: 6,// 6
+cdma1xRtt: 7,// 7
+cdma1xEvdo: 8,// 8
+cdma1xEvdoRevA: 9,// 9
+cdma1xEvdv: 10,// 10
+cdma3xRtt: 11,// 11
+cdma1xEvdoRevB: 12,// 12
+cdmaUmb: 13,// 13
+custom: 14,// 14

|};



/**
 * Defines the network registration states for a WWAN connection.
 */

declare  var Windows$Networking$Connectivity$WwanNetworkRegistrationState: {|
  +none: 0,// 0
+deregistered: 1,// 1
+searching: 2,// 2
+home: 3,// 3
+roaming: 4,// 4
+partner: 5,// 5
+denied: 6,// 6

|};



/**
 * Defines the desired state of the connection profile for which usage data is returned by the method GetNetworkUsageAsync .
 */
declare interface Windows$Networking$Connectivity$NetworkUsageStates {

/**
 * Defines the desired roaming state of the network connection.
 */
roaming: $Values<typeof Windows$Networking$Connectivity$TriStates>,

/**
 * Defines the desired sharing state of the network connection.
 */
shared: $Values<typeof Windows$Networking$Connectivity$TriStates>
} 


/**
 * Represents the method that handles network status change notifications. This method is called when any properties exposed by the NetworkInformation object changes while the app is active.
 */
declare type Windows$Networking$Connectivity$NetworkStatusChangedEventHandler = (ev: Windows$WinRTEvent<any>) => void;


/**
 * The domain type of the HostName object when the HostNameType is a domain name.
 */

declare  var Windows$Networking$DomainNameType: {|
  +suffix: 0,// 0
+fullyQualified: 1,// 1

|};



/**
 * Provides data for the local endpoint and remote endpoint for a network connection used by network apps.
 */
declare class Windows$Networking$EndpointPair  {

/**
 * Creates a new EndpointPair object.
 * @param localHostName The local hostname or IP address for the EndpointPair object.
 * @param localServiceName The local service name or the local TCP or UDP port number for the EndpointPair object.
 * @param remoteHostName The remote hostname or IP address for the EndpointPair object.
 * @param remoteServiceName The remote service name or the remote TCP or UDP port number for the EndpointPair object.
 */
constructor(localHostName: Windows$Networking$HostName, localServiceName: string, remoteHostName: Windows$Networking$HostName, remoteServiceName: string): this;

/**
 * Get or set the local hostname for the EndpointPair object.
 */
localHostName: Windows$Networking$HostName;

/**
 * Get or set the local service name for the EndpointPair object.
 */
localServiceName: string;

/**
 * Get or set the remote hostname for the EndpointPair object.
 */
remoteHostName: Windows$Networking$HostName;

/**
 * Get or set the remote service name for the EndpointPair object.
 */
remoteServiceName: string
}


/**
 * Provides data for a hostname or an IP address.
 */
declare class Windows$Networking$HostName  {

/**
 * Compares two strings to determine if they represent the same hostname.
 * @param value1 A hostname or IP address.
 * @param value2 A hostname or IP address.
 * @return The return value indicates the lexicographic relation of value1 to value2. If the two parameters represent the same canonical hostname, then zero is returned. If value1 is less than value2, the return value is less than zero. If value1 is greater than value2, the return vale is greater than zero.
 */
static compare(value1: string, value2: string): number;

/**
 * Creates a new HostName object from a string that contains a hostname or an IP address.
 * @param hostName A string that contains a hostname or an IP address.
 */
constructor(hostName: string): this;

/**
 * Gets the canonical name for the HostName object.
 */
canonicalName: string;

/**
 * Gets the display name for the HostName object.
 */
displayName: string;

/**
 * Gets the IPInformation object for a local IP address assigned to a HostName object.
 */
ipInformation: Windows$Networking$Connectivity$IPInformation;

/**
 * Determines whether the specified HostName object has an equivalent value to the current HostName object.
 * @param hostName A HostName object that is compared with the current HostName.
 * @return A Boolean value that indicates whether the specified HostName object is equal to the current HostName object.
 */
isEqual(hostName: Windows$Networking$HostName): boolean;

/**
 * Gets the original string used to construct the HostName object.
 */
rawName: string;

/**
 * Gets the HostNameType of the HostName object.
 */
type: $Values<typeof Windows$Networking$HostNameType>
}


/**
 * Options for how a list of EndpointPair objects is sorted.
 */

declare  var Windows$Networking$HostNameSortOptions: {|
  +none: 0,// 0
+optimizeForLongConnections: 1,// 1

|};



/**
 * The type of a HostName object.
 */

declare  var Windows$Networking$HostNameType: {|
  +domainName: 0,// 0
+ipv4: 1,// 1
+ipv6: 2,// 2
+bluetooth: 3,// 3

|};



      declare var npm$namespace$Windows$Networking$NetworkOperators: {
        
        
        DataClasses: typeof Windows$Networking$NetworkOperators$DataClasses,
HotspotAuthenticationResponseCode: typeof Windows$Networking$NetworkOperators$HotspotAuthenticationResponseCode,
MobileBroadbandAccountWatcherStatus: typeof Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcherStatus,
MobileBroadbandDeviceType: typeof Windows$Networking$NetworkOperators$MobileBroadbandDeviceType,
MobileBroadbandPinFormat: typeof Windows$Networking$NetworkOperators$MobileBroadbandPinFormat,
MobileBroadbandPinLockState: typeof Windows$Networking$NetworkOperators$MobileBroadbandPinLockState,
MobileBroadbandPinType: typeof Windows$Networking$NetworkOperators$MobileBroadbandPinType,
MobileBroadbandRadioState: typeof Windows$Networking$NetworkOperators$MobileBroadbandRadioState,
MobileBroadbandUiccAppOperationStatus: typeof Windows$Networking$NetworkOperators$MobileBroadbandUiccAppOperationStatus,
NetworkDeviceStatus: typeof Windows$Networking$NetworkOperators$NetworkDeviceStatus,
NetworkOperatorEventMessageType: typeof Windows$Networking$NetworkOperators$NetworkOperatorEventMessageType,
NetworkRegistrationState: typeof Windows$Networking$NetworkOperators$NetworkRegistrationState,
ProfileMediaType: typeof Windows$Networking$NetworkOperators$ProfileMediaType,
TetheringCapability: typeof Windows$Networking$NetworkOperators$TetheringCapability,
TetheringOperationStatus: typeof Windows$Networking$NetworkOperators$TetheringOperationStatus,
TetheringOperationalState: typeof Windows$Networking$NetworkOperators$TetheringOperationalState,
UiccAccessCondition: typeof Windows$Networking$NetworkOperators$UiccAccessCondition,
UiccAppKind: typeof Windows$Networking$NetworkOperators$UiccAppKind,
UiccAppRecordKind: typeof Windows$Networking$NetworkOperators$UiccAppRecordKind,
UssdResultCode: typeof Windows$Networking$NetworkOperators$UssdResultCode,
        HotspotAuthenticationContext: typeof Windows$Networking$NetworkOperators$HotspotAuthenticationContext,
HotspotAuthenticationEventDetails: typeof Windows$Networking$NetworkOperators$HotspotAuthenticationEventDetails,
HotspotCredentialsAuthenticationResult: typeof Windows$Networking$NetworkOperators$HotspotCredentialsAuthenticationResult,
KnownCSimFilePaths: typeof Windows$Networking$NetworkOperators$KnownCSimFilePaths,
KnownRuimFilePaths: typeof Windows$Networking$NetworkOperators$KnownRuimFilePaths,
KnownSimFilePaths: typeof Windows$Networking$NetworkOperators$KnownSimFilePaths,
KnownUSimFilePaths: typeof Windows$Networking$NetworkOperators$KnownUSimFilePaths,
MobileBroadbandAccount: typeof Windows$Networking$NetworkOperators$MobileBroadbandAccount,
MobileBroadbandAccountEventArgs: typeof Windows$Networking$NetworkOperators$MobileBroadbandAccountEventArgs,
MobileBroadbandAccountUpdatedEventArgs: typeof Windows$Networking$NetworkOperators$MobileBroadbandAccountUpdatedEventArgs,
MobileBroadbandAccountWatcher: typeof Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher,
MobileBroadbandDeviceInformation: typeof Windows$Networking$NetworkOperators$MobileBroadbandDeviceInformation,
MobileBroadbandDeviceService: typeof Windows$Networking$NetworkOperators$MobileBroadbandDeviceService,
MobileBroadbandDeviceServiceCommandResult: typeof Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceCommandResult,
MobileBroadbandDeviceServiceCommandSession: typeof Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceCommandSession,
MobileBroadbandDeviceServiceDataReceivedEventArgs: typeof Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceDataReceivedEventArgs,
MobileBroadbandDeviceServiceDataSession: typeof Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceDataSession,
MobileBroadbandDeviceServiceInformation: typeof Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceInformation,
MobileBroadbandDeviceServiceTriggerDetails: typeof Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceTriggerDetails,
MobileBroadbandModem: typeof Windows$Networking$NetworkOperators$MobileBroadbandModem,
MobileBroadbandModemConfiguration: typeof Windows$Networking$NetworkOperators$MobileBroadbandModemConfiguration,
MobileBroadbandNetwork: typeof Windows$Networking$NetworkOperators$MobileBroadbandNetwork,
MobileBroadbandNetworkRegistrationStateChange: typeof Windows$Networking$NetworkOperators$MobileBroadbandNetworkRegistrationStateChange,
MobileBroadbandNetworkRegistrationStateChangeTriggerDetails: typeof Windows$Networking$NetworkOperators$MobileBroadbandNetworkRegistrationStateChangeTriggerDetails,
MobileBroadbandPin: typeof Windows$Networking$NetworkOperators$MobileBroadbandPin,
MobileBroadbandPinLockStateChange: typeof Windows$Networking$NetworkOperators$MobileBroadbandPinLockStateChange,
MobileBroadbandPinLockStateChangeTriggerDetails: typeof Windows$Networking$NetworkOperators$MobileBroadbandPinLockStateChangeTriggerDetails,
MobileBroadbandPinManager: typeof Windows$Networking$NetworkOperators$MobileBroadbandPinManager,
MobileBroadbandPinOperationResult: typeof Windows$Networking$NetworkOperators$MobileBroadbandPinOperationResult,
MobileBroadbandRadioStateChange: typeof Windows$Networking$NetworkOperators$MobileBroadbandRadioStateChange,
MobileBroadbandRadioStateChangeTriggerDetails: typeof Windows$Networking$NetworkOperators$MobileBroadbandRadioStateChangeTriggerDetails,
MobileBroadbandUicc: typeof Windows$Networking$NetworkOperators$MobileBroadbandUicc,
MobileBroadbandUiccApp: typeof Windows$Networking$NetworkOperators$MobileBroadbandUiccApp,
MobileBroadbandUiccAppReadRecordResult: typeof Windows$Networking$NetworkOperators$MobileBroadbandUiccAppReadRecordResult,
MobileBroadbandUiccAppRecordDetailsResult: typeof Windows$Networking$NetworkOperators$MobileBroadbandUiccAppRecordDetailsResult,
MobileBroadbandUiccAppsResult: typeof Windows$Networking$NetworkOperators$MobileBroadbandUiccAppsResult,
NetworkOperatorNotificationEventDetails: typeof Windows$Networking$NetworkOperators$NetworkOperatorNotificationEventDetails,
NetworkOperatorTetheringAccessPointConfiguration: typeof Windows$Networking$NetworkOperators$NetworkOperatorTetheringAccessPointConfiguration,
NetworkOperatorTetheringClient: typeof Windows$Networking$NetworkOperators$NetworkOperatorTetheringClient,
NetworkOperatorTetheringManager: typeof Windows$Networking$NetworkOperators$NetworkOperatorTetheringManager,
NetworkOperatorTetheringOperationResult: typeof Windows$Networking$NetworkOperators$NetworkOperatorTetheringOperationResult,
ProvisionFromXmlDocumentResults: typeof Windows$Networking$NetworkOperators$ProvisionFromXmlDocumentResults,
ProvisionedProfile: typeof Windows$Networking$NetworkOperators$ProvisionedProfile,
ProvisioningAgent: typeof Windows$Networking$NetworkOperators$ProvisioningAgent,
UssdMessage: typeof Windows$Networking$NetworkOperators$UssdMessage,
UssdReply: typeof Windows$Networking$NetworkOperators$UssdReply,
UssdSession: typeof Windows$Networking$NetworkOperators$UssdSession,
        
      }

/**
 * Describes the cellular data services supported by a mobile broadband network device.
 */

declare  var Windows$Networking$NetworkOperators$DataClasses: {|
  +none: 0,// 0
+gprs: 1,// 1
+edge: 2,// 2
+umts: 3,// 3
+hsdpa: 4,// 4
+hsupa: 5,// 5
+lteAdvanced: 6,// 6
+cdma1xRtt: 7,// 7
+cdma1xEvdo: 8,// 8
+cdma1xEvdoRevA: 9,// 9
+cdma1xEvdv: 10,// 10
+cdma3xRtt: 11,// 11
+cdma1xEvdoRevB: 12,// 12
+cdmaUmb: 13,// 13
+custom: 14,// 14

|};



/**
 * Provides the authentication context that contains details of the current authentication attempt and provides methods to perform the authentication.
 */
declare class Windows$Networking$NetworkOperators$HotspotAuthenticationContext  {

/**
 * Gets the context of an authentication attempt.
 * @param evenToken The event token retrieved from the network operator hotspot authentication event . The token is a GUID in string format.
 */
static tryGetAuthenticationContext(
evenToken: string): {
context: Windows$Networking$NetworkOperators$HotspotAuthenticationContext,
returnValue: boolean
};

/**
 * Aborts the current authentication attempt and disconnects the WLAN interface from the hotspot.
 * @param markAsManual If true, Windows disables the auto-connect property for the corresponding WLAN profile and avoids future auto-connects to this hotspot. Otherwise, false.
 */
abortAuthentication(markAsManual: boolean): void;

/**
 * Gets the HTTPS URL specified in the Wireless Internet Service Provider roaming (WISPr) redirect message.
 */
authenticationUrl: Windows$Foundation$Uri;

/**
 * Provides credentials to Windows for hotspot authentication
 * @param userName The UserName parameter of the Wireless Internet Service Provider roaming (WISPr) authentication protocol. IssueCredentials performs URL encoding before submitting the value to the server. If this string is empty, the corresponding authentication parameter is skipped.
 * @param password The Password parameter of the WISPr authentication protocol. IssueCredentials performs URL encoding before submitting the value to the server. If this string is empty, the corresponding authentication parameter is skipped.
 * @param extraParameters Additional parameters to be appended to the authentication string. IssueCredentials appends this parameter after an "&" character to the HTTP POST string as is without any encoding. This can be used to add multiple parameters. The default for this parameter is an empty string.
 * @param markAsManualConnectOnFailure If true, an application permanently disables the auto-connect property on a connection. If authentication fails, the connection will be disconnected and not retried in the current user session. Otherwise, false.
 */
issueCredentials(
userName: string,
password: string,
extraParameters: string,
markAsManualConnectOnFailure: boolean): void;

/**
 * Asynchronously provides credentials to Windows for hotspot authentication Windows does not cache these credentials and another authentication event will be raised when the system connects to the same hotspot again.
 * @param userName The UserName parameter of the Wireless Internet Service Provider roaming (WISPr) authentication protocol. IssueCredentials performs URL encoding before submitting the value to the server. If this string is empty, the corresponding authentication parameter is skipped.
 * @param password The Password parameter of the WISPr authentication protocol. IssueCredentials performs URL encoding before submitting the value to the server. If this string is empty, the corresponding authentication parameter is skipped.
 * @param extraParameters Additional parameters to be appended to the authentication string. IssueCredentials appends this parameter after an "&" character to the HTTP POST string as is without any encoding. This can be used to add multiple parameters. The default for this parameter is an empty string.
 * @param markAsManualConnectOnFailure If true, an application permanently disables the auto-connect property on a connection. If authentication fails, the connection will be disconnected and not retried in the current user session. Otherwise, false.
 * @return Results of the Hotspot authentication request.
 */
issueCredentialsAsync(
userName: string,
password: string,
extraParameters: string,
markAsManualConnectOnFailure: boolean): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$HotspotCredentialsAuthenticationResult>;

/**
 * Gets the network interface that is connected to the WLAN access point of the hotspot.
 */
networkAdapter: Windows$Networking$Connectivity$NetworkAdapter;

/**
 * Gets the URL of the web page where the Wireless Internet Service Provider roaming (WISPr) redirect message was found.
 */
redirectMessageUrl: Windows$Foundation$Uri;

/**
 * Gets the XML blob of the Wireless Internet Service Provider roaming (WISPr) redirect message of the hotspot.
 */
redirectMessageXml: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Skips Wireless Internet Service Provider roaming (WISPr) Windows authentication.
 */
skipAuthentication(): void;

/**
 * Called by a background task handler to launch the foreground application when there is an authentication attempt to complete.
 * @param packageRelativeApplicationId The foreground application ID within its application package. The application must belong to the same package as the background task handler.
 * @param applicationParameters Optional command line parameters that are passed to the application at launch.
 */
triggerAttentionRequired(packageRelativeApplicationId: string, applicationParameters: string): void;

/**
 * Gets the SSID of the WLAN access point of the hotspot.
 */
wirelessNetworkId: number
}


/**
 * Provides the content of the event that is raised for background task handlers for the hotspot authentication event.
 */
declare class Windows$Networking$NetworkOperators$HotspotAuthenticationEventDetails  {

/**
 * Gets a GUID that uniquely identifies the authentication attempt for which this event was raised.
 */
eventToken: string
}


/**
 * Defines values used to indicate status of connection authentication with a mobile hotspot. Provides the response code from the WISPr server for an authentication attempt.
 */

declare  var Windows$Networking$NetworkOperators$HotspotAuthenticationResponseCode: {|
  +noError: 0,// 0
+loginSucceeded: 1,// 1
+loginFailed: 2,// 2
+radiusServerError: 3,// 3
+networkAdministratorError: 4,// 4
+loginAborted: 5,// 5
+accessGatewayInternalError: 6,// 6

|};



/**
 * Represents the results of a Hotspot authentication request.
 */
declare class Windows$Networking$NetworkOperators$HotspotCredentialsAuthenticationResult  {

/**
 * Provides the XML blob containing the WISPr authentication reply message from the server.
 */
authenticationReplyXml: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Indicates if a network error has occurred that prevented the authentication attempt. If true, the other properties should not be examined.
 */
hasNetworkErrorOccurred: boolean;

/**
 * Provides the most recent Logoff URL as returned from the server in the authentication reply or from an earlier redirect message. If no Logoff URL was provided by the server, this property returns an empty URI.
 */
logoffUrl: Windows$Foundation$Uri;

/**
 * Provides the WISPr Response Code for the authentication attempt as returned from the server. Possible values are defined by HotspotAuthenticationResponseCode .
 */
responseCode: $Values<typeof Windows$Networking$NetworkOperators$HotspotAuthenticationResponseCode>
}


/**
 * Static class that provides well known CSIM file paths.
 */
declare class Windows$Networking$NetworkOperators$KnownCSimFilePaths  {

/**
 * Static property that gets the EFSPN path.
 */
static efSpn: Windows$Foundation$Collections$IVectorView<number>;

/**
 * Static property that gets the GID1 path.
 */
static gid1: Windows$Foundation$Collections$IVectorView<number>;

/**
 * Static property that gets the GID2 path.
 */
static gid2: Windows$Foundation$Collections$IVectorView<number>
}


/**
 * Static class that provides known RUIM file paths.
 */
declare class Windows$Networking$NetworkOperators$KnownRuimFilePaths  {

/**
 * Static property that gets the EFSPN path.
 */
static efSpn: Windows$Foundation$Collections$IVectorView<number>;

/**
 * Static property that gets the GID1 path.
 */
static gid1: Windows$Foundation$Collections$IVectorView<number>;

/**
 * Static property that gets the GID2 path.
 */
static gid2: Windows$Foundation$Collections$IVectorView<number>
}


/**
 * Static class that provides known SIM file paths.
 */
declare class Windows$Networking$NetworkOperators$KnownSimFilePaths  {

/**
 * Static property that gets the EFONS path.
 */
static efOns: Windows$Foundation$Collections$IVectorView<number>;

/**
 * Static property that gets the EFSPN path.
 */
static efSpn: Windows$Foundation$Collections$IVectorView<number>;

/**
 * Static property that gets the GID1 path.
 */
static gid1: Windows$Foundation$Collections$IVectorView<number>;

/**
 * Static property that gets the GID2 path.
 */
static gid2: Windows$Foundation$Collections$IVectorView<number>
}


/**
 * Static class that provides known USIM file paths.
 */
declare class Windows$Networking$NetworkOperators$KnownUSimFilePaths  {

/**
 * Static property that gets the EFOPL path.
 */
static efOpl: Windows$Foundation$Collections$IVectorView<number>;

/**
 * Static property that gets the EFPNN path.
 */
static efPnn: Windows$Foundation$Collections$IVectorView<number>;

/**
 * Static property that gets the EFSPN path.
 */
static efSpn: Windows$Foundation$Collections$IVectorView<number>;

/**
 * Static property that gets the GID1 path.
 */
static gid1: Windows$Foundation$Collections$IVectorView<number>;

/**
 * Static property that gets the GID2 path.
 */
static gid2: Windows$Foundation$Collections$IVectorView<number>
}


/**
 * Represents a mobile broadband account and related information about the network provider for the account.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandAccount  {

/**
 * A list of all network account IDs for the network service provider.
 */
static availableNetworkAccountIds: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Creates a mobile broadband account for the mobile device associated with the supplied network account ID.
 * @param networkAccountId The network account ID to use to select the corresponding mobile broadband device to use for the account.
 * @return A mobile broadband account for the mobile device associated with the supplied network account ID.
 */
static createFromNetworkAccountId(
networkAccountId: string): Windows$Networking$NetworkOperators$MobileBroadbandAccount;

/**
 * Gets the mobile broadband device information associated with this account.
 */
currentDeviceInformation: Windows$Networking$NetworkOperators$MobileBroadbandDeviceInformation;

/**
 * Gets the Mobile Broadband network object for this account.
 */
currentNetwork: Windows$Networking$NetworkOperators$MobileBroadbandNetwork;

/**
 * Retrieves an array of ConnectionProfile objects that represent connections associated with the Mobile Broadband account.
 * @return An array of ConnectionProfile objects.
 */
getConnectionProfiles(
): Windows$Foundation$Collections$IVectorView<Windows$Networking$Connectivity$ConnectionProfile>;

/**
 * Gets a unique identifier for the mobile broadband account.
 */
networkAccountId: string;

/**
 * A unique identifier for the network provider for the mobile broadband account.
 */
serviceProviderGuid: string;

/**
 * The name of the network provider for the mobile broadband account.
 */
serviceProviderName: string
}


/**
 * Provides information for the AccountAdded and AccountRemoved events.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandAccountEventArgs  {

/**
 * Gets the network account Id that was added or removed.
 */
networkAccountId: string
}


/**
 * Provides information for the AccountUpdated event.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandAccountUpdatedEventArgs  {

/**
 * Gets a value indicating whether the device information has changed for the account.
 */
hasDeviceInformationChanged: boolean;

/**
 * Gets a value that indicates if the CurrentNetwork was updated for the account.
 */
hasNetworkChanged: boolean;

/**
 * Gets the network account Id of the updated account.
 */
networkAccountId: string
}


/**
 * Provides information regarding availability of and updates to Mobile Broadband Accounts.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher  {

/**
 * Creates a new instance of a MobileBroadbandAccountWatcher .
 */
constructor(): this;

/**
 * Occurs when a Mobile Broadband Account is added to the client.
 */
onaccountadded: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher, Windows$Networking$NetworkOperators$MobileBroadbandAccountEventArgs>;
addEventListener(
type: "accountadded",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher, Windows$Networking$NetworkOperators$MobileBroadbandAccountEventArgs>): void;
removeEventListener(
type: "accountadded",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher, Windows$Networking$NetworkOperators$MobileBroadbandAccountEventArgs>): void;

/**
 * Occurs when a Mobile Broadband Account is removed from the client.
 */
onaccountremoved: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher, Windows$Networking$NetworkOperators$MobileBroadbandAccountEventArgs>;
addEventListener(
type: "accountremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher, Windows$Networking$NetworkOperators$MobileBroadbandAccountEventArgs>): void;
removeEventListener(
type: "accountremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher, Windows$Networking$NetworkOperators$MobileBroadbandAccountEventArgs>): void;

/**
 * Occurs when a Mobile Broadband Account is updated on the client.
 */
onaccountupdated: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher, Windows$Networking$NetworkOperators$MobileBroadbandAccountUpdatedEventArgs>;
addEventListener(
type: "accountupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher, Windows$Networking$NetworkOperators$MobileBroadbandAccountUpdatedEventArgs>): void;
removeEventListener(
type: "accountupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher, Windows$Networking$NetworkOperators$MobileBroadbandAccountUpdatedEventArgs>): void;

/**
 * Occurs when the account watcher has finished enumerating accounts for the client.
 */
onenumerationcompleted: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher, any>;
addEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher, any>): void;
removeEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher, any>): void;

/**
 * Occurs when the MobileBroadbandAccountWatcher has stopped.
 */
onstopped: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher, any>;
addEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher, any>): void;
removeEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcher, any>): void;

/**
 * Starts the account watcher.
 */
start(): void;

/**
 * Gets the status of the account watcher.
 */
status: $Values<typeof Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcherStatus>;

/**
 * Stops the account watcher.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Describes different states of a MobileBroadbandAccountWatcherStatus object.
 */

declare  var Windows$Networking$NetworkOperators$MobileBroadbandAccountWatcherStatus: {|
  +created: 0,// 0
+started: 1,// 1
+enumerationCompleted: 2,// 2
+stopped: 3,// 3
+aborted: 4,// 4

|};



/**
 * Represents the current state of the mobile broadband network device for the account.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandDeviceInformation  {

/**
 * Gets the cellular technology used by the mobile broadband network device.
 */
cellularClass: $Values<typeof Windows$Devices$Sms$CellularClass>;

/**
 * Gets a value indicating the radio state of the device.
 */
currentRadioState: $Values<typeof Windows$Networking$NetworkOperators$MobileBroadbandRadioState>;

/**
 * Gets the name of the data class when the DataClasses property returns Custom.
 */
customDataClass: string;

/**
 * Gets the cellular data services supported by the mobile broadband network device.
 */
dataClasses: $Values<typeof Windows$Networking$NetworkOperators$DataClasses>;

/**
 * Gets the DeviceInformation Id of the mobile broadband device.
 */
deviceId: string;

/**
 * Gets a value indicating the type of Mobile Broadband device.
 */
deviceType: $Values<typeof Windows$Networking$NetworkOperators$MobileBroadbandDeviceType>;

/**
 * Gets the device-specific firmware information for the mobile broadband network device.
 */
firmwareInformation: string;

/**
 * Gets the name of the manufacturer of the mobile broadband network device.
 */
manufacturer: string;

/**
 * Gets the value that uniquely identifies the mobile broadband device to the network provider.
 */
mobileEquipmentId: string;

/**
 * Gets the name of the model of the mobile broadband network device.
 */
model: string;

/**
 * Gets the readiness status of the mobile broadband network device.
 */
networkDeviceStatus: $Values<typeof Windows$Networking$NetworkOperators$NetworkDeviceStatus>;

/**
 * Gets a MobileBroadbandPinManager object for the mobile broadband device.
 */
pinManager: Windows$Networking$NetworkOperators$MobileBroadbandPinManager;

/**
 * Gets the revision of the mobile broadband device.
 */
revision: string;

/**
 * Gets the serial number of the mobile broadband device.
 */
serialNumber: string;

/**
 * Gets the SIM integrated circuit card identifier (ICCID) for the mobile broadband network device.
 */
simIccId: string;

/**
 * Gets the subscriber identifier for the mobile broadband network device.
 */
subscriberId: string;

/**
 * Gets the telephone numbers for the mobile broadband device.
 */
telephoneNumbers: Windows$Foundation$Collections$IVectorView<string>
}


/**
 * Represents a mobile broadband device service.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandDeviceService  {

/**
 * Gets the unique device service identity for the mobile broadband device service.
 */
deviceServiceId: string;

/**
 * Opens a new MobileBroadbandDeviceServiceCommandSession for the mobile broadband device service.
 * @return A new command session for the mobile broadband device service.
 */
openCommandSession(
): Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceCommandSession;

/**
 * Opens a new MobileBroadbandDeviceServiceDataSession for the mobile broadband device service.
 * @return A new data session for the Mobile Broadband device service.
 */
openDataSession(): Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceDataSession;

/**
 * Gets a list of supported device service commands for the mobile broadband device service.
 */
supportedCommands: Windows$Foundation$Collections$IVectorView<number>
}


/**
 * Represents the result of a mobile broadband device service command.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceCommandResult  {

/**
 * Gets the response data from the command execution on a mobile broadband device service.
 */
responseData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the status code of the command execution on a mobile broadband device service.
 */
statusCode: number
}


/**
 * Represents a device service command session which allows the caller to submit predefined commands to the modem on a mobile broadband device service.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceCommandSession  {

/**
 * Closes the command session on a mobile broadband device service.
 */
closeSession(): void;

/**
 * Starts an asynchronous operation on a mobile broadband device service to send a query command to the command session.
 * @param commandId The command identifier for the query command to be executed.
 * @param data The data to be submitted as part of the command.
 * @return An asynchronous operation that returns the result of the command.
 */
sendQueryCommandAsync(
commandId: number,
data: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceCommandResult>;

/**
 * Starts an asynchronous operation on a mobile broadband device service to send a set command to the command session.
 * @param commandId The command identifier for the set command to be executed.
 * @param data The data to be submitted as part of the command.
 * @return An asynchronous operation that returns the result of the command.
 */
sendSetCommandAsync(
commandId: number,
data: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceCommandResult>
}


/**
 * Provides data for a DataReceived event on a MobileBroadbandDeviceServiceDataSession when data is received .
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceDataReceivedEventArgs  {

/**
 * Gets the data received on the MobileBroadbandDeviceServiceDataSession .
 */
receivedData: Windows$Storage$Streams$IBuffer
}


/**
 * Represents a device service data session which allows the caller to write data to the modem on a mobile broadband device service.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceDataSession  {

/**
 * Closes the data session on a mobile broadband device service.
 */
closeSession(): void;

/**
 * An event that indicates that data was received on the MobileBroadbandDeviceServiceDataSession object after the WriteDataAsync method was called.
 */
ondatareceived: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceDataSession, Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceDataReceivedEventArgs>;
addEventListener(
type: "datareceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceDataSession, Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceDataReceivedEventArgs>): void;
removeEventListener(
type: "datareceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceDataSession, Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceDataReceivedEventArgs>): void;

/**
 * Starts an asynchronous operation on a mobile broadband device service to write data to the data session.
 * @param value The data to be submitted as part of the write operation.
 * @return An asynchronous operation that returns the result of the write operation.
 */
writeDataAsync(
value: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncAction;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Contains information about a mobile broadband device service.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceInformation  {

/**
 * Gets the unique device service identifier for the mobile broadband device.
 */
deviceServiceId: string;

/**
 * Determines if the mobile broadband device service is able to read data.
 */
isDataReadSupported: boolean;

/**
 * Determines if the mobile broadband device service is able to write data.
 */
isDataWriteSupported: boolean
}


/**
 * Provides details for a network device service notification.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceTriggerDetails  {

/**
 * Gets the device ID of the device that triggered a broadband device service event.
 */
deviceId: string;

/**
 * Gets the device service identifier for the device service trigger event.
 */
deviceServiceId: string;

/**
 * Gets the received data associated with the triggered event.
 */
receivedData: Windows$Storage$Streams$IBuffer
}


/**
 * Describes different types of Mobile Broadband devices.
 */

declare  var Windows$Networking$NetworkOperators$MobileBroadbandDeviceType: {|
  +unknown: 0,// 0
+embedded: 1,// 1
+removable: 2,// 2
+remote: 3,// 3

|};



/**
 * Represents a mobile broadband modem.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandModem  {

/**
 * Determine if a mobile broadband device is a Wireless WAN device.
 * @param deviceId The mobile broadband device ID
 * @return The mobile broadband modem.
 */
static fromId(deviceId: string): Windows$Networking$NetworkOperators$MobileBroadbandModem;

/**
 * Determines the default mobile broadband modem.
 * @return The mobile broadband modem.
 */
static getDefault(): Windows$Networking$NetworkOperators$MobileBroadbandModem;

/**
 * Gets a device selector for the mobile broadband modem.
 * @return A device selector for the mobile broadband modem.
 */
static getDeviceSelector(): string;

/**
 * Gets the MobileBroadbandAccount associated currently with the mobile broadband modem.
 */
currentAccount: Windows$Networking$NetworkOperators$MobileBroadbandAccount;

/**
 * Gets an object that describes the mobile broadband network that this modem us currently attached to.
 */
currentNetwork: Windows$Networking$NetworkOperators$MobileBroadbandNetwork;

/**
 * Gets the MobileBroadbandDeviceInformation for the mobile broadband modem.
 */
deviceInformation: Windows$Networking$NetworkOperators$MobileBroadbandDeviceInformation;

/**
 * Gets a list of the device services available for the mobile broadband modem.
 */
deviceServices: Windows$Foundation$Collections$IVectorView<Windows$Networking$NetworkOperators$MobileBroadbandDeviceServiceInformation>;

/**
 * Asynchronously retrieves mobile broadband modem configuration information.
 * @return An asynchronous retrieval operation. On successful completion, contains a MobileBroadbandModemConfiguration object representing the current configuration.
 */
getCurrentConfigurationAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$MobileBroadbandModemConfiguration>;

/**
 * Gets a specific device service for the mobile broadband modem.
 * @param deviceServiceId The unique device service identifier for the device service to be retrieved.
 * @return The mobile broadband device service retrieved.
 */
getDeviceService(
deviceServiceId: string): Windows$Networking$NetworkOperators$MobileBroadbandDeviceService;

/**
 * Gets a value indicating whether the mobile broadband modem allows a reset operation.
 */
isResetSupported: boolean;

/**
 * Gets the maximum device service command size, in bytes, for the mobile broadband modem.
 */
maxDeviceServiceCommandSizeInBytes: number;

/**
 * Gets the maximum device service data size, in bytes, for the mobile broadband modem.
 */
maxDeviceServiceDataSizeInBytes: number;

/**
 * Asynchronously performs a reset operation on the mobile broadband modem.
 * @return An asynchronous reset operation.
 */
resetAsync(): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Contains details about the mobile broadband modem configuration.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandModemConfiguration  {

/**
 * Gets the home provider ID associated with the mobile broadband modem.
 */
homeProviderId: string;

/**
 * Gets the home provider name for the mobile broadband modem.
 */
homeProviderName: string;

/**
 * Gets an object representing the Universal Integrated Circuit Card (UICC), commonly called a "SIM card", associated with the mobile broadband modem.
 */
uicc: Windows$Networking$NetworkOperators$MobileBroadbandUicc
}


/**
 * Represents a mobile broadband network and the current network state.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandNetwork  {

/**
 * The name of the currently connected access point.
 */
accessPointName: string;

/**
 * Attempts to get the latest network activation error.
 */
activationNetworkError: number;

/**
 * Asynchronously retrieves a value indicating whether this network currently supports voice calls.
 * @return An asynchronous retrieval operation. On successful completion, contains a value indicating whether the network supports voice calls (if true) or not.
 */
getVoiceCallSupportAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets the unique network interface that identifies the mobile broadband network.
 */
networkAdapter: Windows$Networking$Connectivity$NetworkAdapter;

/**
 * Gets the current network registration state.
 */
networkRegistrationState: $Values<typeof Windows$Networking$NetworkOperators$NetworkRegistrationState>;

/**
 * Gets the latest packet attach network error.
 */
packetAttachNetworkError: number;

/**
 * Gets the data class of the current mobile network.
 */
registeredDataClass: $Values<typeof Windows$Networking$NetworkOperators$DataClasses>;

/**
 * Gets the provider ID for the currently registered mobile network.
 */
registeredProviderId: string;

/**
 * Gets the provider name for the currently registered mobile network.
 */
registeredProviderName: string;

/**
 * Gets the latest network registration error.
 */
registrationNetworkError: number;

/**
 * Gets a list of all UICC apps available on the SIM card that can be used for registration on a mobile network. This list includes UICC apps that are not currently used for registration, but could potentially could be used for registration.
 */
registrationUiccApps: Windows$Foundation$Collections$IVectorView<Windows$Networking$NetworkOperators$MobileBroadbandUiccApp>;

/**
 * Displays the connect UI for a specific mobile network.
 */
showConnectionUI(): void
}


/**
 * Provides details about one network registration state change.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandNetworkRegistrationStateChange  {

/**
 * Gets the unique identifier of the device associated with a network registration state change.
 */
deviceId: string;

/**
 * Gets an object which contains details about the network associated with this network state change.
 */
network: Windows$Networking$NetworkOperators$MobileBroadbandNetwork
}


/**
 * Provides details for a network registration state change notification.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandNetworkRegistrationStateChangeTriggerDetails  {

/**
 * Gets the collection of network registration state changes associated with this notification.
 */
networkRegistrationStateChanges: Windows$Foundation$Collections$IVectorView<Windows$Networking$NetworkOperators$MobileBroadbandNetworkRegistrationStateChange>
}


/**
 * Contains the properties and methods associated with a mobile broadband PIN.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandPin  {

/**
 * Gets the number of attempts remaining before the mobile broadband PIN is blocked.
 */
attemptsRemaining: number;

/**
 * Starts an asynchronous operation to change an already-enabled mobile broadband PIN.
 * @param currentPin The current mobile broadband PIN.
 * @param newPin The new mobile broadband PIN.
 * @return An asynchronous operation that returns the result.
 */
changeAsync(
currentPin: string,
newPin: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$MobileBroadbandPinOperationResult>;

/**
 * Starts an asynchronous operation to disable a previously-enabled mobile broadband PIN.
 * @param currentPin The current mobile broadband PIN.
 * @return An asynchronous operation that returns the result.
 */
disableAsync(
currentPin: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$MobileBroadbandPinOperationResult>;

/**
 * Starts an asynchronous operation to enable a previously-disabled mobile broadband PIN.
 * @param currentPin The current mobile broadband PIN.
 * @return An asynchronous operation that returns the result.
 */
enableAsync(
currentPin: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$MobileBroadbandPinOperationResult>;

/**
 * Gets a boolean value that indicates if the mobile broadband PIN is enabled.
 */
enabled: boolean;

/**
 * Starts an asynchronous operation to get the current mobile broadband PIN from the user.
 * @param currentPin The current mobile broadband PIN.
 * @return An asynchronous operation that returns the result.
 */
enterAsync(
currentPin: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$MobileBroadbandPinOperationResult>;

/**
 * Gets the format for a mobile broadband PIN.
 */
format: $Values<typeof Windows$Networking$NetworkOperators$MobileBroadbandPinFormat>;

/**
 * Gets the lock state for a mobile broadband PIN.
 */
lockState: $Values<typeof Windows$Networking$NetworkOperators$MobileBroadbandPinLockState>;

/**
 * Gets the maximum length, in bytes, of the mobile broadband PIN.
 */
maxLength: number;

/**
 * Gets the minimum length, in bytes, of the mobile broadband PIN.
 */
minLength: number;

/**
 * Gets the PIN type for a mobile broadband PIN.
 */
type: $Values<typeof Windows$Networking$NetworkOperators$MobileBroadbandPinType>;

/**
 * Starts an asynchronous operation to unblock a previously-blocked mobile broadband PIN using a PIN unlock key (PUK).
 * @param pinUnblockKey The PIN unblock key.
 * @param newPin The new mobile broadband PIN.
 * @return An asynchronous operation that returns the result.
 */
unblockAsync(
pinUnblockKey: string,
newPin: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$MobileBroadbandPinOperationResult>
}


/**
 * Describes the possible formats for a mobile broadband PIN.
 */

declare  var Windows$Networking$NetworkOperators$MobileBroadbandPinFormat: {|
  +unknown: 0,// 0
+numeric: 1,// 1
+alphanumeric: 2,// 2

|};



/**
 * Describes the possible PIN lock states of a mobile broadband PIN.
 */

declare  var Windows$Networking$NetworkOperators$MobileBroadbandPinLockState: {|
  +unknown: 0,// 0
+unlocked: 1,// 1
+pinRequired: 2,// 2
+pinUnblockKeyRequired: 3,// 3

|};



/**
 * Contains details of a PIN lock state change notification.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandPinLockStateChange  {

/**
 * Gets the device identifier associated with a PIN lock state change.
 */
deviceId: string;

/**
 * Gets a value representing the new PIN lock state after a PIN lock state change.
 */
pinLockState: $Values<typeof Windows$Networking$NetworkOperators$MobileBroadbandPinLockState>;

/**
 * Gets a value representing the type of PIN involved in a PIN lock state change.
 */
pinType: $Values<typeof Windows$Networking$NetworkOperators$MobileBroadbandPinType>
}


/**
 * Provides details for a network registration state change notification.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandPinLockStateChangeTriggerDetails  {

/**
 * Gets the collection of PIN lock state change details associated with a notification.
 */
pinLockStateChanges: Windows$Foundation$Collections$IVectorView<Windows$Networking$NetworkOperators$MobileBroadbandPinLockStateChange>
}


/**
 * Defines the PIN manager for a given mobile broadband modem and SIM Card.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandPinManager  {

/**
 * Gets the mobile broadband PIN of a specific PIN type.
 * @param pinType The mobile broadband PIN type.
 * @return The mobile broadband PIN returned. This value is either provided by the end user or from a cache if allowed. .
 */
getPin(
pinType: $Values<typeof Windows$Networking$NetworkOperators$MobileBroadbandPinType>): Windows$Networking$NetworkOperators$MobileBroadbandPin;

/**
 * Gets a list of the supported PIN types for the mobile broadband modem and SIM Card.
 */
supportedPins: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Networking$NetworkOperators$MobileBroadbandPinType>>
}


/**
 * Represents the result of a mobile broadband PIN operation.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandPinOperationResult  {

/**
 * Gets the number of PIN entry attempts remaining until the mobile broadband PIN is blocked.
 */
attemptsRemaining: number;

/**
 * Gets a value indicating whether the PIN operation was successful.
 */
isSuccessful: boolean
}


/**
 * Describes the possible types for a mobile broadband PIN.
 */

declare  var Windows$Networking$NetworkOperators$MobileBroadbandPinType: {|
  +none: 0,// 0
+custom: 1,// 1
+pin1: 2,// 2
+pin2: 3,// 3
+simPin: 4,// 4
+firstSimPin: 5,// 5
+networkPin: 6,// 6
+networkSubsetPin: 7,// 7
+serviceProviderPin: 8,// 8
+corporatePin: 9,// 9
+subsidyLock: 10,// 10

|};



/**
 * Describes radio states for a Mobile Broadband device.
 */

declare  var Windows$Networking$NetworkOperators$MobileBroadbandRadioState: {|
  +off: 0,// 0
+on: 1,// 1

|};



/**
 * Contains details of a radio state change notification.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandRadioStateChange  {

/**
 * Gets the device ID of the device whose radio state changed.
 */
deviceId: string;

/**
 * Gets the new state of the radio.
 */
radioState: $Values<typeof Windows$Networking$NetworkOperators$MobileBroadbandRadioState>
}


/**
 * Provides details for a radio state change notification.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandRadioStateChangeTriggerDetails  {

/**
 * Gets the collection of radio state change details associated with a notification.
 */
radioStateChanges: Windows$Foundation$Collections$IVectorView<Windows$Networking$NetworkOperators$MobileBroadbandRadioStateChange>
}


/**
 * Represents a Universal Integrated Circuit Card (UICC), normally called a SIM Card on a mobile broadband device.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandUicc  {

/**
 * Asynchronously retrieves a list of mobile broadband UICC (SIM card) applications.
 * @return An asynchronous retrieval operation. On successful completion, returns an object with the results of the retrieval operation.
 */
getUiccAppsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$MobileBroadbandUiccAppsResult>;

/**
 * Gets the unique SIM Card identity on a mobile broadband device.
 */
simIccId: string
}


/**
 * Represents a UICC (SIM card) application.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandUiccApp  {

/**
 * Asynchronously retrieves details about a UICC application.
 * @param uiccFilePath A sequence of characters specifying the UICC file path of the application. Use the MobileBroadbandUiccApp.Id property value of this instance, to get app record details for this application.
 * @return An asynchronous retrieval operation. On successful completion, returns a MobileBroadbandUiccAppRecordDetailsResult instance initialized for the specified application's details.
 */
getRecordDetailsAsync(
uiccFilePath: Windows$Foundation$Collections$IIterable<number>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$MobileBroadbandUiccAppRecordDetailsResult>;

/**
 * Gets the ID of this UICC application.
 */
id: Windows$Storage$Streams$IBuffer;

/**
 * Gets what kind of UICC application this instance represents.
 */
kind: $Values<typeof Windows$Networking$NetworkOperators$UiccAppKind>;

/**
 * Asynchronously reads a UICC application record.
 * @param uiccFilePath A sequence of characters specifying the path to the UICC application.
 * @param recordIndex The record index within the UICC application's records.
 * @return An asynchronous retrieval operation. On successful completion, returns a MobileBroadbandUiccAppReadRecordResult with the result of the operation.
 */
readRecordAsync(
uiccFilePath: Windows$Foundation$Collections$IIterable<number>,
recordIndex: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$MobileBroadbandUiccAppReadRecordResult>
}


/**
 * Describes the status of an operation on a UICC application.
 */

declare  var Windows$Networking$NetworkOperators$MobileBroadbandUiccAppOperationStatus: {|
  +success: 0,// 0
+invalidUiccFilePath: 1,// 1
+accessConditionNotHeld: 2,// 2
+uiccBusy: 3,// 3

|};



/**
 * Encapsulates the results of a UICC application record read operation.
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandUiccAppReadRecordResult  {

/**
 * Gets the data returned by the application record read operation. Note that if Status is not Success, this value may be invalid or empty.
 */
data: Windows$Storage$Streams$IBuffer;

/**
 * Gets a value which indicates whether the record read completed successfully.
 */
status: $Values<typeof Windows$Networking$NetworkOperators$MobileBroadbandUiccAppOperationStatus>
}


/**
 * Contains details about results of a UICC application record read operation initiated with MobileBroadbandUiccAppClass.GetRecordDetailsAsync .
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandUiccAppRecordDetailsResult  {

/**
 * Gets an enumeration value specifying what kind of record this is.
 */
kind: $Values<typeof Windows$Networking$NetworkOperators$UiccAppRecordKind>;

/**
 * Gets a value specifying how read access to this record is determined.
 */
readAccessCondition: $Values<typeof Windows$Networking$NetworkOperators$UiccAccessCondition>;

/**
 * Gets the count of this record in the list of records provided by this UICC application.
 */
recordCount: number;

/**
 * Gets the size in bytes of this record.
 */
recordSize: number;

/**
 * Gets the status of the operation to retrieve UICC application record details. If this value is not Success, then other properties might not contain valid values.
 */
status: $Values<typeof Windows$Networking$NetworkOperators$MobileBroadbandUiccAppOperationStatus>;

/**
 * Gets a value specifying how write access to this record is determined.
 */
writeAccessCondition: $Values<typeof Windows$Networking$NetworkOperators$UiccAccessCondition>
}


/**
 * Reports results of a call to MobileBroadbandUicc.GetUiccAppsAsync .
 */
declare class Windows$Networking$NetworkOperators$MobileBroadbandUiccAppsResult  {

/**
 * Gets the status of the completed MobileBroadbandUicc.GetUiccAppsAsync operation. If this value is not Success, then other properties may not be valid.
 */
status: $Values<typeof Windows$Networking$NetworkOperators$MobileBroadbandUiccAppOperationStatus>;

/**
 * A list of UICC applications retrieved using MobileBroadbandUicc.GetUiccAppsAsync . Note that this is only valid when Status is Success.
 */
uiccApps: Windows$Foundation$Collections$IVectorView<Windows$Networking$NetworkOperators$MobileBroadbandUiccApp>
}


/**
 * Describes the readiness of a device to connect to a wireless network.
 */

declare  var Windows$Networking$NetworkOperators$NetworkDeviceStatus: {|
  +deviceNotReady: 0,// 0
+deviceReady: 1,// 1
+simNotInserted: 2,// 2
+badSim: 3,// 3
+deviceHardwareFailure: 4,// 4
+accountNotActivated: 5,// 5
+deviceLocked: 6,// 6
+deviceBlocked: 7,// 7

|};



/**
 * Describes the type of a network operator notification message.
 */

declare  var Windows$Networking$NetworkOperators$NetworkOperatorEventMessageType: {|
  +gsm: 0,// 0
+cdma: 1,// 1
+ussd: 2,// 2
+dataPlanThresholdReached: 3,// 3
+dataPlanReset: 4,// 4
+dataPlanDeleted: 5,// 5
+profileConnected: 6,// 6
+profileDisconnected: 7,// 7
+registeredRoaming: 8,// 8
+registeredHome: 9,// 9
+tetheringEntitlementCheck: 10,// 10
+tetheringOperationalStateChanged: 11,// 11
+tetheringNumberOfClientsChanged: 12,// 12

|};



/**
 * Provides details for a network operator notification.
 */
declare class Windows$Networking$NetworkOperators$NetworkOperatorNotificationEventDetails  {

/**
 * Used to indicate if tethering is permitted for a device. If it is not, a reason can be provided.
 * @param allow true if tethering is permitted; otherwise, false.
 * @param entitlementFailureReason The reason tethering is not permitted.
 */
authorizeTethering(allow: boolean, entitlementFailureReason: string): void;

/**
 * Gets the data-coding scheme (DCS) of the received message.
 */
encodingType: number;

/**
 * Gets the message for the network operator notification.
 */
message: string;

/**
 * Gets a unique identifier for the mobile broadband account that received the notification.
 */
networkAccountId: string;

/**
 * Gets the type of the network notification.
 */
notificationType: $Values<typeof Windows$Networking$NetworkOperators$NetworkOperatorEventMessageType>;

/**
 * Gets the identifier of the provisioned rule that matched and triggered the notification.
 */
ruleId: string;

/**
 * Gets an SMS message for the mobile broadband account that received the notification.
 */
smsMessage: Windows$Devices$Sms$ISmsMessage
}


/**
 * Provides the ability to configure and create a NetworkOperatorTetheringAccessPointConfiguration object that contains a specific network account ID (SSID) and specifies the passphrase used to authenticate clients trying to establish a network connection to the tethering network.
 */
declare class Windows$Networking$NetworkOperators$NetworkOperatorTetheringAccessPointConfiguration  {

/**
 * Creates an instance of the NetworkOperatorTetheringAccessPointConfiguration .
 */
constructor(): this;

/**
 * Gets or sets the passphrase used to authenticate the connection.
 */
passphrase: string;

/**
 * Gets or sets the network account ID.
 */
ssid: string
}


/**
 * Contains details about a tethering client.
 */
declare class Windows$Networking$NetworkOperators$NetworkOperatorTetheringClient  {

/**
 * Gets a list of hostnames used by this tethering client.
 */
hostNames: Windows$Foundation$Collections$IVectorView<Windows$Networking$HostName>;

/**
 * Gets the MAC address of this tethering client.
 */
macAddress: string
}


/**
 * This interface exposes the methods and properties used to control and configure tethering capabilities for a specific network account.
 */
declare class Windows$Networking$NetworkOperators$NetworkOperatorTetheringManager  {

/**
 * Creates a NetworkOperatorTetheringManager using the given profile.
 * @param profile Connection profile to be used.
 * @return The resulting manager object.
 */
static createFromConnectionProfile(
profile: Windows$Networking$Connectivity$ConnectionProfile): Windows$Networking$NetworkOperators$NetworkOperatorTetheringManager;

/**
 * Creates an instance of NetworkOperatorTetheringManager for a specific network account using the provided network account ID for the mobile broadband device.
 * @param networkAccountId The network account ID.
 * @return A NetworkOperatorTetheringManager object.
 */
static createFromNetworkAccountId(
networkAccountId: string): Windows$Networking$NetworkOperators$NetworkOperatorTetheringManager;

/**
 * Indicates if a device is capable of creating a tethering network. Possible values are defined by TetheringCapability .
 * @param networkAccountId The network account ID.
 * @return The tethering capabilities of a network account.
 */
static getTetheringCapability(
networkAccountId: string): $Values<typeof Windows$Networking$NetworkOperators$TetheringCapability>;

/**
 * Gets tethering capabilities, based on the given connection profile.
 * @param profile Connection profile to be checked.
 * @return Tethering capabilities of the connection profile.
 */
static getTetheringCapabilityFromConnectionProfile(
profile: Windows$Networking$Connectivity$ConnectionProfile): $Values<typeof Windows$Networking$NetworkOperators$TetheringCapability>;

/**
 * Gets the current number of connected clients on the tethering network.
 */
clientCount: number;

/**
 * Use this method to provide tethering network configuration details for the tethering network.
 * @param configuration Provides a network account ID (SSID) and specifies the passphrase used for authentication when establishing a tethered network connection.
 * @return The asynchronous action.
 */
configureAccessPointAsync(
configuration: Windows$Networking$NetworkOperators$NetworkOperatorTetheringAccessPointConfiguration): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the current access point configuration for a network account as defined by a NetworkOperatorTetheringAccessPointConfiguration object.
 * @return Indicates the network account id and specifies the pass-phrase used for authentication when establishing a connection over the tethering network.
 */
getCurrentAccessPointConfiguration(
): Windows$Networking$NetworkOperators$NetworkOperatorTetheringAccessPointConfiguration;

/**
 * Retrieves a list of tethering clients for this NetworkOperatorTetheringManager .
 * @return A list of clients.
 */
getTetheringClients(
): Windows$Foundation$Collections$IVectorView<Windows$Networking$NetworkOperators$NetworkOperatorTetheringClient>;

/**
 * Gets the maximum number of client connections over a tethered network.
 */
maxClientCount: number;

/**
 * Establishes the tethering network.
 * @return The result of the tethering network operation.
 */
startTetheringAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$NetworkOperatorTetheringOperationResult>;

/**
 * Shuts down the tethering network.
 * @return The result of the tethering network operation.
 */
stopTetheringAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$NetworkOperatorTetheringOperationResult>;

/**
 * Gets the current operational state of the tethering feature. Possible values are defined by TetheringOperationalState
 */
tetheringOperationalState: $Values<typeof Windows$Networking$NetworkOperators$TetheringOperationalState>
}


/**
 * Represents the results of a StartTetheringAsync or StopTetheringAsync operation. In addition to the TetheringOperationStatus value, it can include an optional error message string that provides mobile operator specific context to the error.
 */
declare class Windows$Networking$NetworkOperators$NetworkOperatorTetheringOperationResult  {

/**
 * An optional error message string that provides mobile operator specific context to the error.
 */
additionalErrorMessage: string;

/**
 * Indicates the result of a tethering operation. Possible values are defined by TetheringOperationStatus .
 */
status: $Values<typeof Windows$Networking$NetworkOperators$TetheringOperationStatus>
}


/**
 * Describes the network registration state of a mobile broadband device.
 */

declare  var Windows$Networking$NetworkOperators$NetworkRegistrationState: {|
  +none: 0,// 0
+deregistered: 1,// 1
+searching: 2,// 2
+home: 3,// 3
+roaming: 4,// 4
+partner: 5,// 5
+denied: 6,// 6

|};



/**
 * Describes network types for provisioned network connectivity profiles.
 */

declare  var Windows$Networking$NetworkOperators$ProfileMediaType: {|
  +wlan: 0,// 0
+wwan: 1,// 1

|};



/**
 * The results object returned to the application when the provisioning operation has completed.
 */
declare class Windows$Networking$NetworkOperators$ProvisionFromXmlDocumentResults  {

/**
 * Determines whether all elements specified in the provisioning XML were applied.
 */
allElementsProvisioned: boolean;

/**
 * Indicates which elements in the provisioning profile could not be successfully provisioned.
 */
provisionResultsXml: string
}


/**
 * Updates cost and usage information for a mobile broadband profile.
 */
declare class Windows$Networking$NetworkOperators$ProvisionedProfile  {

/**
 * Called by the application to update the cost for a specific profile.
 * @param value Updates the cost for the profile.
 */
updateCost(value: $Values<typeof Windows$Networking$Connectivity$NetworkCostType>): void;

/**
 * Called by the application to update the usage for a specific profile.
 * @param value Updates the usage for a profile.
 */
updateUsage(value: Windows$Networking$NetworkOperators$ProfileUsage): void
}


/**
 * Represents an agent that provisions connectivity and subscription information with a network provider.
 */
declare class Windows$Networking$NetworkOperators$ProvisioningAgent  {

/**
 * Creates a provisioning agent for the mobile device associated with the supplied network account ID.
 * @param networkAccountId The network account ID to use to select the corresponding mobile broadband device to use for the provisioning agent.
 * @return The provisioning agent for the mobile device associated with the supplied network account ID.
 */
static createFromNetworkAccountId(
networkAccountId: string): Windows$Networking$NetworkOperators$ProvisioningAgent;

/**
 * Creates a new instance of a ProvisioningAgent .
 */
constructor(): this;

/**
 * Retrieves cost and plan information associated with the mobile broadband profile.
 * @param mediaType The media type that the profile belongs to.
 * @param profileName The name of the profile that the cost will be applied to.
 * @return The profile.
 */
getProvisionedProfile(
mediaType: $Values<typeof Windows$Networking$NetworkOperators$ProfileMediaType>,
profileName: string): Windows$Networking$NetworkOperators$ProvisionedProfile;

/**
 * Provisions a device for network connectivity asynchronously, based on the supplied XML document.
 * @param provisioningXmlDocument An instance of CarrierControlSchema that contains the network connectivity provisioning information.
 * @return An asynchronous handler to start the provisioning attempt and track its completion.
 */
provisionFromXmlDocumentAsync(
provisioningXmlDocument: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$ProvisionFromXmlDocumentResults>
}


/**
 * Defines values that can be returned after calling getTetheringCapability to indicate the tethering capabilities of a network account.
 */

declare  var Windows$Networking$NetworkOperators$TetheringCapability: {|
  +enabled: 0,// 0
+disabledByGroupPolicy: 1,// 1
+disabledByHardwareLimitation: 2,// 2
+disabledByOperator: 3,// 3
+disabledBySku: 4,// 4
+disabledByRequiredAppNotInstalled: 5,// 5
+disabledDueToUnknownCause: 6,// 6
+disabledBySystemCapability: 7,// 7

|};



/**
 * Defines the values returned with a NetworkOperatorTetheringOperationResult object to indicate the status of a tethering operation.
 */

declare  var Windows$Networking$NetworkOperators$TetheringOperationStatus: {|
  +success: 0,// 0
+unknown: 1,// 1
+mobileBroadbandDeviceOff: 2,// 2
+wiFiDeviceOff: 3,// 3
+entitlementCheckTimeout: 4,// 4
+entitlementCheckFailure: 5,// 5
+operationInProgress: 6,// 6

|};



/**
 * Defines values used by the TetheringOperationalState property to indicate the operational state of a device's tethering capabilities.
 */

declare  var Windows$Networking$NetworkOperators$TetheringOperationalState: {|
  +unknown: 0,// 0
+on: 1,// 1
+off: 2,// 2
+inTransition: 3,// 3

|};



/**
 * Describes the conditions placed on operations using a UICC application.
 */

declare  var Windows$Networking$NetworkOperators$UiccAccessCondition: {|
  +alwaysAllowed: 0,// 0
+pin1: 1,// 1
+pin2: 2,// 2
+pin3: 3,// 3
+pin4: 4,// 4
+administrative5: 5,// 5
+administrative6: 6,// 6
+neverAllowed: 7,// 7

|};



/**
 * Describes the kinds of UICC applications.
 */

declare  var Windows$Networking$NetworkOperators$UiccAppKind: {|
  +unknown: 0,// 0
+mf: 1,// 1
+mfSim: 2,// 2
+mfRuim: 3,// 3
+usim: 4,// 4
+csim: 5,// 5
+isim: 6,// 6

|};



/**
 * Describes the kinds of UICC application record.
 */

declare  var Windows$Networking$NetworkOperators$UiccAppRecordKind: {|
  +unknown: 0,// 0
+transparent: 1,// 1
+recordOriented: 2,// 2

|};



/**
 * Represents a USSD message that is used for sending messages to and receiving messages from the network.
 */
declare class Windows$Networking$NetworkOperators$UssdMessage  {

/**
 * Creates a new instance of a UssdMessage and encodes the supplied string into the message payload.
 * @param messageText The payload for the UssdMessage.
 */
constructor(messageText: string): this;

/**
 * Gets or sets the encoding scheme of the payload of this UssdMessage .
 */
dataCodingScheme: number;

/**
 * Gets the raw payload of this UssdMessage .
 * @return The raw payload of this UssdMessage .
 */
getPayload(): number[];

/**
 * Gets or sets the payload of this UssdMessage as text.
 */
payloadAsText: string;

/**
 * Sets the raw payload of this UssdMessage .
 * @param value The raw payload of this UssdMessage .
 */
setPayload(value: number[]): void
}


/**
 * Represents the network response after sending a USSD message.
 */
declare class Windows$Networking$NetworkOperators$UssdReply  {

/**
 * Gets the message for the USSD response.
 */
message: Windows$Networking$NetworkOperators$UssdMessage;

/**
 * Gets the result code for the USSD response.
 */
resultCode: $Values<typeof Windows$Networking$NetworkOperators$UssdResultCode>
}


/**
 * Describes the USSD response codes for messages sent to the network.
 */

declare  var Windows$Networking$NetworkOperators$UssdResultCode: {|
  +noActionRequired: 0,// 0
+actionRequired: 1,// 1
+terminated: 2,// 2
+otherLocalClient: 3,// 3
+operationNotSupported: 4,// 4
+networkTimeout: 5,// 5

|};



/**
 * Represents a session of the USSD network protocol.
 */
declare class Windows$Networking$NetworkOperators$UssdSession  {

/**
 * Creates a USSD session for the mobile device associated with the supplied network account ID.
 * @param networkAccountId The network account ID to use to select the corresponding mobile broadband device to use for the USSD session.
 * @return The USSD session for the mobile device associated with the supplied network account ID.
 */
static createFromNetworkAccountId(networkAccountId: string): Windows$Networking$NetworkOperators$UssdSession;

/**
 * Creates a USSD session for the mobile device associated with the supplied network interface ID.
 * @param networkInterfaceId The network interface ID to use to select the corresponding mobile broadband device to use for the USSD session.
 * @return The USSD session for the mobile device associated with the supplied network interface ID.
 */
static createFromNetworkInterfaceId(networkInterfaceId: string): Windows$Networking$NetworkOperators$UssdSession;

/**
 * Closes the USSD session with the network.
 */
close(): void;

/**
 * Sends a message to a USSD session and returns a handler to retrieve the reply asynchronously.
 * @param message The message to send to the USSD session.
 * @return An asynchronous handler to retrieve the USSD response to the sent message.
 */
sendMessageAndGetReplyAsync(
message: Windows$Networking$NetworkOperators$UssdMessage): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$NetworkOperators$UssdReply>
}


/**
 * Used to update the usage of plan data.
 */
declare interface Windows$Networking$NetworkOperators$ProfileUsage {

/**
 * The last time UsageInMegabytes was updated.
 */
lastSyncTime: Date,

/**
 * Updates the usage in megabytes.
 */
usageInMegabytes: number
} 


      declare var npm$namespace$Windows$Networking$Proximity: {
        
        
        PeerDiscoveryTypes: typeof Windows$Networking$Proximity$PeerDiscoveryTypes,
PeerRole: typeof Windows$Networking$Proximity$PeerRole,
PeerWatcherStatus: typeof Windows$Networking$Proximity$PeerWatcherStatus,
TriggeredConnectState: typeof Windows$Networking$Proximity$TriggeredConnectState,
        ConnectionRequestedEventArgs: typeof Windows$Networking$Proximity$ConnectionRequestedEventArgs,
PeerFinder: typeof Windows$Networking$Proximity$PeerFinder,
PeerInformation: typeof Windows$Networking$Proximity$PeerInformation,
PeerWatcher: typeof Windows$Networking$Proximity$PeerWatcher,
ProximityDevice: typeof Windows$Networking$Proximity$ProximityDevice,
ProximityMessage: typeof Windows$Networking$Proximity$ProximityMessage,
TriggeredConnectionStateChangedEventArgs: typeof Windows$Networking$Proximity$TriggeredConnectionStateChangedEventArgs,
        
      }

/**
 * Contains properties that are passed to an application with the ConnectionRequested event.
 */
declare class Windows$Networking$Proximity$ConnectionRequestedEventArgs  {

/**
 * Gets the information for a peer that's requesting a connection.
 */
peerInformation: Windows$Networking$Proximity$PeerInformation
}


/**
 * Indicates which discovery options are available to use with the PeerFinder class.
 */

declare  var Windows$Networking$Proximity$PeerDiscoveryTypes: {|
  +none: 0,// 0
+browse: 1,// 1
+triggered: 2,// 2

|};



/**
 * Enables you to discover other instances of your app on nearby devices and create a socket connection between the peer apps by using a tap gesture or by browsing. For creating Bluetooth socket connections on Windows 8.1 and later, use Windows.Devices.Bluetooth.Rfcomm instead.
 */
declare class Windows$Networking$Proximity$PeerFinder  {

/**
 * Specifies whether the PeerFinder class may connect a StreamSocket object by using Bluetooth.
 */
static allowBluetooth: boolean;

/**
 * Specifies whether the PeerFinder class may connect to a StreamSocket object using TCP/IP.
 */
static allowInfrastructure: boolean;

/**
 * Specifies whether the PeerFinder class may connect a StreamSocket object by using Wi-Fi Direct.
 */
static allowWiFiDirect: boolean;

/**
 * Gets a list of alternate appId values to match with peer applications on other platforms.
 */
static alternateIdentities: Windows$Foundation$Collections$IMap<string, string>;

/**
 * Connects to a peer discovered by a call to the FindAllPeersAsync method.
 * @param peerInformation A peer information object representing the peer to connect to.
 * @return An asynchronous operation for connecting to a remote peer using the supplied StreamSocket object.
 */
static connectAsync(
peerInformation: Windows$Networking$Proximity$PeerInformation): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$Sockets$StreamSocket>;

/**
 * Creates a new instance of a PeerWatcher object for dynamic discovery of peer apps.
 * @return An instance of a PeerWatcher object for dynamic discovery of peer apps.
 */
static createWatcher(): Windows$Networking$Proximity$PeerWatcher;

/**
 * Gets or sets user or device data to include during device discovery.
 */
static discoveryData: Windows$Storage$Streams$IBuffer;

/**
 * Gets or sets the name that identifies your computer to remote peers.
 */
static displayName: string;

/**
 * Asynchronously browses for peer devices that are running the same app within wireless range.
 * @return The asynchronous operation for browsing for peer devices that are running your app.
 */
static findAllPeersAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Occurs when a remote peer requests a connection using the ConnectAsync method.
 */
static onconnectionrequested: Windows$Foundation$TypedEventHandler<any, Windows$Networking$Proximity$ConnectionRequestedEventArgs>;
static addEventListener(
type: "connectionrequested",
listener: Windows$Foundation$TypedEventHandler<any, Windows$Networking$Proximity$ConnectionRequestedEventArgs>): void;
static removeEventListener(
type: "connectionrequested",
listener: Windows$Foundation$TypedEventHandler<any, Windows$Networking$Proximity$ConnectionRequestedEventArgs>): void;

/**
 * Occurs during a tap gesture from a remote peer.
 */
static ontriggeredconnectionstatechanged: Windows$Foundation$TypedEventHandler<any, Windows$Networking$Proximity$TriggeredConnectionStateChangedEventArgs>;
static addEventListener(
type: "triggeredconnectionstatechanged",
listener: Windows$Foundation$TypedEventHandler<any, Windows$Networking$Proximity$TriggeredConnectionStateChangedEventArgs>): void;
static removeEventListener(
type: "triggeredconnectionstatechanged",
listener: Windows$Foundation$TypedEventHandler<any, Windows$Networking$Proximity$TriggeredConnectionStateChangedEventArgs>): void;

/**
 * Gets or sets the role of the app in peer-to-peer connections.
 */
static role: $Values<typeof Windows$Networking$Proximity$PeerRole>;

/**
 * Makes an app discoverable to remote peers.
 * @param peerMessage The message to deliver to the proximate device.
 */
static start(peerMessage: string): void;

/**
 * Makes an app discoverable to remote peers.
 */
static start(): void;

/**
 * Stops advertising for a peer connection.
 */
static stop(): void;

/**
 * Gets a value that indicates which discovery options are available to use with the PeerFinder class.
 */
static supportedDiscoveryTypes: $Values<typeof Windows$Networking$Proximity$PeerDiscoveryTypes>;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Contains information that identifies a peer.
 */
declare class Windows$Networking$Proximity$PeerInformation  {

/**
 * Gets the device data included during device discovery.
 */
discoveryData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the display name of the peer.
 */
displayName: string;

/**
 * Gets the hostname or IP address of the peer.
 */
hostName: Windows$Networking$HostName;

/**
 * Gets the app id for the peer app.
 */
id: string;

/**
 * Gets the service name or TCP port number of the peer.
 */
serviceName: string
}


/**
 * Describes the role of the peer app when connected to multiple peers.
 */

declare  var Windows$Networking$Proximity$PeerRole: {|
  +peer: 0,// 0
+host: 1,// 1
+client: 2,// 2

|};



/**
 * Dynamically discovers peer apps within wireless range.
 */
declare class Windows$Networking$Proximity$PeerWatcher  {

/**
 * Occurs when a peer app is found within wireless range.
 */
onadded: Windows$Foundation$TypedEventHandler<Windows$Networking$Proximity$PeerWatcher, Windows$Networking$Proximity$PeerInformation>;
addEventListener(
type: "added",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Proximity$PeerWatcher, Windows$Networking$Proximity$PeerInformation>): void;
removeEventListener(
type: "added",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Proximity$PeerWatcher, Windows$Networking$Proximity$PeerInformation>): void;

/**
 * Occurs after a scan operation is complete and all peer apps within wireless range have been found.
 */
onenumerationcompleted: Windows$Foundation$TypedEventHandler<Windows$Networking$Proximity$PeerWatcher, any>;
addEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Proximity$PeerWatcher, any>): void;
removeEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Proximity$PeerWatcher, any>): void;

/**
 * Occurs when a peer app is no longer within wireless range.
 */
onremoved: Windows$Foundation$TypedEventHandler<Windows$Networking$Proximity$PeerWatcher, Windows$Networking$Proximity$PeerInformation>;
addEventListener(
type: "removed",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Proximity$PeerWatcher, Windows$Networking$Proximity$PeerInformation>): void;
removeEventListener(
type: "removed",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Proximity$PeerWatcher, Windows$Networking$Proximity$PeerInformation>): void;

/**
 * Occurs when the PeerWatcher object has been stopped.
 */
onstopped: Windows$Foundation$TypedEventHandler<Windows$Networking$Proximity$PeerWatcher, any>;
addEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Proximity$PeerWatcher, any>): void;
removeEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Proximity$PeerWatcher, any>): void;

/**
 * Occurs when the DisplayName or DiscoveryData for a peer app within wireless range has changed.
 */
onupdated: Windows$Foundation$TypedEventHandler<Windows$Networking$Proximity$PeerWatcher, Windows$Networking$Proximity$PeerInformation>;
addEventListener(
type: "updated",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Proximity$PeerWatcher, Windows$Networking$Proximity$PeerInformation>): void;
removeEventListener(
type: "updated",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$Proximity$PeerWatcher, Windows$Networking$Proximity$PeerInformation>): void;

/**
 * Begin dynamically searching for peer apps within wireless range.
 */
start(): void;

/**
 * Gets the current state of the PeerWatcher object.
 */
status: $Values<typeof Windows$Networking$Proximity$PeerWatcherStatus>;

/**
 * Stop dynamically searching for peer apps within wireless range.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Describes the status of a PeerWatcher object.
 */

declare  var Windows$Networking$Proximity$PeerWatcherStatus: {|
  +created: 0,// 0
+started: 1,// 1
+enumerationCompleted: 2,// 2
+stopping: 3,// 3
+stopped: 4,// 4
+aborted: 5,// 5

|};



/**
 * Enables you to publish messages to proximate devices or subscribe to messages from proximate devices.
 */
declare class Windows$Networking$Proximity$ProximityDevice  {

/**
 * Creates an instance of a ProximityDevice class and activates the specified proximity device interface.
 * @param deviceId The DeviceInformation Id of a proximity device.
 * @return A new ProximityDevice that uses the specified proximity device interface. Throws a System.IO.FileNotFoundException exception if the specified proximity device interface isunavailable.
 */
static fromId(deviceId: string): Windows$Networking$Proximity$ProximityDevice;

/**
 * Creates an instance of a ProximityDevice class and activates the default proximity provider.
 * @return A new proximity device that uses the default proximity provider. Returns NULL if no proximity devices are installed.
 */
static getDefault(): Windows$Networking$Proximity$ProximityDevice;

/**
 * Returns the class selection string that you can use to enumerate proximity devices.
 * @return The class selection string for proximity devices.
 */
static getDeviceSelector(): string;

/**
 * Gets the transfer rate of a proximity device.
 */
bitsPerSecond: number;

/**
 * Gets the DeviceInformation Id for a proximity device.
 */
deviceId: string;

/**
 * Gets the maximum size of a published message that this proximity device supports.
 */
maxMessageBytes: number;

/**
 * Occurs when a device enters the proximate range.
 */
ondevicearrived: Windows$Networking$Proximity$DeviceArrivedEventHandler;
addEventListener(
type: "devicearrived",
listener: Windows$Networking$Proximity$DeviceArrivedEventHandler): void;
removeEventListener(
type: "devicearrived",
listener: Windows$Networking$Proximity$DeviceArrivedEventHandler): void;

/**
 * Occurs when a device leaves the proximate range.
 */
ondevicedeparted: Windows$Networking$Proximity$DeviceDepartedEventHandler;
addEventListener(
type: "devicedeparted",
listener: Windows$Networking$Proximity$DeviceDepartedEventHandler): void;
removeEventListener(
type: "devicedeparted",
listener: Windows$Networking$Proximity$DeviceDepartedEventHandler): void;

/**
 * Publishes a message that contains binary data to subscribers of the specified message type.
 * @param messageType The type of message to deliver to subscribers.
 * @param message The binary message data to deliver to subscribers.
 * @return A unique publication ID for the published message.
 */
publishBinaryMessage(messageType: string, message: Windows$Storage$Streams$IBuffer): number;

/**
 * Publishes a message that contains binary data to subscribers of the specified message type. The specified handler is called when the message has been transmitted.
 * @param messageType The type of message to deliver to subscribers.
 * @param message The binary message data to deliver to subscribers.
 * @param messageTransmittedHandler The handler to call when the message has been transmitted.
 * @return A unique publication ID for the published message.
 */
publishBinaryMessage(
messageType: string,
message: Windows$Storage$Streams$IBuffer,
messageTransmittedHandler: Windows$Networking$Proximity$MessageTransmittedHandler): number;

/**
 * Publishes a message to subscribers of the specified message type.
 * @param messageType The type of message to deliver to subscribers.
 * @param message The message to deliver to subscribers.
 * @return A unique publication ID for the published message. Pass this value to the StopPublishingMessage method to stop publishing the message.
 */
publishMessage(messageType: string, message: string): number;

/**
 * Publishes a message to subscribers of the specified message type. The specified handler is called when the message has been transmitted.
 * @param messageType The type of message to deliver to subscribers.
 * @param message The message to deliver to subscribers.
 * @param messageTransmittedHandler The handler to call when the message has been transmitted.
 * @return A unique publication ID for the published message.
 */
publishMessage(
messageType: string,
message: string,
messageTransmittedHandler: Windows$Networking$Proximity$MessageTransmittedHandler): number;

/**
 * Publishes a Uniform Resource Identifier (URI) to a proximate device. The specified handler is called when the message has been transmitted.
 * @param message The URI to publish.
 * @param messageTransmittedHandler The handler to call when the message has been transmitted.
 * @return The publication ID of the message.
 */
publishUriMessage(
message: Windows$Foundation$Uri,
messageTransmittedHandler: Windows$Networking$Proximity$MessageTransmittedHandler): number;

/**
 * Publishes a Uniform Resource Identifier (URI) to a proximate device.
 * @param message The URI to publish.
 * @return The publication ID of the message.
 */
publishUriMessage(message: Windows$Foundation$Uri): number;

/**
 * Stops publishing a message.
 * @param messageId The publication ID for the message.
 */
stopPublishingMessage(messageId: number): void;

/**
 * Cancels a message subscription.
 * @param subscriptionId The subscription ID for the message.
 */
stopSubscribingForMessage(subscriptionId: number): void;

/**
 * Creates a subscription for a specified message type.
 * @param messageType The type of message to deliver to this subscription.
 * @param messageReceivedHandler The handler that the proximity provider will call when it delivers a message.
 * @return A unique ID for the subscription.
 */
subscribeForMessage(
messageType: string,
messageReceivedHandler: Windows$Networking$Proximity$MessageReceivedHandler): number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a message that's received from a subscription.
 */
declare class Windows$Networking$Proximity$ProximityMessage  {

/**
 * Gets the binary data of the message.
 */
data: Windows$Storage$Streams$IBuffer;

/**
 * Gets the message data as text.
 */
dataAsString: string;

/**
 * Gets the type of the message.
 */
messageType: string;

/**
 * Gets the subscription ID of the message.
 */
subscriptionId: number
}


/**
 * Indicates the current state of a connection to a peer application.
 */

declare  var Windows$Networking$Proximity$TriggeredConnectState: {|
  +peerFound: 0,// 0
+listening: 1,// 1
+connecting: 2,// 2
+completed: 3,// 3
+canceled: 4,// 4
+failed: 5,// 5

|};



/**
 * Contains properties that the TriggeredConnectionStateChanged event passes to an application.
 */
declare class Windows$Networking$Proximity$TriggeredConnectionStateChangedEventArgs  {

/**
 * Gets the unique identifier for the connection in progress.
 */
id: number;

/**
 * Gets the StreamSocket instance for the connection.
 */
socket: Windows$Networking$Sockets$StreamSocket;

/**
 * Gets the state of the connection in progress.
 */
state: $Values<typeof Windows$Networking$Proximity$TriggeredConnectState>
}


/**
 * Describes the method that handles the DeviceArrived event.
 */
declare type Windows$Networking$Proximity$DeviceArrivedEventHandler = (ev: Windows$WinRTEvent<Windows$Networking$Proximity$ProximityDevice>) => void;


/**
 * Describes the method that handles the DeviceDeparted event.
 */
declare type Windows$Networking$Proximity$DeviceDepartedEventHandler = (ev: Windows$WinRTEvent<Windows$Networking$Proximity$ProximityDevice>) => void;


/**
 * Describes the method that will handle the event that's fired when a published message has been transmitted.
 */
declare type Windows$Networking$Proximity$MessageTransmittedHandler = (
sender: Windows$Networking$Proximity$ProximityDevice,
messageId: number) => void;


/**
 * Describes the method that will handle the event that's fired when a message that has been subscribed to has been received.
 */
declare type Windows$Networking$Proximity$MessageReceivedHandler = (
sender: Windows$Networking$Proximity$ProximityDevice,
message: Windows$Networking$Proximity$ProximityMessage) => void;


      declare var npm$namespace$Windows$Networking$PushNotifications: {
        
        
        PushNotificationType: typeof Windows$Networking$PushNotifications$PushNotificationType,
        PushNotificationChannel: typeof Windows$Networking$PushNotifications$PushNotificationChannel,
PushNotificationChannelManager: typeof Windows$Networking$PushNotifications$PushNotificationChannelManager,
PushNotificationReceivedEventArgs: typeof Windows$Networking$PushNotifications$PushNotificationReceivedEventArgs,
RawNotification: typeof Windows$Networking$PushNotifications$RawNotification,
        
      }

/**
 * Represents a delivery vehicle and addressing mechanism for push notifications. The channel Uniform Resource Identifier (URI) represented by this interface is used by a third-party application server to communicate with the Windows Push Notification Services (WNS). The push notification channel is used by the client to intercept notifications.
 */
declare class Windows$Networking$PushNotifications$PushNotificationChannel  {

/**
 * Explicitly invalidates this channel. Any notifications pushed to this channel after this method is called are not delivered.
 */
close(): void;

/**
 * Gets the time at which the channel expires. Notifications sent to this channel after this time are rejected.
 */
expirationTime: Date;

/**
 * Fires when a push notification has arrived on this channel.
 */
onpushnotificationreceived: Windows$Foundation$TypedEventHandler<Windows$Networking$PushNotifications$PushNotificationChannel, Windows$Networking$PushNotifications$PushNotificationReceivedEventArgs>;
addEventListener(
type: "pushnotificationreceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$PushNotifications$PushNotificationChannel, Windows$Networking$PushNotifications$PushNotificationReceivedEventArgs>): void;
removeEventListener(
type: "pushnotificationreceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$PushNotifications$PushNotificationChannel, Windows$Networking$PushNotifications$PushNotificationReceivedEventArgs>): void;

/**
 * Gets the Uniform Resource Identifier (URI) to which an app server sends a push notification intended for an application or secondary tile bound to this channel. This URI is transmitted to and stored by the third-party app server.
 */
uri: string;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Creates objects that you use to retrieve push notification channels from the Windows Push Notification Services (WNS). These channels are bound to an app or secondary tile .
 */
declare class Windows$Networking$PushNotifications$PushNotificationChannelManager  {

/**
 * Creates an object, bound to a specified app, through which you retrieve a push notification channel from Windows Push Notification Services (WNS). The specified app must be in the same package as the calling app.
 * @param applicationId The Package Relative Application ID (PRAID) of the app to bind to the push notification channel.
 * @return The object, bound to the app specified in applicationId, that is used to request a PushNotificationChannel from the WNS.
 */
static createPushNotificationChannelForApplicationAsync(
applicationId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$PushNotifications$PushNotificationChannel>;

/**
 * Creates an object, bound to the calling app, through which you retrieve a push notification channel from Windows Push Notification Services (WNS).
 * @return The object, bound to the calling app, that is used to request a PushNotificationChannel from the WNS.
 */
static createPushNotificationChannelForApplicationAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$PushNotifications$PushNotificationChannel>;

/**
 * Creates an object, bound to a secondary tile , through which you retrieve a push notification channel from Windows Push Notification Services (WNS). The tile can be a secondary tile of the calling app or any other app in the same package.
 * @param tileId The ID of the secondary tile to bind to the push notification channel.
 * @return The object, bound to the secondary tile, that is used to request a PushNotificationChannel from the WNS.
 */
static createPushNotificationChannelForSecondaryTileAsync(
tileId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$PushNotifications$PushNotificationChannel>
}


/**
 * Encapsulates a push notification that has been received from the app server, identifying the type and supplying the content of the notification. Windows passes this information in the PushNotificationReceived event.
 */
declare class Windows$Networking$PushNotifications$PushNotificationReceivedEventArgs  {

/**
 * Gets the content of a badge update to perform in response to this push notification.
 */
badgeNotification: Windows$UI$Notifications$BadgeNotification;

/**
 * Gets or sets whether Windows should perform its default handling of the notification.
 */
cancel: boolean;

/**
 * Gets the type of push notification that has been received from the app server.
 */
notificationType: $Values<typeof Windows$Networking$PushNotifications$PushNotificationType>;
rawNotification: any;

/**
 * Gets the content of a tile update to perform in response to this push notification.
 */
tileNotification: Windows$UI$Notifications$TileNotification;

/**
 * Gets the content of a toast to display in response to this push notification.
 */
toastNotification: Windows$UI$Notifications$ToastNotification
}


/**
 * The type of push notification that has been received from the app server. Used by the NotificationType property.
 */

declare  var Windows$Networking$PushNotifications$PushNotificationType: {|
  +toast: 0,// 0
+tile: 1,// 1
+badge: 2,// 2
+raw: 3,// 3
+tileFlyout: 4,// 4

|};



/**
 * Encapsulates the app-defined content of a raw notification (a push notification that does not involve UI). Its contents can be used in an app's background task, if the app has that capability, or otherwise consumed by the app and acted on as needed.
 */
declare class Windows$Networking$PushNotifications$RawNotification  {

/**
 * Gets the content of the raw notification as a string. This string specifies a background task associated with the app.
 */
content: string
}


      declare var npm$namespace$Windows$Networking$ServiceDiscovery: {
        
        
        
        
        Dnssd: typeof npm$namespace$Windows$Networking$ServiceDiscovery$Dnssd,
      }

      declare var npm$namespace$Windows$Networking$ServiceDiscovery$Dnssd: {
        
        
        DnssdRegistrationStatus: typeof Windows$Networking$ServiceDiscovery$Dnssd$DnssdRegistrationStatus,
DnssdServiceWatcherStatus: typeof Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceWatcherStatus,
        DnssdRegistrationResult: typeof Windows$Networking$ServiceDiscovery$Dnssd$DnssdRegistrationResult,
DnssdServiceInstance: typeof Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceInstance,
DnssdServiceInstanceCollection: typeof Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceInstanceCollection,
DnssdServiceWatcher: typeof Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceWatcher,
        
      }

/**
 * Encapsulates detailed information about the result of an attempt to register a service instance using DNS-SD.
 */
declare class Windows$Networking$ServiceDiscovery$Dnssd$DnssdRegistrationResult  {

/**
 * Constructor.
 */
constructor(): this;

/**
 * Indicates whether the instance name was changed in the course of the registration process.
 */
hasInstanceNameChanged: boolean;

/**
 * The IP address of the successfully-created service instance.
 */
ipAddress: Windows$Networking$HostName;

/**
 * An enumeration value indicating the result of a service instance registration attempt.
 */
status: $Values<typeof Windows$Networking$ServiceDiscovery$Dnssd$DnssdRegistrationStatus>
}


/**
 * Values representing the status of a DNS-SD registration attempt.
 */

declare  var Windows$Networking$ServiceDiscovery$Dnssd$DnssdRegistrationStatus: {|
  +success: 0,// 0
+invalidServiceName: 1,// 1
+serverError: 2,// 2
+securityError: 3,// 3

|};



/**
 * Encapsulates an instance of a service that uses DNS Service Discovery (DNS-SD).
 */
declare class Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceInstance  {

/**
 * Creates a new DnssdServiceInstance object with the specified instance name, host name, and port.
 * @param DnssdServiceInstanceName The service instance name for the service instance being created.
 * @param hostName The hostname for the service instance being created.
 * @param port The port number for the service instance being created.
 */
constructor(DnssdServiceInstanceName: string, hostName: Windows$Networking$HostName, port: number): this;

/**
 * Gets or sets the DNS-SD service instance name for this DnssdServiceInstance .
 */
dnssdServiceInstanceName: string;

/**
 * Gets or sets the hostname of the host for this DnssdServiceInstance .
 */
hostName: Windows$Networking$HostName;

/**
 * Gets or sets the port number used by this DnssdServiceInstance .
 */
port: number;

/**
 * Gets or sets the priority value to assign to this service instance, as defined in RFC 2782. Clients use Priority to decide which of several equivalent service instances to attach to.
 */
priority: number;

/**
 * Asynchronously registers a datagram (UDP) socket listener for the service, on a given socket and network adapter.
 * @param socket Describes the socket that this service instance uses to listen for new service clients.
 * @param adapter Specifies the network adapter this service uses to listen for new service clients.
 * @return On successful completion of the asynchronous operation, returns an object describing the results of registration.
 */
registerDatagramSocketAsync(
socket: Windows$Networking$Sockets$DatagramSocket,
adapter: Windows$Networking$Connectivity$NetworkAdapter): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$ServiceDiscovery$Dnssd$DnssdRegistrationResult>;

/**
 * Asynchronously registers a datagram (UDP) socket listener for the service, on a given socket.
 * @param socket Describes the socket that this service instance uses to listen for new service clients.
 * @return On successful completion of the asynchronous operation, returns an object describing the results of registration.
 */
registerDatagramSocketAsync(
socket: Windows$Networking$Sockets$DatagramSocket): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$ServiceDiscovery$Dnssd$DnssdRegistrationResult>;

/**
 * Asynchronously registers a stream (TCP) socket listener for the service, on the given socket and network adapter.
 * @param socket Describes the socket that this service instance uses to listen for new service clients.
 * @param adapter Specifies the network adapter this service uses to listen for new service clients.
 * @return On successful completion of the asynchronous operation, returns an object describing the results of registration.
 */
registerStreamSocketListenerAsync(
socket: Windows$Networking$Sockets$StreamSocketListener,
adapter: Windows$Networking$Connectivity$NetworkAdapter): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$ServiceDiscovery$Dnssd$DnssdRegistrationResult>;

/**
 * Asynchronously registers a stream (TCP) socket listener for the service, on the given socket.
 * @param socket Describes the socket that this service instance uses to listen for new service clients.
 * @return On successful completion of the asynchronous operation, returns an object describing the results of registration.
 */
registerStreamSocketListenerAsync(
socket: Windows$Networking$Sockets$StreamSocketListener): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$ServiceDiscovery$Dnssd$DnssdRegistrationResult>;

/**
 * Gets the attributes of this service instance, as a list of [name, value] pairs of strings. Attributes can be inspected by service clients to determine additional information about a service instance.
 */
textAttributes: Windows$Foundation$Collections$IMap<string, string>;

/**
 * Gets or sets the weight value assigned to this service instance, as defined in RFC 2782. Clients use the Weight value to choose between servers with the same Priority value.
 */
weight: number
}


/**
 * A collection of DNS Service Discovery (DNS-SD) service instances.
 */
declare class Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceInstanceCollection mixins Array<Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceInstance> {

/**
 * Gets an iterator that is initialized to refer to the first item in the instance collection.
 * @return Gets an iterator instance initialized to the first item in the service instance collection. Your code can use this iterator to enumerate all members of the collection.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceInstance>;

/**
 * Gets the DnssdServiceInstance at a given index into the DnssdServiceInstanceCollection .
 * @param index The index of the instance to be retrieved. Indices are 0-based. If your code specifies an index that is out of bounds, an exception is thrown. The maximum valid index is equal to one less than the DnssdServiceInstanceCollection.Size value.
 * @return The DnssdServiceInstance at the given index in the collection.
 */
getAt(index: number): Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceInstance;

/**
 * Gets multiple DnssdServiceInstance objects from a DNS-SD service instance collection.
 * @param startIndex Index of the first collection item to be retrieved.
 */
getMany(
startIndex: number): {
items: Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceInstance,
returnValue: number
};

/**
 * Gets a value indicating whether a given DnssdServiceInstance is at the specified index in this service instance collection.
 * @param value The DnssdServiceInstance to get the index of.
 */
indexOf(
value: Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceInstance): {
index: number,
returnValue: boolean
};

/**
 * Gets the number of items in the collection
 */
size: number;
indexOf(
value: Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceInstance,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceInstance,
fromIndex?: number): number
}


/**
 * Maintains a collection of available DNS Service Discovery (DNS-SD) service instances.
 */
declare class Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceWatcher  {

/**
 * Event that is triggered when a DnssdServiceWatcher has added a DNS Service Discovery (DNS-SD) instance to its collection of available service instances.
 */
onadded: Windows$Foundation$TypedEventHandler<Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceWatcher, Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceInstance>;
addEventListener(
type: "added",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceWatcher, Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceInstance>): void;
removeEventListener(
type: "added",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceWatcher, Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceInstance>): void;

/**
 * Event triggered when a DnssdServiceWatcher has finished enumerating available DNS Service Discovery (DNS-SD) service instances.
 */
onenumerationcompleted: Windows$Foundation$TypedEventHandler<Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceWatcher, any>;
addEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceWatcher, any>): void;
removeEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceWatcher, any>): void;

/**
 * Event triggered when an in-progress enumeration has been stopped.
 */
onstopped: Windows$Foundation$TypedEventHandler<Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceWatcher, any>;
addEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceWatcher, any>): void;
removeEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceWatcher, any>): void;

/**
 * Starts an enumeration of the network for available DNS Service Discovery (DNS-SD) service instances.
 */
start(): void;

/**
 * Gets the current status of the DnssdServiceWatcherStatus .
 */
status: $Values<typeof Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceWatcherStatus>;

/**
 * Stops an in-progress enumeration of available DNS Service Discovery (DNS-SD) service instances.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Values representing the status of a DnssdServiceWatcher.
 */

declare  var Windows$Networking$ServiceDiscovery$Dnssd$DnssdServiceWatcherStatus: {|
  +created: 0,// 0
+started: 1,// 1
+enumerationCompleted: 2,// 2
+stopping: 3,// 3
+stopped: 4,// 4
+aborted: 5,// 5

|};



      declare var npm$namespace$Windows$Networking$Vpn: {
        
        
        VpnAppIdType: typeof Windows$Networking$Vpn$VpnAppIdType,
VpnAuthenticationMethod: typeof Windows$Networking$Vpn$VpnAuthenticationMethod,
VpnChannelActivityEventType: typeof Windows$Networking$Vpn$VpnChannelActivityEventType,
VpnChannelRequestCredentialsOptions: typeof Windows$Networking$Vpn$VpnChannelRequestCredentialsOptions,
VpnCredentialType: typeof Windows$Networking$Vpn$VpnCredentialType,
VpnDataPathType: typeof Windows$Networking$Vpn$VpnDataPathType,
VpnDomainNameType: typeof Windows$Networking$Vpn$VpnDomainNameType,
VpnIPProtocol: typeof Windows$Networking$Vpn$VpnIPProtocol,
VpnManagementErrorStatus: typeof Windows$Networking$Vpn$VpnManagementErrorStatus,
VpnNativeProtocolType: typeof Windows$Networking$Vpn$VpnNativeProtocolType,
VpnPacketBufferStatus: typeof Windows$Networking$Vpn$VpnPacketBufferStatus,
VpnRoutingPolicyType: typeof Windows$Networking$Vpn$VpnRoutingPolicyType,
        
        
      }

/**
 * Specifies the type of AppId understood by the VPN platform.
 */

declare  var Windows$Networking$Vpn$VpnAppIdType: {|
  +packageFamilyName: 0,// 0
+fullyQualifiedBinaryName: 1,// 1
+filePath: 2,// 2

|};



/**
 * Specifies the type of authentication methods allowed by the operating system native VPN protocols.
 */

declare  var Windows$Networking$Vpn$VpnAuthenticationMethod: {|
  +mschapv2: 0,// 0
+eap: 1,// 1
+certificate: 2,// 2
+presharedKey: 3,// 3

|};



/**
 * Specifies the type of activity events.
 */

declare  var Windows$Networking$Vpn$VpnChannelActivityEventType: {|
  +idle: 0,// 0
+active: 1,// 1

|};



/**
 * Specifies the values defining whether a requested credential is a retry case, or should be used for single sign on.
 */

declare  var Windows$Networking$Vpn$VpnChannelRequestCredentialsOptions: {|
  +none: 0,// 0
+retrying: 1,// 1
+useForSingleSignIn: 2,// 2

|};



/**
 * Specifies the types of credentials that can be requested by the VPN platform.
 */

declare  var Windows$Networking$Vpn$VpnCredentialType: {|
  +usernamePassword: 0,// 0
+usernameOtpPin: 1,// 1
+usernamePasswordAndPin: 2,// 2
+usernamePasswordChange: 3,// 3
+smartCard: 4,// 4
+protectedCertificate: 5,// 5
+unProtectedCertificate: 6,// 6

|};



/**
 * VpnDataPathType is not supported and may be altered or unavailable in the future.
 */

declare  var Windows$Networking$Vpn$VpnDataPathType: {|
  +send: 0,// 0
+receive: 1,// 1

|};



/**
 * Describes whether a name is a domain name suffix or a fully qualified domain name.
 */

declare  var Windows$Networking$Vpn$VpnDomainNameType: {|
  +suffix: 0,// 0
+fullyQualified: 1,// 1
+reserved: 2,// 2

|};



/**
 * Specifies the IP protocols (numeric values).
 */

declare  var Windows$Networking$Vpn$VpnIPProtocol: {|
  +none: 0,// 0
+tcp: 1,// 1
+udp: 2,// 2
+icmp: 3,// 3
+ipv6Icmp: 4,// 4
+igmp: 5,// 5
+pgm: 6,// 6

|};



/**
 * Describes the known VPN management errors.
 */

declare  var Windows$Networking$Vpn$VpnManagementErrorStatus: {|
  +ok: 0,// 0
+other: 1,// 1
+invalidXmlSyntax: 2,// 2
+profileNameTooLong: 3,// 3
+profileInvalidAppId: 4,// 4
+accessDenied: 5,// 5

|};



/**
 * Specifies the native protocol types.
 */

declare  var Windows$Networking$Vpn$VpnNativeProtocolType: {|
  +pptp: 0,// 0
+l2tp: 1,// 1
+ipsecIkev2: 2,// 2

|};



/**
 * Describes the possible states of the VPN packet buffer.
 */

declare  var Windows$Networking$Vpn$VpnPacketBufferStatus: {|
  +ok: 0,// 0
+invalidBufferSize: 1,// 1

|};



/**
 * Specifies the routing policy type.
 */

declare  var Windows$Networking$Vpn$VpnRoutingPolicyType: {|
  +splitRouting: 0,// 0
+forceAllTrafficOverVpn: 1,// 1

|};



      declare var npm$namespace$Windows$Networking$XboxLive: {
        
        
        XboxLiveEndpointPairCreationBehaviors: typeof Windows$Networking$XboxLive$XboxLiveEndpointPairCreationBehaviors,
XboxLiveEndpointPairCreationStatus: typeof Windows$Networking$XboxLive$XboxLiveEndpointPairCreationStatus,
XboxLiveEndpointPairState: typeof Windows$Networking$XboxLive$XboxLiveEndpointPairState,
XboxLiveNetworkAccessKind: typeof Windows$Networking$XboxLive$XboxLiveNetworkAccessKind,
XboxLiveQualityOfServiceMeasurementStatus: typeof Windows$Networking$XboxLive$XboxLiveQualityOfServiceMeasurementStatus,
XboxLiveQualityOfServiceMetric: typeof Windows$Networking$XboxLive$XboxLiveQualityOfServiceMetric,
XboxLiveSocketKind: typeof Windows$Networking$XboxLive$XboxLiveSocketKind,
        XboxLiveDeviceAddress: typeof Windows$Networking$XboxLive$XboxLiveDeviceAddress,
XboxLiveEndpointPair: typeof Windows$Networking$XboxLive$XboxLiveEndpointPair,
XboxLiveEndpointPairCreationResult: typeof Windows$Networking$XboxLive$XboxLiveEndpointPairCreationResult,
XboxLiveEndpointPairStateChangedEventArgs: typeof Windows$Networking$XboxLive$XboxLiveEndpointPairStateChangedEventArgs,
XboxLiveEndpointPairTemplate: typeof Windows$Networking$XboxLive$XboxLiveEndpointPairTemplate,
XboxLiveInboundEndpointPairCreatedEventArgs: typeof Windows$Networking$XboxLive$XboxLiveInboundEndpointPairCreatedEventArgs,
XboxLiveQualityOfServiceMeasurement: typeof Windows$Networking$XboxLive$XboxLiveQualityOfServiceMeasurement,
XboxLiveQualityOfServiceMetricResult: typeof Windows$Networking$XboxLive$XboxLiveQualityOfServiceMetricResult,
XboxLiveQualityOfServicePrivatePayloadResult: typeof Windows$Networking$XboxLive$XboxLiveQualityOfServicePrivatePayloadResult,
        
      }

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Networking$XboxLive$XboxLiveDeviceAddress  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param base64 This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static createFromSnapshotBase64(base64: string): Windows$Networking$XboxLive$XboxLiveDeviceAddress;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param buffer This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static createFromSnapshotBuffer(
buffer: Windows$Storage$Streams$IBuffer): Windows$Networking$XboxLive$XboxLiveDeviceAddress;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param buffer This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static createFromSnapshotBytes(buffer: number[]): Windows$Networking$XboxLive$XboxLiveDeviceAddress;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static getLocal(): Windows$Networking$XboxLive$XboxLiveDeviceAddress;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static maxSnapshotBytesSize: number;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param otherDeviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
compare(otherDeviceAddress: Windows$Networking$XboxLive$XboxLiveDeviceAddress): number;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getSnapshotAsBase64(): string;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getSnapshotAsBuffer(): Windows$Storage$Streams$IBuffer;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getSnapshotAsBytes(): {
buffer: number[],
bytesWritten: number
};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
isLocal: boolean;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
isValid: boolean;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
networkAccessKind: $Values<typeof Windows$Networking$XboxLive$XboxLiveNetworkAccessKind>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
onsnapshotchanged: Windows$Foundation$TypedEventHandler<Windows$Networking$XboxLive$XboxLiveDeviceAddress, any>;
addEventListener(
type: "snapshotchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$XboxLive$XboxLiveDeviceAddress, any>): void;
removeEventListener(
type: "snapshotchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$XboxLive$XboxLiveDeviceAddress, any>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Networking$XboxLive$XboxLiveEndpointPair  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param localHostName This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param localPort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param remoteHostName This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param remotePort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static findEndpointPairByHostNamesAndPorts(
localHostName: Windows$Networking$HostName,
localPort: string,
remoteHostName: Windows$Networking$HostName,
remotePort: string): Windows$Networking$XboxLive$XboxLiveEndpointPair;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param localSocketAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param remoteSocketAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static findEndpointPairBySocketAddressBytes(
localSocketAddress: number[],
remoteSocketAddress: number[]): Windows$Networking$XboxLive$XboxLiveEndpointPair;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
deleteAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getLocalSocketAddressBytes(): number[];

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getRemoteSocketAddressBytes(): number[];

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
localHostName: Windows$Networking$HostName;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
localPort: string;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
onstatechanged: Windows$Foundation$TypedEventHandler<Windows$Networking$XboxLive$XboxLiveEndpointPair, Windows$Networking$XboxLive$XboxLiveEndpointPairStateChangedEventArgs>;
addEventListener(
type: "statechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$XboxLive$XboxLiveEndpointPair, Windows$Networking$XboxLive$XboxLiveEndpointPairStateChangedEventArgs>): void;
removeEventListener(
type: "statechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$XboxLive$XboxLiveEndpointPair, Windows$Networking$XboxLive$XboxLiveEndpointPairStateChangedEventArgs>): void;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
remoteDeviceAddress: Windows$Networking$XboxLive$XboxLiveDeviceAddress;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
remoteHostName: Windows$Networking$HostName;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
remotePort: string;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
state: $Values<typeof Windows$Networking$XboxLive$XboxLiveEndpointPairState>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
template: Windows$Networking$XboxLive$XboxLiveEndpointPairTemplate;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */

declare  var Windows$Networking$XboxLive$XboxLiveEndpointPairCreationBehaviors: {|
  +none: 0,// 0
+reevaluatePath: 1,// 1

|};



/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Networking$XboxLive$XboxLiveEndpointPairCreationResult  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
deviceAddress: Windows$Networking$XboxLive$XboxLiveDeviceAddress;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
endpointPair: Windows$Networking$XboxLive$XboxLiveEndpointPair;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
isExistingPathEvaluation: boolean;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
status: $Values<typeof Windows$Networking$XboxLive$XboxLiveEndpointPairCreationStatus>
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */

declare  var Windows$Networking$XboxLive$XboxLiveEndpointPairCreationStatus: {|
  +succeeded: 0,// 0
+noLocalNetworks: 1,// 1
+noCompatibleNetworkPaths: 2,// 2
+localSystemNotAuthorized: 3,// 3
+canceled: 4,// 4
+timedOut: 5,// 5
+remoteSystemNotAuthorized: 6,// 6
+refusedDueToConfiguration: 7,// 7
+unexpectedInternalError: 8,// 8

|};



/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */

declare  var Windows$Networking$XboxLive$XboxLiveEndpointPairState: {|
  +invalid: 0,// 0
+creatingOutbound: 1,// 1
+creatingInbound: 2,// 2
+ready: 3,// 3
+deletingLocally: 4,// 4
+remoteEndpointTerminating: 5,// 5
+deleted: 6,// 6

|};



/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Networking$XboxLive$XboxLiveEndpointPairStateChangedEventArgs  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
newState: $Values<typeof Windows$Networking$XboxLive$XboxLiveEndpointPairState>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
oldState: $Values<typeof Windows$Networking$XboxLive$XboxLiveEndpointPairState>
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Networking$XboxLive$XboxLiveEndpointPairTemplate  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param name This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static getTemplateByName(name: string): Windows$Networking$XboxLive$XboxLiveEndpointPairTemplate;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static templates: Windows$Foundation$Collections$IVectorView<Windows$Networking$XboxLive$XboxLiveEndpointPairTemplate>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
acceptorBoundPortRangeLower: number;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
acceptorBoundPortRangeUpper: number;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param behaviors This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
createEndpointPairAsync(
deviceAddress: Windows$Networking$XboxLive$XboxLiveDeviceAddress,
behaviors: $Values<typeof Windows$Networking$XboxLive$XboxLiveEndpointPairCreationBehaviors>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$XboxLive$XboxLiveEndpointPairCreationResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
createEndpointPairAsync(
deviceAddress: Windows$Networking$XboxLive$XboxLiveDeviceAddress): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$XboxLive$XboxLiveEndpointPairCreationResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param initiatorPort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param acceptorPort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
createEndpointPairForPortsAsync(
deviceAddress: Windows$Networking$XboxLive$XboxLiveDeviceAddress,
initiatorPort: string,
acceptorPort: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$XboxLive$XboxLiveEndpointPairCreationResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param initiatorPort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param acceptorPort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param behaviors This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
createEndpointPairForPortsAsync(
deviceAddress: Windows$Networking$XboxLive$XboxLiveDeviceAddress,
initiatorPort: string,
acceptorPort: string,
behaviors: $Values<typeof Windows$Networking$XboxLive$XboxLiveEndpointPairCreationBehaviors>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Networking$XboxLive$XboxLiveEndpointPairCreationResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
endpointPairs: Windows$Foundation$Collections$IVectorView<Windows$Networking$XboxLive$XboxLiveEndpointPair>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
initiatorBoundPortRangeLower: number;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
initiatorBoundPortRangeUpper: number;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
name: string;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
oninboundendpointpaircreated: Windows$Foundation$TypedEventHandler<Windows$Networking$XboxLive$XboxLiveEndpointPairTemplate, Windows$Networking$XboxLive$XboxLiveInboundEndpointPairCreatedEventArgs>;
addEventListener(
type: "inboundendpointpaircreated",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$XboxLive$XboxLiveEndpointPairTemplate, Windows$Networking$XboxLive$XboxLiveInboundEndpointPairCreatedEventArgs>): void;
removeEventListener(
type: "inboundendpointpaircreated",
listener: Windows$Foundation$TypedEventHandler<Windows$Networking$XboxLive$XboxLiveEndpointPairTemplate, Windows$Networking$XboxLive$XboxLiveInboundEndpointPairCreatedEventArgs>): void;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
socketKind: $Values<typeof Windows$Networking$XboxLive$XboxLiveSocketKind>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Networking$XboxLive$XboxLiveInboundEndpointPairCreatedEventArgs  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
endpointPair: Windows$Networking$XboxLive$XboxLiveEndpointPair
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */

declare  var Windows$Networking$XboxLive$XboxLiveNetworkAccessKind: {|
  +open: 0,// 0
+moderate: 1,// 1
+strict: 2,// 2

|};



/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Networking$XboxLive$XboxLiveQualityOfServiceMeasurement  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static clearPrivatePayload(): void;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static isSystemInboundBandwidthConstrained: boolean;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static isSystemOutboundBandwidthConstrained: boolean;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static maxPrivatePayloadSize: number;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static maxSimultaneousProbeConnections: number;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param payload This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static publishPrivatePayloadBytes(payload: number[]): void;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static publishedPrivatePayload: Windows$Storage$Streams$IBuffer;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
constructor(): this;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
deviceAddresses: Windows$Foundation$Collections$IVector<Windows$Networking$XboxLive$XboxLiveDeviceAddress>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param metric This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getMetricResult(
deviceAddress: Windows$Networking$XboxLive$XboxLiveDeviceAddress,
metric: $Values<typeof Windows$Networking$XboxLive$XboxLiveQualityOfServiceMetric>): Windows$Networking$XboxLive$XboxLiveQualityOfServiceMetricResult;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getMetricResultsForDevice(
deviceAddress: Windows$Networking$XboxLive$XboxLiveDeviceAddress): Windows$Foundation$Collections$IVectorView<Windows$Networking$XboxLive$XboxLiveQualityOfServiceMetricResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param metric This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getMetricResultsForMetric(
metric: $Values<typeof Windows$Networking$XboxLive$XboxLiveQualityOfServiceMetric>): Windows$Foundation$Collections$IVectorView<Windows$Networking$XboxLive$XboxLiveQualityOfServiceMetricResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getPrivatePayloadResult(
deviceAddress: Windows$Networking$XboxLive$XboxLiveDeviceAddress): Windows$Networking$XboxLive$XboxLiveQualityOfServicePrivatePayloadResult;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
measureAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
metricResults: Windows$Foundation$Collections$IVectorView<Windows$Networking$XboxLive$XboxLiveQualityOfServiceMetricResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
metrics: Windows$Foundation$Collections$IVector<$Values<typeof Windows$Networking$XboxLive$XboxLiveQualityOfServiceMetric>>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
numberOfProbesToAttempt: number;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
numberOfResultsPending: number;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
privatePayloadResults: Windows$Foundation$Collections$IVectorView<Windows$Networking$XboxLive$XboxLiveQualityOfServicePrivatePayloadResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
shouldRequestPrivatePayloads: boolean;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
timeoutInMilliseconds: number
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */

declare  var Windows$Networking$XboxLive$XboxLiveQualityOfServiceMeasurementStatus: {|
  +notStarted: 0,// 0
+inProgress: 1,// 1
+inProgressWithProvisionalResults: 2,// 2
+succeeded: 3,// 3
+noLocalNetworks: 4,// 4
+noCompatibleNetworkPaths: 5,// 5
+localSystemNotAuthorized: 6,// 6
+canceled: 7,// 7
+timedOut: 8,// 8
+remoteSystemNotAuthorized: 9,// 9
+refusedDueToConfiguration: 10,// 10
+unexpectedInternalError: 11,// 11

|};



/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */

declare  var Windows$Networking$XboxLive$XboxLiveQualityOfServiceMetric: {|
  +averageLatencyInMilliseconds: 0,// 0
+minLatencyInMilliseconds: 1,// 1
+maxLatencyInMilliseconds: 2,// 2
+averageOutboundBitsPerSecond: 3,// 3
+minOutboundBitsPerSecond: 4,// 4
+maxOutboundBitsPerSecond: 5,// 5
+averageInboundBitsPerSecond: 6,// 6
+minInboundBitsPerSecond: 7,// 7
+maxInboundBitsPerSecond: 8,// 8

|};



/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Networking$XboxLive$XboxLiveQualityOfServiceMetricResult  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
deviceAddress: Windows$Networking$XboxLive$XboxLiveDeviceAddress;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
metric: $Values<typeof Windows$Networking$XboxLive$XboxLiveQualityOfServiceMetric>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
status: $Values<typeof Windows$Networking$XboxLive$XboxLiveQualityOfServiceMeasurementStatus>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
value: number
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Networking$XboxLive$XboxLiveQualityOfServicePrivatePayloadResult  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
deviceAddress: Windows$Networking$XboxLive$XboxLiveDeviceAddress;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
status: $Values<typeof Windows$Networking$XboxLive$XboxLiveQualityOfServiceMeasurementStatus>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
value: Windows$Storage$Streams$IBuffer
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */

declare  var Windows$Networking$XboxLive$XboxLiveSocketKind: {|
  +none: 0,// 0
+datagram: 1,// 1
+stream: 2,// 2

|};



      declare var npm$namespace$Windows$ApplicationModel: {
        
        
        
        AppDisplayInfo: typeof Windows$ApplicationModel$AppDisplayInfo,
AppInfo: typeof Windows$ApplicationModel$AppInfo,
DesignMode: typeof Windows$ApplicationModel$DesignMode,
Package: typeof Windows$ApplicationModel$Package,
PackageId: typeof Windows$ApplicationModel$PackageId,
PackageStatus: typeof Windows$ApplicationModel$PackageStatus,
SuspendingDeferral: typeof Windows$ApplicationModel$SuspendingDeferral,
SuspendingEventArgs: typeof Windows$ApplicationModel$SuspendingEventArgs,
SuspendingOperation: typeof Windows$ApplicationModel$SuspendingOperation,
        Activation: typeof npm$namespace$Windows$ApplicationModel$Activation,
AppService: typeof npm$namespace$Windows$ApplicationModel$AppService,
Appointments: typeof npm$namespace$Windows$ApplicationModel$Appointments,
Background: typeof npm$namespace$Windows$ApplicationModel$Background,
Calls: typeof npm$namespace$Windows$ApplicationModel$Calls,
Chat: typeof npm$namespace$Windows$ApplicationModel$Chat,
Contacts: typeof npm$namespace$Windows$ApplicationModel$Contacts,
Core: typeof npm$namespace$Windows$ApplicationModel$Core,
DataTransfer: typeof npm$namespace$Windows$ApplicationModel$DataTransfer,
Email: typeof npm$namespace$Windows$ApplicationModel$Email,
ExtendedExecution: typeof npm$namespace$Windows$ApplicationModel$ExtendedExecution,
LockScreen: typeof npm$namespace$Windows$ApplicationModel$LockScreen,
Resources: typeof npm$namespace$Windows$ApplicationModel$Resources,
Search: typeof npm$namespace$Windows$ApplicationModel$Search,
Store: typeof npm$namespace$Windows$ApplicationModel$Store,
UserDataAccounts: typeof npm$namespace$Windows$ApplicationModel$UserDataAccounts,
VoiceCommands: typeof npm$namespace$Windows$ApplicationModel$VoiceCommands,
Wallet: typeof npm$namespace$Windows$ApplicationModel$Wallet,
      }

      declare var npm$namespace$Windows$ApplicationModel$Activation: {
        
        
        ActivationKind: typeof Windows$ApplicationModel$Activation$ActivationKind,
ApplicationExecutionState: typeof Windows$ApplicationModel$Activation$ApplicationExecutionState,
        AppointmentsProviderAddAppointmentActivatedEventArgs: typeof Windows$ApplicationModel$Activation$AppointmentsProviderAddAppointmentActivatedEventArgs,
AppointmentsProviderRemoveAppointmentActivatedEventArgs: typeof Windows$ApplicationModel$Activation$AppointmentsProviderRemoveAppointmentActivatedEventArgs,
AppointmentsProviderReplaceAppointmentActivatedEventArgs: typeof Windows$ApplicationModel$Activation$AppointmentsProviderReplaceAppointmentActivatedEventArgs,
AppointmentsProviderShowAppointmentDetailsActivatedEventArgs: typeof Windows$ApplicationModel$Activation$AppointmentsProviderShowAppointmentDetailsActivatedEventArgs,
AppointmentsProviderShowTimeFrameActivatedEventArgs: typeof Windows$ApplicationModel$Activation$AppointmentsProviderShowTimeFrameActivatedEventArgs,
CachedFileUpdaterActivatedEventArgs: typeof Windows$ApplicationModel$Activation$CachedFileUpdaterActivatedEventArgs,
CameraSettingsActivatedEventArgs: typeof Windows$ApplicationModel$Activation$CameraSettingsActivatedEventArgs,
ContactCallActivatedEventArgs: typeof Windows$ApplicationModel$Activation$ContactCallActivatedEventArgs,
ContactMapActivatedEventArgs: typeof Windows$ApplicationModel$Activation$ContactMapActivatedEventArgs,
ContactMessageActivatedEventArgs: typeof Windows$ApplicationModel$Activation$ContactMessageActivatedEventArgs,
ContactPickerActivatedEventArgs: typeof Windows$ApplicationModel$Activation$ContactPickerActivatedEventArgs,
ContactPostActivatedEventArgs: typeof Windows$ApplicationModel$Activation$ContactPostActivatedEventArgs,
ContactVideoCallActivatedEventArgs: typeof Windows$ApplicationModel$Activation$ContactVideoCallActivatedEventArgs,
DeviceActivatedEventArgs: typeof Windows$ApplicationModel$Activation$DeviceActivatedEventArgs,
DevicePairingActivatedEventArgs: typeof Windows$ApplicationModel$Activation$DevicePairingActivatedEventArgs,
DialReceiverActivatedEventArgs: typeof Windows$ApplicationModel$Activation$DialReceiverActivatedEventArgs,
FileActivatedEventArgs: typeof Windows$ApplicationModel$Activation$FileActivatedEventArgs,
FileOpenPickerActivatedEventArgs: typeof Windows$ApplicationModel$Activation$FileOpenPickerActivatedEventArgs,
FileOpenPickerContinuationEventArgs: typeof Windows$ApplicationModel$Activation$FileOpenPickerContinuationEventArgs,
FileSavePickerActivatedEventArgs: typeof Windows$ApplicationModel$Activation$FileSavePickerActivatedEventArgs,
FileSavePickerContinuationEventArgs: typeof Windows$ApplicationModel$Activation$FileSavePickerContinuationEventArgs,
FolderPickerContinuationEventArgs: typeof Windows$ApplicationModel$Activation$FolderPickerContinuationEventArgs,
LaunchActivatedEventArgs: typeof Windows$ApplicationModel$Activation$LaunchActivatedEventArgs,
LockScreenActivatedEventArgs: typeof Windows$ApplicationModel$Activation$LockScreenActivatedEventArgs,
LockScreenCallActivatedEventArgs: typeof Windows$ApplicationModel$Activation$LockScreenCallActivatedEventArgs,
PickerReturnedActivatedEventArgs: typeof Windows$ApplicationModel$Activation$PickerReturnedActivatedEventArgs,
Print3DWorkflowActivatedEventArgs: typeof Windows$ApplicationModel$Activation$Print3DWorkflowActivatedEventArgs,
PrintTaskSettingsActivatedEventArgs: typeof Windows$ApplicationModel$Activation$PrintTaskSettingsActivatedEventArgs,
ProtocolActivatedEventArgs: typeof Windows$ApplicationModel$Activation$ProtocolActivatedEventArgs,
ProtocolForResultsActivatedEventArgs: typeof Windows$ApplicationModel$Activation$ProtocolForResultsActivatedEventArgs,
RestrictedLaunchActivatedEventArgs: typeof Windows$ApplicationModel$Activation$RestrictedLaunchActivatedEventArgs,
SearchActivatedEventArgs: typeof Windows$ApplicationModel$Activation$SearchActivatedEventArgs,
ShareTargetActivatedEventArgs: typeof Windows$ApplicationModel$Activation$ShareTargetActivatedEventArgs,
SplashScreen: typeof Windows$ApplicationModel$Activation$SplashScreen,
ToastNotificationActivatedEventArgs: typeof Windows$ApplicationModel$Activation$ToastNotificationActivatedEventArgs,
VoiceCommandActivatedEventArgs: typeof Windows$ApplicationModel$Activation$VoiceCommandActivatedEventArgs,
WalletActionActivatedEventArgs: typeof Windows$ApplicationModel$Activation$WalletActionActivatedEventArgs,
WebAccountProviderActivatedEventArgs: typeof Windows$ApplicationModel$Activation$WebAccountProviderActivatedEventArgs,
WebAuthenticationBrokerContinuationEventArgs: typeof Windows$ApplicationModel$Activation$WebAuthenticationBrokerContinuationEventArgs,
        
      }

/**
 * Specifies the type of activation.
 */

declare  var Windows$ApplicationModel$Activation$ActivationKind: {|
  +launch: 0,// 0
+search: 1,// 1
+shareTarget: 2,// 2
+file: 3,// 3
+protocol: 4,// 4
+fileOpenPicker: 5,// 5
+fileSavePicker: 6,// 6
+cachedFileUpdater: 7,// 7
+contactPicker: 8,// 8
+device: 9,// 9
+printTaskSettings: 10,// 10
+cameraSettings: 11,// 11
+restrictedLaunch: 12,// 12
+appointmentsProvider: 13,// 13
+contact: 14,// 14
+lockScreenCall: 15,// 15
+voiceCommand: 16,// 16
+lockScreen: 17,// 17
+pickerReturned: 18,// 18
+walletAction: 19,// 19
+pickFileContinuation: 20,// 20
+pickSaveFileContinuation: 21,// 21
+pickFolderContinuation: 22,// 22
+webAuthenticationBrokerContinuation: 23,// 23
+webAccountProvider: 24,// 24
+componentUI: 25,// 25
+protocolForResults: 26,// 26
+toastNotification: 27,// 27
+print3DWorkflow: 28,// 28
+dialReceiver: 29,// 29
+devicePairing: 30,// 30

|};



/**
 * Specifies the execution state of the app.
 */

declare  var Windows$ApplicationModel$Activation$ApplicationExecutionState: {|
  +notRunning: 0,// 0
+running: 1,// 1
+suspended: 2,// 2
+terminated: 3,// 3
+closedByUser: 4,// 4

|};



/**
 * Provides data when an app is activated to add an appointment to the users calendar.
 */
declare class Windows$ApplicationModel$Activation$AppointmentsProviderAddAppointmentActivatedEventArgs  {

/**
 * Gets the appointment that is provided to the app when the user tries to add it.
 */
addAppointmentOperation: Windows$ApplicationModel$Appointments$AppointmentsProvider$AddAppointmentOperation;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed by the appointments provider.
 */
verb: string
}


/**
 * Provides data when an app is activated to remove an appointment from the users calendar.
 */
declare class Windows$ApplicationModel$Activation$AppointmentsProviderRemoveAppointmentActivatedEventArgs  {

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the appointment that is provided to the app when the user tries to remove it.
 */
removeAppointmentOperation: Windows$ApplicationModel$Appointments$AppointmentsProvider$RemoveAppointmentOperation;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed by the appointments provider.
 */
verb: string
}


/**
 * Provides data when an app is activated to replace an appointment in the users calendar.
 */
declare class Windows$ApplicationModel$Activation$AppointmentsProviderReplaceAppointmentActivatedEventArgs  {

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the appointment that is provided to the app when the user tries to replace it.
 */
replaceAppointmentOperation: Windows$ApplicationModel$Appointments$AppointmentsProvider$ReplaceAppointmentOperation;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed by the appointments provider.
 */
verb: string
}


/**
 * Provides data when an app is activated to show the details of an appointment.
 */
declare class Windows$ApplicationModel$Activation$AppointmentsProviderShowAppointmentDetailsActivatedEventArgs  {

/**
 * Gets the start date of the appointment instance for which the app should display details.
 */
instanceStartDate: Date;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the local identifier of the appointment for which the app should display details.
 */
localId: string;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the roaming identifier of the appointment for which the app should display details.
 */
roamingId: string;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed by the appointments provider.
 */
verb: string
}


/**
 * Provides data when an app is activated to show a specified time frame on the users calendar.
 */
declare class Windows$ApplicationModel$Activation$AppointmentsProviderShowTimeFrameActivatedEventArgs  {

/**
 * Gets the duration of the time frame to be shown.
 */
duration: number;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the starting date and time of the time frame to be shown.
 */
timeToShow: Date;

/**
 * Gets the action to be performed by the appointments provider.
 */
verb: string
}


/**
 * Provides information about the activated event that fires when the user saves or opens a file that needs updates from the app.
 */
declare class Windows$ApplicationModel$Activation$CachedFileUpdaterActivatedEventArgs  {

/**
 * Gets the letterbox UI of the file picker that is displayed when a file needs updates from the app.
 */
cachedFileUpdaterUI: Windows$Storage$Provider$CachedFileUpdaterUI;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Enables a camera settings app to handle the activation parameters for the app.
 */
declare class Windows$ApplicationModel$Activation$CameraSettingsActivatedEventArgs  {

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the object that controls device settings on the camera.
 */
videoDeviceController: any;

/**
 * Gets the object that implements additional extended settings for the camera.
 */
videoDeviceExtension: any
}


/**
 * Provides data when an app is activated to call a contact.
 */
declare class Windows$ApplicationModel$Activation$ContactCallActivatedEventArgs  {

/**
 * Gets the contact for the call.
 */
contact: Windows$ApplicationModel$Contacts$Contact;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the identifier of the service used for the call.
 */
serviceId: string;

/**
 * Gets the user identifier of the service used for the call.
 */
serviceUserId: string;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed.
 */
verb: string
}


/**
 * Provides data when an app is activated to map a contact.
 */
declare class Windows$ApplicationModel$Activation$ContactMapActivatedEventArgs  {

/**
 * Gets the address of a contact for the mapping operation.
 */
address: Windows$ApplicationModel$Contacts$ContactAddress;

/**
 * Gets the contact for the mapping operation.
 */
contact: Windows$ApplicationModel$Contacts$Contact;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed.
 */
verb: string
}


/**
 * Provides data when an app is activated to send a message to a contact.
 */
declare class Windows$ApplicationModel$Activation$ContactMessageActivatedEventArgs  {

/**
 * Gets the contact for the message.
 */
contact: Windows$ApplicationModel$Contacts$Contact;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the identifier of the service used for the message.
 */
serviceId: string;

/**
 * Gets the user identifier of the service used for the message.
 */
serviceUserId: string;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed.
 */
verb: string
}


/**
 * Provides data when an app is activated because it uses the Contact Picker.
 */
declare class Windows$ApplicationModel$Activation$ContactPickerActivatedEventArgs  {

/**
 * Gets the letterbox UI of the contact picker that is displayed when the user wants to pick contacts that are provided by the app.
 */
contactPickerUI: Windows$ApplicationModel$Contacts$Provider$ContactPickerUI;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides data when an app is activated to post a contact.
 */
declare class Windows$ApplicationModel$Activation$ContactPostActivatedEventArgs  {

/**
 * Gets the contact for the post.
 */
contact: Windows$ApplicationModel$Contacts$Contact;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the identifier of the service used for the post.
 */
serviceId: string;

/**
 * Gets the user identifier of the service used for the post.
 */
serviceUserId: string;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed.
 */
verb: string
}


/**
 * Provides data when an app is activated to video call a contact.
 */
declare class Windows$ApplicationModel$Activation$ContactVideoCallActivatedEventArgs  {

/**
 * Gets the contact for the video call.
 */
contact: Windows$ApplicationModel$Contacts$Contact;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the identifier of the service used for the video call.
 */
serviceId: string;

/**
 * Gets the user identifier of the service used for the video call.
 */
serviceUserId: string;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed.
 */
verb: string
}


/**
 * Provides information for a device that invokes AutoPlay.
 */
declare class Windows$ApplicationModel$Activation$DeviceActivatedEventArgs  {

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Gets the device identifier for the device that invoked AutoPlay.
 */
deviceInformationId: string;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action associated with the activated device.
 */
verb: string;

/**
 * Gets the view switcher object that allows you to set the view for the application.
 */
viewSwitcher: Windows$UI$ViewManagement$ActivationViewSwitcher
}

declare class Windows$ApplicationModel$Activation$DevicePairingActivatedEventArgs  {
deviceInformation: any;
kind: any;
previousExecutionState: any;
splashScreen: any
}


/**
 * Provides data when an app is activated from another app by using the DIAL protocol.
 */
declare class Windows$ApplicationModel$Activation$DialReceiverActivatedEventArgs  {

/**
 * Gets the name of the app that invoked the dial receiver app.
 */
appName: string;

/**
 * Gets the arguments passed by the calling app.
 */
arguments: string;

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the unique tile identifier for the calling app.
 */
tileId: string;

/**
 * Gets the view switcher object that allows you to set the view for the application.
 */
viewSwitcher: Windows$UI$ViewManagement$ActivationViewSwitcher
}


/**
 * Provides data when an app is activated because it is the app associated with a file.
 */
declare class Windows$ApplicationModel$Activation$FileActivatedEventArgs  {

/**
 * The package family name of the app that launched your app.
 */
callerPackageFamilyName: string;

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Gets the files for which the app was activated.
 */
files: Windows$Foundation$Collections$IVectorView<Windows$Storage$IStorageItem>;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the neighboring files of the files for which the app was activated.
 */
neighboringFilesQuery: Windows$Storage$Search$StorageFileQueryResult;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action associated with the activated file.
 */
verb: string;

/**
 * Provides the object that allows you to set the view for the application.
 */
viewSwitcher: Windows$UI$ViewManagement$ActivationViewSwitcher
}


/**
 * Provides information about an activated event that fires when the user tries to pick files or folders that are provided by the app.
 */
declare class Windows$ApplicationModel$Activation$FileOpenPickerActivatedEventArgs  {

/**
 * The package family name of the app that launched your app.
 */
callerPackageFamilyName: string;

/**
 * Gets the letterbox UI of the file picker that is displayed when the user wants to pick files or folders that are provided by the app.
 */
fileOpenPickerUI: Windows$Storage$Pickers$Provider$FileOpenPickerUI;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information about an activated event that fires after the app was suspended for a file open picker operation.
 */
declare class Windows$ApplicationModel$Activation$FileOpenPickerContinuationEventArgs  {

/**
 * Gets a set of values populated by the app before a FileOpenPicker operation that deactivates the app in order to provide context when the app is activated.
 */
continuationData: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the list of files selected by the user during the file open picker operation.
 */
files: Windows$Foundation$Collections$IVectorView<Windows$Storage$StorageFile>;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information about an activated event that fires when the user saves a file through the file picker and selects the app as the location.
 */
declare class Windows$ApplicationModel$Activation$FileSavePickerActivatedEventArgs  {

/**
 * The package family name of the app that launched this app.
 */
callerPackageFamilyName: string;

/**
 * Gets the ID of the enterprise that owns the file.
 */
enterpriseId: string;

/**
 * Gets the letterbox UI of the file picker that is displayed when the user saves a file and selects the app as the save location.
 */
fileSavePickerUI: Windows$Storage$Pickers$Provider$FileSavePickerUI;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information about an activated event that fires after the app was suspended for a file save picker operation.
 */
declare class Windows$ApplicationModel$Activation$FileSavePickerContinuationEventArgs  {

/**
 * Gets a set of values populated by the app before a FileSavePicker operation that deactivates the app in order to provide context when the app is activated.
 */
continuationData: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the file selected by the user during the file save picker operation.
 */
file: Windows$Storage$StorageFile;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information about an activated event that fires after the app was suspended for a folder picker operation.
 */
declare class Windows$ApplicationModel$Activation$FolderPickerContinuationEventArgs  {

/**
 * Gets a set of values populated by the app before a FolderPicker operation that deactivates the app in order to provide context when the app is activated.
 */
continuationData: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the folder selected by the user during the folder picker operation.
 */
folder: Windows$Storage$StorageFolder;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides event information when an app is launched.
 */
declare class Windows$ApplicationModel$Activation$LaunchActivatedEventArgs  {

/**
 * Gets the arguments that are passed to the app during its launch activation.
 */
arguments: string;

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Gets the reason that this app is being activated.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Indicates whether the app was pre-launched.
 */
prelaunchActivated: boolean;

/**
 * Gets the execution state of the app before this activation.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the ID of the tile that was invoked to launch the app.
 */
tileId: string;

/**
 * Gets the view switcher object that allows you to set the view for the application.
 */
viewSwitcher: Windows$UI$ViewManagement$ActivationViewSwitcher
}


/**
 * Provides information about an event that occurs when the app is activated as the lock screen.
 */
declare class Windows$ApplicationModel$Activation$LockScreenActivatedEventArgs  {

/**
 * Gets an object that allows an app that is activated as the lock screen to get the same data that the default lock screen can access, and to register for updates to that data.
 */
info: any;

/**
 * Gets the reason for the activation of the app for this event.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before the app was activated as the lock screen.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides event information when communication to and from the lock screen is required.
 */
declare class Windows$ApplicationModel$Activation$LockScreenCallActivatedEventArgs  {

/**
 * Gets the arguments that are passed to the app to launch it.
 */
arguments: string;

/**
 * Gets the UI that handles communication to and from the lock screen.
 */
callUI: Windows$ApplicationModel$Calls$LockScreenCallUI;

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the identifier of the source that launched the app.
 */
tileId: string;

/**
 * Gets the view switcher object that allows you to set the view for the application.
 */
viewSwitcher: Windows$UI$ViewManagement$ActivationViewSwitcher
}


/**
 * Provides data for the Activated event when it occurs after a picker returns.
 */
declare class Windows$ApplicationModel$Activation$PickerReturnedActivatedEventArgs  {

/**
 * Gets the reason that this app is being activated.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets an identifier indicating the picker operation that was performed prior to the activation.
 */
pickerOperationId: string;

/**
 * Gets the execution state of the app before this activation.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information about an event that occurs when the app is launched as a 3D printing workflow.
 */
declare class Windows$ApplicationModel$Activation$Print3DWorkflowActivatedEventArgs  {

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets a customized printing experience for a 3D printer.
 */
workflow: Windows$Devices$Printers$Extensions$Print3DWorkflow
}


/**
 * Provides information in response to the event that is raised when print task settings are activated.
 */
declare class Windows$ApplicationModel$Activation$PrintTaskSettingsActivatedEventArgs  {

/**
 * Gets the configuration information for the print task.
 */
configuration: Windows$Devices$Printers$Extensions$PrintTaskConfiguration;

/**
 * Gets the activation type for the print task settings.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before the settings were activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides data when an app is activated because it is the app associated with a URI scheme name.
 */
declare class Windows$ApplicationModel$Activation$ProtocolActivatedEventArgs  {

/**
 * Gets the package family name of the application that activated the current application.
 */
callerPackageFamilyName: string;

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Data received from the application that activated the current application.
 */
data: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the Uniform Resource Identifier (URI) for which the app was activated.
 */
uri: Windows$Foundation$Uri;

/**
 * Gets the view switcher object that allows you to set the view for the application.
 */
viewSwitcher: Windows$UI$ViewManagement$ActivationViewSwitcher
}


/**
 * Received by an application when it is launched by another application with the expectation that it will return results back to the caller.
 */
declare class Windows$ApplicationModel$Activation$ProtocolForResultsActivatedEventArgs  {

/**
 * Gets the package family name of the application that activated the current application.
 */
callerPackageFamilyName: string;

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Data received from the application that activated the current application.
 */
data: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the ProtocolForResultsOperation that you use to signal that your app is ready to return to the app that launched it for results.
 */
protocolForResultsOperation: Windows$System$ProtocolForResultsOperation;

/**
 * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the Uniform Resource Identifier (URI) used to activate the app.
 */
uri: Windows$Foundation$Uri;

/**
 * Gets the view switcher object that allows you to set the view for the application.
 */
viewSwitcher: Windows$UI$ViewManagement$ActivationViewSwitcher
}


/**
 * Provides event information when a restricted app is launched.
 */
declare class Windows$ApplicationModel$Activation$RestrictedLaunchActivatedEventArgs  {

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets information about a shared context for the restricted launch.
 */
sharedContext: any;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information about the activated event that fires when the user searches the app from the Search charm and the app isn't the main app on screen.
 */
declare class Windows$ApplicationModel$Activation$SearchActivatedEventArgs  {

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the Internet Engineering Task Force (IETF) language tag (BCP 47 standard) that identifies the language currently associated with the user's text input device.
 */
language: string;

/**
 * Gets a SearchPaneQueryLinguisticDetails object that provides info about query text that the user enters through an Input Method Editor (IME).
 */
linguisticDetails: Windows$ApplicationModel$Search$SearchPaneQueryLinguisticDetails;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the text that the user wants the app to search for. The user entered this text into the search box of the search pane.
 */
queryText: string;

/**
 * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the view switcher object that allows you to set the view for the application.
 */
viewSwitcher: Windows$UI$ViewManagement$ActivationViewSwitcher
}


/**
 * Provides information for an application that is a target for share operations.
 */
declare class Windows$ApplicationModel$Activation$ShareTargetActivatedEventArgs  {

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets information about data included in a share operation.
 */
shareOperation: Windows$ApplicationModel$DataTransfer$ShareTarget$ShareOperation;

/**
 * Gets the splash screen object which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides a dismissal event and image location information for the app's splash screen.
 */
declare class Windows$ApplicationModel$Activation$SplashScreen  {

/**
 * The coordinates of the app's splash screen image relative to the window.
 */
imageLocation: Windows$Foundation$Rect;

/**
 * Fires when the app's splash screen is dismissed.
 */
ondismissed: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Activation$SplashScreen, any>;
addEventListener(
type: "dismissed",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Activation$SplashScreen, any>): void;
removeEventListener(
type: "dismissed",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Activation$SplashScreen, any>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides information about an event that occurs when the app is activated because a user tapped on the body of a toast notification or performed an action inside a toast notification.
 */
declare class Windows$ApplicationModel$Activation$ToastNotificationActivatedEventArgs  {

/**
 * Gets the arguments that the app can retrieve after it is activated through an interactive toast notification.
 */
argument: string;

/**
 * Gets the reason for the activation of the app for this event.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before the app was activated because a user tapped on the body of a toast notification or performed an action inside a toast notification.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets a set of values that you can use to obtain the user input from an interactive toast notification.
 */
userInput: Windows$Foundation$Collections$ValueSet
}


/**
 * Contains info for the app's activated event when the app is launched through a voice command.
 */
declare class Windows$ApplicationModel$Activation$VoiceCommandActivatedEventArgs  {

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the SpeechRecognitionResult object representing the voice command that activated the app.
 */
result: Windows$Media$SpeechRecognition$SpeechRecognitionResult;

/**
 * Gets info about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information to an app that was launched as the result of a wallet action.
 */
declare class Windows$ApplicationModel$Activation$WalletActionActivatedEventArgs  {

/**
 * Gets the ID of the action, such as the id of the verb, transaction and so on.
 */
actionId: string;

/**
 * Gets the action that was performed on the WalletItem .
 */
actionKind: $Values<typeof Windows$ApplicationModel$Wallet$WalletActionKind>;

/**
 * Gets the ID of the WalletItem on which the user performed the action.
 */
itemId: string;

/**
 * Gets the type of action that was performed on the WalletItem .
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information to an app activated as a result of a web account provider operation.
 */
declare class Windows$ApplicationModel$Activation$WebAccountProviderActivatedEventArgs  {

/**
 * Gets the kind of web account provider activation.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the web account provider operation.
 */
operation: Windows$Security$Authentication$Web$Provider$IWebAccountProviderOperation;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information to an app that was launched after being suspended for a web authentication broker operation.
 */
declare class Windows$ApplicationModel$Activation$WebAuthenticationBrokerContinuationEventArgs  {

/**
 * Gets a set of values populated by the app before a web authentication broker operation that deactivates the app in order to provide context when the app is activated.
 */
continuationData: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the WebAuthenticationResult object returned from the web authentication broker operation.
 */
webAuthenticationResult: Windows$Security$Authentication$Web$WebAuthenticationResult
}


/**
 * Provides common properties for all activation types.
 */
declare interface Windows$ApplicationModel$Activation$IActivatedEventArgs {

/**
 * Gets the reason that this app is being activated.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>,

/**
 * Gets the execution state of the app before this activation.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>,

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
} 


/**
 * Provides an application's name, description, and logo.
 */
declare class Windows$ApplicationModel$AppDisplayInfo  {

/**
 * Gets the application's description.
 */
description: string;

/**
 * Gets the application's display name.
 */
displayName: string;

/**
 * Get the application's logo.
 * @param size The size of the rectangle in which the logo must fit.
 * @return The largest logo in your Package.appxmanifest file that will fit in the specified Size.
 */
getLogo(
size: Windows$Foundation$Size): Windows$Storage$Streams$RandomAccessStreamReference
}


/**
 * Provides information about an application such as it name, logo, package information, ID.
 */
declare class Windows$ApplicationModel$AppInfo  {

/**
 * An identifier that uniquely identifies the app.
 */
appUserModelId: string;

/**
 * Gets information that describes the application.
 */
displayInfo: Windows$ApplicationModel$AppDisplayInfo;

/**
 * Gets the app identifier.
 */
id: string;

/**
 * An identifier that uniquely identifies the app's package.
 */
packageFamilyName: string
}


      declare var npm$namespace$Windows$ApplicationModel$AppService: {
        
        
        AppServiceClosedStatus: typeof Windows$ApplicationModel$AppService$AppServiceClosedStatus,
AppServiceConnectionStatus: typeof Windows$ApplicationModel$AppService$AppServiceConnectionStatus,
AppServiceResponseStatus: typeof Windows$ApplicationModel$AppService$AppServiceResponseStatus,
        AppServiceCatalog: typeof Windows$ApplicationModel$AppService$AppServiceCatalog,
AppServiceClosedEventArgs: typeof Windows$ApplicationModel$AppService$AppServiceClosedEventArgs,
AppServiceConnection: typeof Windows$ApplicationModel$AppService$AppServiceConnection,
AppServiceDeferral: typeof Windows$ApplicationModel$AppService$AppServiceDeferral,
AppServiceRequest: typeof Windows$ApplicationModel$AppService$AppServiceRequest,
AppServiceRequestReceivedEventArgs: typeof Windows$ApplicationModel$AppService$AppServiceRequestReceivedEventArgs,
AppServiceResponse: typeof Windows$ApplicationModel$AppService$AppServiceResponse,
AppServiceTriggerDetails: typeof Windows$ApplicationModel$AppService$AppServiceTriggerDetails,
        
      }

/**
 * Enumerates the available app service providers on the device.
 */
declare class Windows$ApplicationModel$AppService$AppServiceCatalog  {
static findAppServiceProvidersAsync: any
}


/**
 * Provides data for the AppServiceConnection.ServiceClosed event that occurs when the other endpoint closes connection to the app service.
 */
declare class Windows$ApplicationModel$AppService$AppServiceClosedEventArgs  {

/**
 * Gets the status that was set when the endpoint for the app service was closed.
 */
status: $Values<typeof Windows$ApplicationModel$AppService$AppServiceClosedStatus>
}


/**
 * Describes the status that was set when the endpoint for the app service was closed.
 */

declare  var Windows$ApplicationModel$AppService$AppServiceClosedStatus: {|
  +completed: 0,// 0
+canceled: 1,// 1
+resourceLimitsExceeded: 2,// 2
+unknown: 3,// 3

|};



/**
 * Represents a connection to the endpoint for an app service.
 */
declare class Windows$ApplicationModel$AppService$AppServiceConnection  {

/**
 * Creates and initializes a new instance of the AppServiceConnection class.
 */
constructor(): this;

/**
 * Gets or sets the name of the app service to which you want to connect.
 */
appServiceName: string;

/**
 * Closes the connection to the app service.
 */
close(): void;

/**
 * Occurs when a message arrives from the other endpoint of the app service connection.
 */
onrequestreceived: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$AppService$AppServiceConnection, Windows$ApplicationModel$AppService$AppServiceRequestReceivedEventArgs>;
addEventListener(
type: "requestreceived",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$AppService$AppServiceConnection, Windows$ApplicationModel$AppService$AppServiceRequestReceivedEventArgs>): void;
removeEventListener(
type: "requestreceived",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$AppService$AppServiceConnection, Windows$ApplicationModel$AppService$AppServiceRequestReceivedEventArgs>): void;

/**
 * Occurs when the other endpoint closes the connection to the app service.
 */
onserviceclosed: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$AppService$AppServiceConnection, Windows$ApplicationModel$AppService$AppServiceClosedEventArgs>;
addEventListener(
type: "serviceclosed",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$AppService$AppServiceConnection, Windows$ApplicationModel$AppService$AppServiceClosedEventArgs>): void;
removeEventListener(
type: "serviceclosed",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$AppService$AppServiceConnection, Windows$ApplicationModel$AppService$AppServiceClosedEventArgs>): void;

/**
 * Opens a connection to the endpoint for the app service.
 * @return An asynchronous operation to open a connection to the endpoint for the app service.
 */
openAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$AppService$AppServiceConnectionStatus>>;

/**
 * Gets or sets the package family name for the package that contains the endpoint for the app service.
 */
packageFamilyName: string;

/**
 * Sends a message to the other endpoint of the app service connection.
 * @param message The message that you want to send.
 * @return An asynchronous operation to send the message that optionally returns a response message when complete.
 */
sendMessageAsync(
message: Windows$Foundation$Collections$ValueSet): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$AppService$AppServiceResponse>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Describes the status for the attempt that an app makes to open a connection to an app service by calling the AppServiceConnection.OpenAsync method.
 */

declare  var Windows$ApplicationModel$AppService$AppServiceConnectionStatus: {|
  +success: 0,// 0
+appNotInstalled: 1,// 1
+appUnavailable: 2,// 2
+appServiceUnavailable: 3,// 3
+unknown: 4,// 4

|};



/**
 * Enables the background task for an app service to get a deferral so that the app service can respond to subsequent requests.
 */
declare class Windows$ApplicationModel$AppService$AppServiceDeferral  {

/**
 * Indicates that the content for an asynchronous handler for the AppServiceConnection.RequestReceived event is ready, or that an error occurred.
 */
complete(): void
}


/**
 * Represents a message that the endpoint for one app service sends to another app service.
 */
declare class Windows$ApplicationModel$AppService$AppServiceRequest  {

/**
 * Gets the message that request from the app service contains.
 */
message: Windows$Foundation$Collections$ValueSet;

/**
 * Sends a response to a received request.
 * @param message The message that you want to include in the response.
 * @return An asynchronous operation to send the response.
 */
sendResponseAsync(
message: Windows$Foundation$Collections$ValueSet): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$AppService$AppServiceResponseStatus>>
}


/**
 * Provides data for the AppServiceConnection.RequestReceived event that occurs when a message arrives from the other endpoint of the app service connection.
 */
declare class Windows$ApplicationModel$AppService$AppServiceRequestReceivedEventArgs  {

/**
 * Informs the system that the event handler might continue to perform work after the event handler returns.
 * @return The deferral.
 */
getDeferral(): Windows$ApplicationModel$AppService$AppServiceDeferral;

/**
 * Gets the request that was received from the app service.
 */
request: Windows$ApplicationModel$AppService$AppServiceRequest
}


/**
 * Represents the message that the app service sent in response to a request.
 */
declare class Windows$ApplicationModel$AppService$AppServiceResponse  {

/**
 * Gets the message that the response from the app service contains.
 */
message: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the status for the response from the app service.
 */
status: $Values<typeof Windows$ApplicationModel$AppService$AppServiceResponseStatus>
}


/**
 * Describes the status when an app tries to send a message to an app service by calling the AppServiceConnection.SendMessageAsync method.
 */

declare  var Windows$ApplicationModel$AppService$AppServiceResponseStatus: {|
  +success: 0,// 0
+failure: 1,// 1
+resourceLimitsExceeded: 2,// 2
+unknown: 3,// 3

|};



/**
 * Represents details associated with the background task for the app service.
 */
declare class Windows$ApplicationModel$AppService$AppServiceTriggerDetails  {

/**
 * Gets the connection to the endpoint of the other app service.
 */
appServiceConnection: Windows$ApplicationModel$AppService$AppServiceConnection;

/**
 * Gets the name of the package family for the client app that called the background task for the app service.
 */
callerPackageFamilyName: string;

/**
 * Gets the name of the app service.
 */
name: string
}


      declare var npm$namespace$Windows$ApplicationModel$Appointments: {
        
        
        AppointmentBusyStatus: typeof Windows$ApplicationModel$Appointments$AppointmentBusyStatus,
AppointmentCalendarOtherAppReadAccess: typeof Windows$ApplicationModel$Appointments$AppointmentCalendarOtherAppReadAccess,
AppointmentCalendarOtherAppWriteAccess: typeof Windows$ApplicationModel$Appointments$AppointmentCalendarOtherAppWriteAccess,
AppointmentCalendarSyncStatus: typeof Windows$ApplicationModel$Appointments$AppointmentCalendarSyncStatus,
AppointmentConflictType: typeof Windows$ApplicationModel$Appointments$AppointmentConflictType,
AppointmentDaysOfWeek: typeof Windows$ApplicationModel$Appointments$AppointmentDaysOfWeek,
AppointmentDetailsKind: typeof Windows$ApplicationModel$Appointments$AppointmentDetailsKind,
AppointmentParticipantResponse: typeof Windows$ApplicationModel$Appointments$AppointmentParticipantResponse,
AppointmentParticipantRole: typeof Windows$ApplicationModel$Appointments$AppointmentParticipantRole,
AppointmentRecurrenceUnit: typeof Windows$ApplicationModel$Appointments$AppointmentRecurrenceUnit,
AppointmentSensitivity: typeof Windows$ApplicationModel$Appointments$AppointmentSensitivity,
AppointmentStoreAccessType: typeof Windows$ApplicationModel$Appointments$AppointmentStoreAccessType,
AppointmentStoreChangeType: typeof Windows$ApplicationModel$Appointments$AppointmentStoreChangeType,
AppointmentSummaryCardView: typeof Windows$ApplicationModel$Appointments$AppointmentSummaryCardView,
AppointmentWeekOfMonth: typeof Windows$ApplicationModel$Appointments$AppointmentWeekOfMonth,
FindAppointmentCalendarsOptions: typeof Windows$ApplicationModel$Appointments$FindAppointmentCalendarsOptions,
RecurrenceType: typeof Windows$ApplicationModel$Appointments$RecurrenceType,
        Appointment: typeof Windows$ApplicationModel$Appointments$Appointment,
AppointmentCalendar: typeof Windows$ApplicationModel$Appointments$AppointmentCalendar,
AppointmentCalendarSyncManager: typeof Windows$ApplicationModel$Appointments$AppointmentCalendarSyncManager,
AppointmentConflictResult: typeof Windows$ApplicationModel$Appointments$AppointmentConflictResult,
AppointmentException: typeof Windows$ApplicationModel$Appointments$AppointmentException,
AppointmentInvitee: typeof Windows$ApplicationModel$Appointments$AppointmentInvitee,
AppointmentManager: typeof Windows$ApplicationModel$Appointments$AppointmentManager,
AppointmentOrganizer: typeof Windows$ApplicationModel$Appointments$AppointmentOrganizer,
AppointmentProperties: typeof Windows$ApplicationModel$Appointments$AppointmentProperties,
AppointmentRecurrence: typeof Windows$ApplicationModel$Appointments$AppointmentRecurrence,
AppointmentStore: typeof Windows$ApplicationModel$Appointments$AppointmentStore,
AppointmentStoreChange: typeof Windows$ApplicationModel$Appointments$AppointmentStoreChange,
AppointmentStoreChangeReader: typeof Windows$ApplicationModel$Appointments$AppointmentStoreChangeReader,
AppointmentStoreChangeTracker: typeof Windows$ApplicationModel$Appointments$AppointmentStoreChangeTracker,
AppointmentStoreChangedDeferral: typeof Windows$ApplicationModel$Appointments$AppointmentStoreChangedDeferral,
AppointmentStoreChangedEventArgs: typeof Windows$ApplicationModel$Appointments$AppointmentStoreChangedEventArgs,
AppointmentStoreNotificationTriggerDetails: typeof Windows$ApplicationModel$Appointments$AppointmentStoreNotificationTriggerDetails,
FindAppointmentsOptions: typeof Windows$ApplicationModel$Appointments$FindAppointmentsOptions,
        AppointmentsProvider: typeof npm$namespace$Windows$ApplicationModel$Appointments$AppointmentsProvider,
      }

/**
 * Represents an appointment in a calendar. This class is used when an app is activated using the AppointmentsProvider value for ActivationKind , as a value for AppointmentInformation properties.
 */
declare class Windows$ApplicationModel$Appointments$Appointment  {

/**
 * Initializes a new instance of the Appointment class.
 */
constructor(): this;

/**
 * Gets or sets a Boolean value that indicates whether the appointment will last all day. The default is FALSE for won't last all day.
 */
allDay: boolean;

/**
 * Gets or sets a value that indicates whether the appointment will allow users to propose a new time.
 */
allowNewTimeProposal: boolean;

/**
 * Gets or sets a AppointmentBusyStatus -typed value that indicates the busy status for a participant of an appointment.
 */
busyStatus: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentBusyStatus>;

/**
 * Gets the unique identifier for the calendar associated with the appointment.
 */
calendarId: string;

/**
 * Gets the current change number of the local version of the Appointment .
 */
changeNumber: number;

/**
 * Gets or sets a string value. The string contains extended details that describe the appointment. Details is of type String and a maximum of 1,073,741,823 characters in length, which is the maximum length of a JET database string.
 */
details: string;

/**
 * Gets or sets the type of appointment details, plain text or HTML.
 */
detailsKind: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentDetailsKind>;

/**
 * Gets or sets a time span that represents the time duration of the appointment. Duration is of type TimeSpan and must be non-negative.
 */
duration: number;

/**
 * Gets a value that indicates whether the appointment has invitees.
 */
hasInvitees: boolean;

/**
 * Gets the list of participants for the appointment. Invitees is of type IVector(AppointmentInvitee) . If an organizer is set and invitee length is greater than 0, a call to an AppointmentManager API fails with E_INVALIDARG. The number of invitees is unlimited.
 */
invitees: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Appointments$AppointmentInvitee>;

/**
 * Gets or sets a value that indicates whether the appointment has been cancelled.
 */
isCanceledMeeting: boolean;

/**
 * Gets or sets a value that indicates whether the appointment was organized by the current user.
 */
isOrganizedByUser: boolean;

/**
 * Gets or sets a value that indicates whether a response to the appointment invitation is requested.
 */
isResponseRequested: boolean;

/**
 * Gets a string that uniquely identifies the appointment on the local device.
 */
localId: string;

/**
 * Gets or sets a string that communicates the physical location of the appointment. Location is of type String and a maximum of 32,768 characters in length.
 */
location: string;

/**
 * Gets or sets a string value that is a URL used to join the online meeting for the appointment.
 */
onlineMeetingLink: string;

/**
 * Gets or sets the organizer of the appointment. Organizer is of type AppointmentOrganizer . If an organizer is set and invitee length is greater than 0, a call to an AppointmentManager API fails with E_INVALIDARG. The number of invitees is unlimited.
 */
organizer: Windows$ApplicationModel$Appointments$AppointmentOrganizer;

/**
 * Gets the original starting time for a recurring appointment.
 */
originalStartTime: Date;

/**
 * Gets or sets the object that describes when and how often the appointment occurs. Recurrence is of type AppointmentRecurrence .
 */
recurrence: Windows$ApplicationModel$Appointments$AppointmentRecurrence;

/**
 * Gets or sets a time span value. The value declares the amount of time to subtract from the StartTime , and that time used as the issue time for a reminder for an appointment. A null value indicates that the appointment will not issue a reminder. Reminder is of type IReference(TimeSpan) .
 */
reminder: number;

/**
 * Gets or sets the current change number of the server version of the Appointment .
 */
remoteChangeNumber: number;

/**
 * Gets or sets the date and time that the user responded to the appointment request.
 */
replyTime: Date;

/**
 * Gets or sets a string that uniquely identifies an appointment across devices.
 */
roamingId: string;

/**
 * Gets or sets a AppointmentSensitivity -typed value that indicates the sensitivity of the appointment.
 */
sensitivity: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentSensitivity>;

/**
 * Gets or sets the starting time for the appointment. StartTime is of type DateTime .
 */
startTime: Date;

/**
 * Gets or sets a string that communicates the subject of the appointment. Subject is of type String and a maximum of 255 characters in length.
 */
subject: string;

/**
 * Gets the Uniform Resource Identifier ( Uri ) for the appointment. Allows the Calendar app to perform an association launch to go back to the source app or other URI that represents this appointment.
 */
uri: Windows$Foundation$Uri;

/**
 * Gets or sets the user's response to the appointment request.
 */
userResponse: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentParticipantResponse>
}


/**
 * Specifies the busy status for a participant of an appointment.
 */

declare  var Windows$ApplicationModel$Appointments$AppointmentBusyStatus: {|
  +busy: 0,// 0
+tentative: 1,// 1
+free: 2,// 2
+outOfOffice: 3,// 3
+workingElsewhere: 4,// 4

|};



/**
 * Represents a calendar with appointments.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentCalendar  {

/**
 * Gets or sets a Boolean value that indicates if the calendar supports cancelling meetings.
 */
canCancelMeetings: boolean;

/**
 * Gets or sets a Boolean value that indicates if the calendar supports creating or updating appointments.
 */
canCreateOrUpdateAppointments: boolean;

/**
 * Gets or sets a Boolean value that indicates if the calendar supports forwarding meetings.
 */
canForwardMeetings: boolean;

/**
 * Gets or sets a Boolean value that indicates if the calendar supports notifying attendees.
 */
canNotifyInvitees: boolean;

/**
 * Gets or sets a Boolean value that indicates if the calendar supports proposing new meeting times.
 */
canProposeNewTimeForMeetings: boolean;

/**
 * Gets or sets a Boolean value that indicates if the calendar supports updating meeting responses.
 */
canUpdateMeetingResponses: boolean;

/**
 * Asynchronously deletes the appointment with the specified ID.
 * @param localId The LocalId of the appointment to be deleted.
 * @return An asynchronous action.
 */
deleteAppointmentAsync(localId: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously deletes the appointment instance with the specified start time of a master appointment with the specified ID.
 * @param localId The LocalId of the master appointment associated with the appointment instance to be deleted.
 * @param instanceStartTime The start time of the appointment instance to be deleted.
 * @return An asynchronous action.
 */
deleteAppointmentInstanceAsync(
localId: string,
instanceStartTime: Date): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously deletes the appointment calendar.
 * @return An asynchrounous action.
 */
deleteAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the color that the built-in calendar app uses for appointments associated with the calendar.
 */
displayColor: Windows$UI$Color;

/**
 * Gets a string representing the display name for the AppointmentCalendar .
 */
displayName: string;

/**
 * Asynchronously retrieves a list of appointment instances of the specified master appointment that meet the specified criteria.
 * @param masterLocalId The LocalId of the master appointment for which appointment instances are retrieved.
 * @param rangeStart The start time of the time window for which appointment instances are retrieved.
 * @param rangeLength The length of the time window for which appointment instances are retrieved.
 * @param pOptions A FindAppointmentsOptions object that is used to specify more options for this operation.
 * @return An asynchronous operation that returns IVectorView on successful completion.
 */
findAllInstancesAsync(
masterLocalId: string,
rangeStart: Date,
rangeLength: number,
pOptions: Windows$ApplicationModel$Appointments$FindAppointmentsOptions): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously retrieves a list of appointment instances of the specified master appointment that meet the specified criteria.
 * @param masterLocalId The LocalId of the master appointment for which appointment instances are retrieved.
 * @param rangeStart The start time of the time window for which appointment instances are retrieved.
 * @param rangeLength The length of the time window for which appointment instances are retrieved.
 * @return An asynchronous operation that returns IVectorView on successful completion.
 */
findAllInstancesAsync(
masterLocalId: string,
rangeStart: Date,
rangeLength: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously retrieves a list of appointments belonging to the current AppointmentCalendar that meet the specified criteria.
 * @param rangeStart The start time of the time window for which appointments are retrieved.
 * @param rangeLength The length of the time window for which appointments are retrieved.
 * @return An asynchronous operation that returns IVectorView on successful completion.
 */
findAppointmentsAsync(
rangeStart: Date,
rangeLength: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously retrieves a list of appointments belonging to the current AppointmentCalendar that meet the specified criteria.
 * @param rangeStart The start time of the time window for which appointments are retrieved.
 * @param rangeLength The length of the time window for which appointments are retrieved.
 * @param options A FindAppointmentsOptions object that is used to specify more options for this operation.
 * @return An asynchronous operation that returns IVectorView on successful completion.
 */
findAppointmentsAsync(
rangeStart: Date,
rangeLength: number,
options: Windows$ApplicationModel$Appointments$FindAppointmentsOptions): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously retrieves a list of appointment instances that are exceptions from the specified master appointment.
 * @param masterLocalId The LocalId of the master appointment for which exceptional appointment instances are retrieved.
 * @return An asynchronous operation that returns IVectorView on successful completion.
 */
findExceptionsFromMasterAsync(
masterLocalId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously retrieves a list of appointments that meet the specified criteria.
 * @param options A FindAppointmentsOptions object that is used to specify more options for this operation.
 * @return An asynchronous operation that returns IVectorView on successful completion.
 */
findUnexpandedAppointmentsAsync(
options: Windows$ApplicationModel$Appointments$FindAppointmentsOptions): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously retrieves a list of appointments that meet the specified criteria.
 * @return An asynchronous operation that returns IVectorView on successful completion.
 */
findUnexpandedAppointmentsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously retrieves the Appointment with the specified ID.
 * @param localId The LocalId of the appointment to be retrieved.
 * @return An asynchronous operation that returns Appointment on successful completion.
 */
getAppointmentAsync(
localId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Appointments$Appointment>;

/**
 * (Applies to Windows Phone only) Asynchronously retrieves the Appointment with the specified ID and includes data for the specified properties.
 * @param localId The LocalId of the appointment to be retrieved.
 * @param prefetchProperties A list of names of the properties for which data should be included when the appointment is retrieved.
 * @return An asynchronous operation that returns Appointment on successful completion.
 */
getAppointmentAsync(
localId: string,
prefetchProperties: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Appointments$Appointment>;

/**
 * Asynchronously retrieves the appointment instance of the specified master appointment that has the specified start time.
 * @param localId The ID of the master appointment to which the retrieved appointment instance belongs.
 * @param instanceStartTime The start time of the appointment instance to be retrieved.
 * @return An asynchronous operation that returns Appointment on successful completion.
 */
getAppointmentInstanceAsync(
localId: string,
instanceStartTime: Date): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Appointments$Appointment>;

/**
 * Gets whether the AppointmentCalendar is hidden in the device's built-in calendar UI.
 */
isHidden: boolean;

/**
 * Gets a string that uniquely identifies the appointment calendar on the local device.
 */
localId: string;

/**
 * Gets or sets a Boolean value that indicates if invitees must be sent notifications.
 */
mustNofityInvitees: boolean;

/**
 * Gets or sets a boolean value indicating whether other apps on the device have read access to the appointment calendar.
 */
otherAppReadAccess: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentCalendarOtherAppReadAccess>;

/**
 * Gets or sets a boolean value indicating whether other apps on the device have write access to the appointment calendar.
 */
otherAppWriteAccess: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentCalendarOtherAppWriteAccess>;

/**
 * Gets the remote ID for the AppointmentCalendar .
 */
remoteId: string;

/**
 * Asynchronously saves the provided appointment to the calendar.
 * @param pAppointment The appointment to be saved.
 * @return An asynchronous action.
 */
saveAppointmentAsync(
pAppointment: Windows$ApplicationModel$Appointments$Appointment): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously saves changes to the appointment calendar.
 * @return An asynchronous action.
 */
saveAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets a string that describes the provider for the appointment calendar.
 */
sourceDisplayName: string;

/**
 * Gets or sets how the summary card for the calendar's appointments are displayed.
 */
summaryCardView: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentSummaryCardView>;

/**
 * Gets the AppointmentCalendarSyncManager which can be used to sync with the remote server.
 */
syncManager: Windows$ApplicationModel$Appointments$AppointmentCalendarSyncManager;

/**
 * Asynchronously attempts to cancel a meeting.
 * @param meeting The meeting to cancel.
 * @param subject The subject for the cancellation notification.
 * @param comment The body of the cancellation notification.
 * @param notifyInvitees A Boolean value indicating if invitees should be notified.
 * @return A Boolean value indicating if the operation was successful.
 */
tryCancelMeetingAsync(
meeting: Windows$ApplicationModel$Appointments$Appointment,
subject: string,
comment: string,
notifyInvitees: boolean): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously attempts to create or update a meeting.
 * @param appointment The meeting to create or update.
 * @param notifyInvitees A Boolean value indicating if invitees should be notified.
 * @return A Boolean value indicating if the operation was successful.
 */
tryCreateOrUpdateAppointmentAsync(
appointment: Windows$ApplicationModel$Appointments$Appointment,
notifyInvitees: boolean): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously attempts to forward a meeting.
 * @param meeting The meeting to forward.
 * @param invitees A list of new invitees to receive the forwarded meeting.
 * @param subject The subject of the meeting invitation.
 * @param forwardHeader A new meeting header that includes the new invitees.
 * @param comment The body of the forwarded meeting invitation.
 * @return A Boolean value indicating if the operation was successful.
 */
tryForwardMeetingAsync(
meeting: Windows$ApplicationModel$Appointments$Appointment,
invitees: Windows$Foundation$Collections$IIterable<Windows$ApplicationModel$Appointments$AppointmentInvitee>,
subject: string,
forwardHeader: string,
comment: string): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously attempts to propose a new meeting time.
 * @param meeting The meeting to update.
 * @param newStartTime The proposed new start time.
 * @param newDuration A new duration for the meeting.
 * @param subject The subject of the meeting invitation.
 * @param comment The body of the meeting invitation.
 * @return A Boolean value indicating if the operation was successful.
 */
tryProposeNewTimeForMeetingAsync(
meeting: Windows$ApplicationModel$Appointments$Appointment,
newStartTime: Date,
newDuration: number,
subject: string,
comment: string): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously attempts to update the response to a meeting invitation.
 * @param meeting The meeting to update.
 * @param response The response to the meeting invitation, such as accept, tentative or decline.
 * @param subject The subject of the response.
 * @param comment The body of the response.
 * @param sendUpdate A Boolean value indicating whether or not to send the response to the meeting organizer.
 * @return A Boolean value indicating if the operation was successful.
 */
tryUpdateMeetingResponseAsync(
meeting: Windows$ApplicationModel$Appointments$Appointment,
response: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentParticipantResponse>,
subject: string,
comment: string,
sendUpdate: boolean): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Get the identifier of the user account data for the AppointmentCalendar .
 */
userDataAccountId: string
}


/**
 * Specifies the level of read access provided to an app calendar.
 */

declare  var Windows$ApplicationModel$Appointments$AppointmentCalendarOtherAppReadAccess: {|
  +systemOnly: 0,// 0
+limited: 1,// 1
+full: 2,// 2

|};



/**
 * Specifies the level of write access provided to an app calendar.
 */

declare  var Windows$ApplicationModel$Appointments$AppointmentCalendarOtherAppWriteAccess: {|
  +none: 0,// 0
+systemOnly: 1,// 1

|};



/**
 * Provides access to sync functionality for an AppointmentCalendar object.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentCalendarSyncManager  {

/**
 * Gets the last date and time that a sync with the AppointmentCalendar server was attempted.
 */
lastAttemptedSyncTime: Date;

/**
 * Gets the last date and time that a sync with the AppointmentCalendar server was successful.
 */
lastSuccessfulSyncTime: Date;

/**
 * Occurs when the status of an AppointmentCalendar sync operation changes.
 */
onsyncstatuschanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Appointments$AppointmentCalendarSyncManager, any>;
addEventListener(
type: "syncstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Appointments$AppointmentCalendarSyncManager, any>): void;
removeEventListener(
type: "syncstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Appointments$AppointmentCalendarSyncManager, any>): void;

/**
 * Gets the current status of the AppointmentCalendarSyncManager .
 */
status: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentCalendarSyncStatus>;

/**
 * Initiates a sync operation on the AppointmentCalendar .
 * @return A Boolean value indicating if the sync was successfully initiated.
 */
syncAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies the current sync status of an AppointmentCalendar .
 */

declare  var Windows$ApplicationModel$Appointments$AppointmentCalendarSyncStatus: {|
  +idle: 0,// 0
+syncing: 1,// 1
+upToDate: 2,// 2
+authenticationError: 3,// 3
+policyError: 4,// 4
+unknownError: 5,// 5
+manualAccountRemovalRequired: 6,// 6

|};



/**
 * Represents a conflict between appointments.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentConflictResult  {

/**
 * Gets the date of the appointment conflict.
 */
date: Date;

/**
 * Gets a value indicating the type of appointment conflict.
 */
type: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentConflictType>
}


/**
 * Specifies the way in which an appointment conflicts with another appointment.
 */

declare  var Windows$ApplicationModel$Appointments$AppointmentConflictType: {|
  +none: 0,// 0
+adjacent: 1,// 1
+overlap: 2,// 2

|};



/**
 * Specifies the days of the week on which an appointment occurs.
 */

declare  var Windows$ApplicationModel$Appointments$AppointmentDaysOfWeek: {|
  +none: 0,// 0
+sunday: 1,// 1
+monday: 2,// 2
+tuesday: 3,// 3
+wednesday: 4,// 4
+thursday: 5,// 5
+friday: 6,// 6
+saturday: 7,// 7

|};



/**
 * Defines the type of content in appointment details.
 */

declare  var Windows$ApplicationModel$Appointments$AppointmentDetailsKind: {|
  +plainText: 0,// 0
+html: 1,// 1

|};



/**
 * Represents an appointment instance that is an exception from the master appointment.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentException  {

/**
 * Gets the appointment that is an exception from the master appointment.
 */
appointment: Windows$ApplicationModel$Appointments$Appointment;

/**
 * Gets a list of the names of the appointment properties for which an exception was found.
 */
exceptionProperties: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets a value indicating whether the exception is that the appointment instance has been deleted.
 */
isDeleted: boolean
}


/**
 * Represents a participant of an appointment in a calendar.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentInvitee  {

/**
 * Initializes a new instance of the AppointmentInvitee class.
 */
constructor(): this;

/**
 * Gets or sets a string that communicates the address of a participant of an appointment. The address is inherited from IAppointmentParticipant and is a Simple Mail Transfer Protocol (SMTP) e-mail address. It is also of type String and between 1 and 321 characters in length (non-empty).
 */
address: string;

/**
 * Gets or sets a string that communicates the display name of a participant of an appointment. The display name is inherited from IAppointmentParticipant , of type String , and a maximum of 256 characters in length.
 */
displayName: string;

/**
 * Gets or sets a AppointmentParticipantResponse -typed value that indicates the response from a participant concerning an appointment invitation.
 */
response: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentParticipantResponse>;

/**
 * Gets or sets a AppointmentParticipantRole -typed value that indicates the role of a participant concerning an appointment invitation.
 */
role: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentParticipantRole>
}


/**
 * Provides APIs to interact with the users Appointments provider app (for example, the Calendar app). Call static methods to display provider-specific UI so that the user can perform tasks.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentManager  {

/**
 * Requests the AppointmentStore object associated with the calling application.
 * @param options An AppointmentStoreAccessType value indicating the level of access the returned appointment store will have.
 * @return An asynchronous operation that returns an AppointmentStore upon successful completion.
 */
static requestStoreAsync(
options: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentStoreAccessType>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Appointments$AppointmentStore>;

/**
 * Shows the Appointments provider Add Appointment UI, to enable the user to add an appointment.
 * @param appointment The object representing the information for the appointment to add.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Add Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Add Appointment UI displays around the button, not overlapping it.
 * @param preferredPlacement The Placement that describes the preferred placement of the Add Appointment UI.
 * @return When this method completes, it returns a String object that represents the appointment. This serves as an appointment identifier for future reference when updating or removing. If the appointment identifier returned is an empty string, the appointment was not added to the Appointments provider app.
 */
static showAddAppointmentAsync(
appointment: Windows$ApplicationModel$Appointments$Appointment,
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Shows the Appointments provider Add Appointment UI, to enable the user to add an appointment.
 * @param appointment The object representing the information for the appointment to add.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Add Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Add Appointment UI displays around the button, not overlapping it.
 * @return When this method completes, it returns a String object that represents the appointment. This serves as an appointment identifier for future reference when updating or removing. If the appointment identifier returned is an empty string, the appointment was not added to the Appointments provider app.
 */
static showAddAppointmentAsync(
appointment: Windows$ApplicationModel$Appointments$Appointment,
selection: Windows$Foundation$Rect): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Shows the Appointments provider Appointment Details UI, to enable the user to view the specified appointment.
 * @param appointmentId The LocalId of the appointment to be displayed.
 * @return An asynchronous action.
 */
static showAppointmentDetailsAsync(appointmentId: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Shows the Appointments provider Appointment Details UI, to enable the user to view the specified appointment.
 * @param appointmentId The LocalId of the appointment to be displayed.
 * @param instanceStartDate A DateTime object with the start time of the appointment instance to be displayed.
 * @return An asynchronous action.
 */
static showAppointmentDetailsAsync(
appointmentId: string,
instanceStartDate: Date): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Shows the Appointments provider Add Appointment UI including the full edit experience, to enable the user to add an appointment.
 * @param appointment The appointment to be added.
 * @return An asynchronous operation that returns a string containing an appointment ID upon successful completion.
 */
static showEditNewAppointmentAsync(
appointment: Windows$ApplicationModel$Appointments$Appointment): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Shows the Appointments provider Remove Appointment UI, to enable the user to remove an appointment.
 * @param appointmentId The appointment identifier. This is typically obtained from the async return value of a previous ShowAddAppointmentAsync call.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Remove Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Remove Appointment UI displays around the button, not overlapping it.
 * @return When this method completes, it returns a Boolean value that indicates whether the Appointment provider app removed the appointment.
 */
static showRemoveAppointmentAsync(
appointmentId: string,
selection: Windows$Foundation$Rect): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Shows the Appointments provider Remove Appointment UI, to enable the user to remove an appointment.
 * @param appointmentId The appointment identifier. This is typically obtained from the async return value of a previous ShowAddAppointmentAsync call.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Remove Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Remove Appointment UI displays around the button, not overlapping it.
 * @param preferredPlacement The Placement that describes the preferred placement of the Remove Appointment UI.
 * @return When this method completes, it returns a Boolean value that indicates whether the Appointment provider app removed the appointment.
 */
static showRemoveAppointmentAsync(
appointmentId: string,
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Shows the Appointments provider Remove Appointment UI, to enable the user to remove an appointment.
 * @param appointmentId The appointment identifier. This is typically obtained from the async return value of a previous ShowAddAppointmentAsync call.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Remove Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Remove Appointment UI displays around the button, not overlapping it.
 * @param preferredPlacement The Placement that describes the preferred placement of the Remove Appointment UI.
 * @param instanceStartDate The start date and time of the appointment instance to remove.
 * @return When this method completes, it returns a Boolean value that indicates whether the Appointment provider app removed the appointment.
 */
static showRemoveAppointmentAsync(
appointmentId: string,
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>,
instanceStartDate: Date): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Shows the Appointments provider Replace Appointment UI, to enable the user to replace an appointment.
 * @param appointmentId The appointment identifier of the current appointment. This is typically obtained from the async return value of a previous ShowAddAppointmentAsync or ShowReplaceAppointmentAsync call.
 * @param appointment The object representing the information for the appointment to replace the current appointment.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Replace Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Replace Appointment UI displays around the button, not overlapping it.
 * @return When this method completes, it returns a String object that represents the appointment. This serves as an appointment identifier for future reference when updating or removing. If the appointment identifier returned is an empty string, the appointment was not replaced in the Appointments provider app.
 */
static showReplaceAppointmentAsync(
appointmentId: string,
appointment: Windows$ApplicationModel$Appointments$Appointment,
selection: Windows$Foundation$Rect): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Shows the Appointments provider Replace Appointment UI, to enable the user to replace an appointment.
 * @param appointmentId The appointment identifier of the current appointment. This is typically obtained from the async return value of a previous ShowAddAppointmentAsync or ShowReplaceAppointmentAsync call.
 * @param appointment The object representing the information for the appointment to replace the current appointment.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Replace Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Replace Appointment UI displays around the button, not overlapping it.
 * @param preferredPlacement The Placement that describes the preferred placement of the Replace Appointment UI.
 * @param instanceStartDate The start date and time of the appointment instance to replace.
 * @return When this method completes, it returns a String object that represents the appointment. This serves as an appointment identifier for future reference when updating or removing. If the appointment identifier returned is an empty string, the appointment was not replaced in the Appointments provider app.
 */
static showReplaceAppointmentAsync(
appointmentId: string,
appointment: Windows$ApplicationModel$Appointments$Appointment,
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>,
instanceStartDate: Date): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Shows the Appointments provider Replace Appointment UI, to enable the user to replace an appointment.
 * @param appointmentId The appointment identifier of the current appointment. This is typically obtained from the async return value of a previous ShowAddAppointmentAsync or ShowReplaceAppointmentAsync call.
 * @param appointment The object representing the information for the appointment to replace the current appointment.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Replace Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Replace Appointment UI displays around the button, not overlapping it.
 * @param preferredPlacement The Placement that describes the preferred placement of the Replace Appointment UI.
 * @return When this method completes, it returns a String object that represents the appointment. This serves as an appointment identifier for future reference when updating or removing. If the appointment identifier returned is an empty string, the appointment was not replaced in the Appointments provider app.
 */
static showReplaceAppointmentAsync(
appointmentId: string,
appointment: Windows$ApplicationModel$Appointments$Appointment,
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Shows the Appointments provider app's primary UI. This typically displays a time frame from an appointments calendar.
 * @param timeToShow A date and time object that specifies the beginning of the time frame that the Appointments provider app should display.
 * @param duration A timespan that hints to the Appointments provider app how long the time frame shown should be.
 * @return When this method returns, it does not return a result. On completion, the AsyncActionCompletedHandler specified by get_Completed / Completed is invoked.
 */
static showTimeFrameAsync(
timeToShow: Date,
duration: number): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Represents the organizer of an appointment in a calendar.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentOrganizer  {

/**
 * Initializes a new instance of the AppointmentOrganizer class.
 */
constructor(): this;

/**
 * Gets or sets a string that communicates the address of the organizer of an appointment. The address is required, inherited from IAppointmentParticipant , and a Simple Mail Transfer Protocol (SMTP) e-mail address. It is also of type String and between 1 and 321 characters in length (non-empty).
 */
address: string;

/**
 * Gets or sets a string that communicates the display name of the organizer of an appointment. The display name is optional, inherited from IAppointmentParticipant , of type String , and a maximum of 256 characters in length.
 */
displayName: string
}


/**
 * Specifies the response from a participant concerning an appointment invitation.
 */

declare  var Windows$ApplicationModel$Appointments$AppointmentParticipantResponse: {|
  +none: 0,// 0
+tentative: 1,// 1
+accepted: 2,// 2
+declined: 3,// 3
+unknown: 4,// 4

|};



/**
 * Specifies the role of an item concerning an appointment invitation.
 */

declare  var Windows$ApplicationModel$Appointments$AppointmentParticipantRole: {|
  +requiredAttendee: 0,// 0
+optionalAttendee: 1,// 1
+resource: 2,// 2

|};



/**
 * Provides strings that identify the properties of an appointment.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentProperties  {

/**
 * Gets the name of the AllDay property.
 */
static allDay: string;

/**
 * Gets the name of AllowNewTimeProposal the property.
 */
static allowNewTimeProposal: string;

/**
 * Gets the name of the BusyStatus property.
 */
static busyStatus: string;

/**
 * Gets the current change number of the local version of the Appointment .
 */
static changeNumber: string;

/**
 * Gets a list of names for the default appointment properties.
 */
static defaultProperties: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets the name of the Details property.
 */
static details: string;
static detailsKind: any;

/**
 * Gets the name of the Duration property.
 */
static duration: string;

/**
 * Gets the name of the HasInvitees property.
 */
static hasInvitees: string;

/**
 * Gets the name of the Invitees property.
 */
static invitees: string;

/**
 * Gets the name of the IsCanceledMeeting property.
 */
static isCanceledMeeting: string;

/**
 * Gets the name of the IsOrganizedByUser property.
 */
static isOrganizedByUser: string;

/**
 * Gets the name of the IsResponseRequested property.
 */
static isResponseRequested: string;

/**
 * Gets the name of the Location property.
 */
static location: string;

/**
 * Gets the name of the OnlineMeetingLink property.
 */
static onlineMeetingLink: string;

/**
 * Gets the name of the Organizer property.
 */
static organizer: string;

/**
 * Gets the name of the OriginalStartTime property.
 */
static originalStartTime: string;

/**
 * Gets the name of the Recurrence property.
 */
static recurrence: string;

/**
 * Gets the name of the Reminder property.
 */
static reminder: string;
static remoteChangeNumber: any;

/**
 * Gets the name of the ReplyTime property.
 */
static replyTime: string;

/**
 * Gets the name of the Sensitivity property.
 */
static sensitivity: string;

/**
 * Gets the name of the StartTime property.
 */
static startTime: string;

/**
 * Gets the name of the Subject property.
 */
static subject: string;

/**
 * Gets the name of the Uri property.
 */
static uri: string;

/**
 * Gets the name of the UserResponse property.
 */
static userResponse: string
}


/**
 * Represents when and how often an appointment occurs.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentRecurrence  {

/**
 * Initializes a new instance of the AppointmentRecurrence class.
 */
constructor(): this;
calendarIdentifier: any;

/**
 * Gets or sets the day on which an appointment occurs. Day is of type UInt32 , has a default value of 1, and can be a value from 1 to 31.
 */
day: number;

/**
 * Gets or sets a combination of AppointmentDaysOfWeek -typed values for all the days of the week on which an appointment occurs.
 */
daysOfWeek: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentDaysOfWeek>;

/**
 * Gets or sets the interval between occurrences of an appointment. Interval is of type UInt32 and has a default value of 1. For daily, the interval is the number of days in between, for weekly, the number of weeks, and so on.
 */
interval: number;

/**
 * Gets or sets the month on which an appointment occurs. Month is of type UInt32 , has a default value of 1, and can be a value from 1 to 12.
 */
month: number;

/**
 * Gets or sets the number of times an appointment recurs. Occurrences is of type IReference(UInt32) and is NULL by default. Occurrences is mutually exclusive with Until .
 */
occurrences: number;

/**
 * Gets a value indicating what type of recurrence applies to the associated appointment.
 */
recurrenceType: $Values<typeof Windows$ApplicationModel$Appointments$RecurrenceType>;

/**
 * Gets or sets the time zone for the recurrence.
 */
timeZone: string;

/**
 * Gets or sets a AppointmentRecurrenceUnit -typed value that indicates the frequency for which the appointment occurs.
 */
unit: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentRecurrenceUnit>;

/**
 * Gets or sets the date and time until which an appointment is valid. Until is of type IReference(DateTime) and is NULL by default. Until is mutually exclusive with Occurrences .
 */
until: Date;

/**
 * Gets or sets a AppointmentWeekOfMonth -typed value that indicates the week of the month for which the appointment occurs. The first week is the default.
 */
weekOfMonth: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentWeekOfMonth>
}


/**
 * Specifies the frequency for which an appointment occurs.
 */

declare  var Windows$ApplicationModel$Appointments$AppointmentRecurrenceUnit: {|
  +daily: 0,// 0
+weekly: 1,// 1
+monthly: 2,// 2
+monthlyOnDay: 3,// 3
+yearly: 4,// 4
+yearlyOnDay: 5,// 5

|};



/**
 * Specifies the sensitivity of an appointment.
 */

declare  var Windows$ApplicationModel$Appointments$AppointmentSensitivity: {|
  +public: 0,// 0
+private: 1,// 1

|};



/**
 * Represents a store that contains appointments.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentStore  {

/**
 * Returns the AppointmentStoreChangeTracker associated with the appointment store.
 */
changeTracker: Windows$ApplicationModel$Appointments$AppointmentStoreChangeTracker;

/**
 * Asynchronously creates a new AppointmentCalendar within the appointment store using the specified parameters.
 * @param name The name for the new AppointmentCalendar .
 * @return An async operation that provides access to the newly created AppointmentCalendar .
 */
createAppointmentCalendarAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Appointments$AppointmentCalendar>;

/**
 * Asynchronously creates a new AppointmentCalendar within the appointment store with the specified name and user data account ID.
 * @param name The name for the new AppointmentCalendar .
 * @param userDataAccountId The identifier for the user data account used to create the AppointmentCalendar .
 * @return An async operation that provides access to the newly created AppointmentCalendar .
 */
createAppointmentCalendarAsync(
name: string,
userDataAccountId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Appointments$AppointmentCalendar>;

/**
 * Retrieves a list of appointment calendars in the appointment store that meet the criteria specified by the supplied FindAppointmentCalendarsOptions object..
 * @param options The object that specifies the criteria that determines which appointment calendars are returned.
 * @return An asynchronous operation that returns an IVectorView upon successful completion.
 */
findAppointmentCalendarsAsync(
options: $Values<typeof Windows$ApplicationModel$Appointments$FindAppointmentCalendarsOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a list of all of the appointment calendars in the appointment store.
 * @return An asynchronous operation that returns an IVectorView upon successful completion.
 */
findAppointmentCalendarsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a list of appointments in the appointment calendar that fall within the specified date range.
 * @param rangeStart The start of the date range for which appointments are retrieved.
 * @param rangeLength The length of the date range for which appointments are retrieved.
 * @return An asynchronous operation that returns an IVectorView upon successful completion.
 */
findAppointmentsAsync(
rangeStart: Date,
rangeLength: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a list of appointments in the appointment calendar that fall within the specified date range and meet the criteria specified by the supplied FindAppointmentsOptions object..
 * @param rangeStart The start of the date range for which appointments are retrieved.
 * @param rangeLength The length of the date range for which appointments are retrieved.
 * @param options The object that specifies the criteria that determines which appointments are returned.
 * @return An asynchronous operation that returns an IVectorView upon successful completion.
 */
findAppointmentsAsync(
rangeStart: Date,
rangeLength: number,
options: Windows$ApplicationModel$Appointments$FindAppointmentsOptions): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Returns an AppointmentConflictResult representing a conflict between the specified appointment and an existing appointment instance in the appointment store.
 * @param appointment The appointment for which a conflict is sought.
 * @param instanceStartTime The start time of the appointment instance for which a conflict is sought.
 * @return An asynchronous operation that returns an AppointmentConflictResult upon successful completion.
 */
findConflictAsync(
appointment: Windows$ApplicationModel$Appointments$Appointment,
instanceStartTime: Date): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Appointments$AppointmentConflictResult>;

/**
 * Returns an AppointmentConflictResult representing a conflict between the specified appointment and an existing appointment in the appointment store.
 * @param appointment The appointment for which a conflict is sought.
 * @return An asynchronous operation that returns an AppointmentConflictResult upon successful completion.
 */
findConflictAsync(
appointment: Windows$ApplicationModel$Appointments$Appointment): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Appointments$AppointmentConflictResult>;

/**
 * Returns a list of LocalId values for appointment instances with the specified RoamingId value.
 * @param roamingId The RoamingId value for which local ID values are sought.
 * @return An asynchronous operation that returns an IVectorView upon successful completion.
 */
findLocalIdsFromRoamingIdAsync(
roamingId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves the Appointment with the specified LocalId .
 * @param localId The LocalId of the appointment to be retrieved.
 * @return An asynchronous operation that returns an Appointment upon successful completion.
 */
getAppointmentAsync(
localId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Appointments$Appointment>;

/**
 * Retrieves the AppointmentCalendar with the specified LocalId or RemoteId .
 * @param calendarId The LocalId or RemoteId of the AppointmentCalendar to be retrieved.
 * @return An asynchronous operation that returns an AppointmentCalendar upon successful completion.
 */
getAppointmentCalendarAsync(
calendarId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Appointments$AppointmentCalendar>;

/**
 * Retrieves the instance of the Appointment with the specified LocalId and the specified start time.
 * @param localId The LocalId of the appointment instance to be retrieved.
 * @param instanceStartTime The start time of the appointment instance to be retrieved.
 * @return An asynchronous operation that returns an Appointment upon successful completion.
 */
getAppointmentInstanceAsync(
localId: string,
instanceStartTime: Date): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Appointments$Appointment>;

/**
 * Moves the specified Appointment object to the specified AppointmentCalendar .
 * @param appointment The appointment to be moved.
 * @param destinationCalendar The appointment calendar to which the appointment is moved.
 * @return An asynchronous action.
 */
moveAppointmentAsync(
appointment: Windows$ApplicationModel$Appointments$Appointment,
destinationCalendar: Windows$ApplicationModel$Appointments$AppointmentCalendar): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Occurs when the AppointmentStore changes.
 */
onstorechanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Appointments$AppointmentStore, Windows$ApplicationModel$Appointments$AppointmentStoreChangedEventArgs>;
addEventListener(
type: "storechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Appointments$AppointmentStore, Windows$ApplicationModel$Appointments$AppointmentStoreChangedEventArgs>): void;
removeEventListener(
type: "storechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Appointments$AppointmentStore, Windows$ApplicationModel$Appointments$AppointmentStoreChangedEventArgs>): void;

/**
 * Shows the Appointments provider Add Appointment UI, to enable the user to add an appointment.
 * @param appointment The object representing the information for the appointment to add.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Add Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Add Appointment UI displays around the button, not overlapping it.
 * @return When this method completes, it returns a String object that represents the RoamingId of the appointment. If the appointment identifier returned is an empty string, the appointment was not added to the Appointments provider app.
 */
showAddAppointmentAsync(
appointment: Windows$ApplicationModel$Appointments$Appointment,
selection: Windows$Foundation$Rect): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Shows the Appointments provider Appointment Details UI, to enable the user to view the specified appointment.
 * @param localId The LocalId of the appointment to be displayed.
 * @return An asynchronous action.
 */
showAppointmentDetailsAsync(localId: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Shows the Appointments provider Appointment Details UI, to enable the user to view the specified appointment.
 * @param localId The LocalId of the appointment to be displayed.
 * @param instanceStartDate A DateTime object with the start time of the appointment instance to be displayed.
 * @return An asynchronous action.
 */
showAppointmentDetailsAsync(
localId: string,
instanceStartDate: Date): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Shows the Appointments provider Add Appointment UI including the full edit experience, to enable the user to add an appointment.
 * @param appointment The appointment to be added.
 * @return When this method completes, it returns a String object that represents the RoamingId of the appointment. If the appointment identifier returned is an empty string, the appointment was not added to the Appointments provider app.
 */
showEditNewAppointmentAsync(
appointment: Windows$ApplicationModel$Appointments$Appointment): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Shows the Appointments provider Remove Appointment UI, to enable the user to remove an appointment.
 * @param localId The LocalId of the appointment to be removed.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Remove Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Remove Appointment UI displays around the button, not overlapping it.
 * @return When this method completes, it returns a Boolean value that indicates whether the Appointment provider app removed the appointment.
 */
showRemoveAppointmentAsync(
localId: string,
selection: Windows$Foundation$Rect): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Shows the Appointments provider Remove Appointment UI, to enable the user to remove an appointment.
 * @param localId The LocalId of the appointment to be removed.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Remove Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Remove Appointment UI displays around the button, not overlapping it.
 * @param preferredPlacement The Placement that describes the preferred placement of the Remove Appointment UI.
 * @param instanceStartDate The start date and time of the appointment instance to remove.
 * @return When this method completes, it returns a Boolean value that indicates whether the Appointment provider app removed the appointment.
 */
showRemoveAppointmentAsync(
localId: string,
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>,
instanceStartDate: Date): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Shows the Appointments provider Replace Appointment UI, to enable the user to replace an appointment.
 * @param localId The LocalId of the appointment to be replaced.
 * @param appointment The object representing the appointment to replace the existing appointment.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Replace Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Replace Appointment UI displays around the button, not overlapping it.
 * @return When this method completes, it returns a String object that represents the RoamingId of the appointment that replaced the existing appointment.
 */
showReplaceAppointmentAsync(
localId: string,
appointment: Windows$ApplicationModel$Appointments$Appointment,
selection: Windows$Foundation$Rect): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Shows the Appointments provider Replace Appointment UI, to enable the user to replace an appointment.
 * @param localId The LocalId of the appointment to be replaced.
 * @param appointment The object representing the appointment to replace the existing appointment.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Replace Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Replace Appointment UI displays around the button, not overlapping it.
 * @param preferredPlacement The Placement that describes the preferred placement of the Replace Appointment UI.
 * @param instanceStartDate The start date and time of the appointment instance to replace.
 * @return When this method completes, it returns a String object that represents the RoamingId of the appointment that replaced the existing appointment.
 */
showReplaceAppointmentAsync(
localId: string,
appointment: Windows$ApplicationModel$Appointments$Appointment,
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>,
instanceStartDate: Date): Windows$Foundation$IPromiseWithIAsyncOperation<string>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies the level of access granted to an AppointmentStore .
 */

declare  var Windows$ApplicationModel$Appointments$AppointmentStoreAccessType: {|
  +appCalendarsReadWrite: 0,// 0
+allCalendarsReadOnly: 1,// 1
+allCalendarsReadWrite: 2,// 2

|};



/**
 * Represents a change that has occurred in an appointment store.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentStoreChange  {

/**
 * Gets the Appointment associated with the change.
 */
appointment: Windows$ApplicationModel$Appointments$Appointment;

/**
 * Gets the AppointmentCalendar in which the change occurred.
 */
appointmentCalendar: Windows$ApplicationModel$Appointments$AppointmentCalendar;

/**
 * Gets an AppointmentStoreChangeType value indicating the type of change represented by the object.
 */
changeType: $Values<typeof Windows$ApplicationModel$Appointments$AppointmentStoreChangeType>
}


/**
 * Enables the calling app to read through the changes to appointments in its appointment store.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentStoreChangeReader  {

/**
 * Tells the system that all of the changes to appointments returned by the call to ReadBatchAsync have been addressed by the app.
 */
acceptChanges(): void;

/**
 * Tells the system that all of the changes to appointments returned by the call to ReadBatchAsync , up to the specified AppointmentStoreChange , have been addressed by the app.
 * @param lastChangeToAccept The AppointmentStoreChange object indicating the latest change that has been addressed by the app.
 */
acceptChangesThrough(
lastChangeToAccept: Windows$ApplicationModel$Appointments$AppointmentStoreChange): void;

/**
 * Returns a list of the changes that have occurred in the appointment store that have not yet been accepted by the calling app.
 * @return An asynchronous operation that returns an IVectorView upon successful completion.
 */
readBatchAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>
}


/**
 * Provides APIs for managing change tracking for appointments.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentStoreChangeTracker  {
enable: any;
getChangeReader: any;
reset: any
}


/**
 * Specifies the type of change represented by an AppointmentStoreChange object.
 */

declare  var Windows$ApplicationModel$Appointments$AppointmentStoreChangeType: {|
  +appointmentCreated: 0,// 0
+appointmentModified: 1,// 1
+appointmentDeleted: 2,// 2
+changeTrackingLost: 3,// 3
+calendarCreated: 4,// 4
+calendarModified: 5,// 5
+calendarDeleted: 6,// 6

|};



/**
 * Represents a background task deferral returned by the AppointmentStoreChangedEventArgs.GetDeferral method.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentStoreChangedDeferral  {

/**
 * Informs the system that an asynchronous operation associated with an AppointmentStore has finished.
 */
complete(): void
}


/**
 * Provides data for a StoreChanged event.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentStoreChangedEventArgs  {

/**
 * Gets the deferral object for the StoreChanged event.
 * @return The deferral object for the StoreChanged event.
 */
getDeferral(): Windows$ApplicationModel$Appointments$AppointmentStoreChangedDeferral
}


/**
 * Passed to a background task to indicate that the task was invoked by an AppointmentStore .
 */
declare class Windows$ApplicationModel$Appointments$AppointmentStoreNotificationTriggerDetails  {}


/**
 * Specifies how the summary card for an appointment is displayed.
 */

declare  var Windows$ApplicationModel$Appointments$AppointmentSummaryCardView: {|
  +system: 0,// 0
+app: 1,// 1

|};



/**
 * Specifies the week of the month for which the appointment occurs.
 */

declare  var Windows$ApplicationModel$Appointments$AppointmentWeekOfMonth: {|
  +first: 0,// 0
+second: 1,// 1
+third: 2,// 2
+fourth: 3,// 3
+last: 4,// 4

|};



      declare var npm$namespace$Windows$ApplicationModel$Appointments$AppointmentsProvider: {
        
        
        
        AddAppointmentOperation: typeof Windows$ApplicationModel$Appointments$AppointmentsProvider$AddAppointmentOperation,
AppointmentsProviderLaunchActionVerbs: typeof Windows$ApplicationModel$Appointments$AppointmentsProvider$AppointmentsProviderLaunchActionVerbs,
RemoveAppointmentOperation: typeof Windows$ApplicationModel$Appointments$AppointmentsProvider$RemoveAppointmentOperation,
ReplaceAppointmentOperation: typeof Windows$ApplicationModel$Appointments$AppointmentsProvider$ReplaceAppointmentOperation,
        
      }

/**
 * Represents the operation object associated with adding a new appointment. Appointments provider apps use this info to perform the operation.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentsProvider$AddAppointmentOperation  {

/**
 * Gets the Appointment info from the activation request.
 */
appointmentInformation: Windows$ApplicationModel$Appointments$Appointment;

/**
 * Dismisses the UI for the operation that adds a new appointment.
 */
dismissUI(): void;

/**
 * Call this method to inform the activating app that the operation was canceled by the user.
 */
reportCanceled(): void;

/**
 * Call this method to inform the activating app that the operation was completed successfully. Provide a unique appointment ID as the itemID parameter.
 * @param itemId A unique appointment ID that the activating app can later use to remove this appointment if necessary.
 */
reportCompleted(itemId: string): void;

/**
 * Informs the activating app that the operation couldn't be completed because of a provider error.
 * @param value A string that contains info about the error.
 */
reportError(value: string): void;

/**
 * Gets the package family name of the app that is requesting the operation.
 */
sourcePackageFamilyName: string
}


/**
 * Represents the object associated with retrieving the operation of the appointments provider.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentsProvider$AppointmentsProviderLaunchActionVerbs  {

/**
 * Gets the add-appointment action that the appointments provider performs.
 */
static addAppointment: string;

/**
 * Gets the remove-appointment action that the appointments provider performs.
 */
static removeAppointment: string;

/**
 * Gets the replace-appointment action that the appointments provider performs.
 */
static replaceAppointment: string;

/**
 * Gets the show-appointment-details action that the appointments provider performs.
 */
static showAppointmentDetails: string;

/**
 * Gets the show-time-frame action of an appointment that the appointments provider performs.
 */
static showTimeFrame: string
}


/**
 * Represents the operation object associated with removing an appointment. Appointments provider apps use this info to perform the operation.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentsProvider$RemoveAppointmentOperation  {

/**
 * Gets the unique identifier of the appointment to remove.
 */
appointmentId: string;

/**
 * Dismisses the UI for the operation that removes an appointment.
 */
dismissUI(): void;

/**
 * Gets the start date and time of the appointment instance to remove.
 */
instanceStartDate: Date;

/**
 * Call this method to inform the activating app that the operation was canceled by the user.
 */
reportCanceled(): void;

/**
 * Informs the activating app that the operation was completed successfully.
 */
reportCompleted(): void;

/**
 * Informs the activating app that the operation couldn't be completed because of a provider error.
 * @param value A string that contains info about the error.
 */
reportError(value: string): void;

/**
 * Gets the package family name of the app that is requesting the operation.
 */
sourcePackageFamilyName: string
}


/**
 * Represents the operation object associated with replacing an appointment. Appointments provider apps use this info to perform the operation.
 */
declare class Windows$ApplicationModel$Appointments$AppointmentsProvider$ReplaceAppointmentOperation  {

/**
 * Gets the unique identifier of the appointment to replace.
 */
appointmentId: string;

/**
 * Gets the Appointment info from the activation request.
 */
appointmentInformation: Windows$ApplicationModel$Appointments$Appointment;

/**
 * Dismisses the UI for the operation that replaces an appointment.
 */
dismissUI(): void;

/**
 * Gets the start date and time of the appointment instance to replace.
 */
instanceStartDate: Date;

/**
 * Informs the activating app that the operation was canceled by the user.
 */
reportCanceled(): void;

/**
 * Informs the activating app that the operation was completed successfully.
 * @param itemId A unique appointment ID that the activating app can later use to remove this appointment if necessary or to replace it again.
 */
reportCompleted(itemId: string): void;

/**
 * Informs the activating app that the operation couldn't be completed because of a provider error.
 * @param value A string that contains info about the error.
 */
reportError(value: string): void;

/**
 * Gets the package family name of the app that is requesting the operation.
 */
sourcePackageFamilyName: string
}


/**
 * Specifies additional options when querying for appointment calendars.
 */

declare  var Windows$ApplicationModel$Appointments$FindAppointmentCalendarsOptions: {|
  +none: 0,// 0
+includeHidden: 1,// 1

|};



/**
 * Represents a set of options that modifies a query for appointments.
 */
declare class Windows$ApplicationModel$Appointments$FindAppointmentsOptions  {
calendarIds: any;
fetchProperties: any;
includeHidden: any;
maxCount: any
}


/**
 * Specifies the recurrence type of an appointment.
 */

declare  var Windows$ApplicationModel$Appointments$RecurrenceType: {|
  +master: 0,// 0
+instance: 1,// 1
+exceptionInstance: 2,// 2

|};



      declare var npm$namespace$Windows$ApplicationModel$Background: {
        
        
        AlarmAccessStatus: typeof Windows$ApplicationModel$Background$AlarmAccessStatus,
ApplicationTriggerResult: typeof Windows$ApplicationModel$Background$ApplicationTriggerResult,
BackgroundAccessStatus: typeof Windows$ApplicationModel$Background$BackgroundAccessStatus,
BackgroundTaskCancellationReason: typeof Windows$ApplicationModel$Background$BackgroundTaskCancellationReason,
BackgroundTaskThrottleCounter: typeof Windows$ApplicationModel$Background$BackgroundTaskThrottleCounter,
BackgroundWorkCostValue: typeof Windows$ApplicationModel$Background$BackgroundWorkCostValue,
DeviceTriggerResult: typeof Windows$ApplicationModel$Background$DeviceTriggerResult,
LocationTriggerType: typeof Windows$ApplicationModel$Background$LocationTriggerType,
MediaProcessingTriggerResult: typeof Windows$ApplicationModel$Background$MediaProcessingTriggerResult,
SystemConditionType: typeof Windows$ApplicationModel$Background$SystemConditionType,
SystemTriggerType: typeof Windows$ApplicationModel$Background$SystemTriggerType,
        ActivitySensorTrigger: typeof Windows$ApplicationModel$Background$ActivitySensorTrigger,
AlarmApplicationManager: typeof Windows$ApplicationModel$Background$AlarmApplicationManager,
ApplicationTrigger: typeof Windows$ApplicationModel$Background$ApplicationTrigger,
ApplicationTriggerDetails: typeof Windows$ApplicationModel$Background$ApplicationTriggerDetails,
AppointmentStoreNotificationTrigger: typeof Windows$ApplicationModel$Background$AppointmentStoreNotificationTrigger,
BackgroundExecutionManager: typeof Windows$ApplicationModel$Background$BackgroundExecutionManager,
BackgroundTaskBuilder: typeof Windows$ApplicationModel$Background$BackgroundTaskBuilder,
BackgroundTaskCompletedEventArgs: typeof Windows$ApplicationModel$Background$BackgroundTaskCompletedEventArgs,
BackgroundTaskDeferral: typeof Windows$ApplicationModel$Background$BackgroundTaskDeferral,
BackgroundTaskProgressEventArgs: typeof Windows$ApplicationModel$Background$BackgroundTaskProgressEventArgs,
BackgroundTaskRegistration: typeof Windows$ApplicationModel$Background$BackgroundTaskRegistration,
BackgroundWorkCost: typeof Windows$ApplicationModel$Background$BackgroundWorkCost,
BluetoothLEAdvertisementPublisherTrigger: typeof Windows$ApplicationModel$Background$BluetoothLEAdvertisementPublisherTrigger,
BluetoothLEAdvertisementWatcherTrigger: typeof Windows$ApplicationModel$Background$BluetoothLEAdvertisementWatcherTrigger,
CachedFileUpdaterTrigger: typeof Windows$ApplicationModel$Background$CachedFileUpdaterTrigger,
CachedFileUpdaterTriggerDetails: typeof Windows$ApplicationModel$Background$CachedFileUpdaterTriggerDetails,
ChatMessageNotificationTrigger: typeof Windows$ApplicationModel$Background$ChatMessageNotificationTrigger,
ChatMessageReceivedNotificationTrigger: typeof Windows$ApplicationModel$Background$ChatMessageReceivedNotificationTrigger,
ContactStoreNotificationTrigger: typeof Windows$ApplicationModel$Background$ContactStoreNotificationTrigger,
ContentPrefetchTrigger: typeof Windows$ApplicationModel$Background$ContentPrefetchTrigger,
DeviceConnectionChangeTrigger: typeof Windows$ApplicationModel$Background$DeviceConnectionChangeTrigger,
DeviceManufacturerNotificationTrigger: typeof Windows$ApplicationModel$Background$DeviceManufacturerNotificationTrigger,
DeviceServicingTrigger: typeof Windows$ApplicationModel$Background$DeviceServicingTrigger,
DeviceUseTrigger: typeof Windows$ApplicationModel$Background$DeviceUseTrigger,
DeviceWatcherTrigger: typeof Windows$ApplicationModel$Background$DeviceWatcherTrigger,
EmailStoreNotificationTrigger: typeof Windows$ApplicationModel$Background$EmailStoreNotificationTrigger,
GattCharacteristicNotificationTrigger: typeof Windows$ApplicationModel$Background$GattCharacteristicNotificationTrigger,
LocationTrigger: typeof Windows$ApplicationModel$Background$LocationTrigger,
MaintenanceTrigger: typeof Windows$ApplicationModel$Background$MaintenanceTrigger,
MediaProcessingTrigger: typeof Windows$ApplicationModel$Background$MediaProcessingTrigger,
MobileBroadbandDeviceServiceNotificationTrigger: typeof Windows$ApplicationModel$Background$MobileBroadbandDeviceServiceNotificationTrigger,
MobileBroadbandPinLockStateChangeTrigger: typeof Windows$ApplicationModel$Background$MobileBroadbandPinLockStateChangeTrigger,
MobileBroadbandRadioStateChangeTrigger: typeof Windows$ApplicationModel$Background$MobileBroadbandRadioStateChangeTrigger,
MobileBroadbandRegistrationStateChangeTrigger: typeof Windows$ApplicationModel$Background$MobileBroadbandRegistrationStateChangeTrigger,
NetworkOperatorHotspotAuthenticationTrigger: typeof Windows$ApplicationModel$Background$NetworkOperatorHotspotAuthenticationTrigger,
NetworkOperatorNotificationTrigger: typeof Windows$ApplicationModel$Background$NetworkOperatorNotificationTrigger,
PhoneTrigger: typeof Windows$ApplicationModel$Background$PhoneTrigger,
PushNotificationTrigger: typeof Windows$ApplicationModel$Background$PushNotificationTrigger,
RcsEndUserMessageAvailableTrigger: typeof Windows$ApplicationModel$Background$RcsEndUserMessageAvailableTrigger,
RfcommConnectionTrigger: typeof Windows$ApplicationModel$Background$RfcommConnectionTrigger,
SensorDataThresholdTrigger: typeof Windows$ApplicationModel$Background$SensorDataThresholdTrigger,
SmsMessageReceivedTrigger: typeof Windows$ApplicationModel$Background$SmsMessageReceivedTrigger,
SocketActivityTrigger: typeof Windows$ApplicationModel$Background$SocketActivityTrigger,
StorageLibraryContentChangedTrigger: typeof Windows$ApplicationModel$Background$StorageLibraryContentChangedTrigger,
SystemCondition: typeof Windows$ApplicationModel$Background$SystemCondition,
SystemTrigger: typeof Windows$ApplicationModel$Background$SystemTrigger,
TimeTrigger: typeof Windows$ApplicationModel$Background$TimeTrigger,
ToastNotificationActionTrigger: typeof Windows$ApplicationModel$Background$ToastNotificationActionTrigger,
ToastNotificationHistoryChangedTrigger: typeof Windows$ApplicationModel$Background$ToastNotificationHistoryChangedTrigger,
        
      }

/**
 * Represents a trigger that is activated when the ActivitySensor receives input. This is used when your application needs to respond to the activity sensor.
 */
declare class Windows$ApplicationModel$Background$ActivitySensorTrigger  {

/**
 * Creates an instance of the ActivitySensorTrigger class with an initial MinimumReportInterval .
 * @param reportIntervalInMilliseconds The initial report interval to use for MinimumReportInterval .
 */
constructor(reportIntervalInMilliseconds: number): this;

/**
 * Gets the minimum supported report interval for the sensor trigger.
 */
minimumReportInterval: number;

/**
 * Gets the report interval for the trigger.
 */
reportInterval: number;

/**
 * Gets or sets the list of activities your trigger is subscribed to.
 */
subscribedActivities: Windows$Foundation$Collections$IVector<$Values<typeof Windows$Devices$Sensors$ActivityType>>;

/**
 * Gets the list of supported activities you can subscribe to.
 */
supportedActivities: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Devices$Sensors$ActivityType>>
}


/**
 * Indicates whether the user has given permission for the app to set alarms.
 */

declare  var Windows$ApplicationModel$Background$AlarmAccessStatus: {|
  +unspecified: 0,// 0
+allowedWithWakeupCapability: 1,// 1
+allowedWithoutWakeupCapability: 2,// 2
+denied: 3,// 3

|};



/**
 * Requests permission from the user to set alarms, and retrieves the status of user permission for the app to set alarms.
 */
declare class Windows$ApplicationModel$Background$AlarmApplicationManager  {

/**
 * Retrieves the status of user permission for the app to set alarms.
 * @return Indicates whether the user has granted permission to set alarms.
 */
static getAccessStatus(): $Values<typeof Windows$ApplicationModel$Background$AlarmAccessStatus>;

/**
 * Requests permission from the user to set alarms.
 * @return This method returns an AlarmAccessStatus value when it completes.
 */
static requestAccessAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$Background$AlarmAccessStatus>>
}


/**
 * This is used to trigger background tasks.
 */
declare class Windows$ApplicationModel$Background$ApplicationTrigger  {

/**
 * Creates a new ApplicationTrigger class
 */
constructor(): this;

/**
 * This method attempts to set the trigger and start the registered background task with specified arguments.
 * @param arguments The serialized arguments that are passed to the background task.
 * @return Returns an ApplicationTriggerResult enumeration that indicates whether the user provided the necessary consent for the operation or the system policies didn't reject the request to trigger a background task.
 */
requestAsync(
args: Windows$Foundation$Collections$ValueSet): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$Background$ApplicationTriggerResult>>;

/**
 * This method attempts to set the trigger and start the registered background task.
 * @return Returns an ApplicationTriggerResult enumeration that indicates whether the user provided the necessary consent for the operation or the system policies didn't reject the request to trigger a background task.
 */
requestAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$Background$ApplicationTriggerResult>>
}


/**
 * (Applies to Windows Phone only) The details of an ApplicationTrigger .
 */
declare class Windows$ApplicationModel$Background$ApplicationTriggerDetails  {

/**
 * The arguments that were passed to the background task using the ApplicationTrigger.RequestAsync(ValueSet) method.
 */
arguments: Windows$Foundation$Collections$ValueSet
}


/**
 * The result of the request to trigger a background task. The RequestAsync method returns a value of this enumeration type.
 */

declare  var Windows$ApplicationModel$Background$ApplicationTriggerResult: {|
  +allowed: 0,// 0
+currentlyRunning: 1,// 1
+disabledByPolicy: 2,// 2
+unknownError: 3,// 3

|};



/**
 * Represents a trigger that launches a background task for processing changes to the appointment store.
 */
declare class Windows$ApplicationModel$Background$AppointmentStoreNotificationTrigger  {

/**
 * Initializes a new instance of the AppointmentStoreNotificationTrigger class.
 */
constructor(): this
}


/**
 * On Windows, this enumeration specifies an app's ability to perform background activity and display a tile on the lock screen. For Windows Phone Store apps, it only indicates an app's ability to perform background activity.
 */

declare  var Windows$ApplicationModel$Background$BackgroundAccessStatus: {|
  +unspecified: 0,// 0
+allowedWithAlwaysOnRealTimeConnectivity: 1,// 1
+allowedMayUseActiveRealTimeConnectivity: 2,// 2
+denied: 3,// 3

|};



/**
 * Provides methods that let an app ask to be added to the lock screen's apps list or query its current access to background activity and badge updates on the lock screen.
 */
declare class Windows$ApplicationModel$Background$BackgroundExecutionManager  {

/**
 * Gets the ability of the calling lock screen app to perform background activity and update its badge.
 * @return One of the enumeration values that specify the app's capabilities on the lock screen.
 */
static getAccessStatus(): $Values<typeof Windows$ApplicationModel$Background$BackgroundAccessStatus>;

/**
 * Gets the ability of a specific lock screen app to perform background activity and update its badge.
 * @param applicationId The Package Relative Application ID (PRAID) of the app whose capabilities are being retrieved. The specified app must be in the same package as the calling app.
 * @return One of the enumeration values that specify the app's capabilities on the lock screen.
 */
static getAccessStatus(
applicationId: string): $Values<typeof Windows$ApplicationModel$Background$BackgroundAccessStatus>;

/**
 * Removes a specific app from the lock screen's apps list.
 * @param applicationId The Package Relative Application ID (PRAID) of the app to be removed from the lock screen. The specified app must be in the same package as the calling app.
 */
static removeAccess(applicationId: string): void;

/**
 * Removes the calling app from the lock screen's apps list.
 */
static removeAccess(): void;

/**
 * Requests access for an app to run background tasks.
 * @param applicationId The Package Relative Application ID (PRAID) of the app to be added to the lock screen. The specified app must be in the same package as the calling app.
 * @return The object, bound to the app specified by applicationId, that is used to request that the app be added to the lock screen's apps list. When the operation completes, it returns a member of the BackgroundAccessStatus enumeration that specifies the outcome.
 */
static requestAccessAsync(
applicationId: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$Background$BackgroundAccessStatus>>;

/**
 * Requests access for an app to run background tasks.
 * @return The object, bound to the calling app, that is used to request that the app be added to the lock screen's apps list. When the operation completes, it returns a member of the BackgroundAccessStatus enumeration that specifies the outcome.
 */
static requestAccessAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$Background$BackgroundAccessStatus>>
}


/**
 * Represents a background task to be registered with the system.
 */
declare class Windows$ApplicationModel$Background$BackgroundTaskBuilder  {

/**
 * Creates an instance of the BackgroundTaskBuilder class.
 */
constructor(): this;

/**
 * Adds a condition to a background task.
 * @param condition An instance of a SystemCondition object.
 */
addCondition(condition: Windows$ApplicationModel$Background$IBackgroundCondition): void;

/**
 * Indicates whether the background task will be canceled if at least one of its required conditions is no longer met.
 */
cancelOnConditionLoss: boolean;

/**
 * This API is not available to all Windows/Windows Phone apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
isNetworkRequested: boolean;

/**
 * Gets or sets the name of a background task.
 */
name: string;

/**
 * Registers a background task with the system.
 * @return An instance of a BackgroundTaskRegistration object.
 */
register(): Windows$ApplicationModel$Background$BackgroundTaskRegistration;

/**
 * Sets the event trigger for a background task.
 * @param trigger An instance of an event trigger object such as a SystemTrigger , TimeTrigger , or NetworkOperatorNotificationTrigger .
 */
setTrigger(trigger: Windows$ApplicationModel$Background$IBackgroundTrigger): void;

/**
 * Gets or sets the class that performs the work of a background task.
 */
taskEntryPoint: string
}


/**
 * Specifies the reasons for cancelling a background task.
 */

declare  var Windows$ApplicationModel$Background$BackgroundTaskCancellationReason: {|
  +abort: 0,// 0
+terminating: 1,// 1
+loggingOff: 2,// 2
+servicingUpdate: 3,// 3
+idleTask: 4,// 4
+uninstall: 5,// 5
+conditionLoss: 6,// 6
+systemPolicy: 7,// 7
+quietHoursEntered: 8,// 8
+executionTimeExceeded: 9,// 9
+resourceRevocation: 10,// 10
+energySaver: 11,// 11

|};



/**
 * Represents completion information for a task at the time a completion notification is sent.
 */
declare class Windows$ApplicationModel$Background$BackgroundTaskCompletedEventArgs  {

/**
 * Throws an exception if the background task completed event has reported an error.
 */
checkResult(): void;

/**
 * Gets the identifier of the background task instance for this completion status notification.
 */
instanceId: string
}


/**
 * Represents a background task deferral returned by the IBackgroundTaskInstance.GetDeferral method.
 */
declare class Windows$ApplicationModel$Background$BackgroundTaskDeferral  {

/**
 * Informs the system that an asynchronous operation associated with a background task has finished.
 */
complete(): void
}


/**
 * Represents progress information for a task at the time a progress update notification is sent.
 */
declare class Windows$ApplicationModel$Background$BackgroundTaskProgressEventArgs  {

/**
 * Gets the identifier of the background task instance for this progress status notification.
 */
instanceId: string;

/**
 * Gets progress status for a background task instance.
 */
progress: number
}


/**
 * Represents a background task that has been registered with the system.
 */
declare class Windows$ApplicationModel$Background$BackgroundTaskRegistration  {

/**
 * Enumerates an application's registered background tasks.
 */
static allTasks: Windows$Foundation$Collections$IMapView<string, Windows$ApplicationModel$Background$IBackgroundTaskRegistration>;

/**
 * Gets the name of a registered background task.
 */
name: string;

/**
 * Attaches a completed event handler to the registered background task.
 */
oncompleted: Windows$ApplicationModel$Background$BackgroundTaskCompletedEventHandler;
addEventListener(
type: "completed",
listener: Windows$ApplicationModel$Background$BackgroundTaskCompletedEventHandler): void;
removeEventListener(
type: "completed",
listener: Windows$ApplicationModel$Background$BackgroundTaskCompletedEventHandler): void;

/**
 * Attaches a progress event handler to the registered background task.
 */
onprogress: Windows$ApplicationModel$Background$BackgroundTaskProgressEventHandler;
addEventListener(
type: "progress",
listener: Windows$ApplicationModel$Background$BackgroundTaskProgressEventHandler): void;
removeEventListener(
type: "progress",
listener: Windows$ApplicationModel$Background$BackgroundTaskProgressEventHandler): void;

/**
 * Gets the identifier of a registered background task.
 */
taskId: string;

/**
 * This is not intended for use in your code. For all unsupported trigger types, the value returned by this property is null.
 */
trigger: Windows$ApplicationModel$Background$IBackgroundTrigger;

/**
 * Cancels the registration of a registered background task.
 * @param cancelTask True if currently running instances of this background task should be canceled. If this parameter is false, currently running instances are allowed to finish. Canceled instances receive a Canceled event with a cancellation reason of Abort.
 */
unregister(cancelTask: boolean): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Indicates the type of throttle count to check for in a GetThrottleCount request.
 */

declare  var Windows$ApplicationModel$Background$BackgroundTaskThrottleCounter: {|
  +all: 0,// 0
+cpu: 1,// 1
+network: 2,// 2

|};



/**
 * Retrieves a hint about resource availability for background tasks. Background tasks can use this hint to decide how much work to do when they are activated.
 */
declare class Windows$ApplicationModel$Background$BackgroundWorkCost  {

/**
 * Retrieves a hint about resource availability for background tasks.
 */
static currentBackgroundWorkCost: $Values<typeof Windows$ApplicationModel$Background$BackgroundWorkCostValue>
}


/**
 * Indicates the current cost of doing background work. Used as a hint to background tasks about how much work they can do.
 */

declare  var Windows$ApplicationModel$Background$BackgroundWorkCostValue: {|
  +low: 0,// 0
+medium: 1,// 1
+high: 2,// 2

|};



/**
 * Represents a trigger that is registered to advertise a Bluetooth LE advertisement in the background.
 */
declare class Windows$ApplicationModel$Background$BluetoothLEAdvertisementPublisherTrigger  {

/**
 * Creates a new instance of the BluetoothLEAdvertisementPublisherTrigger class.
 */
constructor(): this;

/**
 * Gets the Bluetooth LE advertisement to configure and publish in the background.
 */
advertisement: Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisement
}


/**
 * Represents a trigger that is registered to scan for Bluetooth LE advertisement in the background.
 */
declare class Windows$ApplicationModel$Background$BluetoothLEAdvertisementWatcherTrigger  {

/**
 * Creates a new instance of the BluetoothLEAdvertisementWatcherTrigger class.
 */
constructor(): this;

/**
 * Gets or sets the configuration of Bluetooth LE advertisement filtering that uses payload section-based filtering.
 */
advertisementFilter: Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementFilter;

/**
 * Gets the maximum out of range timeout supported for the SignalStrengthFilter property of this trigger.
 */
maxOutOfRangeTimeout: number;

/**
 * Gets the maximum sampling interval supported for the SignalStrengthFilter property of this trigger. The maximum sampling interval is used to deactivate the sampling filter and only trigger received events based on the device coming in and out of range.
 */
maxSamplingInterval: number;

/**
 * Gets the minimum out of range timeout supported for the SignalStrengthFilter property of this trigger.
 */
minOutOfRangeTimeout: number;

/**
 * Gets the minimum sampling interval supported for the SignalStrengthFilter property of this trigger. The minimum sampling interval for the background watcher cannot be zero unlike its foreground counterpart.
 */
minSamplingInterval: number;

/**
 * Gets or sets the configuration of Bluetooth LE advertisement filtering that uses signal strength-based filtering.
 */
signalStrengthFilter: Windows$Devices$Bluetooth$BluetoothSignalStrengthFilter
}


/**
 * Represents a trigger that launches a background task to enable the Cached File Updater contract.
 */
declare class Windows$ApplicationModel$Background$CachedFileUpdaterTrigger  {

/**
 * Initializes a new instance of the CachedFileUpdaterTrigger class.
 */
constructor(): this
}


/**
 * Provides details about the cached file operation that invoked the trigger.
 */
declare class Windows$ApplicationModel$Background$CachedFileUpdaterTriggerDetails  {

/**
 * Gets whether the system can display UI allowing the user to launch provider app in response to the cached file updater trigger.
 */
canRequestUserInput: boolean;

/**
 * Gets the FileUpdateRequest object associated with the cached file update.
 */
updateRequest: Windows$Storage$Provider$FileUpdateRequest;

/**
 * Gets the CachedFileTarget object associated with cached file update that indicates whether the local or remote file should be updated.
 */
updateTarget: $Values<typeof Windows$Storage$Provider$CachedFileTarget>
}


/**
 * Represents a trigger that is activated when there is a notification for a text message.
 */
declare class Windows$ApplicationModel$Background$ChatMessageNotificationTrigger  {

/**
 * Represents a trigger that is activated when there is a notification for a text message.
 */
constructor(): this
}


/**
 * Represents a trigger that launches a background task that handles any incoming message that might need to be filtered according to its content. For more information about filtering messages, see Windows.ApplicationModel.CommunicationBlocking .
 */
declare class Windows$ApplicationModel$Background$ChatMessageReceivedNotificationTrigger  {

/**
 * Initializes a new instance of the ChatMessageReceivedNotificationTrigger class.
 */
constructor(): this
}


/**
 * Represents a trigger that launches a background task for processing changes to the contacts store.
 */
declare class Windows$ApplicationModel$Background$ContactStoreNotificationTrigger  {

/**
 * Initializes a new instance of the ContactStoreNotificationTrigger class.
 */
constructor(): this
}


/**
 * Provides the ability to run custom handlers when prefetching web resources.
 */
declare class Windows$ApplicationModel$Background$ContentPrefetchTrigger  {

/**
 * Initializes a new instance of the ContentPrefetchTrigger class.
 */
constructor(): this;

/**
 * Initializes a new instance of the ContentPrefetchTrigger class using a specified time interval.
 * @param waitInterval Interval before next allowed content prefetch.
 */
constructor(waitInterval: number): this;

/**
 * Retrieves the time interval for prefetching web content.
 */
waitInterval: number
}


/**
 * Represents a trigger that launches a background task when the connection status of a device changes.
 */
declare class Windows$ApplicationModel$Background$DeviceConnectionChangeTrigger  {

/**
 * Begins an asynchronous operation to get the DeviceConnectionChangeTrigger associated with the specified Id.
 * @param deviceId The device Id with which to find the associated trigger.
 * @return The DeviceConnectionChangeTrigger object associated with the specified device Id.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Background$DeviceConnectionChangeTrigger>;

/**
 * Gets whether the system can maintain a connection to the specified device.
 */
canMaintainConnection: boolean;

/**
 * Gets the device Id associated with the device.
 */
deviceId: string;

/**
 * Gets or sets whether the system should automatically attempt to keep the referenced device connected.
 */
maintainConnection: boolean
}


/**
 * Represents a trigger that launches a background task to enable device manufacturer operations.
 */
declare class Windows$ApplicationModel$Background$DeviceManufacturerNotificationTrigger  {

/**
 * Initializes a new instance of the DeviceManufacturerNotificationTrigger class.
 * @param triggerQualifier An app-defined string that qualifies the trigger.
 * @param oneShot Whether the trigger is used only once.
 */
constructor(triggerQualifier: string, oneShot: boolean): this;

/**
 * Gets whether the trigger is used only once.
 */
oneShot: boolean;

/**
 * Gets an app-defined string that qualifies the trigger.
 */
triggerQualifier: string
}


/**
 * Represents an event that an application can trigger to initiate a long-running update (firmware or settings) of a device.
 */
declare class Windows$ApplicationModel$Background$DeviceServicingTrigger  {

/**
 * Constructor for DeviceServicingTrigger . Takes no parameters.
 */
constructor(): this;

/**
 * Triggers the background task (settings or firmware update) and returns a DeviceTriggerResult indicating success or failure of the trigger request. Takes the DeviceInformation.ID string and an optional estimated time the background task will run. If your app cannot determine an appropriate time estimate, provide zero as the estimated time.
 * @param deviceId The DeviceInformation.ID of the device the background task will access.
 * @param expectedDuration Optional value. The expected duration of the background settings update or background firmware update. Set this value to zero if an appropriate time estimate cannot be determined.
 * @return This method returns a DeviceTriggerResult when it completes asynchronously.
 */
requestAsync(
deviceId: string,
expectedDuration: number): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$Background$DeviceTriggerResult>>;

/**
 * Triggers the background task (settings or firmware update) and returns a DeviceTriggerResult indicating success or failure of the trigger request. Takes the DeviceInformation.ID string, an optional estimated time the background task will run, and an optional app-specific string passed to the background task identifying which device operation to perform. If your app cannot determine an appropriate time estimate, provide zero as the estimated time.
 * @param deviceId The DeviceInformation.ID of the device the background task will access.
 * @param expectedDuration Optional value. The expected duration of the background settings update or background firmware update. Set this value to zero if an appropriate time estimate cannot be determined.
 * @param arguments Optional value. An app-specific string passed to the background task identifying which device operation to perform.
 * @return This method returns a DeviceTriggerResult when it completes asynchronously.
 */
requestAsync(
deviceId: string,
expectedDuration: number,
args: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$Background$DeviceTriggerResult>>
}


/**
 * Indicates whether the device background task operation was allowed or denied, and if it was denied specifies the reason.
 */

declare  var Windows$ApplicationModel$Background$DeviceTriggerResult: {|
  +allowed: 0,// 0
+deniedByUser: 1,// 1
+deniedBySystem: 2,// 2
+lowBattery: 3,// 3

|};



/**
 * Represents an event that a Windows Runtime app can trigger to initiate a long-running operation with a device or sensor.
 */
declare class Windows$ApplicationModel$Background$DeviceUseTrigger  {

/**
 * Constructor for DeviceUseTrigger . Takes no parameters.
 */
constructor(): this;

/**
 * Triggers the background task and returns a DeviceTriggerResult indicating success or failure of the trigger request. Takes the DeviceInformation.ID of the device or sensor that the background task will access, and an optional app-specific string passed to the background task identifying which operation to perform.
 * @param deviceId The DeviceInformation.ID of the device or sensor that the background task will access.
 * @param arguments Optional value. A string specified by your app and passed to the background task, identifying which operation to perform.
 * @return This method returns a DeviceTriggerResult when it completes asynchronously.
 */
requestAsync(
deviceId: string,
args: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$Background$DeviceTriggerResult>>;

/**
 * Triggers the background task and returns a DeviceTriggerResult indicating success or failure of the trigger request. Takes the DeviceInformation.ID of the device or sensor that the background task will access.
 * @param deviceId The DeviceInformation.ID of the device or sensor that the background task will access.
 * @return This method returns a DeviceTriggerResult when it completes asynchronously.
 */
requestAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$Background$DeviceTriggerResult>>
}


/**
 * Represents an event that causes a background task to run when changes occur to the list of devices.
 */
declare class Windows$ApplicationModel$Background$DeviceWatcherTrigger  {}


/**
 * Represents a trigger that enables notification of changes to the email store.
 */
declare class Windows$ApplicationModel$Background$EmailStoreNotificationTrigger  {

/**
 * Initializes a new instance of the EmailStoreNotificationTrigger class.
 */
constructor(): this
}


/**
 * Represents a trigger that launches a background task when an incoming change notification is received for a Bluetooth LE GATT characteristic.
 */
declare class Windows$ApplicationModel$Background$GattCharacteristicNotificationTrigger  {

/**
 * Initializes a new instance of the GattCharacteristicNotificationTrigger class.
 * @param characteristic The GATT characteristic for which value change notifications are desired.
 */
constructor(characteristic: Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristic): this;

/**
 * Gets the GATT characteristic for which value change notifications are desired.
 */
characteristic: Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristic
}


/**
 * Represents a location event that triggers a background task. This is used for Geofencing.
 */
declare class Windows$ApplicationModel$Background$LocationTrigger  {

/**
 * Initializes a new instance of a location event trigger.
 * @param triggerType The type of location event for this trigger.
 */
constructor(triggerType: $Values<typeof Windows$ApplicationModel$Background$LocationTriggerType>): this;

/**
 * The type of location event for this trigger.
 */
triggerType: $Values<typeof Windows$ApplicationModel$Background$LocationTriggerType>
}


/**
 * Indicates a type of location event for a location background task trigger.
 */

declare  var Windows$ApplicationModel$Background$LocationTriggerType: {|
  +geofence: 0,// 0

|};



/**
 * Represents a maintenance trigger.
 */
declare class Windows$ApplicationModel$Background$MaintenanceTrigger  {

/**
 * Initializes a new instance of a maintenance trigger.
 * @param freshnessTime The number of minutes to wait before scheduling the background task. The system schedules the task within 15 minutes after freshnessTime elapses.
 * @param oneShot True if the maintenance trigger is used once; false if it is used each time the freshnessTime interval elapses.
 */
constructor(freshnessTime: number, oneShot: boolean): this;

/**
 * Gets the interval of a maintenance trigger.
 */
freshnessTime: number;

/**
 * Gets whether the maintenance trigger is used only once or each time the FreshnessTime interval elapses.
 */
oneShot: boolean
}


/**
 * Represents a trigger that launches a background task for performing media processing.
 */
declare class Windows$ApplicationModel$Background$MediaProcessingTrigger  {

/**
 * Initializes a new instance of the MediaProcessingTrigger class.
 */
constructor(): this;

/**
 * Triggers the background task and returns a MediaProcessingTriggerResult indicating success or failure of the trigger request.
 * @return An asynchronous operation that returns a MediaProcessingTriggerResult upon completion.
 */
requestAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$Background$MediaProcessingTriggerResult>>;

/**
 * Triggers the background task with the provided collection of arguments and returns a MediaProcessingTriggerResult indicating success or failure of the trigger request.
 * @param arguments A collection of arguments that will be passed to the media processing background task.
 * @return An asynchronous operation that returns a MediaProcessingTriggerResult upon completion.
 */
requestAsync(
args: Windows$Foundation$Collections$ValueSet): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$Background$MediaProcessingTriggerResult>>
}


/**
 * Specifies the result of a call to MediaProcessingTrigger::RequestAsync .
 */

declare  var Windows$ApplicationModel$Background$MediaProcessingTriggerResult: {|
  +allowed: 0,// 0
+currentlyRunning: 1,// 1
+disabledByPolicy: 2,// 2
+unknownError: 3,// 3

|};



/**
 * Represents a trigger that activates when the network sends SIM tool commands. Apps receiving this notification then process the SIM tool commands.
 */
declare class Windows$ApplicationModel$Background$MobileBroadbandDeviceServiceNotificationTrigger  {

/**
 * Constructs a MobileBroadbandDeviceServiceNotificationTrigger object.
 */
constructor(): this
}


/**
 * Represents a trigger that indicates when the SIM PIN lock state has changed.
 */
declare class Windows$ApplicationModel$Background$MobileBroadbandPinLockStateChangeTrigger  {

/**
 * Constructs a MobileBroadbandPinLockStateChangeTrigger object.
 */
constructor(): this
}


/**
 * Represents a trigger that indicates when mobile broadband radio state has changed. For example, this trigger activates when a mobile device transitions to or from airplane mode.
 */
declare class Windows$ApplicationModel$Background$MobileBroadbandRadioStateChangeTrigger  {

/**
 * Constructs a MobileBroadbandRadioStateChangeTrigger object.
 */
constructor(): this
}


/**
 * Represents a trigger that indicates when mobile broadband registration state has changed. For example, this trigger activates when a mobile device transitions to or from Roaming.
 */
declare class Windows$ApplicationModel$Background$MobileBroadbandRegistrationStateChangeTrigger  {

/**
 * Creates a MobileBroadbandRegistrationStateChangeTrigger object.
 */
constructor(): this
}


/**
 * Represents a mobile network operator hotspot authentication trigger.
 */
declare class Windows$ApplicationModel$Background$NetworkOperatorHotspotAuthenticationTrigger  {

/**
 * Initializes a new instance of a mobile network operator hotspot authentication trigger.
 */
constructor(): this
}


/**
 * Represents a mobile network operator notification trigger.
 */
declare class Windows$ApplicationModel$Background$NetworkOperatorNotificationTrigger  {

/**
 * Initializes a new instance of a mobile network operator notification.
 * @param networkAccountId Specifies the unique identifier of the mobile broadband account.
 */
constructor(networkAccountId: string): this;

/**
 * Gets the account identifier for the mobile network operator notification trigger.
 */
networkAccountId: string
}


/**
 * Represents a phone event that triggers a background task.
 */
declare class Windows$ApplicationModel$Background$PhoneTrigger  {

/**
 * Initializes a new instance of the PhoneTrigger class.
 * @param type Specifies the type of phone event.
 * @param oneShot Indicates if the trigger is a one-shot notification. If you weren't subscribed when a one-shot notification was sent, you get nothing. If you weren't connected when you fired a one-shot notification, nothing happens.
 */
constructor(type: $Values<typeof Windows$ApplicationModel$Calls$Background$PhoneTriggerType>, oneShot: boolean): this;

/**
 * Gets a Boolean value indicating if the trigger is a one-shot notification.
 */
oneShot: boolean;

/**
 * Gets the type of phone event indicated by the trigger.
 */
triggerType: $Values<typeof Windows$ApplicationModel$Calls$Background$PhoneTriggerType>
}


/**
 * Represents an object that invokes a background work item on the app in response to the receipt of a raw notification .
 */
declare class Windows$ApplicationModel$Background$PushNotificationTrigger  {

/**
 * Invokes a background work item on the app in response to the receipt of a raw notification .
 */
constructor(): this;

/**
 * Invokes a background work item on a specified app in response to the receipt of a raw notification .
 * @param applicationId The app's Package Relative Application ID (PRAID). The specified app must be in the same package as the calling app.
 */
constructor(applicationId: string): this
}


/**
 * Represents a trigger that launches a background task when a new Rich Communication Services (RCS) message is available.
 */
declare class Windows$ApplicationModel$Background$RcsEndUserMessageAvailableTrigger  {

/**
 * Initializes a new instance of the RcsEndUserMessageAvailableTrigger class.
 */
constructor(): this
}


/**
 * Represents a trigger that launches a background task when an RFCOMM inbound or outbound connections are established.
 */
declare class Windows$ApplicationModel$Background$RfcommConnectionTrigger  {

/**
 * Initializes a new instance of the RfcommConnectionTrigger class.
 */
constructor(): this;

/**
 * Gets or sets whether the app wants to handle multiple connections at a time.
 */
allowMultipleConnections: boolean;

/**
 * Gets or sets the RfcommInboundConnectionInformation object that describes how the system will advertise and listen for inbound connections on behalf of the app.
 */
inboundConnection: Windows$Devices$Bluetooth$Background$RfcommInboundConnectionInformation;

/**
 * Gets or sets the RfcommOutboundConnectionInformation object that describes how the system will create outgoing connections on behalf of the app.
 */
outboundConnection: Windows$Devices$Bluetooth$Background$RfcommOutboundConnectionInformation;

/**
 * Gets or sets the minimum protection level required for connections that are created or accepted on behalf of the app.
 */
protectionLevel: $Values<typeof Windows$Networking$Sockets$SocketProtectionLevel>;

/**
 * Gets or sets specific remote Bluetooth device the system will connect to, or accept connections from, on behalf of the app.
 */
remoteHostName: Windows$Networking$HostName
}


/**
 * Represents a trigger that responds when a threshold limit for a sensor is crossed.
 */
declare class Windows$ApplicationModel$Background$SensorDataThresholdTrigger  {

/**
 * Initializes a new instance of the SensorDataThresholdTrigger class.
 * @param threshold The threshold for a sensor that indicates when it should be triggered.
 */
constructor(threshold: Windows$Devices$Sensors$ISensorDataThreshold): this
}


/**
 * Represents a trigger that is raised when an SMS message has arrived.
 */
declare class Windows$ApplicationModel$Background$SmsMessageReceivedTrigger  {

/**
 * Initializes a new instance of an SMS message received trigger.
 * @param filterRules Filter rules to be applied to incoming SMS messages. Only messages that pass through the filter rules raise the trigger.
 */
constructor(filterRules: Windows$Devices$Sms$SmsFilterRules): this
}


/**
 * Represents a trigger that launches a background task for handling socket activity.
 */
declare class Windows$ApplicationModel$Background$SocketActivityTrigger  {

/**
 * Initializes a new instance of a socket activity trigger.
 */
constructor(): this
}


/**
 * Creates a trigger that will fire when a file is changed in a specified library.
 */
declare class Windows$ApplicationModel$Background$StorageLibraryContentChangedTrigger  {

/**
 * Creates a trigger that will fire when a file is changed in the specified library.
 * @param storageLibrary The location that the trigger monitors such as the music library or documents library.
 * @return A trigger that monitors the specified location.
 */
static create(
storageLibrary: Windows$Storage$StorageLibrary): Windows$ApplicationModel$Background$StorageLibraryContentChangedTrigger;

/**
 * Creates a trigger that will fire when a file is changed in any of the specified libraries.
 * @param storageLibraries The list of libraries that the trigger will monitor.
 * @return A trigger that monitors the specified location(s).
 */
static createFromLibraries(
storageLibraries: Windows$Foundation$Collections$IIterable<Windows$Storage$StorageLibrary>): Windows$ApplicationModel$Background$StorageLibraryContentChangedTrigger
}


/**
 * Represents a system condition that must be in effect for a background task to run.
 */
declare class Windows$ApplicationModel$Background$SystemCondition  {

/**
 * Initializes a new instance of a system condition.
 * @param conditionType Specifies the condition type.
 */
constructor(conditionType: $Values<typeof Windows$ApplicationModel$Background$SystemConditionType>): this;

/**
 * Gets the condition type of a system condition.
 */
conditionType: $Values<typeof Windows$ApplicationModel$Background$SystemConditionType>
}


/**
 * Specifies a system condition that must be in effect for a background task to run. If a background task with a system condition is triggered, the task will not run until the condition is met.
 */

declare  var Windows$ApplicationModel$Background$SystemConditionType: {|
  +invalid: 0,// 0
+userPresent: 1,// 1
+userNotPresent: 2,// 2
+internetAvailable: 3,// 3
+internetNotAvailable: 4,// 4
+sessionConnected: 5,// 5
+sessionDisconnected: 6,// 6
+freeNetworkAvailable: 7,// 7
+backgroundWorkCostNotHigh: 8,// 8

|};



/**
 * Represents a system event that triggers a background task to run.
 */
declare class Windows$ApplicationModel$Background$SystemTrigger  {

/**
 * Initializes a new instance of a system event trigger.
 * @param triggerType Specifies the system event type.
 * @param oneShot True if the system event trigger will be used once; false if it will be used every time the event occurs.
 */
constructor(triggerType: $Values<typeof Windows$ApplicationModel$Background$SystemTriggerType>, oneShot: boolean): this;

/**
 * Gets whether a system event trigger will be used only once.
 */
oneShot: boolean;

/**
 * Gets the system event type of a system event trigger.
 */
triggerType: $Values<typeof Windows$ApplicationModel$Background$SystemTriggerType>
}


/**
 * Specifies the system events that can be used to trigger a background task.
 */

declare  var Windows$ApplicationModel$Background$SystemTriggerType: {|
  +invalid: 0,// 0
+smsReceived: 1,// 1
+userPresent: 2,// 2
+userAway: 3,// 3
+networkStateChange: 4,// 4
+controlChannelReset: 5,// 5
+internetAvailable: 6,// 6
+sessionConnected: 7,// 7
+servicingComplete: 8,// 8
+lockScreenApplicationAdded: 9,// 9
+lockScreenApplicationRemoved: 10,// 10
+timeZoneChange: 11,// 11
+onlineIdConnectedStateChange: 12,// 12
+backgroundWorkCostChange: 13,// 13
+powerStateChange: 14,// 14

|};



/**
 * Represents a time event that triggers a background task to run.
 */
declare class Windows$ApplicationModel$Background$TimeTrigger  {

/**
 * Initializes a new instance of a time event trigger.
 * @param freshnessTime Specifies the number of minutes to wait before scheduling the background task. The system schedules the task within 15 minutes after freshnessTime elapses. If the OneShot property is false, freshnessTime specifies the interval between recurring tasks.
 * @param oneShot True if the time event trigger will be used once; false if it will be used each time freshnessTime elapses.
 */
constructor(freshnessTime: number, oneShot: boolean): this;

/**
 * Gets the interval of a time event trigger.
 */
freshnessTime: number;

/**
 * Gets whether the time event trigger will be used only once or each time the FreshnessTime interval elapses.
 */
oneShot: boolean
}


/**
 * Represents an event that causes a background task to run when the user performs an action on an interactive toast notification.
 */
declare class Windows$ApplicationModel$Background$ToastNotificationActionTrigger  {

/**
 * Creates and initializes a new instance of the ToastNotificationActionTrigger class.
 */
constructor(): this;

/**
 * Creates and initializes a new instance of the ToastNotificationActionTrigger class for the app with the specified identifier.
 * @param applicationId The identifier of the app for which you want to create an instance of the ToastNotificationActionTrigger class.
 */
constructor(applicationId: string): this
}


/**
 * Represents an event that causes a background task to run when the history of toast notifications for the app is cleared, when one or more toast notifications are added to or removed from the notification history for the app, or when one or more toast notifications for the app expire and are removed from the notification history.
 */
declare class Windows$ApplicationModel$Background$ToastNotificationHistoryChangedTrigger  {

/**
 * Creates and initializes a new instance of the ToastNotificationHistoryChangedTrigger class.
 */
constructor(): this;

/**
 * Creates and initializes a new instance of the ToastNotificationHistoryChangedTrigger class for the app with the specified identifier.
 * @param applicationId The identifier of the app for which you want to create an instance of the ToastNotificationHistoryChangedTrigger class.
 */
constructor(applicationId: string): this
}


/**
 * Used to enforce the system condition object type.
 */
declare interface Windows$ApplicationModel$Background$IBackgroundCondition {} 


/**
 * Represents the base interface for trigger events.
 */
declare interface Windows$ApplicationModel$Background$IBackgroundTrigger {} 


/**
 * Provides access to a registered background task.
 */
declare interface Windows$ApplicationModel$Background$IBackgroundTaskRegistration {

/**
 * Unregisters a registered background task.
 * @param cancelTask True if currently running instances of this background task should be canceled. If this parameter is false, currently running instances of this background task should be allowed to finish. Canceled instances receive a Canceled event with a BackgroundTaskCancellationReason of Abort.
 */
unregister(cancelTask: boolean): void,

/**
 * Gets the name of a registered background task.
 */
name: string,

/**
 * Gets the identifier of a registered background task.
 */
taskId: string,

/**
 * Gets the trigger associated with the background task.
 */
trigger: Windows$ApplicationModel$Background$IBackgroundTrigger
} 


/**
 * Represents a method that handles completion events for a background task.
 */
declare type Windows$ApplicationModel$Background$BackgroundTaskCompletedEventHandler = (
ev: Windows$ApplicationModel$Background$BackgroundTaskCompletedEventArgs & Windows$WinRTEvent<Windows$ApplicationModel$Background$BackgroundTaskRegistration>) => void;


/**
 * Represents a method that handles progress update events for a background task.
 */
declare type Windows$ApplicationModel$Background$BackgroundTaskProgressEventHandler = (
ev: Windows$ApplicationModel$Background$BackgroundTaskProgressEventArgs & Windows$WinRTEvent<Windows$ApplicationModel$Background$BackgroundTaskRegistration>) => void;


/**
 * Represents a method that handles the cancellation of a background task.
 */
declare type Windows$ApplicationModel$Background$BackgroundTaskCanceledEventHandler = (
ev: $Values<typeof Windows$ApplicationModel$Background$BackgroundTaskCancellationReason> & Windows$WinRTEvent<Windows$ApplicationModel$Background$IBackgroundTaskInstance>) => void;


/**
 * Provides access to a background task instance.
 */
declare interface Windows$ApplicationModel$Background$IBackgroundTaskInstance {

/**
 * Informs the system that the background task might continue to perform work after the IBackgroundTask.Run method returns.
 * @return A background task deferral.
 */
getDeferral(): Windows$ApplicationModel$Background$BackgroundTaskDeferral,

/**
 * Gets the instance ID of the background task instance.
 */
instanceId: string,

/**
 * Gets or sets progress status for a background task instance.
 */
progress: number,

/**
 * Gets the number of times resource management policy caused the background task to be suspended.
 */
suspendedCount: number,

/**
 * Gets access to the registered background task for this background task instance.
 */
task: Windows$ApplicationModel$Background$BackgroundTaskRegistration,

/**
 * Gets additional information associated with a background task instance.
 */
triggerDetails: any,

/**
 * Retrieves the number of times the background task has been suspended for using too many resources.
 * @param counter Indicates the type of resource to include in the throttle count: network, CPU, or both.
 * @return This method returns the number of times the background task has been suspended for exceeding its quota of the indicated resource type.
 */
getThrottleCount(
counter: $Values<typeof Windows$ApplicationModel$Background$BackgroundTaskThrottleCounter>): number
} 


      declare var npm$namespace$Windows$ApplicationModel$Calls: {
        
        
        PhoneCallHistoryEntryMedia: typeof Windows$ApplicationModel$Calls$PhoneCallHistoryEntryMedia,
PhoneCallHistoryEntryOtherAppReadAccess: typeof Windows$ApplicationModel$Calls$PhoneCallHistoryEntryOtherAppReadAccess,
PhoneCallHistoryEntryQueryDesiredMedia: typeof Windows$ApplicationModel$Calls$PhoneCallHistoryEntryQueryDesiredMedia,
PhoneCallHistoryEntryRawAddressKind: typeof Windows$ApplicationModel$Calls$PhoneCallHistoryEntryRawAddressKind,
PhoneCallHistorySourceIdKind: typeof Windows$ApplicationModel$Calls$PhoneCallHistorySourceIdKind,
PhoneCallHistoryStoreAccessType: typeof Windows$ApplicationModel$Calls$PhoneCallHistoryStoreAccessType,
        LockScreenCallEndCallDeferral: typeof Windows$ApplicationModel$Calls$LockScreenCallEndCallDeferral,
LockScreenCallEndRequestedEventArgs: typeof Windows$ApplicationModel$Calls$LockScreenCallEndRequestedEventArgs,
LockScreenCallUI: typeof Windows$ApplicationModel$Calls$LockScreenCallUI,
PhoneCallHistoryEntry: typeof Windows$ApplicationModel$Calls$PhoneCallHistoryEntry,
PhoneCallHistoryEntryAddress: typeof Windows$ApplicationModel$Calls$PhoneCallHistoryEntryAddress,
PhoneCallHistoryEntryQueryOptions: typeof Windows$ApplicationModel$Calls$PhoneCallHistoryEntryQueryOptions,
PhoneCallHistoryEntryReader: typeof Windows$ApplicationModel$Calls$PhoneCallHistoryEntryReader,
PhoneCallHistoryManager: typeof Windows$ApplicationModel$Calls$PhoneCallHistoryManager,
PhoneCallHistoryStore: typeof Windows$ApplicationModel$Calls$PhoneCallHistoryStore,
        Background: typeof npm$namespace$Windows$ApplicationModel$Calls$Background,
      }

      declare var npm$namespace$Windows$ApplicationModel$Calls$Background: {
        
        
        PhoneCallBlockedReason: typeof Windows$ApplicationModel$Calls$Background$PhoneCallBlockedReason,
PhoneLineChangeKind: typeof Windows$ApplicationModel$Calls$Background$PhoneLineChangeKind,
PhoneLineProperties: typeof Windows$ApplicationModel$Calls$Background$PhoneLineProperties,
PhoneTriggerType: typeof Windows$ApplicationModel$Calls$Background$PhoneTriggerType,
        PhoneCallBlockedTriggerDetails: typeof Windows$ApplicationModel$Calls$Background$PhoneCallBlockedTriggerDetails,
PhoneCallOriginDataRequestTriggerDetails: typeof Windows$ApplicationModel$Calls$Background$PhoneCallOriginDataRequestTriggerDetails,
PhoneLineChangedTriggerDetails: typeof Windows$ApplicationModel$Calls$Background$PhoneLineChangedTriggerDetails,
PhoneNewVoicemailMessageTriggerDetails: typeof Windows$ApplicationModel$Calls$Background$PhoneNewVoicemailMessageTriggerDetails,
        
      }

/**
 * Provides the reason why a phone call was rejected.
 */

declare  var Windows$ApplicationModel$Calls$Background$PhoneCallBlockedReason: {|
  +inCallBlockingList: 0,// 0
+privateNumber: 1,// 1
+unknownNumber: 2,// 2

|};



/**
 * Used to provide the details about a call that was just blocked.
 */
declare class Windows$ApplicationModel$Calls$Background$PhoneCallBlockedTriggerDetails  {

/**
 * Gets the reason why a phone call was blocked.
 */
callBlockedReason: $Values<typeof Windows$ApplicationModel$Calls$Background$PhoneCallBlockedReason>;

/**
 * Gets the ID of the phone call that was just blocked.
 */
lineId: string;

/**
 * Gets the phone number of the blocked call.
 */
phoneNumber: string
}


/**
 * Used to provide the origin details of the phone call.
 */
declare class Windows$ApplicationModel$Calls$Background$PhoneCallOriginDataRequestTriggerDetails  {

/**
 * Gets the phone number for the origin of the phone call.
 */
phoneNumber: string;

/**
 * Gets the unique identifier for this phone call.
 */
requestId: string
}


/**
 * Indicates the type of change for a background phone line change trigger.
 */

declare  var Windows$ApplicationModel$Calls$Background$PhoneLineChangeKind: {|
  +added: 0,// 0
+removed: 1,// 1
+propertiesChanged: 2,// 2

|};



/**
 * Used to provide the details about a change to the properties of a phone line.
 */
declare class Windows$ApplicationModel$Calls$Background$PhoneLineChangedTriggerDetails  {

/**
 * Gets a PhoneLineChangeKind value that indicates if the phone line was added, removed, or changed.
 */
changeType: $Values<typeof Windows$ApplicationModel$Calls$Background$PhoneLineChangeKind>;

/**
 * Checks a phone line against a set of flags to see if any of the specified properties of the phone line have changed.
 * @param lineProperty A set of flags which indicate the phone line properties to query for changes.
 * @return Returns true if any of the properties indicated by the lineProperty parameter have changed on the phone line.
 */
hasLinePropertyChanged(
lineProperty: $Values<typeof Windows$ApplicationModel$Calls$Background$PhoneLineProperties>): boolean;

/**
 * Gets the ID of the phone line that was added, removed, or changed.
 */
lineId: string
}


/**
 * Indicates a set of property flags that are part of a phone line changed trigger. Multiple properties can be set at one time.
 */

declare  var Windows$ApplicationModel$Calls$Background$PhoneLineProperties: {|
  +none: 0,// 0
+brandingOptions: 1,// 1
+canDial: 2,// 2
+cellularDetails: 3,// 3
+displayColor: 4,// 4
+displayName: 5,// 5
+networkName: 6,// 6
+networkState: 7,// 7
+transport: 8,// 8
+voicemail: 9,// 9

|};



/**
 * Used to provide the details about a new voice mail message on a phone line.
 */
declare class Windows$ApplicationModel$Calls$Background$PhoneNewVoicemailMessageTriggerDetails  {

/**
 * Gets the ID of the phone line for which the new voice mail arrived.
 */
lineId: string;

/**
 * Gets the optional voice mail changed message set by an operator when they send a voice mail changed SMS.
 */
operatorMessage: string;

/**
 * Gets the new count of voice mail messages for the phone line.
 */
voicemailCount: number
}


/**
 * Indicates a type of event for a phone trigger.
 */

declare  var Windows$ApplicationModel$Calls$Background$PhoneTriggerType: {|
  +newVoicemailMessage: 0,// 0
+callHistoryChanged: 1,// 1
+lineChanged: 2,// 2
+airplaneModeDisabledForEmergencyCall: 3,// 3
+callOriginDataRequest: 4,// 4
+callBlocked: 5,// 5

|};



/**
 * The LockScreenCallEndCallDeferral object signals when the app no longer needs to defer the removal of itself from the lock screen.
 */
declare class Windows$ApplicationModel$Calls$LockScreenCallEndCallDeferral  {

/**
 * Completes the deferral of the removal of the app from the lock screen, which causes the app to be removed from the lock screen if it hasn't already been removed by other means.
 */
complete(): void
}


/**
 * Controls the removal of an app from the lock screen.
 */
declare class Windows$ApplicationModel$Calls$LockScreenCallEndRequestedEventArgs  {

/**
 * Gets the deadline by which the app must complete the deferral.
 */
deadline: Date;

/**
 * Requests to defer the default behavior of removing the app from the lock screen.
 * @return When this method completes, it returns a LockScreenCallEndCallDeferral object that signals when the app no longer needs to defer the removal of itself from the lock screen.
 */
getDeferral(): Windows$ApplicationModel$Calls$LockScreenCallEndCallDeferral
}


/**
 * Handles communication to and from the lock screen.
 */
declare class Windows$ApplicationModel$Calls$LockScreenCallUI  {

/**
 * Gets and sets a brief description of the nature of the call. This brief description is also called the call's accessible name; its form is "Video call with Jane Doe."
 */
callTitle: string;

/**
 * Removes the app from the lock screen UI.
 */
dismiss(): void;

/**
 * Occurs when the lock screen interaction is complete.
 */
onclosed: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Calls$LockScreenCallUI, any>;
addEventListener(
type: "closed",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Calls$LockScreenCallUI, any>): void;
removeEventListener(
type: "closed",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Calls$LockScreenCallUI, any>): void;

/**
 * Occurs when the lock screen wants to end the call.
 */
onendrequested: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Calls$LockScreenCallUI, Windows$ApplicationModel$Calls$LockScreenCallEndRequestedEventArgs>;
addEventListener(
type: "endrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Calls$LockScreenCallUI, Windows$ApplicationModel$Calls$LockScreenCallEndRequestedEventArgs>): void;
removeEventListener(
type: "endrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Calls$LockScreenCallUI, Windows$ApplicationModel$Calls$LockScreenCallEndRequestedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * A collection of information about a phone call for the call history.
 */
declare class Windows$ApplicationModel$Calls$PhoneCallHistoryEntry  {

/**
 * Creates a new PhoneCallHistoryEntry object.
 */
constructor(): this;

/**
 * Gets or sets the address book information for this phone call.
 */
address: Windows$ApplicationModel$Calls$PhoneCallHistoryEntryAddress;

/**
 * Gets or sets the duration of the call.
 */
duration: number;

/**
 * Gets the unique identifier for this log entry.
 */
id: string;

/**
 * Gets or sets a value determining whether the caller ID is blocked for this phone call.
 */
isCallerIdBlocked: boolean;

/**
 * Gets or sets a value that determines whether the call is classified as an emergency.
 */
isEmergency: boolean;

/**
 * Gets or sets whether a call is an incoming call.
 */
isIncoming: boolean;

/**
 * Gets or sets whether a phone call was missed.
 */
isMissed: boolean;

/**
 * Gets or sets whether a call is currently ringing.
 */
isRinging: boolean;

/**
 * Gets or sets a whether a phone call is seen.
 */
isSeen: boolean;

/**
 * Gets or sets whether this entry is suppressed.
 */
isSuppressed: boolean;

/**
 * Gets or sets whether the phone call entry is a voicemail message.
 */
isVoicemail: boolean;

/**
 * Gets or sets the type of media associated with a call.
 */
media: $Values<typeof Windows$ApplicationModel$Calls$PhoneCallHistoryEntryMedia>;

/**
 * Gets or sets the level of access provided to other applications.
 */
otherAppReadAccess: $Values<typeof Windows$ApplicationModel$Calls$PhoneCallHistoryEntryOtherAppReadAccess>;

/**
 * Gets or sets the remote id for the entry.
 */
remoteId: string;

/**
 * Gets the display name for the source of the phone call.
 */
sourceDisplayName: string;

/**
 * Gets or sets the identifier for the source of the phone call.
 */
sourceId: string;

/**
 * Gets or sets a value that indicates what type of identifier the SourceId is.
 */
sourceIdKind: $Values<typeof Windows$ApplicationModel$Calls$PhoneCallHistorySourceIdKind>;

/**
 * Gets or sets the start time for this history entry.
 */
startTime: Date
}


/**
 * Address book information for a contact used by PhoneCallHistoryEntry objects.
 */
declare class Windows$ApplicationModel$Calls$PhoneCallHistoryEntryAddress  {

/**
 * Creates a new empty PhoneCallHistoryEntryAddress object.
 */
constructor(): this;

/**
 * Creates a new PhoneCallHistoryEntryAddress object with an initial address.
 * @param rawAddress The address to initiailize to the RawAddress property.
 * @param rawAddressKind The type of address represented by rawAddress.
 */
constructor(rawAddress: string, rawAddressKind: $Values<typeof Windows$ApplicationModel$Calls$PhoneCallHistoryEntryRawAddressKind>): this;

/**
 * Gets or sets the unique identifier for this contact.
 */
contactId: string;

/**
 * Get or sets the display name for this entry.
 */
displayName: string;

/**
 * Gets or sets the address information for this contact.
 */
rawAddress: string;

/**
 * Gets or sets the type of address indicated by RawAddress .
 */
rawAddressKind: $Values<typeof Windows$ApplicationModel$Calls$PhoneCallHistoryEntryRawAddressKind>
}


/**
 * The type of media associated with a call.
 */

declare  var Windows$ApplicationModel$Calls$PhoneCallHistoryEntryMedia: {|
  +audio: 0,// 0
+video: 1,// 1

|};



/**
 * The level of read access provided to other applications.
 */

declare  var Windows$ApplicationModel$Calls$PhoneCallHistoryEntryOtherAppReadAccess: {|
  +full: 0,// 0
+systemOnly: 1,// 1

|};



/**
 * A filter used to retrieve call entries based on the contained media.
 */

declare  var Windows$ApplicationModel$Calls$PhoneCallHistoryEntryQueryDesiredMedia: {|
  +none: 0,// 0
+audio: 1,// 1
+video: 2,// 2
+all: 3,// 3

|};



/**
 * Options for querying the phone call entries.
 */
declare class Windows$ApplicationModel$Calls$PhoneCallHistoryEntryQueryOptions  {

/**
 * Creates a new PhoneCallHistoryEntryQueryOptions object.
 */
constructor(): this;

/**
 * Gets or sets the query filter based on the type of media.
 */
desiredMedia: $Values<typeof Windows$ApplicationModel$Calls$PhoneCallHistoryEntryQueryDesiredMedia>;

/**
 * Get the query filter based on the source ID of the phone call entry.
 */
sourceIds: Windows$Foundation$Collections$IVector<string>
}


/**
 * The type of address used by the PhoneCallHistoryEntryAddress .
 */

declare  var Windows$ApplicationModel$Calls$PhoneCallHistoryEntryRawAddressKind: {|
  +phoneNumber: 0,// 0
+custom: 1,// 1

|};



/**
 * Enables the calling app to read through the phone call history entries.
 */
declare class Windows$ApplicationModel$Calls$PhoneCallHistoryEntryReader  {

/**
 * Returns a list of the PhoneCallHistoryEntry objects.
 * @return An asynchronous operation that returns an IVectorView upon successful completion.
 */
readBatchAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>
}


/**
 * Provides APIs for the application to get access to the PhoneCallHistoryStore .
 */
declare class Windows$ApplicationModel$Calls$PhoneCallHistoryManager  {

/**
 * Requests the PhoneCallHistoryStore associated with the calling application.
 * @param accessType The type of access requested for the PhoneCallHistoryStore object.
 * @return An asynchronous operation that returns a PhoneCallHistoryStore object on successful completion.
 */
static requestStoreAsync(
accessType: $Values<typeof Windows$ApplicationModel$Calls$PhoneCallHistoryStoreAccessType>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Calls$PhoneCallHistoryStore>
}


/**
 * The type of identifier that the PhoneCallHistoryEntry.SourceId refers to.
 */

declare  var Windows$ApplicationModel$Calls$PhoneCallHistorySourceIdKind: {|
  +cellularPhoneLineId: 0,// 0
+packageFamilyName: 1,// 1

|};



/**
 * A collection of phone call history entries.
 */
declare class Windows$ApplicationModel$Calls$PhoneCallHistoryStore  {

/**
 * Deletes entries in the store.
 * @param callHistoryEntries The entries to delete.
 */
deleteEntriesAsync(
callHistoryEntries: Windows$Foundation$Collections$IIterable<Windows$ApplicationModel$Calls$PhoneCallHistoryEntry>): any;

/**
 * Delete an entry from the store.
 * @param callHistoryEntry The entry to delete.
 */
deleteEntryAsync(callHistoryEntry: Windows$ApplicationModel$Calls$PhoneCallHistoryEntry): any;

/**
 * Gets an entry from the store based on the entry id.
 * @param callHistoryEntryId The PhoneCallHistoryEntryt.Id of the relevant entry.
 */
getEntryAsync(callHistoryEntryId: string): any;

/**
 * Retrieves an entry reader based on provided filters.
 * @param queryOptions The options used to create a filtered entry reader.
 * @return A reader that can be used to go through the phone call log entries.
 */
getEntryReader(
queryOptions: Windows$ApplicationModel$Calls$PhoneCallHistoryEntryQueryOptions): Windows$ApplicationModel$Calls$PhoneCallHistoryEntryReader;

/**
 * Retrieves a default phone call history entry that reads all entries.
 * @return A reader that can be used to go through the phone call log entries.
 */
getEntryReader(): Windows$ApplicationModel$Calls$PhoneCallHistoryEntryReader;

/**
 * Gets the number of unseen log entries for the provided sources.
 * @param sourceIds The identifiers that need to match PhoneCallHistoryEntry.SourceId in order for that entry to be considered.
 * @return The total number of unseen entries matching all of the identifiers provided by sourceIds.
 */
getSourcesUnseenCountAsync(
sourceIds: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * Gets the number of unseen entries.
 * @return The number of unseen entries.
 */
getUnseenCountAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * Update all the entries to indicate they have all been seen by the user.
 */
markAllAsSeenAsync(): any;

/**
 * Updates entries to indicate they have been seen by the user.
 * @param callHistoryEntries The entries to mark as seen. This updates the PhoneCallHistoryEntry.IsSeen property.
 */
markEntriesAsSeenAsync(
callHistoryEntries: Windows$Foundation$Collections$IIterable<Windows$ApplicationModel$Calls$PhoneCallHistoryEntry>): any;

/**
 * Updates an entry to indicate it has been seen.
 * @param callHistoryEntry The entry to update.
 */
markEntryAsSeenAsync(callHistoryEntry: Windows$ApplicationModel$Calls$PhoneCallHistoryEntry): any;

/**
 * Marks all entries from the specified sources as seen.
 * @param sourceIds The list of source identifiers to mark as seen. Only entries that match PhoneCallHistoryEntry.SourceId will be updated.
 */
markSourcesAsSeenAsync(sourceIds: Windows$Foundation$Collections$IIterable<string>): any;

/**
 * Saves an entry to the store.
 * @param callHistoryEntry The entry to save.
 */
saveEntryAsync(callHistoryEntry: Windows$ApplicationModel$Calls$PhoneCallHistoryEntry): any
}


/**
 * The type of store you want to retrieve.
 */

declare  var Windows$ApplicationModel$Calls$PhoneCallHistoryStoreAccessType: {|
  +appEntriesReadWrite: 0,// 0
+allEntriesLimitedReadWrite: 1,// 1
+allEntriesReadWrite: 2,// 2

|};



      declare var npm$namespace$Windows$ApplicationModel$Chat: {
        
        
        ChatConversationThreadingKind: typeof Windows$ApplicationModel$Chat$ChatConversationThreadingKind,
ChatItemKind: typeof Windows$ApplicationModel$Chat$ChatItemKind,
ChatMessageChangeType: typeof Windows$ApplicationModel$Chat$ChatMessageChangeType,
ChatMessageKind: typeof Windows$ApplicationModel$Chat$ChatMessageKind,
ChatMessageOperatorKind: typeof Windows$ApplicationModel$Chat$ChatMessageOperatorKind,
ChatMessageStatus: typeof Windows$ApplicationModel$Chat$ChatMessageStatus,
ChatMessageTransportKind: typeof Windows$ApplicationModel$Chat$ChatMessageTransportKind,
ChatMessageValidationStatus: typeof Windows$ApplicationModel$Chat$ChatMessageValidationStatus,
ChatStoreChangedEventKind: typeof Windows$ApplicationModel$Chat$ChatStoreChangedEventKind,
ChatTransportErrorCodeCategory: typeof Windows$ApplicationModel$Chat$ChatTransportErrorCodeCategory,
ChatTransportInterpretedErrorCode: typeof Windows$ApplicationModel$Chat$ChatTransportInterpretedErrorCode,
RcsServiceKind: typeof Windows$ApplicationModel$Chat$RcsServiceKind,
        ChatCapabilities: typeof Windows$ApplicationModel$Chat$ChatCapabilities,
ChatCapabilitiesManager: typeof Windows$ApplicationModel$Chat$ChatCapabilitiesManager,
ChatConversation: typeof Windows$ApplicationModel$Chat$ChatConversation,
ChatConversationReader: typeof Windows$ApplicationModel$Chat$ChatConversationReader,
ChatConversationThreadingInfo: typeof Windows$ApplicationModel$Chat$ChatConversationThreadingInfo,
ChatMessage: typeof Windows$ApplicationModel$Chat$ChatMessage,
ChatMessageAttachment: typeof Windows$ApplicationModel$Chat$ChatMessageAttachment,
ChatMessageBlocking: typeof Windows$ApplicationModel$Chat$ChatMessageBlocking,
ChatMessageChange: typeof Windows$ApplicationModel$Chat$ChatMessageChange,
ChatMessageChangeReader: typeof Windows$ApplicationModel$Chat$ChatMessageChangeReader,
ChatMessageChangeTracker: typeof Windows$ApplicationModel$Chat$ChatMessageChangeTracker,
ChatMessageChangedDeferral: typeof Windows$ApplicationModel$Chat$ChatMessageChangedDeferral,
ChatMessageChangedEventArgs: typeof Windows$ApplicationModel$Chat$ChatMessageChangedEventArgs,
ChatMessageManager: typeof Windows$ApplicationModel$Chat$ChatMessageManager,
ChatMessageNotificationTriggerDetails: typeof Windows$ApplicationModel$Chat$ChatMessageNotificationTriggerDetails,
ChatMessageReader: typeof Windows$ApplicationModel$Chat$ChatMessageReader,
ChatMessageStore: typeof Windows$ApplicationModel$Chat$ChatMessageStore,
ChatMessageStoreChangedEventArgs: typeof Windows$ApplicationModel$Chat$ChatMessageStoreChangedEventArgs,
ChatMessageTransport: typeof Windows$ApplicationModel$Chat$ChatMessageTransport,
ChatMessageTransportConfiguration: typeof Windows$ApplicationModel$Chat$ChatMessageTransportConfiguration,
ChatMessageValidationResult: typeof Windows$ApplicationModel$Chat$ChatMessageValidationResult,
ChatQueryOptions: typeof Windows$ApplicationModel$Chat$ChatQueryOptions,
ChatRecipientDeliveryInfo: typeof Windows$ApplicationModel$Chat$ChatRecipientDeliveryInfo,
ChatSearchReader: typeof Windows$ApplicationModel$Chat$ChatSearchReader,
RcsEndUserMessage: typeof Windows$ApplicationModel$Chat$RcsEndUserMessage,
RcsEndUserMessageAction: typeof Windows$ApplicationModel$Chat$RcsEndUserMessageAction,
RcsEndUserMessageAvailableEventArgs: typeof Windows$ApplicationModel$Chat$RcsEndUserMessageAvailableEventArgs,
RcsEndUserMessageAvailableTriggerDetails: typeof Windows$ApplicationModel$Chat$RcsEndUserMessageAvailableTriggerDetails,
RcsEndUserMessageManager: typeof Windows$ApplicationModel$Chat$RcsEndUserMessageManager,
RcsManager: typeof Windows$ApplicationModel$Chat$RcsManager,
RcsServiceKindSupportedChangedEventArgs: typeof Windows$ApplicationModel$Chat$RcsServiceKindSupportedChangedEventArgs,
RcsTransport: typeof Windows$ApplicationModel$Chat$RcsTransport,
RcsTransportConfiguration: typeof Windows$ApplicationModel$Chat$RcsTransportConfiguration,
RemoteParticipantComposingChangedEventArgs: typeof Windows$ApplicationModel$Chat$RemoteParticipantComposingChangedEventArgs,
        
      }

/**
 * Represents the Rich Communication Services (RCS) chat capabilities of a phone number.
 */
declare class Windows$ApplicationModel$Chat$ChatCapabilities  {

/**
 * Gets a Boolean value indicating if a phone number supports Rich Communication Services (RCS) chat.
 */
isChatCapable: boolean;

/**
 * Gets a Boolean value indicating if a phone number supports Rich Communication Services (RCS) file transfer.
 */
isFileTransferCapable: boolean;

/**
 * Gets a Boolean value indicating if a phone number is capable of pushing Rich Communication Services (RCS) geolocation.
 */
isGeoLocationPushCapable: boolean;

/**
 * Gets a Boolean value indicating if a phone number supports Rich Communication Services (RCS) integrated messaging.
 */
isIntegratedMessagingCapable: boolean;

/**
 * Gets a Boolean value indicating if an Rich Communication Services (RCS) capable phone number is online.
 */
isOnline: boolean
}


/**
 * Provides functionality for getting chat capabilities.
 */
declare class Windows$ApplicationModel$Chat$ChatCapabilitiesManager  {

/**
 * Asynchronously gets the locally cached Rich Communication Services (RCS) chat capabilities for the specified phone number.
 * @param address The phone number for which to get the RCS chat capabilites
 * @return The locally cached RCS chat capabilities.
 */
static getCachedCapabilitiesAsync(
address: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Chat$ChatCapabilities>;

/**
 * Asynchronously gets the Rich Communication Services (RCS) chat capabilities for the specified phone number from the service provider.
 * @param address The phone number for which to get the RCS chat capabilities.
 * @return The RCS chat capabilities from the service provider.
 */
static getCapabilitiesFromNetworkAsync(
address: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Chat$ChatCapabilities>
}


/**
 * Represents a conversation in a chat client.
 */
declare class Windows$ApplicationModel$Chat$ChatConversation  {

/**
 * Gets or sets a boolean that indicates whether participants can be modified or not.
 */
canModifyParticipants: boolean;

/**
 * Asynchronously deletes all of the messages in the ChatConversation and the conversation itself.
 * @return An async action that indicates when the delete has completed.
 */
deleteAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the ChatMessageReader for this ChatConversation .
 * @return The ChatMessageReader for this ChatConversation .
 */
getMessageReader(): Windows$ApplicationModel$Chat$ChatMessageReader;

/**
 * Gets a Boolean value indicating if there are unread messages in the ChatConversation .
 */
hasUnreadMessages: boolean;

/**
 * Gets the unique identifier for the ChatConversation .
 */
id: string;

/**
 * Gets or sets a Boolean value indicating if the ChatConversation is muted.
 */
isConversationMuted: boolean;

/**
 * Asynchronously marks all the messages in the conversation before the specified DateTime as read.
 * @param value Mark all messages before this DateTime as read.
 * @return An async action indicating that the operation has completed.
 */
markMessagesAsReadAsync(value: Date): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously marks all the messages in the conversation as read.
 * @return An async action indicating that the operation has completed.
 */
markMessagesAsReadAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the ID of the most recent message in the conversation.
 */
mostRecentMessageId: string;

/**
 * Call this to indicate that the local participant has started or has completed typing.
 * @param transportId Specifies the ChatMessageTransport to use.
 * @param participantAddress The address of the remote participant.
 * @param isComposing TRUE if the local participant is typing, otherwise FALSE.
 */
notifyLocalParticipantComposing(transportId: string, participantAddress: string, isComposing: boolean): void;

/**
 * Locally triggers the event that indicates that a remote participant is typing.
 * @param transportId Specifies the ChatMessageTransport to use.
 * @param participantAddress The address of the remote participant.
 * @param isComposing TRUE if the remote participant is typing, otherwise FALSE.
 */
notifyRemoteParticipantComposing(transportId: string, participantAddress: string, isComposing: boolean): void;

/**
 * Occurs when the remote user has started or finished typing.
 */
onremoteparticipantcomposingchanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Chat$ChatConversation, Windows$ApplicationModel$Chat$RemoteParticipantComposingChangedEventArgs>;
addEventListener(
type: "remoteparticipantcomposingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Chat$ChatConversation, Windows$ApplicationModel$Chat$RemoteParticipantComposingChangedEventArgs>): void;
removeEventListener(
type: "remoteparticipantcomposingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Chat$ChatConversation, Windows$ApplicationModel$Chat$RemoteParticipantComposingChangedEventArgs>): void;

/**
 * Gets a list of all the participants in the conversation.
 */
participants: Windows$Foundation$Collections$IVector<string>;

/**
 * Asynchronously saves the ChatConversation .
 * @return An async action indicating that the operation has completed.
 */
saveAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets or sets the subject of a group conversation.
 */
subject: string;

/**
 * Gets the threading info for the ChatConversation .
 */
threadingInfo: Windows$ApplicationModel$Chat$ChatConversationThreadingInfo;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides functionality for reading batches of conversations from the ChatMessageStore .
 */
declare class Windows$ApplicationModel$Chat$ChatConversationReader  {

/**
 * Asynchronously reads batches of conversations from the ChatMessageStore .
 * @param count Specifies the size of the batch to read.
 * @return The list of conversations.
 */
readBatchAsync(
count: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously reads batches of conversations from the ChatMessageStore .
 * @return The list of conversations.
 */
readBatchAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>
}


/**
 * Provides threading info for a ChatConversation .
 */
declare class Windows$ApplicationModel$Chat$ChatConversationThreadingInfo  {

/**
 * Initializes a new instance of the ChatConversationThreadingInfo class.
 */
constructor(): this;

/**
 * Gets or sets the Contact.Id for the remote participant.
 */
contactId: string;

/**
 * Gets or sets the ID of the ChatConversation .
 */
conversationId: string;

/**
 * Gets or sets a string where you can store your own custom threading info.
 */
custom: string;

/**
 * Gets or sets a value that indicates the type of threading info, such as participant, contact ID, conversation ID, and so on.
 */
kind: $Values<typeof Windows$ApplicationModel$Chat$ChatConversationThreadingKind>;

/**
 * Gets the list of participants in the ChatConversation .
 */
participants: Windows$Foundation$Collections$IVector<string>
}


/**
 * Specifies how a conversation is threaded.
 */

declare  var Windows$ApplicationModel$Chat$ChatConversationThreadingKind: {|
  +participants: 0,// 0
+contactId: 1,// 1
+conversationId: 2,// 2
+custom: 3,// 3

|};



/**
 * Specifies the type of a chat item.
 */

declare  var Windows$ApplicationModel$Chat$ChatItemKind: {|
  +message: 0,// 0
+conversation: 1,// 1

|};



/**
 * Represents a chat message.
 */
declare class Windows$ApplicationModel$Chat$ChatMessage  {

/**
 * Creates a new instance of the ChatMessage class.
 */
constructor(): this;

/**
 * Gets a list of chat message attachments.
 */
attachments: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Chat$ChatMessageAttachment>;

/**
 * Gets or sets the body of the chat message.
 */
body: string;

/**
 * Gets or sets the estimated size of a file to be sent or received.
 */
estimatedDownloadSize: number;

/**
 * Gets the identifier or address of the sender of the message.
 */
from: string;

/**
 * Gets the identifier of the message.
 */
id: string;

/**
 * Gets or sets a Boolean value indicating if the message is an auto-reply.
 */
isAutoReply: boolean;

/**
 * Gets a Boolean value indicating if forwarding is disabled.
 */
isForwardingDisabled: boolean;

/**
 * Gets Boolean a value indicating if the message is incoming or outgoing.
 */
isIncoming: boolean;

/**
 * Gets a Boolean value indicating if the message has been read.
 */
isRead: boolean;

/**
 * Gets or sets a Boolean value indicating if the message was received during user specified quiet hours.
 */
isReceivedDuringQuietHours: boolean;

/**
 * Gets a Boolean value indicating if reply is disabled on the ChatMessage .
 */
isReplyDisabled: boolean;

/**
 * Gets or sets a Boolean value indicating if the message has been seen.
 */
isSeen: boolean;

/**
 * Gets a Boolean value indicating if the message is stored on a SIM card.
 */
isSimMessage: boolean;

/**
 * Gets the local timestamp of the message.
 */
localTimestamp: Date;

/**
 * Gets or sets the type of the ChatMessage .
 */
messageKind: $Values<typeof Windows$ApplicationModel$Chat$ChatMessageKind>;

/**
 * Gets or sets a value indicating the type of message operator, such as SMS, MMS, or RCS.
 */
messageOperatorKind: $Values<typeof Windows$ApplicationModel$Chat$ChatMessageOperatorKind>;

/**
 * Gets the network timestamp of the message.
 */
networkTimestamp: Date;

/**
 * Gets the list of send statuses for the message.
 */
recipientSendStatuses: Windows$Foundation$Collections$IMapView<string, $Values<typeof Windows$ApplicationModel$Chat$ChatMessageStatus>>;

/**
 * Gets the list of recipients of the message.
 */
recipients: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets the delivery info for each of the recipients of the ChatMessage .
 */
recipientsDeliveryInfos: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Chat$ChatRecipientDeliveryInfo>;

/**
 * Gets or sets the remote ID for the ChatMessage .
 */
remoteId: string;

/**
 * Gets or sets a Boolean value indicating if notification of receiving the ChatMessage should be suppressed.
 */
shouldSuppressNotification: boolean;

/**
 * Gets the status of the message. Typical states include draft, sent, received, deleted, etc.
 */
status: $Values<typeof Windows$ApplicationModel$Chat$ChatMessageStatus>;

/**
 * Gets the subject of the message.
 */
subject: string;

/**
 * Gets or sets the conversation threading info for the ChatMessage .
 */
threadingInfo: Windows$ApplicationModel$Chat$ChatConversationThreadingInfo;

/**
 * Gets the transport friendly name of the message.
 */
transportFriendlyName: string;

/**
 * Gets or sets the transport ID of the message.
 */
transportId: string
}


/**
 * Represents an attachment to a chat message.
 */
declare class Windows$ApplicationModel$Chat$ChatMessageAttachment  {

/**
 * Initializes a new instance of the ChatMessageAttachment class.
 * @param mimeType The MIME type of the attachment.
 * @param dataStreamReference A stream containing the attachment data.
 */
constructor(mimeType: string, dataStreamReference: Windows$Storage$Streams$IRandomAccessStreamReference): this;

/**
 * Gets or sets a stream reference for a message attachment.
 */
dataStreamReference: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets or sets the identifier for the attachment group to which this attachment belongs.
 */
groupId: number;

/**
 * Gets or sets the MIME type of the attachment.
 */
mimeType: string;

/**
 * Gets or sets the original file name of the attachment.
 */
originalFileName: string;

/**
 * Gets or sets the text encoded representation of the attachment object.
 */
text: string;

/**
 * Gets or sets the thumbnail image for the attachment.
 */
thumbnail: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets or sets the progress of transferring the attachment.
 */
transferProgress: number
}


/**
 * Provides functionality for blocking messages.
 */
declare class Windows$ApplicationModel$Chat$ChatMessageBlocking  {

/**
 * Asynchronously marks a message as blocked or unblocked.
 * @param localChatMessageId The ID of the message to block.
 * @param blocked TRUE if the message should be blocked, FALSE if it should be unblocked.
 * @return An async action indicating that the operation has completed.
 */
static markMessageAsBlockedAsync(
localChatMessageId: string,
blocked: boolean): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Represents a revision to a chat message.
 */
declare class Windows$ApplicationModel$Chat$ChatMessageChange  {

/**
 * Gets the type of change made to a chat message, such as created, modified, etc.
 */
changeType: $Values<typeof Windows$ApplicationModel$Chat$ChatMessageChangeType>;

/**
 * Gets the updated message text.
 */
message: Windows$ApplicationModel$Chat$ChatMessage
}


/**
 * Provides methods for reading and accepting message change revisions.
 */
declare class Windows$ApplicationModel$Chat$ChatMessageChangeReader  {

/**
 * Accepts all the changes up to and including the latest change to the message.
 */
acceptChanges(): void;

/**
 * Accepts all the changes up to a specified change.
 * @param lastChangeToAcknowledge The last change to acknowledge.
 */
acceptChangesThrough(lastChangeToAcknowledge: Windows$ApplicationModel$Chat$ChatMessageChange): void;

/**
 * Returns a batch list of chat message change objects from the message stores change tracker.
 * @return An asynchronous operation that returns a list of changes.
 */
readBatchAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>
}


/**
 * Provides methods to enable and retrieve message change revisions.
 */
declare class Windows$ApplicationModel$Chat$ChatMessageChangeTracker  {

/**
 * Enables change tracking for the messages in the message store.
 */
enable(): void;

/**
 * Returns a ChatMessageChangeReader class object which provides a collection of message revisions from the message store.
 * @return The change reader associated with the change tracker.
 */
getChangeReader(): Windows$ApplicationModel$Chat$ChatMessageChangeReader;

/**
 * Resets change tracking for the messages in the message store. The first revision begins with the next message change.
 */
reset(): void
}


/**
 * Specifies the type of change made to a chat message.
 */

declare  var Windows$ApplicationModel$Chat$ChatMessageChangeType: {|
  +messageCreated: 0,// 0
+messageModified: 1,// 1
+messageDeleted: 2,// 2
+changeTrackingLost: 3,// 3

|};



/**
 * Represents a deferred asynchronous change request.
 */
declare class Windows$ApplicationModel$Chat$ChatMessageChangedDeferral  {

/**
 * Fires to indicate that the deferred change request has completed.
 */
complete(): void
}


/**
 * Represents event parameters used by the event handler that processes message change events.
 */
declare class Windows$ApplicationModel$Chat$ChatMessageChangedEventArgs  {

/**
 * The message changed event handler that an application registers with the message store receives a deferral object in the event parameters. The GetDeferral method registers a change deferral and allows an application to take action related to the change before the message store completes the change.
 * @return Gets a deferral for the MessageChanged event.
 */
getDeferral(): Windows$ApplicationModel$Chat$ChatMessageChangedDeferral
}


/**
 * Specifies the type of chat message.
 */

declare  var Windows$ApplicationModel$Chat$ChatMessageKind: {|
  +standard: 0,// 0
+fileTransferRequest: 1,// 1
+transportCustom: 2,// 2
+joinedConversation: 3,// 3
+leftConversation: 4,// 4
+otherParticipantJoinedConversation: 5,// 5
+otherParticipantLeftConversation: 6,// 6

|};



/**
 * Provides access to message transports and the message store. Also provides a method to display the UI to compose messages.
 */
declare class Windows$ApplicationModel$Chat$ChatMessageManager  {

/**
 * Asynchronously gets the ChatMessageTransport .
 * @param transportId The locally unique identifier for the message transport.
 * @return The message transport.
 */
static getTransportAsync(
transportId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Chat$ChatMessageTransport>;

/**
 * Asynchronously gets the chat message transports available on the device.
 * @return An asynchronous operation that returns a list of transports on successful completion.
 */
static getTransportsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously registers the app as a ChatMessageTransport in order to post messages to the ChatMessageStore .
 * @return The transport ID for the newly registered ChatMessageTransport .
 */
static registerTransportAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Returns the SMS messaging store for the phone.
 * @return An asynchronous operation that returns a ChatMessageStore on successful completion.
 */
static requestStoreAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Chat$ChatMessageStore>;

/**
 * Shows the compose SMS dialog, pre-populated with data from the supplied ChatMessage object, allowing the user to send an SMS message.
 * @param message The chat message.
 * @return An asynchronous action.
 */
static showComposeSmsMessageAsync(
message: Windows$ApplicationModel$Chat$ChatMessage): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Launches the device's SMS settings app.
 */
static showSmsSettings(): void
}


/**
 * Represents the message notification triggered from a registered background task. A chat app can receive notifications of incoming messages or send events by setting a task trigger and task entry point.
 */
declare class Windows$ApplicationModel$Chat$ChatMessageNotificationTriggerDetails  {

/**
 * Gets the message associated with the notification. This is either an incoming message or an outgoing message with a send status event.
 */
chatMessage: Windows$ApplicationModel$Chat$ChatMessage;

/**
 * Gets a Boolean value indicating if the background task should issue a toast notification for the message.
 */
shouldDisplayToast: boolean;

/**
 * Gets a Boolean value indicating if the Windows Action Center should be updated with the message.
 */
shouldUpdateActionCenter: boolean;

/**
 * Gets a Boolean value indicating if the background task should update the apps lock screen count.
 */
shouldUpdateBadge: boolean;

/**
 * Gets a Boolean value indicating that the background task should update the app's tile count for the message.
 */
shouldUpdateDetailText: boolean
}


/**
 * Specifies the message operator type.
 */

declare  var Windows$ApplicationModel$Chat$ChatMessageOperatorKind: {|
  +unspecified: 0,// 0
+sms: 1,// 1
+mms: 2,// 2
+rcs: 3,// 3

|};



/**
 * Provides methods for reading messages from the message store.
 */
declare class Windows$ApplicationModel$Chat$ChatMessageReader  {

/**
 * Returns a batch list of chat messages from the message store.
 * @return An asynchronous operation that returns a list of chat messages upon successful completion.
 */
readBatchAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Returns a batch list of chat messages from the message store limited to the specified size.
 * @param count The size of the batch to read.
 * @return An asynchronous operation that returns a list of chat messages upon successful completion.
 */
readBatchAsync(
count: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>
}


/**
 * Specifies the current status of a chat message such as draft, sent, or received.
 */

declare  var Windows$ApplicationModel$Chat$ChatMessageStatus: {|
  +draft: 0,// 0
+sending: 1,// 1
+sent: 2,// 2
+sendRetryNeeded: 3,// 3
+sendFailed: 4,// 4
+received: 5,// 5
+receiveDownloadNeeded: 6,// 6
+receiveDownloadFailed: 7,// 7
+receiveDownloading: 8,// 8
+deleted: 9,// 9
+declined: 10,// 10
+cancelled: 11,// 11
+recalled: 12,// 12
+receiveRetryNeeded: 13,// 13

|};



/**
 * Provides the methods and properties to read, manage and send messages. An application gets access to the message store using the static ChatMessageManager class .
 */
declare class Windows$ApplicationModel$Chat$ChatMessageStore  {

/**
 * Gets a ChatMessageChangeTracker class object for the message store. A message change tracker allows an application to monitor changes to messages in the message store.
 */
changeTracker: Windows$ApplicationModel$Chat$ChatMessageChangeTracker;

/**
 * Deletes a message from the chat message store.
 * @param localMessageId The local ID of the message to be deleted.
 * @return An asynchronous action.
 */
deleteMessageAsync(localMessageId: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Downloads a message specified by the identifier to the message store.
 * @param localChatMessageId The local ID of the message to be downloaded.
 * @return An asynchronous action.
 */
downloadMessageAsync(localChatMessageId: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously forwards the specified message to new recipients.
 * @param localChatMessageId The ID of the message to forward.
 * @param addresses The addresses of the new recipients of the forwarded message.
 * @return A copy of the forwarded message.
 */
forwardMessageAsync(
localChatMessageId: string,
addresses: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Chat$ChatMessage>;

/**
 * Asynchronously gets a ChatConversation by ID using the specified transports.
 * @param conversationId The ID of the conversation to retrieve.
 * @param transportIds The IDs of the transports to use to retrieve the ChatConversation .
 * @return The ChatConversation specified by the conversationId parameter.
 */
getConversationAsync(
conversationId: string,
transportIds: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Chat$ChatConversation>;

/**
 * Asynchronously gets a ChatConversation by ID.
 * @param conversationId The ID of the conversation to retrieve.
 * @return The ChatConversation specified by the conversationId parameter.
 */
getConversationAsync(
conversationId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Chat$ChatConversation>;

/**
 * Asynchronously gets a conversation based on a threading info object.
 * @param threadingInfo The threading info that identifies the conversation.
 * @return The conversation identified by the threadingInfo parameter.
 */
getConversationFromThreadingInfoAsync(
threadingInfo: Windows$ApplicationModel$Chat$ChatConversationThreadingInfo): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Chat$ChatConversation>;

/**
 * Gets a new or existing ChatConversationReader for the message store.
 * @return The new or existing ChatConversationReader .
 */
getConversationReader(): Windows$ApplicationModel$Chat$ChatConversationReader;

/**
 * Gets a new or existing ChatConversationReader for the message store using the specified transports.
 * @param transportIds The IDs for the transports to use to retrieve the ChatConversationReader .
 * @return The new or existing ChatConversationReader .
 */
getConversationReader(
transportIds: Windows$Foundation$Collections$IIterable<string>): Windows$ApplicationModel$Chat$ChatConversationReader;

/**
 * Retrieves a message specified by an identifier from the message store.
 * @param localChatMessageId The local ID of the chat message to be retrieved.
 * @return An asynchronous operation that returns a chat message upon successful completion.
 */
getMessageAsync(
localChatMessageId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Chat$ChatMessage>;

/**
 * Gets a message by its remote ID.
 * @param transportId The TransportId to use to get the ChatMessage .
 * @param remoteId The RemoteId of the ChatMessage to retrieve.
 * @return The message.
 */
getMessageByRemoteIdAsync(
transportId: string,
remoteId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Chat$ChatMessage>;

/**
 * Gets a ChatMessageReader class object which provides a message collection from the message store.
 * @return The chat message reader.
 */
getMessageReader(): Windows$ApplicationModel$Chat$ChatMessageReader;

/**
 * Gets a ChatMessageReader class object which provides a message collection from the message store. The collection of messages is limited to the time span provided.
 * @param recentTimeLimit The time window for the retrieved reader.
 * @return The chat message reader.
 */
getMessageReader(recentTimeLimit: number): Windows$ApplicationModel$Chat$ChatMessageReader;

/**
 * Gets a new or existing ChatSearchReader to be used to search for messages.
 * @param value The query options that the search reader will use when looking for matching messages.
 * @return The new or existing search reader.
 */
getSearchReader(
value: Windows$ApplicationModel$Chat$ChatQueryOptions): Windows$ApplicationModel$Chat$ChatSearchReader;

/**
 * Asynchronously gets the number of unread chat messages using the specified transports.
 * @param transportIds The IDs of the chat transports to use to get the unseen messages count.
 * @return The number of unread chat messages.
 */
getUnseenCountAsync(
transportIds: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * Asynchronously gets the number of unread chat messages.
 * @return The number of unread chat messages.
 */
getUnseenCountAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * Asynchronously marks all transport messages as seen.
 * @param transportIds The IDs of the transports for which to mark all messages as seen.
 * @return An async action indicating that the operation has finished.
 */
markAsSeenAsync(
transportIds: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously marks all transport messages as seen.
 * @return An async action indicating that the operation has finished.
 */
markAsSeenAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Marks a specified message in the store as already read.
 * @param localChatMessageId The local ID of the message to be marked as read.
 * @return An asynchronous action.
 */
markMessageReadAsync(localChatMessageId: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * An event that occurs when a message in the message store is changed.
 */
onmessagechanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Chat$ChatMessageStore, Windows$ApplicationModel$Chat$ChatMessageChangedEventArgs>;
addEventListener(
type: "messagechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Chat$ChatMessageStore, Windows$ApplicationModel$Chat$ChatMessageChangedEventArgs>): void;
removeEventListener(
type: "messagechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Chat$ChatMessageStore, Windows$ApplicationModel$Chat$ChatMessageChangedEventArgs>): void;

/**
 * Occurs when something in the ChatMessageStore has changed.
 */
onstorechanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Chat$ChatMessageStore, Windows$ApplicationModel$Chat$ChatMessageStoreChangedEventArgs>;
addEventListener(
type: "storechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Chat$ChatMessageStore, Windows$ApplicationModel$Chat$ChatMessageStoreChangedEventArgs>): void;
removeEventListener(
type: "storechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Chat$ChatMessageStore, Windows$ApplicationModel$Chat$ChatMessageStoreChangedEventArgs>): void;

/**
 * Attempts a retry of sending a specified message from the message store.
 * @param localChatMessageId The local ID of the message to be retried.
 * @return An asynchronous action.
 */
retrySendMessageAsync(localChatMessageId: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously saves a message to the ChatMessageStore .
 * @param chatMessage The message to save.
 * @return An async action indicating that the operation has finished.
 */
saveMessageAsync(
chatMessage: Windows$ApplicationModel$Chat$ChatMessage): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Attempts to send a chat message. The message is saved to the message store as part of the send operation.
 * @param chatMessage The chat message to be sent.
 * @return An asynchronous action.
 */
sendMessageAsync(
chatMessage: Windows$ApplicationModel$Chat$ChatMessage): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously attempts to cancel downloading the specified message.
 * @param localChatMessageId The ID of the message to stop downloading.
 * @return An async action indicating that the operation has completed.
 */
tryCancelDownloadMessageAsync(
localChatMessageId: string): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously attempts to cancel sending the specified message.
 * @param localChatMessageId The ID of the message to stop sending.
 * @return An async action indicating that the operation has completed.
 */
tryCancelSendMessageAsync(
localChatMessageId: string): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Checks if a chat message is valid and returns the validation result.
 * @param chatMessage The chat message to validate.
 * @return The validation result.
 */
validateMessage(
chatMessage: Windows$ApplicationModel$Chat$ChatMessage): Windows$ApplicationModel$Chat$ChatMessageValidationResult;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides the data for the ChatMessageStoreChanged event.
 */
declare class Windows$ApplicationModel$Chat$ChatMessageStoreChangedEventArgs  {

/**
 * Gets the ID of the object that changed.
 */
id: string;

/**
 * Gets the type of change that happened.
 */
kind: $Values<typeof Windows$ApplicationModel$Chat$ChatStoreChangedEventKind>
}


/**
 * Represents the identity of a transport for sending and receiving messages. Physically, a chat message transport is a SIM slot on the phone.
 */
declare class Windows$ApplicationModel$Chat$ChatMessageTransport  {

/**
 * Gets the configuration of the message transport.
 */
configuration: Windows$ApplicationModel$Chat$ChatMessageTransportConfiguration;

/**
 * Gets a Boolean value that indicates whether the messaging transport is active.
 */
isActive: boolean;

/**
 * Gets a Boolean value that indicates whether the current application is set as the messaging notification provider.
 */
isAppSetAsNotificationProvider: boolean;

/**
 * Sets the current application to handle messaging notifications.
 * @return An asynchronous action.
 */
requestSetAsNotificationProviderAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets a descriptive name identifying the messaging transport.
 */
transportFriendlyName: string;

/**
 * Gets the messaging transports identifier.
 */
transportId: string;

/**
 * Gets the type of the message transport.
 */
transportKind: $Values<typeof Windows$ApplicationModel$Chat$ChatMessageTransportKind>
}


/**
 * Represents data about the chat message transport.
 */
declare class Windows$ApplicationModel$Chat$ChatMessageTransportConfiguration  {

/**
 * Gets the extended properties of the transport.
 */
extendedProperties: Windows$Foundation$Collections$IMapView<string, any>;

/**
 * Gets the maximum attachment limit for a message on the transport.
 */
maxAttachmentCount: number;

/**
 * Gets the maximum size of an attachment for the transport.
 */
maxMessageSizeInKilobytes: number;

/**
 * Gets the maximum number of recipients for the transport.
 */
maxRecipientCount: number;

/**
 * Gets the supported video encoding format for the transport.
 */
supportedVideoFormat: Windows$Media$MediaProperties$MediaEncodingProfile
}


/**
 * Specifies the type of the message transport.
 */

declare  var Windows$ApplicationModel$Chat$ChatMessageTransportKind: {|
  +text: 0,// 0
+untriaged: 1,// 1
+blocked: 2,// 2
+custom: 3,// 3

|};



/**
 * Provides results for validation of chat messages.
 */
declare class Windows$ApplicationModel$Chat$ChatMessageValidationResult  {

/**
 * Gets the maximum number of text fragments allowed for a message. This value has meaning when the SMS text portion of a message is validated.
 */
maxPartCount: number;

/**
 * Gets the total number of text fragments needed for this message. This value has meaning when the SMS text portion of a message is validated.
 */
partCount: number;

/**
 * Gets the number of characters not used in the final message fragments. This value has meaning when the SMS text portion of a message is validated.
 */
remainingCharacterCountInPart: number;

/**
 * Gets the message validation status code.
 */
status: $Values<typeof Windows$ApplicationModel$Chat$ChatMessageValidationStatus>
}


/**
 * Specifies the validation state of a chat message such as valid, no recipients, or too many attachments.
 */

declare  var Windows$ApplicationModel$Chat$ChatMessageValidationStatus: {|
  +valid: 0,// 0
+noRecipients: 1,// 1
+invalidData: 2,// 2
+messageTooLarge: 3,// 3
+tooManyRecipients: 4,// 4
+transportInactive: 5,// 5
+transportNotFound: 6,// 6
+tooManyAttachments: 7,// 7
+invalidRecipients: 8,// 8
+invalidBody: 9,// 9
+invalidOther: 10,// 10

|};



/**
 * Represents the criteria for finding chat messages.
 */
declare class Windows$ApplicationModel$Chat$ChatQueryOptions  {

/**
 * Initializes a new instance of the ChatQueryOptions class.
 */
constructor(): this;

/**
 * Gets or sets the string to search for the in ChatMessageStore .
 */
searchString: string
}


/**
 * Represent the delivery info about a chat recipient.
 */
declare class Windows$ApplicationModel$Chat$ChatRecipientDeliveryInfo  {

/**
 * Initializes a new instance of the ChatRecipientDeliveryInfo class.
 */
constructor(): this;

/**
 * Gets or sets the time the message was sent to the recipient.
 */
deliveryTime: Date;

/**
 * Gets a Boolean value indicating whether the error for the message that was sent to the recipient is permanent.
 */
isErrorPermanent: boolean;

/**
 * Gets or sets the time the recipient read the message.
 */
readTime: Date;

/**
 * Gets the status of the message.
 */
status: $Values<typeof Windows$ApplicationModel$Chat$ChatMessageStatus>;

/**
 * Gets or sets the transport address of the recipient.
 */
transportAddress: string;

/**
 * Get the transport error code.
 */
transportErrorCode: number;

/**
 * Gets the category for the TransportErrorCode .
 */
transportErrorCodeCategory: $Values<typeof Windows$ApplicationModel$Chat$ChatTransportErrorCodeCategory>;

/**
 * Gets the interpreted error code for the transport.
 */
transportInterpretedErrorCode: $Values<typeof Windows$ApplicationModel$Chat$ChatTransportInterpretedErrorCode>
}


/**
 * Provides functionality to search for chat messages in the ChatMessageStore .
 */
declare class Windows$ApplicationModel$Chat$ChatSearchReader  {

/**
 * Returns a batch of found items matching the search criteria.
 * @param count The maximum number of items to return.
 * @return A list of items matching the search criteria.
 */
readBatchAsync(
count: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Returns a batch of found items matching the search criteria.
 * @return A list of items matching the search criteria.
 */
readBatchAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>
}


/**
 * Specifies the type of change that occurred for a ChatMessageStoreChanged event.
 */

declare  var Windows$ApplicationModel$Chat$ChatStoreChangedEventKind: {|
  +notificationsMissed: 0,// 0
+storeModified: 1,// 1
+messageCreated: 2,// 2
+messageModified: 3,// 3
+messageDeleted: 4,// 4
+conversationModified: 5,// 5
+conversationDeleted: 6,// 6
+conversationTransportDeleted: 7,// 7

|};



/**
 * Specifies the category of a transport error.
 */

declare  var Windows$ApplicationModel$Chat$ChatTransportErrorCodeCategory: {|
  +none: 0,// 0
+http: 1,// 1
+network: 2,// 2
+mmsServer: 3,// 3

|};



/**
 * Specifies an interpretation for the error code.
 */

declare  var Windows$ApplicationModel$Chat$ChatTransportInterpretedErrorCode: {|
  +none: 0,// 0
+unknown: 1,// 1
+invalidRecipientAddress: 2,// 2
+networkConnectivity: 3,// 3
+serviceDenied: 4,// 4
+timeout: 5,// 5

|};



/**
 * Represents a Rich Communication Services (RCS) end user message.
 */
declare class Windows$ApplicationModel$Chat$RcsEndUserMessage  {

/**
 * Gets the actions to which the user can respond.
 */
actions: Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Chat$RcsEndUserMessageAction>;

/**
 * Gets a Boolean value that specifies whether a PIN is required to be sent back with the response.
 */
isPinRequired: boolean;

/**
 * Asynchronously sends the user's selection back.
 * @param action Specifies the label of the action.
 * @return An async action indicating that the operation has completed.
 */
sendResponseAsync(
action: Windows$ApplicationModel$Chat$RcsEndUserMessageAction): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously sends the user's selection back with the specified PIN.
 * @param action Specifies the label of the action.
 * @param pin The PIN to send.
 * @return An async action indicating that the operation has completed.
 */
sendResponseWithPinAsync(
action: Windows$ApplicationModel$Chat$RcsEndUserMessageAction,
pin: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the contents of the message.
 */
text: string;

/**
 * Gets the title of the message.
 */
title: string;

/**
 * Gets the ID of the transport where this message originated.
 */
transportId: string
}


/**
 * Represents the actions to which the user can respond.
 */
declare class Windows$ApplicationModel$Chat$RcsEndUserMessageAction  {

/**
 * Gets the label of the action.
 */
label: string
}


/**
 * Provides the data for a MessageAvailableChanged event.
 */
declare class Windows$ApplicationModel$Chat$RcsEndUserMessageAvailableEventArgs  {

/**
 * Gets a Boolean value indicating if a new message is available.
 */
isMessageAvailable: boolean;

/**
 * Gets the actual message to display, or empty if IsMessageAvailable is FALSE.
 */
message: Windows$ApplicationModel$Chat$RcsEndUserMessage
}


/**
 * Provides data to the background task about a new message.
 */
declare class Windows$ApplicationModel$Chat$RcsEndUserMessageAvailableTriggerDetails  {

/**
 * Gets the text of the new message.
 */
text: string;

/**
 * Gets the title of the new message.
 */
title: string
}


/**
 * Provides functionality for handling message events.
 */
declare class Windows$ApplicationModel$Chat$RcsEndUserMessageManager  {

/**
 * Occurs when a new message is available.
 */
onmessageavailablechanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Chat$RcsEndUserMessageManager, Windows$ApplicationModel$Chat$RcsEndUserMessageAvailableEventArgs>;
addEventListener(
type: "messageavailablechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Chat$RcsEndUserMessageManager, Windows$ApplicationModel$Chat$RcsEndUserMessageAvailableEventArgs>): void;
removeEventListener(
type: "messageavailablechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Chat$RcsEndUserMessageManager, Windows$ApplicationModel$Chat$RcsEndUserMessageAvailableEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides access to APIs for handling Rich Communication Services (RCS) messages.
 */
declare class Windows$ApplicationModel$Chat$RcsManager  {

/**
 * Gets the RcsEndUserMessageManager .
 * @return The end user message manager.
 */
static getEndUserMessageManager(): Windows$ApplicationModel$Chat$RcsEndUserMessageManager;

/**
 * Gets an instance of RcsTransport for the specified transport ID.
 * @param transportId The ID of the transport to retrieve.
 * @return An instance of the transport specified by the transportId parameter.
 */
static getTransportAsync(
transportId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Chat$RcsTransport>;

/**
 * Gets all instances of RcsTransport .
 * @return A list of RcsTransport instances.
 */
static getTransportsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously allows a user to leave a particular conversation.
 * @param conversation The conversation to leave.
 * @return An async action indicating that the operation has completed.
 */
static leaveConversationAsync(
conversation: Windows$ApplicationModel$Chat$ChatConversation): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Specifies the type of the Rich Communication Services (RCS) service.
 */

declare  var Windows$ApplicationModel$Chat$RcsServiceKind: {|
  +chat: 0,// 0
+groupChat: 1,// 1
+fileTransfer: 2,// 2
+capability: 3,// 3

|};



/**
 * Provides data for the ServiceKindSupportedChanged event.
 */
declare class Windows$ApplicationModel$Chat$RcsServiceKindSupportedChangedEventArgs  {

/**
 * Gets the type of the Rich Communication Services (RCS) service.
 */
serviceKind: $Values<typeof Windows$ApplicationModel$Chat$RcsServiceKind>
}


/**
 * Provides functionality for accessing the Rich Communication Services (RCS) transport.
 */
declare class Windows$ApplicationModel$Chat$RcsTransport  {

/**
 * Gets a configuration object that describes the transport settings.
 */
configuration: Windows$ApplicationModel$Chat$RcsTransportConfiguration;

/**
 * Gets a name-value pair for extensibility of service provider configuration values.
 */
extendedProperties: Windows$Foundation$Collections$IMapView<string, any>;

/**
 * Gets a Boolean value indicating if the transport is active.
 */
isActive: boolean;

/**
 * Gets a Boolean value indicating if the specified service kind is supported, such as chat, group chat, file transfer, and so on.
 * @param serviceKind The service kind to verify.
 * @return TRUE if the RcsServiceKind specified in the serviceKind parameter is supported.
 */
isServiceKindSupported(
serviceKind: $Values<typeof Windows$ApplicationModel$Chat$RcsServiceKind>): boolean;

/**
 * Gets a Boolean value indicating if the specified service kind supports store and forward functionality.
 * @param serviceKind The service kind to check for store and forward functionality.
 * @return A Boolean value indicating if the serviceKind supports store and forward.
 */
isStoreAndForwardEnabled(
serviceKind: $Values<typeof Windows$ApplicationModel$Chat$RcsServiceKind>): boolean;

/**
 * Occurs when the service capabilities change.
 */
onservicekindsupportedchanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Chat$RcsTransport, Windows$ApplicationModel$Chat$RcsServiceKindSupportedChangedEventArgs>;
addEventListener(
type: "servicekindsupportedchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Chat$RcsTransport, Windows$ApplicationModel$Chat$RcsServiceKindSupportedChangedEventArgs>): void;
removeEventListener(
type: "servicekindsupportedchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Chat$RcsTransport, Windows$ApplicationModel$Chat$RcsServiceKindSupportedChangedEventArgs>): void;

/**
 * Gets the friendly name of the transport.
 */
transportFriendlyName: string;

/**
 * Gets the ID for the transport that is unique on the device.
 */
transportId: string;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data about the configuration of a Rich Communication Services (RCS) transport.
 */
declare class Windows$ApplicationModel$Chat$RcsTransportConfiguration  {

/**
 * Gets the maximum number of attachments supported by the transport.
 */
maxAttachmentCount: number;

/**
 * Gets the maximum size of a file that can be sent using the transport.
 */
maxFileSizeInKilobytes: number;

/**
 * Gets the maximum size of a group chat message supported by the transport.
 */
maxGroupMessageSizeInKilobytes: number;

/**
 * Gets the maximum size of a chat message supported by the transport.
 */
maxMessageSizeInKilobytes: number;

/**
 * Gets the maximum number of recipients supported for a group chat.
 */
maxRecipientCount: number;

/**
 * Gets the size at which the user should be warned that they are attaching a large file for the transport.
 */
warningFileSizeInKilobytes: number
}


/**
 * Provides data to the RemoteParticipantComposingChanged event.
 */
declare class Windows$ApplicationModel$Chat$RemoteParticipantComposingChangedEventArgs  {

/**
 * Gets a Boolean value indicating if the remote participant is currently composing a message.
 */
isComposing: boolean;

/**
 * Gets the address of the remote chat participant.
 */
participantAddress: string;

/**
 * Gets the ID for the message transport.
 */
transportId: string
}


      declare var npm$namespace$Windows$ApplicationModel$Contacts: {
        
        
        ContactAddressKind: typeof Windows$ApplicationModel$Contacts$ContactAddressKind,
ContactAnnotationOperations: typeof Windows$ApplicationModel$Contacts$ContactAnnotationOperations,
ContactAnnotationStoreAccessType: typeof Windows$ApplicationModel$Contacts$ContactAnnotationStoreAccessType,
ContactBatchStatus: typeof Windows$ApplicationModel$Contacts$ContactBatchStatus,
ContactCardHeaderKind: typeof Windows$ApplicationModel$Contacts$ContactCardHeaderKind,
ContactCardTabKind: typeof Windows$ApplicationModel$Contacts$ContactCardTabKind,
ContactChangeType: typeof Windows$ApplicationModel$Contacts$ContactChangeType,
ContactDateKind: typeof Windows$ApplicationModel$Contacts$ContactDateKind,
ContactEmailKind: typeof Windows$ApplicationModel$Contacts$ContactEmailKind,
ContactFieldCategory: typeof Windows$ApplicationModel$Contacts$ContactFieldCategory,
ContactFieldType: typeof Windows$ApplicationModel$Contacts$ContactFieldType,
ContactListOtherAppReadAccess: typeof Windows$ApplicationModel$Contacts$ContactListOtherAppReadAccess,
ContactListOtherAppWriteAccess: typeof Windows$ApplicationModel$Contacts$ContactListOtherAppWriteAccess,
ContactListSyncStatus: typeof Windows$ApplicationModel$Contacts$ContactListSyncStatus,
ContactMatchReasonKind: typeof Windows$ApplicationModel$Contacts$ContactMatchReasonKind,
ContactNameOrder: typeof Windows$ApplicationModel$Contacts$ContactNameOrder,
ContactPhoneKind: typeof Windows$ApplicationModel$Contacts$ContactPhoneKind,
ContactQueryDesiredFields: typeof Windows$ApplicationModel$Contacts$ContactQueryDesiredFields,
ContactQuerySearchFields: typeof Windows$ApplicationModel$Contacts$ContactQuerySearchFields,
ContactQuerySearchScope: typeof Windows$ApplicationModel$Contacts$ContactQuerySearchScope,
ContactRelationship: typeof Windows$ApplicationModel$Contacts$ContactRelationship,
ContactSelectionMode: typeof Windows$ApplicationModel$Contacts$ContactSelectionMode,
ContactStoreAccessType: typeof Windows$ApplicationModel$Contacts$ContactStoreAccessType,
        AggregateContactManager: typeof Windows$ApplicationModel$Contacts$AggregateContactManager,
Contact: typeof Windows$ApplicationModel$Contacts$Contact,
ContactAddress: typeof Windows$ApplicationModel$Contacts$ContactAddress,
ContactAnnotation: typeof Windows$ApplicationModel$Contacts$ContactAnnotation,
ContactAnnotationList: typeof Windows$ApplicationModel$Contacts$ContactAnnotationList,
ContactAnnotationStore: typeof Windows$ApplicationModel$Contacts$ContactAnnotationStore,
ContactBatch: typeof Windows$ApplicationModel$Contacts$ContactBatch,
ContactCardDelayedDataLoader: typeof Windows$ApplicationModel$Contacts$ContactCardDelayedDataLoader,
ContactCardOptions: typeof Windows$ApplicationModel$Contacts$ContactCardOptions,
ContactChange: typeof Windows$ApplicationModel$Contacts$ContactChange,
ContactChangeReader: typeof Windows$ApplicationModel$Contacts$ContactChangeReader,
ContactChangeTracker: typeof Windows$ApplicationModel$Contacts$ContactChangeTracker,
ContactChangedDeferral: typeof Windows$ApplicationModel$Contacts$ContactChangedDeferral,
ContactChangedEventArgs: typeof Windows$ApplicationModel$Contacts$ContactChangedEventArgs,
ContactConnectedServiceAccount: typeof Windows$ApplicationModel$Contacts$ContactConnectedServiceAccount,
ContactDate: typeof Windows$ApplicationModel$Contacts$ContactDate,
ContactEmail: typeof Windows$ApplicationModel$Contacts$ContactEmail,
ContactField: typeof Windows$ApplicationModel$Contacts$ContactField,
ContactFieldFactory: typeof Windows$ApplicationModel$Contacts$ContactFieldFactory,
ContactInformation: typeof Windows$ApplicationModel$Contacts$ContactInformation,
ContactInstantMessageField: typeof Windows$ApplicationModel$Contacts$ContactInstantMessageField,
ContactJobInfo: typeof Windows$ApplicationModel$Contacts$ContactJobInfo,
ContactLaunchActionVerbs: typeof Windows$ApplicationModel$Contacts$ContactLaunchActionVerbs,
ContactList: typeof Windows$ApplicationModel$Contacts$ContactList,
ContactListSyncManager: typeof Windows$ApplicationModel$Contacts$ContactListSyncManager,
ContactLocationField: typeof Windows$ApplicationModel$Contacts$ContactLocationField,
ContactManager: typeof Windows$ApplicationModel$Contacts$ContactManager,
ContactMatchReason: typeof Windows$ApplicationModel$Contacts$ContactMatchReason,
ContactPhone: typeof Windows$ApplicationModel$Contacts$ContactPhone,
ContactPicker: typeof Windows$ApplicationModel$Contacts$ContactPicker,
ContactQueryOptions: typeof Windows$ApplicationModel$Contacts$ContactQueryOptions,
ContactQueryTextSearch: typeof Windows$ApplicationModel$Contacts$ContactQueryTextSearch,
ContactReader: typeof Windows$ApplicationModel$Contacts$ContactReader,
ContactSignificantOther: typeof Windows$ApplicationModel$Contacts$ContactSignificantOther,
ContactStore: typeof Windows$ApplicationModel$Contacts$ContactStore,
ContactStoreNotificationTriggerDetails: typeof Windows$ApplicationModel$Contacts$ContactStoreNotificationTriggerDetails,
ContactWebsite: typeof Windows$ApplicationModel$Contacts$ContactWebsite,
FullContactCardOptions: typeof Windows$ApplicationModel$Contacts$FullContactCardOptions,
KnownContactField: typeof Windows$ApplicationModel$Contacts$KnownContactField,
        Provider: typeof npm$namespace$Windows$ApplicationModel$Contacts$Provider,
      }

/**
 * Provides functionality for linking individual (raw) contacts across services together into a single aggregate contact.
 */
declare class Windows$ApplicationModel$Contacts$AggregateContactManager  {

/**
 * Returns the list of individual (raw) contacts from the specified aggregate contact.
 * @param contact The aggregate contact from which to extract the list of raw contacts.
 * @return The list of individual (raw) contacts from the specified aggregate contact.
 */
findRawContactsAsync(
contact: Windows$ApplicationModel$Contacts$Contact): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously attempts to link contacts together to make an aggregate contact.
 * @param primaryContact The first contact to link.
 * @param secondaryContact The second contact to link to the primaryContact.
 * @return The newly created aggregate contact.
 */
tryLinkContactsAsync(
primaryContact: Windows$ApplicationModel$Contacts$Contact,
secondaryContact: Windows$ApplicationModel$Contacts$Contact): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$Contact>;

/**
 * Chooses which of the raw contacts provides the main display picture for the aggregate.
 * @param aggregateContact The aggregate contact on which to set the picture.
 * @param rawContact The raw contact that provides the picture for the aggregate.
 * @return True if successful, otherwise false.
 */
trySetPreferredSourceForPictureAsync(
aggregateContact: Windows$ApplicationModel$Contacts$Contact,
rawContact: Windows$ApplicationModel$Contacts$Contact): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously unlinks a raw contact from the parent aggregate contact.
 * @param contact The raw contact to remove from the aggregate.
 * @return An async action that indicates the operation is complete.
 */
unlinkRawContactAsync(
contact: Windows$ApplicationModel$Contacts$Contact): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Represents a contact.
 */
declare class Windows$ApplicationModel$Contacts$Contact  {

/**
 * Creates a new instance of the Contact class.
 */
constructor(): this;

/**
 * Gets the contact addresses for a contact.
 */
addresses: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Contacts$ContactAddress>;

/**
 * If this is a raw contact that is part of an aggregate contact, then this property identifies the parent aggregate.
 */
aggregateId: string;

/**
 * Gets the connected service accounts for a contact.
 */
connectedServiceAccounts: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Contacts$ContactConnectedServiceAccount>;

/**
 * Gets a string that identifies the ContactList to which this contact is a member.
 */
contactListId: string;

/**
 * Gets the data suppliers for a contact. The maximum string length for each data supplier is 50 characters.
 */
dataSuppliers: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets the display name for a contact.
 */
displayName: string;

/**
 * Gets or sets the display that was manually entered by the user.
 */
displayNameOverride: string;

/**
 * Gets or sets the last time the user updated their display picture.
 */
displayPictureUserUpdateTime: Date;

/**
 * Gets the email addresses for a contact.
 */
emails: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Contacts$ContactEmail>;

/**
 * Sets the fields that contain information about a contact.
 */
fields: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Contacts$IContactField>;

/**
 * Gets and sets the first name for a contact. The maximum string length for the first name is 64 characters.
 */
firstName: string;

/**
 * Gets the full name of the Contact .
 */
fullName: string;

/**
 * Gets and sets the honorific prefix for the name for a contact. The maximum string length for the honorific prefix is 32 characters.
 */
honorificNamePrefix: string;

/**
 * Gets and sets the honorific suffix for the name for a contact. The maximum string length for the honorific suffix is 32 characters.
 */
honorificNameSuffix: string;

/**
 * Gets and sets the identifier for a contact. The maximum string length for the identifier is 256 characters.
 */
id: string;

/**
 * Gets the important dates for a contact.
 */
importantDates: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Contacts$ContactDate>;

/**
 * Gets a Boolean value indicating of this is an aggregate Contact .
 */
isAggregate: boolean;

/**
 * Gets a Boolean value indicating if the user manually set the picture for the Contact .
 */
isDisplayPictureManuallySet: boolean;

/**
 * Gets a Boolean value indicating if this Contact represents the user logged into the device.
 */
isMe: boolean;

/**
 * Gets the job info items for a contact.
 */
jobInfo: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Contacts$ContactJobInfo>;

/**
 * Gets a large version of the display picture for the Contact .
 */
largeDisplayPicture: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets and sets the last name for a contact. The maximum string length for the last name is 64 characters.
 */
lastName: string;

/**
 * Gets and sets the middle name for a contact. The maximum string length for the middle name is 64 characters.
 */
middleName: string;

/**
 * Sets and gets the name of the contact.
 */
name: string;

/**
 * Gets or sets the nickname for the Contact .
 */
nickname: string;

/**
 * Gets and sets notes for a contact. The maximum string length for notes is 4096 characters.
 */
notes: string;

/**
 * Gets info about the phones for a contact.
 */
phones: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Contacts$ContactPhone>;

/**
 * Gets the property set object for the contact.
 */
providerProperties: Windows$Foundation$Collections$IPropertySet;

/**
 * Gets or sets an ID that can be used by a service provider to access the Contact in their remote system.
 */
remoteId: string;

/**
 * Gets or puts the path to the ringtone file for the Contact .
 */
ringToneToken: string;

/**
 * Gets the significant others for a contact.
 */
significantOthers: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Contacts$ContactSignificantOther>;

/**
 * Gets a small version of the display picture for the Contact .
 */
smallDisplayPicture: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets the name used to sort the contact.
 */
sortName: string;

/**
 * Gets or sets the display picture for the Contact in its original size.
 */
sourceDisplayPicture: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets or puts the path to the audio file to play when an SMS/MMS message is received from the Contact .
 */
textToneToken: string;
thumbnail: any;

/**
 * Gets the Web sites for a contact.
 */
websites: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Contacts$ContactWebsite>;

/**
 * Gets the Yomi (phonetic Japanese equivalent) display name for a contact.
 */
yomiDisplayName: string;

/**
 * Gets the Yomi (phonetic Japanese equivalent) family name for a contact. The maximum string length for the Yomi family name is 120 characters.
 */
yomiFamilyName: string;

/**
 * Gets the Yomi (phonetic Japanese equivalent) given name for a contact. The maximum string length for the Yomi given name is 120 characters.
 */
yomiGivenName: string
}


/**
 * Represents the address of a contact.
 */
declare class Windows$ApplicationModel$Contacts$ContactAddress  {

/**
 * Initializes a new instance of a ContactAddress class.
 */
constructor(): this;

/**
 * Gets and sets the country of a contact address. The maximum string length for the country is 1024 characters.
 */
country: string;

/**
 * Gets and sets the description of a contact address. The maximum string length for the description is 512 characters.
 */
description: string;

/**
 * Gets and sets the kind of contact address.
 */
kind: $Values<typeof Windows$ApplicationModel$Contacts$ContactAddressKind>;

/**
 * Gets and sets the locality of a contact address. The maximum string length for the locality is 1024 characters.
 */
locality: string;

/**
 * Gets and sets the postal code of a contact address. The maximum string length for the postal code is 1024 characters.
 */
postalCode: string;

/**
 * Gets and sets the region of a contact address. The maximum string length for the region is 1024 characters.
 */
region: string;

/**
 * Gets and sets the street address of a contact address. The maximum string length for the street address is 1024 characters.
 */
streetAddress: string
}


/**
 * Specifies the kinds of contact addresses.
 */

declare  var Windows$ApplicationModel$Contacts$ContactAddressKind: {|
  +home: 0,// 0
+work: 1,// 1
+other: 2,// 2

|};



/**
 * Provides a way to tag existing user contacts with additional information, specifying that your app can perform some SupportedOperations for this particular contact.
 */
declare class Windows$ApplicationModel$Contacts$ContactAnnotation  {

/**
 * Initializes a new instance of the ContactAnnotation class.
 */
constructor(): this;

/**
 * Gets the ID for the parent ContactAnnotationList that this ContactAnnotation is contained within.
 */
annotationListId: string;

/**
 * Gets or set the ID for the Contact to which this ContactAnnotation applies.
 */
contactId: string;

/**
 * Gets the ID for this ContactAnnotation .
 */
id: string;

/**
 * Gets a Boolean value indicating if this ContactAnnotation has been disabled by the user.
 */
isDisabled: boolean;

/**
 * Provides a place to store data to be used by the app when interacting with a service provider.
 */
providerProperties: Windows$Foundation$Collections$ValueSet;

/**
 * Gets or sets an ID that can be used by a service provider to access the corresponding entity in their remote system.
 */
remoteId: string;

/**
 * Gets or sets the group of ContactAnnotationOperations supported by this ContactAnnotation .
 */
supportedOperations: $Values<typeof Windows$ApplicationModel$Contacts$ContactAnnotationOperations>
}


/**
 * Represents a list of ContactAnnotation objects.
 */
declare class Windows$ApplicationModel$Contacts$ContactAnnotationList  {

/**
 * Asynchronously deletes the specified ContactAnnotation from the list.
 * @param annotation The annotation to delete from the list.
 * @return An async action indicating that the operation has completed.
 */
deleteAnnotationAsync(
annotation: Windows$ApplicationModel$Contacts$ContactAnnotation): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously deletes this ContactAnnotationList from the ContactAnnotationStore .
 * @return An async action indicating that the operation has completed.
 */
deleteAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously gets the list of ContactAnnotation objects.
 * @return The list of ContactAnnotation objects.
 */
findAnnotationsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the list of ContactAnnotation objects containing the specified remote ID property.
 * @param remoteId The remote ID used to find the ContactAnnotation objects.
 * @return The list of ContactAnnotation objects containing the specified remote ID property.
 */
findAnnotationsByRemoteIdAsync(
remoteId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the ContactAnnotation with the specified Id .
 * @param annotationId The ContactAnnotation.Id used to identify the ContactAnnotation .
 * @return The ContactAnnotation with the specified ID.
 */
getAnnotationAsync(
annotationId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$ContactAnnotation>;

/**
 * Gets the ID for this ContactAnnotationList .
 */
id: string;

/**
 * Gets the unique identifier for the app package that created the ContactAnnotationList .
 */
providerPackageFamilyName: string;

/**
 * Asynchronously attempts to save the ContactAnnotation to the ContactAnnotationList .
 * @param annotation The annotation to save to the list.
 * @return True if the save was successful, otherwise false.
 */
trySaveAnnotationAsync(
annotation: Windows$ApplicationModel$Contacts$ContactAnnotation): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets the ID for the UserDataAccount used by the app.
 */
userDataAccountId: string
}


/**
 * Specifies the types of operations you can perform with a Contact .
 */

declare  var Windows$ApplicationModel$Contacts$ContactAnnotationOperations: {|
  +none: 0,// 0
+contactProfile: 1,// 1
+message: 2,// 2
+audioCall: 3,// 3
+videoCall: 4,// 4
+socialFeeds: 5,// 5

|};



/**
 * Represents a data store that contains contact annotations.
 */
declare class Windows$ApplicationModel$Contacts$ContactAnnotationStore  {

/**
 * Asynchronously creates a ContactAnnotationList and associates it with the specified user data account ID.
 * @param userDataAccountId The ID for the user data account with which to associate the new ContactAnnotationList . The user data account must be owned by this app.
 * @return The newly created ContactAnnotationList .
 */
createAnnotationListAsync(
userDataAccountId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$ContactAnnotationList>;

/**
 * Asynchronously creates a ContactAnnotationList .
 * @return The newly created ContactAnnotationList .
 */
createAnnotationListAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$ContactAnnotationList>;

/**
 * Asynchronously disables the specified ContactAnnotation , usually as a result of user input.
 * @param annotation The annotation to disable.
 * @return An async action indicating that the operation has completed.
 */
disableAnnotationAsync(
annotation: Windows$ApplicationModel$Contacts$ContactAnnotation): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously gets the list of ContactAnnotationList objects for the app.
 * @return The list of ContactAnnotationList objects.
 */
findAnnotationListsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Get the annotations for the specified Contact .
 * @param contact The Contact for which to retrieve annotations.
 * @return The list of ContactAnnotation objects.
 */
findAnnotationsForContactAsync(
contact: Windows$ApplicationModel$Contacts$Contact): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets a list of Id values based on Contact objects with a specified email address.
 * @param emailAddress The email address used to find the contact Id values.
 * @return The list of Contact objects containing the specified emailAddress.
 */
findContactIdsByEmailAsync(
emailAddress: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets a list of Id values based on Contact objects with a specified phone number.
 * @param phoneNumber The phone number used to find the contact Id values.
 * @return The list of Contact objects containing the specified phoneNumber.
 */
findContactIdsByPhoneNumberAsync(
phoneNumber: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously gets the ContactAnnotationList with the specified ID.
 * @param annotationListId The ID of the ContactAnnotationList to get.
 * @return The ContactAnnotationList with the ID specified in annotationListId.
 */
getAnnotationListAsync(
annotationListId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$ContactAnnotationList>
}


/**
 * Specifies if the app can read and write all annotations or only those belonging to the app itself.
 */

declare  var Windows$ApplicationModel$Contacts$ContactAnnotationStoreAccessType: {|
  +appAnnotationsReadWrite: 0,// 0
+allAnnotationsReadWrite: 1,// 1

|};



/**
 * Represents a group of Contact objects and server search status.
 */
declare class Windows$ApplicationModel$Contacts$ContactBatch  {

/**
 * Gets the list of Contact objects returned by a search operation.
 */
contacts: Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Contacts$Contact>;

/**
 * Gets a ContactBatchStatus value that indicates if a search was successful or if there was a server error.
 */
status: $Values<typeof Windows$ApplicationModel$Contacts$ContactBatchStatus>
}


/**
 * Specifies if the last batch access operation was successful or if there was a server error.
 */

declare  var Windows$ApplicationModel$Contacts$ContactBatchStatus: {|
  +success: 0,// 0
+serverSearchSyncManagerError: 1,// 1
+serverSearchUnknownError: 2,// 2

|};



/**
 * Represents a delayed data loader for a contact card.
 */
declare class Windows$ApplicationModel$Contacts$ContactCardDelayedDataLoader  {

/**
 * Closes the delayed data loader. This informs the contact card to complete the UI (for example, remove any progress indications, like the progress bar) because no more updates to the contact card UI will be requested. The user then can determine that the contact data shown in the UI is complete.
 */
close(): void;

/**
 * Updates the contact card with the Contact object and completes the contact card UI.
 * @param contact The contact to update the contact card with.
 */
setData(contact: Windows$ApplicationModel$Contacts$Contact): void
}


/**
 * Specifies the type of header information to show on a contact card.
 */

declare  var Windows$ApplicationModel$Contacts$ContactCardHeaderKind: {|
  +default: 0,// 0
+basic: 1,// 1
+enterprise: 2,// 2

|};



/**
 * Represents data about how to display a mini contact card.
 */
declare class Windows$ApplicationModel$Contacts$ContactCardOptions  {

/**
 * Initializes a new instance of the ContactCardOptions class.
 */
constructor(): this;

/**
 * Gets or sets a value that specifies the type of header to display on the contact card.
 */
headerKind: $Values<typeof Windows$ApplicationModel$Contacts$ContactCardHeaderKind>;

/**
 * Gets or sets a value that indicates which tab to display first on a mini contact card.
 */
initialTabKind: $Values<typeof Windows$ApplicationModel$Contacts$ContactCardTabKind>;

/**
 * Gets a list to which you can add ContactList.Id values to search for on the server.
 */
serverSearchContactListIds: Windows$Foundation$Collections$IVector<string>
}


/**
 * Specifies which tab to display on a mini contact card.
 */

declare  var Windows$ApplicationModel$Contacts$ContactCardTabKind: {|
  +default: 0,// 0
+email: 1,// 1
+messaging: 2,// 2
+phone: 3,// 3
+video: 4,// 4

|};



/**
 * Represents a change to a Contact .
 */
declare class Windows$ApplicationModel$Contacts$ContactChange  {

/**
 * Gets a value that indicates the type of change that occurred.
 */
changeType: $Values<typeof Windows$ApplicationModel$Contacts$ContactChangeType>;

/**
 * Gets the Contact object that changed.
 */
contact: Windows$ApplicationModel$Contacts$Contact
}


/**
 * Provides a way to monitor and react to changes to contacts.
 */
declare class Windows$ApplicationModel$Contacts$ContactChangeReader  {

/**
 * Call this method to indicate that you have processed and accepted all changes and you don't want the system to show them to you again.
 */
acceptChanges(): void;

/**
 * Call this method to indicate that you have processed and accepted up through the specified change.
 * @param lastChangeToAccept The last change that you want to system to track as accepted by your app.
 */
acceptChangesThrough(lastChangeToAccept: Windows$ApplicationModel$Contacts$ContactChange): void;

/**
 * Asynchronously gets a list of ContactChange objects.
 * @return A list of ContactChange objects.
 */
readBatchAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>
}


/**
 * Provides functionality for monitoring changes to Contact objects in the ContactStore .
 */
declare class Windows$ApplicationModel$Contacts$ContactChangeTracker  {

/**
 * Call this method to enable change tracking.
 */
enable(): void;

/**
 * Gets a ContactChangeReader that can be used to process changes.
 * @return A ContactChangeReader that can be used to process changes.
 */
getChangeReader(): Windows$ApplicationModel$Contacts$ContactChangeReader;

/**
 * Call this method to reset the change tracker if your app receives ContactChangeType.ChangeTrackingLost .
 */
reset(): void
}


/**
 * Specifies the type of change that occurred for a ContactChanged event.
 */

declare  var Windows$ApplicationModel$Contacts$ContactChangeType: {|
  +created: 0,// 0
+modified: 1,// 1
+deleted: 2,// 2
+changeTrackingLost: 3,// 3

|};



/**
 * The deferral object to use while asynchronously processing ContactChanged events.
 */
declare class Windows$ApplicationModel$Contacts$ContactChangedDeferral  {

/**
 * Call this method in order to release the deferral object when all asynchronous processing has finished.
 */
complete(): void
}


/**
 * Provides data for the ContactChanged event.
 */
declare class Windows$ApplicationModel$Contacts$ContactChangedEventArgs  {

/**
 * Gets the ContactChangedDeferral object to use for asynchronous operations.
 * @return The deferral object to use for asynchronous operations.
 */
getDeferral(): Windows$ApplicationModel$Contacts$ContactChangedDeferral
}


/**
 * Represents a connected service account for a contact.
 */
declare class Windows$ApplicationModel$Contacts$ContactConnectedServiceAccount  {

/**
 * Initializes a new instance of a ContactConnectedServiceAccount class.
 */
constructor(): this;

/**
 * Gets and sets the identifier of a connected service account for a contact. The maximum string length for the identifier is 321 characters.
 */
id: string;

/**
 * Gets and sets the service name of a connected service account for a contact. The maximum string length for the service name is 256 characters.
 */
serviceName: string
}


/**
 * Represents an important date for a contact.
 */
declare class Windows$ApplicationModel$Contacts$ContactDate  {

/**
 * Initializes a new instance of a ContactDate class.
 */
constructor(): this;

/**
 * Gets and sets the day for an important date for a contact.
 */
day: number;

/**
 * Gets and sets the description for an important date for a contact. The maximum string length for the description is 512 characters.
 */
description: string;

/**
 * Gets and sets the kind of important date for a contact.
 */
kind: $Values<typeof Windows$ApplicationModel$Contacts$ContactDateKind>;

/**
 * Gets and sets the month for an important date for a contact.
 */
month: number;

/**
 * Gets and sets the year for an important date for a contact.
 */
year: number
}


/**
 * Specifies the kinds of important dates for a contact.
 */

declare  var Windows$ApplicationModel$Contacts$ContactDateKind: {|
  +birthday: 0,// 0
+anniversary: 1,// 1
+other: 2,// 2

|};



/**
 * Represents an email address of a contact.
 */
declare class Windows$ApplicationModel$Contacts$ContactEmail  {

/**
 * Initializes a new instance of a ContactEmail class.
 */
constructor(): this;

/**
 * Gets and sets the email address of a contact. The maximum string length for the description is 321 characters.
 */
address: string;

/**
 * Gets and sets the description of an email address of a contact. The maximum string length for the description is 512 characters.
 */
description: string;

/**
 * Gets and sets the kind of email address of a contact.
 */
kind: $Values<typeof Windows$ApplicationModel$Contacts$ContactEmailKind>
}


/**
 * Specifies the kinds of email addresses for a contact.
 */

declare  var Windows$ApplicationModel$Contacts$ContactEmailKind: {|
  +personal: 0,// 0
+work: 1,// 1
+other: 2,// 2

|};



/**
 * Describes a piece of contact data.
 */
declare class Windows$ApplicationModel$Contacts$ContactField  {

/**
 * Creates a new ContactField object.
 * @param name The name of the field.
 * @param value The value the field contains.
 * @param type The type of field.
 * @param category The category the field belongs to.
 */
constructor(name: string, value: string, type: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldType>, category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>): this;

/**
 * Creates a new ContactField object.
 * @param value The value for the contact field.
 * @param type The type of contact data.
 * @param category The category that the contact belongs to.
 */
constructor(value: string, type: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldType>, category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>): this;

/**
 * Creates a new ContactField object.
 * @param value The value that the field contains.
 * @param type The type of contact data.
 */
constructor(value: string, type: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldType>): this;

/**
 * Gets the category for the contact data.
 */
category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>;

/**
 * Gets the name of the field.
 */
name: string;

/**
 * Gets the contact field type for the data.
 */
type: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldType>;

/**
 * Gets the value of the contact data.
 */
value: string
}


/**
 * Defines the categories that contact data can belong to.
 */

declare  var Windows$ApplicationModel$Contacts$ContactFieldCategory: {|
  +none: 0,// 0
+home: 1,// 1
+work: 2,// 2
+mobile: 3,// 3
+other: 4,// 4

|};



/**
 * Creates fields that contain information about a contact. You can then add these fields to a Contact object to create the contact. This class is available only to apps that support the Contact contract.
 */
declare class Windows$ApplicationModel$Contacts$ContactFieldFactory  {

/**
 * Creates an instance of the ContactFieldFactory class.
 */
constructor(): this;

/**
 * Creates a field to contain information about a contact.
 * @param value The value for the field.
 * @param type The type of field.
 * @param category The category the field belongs to.
 * @return Contains a field that you can add to a Contact object.
 */
createField(
value: string,
type: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldType>,
category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>): Windows$ApplicationModel$Contacts$ContactField;

/**
 * Creates a field to contain information about a contact.
 * @param name The name of the field.
 * @param value The value of the field.
 * @param type The type of field.
 * @param category The category the field belongs to.
 * @return Contains a field that you can add to a Contact object.
 */
createField(
name: string,
value: string,
type: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldType>,
category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>): Windows$ApplicationModel$Contacts$ContactField;

/**
 * Creates a field to contain information about a contact.
 * @param value The value for the field.
 * @param type The type of field.
 * @return Contains a field that you can add to a Contact object.
 */
createField(
value: string,
type: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldType>): Windows$ApplicationModel$Contacts$ContactField;

/**
 * Creates a field to contain information about a contact's instant messaging account.
 * @param userName The user name for the instant messaging account.
 * @param category The category the field belongs to.
 * @return Contains an instant messaging field that you can add to a Contact object.
 */
createInstantMessage(
userName: string,
category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>): Windows$ApplicationModel$Contacts$ContactInstantMessageField;

/**
 * Creates a field to contain information about a contact's instant messaging account.
 * @param userName The user name of the instant messaging account.
 * @param category The category the field belongs to.
 * @param service The name of the instant messaging service.
 * @param displayText The text to display to prompt an instant messaging conversation.
 * @param verb The URI that starts an instant messaging conversation.
 * @return Contains an instant messaging field that you can add to a Contact object.
 */
createInstantMessage(
userName: string,
category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>,
service: string,
displayText: string,
verb: Windows$Foundation$Uri): Windows$ApplicationModel$Contacts$ContactInstantMessageField;

/**
 * Creates a field to contain information about a contact's instant messaging account.
 * @param userName The user name for the instant messaging account.
 * @return Contains an instant messaging field that you can add to a Contact object.
 */
createInstantMessage(userName: string): Windows$ApplicationModel$Contacts$ContactInstantMessageField;

/**
 * Creates a field to contain information about a contact's location.
 * @param unstructuredAddress The address of the contact in an unstructured format.
 * @param category The category the field belongs to.
 * @param street The street address for the address.
 * @param city The name of the city for the address.
 * @param region The name of the region for the address.
 * @param country The name of the country for the address.
 * @param postalCode The postal code for the address.
 * @return Contains a location field that you can add to a Contact object.
 */
createLocation(
unstructuredAddress: string,
category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>,
street: string,
city: string,
region: string,
country: string,
postalCode: string): Windows$ApplicationModel$Contacts$ContactLocationField;

/**
 * Creates a field to contain information about a contact's location.
 * @param unstructuredAddress The address of the contact in an unstructured format.
 * @param category The category the field belongs to.
 * @return Contains a location field that you can add to a Contact object.
 */
createLocation(
unstructuredAddress: string,
category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>): Windows$ApplicationModel$Contacts$ContactLocationField;

/**
 * Creates a field to contain information about a contact's location.
 * @param unstructuredAddress The address of the contact in an unstructured format.
 * @return Contains a location field that you can add to a Contact object.
 */
createLocation(
unstructuredAddress: string): Windows$ApplicationModel$Contacts$ContactLocationField
}


/**
 * Defines the type of contact data.
 */

declare  var Windows$ApplicationModel$Contacts$ContactFieldType: {|
  +email: 0,// 0
+phoneNumber: 1,// 1
+location: 2,// 2
+instantMessage: 3,// 3
+custom: 4,// 4
+connectedServiceAccount: 5,// 5
+importantDate: 6,// 6
+address: 7,// 7
+significantOther: 8,// 8
+notes: 9,// 9
+website: 10,// 10
+jobInfo: 11,// 11

|};



/**
 * Contains the information about a contact.
 */
declare class Windows$ApplicationModel$Contacts$ContactInformation  {

/**
 * A read-only list of the custom fields stored with the contact.
 */
customFields: Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Contacts$ContactField>;

/**
 * A read-only list of email addresses stored with the contact.
 */
emails: Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Contacts$ContactField>;

/**
 * Gets the thumbnail image for the contact.
 * @return An object that provides access to the thumbnail image.
 */
getThumbnailAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStreamWithContentType>;

/**
 * A read-only list of instant messaging accounts stored with the contact.
 */
instantMessages: Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Contacts$ContactInstantMessageField>;

/**
 * A read-only list of locations stored with the contact.
 */
locations: Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Contacts$ContactLocationField>;

/**
 * The name of the contact.
 */
name: string;

/**
 * A read-only list of phone numbers stored with the contact.
 */
phoneNumbers: Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Contacts$ContactField>;

/**
 * Enables you to get the value for a custom field that is stored with a contact.
 * @param customName The name of the field.
 * @return The value of the field.
 */
queryCustomFields(
customName: string): Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Contacts$ContactField>
}


/**
 * Defines a field that is an instant messaging (IM) address.
 */
declare class Windows$ApplicationModel$Contacts$ContactInstantMessageField  {

/**
 * Creates a new ContactInstantMessageField object.
 * @param userName The user's name.
 */
constructor(userName: string): this;

/**
 * Creates a new ContactInstantMessageField object.
 * @param userName The user's name.
 * @param category The category of contact data.
 */
constructor(userName: string, category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>): this;

/**
 * Creates a new ContactInstantMessageField object.
 * @param userName The user's name.
 * @param category The category of the contact data.
 * @param service The name of the instant messaging service.
 * @param displayText The display text used with the instant messaging URI.
 * @param verb The URI that starts an instant message.
 */
constructor(userName: string, category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>, service: string, displayText: string, verb: Windows$Foundation$Uri): this;

/**
 * Gets the category for the contact data.
 */
category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>;

/**
 * Gets the display text for the Uniform Resource Identifier (URI) that starts an instant message.
 */
displayText: string;

/**
 * Gets the Uniform Resource Identifier (URI) that can start an instant message.
 */
launchUri: Windows$Foundation$Uri;

/**
 * Gets the name of the field.
 */
name: string;

/**
 * Gets the name of the service used for sending instant messages.
 */
service: string;

/**
 * Gets the contact field type for the data.
 */
type: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldType>;

/**
 * Gets the user's name.
 */
userName: string;

/**
 * Gets the value of the contact data.
 */
value: string
}


/**
 * Represents job info for a contact.
 */
declare class Windows$ApplicationModel$Contacts$ContactJobInfo  {

/**
 * Initializes a new instance of a ContactJobInfo class.
 */
constructor(): this;

/**
 * Gets and sets the company address of the job info for a contact. The maximum string length for the company address is 1024 characters.
 */
companyAddress: string;

/**
 * Gets and sets the company name of the job info for a contact. The maximum string length for the company name is 64 characters.
 */
companyName: string;

/**
 * Gets and sets the company Yomi (phonetic Japanese equivalent) name of the job info for a contact. The maximum string length for the company Yomi name is 200 characters.
 */
companyYomiName: string;

/**
 * Gets and sets the department of the job info for a contact. The maximum string length for the department is 100 characters.
 */
department: string;

/**
 * Gets and sets the description of the job info for a contact. The maximum string length for the description is 512 characters.
 */
description: string;

/**
 * Gets and sets the manager of the job info for a contact. The maximum string length for the manager is 1024 characters.
 */
manager: string;

/**
 * Gets and sets the office of the job info for a contact. The maximum string length for the office is 40 characters.
 */
office: string;

/**
 * Gets and sets the title of the job info for a contact. The maximum string length for the title is 1024 characters.
 */
title: string
}


/**
 * Provides data when an app is launched to perform an action to a contact.
 */
declare class Windows$ApplicationModel$Contacts$ContactLaunchActionVerbs  {

/**
 * Gets the call contact action.
 */
static call: string;

/**
 * Gets the map contact action.
 */
static map: string;

/**
 * Gets the send message to a contact action.
 */
static message: string;

/**
 * Gets the post to a contact action.
 */
static post: string;

/**
 * Gets the video call contact action.
 */
static videoCall: string
}


/**
 * Represents a list of Contact objects.
 */
declare class Windows$ApplicationModel$Contacts$ContactList  {

/**
 * Gets the app's ContactChangeTracker for this ContactList .
 */
changeTracker: Windows$ApplicationModel$Contacts$ContactChangeTracker;

/**
 * Asynchronously deletes this ContactList , including all Contact objects in the ContactStore .
 * @return An async action indicating that the method is complete.
 */
deleteAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously deletes and individual Contact from this ContactList and the ContactStore .
 * @param contact The Contact to delete.
 * @return An async action indicating that the method is complete.
 */
deleteContactAsync(
contact: Windows$ApplicationModel$Contacts$Contact): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets or puts the name of the ContactList , suitable for display in the user interface.
 */
displayName: string;

/**
 * Asynchronously retrieves the specified Contact object from the ContactList .
 * @param contactId The string that identifies the Contact to return.
 * @return The Contact identified by the contactId parameter.
 */
getContactAsync(
contactId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$Contact>;

/**
 * Asynchronously gets the Contact identified by the specified RemoteId .
 * @param remoteId An ID that can be used by a service provider to access the Contact in their remote system.
 * @return The Contact identified by the remoteId parameter.
 */
getContactFromRemoteIdAsync(
remoteId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$Contact>;

/**
 * Gets a ContactReader object associated with this ContactList and using the specified ContactQueryOptions .
 * @param options The ContactQueryOptions to use when creating the ContactReader .
 * @return A ContactReader object associated with this ContactList .
 */
getContactReader(
options: Windows$ApplicationModel$Contacts$ContactQueryOptions): Windows$ApplicationModel$Contacts$ContactReader;

/**
 * Gets a ContactReader object associated with this ContactList .
 * @return A ContactReader object associated with this ContactList .
 */
getContactReader(): Windows$ApplicationModel$Contacts$ContactReader;

/**
 * Asynchronously gets the Contact object for the current user.
 * @return The Contact object for the current user.
 */
getMeContactAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$Contact>;

/**
 * Gets the locally unique identifier for this ContactList .
 */
id: string;

/**
 * Gets or puts a Boolean value indicating of the ContactList is hidden in the user interface.
 */
isHidden: boolean;

/**
 * Occurs when a Contact in this ContactList has been changed.
 */
oncontactchanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Contacts$ContactList, Windows$ApplicationModel$Contacts$ContactChangedEventArgs>;
addEventListener(
type: "contactchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Contacts$ContactList, Windows$ApplicationModel$Contacts$ContactChangedEventArgs>): void;
removeEventListener(
type: "contactchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Contacts$ContactList, Windows$ApplicationModel$Contacts$ContactChangedEventArgs>): void;

/**
 * Gets or puts a value indicating the read access level to this ContactList for other apps on the system.
 */
otherAppReadAccess: $Values<typeof Windows$ApplicationModel$Contacts$ContactListOtherAppReadAccess>;

/**
 * Gets or puts a value indicating the write access level to this ContactList for other apps on the system.
 */
otherAppWriteAccess: $Values<typeof Windows$ApplicationModel$Contacts$ContactListOtherAppWriteAccess>;

/**
 * Asynchronously saves this ContactList .
 * @return An async action indicating that the method has completed.
 */
saveAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously saves the specified Contact to the ContactStore .
 * @param contact The contact to save.
 * @return An async action indicating that the method has completed.
 */
saveContactAsync(
contact: Windows$ApplicationModel$Contacts$Contact): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the name of the source of the ContactList , suitable for display in the user interface.
 */
sourceDisplayName: string;

/**
 * Gets a Boolean value indicating if you can search the remote server with this ContactList .
 */
supportsServerSearch: boolean;

/**
 * Gets the ContactListSyncManager used to communicate with the server.
 */
syncManager: Windows$ApplicationModel$Contacts$ContactListSyncManager;

/**
 * Gets a string that represents the ID of the user data account for this ContactList .
 */
userDataAccountId: string;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies the level of contact read access granted to other apps.
 */

declare  var Windows$ApplicationModel$Contacts$ContactListOtherAppReadAccess: {|
  +systemOnly: 0,// 0
+limited: 1,// 1
+full: 2,// 2

|};



/**
 * Specifies the level of contact write access granted to other apps.
 */

declare  var Windows$ApplicationModel$Contacts$ContactListOtherAppWriteAccess: {|
  +none: 0,// 0
+systemOnly: 1,// 1

|};



/**
 * Provides functionality for syncing contact information with the server.
 */
declare class Windows$ApplicationModel$Contacts$ContactListSyncManager  {

/**
 * Gets the last time a sync was attempted with the server.
 */
lastAttemptedSyncTime: Date;

/**
 * Gets the last time the ContactList was successfully synced with the server.
 */
lastSuccessfulSyncTime: Date;

/**
 * Occurs when the sync status with the server has changed.
 */
onsyncstatuschanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Contacts$ContactListSyncManager, any>;
addEventListener(
type: "syncstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Contacts$ContactListSyncManager, any>): void;
removeEventListener(
type: "syncstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Contacts$ContactListSyncManager, any>): void;

/**
 * Gets the ContactListSyncStatus .
 */
status: $Values<typeof Windows$ApplicationModel$Contacts$ContactListSyncStatus>;

/**
 * Asynchronously attempts to sync with the contacts server.
 * @return A Boolean value indicating if the sync was successful.
 */
syncAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Defines the ContactList sync status.
 */

declare  var Windows$ApplicationModel$Contacts$ContactListSyncStatus: {|
  +idle: 0,// 0
+syncing: 1,// 1
+upToDate: 2,// 2
+authenticationError: 3,// 3
+policyError: 4,// 4
+unknownError: 5,// 5
+manualAccountRemovalRequired: 6,// 6

|};



/**
 * Contains information about a user's location and address.
 */
declare class Windows$ApplicationModel$Contacts$ContactLocationField  {

/**
 * Creates a new ContactLocationField object.
 * @param unstructuredAddress The address of the contact in an unstructured format.
 * @param category The category the field belongs to.
 */
constructor(unstructuredAddress: string, category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>): this;

/**
 * Creates a new ContactLocationField object.
 * @param unstructuredAddress The address of the contact in an unstructured format.
 */
constructor(unstructuredAddress: string): this;

/**
 * Creates a new ContactLocationField object.
 * @param unstructuredAddress The address of the contact in an unstructured format.
 * @param category The category for the contact data.
 * @param street The street address of the contact.
 * @param city The name of the city for this contact's address.
 * @param region The name of the region for this contact's address.
 * @param country The name of the country for this contact's address.
 * @param postalCode The postal code for this contact's address.
 */
constructor(unstructuredAddress: string, category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>, street: string, city: string, region: string, country: string, postalCode: string): this;

/**
 * Gets the category for the contact data.
 */
category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>;

/**
 * Gets the contact's city.
 */
city: string;

/**
 * Gets the contact's country.
 */
country: string;

/**
 * Gets the name of the field.
 */
name: string;

/**
 * Gets the contact's postal code.
 */
postalCode: string;

/**
 * Gets the contact's region.
 */
region: string;

/**
 * Gets the contact's street.
 */
street: string;

/**
 * Gets the contact field type for the data.
 */
type: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldType>;

/**
 * Gets a string that represents an unstructured address.
 */
unstructuredAddress: string;

/**
 * Gets the value of the contact data.
 */
value: string
}


/**
 * Represents a service that source apps can call to access contact data.
 */
declare class Windows$ApplicationModel$Contacts$ContactManager  {

/**
 * Asynchronously converts a Contact to a vCard.
 * @param contact The Contact to convert.
 * @return A stream containing the vCard data.
 */
static convertContactToVCardAsync(
contact: Windows$ApplicationModel$Contacts$Contact): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$RandomAccessStreamReference>;

/**
 * Asynchronously converts a Contact to a vCard.
 * @param contact The Contact to convert.
 * @param maxBytes The maximum size for the vCard in bytes.
 * @return A stream containing the vCard data.
 */
static convertContactToVCardAsync(
contact: Windows$ApplicationModel$Contacts$Contact,
maxBytes: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$RandomAccessStreamReference>;

/**
 * Asynchronously converts a vCard to a Contact .
 * @param vCard A stream containing the vCard data.
 * @return The converted Contact .
 */
static convertVCardToContactAsync(
vCard: Windows$Storage$Streams$IRandomAccessStreamReference): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$Contact>;

/**
 * Gets a Boolean value indicating if the ShowContactCard method is supported on the current platform.
 * @return A Boolean value indicating if the ShowContactCard method is supported on the current platform.
 */
static isShowContactCardSupported(): boolean;

/**
 * Gets a Boolean value indicating if the ShowDelayLoadedContactCard method is supported on the current platform.
 * @return A Boolean value indicating if the ShowDelayLoadedContactCard method is supported on the current platform.
 */
static isShowDelayLoadedContactCardSupported(): boolean;

/**
 * Asynchronously requests access to the ContactAnnotationStore .
 * @param accessType Specifies the type of access request, app contact annotations or all annotations.
 * @return The requested ContactAnnotationStore .
 */
static requestAnnotationStoreAsync(
accessType: $Values<typeof Windows$ApplicationModel$Contacts$ContactAnnotationStoreAccessType>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$ContactAnnotationStore>;

/**
 * Retrieves a ContactStore object that enables searching or retrieving contacts on the device.
 * @return An asynchronous operation that returns a ContactStore object on successful completion.
 */
static requestStoreAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$ContactStore>;

/**
 * Retrieves a ContactStore object that enables searching or retrieving contacts on the device.
 * @param accessType Specifies the type of read/write access requested.
 * @return An asynchronous operation that returns a ContactStore object on successful completion.
 */
static requestStoreAsync(
accessType: $Values<typeof Windows$ApplicationModel$Contacts$ContactStoreAccessType>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$ContactStore>;

/**
 * Queries the operating system for a users contact and shows the contact data in a contact card.
 * @param contact The object that represents the contact that the app wants to display the contact card for.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the contact card, not within that rectangular area. For example, if an app uses a button to show the contact card, pass the Rect of the button so the contact card displays around the button, not overlapping it.
 */
static showContactCard(
contact: Windows$ApplicationModel$Contacts$Contact,
selection: Windows$Foundation$Rect): void;

/**
 * Queries the operating system for a users contact and shows the contact data in a contact card.
 * @param contact The object that represents the contact that the app wants to display the contact card for.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the contact card, not within that rectangular area. For example, if an app uses a button to show the contact card, pass the Rect of the button so the contact card displays around the button, not overlapping it.
 * @param preferredPlacement The Placement that describes the preferred placement of the contact card.
 */
static showContactCard(
contact: Windows$ApplicationModel$Contacts$Contact,
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>): void;

/**
 * Shows a contact card with the specified parameters.
 * @param contact The object that represents the contact that the app wants to display the contact card for.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the contact card, not within that rectangular area. For example, if an app uses a button to show the contact card, pass the Rect of the button so the contact card displays around the button, not overlapping it.
 * @param preferredPlacement The Placement that describes the preferred placement of the contact card.
 * @param contactCardOptions Specifies how to display the contact card, such as which tab to start on when displaying a mini contact card.
 */
static showContactCard(
contact: Windows$ApplicationModel$Contacts$Contact,
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>,
contactCardOptions: Windows$ApplicationModel$Contacts$ContactCardOptions): void;

/**
 * Shows a contact card that can be updated later if the contact does not exist in the users contact database.
 * @param contact The object that represents the contact that the app wants to display the contact card for.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the contact card, not within that rectangular area. For example, if an app uses a button to show the contact card, pass the Rect of the button so the contact card displays around the button, not overlapping it.
 * @param preferredPlacement The Placement that describes the preferred placement of the contact card.
 * @return Returns the ContactCardDelayedDataLoader object that can be used to update the contact card.
 */
static showDelayLoadedContactCard(
contact: Windows$ApplicationModel$Contacts$Contact,
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>): Windows$ApplicationModel$Contacts$ContactCardDelayedDataLoader;

/**
 * Shows a contact card that can be updated later if the contact does not exist in the users contact database.
 * @param contact The object that represents the contact that the app wants to display the contact card for.
 * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the contact card, not within that rectangular area. For example, if an app uses a button to show the contact card, pass the Rect of the button so the contact card displays around the button, not overlapping it.
 * @param preferredPlacement The Placement that describes the preferred placement of the contact card.
 * @param contactCardOptions Specifies how to display the contact card, such as which tab to start on if you are displaying a mini contact card, or what header type to use if you are showing a full contact card.
 * @return Returns the ContactCardDelayedDataLoader object that can be used to update the contact card.
 */
static showDelayLoadedContactCard(
contact: Windows$ApplicationModel$Contacts$Contact,
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>,
contactCardOptions: Windows$ApplicationModel$Contacts$ContactCardOptions): Windows$ApplicationModel$Contacts$ContactCardDelayedDataLoader;

/**
 * Queries the operating system for a users contact and shows the contact data in a full contact card.
 * @param contact The object that represents the contact that the app wants to display the contact card for.
 * @param fullContactCardOptions Specifies how to display the full contact card.
 */
static showFullContactCard(
contact: Windows$ApplicationModel$Contacts$Contact,
fullContactCardOptions: Windows$ApplicationModel$Contacts$FullContactCardOptions): void;

/**
 * Gets or puts the display name order.
 */
static systemDisplayNameOrder: $Values<typeof Windows$ApplicationModel$Contacts$ContactNameOrder>;

/**
 * Gets or puts the sort order.
 */
static systemSortOrder: $Values<typeof Windows$ApplicationModel$Contacts$ContactNameOrder>
}


/**
 * Provides details about why search results matched the query parameters.
 */
declare class Windows$ApplicationModel$Contacts$ContactMatchReason  {

/**
 * Gets the contact field type that matched the search, such as name, phone number, email address and so on.
 */
field: $Values<typeof Windows$ApplicationModel$Contacts$ContactMatchReasonKind>;

/**
 * Gets a list of matching TextSegment objects which tells you what to highlight in your view as the result of a contact search.
 */
segments: Windows$Foundation$Collections$IVectorView<Windows$Data$Text$TextSegment>;

/**
 * Gets the matching text result from a contact search.
 */
text: string
}


/**
 * Defines the reasons that a Contact matched a search.
 */

declare  var Windows$ApplicationModel$Contacts$ContactMatchReasonKind: {|
  +name: 0,// 0
+emailAddress: 1,// 1
+phoneNumber: 2,// 2
+jobInfo: 3,// 3
+yomiName: 4,// 4
+other: 5,// 5

|};



/**
 * Specifies the name order for a contact.
 */

declare  var Windows$ApplicationModel$Contacts$ContactNameOrder: {|
  +firstNameLastName: 0,// 0
+lastNameFirstName: 1,// 1

|};



/**
 * Represents info about the phone for a contact.
 */
declare class Windows$ApplicationModel$Contacts$ContactPhone  {

/**
 * Initializes a new instance of a ContactPhone class.
 */
constructor(): this;

/**
 * Gets and sets the description of the phone for a contact. The maximum string length for the description is 512 characters.
 */
description: string;

/**
 * Gets and sets the kind of phone for a contact.
 */
kind: $Values<typeof Windows$ApplicationModel$Contacts$ContactPhoneKind>;

/**
 * Gets and sets the phone number of a phone for a contact. The maximum string length for the phone number is 50 characters.
 */
number: string
}


/**
 * Specifies the kinds of phones for a contact.
 */

declare  var Windows$ApplicationModel$Contacts$ContactPhoneKind: {|
  +home: 0,// 0
+mobile: 1,// 1
+work: 2,// 2
+other: 3,// 3
+pager: 4,// 4
+businessFax: 5,// 5
+homeFax: 6,// 6
+company: 7,// 7
+assistant: 8,// 8
+radio: 9,// 9

|};



/**
 * Controls how the Contact Picker user interface opens and what information it shows.
 */
declare class Windows$ApplicationModel$Contacts$ContactPicker  {

/**
 * Creates a new instance of the ContactPicker class.
 */
constructor(): this;

/**
 * Sets the text for the confirmation button in the Contact Picker user interface.
 */
commitButtonText: string;

/**
 * Sets the contact fields your app is interested in.
 */
desiredFields: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets the ways to connect with a contact.
 */
desiredFieldsWithContactFieldType: Windows$Foundation$Collections$IVector<$Values<typeof Windows$ApplicationModel$Contacts$ContactFieldType>>;

/**
 * Launches the Contact Picker to select a single contact.
 * @return The operation that launches the Contact Picker.
 */
pickContactAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$Contact>;

/**
 * Launches the Contact Picker for selecting multiple contacts.
 * @return The operation that launches the contact picker.
 */
pickContactsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVector<any>>;

/**
 * Launches the Contact Picker for selecting multiple contacts.
 * @return The operation that launches the contact picker.
 */
pickMultipleContactsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Launches the Contact Picker for selecting a single contact.
 * @return The operation that launches the Contact Picker.
 */
pickSingleContactAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$ContactInformation>;

/**
 * Controls whether the Contact Picker shows contacts as a complete entity or as a collection of fields.
 */
selectionMode: $Values<typeof Windows$ApplicationModel$Contacts$ContactSelectionMode>
}


/**
 * Defines which fields must exist on a contact in order to match a search operation.
 */

declare  var Windows$ApplicationModel$Contacts$ContactQueryDesiredFields: {|
  +none: 0,// 0
+phoneNumber: 1,// 1
+emailAddress: 2,// 2
+postalAddress: 3,// 3

|};



/**
 * Used to specify the query options when searching for contacts.
 */
declare class Windows$ApplicationModel$Contacts$ContactQueryOptions  {

/**
 * Initializes a new instance of the ContactQueryOptions class.
 */
constructor(): this;

/**
 * Initializes a new instance of the ContactQueryOptions class.
 * @param text The text to match in the search operation.
 * @param fields Specifies which contact fields to search for a match.
 */
constructor(text: string, fields: $Values<typeof Windows$ApplicationModel$Contacts$ContactQuerySearchFields>): this;

/**
 * Initializes a new instance of the ContactQueryOptions class.
 * @param text The text to match in the search operation.
 */
constructor(text: string): this;

/**
 * Gets a list to which you can add ContactAnnotationList.Id values for which to search.
 */
annotationListIds: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets a list to which you can add ContactList.Id values for which to search.
 */
contactListIds: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets or sets the desired fields a contact must have to match the query.
 */
desiredFields: $Values<typeof Windows$ApplicationModel$Contacts$ContactQueryDesiredFields>;

/**
 * Gets or sets the desired annotation operations a contact must have to match the query.
 */
desiredOperations: $Values<typeof Windows$ApplicationModel$Contacts$ContactAnnotationOperations>;

/**
 * Gets or sets a Boolean value indicating if the query results should include contacts from lists that are not shown in the user interface.
 */
includeContactsFromHiddenLists: boolean;

/**
 * Gets a ContactQueryTextSearch object that can be used for text searches.
 */
textSearch: Windows$ApplicationModel$Contacts$ContactQueryTextSearch
}


/**
 * Defines which contact fields to search for a text match.
 */

declare  var Windows$ApplicationModel$Contacts$ContactQuerySearchFields: {|
  +none: 0,// 0
+name: 1,// 1
+email: 2,// 2
+phone: 3,// 3
+all: 4,// 4

|};



/**
 * Defines whether to search the local ContactStore or a server.
 */

declare  var Windows$ApplicationModel$Contacts$ContactQuerySearchScope: {|
  +local: 0,// 0
+server: 1,// 1

|};



/**
 * Specifies parameters to use in a text search of Contact objects.
 */
declare class Windows$ApplicationModel$Contacts$ContactQueryTextSearch  {

/**
 * Gets or sets which contact fields to search for a text match.
 */
fields: $Values<typeof Windows$ApplicationModel$Contacts$ContactQuerySearchFields>;

/**
 * Gets or sets a value that specifies either a local or server search.
 */
searchScope: $Values<typeof Windows$ApplicationModel$Contacts$ContactQuerySearchScope>;

/**
 * Gets or sets the text for which to search.
 */
text: string
}


/**
 * Used to read Contact objects in batches from the ContactStore which may be local or remotely located.
 */
declare class Windows$ApplicationModel$Contacts$ContactReader  {

/**
 * Gets the reason a Contact matched the search query. Returns the properties and substrings that match.
 * @param contact The Contact for which to get the matching properties.
 * @return The list of matching properties and match reasons.
 */
getMatchingPropertiesWithMatchReason(
contact: Windows$ApplicationModel$Contacts$Contact): Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Contacts$ContactMatchReason>;

/**
 * Asynchronously reads a batch of Contact objects from the ContactStore .
 * @return The batch of contacts read from the ContactStore .
 */
readBatchAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$ContactBatch>
}


/**
 * Defines a value that indicates the nature of a contact relationship, such as spouse, partner, sibling, parent and so on.
 */

declare  var Windows$ApplicationModel$Contacts$ContactRelationship: {|
  +other: 0,// 0
+spouse: 1,// 1
+partner: 2,// 2
+sibling: 3,// 3
+parent: 4,// 4
+child: 5,// 5

|};



/**
 * Specifies whether you want to request an entire contact, or only specific fields.
 */

declare  var Windows$ApplicationModel$Contacts$ContactSelectionMode: {|
  +contacts: 0,// 0
+fields: 1,// 1

|};



/**
 * Represents the info about a significant other for a contact.
 */
declare class Windows$ApplicationModel$Contacts$ContactSignificantOther  {

/**
 * Initializes a new instance of a ContactSignificantOther class.
 */
constructor(): this;

/**
 * Gets and sets the description of a significant other for a contact. The maximum string length for the description is 512 characters.
 */
description: string;

/**
 * Gets and sets the name of a significant other for a contact. The maximum string length for the name is 256 characters.
 */
name: string;

/**
 * Gets or puts a value that indicates the nature of the relationship, such as spouse, partner, sibling, parent and so on.
 */
relationship: $Values<typeof Windows$ApplicationModel$Contacts$ContactRelationship>
}


/**
 * Represents a database that contains contacts.
 */
declare class Windows$ApplicationModel$Contacts$ContactStore  {

/**
 * Gets a contact manager that provides functionality for linking individual (raw) contacts across services together into a single aggregate contact.
 */
aggregateContactManager: Windows$ApplicationModel$Contacts$AggregateContactManager;

/**
 * Gets the ContactChangeTracker which provides functionality for monitoring changes to Contact objects in the ContactStore .
 */
changeTracker: Windows$ApplicationModel$Contacts$ContactChangeTracker;

/**
 * Asynchronously creates a ContactList with the specified display name and user account.
 * @param displayName A name for the new ContactList , suitable for displaying in the user interface.
 * @param userDataAccountId The ID for the UserDataAccount to use when creating the ContactList .
 * @return The newly created ContactList .
 */
createContactListAsync(
displayName: string,
userDataAccountId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$ContactList>;

/**
 * Asynchronously creates a ContactList with the specified display name.
 * @param displayName A name for the new ContactList , suitable for displaying in the user interface.
 * @return The newly created ContactList .
 */
createContactListAsync(
displayName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$ContactList>;

/**
 * Asynchronously returns the list of ContactList objects.
 * @return The list of ContactList objects.
 */
findContactListsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a list of Contact objects based on the supplied search text.
 * @param searchText The search string for the operation. The query will attempt to match the name ( Name ), email address ( Emails values), or phone number ( Phones values) of a contact.
 * @return An asynchronous operation that returns a search-filtered list of contacts on successful completion. If you use Asynchronous programming, the result type is a read-only list/vector of Contact items. (You can use APIs of IVectorView<Contact> for C++ or JavaScript, APIs of IReadOnlyList<Contact> for .NET.)
 */
findContactsAsync(
searchText: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Contacts$Contact>>;

/**
 * Retrieves the list of all contacts in the contact store.
 * @return An asynchronous operation that returns a list of all Contact objects in the contact store. If you use Asynchronous programming, the result type is a read-only list/vector of Contact items. (You can use APIs of IVectorView<Contact> for C++ or JavaScript, APIs of IReadOnlyList<Contact> for .NET.)
 */
findContactsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Contacts$Contact>>;

/**
 * Retrieves a Contact object representing the contact with the specified Id value.
 * @param contactId The Id of the contact to be retrieved.
 * @return An asynchronous operation that returns a Contact object on successful completion. If you use Asynchronous programming, the result type is a single Contact object.
 */
getContactAsync(
contactId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$Contact>;

/**
 * Asynchronously gets the ContactList with the specified ID.
 * @param contactListId The ID of the ContactList to retrieve.
 * @return The ContactList with the specified ID or null if the list is not found.
 */
getContactListAsync(
contactListId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$ContactList>;

/**
 * Creates and returns a ContactReader for the ContactStore with the specified ContactQueryOptions .
 * @param options The query options to use when creating the new ContactReader .
 * @return The newly created ContactReader for the ContactStore .
 */
getContactReader(
options: Windows$ApplicationModel$Contacts$ContactQueryOptions): Windows$ApplicationModel$Contacts$ContactReader;

/**
 * Creates and returns a ContactReader for the ContactStore .
 * @return The newly created ContactReader for the ContactStore .
 */
getContactReader(): Windows$ApplicationModel$Contacts$ContactReader;

/**
 * Get the Contact object for the current user.
 * @return The Contact object for the current user.
 */
getMeContactAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Contacts$Contact>;

/**
 * Occurs when a Contact in the ContactStore has been changed.
 */
oncontactchanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Contacts$ContactStore, Windows$ApplicationModel$Contacts$ContactChangedEventArgs>;
addEventListener(
type: "contactchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Contacts$ContactStore, Windows$ApplicationModel$Contacts$ContactChangedEventArgs>): void;
removeEventListener(
type: "contactchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Contacts$ContactStore, Windows$ApplicationModel$Contacts$ContactChangedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Defines the type of access the app has to the ContactStore .
 */

declare  var Windows$ApplicationModel$Contacts$ContactStoreAccessType: {|
  +appContactsReadWrite: 0,// 0
+allContactsReadOnly: 1,// 1
+allContactsReadWrite: 2,// 2

|};



/**
 * Reserved for future use.
 */
declare class Windows$ApplicationModel$Contacts$ContactStoreNotificationTriggerDetails  {}


/**
 * Represents the info about a Web site for a contact.
 */
declare class Windows$ApplicationModel$Contacts$ContactWebsite  {

/**
 * Initializes a new instance of a ContactWebsite class.
 */
constructor(): this;

/**
 * Gets and sets the description of a Web site for a contact. The maximum string length for the description is 512 characters.
 */
description: string;
rawValue: any;

/**
 * Gets and sets the Uniform Resource Identifier (URI) of a Web site for a contact.
 */
uri: Windows$Foundation$Uri
}


/**
 * Specifies the options for displaying the full contact card.
 */
declare class Windows$ApplicationModel$Contacts$FullContactCardOptions  {

/**
 * Initializes a new instance of the FullContactCardOptions class.
 */
constructor(): this;

/**
 * Gets or sets a value that describes the desired view size for the full contact card.
 */
desiredRemainingView: $Values<typeof Windows$UI$ViewManagement$ViewSizePreference>
}


/**
 * A static class that contains the names of contact fields for storing commonly requested information like email address and phone numbers.
 */
declare class Windows$ApplicationModel$Contacts$KnownContactField  {

/**
 * Converts a string representing the name of a field to its corresponding type.
 * @param name The name of the field.
 * @return The type of field.
 */
static convertNameToType(
name: string): $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldType>;

/**
 * Converts the type of a field to its corresponding string name.
 * @param type The type of field.
 * @return The name of the field.
 */
static convertTypeToName(
type: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldType>): string;

/**
 * Contains the name of the field used for email addresses.
 */
static email: string;

/**
 * Contains the name of the field used for instant messaging accounts.
 */
static instantMessage: string;

/**
 * Contains the name of the field used for the contact's location.
 */
static location: string;

/**
 * Contains the name of the field used for phone numbers.
 */
static phoneNumber: string
}


      declare var npm$namespace$Windows$ApplicationModel$Contacts$Provider: {
        
        
        AddContactResult: typeof Windows$ApplicationModel$Contacts$Provider$AddContactResult,
        ContactPickerUI: typeof Windows$ApplicationModel$Contacts$Provider$ContactPickerUI,
ContactRemovedEventArgs: typeof Windows$ApplicationModel$Contacts$Provider$ContactRemovedEventArgs,
        
      }

/**
 * Indicates whether a contact was added successfully.
 */

declare  var Windows$ApplicationModel$Contacts$Provider$AddContactResult: {|
  +added: 0,// 0
+alreadyAdded: 1,// 1
+unavailable: 2,// 2

|};



/**
 * Allows you to call the contact picker UI so you can select one or more contacts.
 */
declare class Windows$ApplicationModel$Contacts$Provider$ContactPickerUI  {

/**
 * Adds a Contact .
 * @param id The ID for the contact.
 * @param contact An object that contains the contact's information.
 * @return An AddContactResult -typed value that indicates whether the contact was added successfully.
 */
addContact(
id: string,
contact: Windows$ApplicationModel$Contacts$Contact): $Values<typeof Windows$ApplicationModel$Contacts$Provider$AddContactResult>;

/**
 * Adds a Contact .
 * @param contact An object that contains the contact's information.
 * @return An AddContactResult -typed value that indicates whether the contact was added successfully.
 */
addContact(
contact: Windows$ApplicationModel$Contacts$Contact): $Values<typeof Windows$ApplicationModel$Contacts$Provider$AddContactResult>;

/**
 * Checks to see whether the contact was already selected by the user.
 * @param id The ID of the contact.
 * @return True if the contact has already been selected; otherwise, false.
 */
containsContact(id: string): boolean;

/**
 * Specifies the fields that you want returned after the user selects one or more contacts.
 */
desiredFields: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the fields with contact field type that you want returned after the user selects one or more contacts.
 */
desiredFieldsWithContactFieldType: Windows$Foundation$Collections$IVector<$Values<typeof Windows$ApplicationModel$Contacts$ContactFieldType>>;

/**
 * Occurs when the user deselects or removes the contact.
 */
oncontactremoved: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Contacts$Provider$ContactPickerUI, Windows$ApplicationModel$Contacts$Provider$ContactRemovedEventArgs>;
addEventListener(
type: "contactremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Contacts$Provider$ContactPickerUI, Windows$ApplicationModel$Contacts$Provider$ContactRemovedEventArgs>): void;
removeEventListener(
type: "contactremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Contacts$Provider$ContactPickerUI, Windows$ApplicationModel$Contacts$Provider$ContactRemovedEventArgs>): void;

/**
 * Removes a contact.
 * @param id The ID of the contact to remove.
 */
removeContact(id: string): void;

/**
 * Determines the selection mode for the contact picker. The most common options are PickSingleContactAsync or PickMultipleContactsAsync .
 */
selectionMode: $Values<typeof Windows$ApplicationModel$Contacts$ContactSelectionMode>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Contains info about a removed contact. Returned when a ContactRemoved event occurs.
 */
declare class Windows$ApplicationModel$Contacts$Provider$ContactRemovedEventArgs  {

/**
 * Contains a unique identifier for the contact.
 */
id: string
}


/**
 * Specifies an object that describes a piece of contact data.
 */
declare interface Windows$ApplicationModel$Contacts$IContactField {

/**
 * Gets the category for the contact data.
 */
category: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldCategory>,

/**
 * Gets the name of the field.
 */
name: string,

/**
 * Gets the contact field type for the data.
 */
type: $Values<typeof Windows$ApplicationModel$Contacts$ContactFieldType>,

/**
 * Gets the value of the contact data.
 */
value: string
} 


      declare var npm$namespace$Windows$ApplicationModel$Core: {
        
        
        
        AppListEntry: typeof Windows$ApplicationModel$Core$AppListEntry,
        
      }

/**
 * Provides an app's display info such as its display name and description, and a method to launch the app.
 */
declare class Windows$ApplicationModel$Core$AppListEntry  {

/**
 * Provides an app's display name, description, and logo.
 */
displayInfo: Windows$ApplicationModel$AppDisplayInfo;

/**
 * Launches the app associated with this AppListEntry
 * @return If the launch fails for any reason, the Boolean value is false
 */
launchAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>
}


      declare var npm$namespace$Windows$ApplicationModel$DataTransfer: {
        
        
        DataPackageOperation: typeof Windows$ApplicationModel$DataTransfer$DataPackageOperation,
        Clipboard: typeof Windows$ApplicationModel$DataTransfer$Clipboard,
DataPackage: typeof Windows$ApplicationModel$DataTransfer$DataPackage,
DataPackagePropertySet: typeof Windows$ApplicationModel$DataTransfer$DataPackagePropertySet,
DataPackagePropertySetView: typeof Windows$ApplicationModel$DataTransfer$DataPackagePropertySetView,
DataPackageView: typeof Windows$ApplicationModel$DataTransfer$DataPackageView,
DataProviderDeferral: typeof Windows$ApplicationModel$DataTransfer$DataProviderDeferral,
DataProviderRequest: typeof Windows$ApplicationModel$DataTransfer$DataProviderRequest,
DataRequest: typeof Windows$ApplicationModel$DataTransfer$DataRequest,
DataRequestDeferral: typeof Windows$ApplicationModel$DataTransfer$DataRequestDeferral,
DataRequestedEventArgs: typeof Windows$ApplicationModel$DataTransfer$DataRequestedEventArgs,
DataTransferManager: typeof Windows$ApplicationModel$DataTransfer$DataTransferManager,
HtmlFormatHelper: typeof Windows$ApplicationModel$DataTransfer$HtmlFormatHelper,
OperationCompletedEventArgs: typeof Windows$ApplicationModel$DataTransfer$OperationCompletedEventArgs,
SharedStorageAccessManager: typeof Windows$ApplicationModel$DataTransfer$SharedStorageAccessManager,
StandardDataFormats: typeof Windows$ApplicationModel$DataTransfer$StandardDataFormats,
TargetApplicationChosenEventArgs: typeof Windows$ApplicationModel$DataTransfer$TargetApplicationChosenEventArgs,
        DragDrop: typeof npm$namespace$Windows$ApplicationModel$DataTransfer$DragDrop,
ShareTarget: typeof npm$namespace$Windows$ApplicationModel$DataTransfer$ShareTarget,
      }

/**
 * Gets and sets information from the clipboard object.
 */
declare class Windows$ApplicationModel$DataTransfer$Clipboard  {

/**
 * Removes all data from the Clipboard.
 */
static clear(): void;

/**
 * Adds the content to the Clipboard and releases the DataPackage object from the source app. This method allows the content to remain available after the application shuts down.
 */
static flush(): void;

/**
 * Gets the current content that is stored in the clipboard object.
 * @return Contains the content of the Clipboard.
 */
static getContent(): Windows$ApplicationModel$DataTransfer$DataPackageView;

/**
 * Occurs when the data stored in the Clipboard changes.
 */
static oncontentchanged: Windows$Foundation$EventHandler<any>;
static addEventListener(type: "contentchanged", listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: "contentchanged", listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Sets the current content that is stored in the clipboard object.
 * @param content Contains the content of the clipboard. If NULL, the clipboard is emptied.
 */
static setContent(content: Windows$ApplicationModel$DataTransfer$DataPackage): void;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Contains the data that a user wants to exchange with another app.
 */
declare class Windows$ApplicationModel$DataTransfer$DataPackage  {

/**
 * Constructor that creates a new DataPackage .
 */
constructor(): this;

/**
 * Returns a DataPackageView object. This object is a read-only copy of the DataPackage object.
 * @return The object that is a read-only copy of the DataPackage object.
 */
getView(): Windows$ApplicationModel$DataTransfer$DataPackageView;

/**
 * Occurs when the DataPackage is destroyed.
 */
ondestroyed: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$DataTransfer$DataPackage, any>;
addEventListener(
type: "destroyed",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$DataTransfer$DataPackage, any>): void;
removeEventListener(
type: "destroyed",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$DataTransfer$DataPackage, any>): void;

/**
 * Occurs when a paste operation is completed.
 */
onoperationcompleted: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$DataTransfer$DataPackage, Windows$ApplicationModel$DataTransfer$OperationCompletedEventArgs>;
addEventListener(
type: "operationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$DataTransfer$DataPackage, Windows$ApplicationModel$DataTransfer$OperationCompletedEventArgs>): void;
removeEventListener(
type: "operationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$DataTransfer$DataPackage, Windows$ApplicationModel$DataTransfer$OperationCompletedEventArgs>): void;

/**
 * Allows you to get and set properties like the title of the content being shared.
 */
properties: Windows$ApplicationModel$DataTransfer$DataPackagePropertySet;

/**
 * Specifies the DataPackageOperation (none, move, copy, or link) for the operation.
 */
requestedOperation: $Values<typeof Windows$ApplicationModel$DataTransfer$DataPackageOperation>;

/**
 * Maps a URI to a file. Used to ensure that referenced content (such as an image) in HTML content is added to the DataPackage .
 */
resourceMap: Windows$Foundation$Collections$IMap<string, Windows$Storage$Streams$RandomAccessStreamReference>;

/**
 * Sets the application link that a DataPackage contains.
 * @param value A URI with a scheme that isn't http or https that's handled by the source app.
 */
setApplicationLink(value: Windows$Foundation$Uri): void;

/**
 * Sets the bitmap image contained in the DataPackage .
 * @param value A stream that contains the bitmap image.
 */
setBitmap(value: Windows$Storage$Streams$RandomAccessStreamReference): void;

/**
 * Sets the data contained in the DataPackage in a RandomAccessStream format.
 * @param formatId Specifies the format of the data. We recommend that you set this value by using the StandardDataFormats class.
 * @param value Specifies the content that the DataPackage contains.
 */
setData(formatId: string, value: any): void;

/**
 * Sets a delegate to handle requests from the target app.
 * @param formatId Specifies the format of the data. We recommend that you set this value by using the StandardDataFormats class.
 * @param delayRenderer A delegate that is responsible for processing requests from a target app.
 */
setDataProvider(
formatId: string,
delayRenderer: Windows$ApplicationModel$DataTransfer$DataProviderHandler): void;

/**
 * Adds HTML content to the DataPackage .
 * @param value The HTML content.
 */
setHtmlFormat(value: string): void;

/**
 * Sets the Rich Text Format (RTF) content that is contained in a DataPackage .
 * @param value Specifies the RTF content for the DataPackage .
 */
setRtf(value: string): void;

/**
 * Sets the files and folders contained in a DataPackage .
 * @param value The files and folders to be added to the DataPackage .
 */
setStorageItems(
value: Windows$Foundation$Collections$IIterable<Windows$Storage$IStorageItem>): void;

/**
 * Adds files and folders to a DataPackage .
 * @param value The files and folders to be added to the DataPackage .
 * @param readOnly Specify true if the files are read-only; false otherwise.
 */
setStorageItems(
value: Windows$Foundation$Collections$IIterable<Windows$Storage$IStorageItem>,
readOnly: boolean): void;

/**
 * Sets the text that a DataPackage contains.
 * @param value The text.
 */
setText(value: string): void;

/**
 * Sets the Uniform Resource Identifier (URI) that is contained in the DataPackage .
 * @param value The URI that is contained in the DataPackage .
 */
setUri(value: Windows$Foundation$Uri): void;

/**
 * Sets the web link that a DataPackage contains.
 * @param value A URI with an http or https scheme that corresponds to the content being displayed to the user.
 */
setWebLink(value: Windows$Foundation$Uri): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies the operation to perform on the DataPackage in clipboard and drag and drop scenarios.
 */

declare  var Windows$ApplicationModel$DataTransfer$DataPackageOperation: {|
  +none: 0,// 0
+copy: 1,// 1
+move: 2,// 2
+link: 3,// 3

|};



/**
 * Defines a set of properties to use with a DataPackage object.
 */
declare class Windows$ApplicationModel$DataTransfer$DataPackagePropertySet  {

/**
 * Gets or sets the Uniform Resource Identifier (URI) of the app's location in the Windows Store.
 */
applicationListingUri: Windows$Foundation$Uri;

/**
 * Gets or sets the name of the app that created the DataPackage object.
 */
applicationName: string;

/**
 * Removes all items from the property set.
 */
clear(): void;

/**
 * Gets or sets the application link to the content from the source app.
 */
contentSourceApplicationLink: Windows$Foundation$Uri;

/**
 * Provides a web link to shared content that's currently displayed in the app.
 */
contentSourceWebLink: Windows$Foundation$Uri;

/**
 * Gets or sets text that describes the contents of the DataPackage .
 */
description: string;

/**
 * Gets or sets the enterprise identity (see Enterprise data protection).
 */
enterpriseId: string;

/**
 * Specifies a vector object that contains the types of files stored in the DataPackage object.
 */
fileTypes: Windows$Foundation$Collections$IVector<string>;

/**
 * Returns an iterator to enumerate the items in the property set.
 * @return The first item in the DataPackage object.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Gets an immutable view of the property set.
 * @return The immutable view.
 */
getView(): Windows$Foundation$Collections$IMapView<string, any>;

/**
 * Indicates whether the DataPackagePropertySet object contains a specific property.
 * @param key The key.
 * @return True if the property set has an item with the specified key; otherwise false.
 */
hasKey(key: string): boolean;

/**
 * Adds a property to the DataPackagePropertySet object.
 * @param key The key to insert.
 * @param value The value to insert.
 * @return True if the method replaced a value that already existed for the key; false if this is a new key.
 */
insert(key: string, value: any): boolean;

/**
 * Gets or sets a background color for the sharing app's Square30x30Logo .
 */
logoBackgroundColor: Windows$UI$Color;

/**
 * Retrieves the value of a specific property.
 * @param key The key.
 * @return The value, if an item with the specified key exists. Otherwise, an error code.
 */
lookup(key: string): any;

/**
 * Gets or sets the package family name of the source app.
 */
packageFamilyName: string;

/**
 * Removes an item from the property set.
 * @param key The key.
 */
remove(key: string): void;

/**
 * Gets the number of items that are contained in the property set.
 */
size: number;

/**
 * Gets or sets the source app's logo.
 */
square30x30Logo: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets or sets a thumbnail image for the DataPackage .
 */
thumbnail: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets or sets the text that displays as a title for the contents of the DataPackage object.
 */
title: string
}


/**
 * Gets the set of properties of a DataPackageView object.
 */
declare class Windows$ApplicationModel$DataTransfer$DataPackagePropertySetView  {

/**
 * Gets the Uniform Resource Identifier (URI) of the app's location in the Windows Store.
 */
applicationListingUri: Windows$Foundation$Uri;

/**
 * Gets the name of the app that created the DataPackage object.
 */
applicationName: string;

/**
 * Gets the application link to the content from the source app.
 */
contentSourceApplicationLink: Windows$Foundation$Uri;

/**
 * Gets a web link to shared content that's currently displayed in the app.
 */
contentSourceWebLink: Windows$Foundation$Uri;

/**
 * Gets the text that describes the contents of the DataPackage .
 */
description: string;

/**
 * Gets or sets the enterprise Id.
 */
enterpriseId: string;

/**
 * Gets a vector object that contains the types of files stored in the DataPackage object.
 */
fileTypes: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Returns an iterator to enumerate the items in the property set.
 * @return The first item in the DataPackage object.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Indicates whether the DataPackagePropertySetView object contains a specific property.
 * @param key The key.
 * @return True if the property set has an item with the specified key; otherwise false.
 */
hasKey(key: string): boolean;

/**
 * Gets a background color for the sharing app's Square30x30Logo .
 */
logoBackgroundColor: Windows$UI$Color;

/**
 * Retrieves the value of a specific property.
 * @param key The key.
 * @return The value, if an item with the specified key exists. Otherwise, an error code.
 */
lookup(key: string): any;

/**
 * Gets the package family name of the source app.
 */
packageFamilyName: string;

/**
 * Gets the number of items that are contained in the property set.
 */
size: number;

/**
 * Divides the object into two views
 */
split(
): {
first: Windows$Foundation$Collections$IMapView<string, any>,
second: Windows$Foundation$Collections$IMapView<string, any>
};

/**
 * Gets the source app's logo.
 */
square30x30Logo: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets the thumbnail image for the DataPackageView .
 */
thumbnail: Windows$Storage$Streams$RandomAccessStreamReference;

/**
 * Gets the text that displays as a title for the contents of the DataPackagePropertySetView object.
 */
title: string
}


/**
 * A read-only version of a DataPackage . Apps that receive shared content get this object when acquiring content.
 */
declare class Windows$ApplicationModel$DataTransfer$DataPackageView  {

/**
 * Returns the formats the DataPackageView contains.
 */
availableFormats: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Checks to see if the DataPackageView contains a specific data format.
 * @param formatId The name of the format.
 * @return True if the DataPackageView contains the format; false otherwise.
 */
contains(formatId: string): boolean;

/**
 * Gets the application link in the DataPackageView object.
 * @return The application link.
 */
getApplicationLinkAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Uri>;

/**
 * Gets the bitmap image contained in the DataPackageView
 * @return A stream containing the bitmap image.
 */
getBitmapAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$RandomAccessStreamReference>;

/**
 * Gets the data contained in the DataPackageView .
 * @param formatId Specifies the format of the data. We recommend that you set this value by using the StandardDataFormats class.
 * @return The data.
 */
getDataAsync(formatId: string): Windows$Foundation$IPromiseWithIAsyncOperation<any>;

/**
 * Gets the HTML stored in the DataPackageView object.
 * @return The HTML.
 */
getHtmlFormatAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Gets the data (such as an image) referenced in HTML content.
 * @return The data referenced in the HTML content.
 */
getResourceMapAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IMapView<any, any>>;

/**
 * Gets the rich text formatted (RTF) content contained in a DataPackageView .
 * @return The rich text formatted content for the DataPackage.
 */
getRtfAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Gets the files and folders stored in a DataPackageView object.
 * @return An array of files and folders stored in a DataPackageView .
 */
getStorageItemsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the text in the DataPackageView object.
 * @return The text.
 */
getTextAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Gets the text in the DataPackageView object.
 * @param formatId A string that represents the data format. Usually StandardDataFormats.text .
 * @return The text.
 */
getTextAsync(formatId: string): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Gets the URI contained in the DataPackageView .
 * @return The Uri.
 */
getUriAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Uri>;

/**
 * Gets the web link in the DataPackageView object.
 * @return The web link.
 */
getWebLinkAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Uri>;

/**
 * Gets a DataPackagePropertySetView object, which contains a read-only set of properties for the data in the DataPackageView object.
 */
properties: Windows$ApplicationModel$DataTransfer$DataPackagePropertySetView;

/**
 * Informs the system that your app is finished using the DataPackageView object. Primarily used for Clipboard operations.
 * @param value An enumeration that states what operation (such as copy or move) was completed. At most one operation flag can be set.
 */
reportOperationCompleted(
value: $Values<typeof Windows$ApplicationModel$DataTransfer$DataPackageOperation>): void;

/**
 * Requests permission to unlock and access a data package that is secured with a protection policy.
 * @param enterpriseId The enterprise Id.
 * @return When this method completes, it returns the results of the protection policy evaluation, which indicates whether or not the data is accessible.
 */
requestAccessAsync(
enterpriseId: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Security$EnterpriseData$ProtectionPolicyEvaluationResult>>;

/**
 * Requests permission to unlock and access a data package that is secured with a protection policy.
 * @return When this method completes, it returns the results of the protection policy evaluation, which indicates whether or not the data is accessible.
 */
requestAccessAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Security$EnterpriseData$ProtectionPolicyEvaluationResult>>;

/**
 * Gets the requested operation (such as copy or move). Primarily used for Clipboard actions.
 */
requestedOperation: $Values<typeof Windows$ApplicationModel$DataTransfer$DataPackageOperation>;

/**
 * Sets the accepted format Id.
 * @param formatId The format Id.
 */
setAcceptedFormatId(formatId: string): void;

/**
 * Unlocks a data package and assumes an enterprise identity for it.
 * @return When this method completes, it returns the results of the protection policy evaluation.
 */
unlockAndAssumeEnterpriseIdentity(
): $Values<typeof Windows$Security$EnterpriseData$ProtectionPolicyEvaluationResult>
}


/**
 * Used by a source app's deferral delegate to notify a DataPackage object that the source app will produce data from another asynchronous function.
 */
declare class Windows$ApplicationModel$DataTransfer$DataProviderDeferral  {

/**
 * Informs a DataPackage that it is ready for processing.
 */
complete(): void
}


/**
 * An object of this type is passed to the DataProviderHandler delegate.
 */
declare class Windows$ApplicationModel$DataTransfer$DataProviderRequest  {

/**
 * Gets the deadline for finishing a delayed rendering operation. If execution goes beyond that deadline, the results of delayed rendering are ignored.
 */
deadline: Date;

/**
 * Specifies the format id.
 */
formatId: string;

/**
 * Returns a DataProviderDeferral object.
 * @return An data provider deferral object.
 */
getDeferral(): Windows$ApplicationModel$DataTransfer$DataProviderDeferral;

/**
 * Sets the content of the DataPackage to be shared with a target app.
 * @param value The object associated with a particular format in the DataPackage .
 */
setData(value: any): void
}


/**
 * Lets your app supply the content the user wants to share or specify a message, if an error occurs.
 */
declare class Windows$ApplicationModel$DataTransfer$DataRequest  {

/**
 * Sets or gets a DataPackage object that contains the content a user wants to share.
 */
data: Windows$ApplicationModel$DataTransfer$DataPackage;

/**
 * Gets the deadline for finishing a delayed rendering operation. If execution goes beyond that deadline, the results of delayed rendering are ignored.
 */
deadline: Date;

/**
 * Cancels the sharing operation and supplies an error string to display to the user.
 * @param value The text to display to the user.
 */
failWithDisplayText(value: string): void;

/**
 * Supports asynchronous sharing operations by creating and returning a DataRequestDeferral object.
 * @return An object that allows you to share or send content asynchronously.
 */
getDeferral(): Windows$ApplicationModel$DataTransfer$DataRequestDeferral
}


/**
 * Enables you to exchange content with a target app asynchronously.
 */
declare class Windows$ApplicationModel$DataTransfer$DataRequestDeferral  {

/**
 * Indicates that the content for an asynchronous share is ready for a target app, or that an error in the sharing operation occurred.
 */
complete(): void
}


/**
 * Contains information about the DataRequested event. The system fires this event when the user invokes the Share UI.
 */
declare class Windows$ApplicationModel$DataTransfer$DataRequestedEventArgs  {

/**
 * Enables you to get the DataRequest object and either give it data or a failure message.
 */
request: Windows$ApplicationModel$DataTransfer$DataRequest
}


/**
 * Programmatically initiates an exchange of content with other apps.
 */
declare class Windows$ApplicationModel$DataTransfer$DataTransferManager  {

/**
 * Returns the DataTransferManager object associated with the current window.
 * @return The DataTransferManager object associated with the current window.
 */
static getForCurrentView(): Windows$ApplicationModel$DataTransfer$DataTransferManager;

/**
 * Programmatically initiates the user interface for sharing content with another app.
 */
static showShareUI(): void;

/**
 * Occurs when a share operation starts.
 */
ondatarequested: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$DataTransfer$DataTransferManager, Windows$ApplicationModel$DataTransfer$DataRequestedEventArgs>;
addEventListener(
type: "datarequested",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$DataTransfer$DataTransferManager, Windows$ApplicationModel$DataTransfer$DataRequestedEventArgs>): void;
removeEventListener(
type: "datarequested",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$DataTransfer$DataTransferManager, Windows$ApplicationModel$DataTransfer$DataRequestedEventArgs>): void;

/**
 * Occurs when the user chooses a target app in the Share charm.
 */
ontargetapplicationchosen: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$DataTransfer$DataTransferManager, Windows$ApplicationModel$DataTransfer$TargetApplicationChosenEventArgs>;
addEventListener(
type: "targetapplicationchosen",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$DataTransfer$DataTransferManager, Windows$ApplicationModel$DataTransfer$TargetApplicationChosenEventArgs>): void;
removeEventListener(
type: "targetapplicationchosen",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$DataTransfer$DataTransferManager, Windows$ApplicationModel$DataTransfer$TargetApplicationChosenEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}




/**
 * Responsible for formatting HTML content that you want to share or add to the Clipboard. Also allows you to get HTML fragments from the content.
 */
declare class Windows$ApplicationModel$DataTransfer$HtmlFormatHelper  {

/**
 * Takes a string that represents HTML content and adds the necessary headers to ensure it is formatted correctly for share and Clipboard operations.
 * @param htmlFragment A string representing the HTML content.
 * @return A string representing the formatted HTML.
 */
static createHtmlFormat(htmlFragment: string): string;

/**
 * Gets a string that represents an HTML fragment.
 * @param htmlFormat The formatted HTML.
 * @return An HTML fragment based on the formatted HTML.
 */
static getStaticFragment(htmlFormat: string): string
}


/**
 * Contains info about the action that a target app completed during a paste operation.
 */
declare class Windows$ApplicationModel$DataTransfer$OperationCompletedEventArgs  {
acceptedFormatId: any;

/**
 * Specifies the operation that the target app completed.
 */
operation: $Values<typeof Windows$ApplicationModel$DataTransfer$DataPackageOperation>
}


      declare var npm$namespace$Windows$ApplicationModel$DataTransfer$ShareTarget: {
        
        
        
        QuickLink: typeof Windows$ApplicationModel$DataTransfer$ShareTarget$QuickLink,
ShareOperation: typeof Windows$ApplicationModel$DataTransfer$ShareTarget$ShareOperation,
        
      }

/**
 * Represents shortcuts that help users share content with the apps they use most.
 */
declare class Windows$ApplicationModel$DataTransfer$ShareTarget$QuickLink  {

/**
 * Creates a new instance of a QuickLink object.
 */
constructor(): this;

/**
 * Specifies an ID for the QuickLink. Your app receives this ID when the user selects its QuickLink. You can use this ID to further customize the sharing process for the user.
 */
id: string;

/**
 * An array of strings that specify the data formats supported by the QuickLink app. The system shows the QuickLink only when the data that a user wants to share matches a format in this array.
 */
supportedDataFormats: Windows$Foundation$Collections$IVector<string>;

/**
 * An array of strings that specify the file types supported by a QuickLink app. The system shows the QuickLink only when the data that a user wants to share contains file items, and the file extensions for those file items match a file type in this array.
 */
supportedFileTypes: Windows$Foundation$Collections$IVector<string>;

/**
 * Specifies a thumbnail image for the QuickLink. The system displays this image when the user is presented with a list of possible apps to share content with.
 */
thumbnail: Windows$Storage$Streams$RandomAccessStreamReference;

/**
 * Specifies the title of a QuickLink. The system displays this info when the user is presented with a list of possible apps to share content with.
 */
title: string
}


/**
 * Handles the bulk of the work during a share operation. This includes the data that the user wants to share, setting or removing QuickLinks, and informing the system about the status of the operation.
 */
declare class Windows$ApplicationModel$DataTransfer$ShareTarget$ShareOperation  {

/**
 * Contains a DataPackage object with the data that the user wants to share.
 */
data: Windows$ApplicationModel$DataTransfer$DataPackageView;

/**
 * Closes the share pane.
 */
dismissUI(): void;

/**
 * A string that contains the ID of a QuickLink.
 */
quickLinkId: string;

/**
 * Removes the QuickLink from the list of QuickLinks that are available to the user.
 */
removeThisQuickLink(): void;

/**
 * Specifies that the sharing operation is complete.
 */
reportCompleted(): void;

/**
 * Specifies that the sharing operation is complete. A QuickLink that the system can save as a shortcut for future sharing operations is included.
 * @param quicklink A QuickLink object that the system saves as a shortcut for future sharing operations.
 */
reportCompleted(quicklink: Windows$ApplicationModel$DataTransfer$ShareTarget$QuickLink): void;

/**
 * Specifies that the app has acquired the content that the user wants to share.
 */
reportDataRetrieved(): void;

/**
 * Specifies that an error occurred during the sharing operation.
 * @param value Specifies the error message. The system displays this message to the user.
 */
reportError(value: string): void;

/**
 * Specifies that the app has started to acquire the content that the user wants to share.
 */
reportStarted(): void;

/**
 * Specifies that the app has requested that the system allow the sharing operation to run as a background task.
 */
reportSubmittedBackgroundTask(): void
}


/**
 * Enables an app to share a file with another app by passing a token as part of a Uri activation. The target app redeems the token to get the file shared by the source app.
 */
declare class Windows$ApplicationModel$DataTransfer$SharedStorageAccessManager  {

/**
 * Gets the sharing token that enables an app to share the specified file with another app.
 * @param file The file to share with the target app.
 * @return The sharing token to provide to the target app as part of a Uri activation.
 */
static addFile(file: Windows$Storage$IStorageFile): string;

/**
 * Gets a file shared by another app by providing the sharing token received from the source app.
 * @param token The sharing token for the shared file.
 * @return A wrapper object that contains the shared file.
 */
static redeemTokenForFileAsync(
token: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Revokes an existing sharing token.
 * @param token The sharing token to revoke.
 */
static removeFile(token: string): void
}


/**
 * Contains static properties that return string values. Each string corresponds to a known format ID. Use this class to avoid errors in using string constants to specify data formats.
 */
declare class Windows$ApplicationModel$DataTransfer$StandardDataFormats  {

/**
 * A read-only property that returns the format ID string value corresponding to the activation link format.
 */
static applicationLink: string;

/**
 * A read-only property that returns the format ID string value corresponding to the Bitmap format.
 */
static bitmap: string;

/**
 * A read-only property that returns the format ID string value corresponding to the HTML format.
 */
static html: string;

/**
 * A read-only property that returns the format ID string value corresponding to the Rich Text Format (RTF).
 */
static rtf: string;

/**
 * A read-only property that returns the format ID string value corresponding to the StorageItem format.
 */
static storageItems: string;

/**
 * A read-only property that returns the format ID string value corresponding to the Text format.
 */
static text: string;

/**
 * A read-only property that returns the format ID string value corresponding to the Uniform Resource Identifier (URI) format.
 */
static uri: string;

/**
 * A read-only property that returns the format ID string value corresponding to the web link format.
 */
static webLink: string
}


/**
 * Contains information about the target app the user chose to share content with. To get this object, you must handle the TargetApplicationChosen event.
 */
declare class Windows$ApplicationModel$DataTransfer$TargetApplicationChosenEventArgs  {

/**
 * Contains the name of the app that the user chose to share content with.
 */
applicationName: string
}


/**
 * Provides data when the target app requests it, instead of including the data in the DataPackage ahead of time. DataProviderHandler is used when the source app wants to avoid unnecessary work that is resource intensive, such as performing format conversions.
 */
declare type Windows$ApplicationModel$DataTransfer$DataProviderHandler = (request: Windows$ApplicationModel$DataTransfer$DataProviderRequest) => void;


/**
 * Enables you to detect whether your app is in design mode in a visual designer.
 */
declare class Windows$ApplicationModel$DesignMode  {

/**
 * Gets a value that indicates whether the process is running in design mode.
 */
static designModeEnabled: boolean
}


      declare var npm$namespace$Windows$ApplicationModel$Email: {
        
        
        EmailAttachmentDownloadState: typeof Windows$ApplicationModel$Email$EmailAttachmentDownloadState,
EmailBatchStatus: typeof Windows$ApplicationModel$Email$EmailBatchStatus,
EmailFlagState: typeof Windows$ApplicationModel$Email$EmailFlagState,
EmailImportance: typeof Windows$ApplicationModel$Email$EmailImportance,
EmailMailboxActionKind: typeof Windows$ApplicationModel$Email$EmailMailboxActionKind,
EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation: typeof Windows$ApplicationModel$Email$EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation,
EmailMailboxAutoReplyMessageResponseKind: typeof Windows$ApplicationModel$Email$EmailMailboxAutoReplyMessageResponseKind,
EmailMailboxChangeType: typeof Windows$ApplicationModel$Email$EmailMailboxChangeType,
EmailMailboxCreateFolderStatus: typeof Windows$ApplicationModel$Email$EmailMailboxCreateFolderStatus,
EmailMailboxDeleteFolderStatus: typeof Windows$ApplicationModel$Email$EmailMailboxDeleteFolderStatus,
EmailMailboxEmptyFolderStatus: typeof Windows$ApplicationModel$Email$EmailMailboxEmptyFolderStatus,
EmailMailboxOtherAppReadAccess: typeof Windows$ApplicationModel$Email$EmailMailboxOtherAppReadAccess,
EmailMailboxOtherAppWriteAccess: typeof Windows$ApplicationModel$Email$EmailMailboxOtherAppWriteAccess,
EmailMailboxSmimeEncryptionAlgorithm: typeof Windows$ApplicationModel$Email$EmailMailboxSmimeEncryptionAlgorithm,
EmailMailboxSmimeSigningAlgorithm: typeof Windows$ApplicationModel$Email$EmailMailboxSmimeSigningAlgorithm,
EmailMailboxSyncStatus: typeof Windows$ApplicationModel$Email$EmailMailboxSyncStatus,
EmailMeetingResponseType: typeof Windows$ApplicationModel$Email$EmailMeetingResponseType,
EmailMessageBodyKind: typeof Windows$ApplicationModel$Email$EmailMessageBodyKind,
EmailMessageDownloadState: typeof Windows$ApplicationModel$Email$EmailMessageDownloadState,
EmailMessageResponseKind: typeof Windows$ApplicationModel$Email$EmailMessageResponseKind,
EmailMessageSmimeKind: typeof Windows$ApplicationModel$Email$EmailMessageSmimeKind,
EmailQueryKind: typeof Windows$ApplicationModel$Email$EmailQueryKind,
EmailQuerySearchFields: typeof Windows$ApplicationModel$Email$EmailQuerySearchFields,
EmailQuerySearchScope: typeof Windows$ApplicationModel$Email$EmailQuerySearchScope,
EmailQuerySortDirection: typeof Windows$ApplicationModel$Email$EmailQuerySortDirection,
EmailQuerySortProperty: typeof Windows$ApplicationModel$Email$EmailQuerySortProperty,
EmailRecipientResolutionStatus: typeof Windows$ApplicationModel$Email$EmailRecipientResolutionStatus,
EmailSpecialFolderKind: typeof Windows$ApplicationModel$Email$EmailSpecialFolderKind,
EmailStoreAccessType: typeof Windows$ApplicationModel$Email$EmailStoreAccessType,
        EmailAttachment: typeof Windows$ApplicationModel$Email$EmailAttachment,
EmailConversation: typeof Windows$ApplicationModel$Email$EmailConversation,
EmailConversationBatch: typeof Windows$ApplicationModel$Email$EmailConversationBatch,
EmailConversationReader: typeof Windows$ApplicationModel$Email$EmailConversationReader,
EmailFolder: typeof Windows$ApplicationModel$Email$EmailFolder,
EmailIrmInfo: typeof Windows$ApplicationModel$Email$EmailIrmInfo,
EmailIrmTemplate: typeof Windows$ApplicationModel$Email$EmailIrmTemplate,
EmailItemCounts: typeof Windows$ApplicationModel$Email$EmailItemCounts,
EmailMailbox: typeof Windows$ApplicationModel$Email$EmailMailbox,
EmailMailboxAction: typeof Windows$ApplicationModel$Email$EmailMailboxAction,
EmailMailboxAutoReply: typeof Windows$ApplicationModel$Email$EmailMailboxAutoReply,
EmailMailboxAutoReplySettings: typeof Windows$ApplicationModel$Email$EmailMailboxAutoReplySettings,
EmailMailboxCapabilities: typeof Windows$ApplicationModel$Email$EmailMailboxCapabilities,
EmailMailboxChange: typeof Windows$ApplicationModel$Email$EmailMailboxChange,
EmailMailboxChangeReader: typeof Windows$ApplicationModel$Email$EmailMailboxChangeReader,
EmailMailboxChangeTracker: typeof Windows$ApplicationModel$Email$EmailMailboxChangeTracker,
EmailMailboxChangedDeferral: typeof Windows$ApplicationModel$Email$EmailMailboxChangedDeferral,
EmailMailboxChangedEventArgs: typeof Windows$ApplicationModel$Email$EmailMailboxChangedEventArgs,
EmailMailboxCreateFolderResult: typeof Windows$ApplicationModel$Email$EmailMailboxCreateFolderResult,
EmailMailboxPolicies: typeof Windows$ApplicationModel$Email$EmailMailboxPolicies,
EmailMailboxSyncManager: typeof Windows$ApplicationModel$Email$EmailMailboxSyncManager,
EmailManager: typeof Windows$ApplicationModel$Email$EmailManager,
EmailMeetingInfo: typeof Windows$ApplicationModel$Email$EmailMeetingInfo,
EmailMessage: typeof Windows$ApplicationModel$Email$EmailMessage,
EmailMessageBatch: typeof Windows$ApplicationModel$Email$EmailMessageBatch,
EmailMessageReader: typeof Windows$ApplicationModel$Email$EmailMessageReader,
EmailQueryOptions: typeof Windows$ApplicationModel$Email$EmailQueryOptions,
EmailQueryTextSearch: typeof Windows$ApplicationModel$Email$EmailQueryTextSearch,
EmailRecipient: typeof Windows$ApplicationModel$Email$EmailRecipient,
EmailRecipientResolutionResult: typeof Windows$ApplicationModel$Email$EmailRecipientResolutionResult,
EmailStore: typeof Windows$ApplicationModel$Email$EmailStore,
EmailStoreNotificationTriggerDetails: typeof Windows$ApplicationModel$Email$EmailStoreNotificationTriggerDetails,
        EmailCertificateValidationStatus: typeof npm$namespace$Windows$ApplicationModel$Email$EmailCertificateValidationStatus,
      }

/**
 * Represents an email attachment.
 */
declare class Windows$ApplicationModel$Email$EmailAttachment  {

/**
 * Initializes a new instance of the EmailAttachment class.
 */
constructor(): this;

/**
 * Initializes a new instance of the EmailAttachment class with the specified random access stream.
 * @param filename The file name to use for the attachment.
 * @param data A random access stream containing the data for the attachment.
 */
constructor(filename: string, data: Windows$Storage$Streams$IRandomAccessStreamReference): this;

/**
 * Initializes a new instance of the EmailAttachment class.
 * @param fileName The filename of the attachment.
 * @param data The stream to use to download the attachment.
 * @param mimeType The MIME type of the attachment.
 */
constructor(fileName: string, data: Windows$Storage$Streams$IRandomAccessStreamReference, mimeType: string): this;

/**
 * Gets or sets a value that identifies the content of the attachment on a remote system.
 */
contentId: string;

/**
 * Gets or sets the location of an email attachment as a Uniform Resource Identifier (URI).
 */
contentLocation: string;

/**
 * Gets or sets the email attachment's data.
 */
data: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets or sets the download state of the email attachment.
 */
downloadState: $Values<typeof Windows$ApplicationModel$Email$EmailAttachmentDownloadState>;

/**
 * Gets or sets the estimated download size of the attachment.
 */
estimatedDownloadSizeInBytes: number;

/**
 * Gets or sets the displayed file name for the email attachment.
 */
fileName: string;

/**
 * Gets the locally unique ID for the email attachment.
 */
id: string;

/**
 * Gets a Boolean value indicating if the attachment came from the base message.
 */
isFromBaseMessage: boolean;

/**
 * Gets or sets a Boolean property indicating if the attachment is included inline, in the body of the message.
 */
isInline: boolean;

/**
 * Gets or sets the MIME type of the attachment.
 */
mimeType: string
}


/**
 * Defines the states of an email attachment download.
 */

declare  var Windows$ApplicationModel$Email$EmailAttachmentDownloadState: {|
  +notDownloaded: 0,// 0
+downloading: 1,// 1
+downloaded: 2,// 2
+failed: 3,// 3

|};



/**
 * Defines the states of an email batch operation.
 */

declare  var Windows$ApplicationModel$Email$EmailBatchStatus: {|
  +success: 0,// 0
+serverSearchSyncManagerError: 1,// 1
+serverSearchUnknownError: 2,// 2

|};



      declare var npm$namespace$Windows$ApplicationModel$Email$EmailCertificateValidationStatus: {
        
        success: typeof Windows$ApplicationModel$Email$EmailCertificateValidationStatus$success,
noMatch: typeof Windows$ApplicationModel$Email$EmailCertificateValidationStatus$noMatch,
invalidUsage: typeof Windows$ApplicationModel$Email$EmailCertificateValidationStatus$invalidUsage,
invalidCertificate: typeof Windows$ApplicationModel$Email$EmailCertificateValidationStatus$invalidCertificate,
revoked: typeof Windows$ApplicationModel$Email$EmailCertificateValidationStatus$revoked,
chainRevoked: typeof Windows$ApplicationModel$Email$EmailCertificateValidationStatus$chainRevoked,
revocationServerFailure: typeof Windows$ApplicationModel$Email$EmailCertificateValidationStatus$revocationServerFailure,
expired: typeof Windows$ApplicationModel$Email$EmailCertificateValidationStatus$expired,
untrusted: typeof Windows$ApplicationModel$Email$EmailCertificateValidationStatus$untrusted,
serverError: typeof Windows$ApplicationModel$Email$EmailCertificateValidationStatus$serverError,
unknownFailure: typeof Windows$ApplicationModel$Email$EmailCertificateValidationStatus$unknownFailure,
        
        
        
      }
declare var Windows$ApplicationModel$Email$EmailCertificateValidationStatus$success: any;

declare var Windows$ApplicationModel$Email$EmailCertificateValidationStatus$noMatch: any;

declare var Windows$ApplicationModel$Email$EmailCertificateValidationStatus$invalidUsage: any;

declare var Windows$ApplicationModel$Email$EmailCertificateValidationStatus$invalidCertificate: any;

declare var Windows$ApplicationModel$Email$EmailCertificateValidationStatus$revoked: any;

declare var Windows$ApplicationModel$Email$EmailCertificateValidationStatus$chainRevoked: any;

declare var Windows$ApplicationModel$Email$EmailCertificateValidationStatus$revocationServerFailure: any;

declare var Windows$ApplicationModel$Email$EmailCertificateValidationStatus$expired: any;

declare var Windows$ApplicationModel$Email$EmailCertificateValidationStatus$untrusted: any;

declare var Windows$ApplicationModel$Email$EmailCertificateValidationStatus$serverError: any;

declare var Windows$ApplicationModel$Email$EmailCertificateValidationStatus$unknownFailure: any;


/**
 * Represents an email conversation.
 */
declare class Windows$ApplicationModel$Email$EmailConversation  {

/**
 * Asynchronously gets a batch of messages in the conversation.
 * @param count The size of the batch of messages to retrieve.
 * @return The batch of messages.
 */
findMessagesAsync(
count: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously gets a batch of messages in the conversation.
 * @return The batch of messages.
 */
findMessagesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the EmailFlagState for the conversation.
 */
flagState: $Values<typeof Windows$ApplicationModel$Email$EmailFlagState>;

/**
 * Gets a Boolean value indicating if the conversation has an attachment.
 */
hasAttachment: boolean;

/**
 * Gets the unique identifier for the EmailConversation .
 */
id: string;

/**
 * Gets the value that specifies the importance of the conversation; normal, high or low.
 */
importance: $Values<typeof Windows$ApplicationModel$Email$EmailImportance>;

/**
 * Gets the last EmailMessageResponseKind for the conversation.
 */
lastEmailResponseKind: $Values<typeof Windows$ApplicationModel$Email$EmailMessageResponseKind>;

/**
 * Gets the latest sender in the conversation.
 */
latestSender: Windows$ApplicationModel$Email$EmailRecipient;

/**
 * Gets the ID for the mailbox.
 */
mailboxId: string;

/**
 * Gets the number of messages in the conversation.
 */
messageCount: number;

/**
 * Gets the ID of the most recent message in the conversation.
 */
mostRecentMessageId: string;

/**
 * Gets the time of the most recent message in the conversation.
 */
mostRecentMessageTime: Date;

/**
 * Gets a preview of the latest message in the conversation.
 */
preview: string;

/**
 * Gets the subject of the latest message in the conversation.
 */
subject: string;

/**
 * Gets the number of unread messages in the conversation.
 */
unreadMessageCount: number
}


/**
 * Represents a group of EmailConversation objects for batch processing.
 */
declare class Windows$ApplicationModel$Email$EmailConversationBatch  {

/**
 * Gets a list of EmailConversation objects to use for batch processing.
 */
conversations: Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Email$EmailConversation>;

/**
 * Gets the status of the last batch processing operation.
 */
status: $Values<typeof Windows$ApplicationModel$Email$EmailBatchStatus>
}


/**
 * Reads a batch of email conversations.
 */
declare class Windows$ApplicationModel$Email$EmailConversationReader  {

/**
 * Asynchronously reads a batch of email conversations.
 * @return Returns a batch of email conversations.
 */
readBatchAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailConversationBatch>
}


/**
 * Defines the flag state of an email message.
 */

declare  var Windows$ApplicationModel$Email$EmailFlagState: {|
  +unflagged: 0,// 0
+flagged: 1,// 1
+completed: 2,// 2
+cleared: 3,// 3

|};



/**
 * Represents and email folder.
 */
declare class Windows$ApplicationModel$Email$EmailFolder  {

/**
 * Asynchronously creates a new folder.
 * @param name The name for the new folder.
 * @return Returns the newly created folder.
 */
createFolderAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailFolder>;

/**
 * Asynchronously deletes this folder.
 * @return An async action indicating that the operation has completed.
 */
deleteAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets or sets the display name for the folder.
 */
displayName: string;

/**
 * Asynchronously finds the child folders of this folder.
 * @return The list of child folders.
 */
findChildFoldersAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets an instance of the EmailConversationReader class.
 * @return The conversation reader.
 */
getConversationReader(): Windows$ApplicationModel$Email$EmailConversationReader;

/**
 * Gets an instance of the EmailConversationReader class using the specified query options.
 * @param options The query options to use when finding the conversation reader.
 * @return The conversation reader that matches the query options.
 */
getConversationReader(
options: Windows$ApplicationModel$Email$EmailQueryOptions): Windows$ApplicationModel$Email$EmailConversationReader;

/**
 * Asynchronously gets the specified message from the folder.
 * @param id The ID of the message to retrieve.
 * @return The message specified in the id parameter.
 */
getMessageAsync(
id: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailMessage>;

/**
 * Asynchronously gets the counts of email items such as flagged emails, important emails, unread emails, total emails, and so on.
 * @return An EmailItemCounts object containing the counts of email items such as flagged emails, important emails, unread emails, total emails, and so on.
 */
getMessageCountsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailItemCounts>;

/**
 * Gets an instance of the EmailMessageReader class.
 * @return The message reader.
 */
getMessageReader(): Windows$ApplicationModel$Email$EmailMessageReader;

/**
 * Gets an instance of the EmailMessageReader class using the specified query options.
 * @param options The query options to use when finding the message reader.
 * @return The message reader that matches the query options.
 */
getMessageReader(
options: Windows$ApplicationModel$Email$EmailQueryOptions): Windows$ApplicationModel$Email$EmailMessageReader;

/**
 * Gets the ID of the email folder.
 */
id: string;

/**
 * Gets or sets a Boolean value indicating if the folder is sync enabled.
 */
isSyncEnabled: boolean;

/**
 * Gets the type of the folder such as inbox, outbox, drafts, sent, and so on.
 */
kind: $Values<typeof Windows$ApplicationModel$Email$EmailSpecialFolderKind>;

/**
 * Gets or sets the last time the folder was successfully synced with the server.
 */
lastSuccessfulSyncTime: Date;

/**
 * Gets the ID of the mailbox that contains this folder.
 */
mailboxId: string;

/**
 * Gets the ID of this folder's parent folder.
 */
parentFolderId: string;

/**
 * Gets or sets the remote ID of the corresponding folder on the server.
 */
remoteId: string;

/**
 * Asynchronously saves the specified email message to the folder.
 * @param message The email message to save.
 * @return An async action indicating that the operation has completed.
 */
saveMessageAsync(
message: Windows$ApplicationModel$Email$EmailMessage): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously attempts to move this folder to the specified folder.
 * @param newParentFolder The new location for this folder.
 * @return A Boolean value indicating if the move was successful.
 */
tryMoveAsync(
newParentFolder: Windows$ApplicationModel$Email$EmailFolder): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously attempts to move this folder to the specified folder and rename it in the process.
 * @param newParentFolder The new location for this folder.
 * @param newFolderName The name for the folder in the new location.
 * @return A Boolean value indicating if the move was successful.
 */
tryMoveAsync(
newParentFolder: Windows$ApplicationModel$Email$EmailFolder,
newFolderName: string): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously attempts to save changes to the folder.
 * @return A Boolean value indicating if the save was successful.
 */
trySaveAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>
}


/**
 * Defines the importance of an email message.
 */

declare  var Windows$ApplicationModel$Email$EmailImportance: {|
  +normal: 0,// 0
+high: 1,// 1
+low: 2,// 2

|};



/**
 * Represents email information rights management (IRM) info.
 */
declare class Windows$ApplicationModel$Email$EmailIrmInfo  {

/**
 * Initializes a new instance of the EmailIrmInfo class.
 */
constructor(): this;

/**
 * Initializes a new instance of the EmailIrmInfo class using the specified IRM expiration time and template.
 * @param expiration The time when the information rights management (IRM) permissions expire.
 * @param irmTemplate The IRM template to apply to the message.
 */
constructor(expiration: Date, irmTemplate: Windows$ApplicationModel$Email$EmailIrmTemplate): this;

/**
 * Gets or sets a Boolean value that indicates if an email message is allowed to be edited.
 */
canEdit: boolean;

/**
 * Gets or sets a Boolean value that indicates if the user can copy the contents of an email message to the clipboard.
 */
canExtractData: boolean;

/**
 * Gets or sets a Boolean value that indicates if the email message is allowed to be forwarded.
 */
canForward: boolean;

/**
 * Gets or sets a Boolean value that indicates if the user is allowed to change any of the email recipients when responding.
 */
canModifyRecipientsOnResponse: boolean;

/**
 * Gets or sets a Boolean value that indicates if the user is allowed to print the contents of the email message or any attachments.
 */
canPrintData: boolean;

/**
 * Gets or sets a Boolean value that indicates if the recipient is allowed to remove information rights management (IRM) when responding.
 */
canRemoveIrmOnResponse: boolean;

/**
 * Gets or sets a Boolean value that indicates if the recipient is allowed to reply to the email message.
 */
canReply: boolean;

/**
 * Gets or sets a Boolean value that indicates if the recipient is allowed to reply all to the email message.
 */
canReplyAll: boolean;

/**
 * Gets or sets the expiration date for the information rights management (IRM) permissions.
 */
expirationDate: Date;

/**
 * Gets or sets a Boolean value that indicates if the sender is the information rights management (IRM) originator.
 */
isIrmOriginator: boolean;

/**
 * Gets or sets a Boolean value that indicates if programmatic access to the message is allowed.
 */
isProgramaticAccessAllowed: boolean;

/**
 * Gets or sets the EmailIrmTemplate used to create the information rights management (IRM) info.
 */
template: Windows$ApplicationModel$Email$EmailIrmTemplate
}


/**
 * Represents a template that can be used to create new EmailIrmInfo objects.
 */
declare class Windows$ApplicationModel$Email$EmailIrmTemplate  {

/**
 * Creates a new instance of the EmailIrmTemplate class with the specified ID, name and description.
 * @param id The ID for the new template.
 * @param name The name of the new template.
 * @param description The description of the new template.
 */
constructor(id: string, name: string, description: string): this;

/**
 * Creates a new instance of the EmailIrmTemplate class.
 */
constructor(): this;

/**
 * Gets or sets the description of the template.
 */
description: string;

/**
 * Gets or sets the ID for the template.
 */
id: string;

/**
 * Gets or sets the name for the template.
 */
name: string
}


/**
 * Represents the counts for various email message attributes such as flagged, important, unread, and so on.
 */
declare class Windows$ApplicationModel$Email$EmailItemCounts  {

/**
 * Gets the number of flagged email messages.
 */
flagged: number;

/**
 * Gets the number of important email messages.
 */
important: number;

/**
 * Gets the total number of email messages
 */
total: number;

/**
 * Gets the number of unread email messages.
 */
unread: number
}


/**
 * Represents an email mailbox located on a remote email server.
 */
declare class Windows$ApplicationModel$Email$EmailMailbox  {

/**
 * Gets the capabilities associated with the mailbox.
 */
capabilities: Windows$ApplicationModel$Email$EmailMailboxCapabilities;

/**
 * Asynchronously changes the flag state of an email message.
 * @param messageId The ID of the email message to change.
 * @param flagState The new email flag state.
 * @return An async action indicating that the operation has completed.
 */
changeMessageFlagStateAsync(
messageId: string,
flagState: $Values<typeof Windows$ApplicationModel$Email$EmailFlagState>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the EmailMailboxChangeTracker for this mailbox.
 */
changeTracker: Windows$ApplicationModel$Email$EmailMailboxChangeTracker;

/**
 * Creates a new response email such as Reply, Reply All, Forward, and so on.
 * @param messageId The ID of the message to which to respond.
 * @param responseType The type of response such as Reply, Reply All, Forward, and so on.
 * @param subject The subject for the response message.
 * @param responseHeaderType The format of the email body such as plain text or HTML.
 * @param responseHeader The header for the response message.
 * @return The newly created response email message.
 */
createResponseMessageAsync(
messageId: string,
responseType: $Values<typeof Windows$ApplicationModel$Email$EmailMessageResponseKind>,
subject: string,
responseHeaderType: $Values<typeof Windows$ApplicationModel$Email$EmailMessageBodyKind>,
responseHeader: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailMessage>;

/**
 * Asynchronously deletes the mailbox.
 * @return An async action indicating that the operation has completed.
 */
deleteAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously deletes an email message from the mailbox.
 * @param messageId The ID of the email message to delete.
 * @return An async action indicating that the operation has completed.
 */
deleteMessageAsync(messageId: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets or sets the name for this mailbox that is suitable for displaying.
 */
displayName: string;

/**
 * Asynchronously downloads an email attachment.
 * @param attachmentId The ID of the attachment to download.
 * @return An async action indicating that the operation has completed.
 */
downloadAttachmentAsync(attachmentId: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously downloads the specified email message.
 * @param messageId The ID of the message to download.
 * @return An async action indicating that the operation has completed.
 */
downloadMessageAsync(messageId: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously gets the specified email conversation.
 * @param id The ID of the email conversation to retrieve.
 * @return Returns the email conversation specified by the id parameter.
 */
getConversationAsync(
id: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailConversation>;

/**
 * Gets or creates an email conversation reader for this mailbox if one does not already exist.
 * @return The email conversation reader.
 */
getConversationReader(): Windows$ApplicationModel$Email$EmailConversationReader;

/**
 * Gets or creates an email conversation reader for this mailbox using the specified query options.
 * @param options The email query options to use when creating the conversation reader.
 * @return The new or existing conversation reader.
 */
getConversationReader(
options: Windows$ApplicationModel$Email$EmailQueryOptions): Windows$ApplicationModel$Email$EmailConversationReader;

/**
 * Asynchronously gets the specified email folder.
 * @param id The ID of the folder to retrieve.
 * @return The email folder specified in the id parameter.
 */
getFolderAsync(
id: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailFolder>;

/**
 * Asynchronously gets the specified email message.
 * @param id The ID of the message to retrieve.
 * @return The email message specified in the id parameter.
 */
getMessageAsync(
id: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailMessage>;

/**
 * Gets or creates an email message reader for this mailbox if one does not already exist.
 * @return The new or existing email message reader.
 */
getMessageReader(): Windows$ApplicationModel$Email$EmailMessageReader;

/**
 * Gets or creates an email conversation reader for this mailbox using the specified query options.
 * @param options The email query options to use when creating the message reader.
 * @return The new or existing email message reader.
 */
getMessageReader(
options: Windows$ApplicationModel$Email$EmailQueryOptions): Windows$ApplicationModel$Email$EmailMessageReader;

/**
 * Asynchronously get a special email folder such as Inbox, Outbox, Drafts and so on.
 * @param folderType The type of folder to retrieve.
 * @return The matching special email folder in this mailbox.
 */
getSpecialFolderAsync(
folderType: $Values<typeof Windows$ApplicationModel$Email$EmailSpecialFolderKind>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailFolder>;

/**
 * Gets the ID for this mailbox.
 */
id: string;

/**
 * Gets a Boolean value that indicates if email data is encrypted when the device is locked.
 */
isDataEncryptedUnderLock: boolean;

/**
 * Gets a Boolean value that indicates if this mailbox is owned by the current app.
 */
isOwnedByCurrentApp: boolean;

/**
 * Gets the identifier for a mailbox linked to this one.
 */
linkedMailboxId: string;

/**
 * Gets or sets the email address for the mailbox.
 */
mailAddress: string;

/**
 * Gets the list of email aliases associated with this mailbox.
 */
mailAddressAliases: Windows$Foundation$Collections$IVector<string>;

/**
 * Asynchronously marks all the messages in a folder as seen.
 * @param folderId The ID of the folder to mark as seen.
 * @return An async action indicating that the operation has completed.
 */
markFolderAsSeenAsync(folderId: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously marks a folder as sync enabled or disabled.
 * @param folderId The ID of the folder to mark.
 * @param isSyncEnabled True to enable to syncing with the server, false to disable syncing.
 * @return An async action indicating that the operation has completed.
 */
markFolderSyncEnabledAsync(
folderId: string,
isSyncEnabled: boolean): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously marks an email message as seen.
 * @param messageId The ID of the message to mark as seen.
 * @return An async action indicating that the operation has completed.
 */
markMessageAsSeenAsync(messageId: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously marks an email message as read or unread.
 * @param messageId The ID of the message to mark.
 * @param isRead True to mark the message as read, false to mark it as unread.
 * @return An async action indicating that the operation has completed.
 */
markMessageReadAsync(
messageId: string,
isRead: boolean): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the identifier of the email mailbox account within its network.
 */
networkAccountId: string;

/**
 * Gets the identifier of the network associated with this email mailbox.
 */
networkId: string;

/**
 * Occurs when the mailbox has changed.
 */
onmailboxchanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Email$EmailMailbox, Windows$ApplicationModel$Email$EmailMailboxChangedEventArgs>;
addEventListener(
type: "mailboxchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Email$EmailMailbox, Windows$ApplicationModel$Email$EmailMailboxChangedEventArgs>): void;
removeEventListener(
type: "mailboxchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Email$EmailMailbox, Windows$ApplicationModel$Email$EmailMailboxChangedEventArgs>): void;

/**
 * Gets or sets the read access level to this mailbox for other apps.
 */
otherAppReadAccess: $Values<typeof Windows$ApplicationModel$Email$EmailMailboxOtherAppReadAccess>;

/**
 * Gets or sets the write access level to this mailbox for other apps.
 */
otherAppWriteAccess: $Values<typeof Windows$ApplicationModel$Email$EmailMailboxOtherAppWriteAccess>;

/**
 * Gets the security policies for attachments in this mailbox.
 */
policies: Windows$ApplicationModel$Email$EmailMailboxPolicies;

/**
 * Resolves a list of one or more email addresses.
 * @param recipients The list of email addresses.
 * @return A list of resolution results. The result list will be in the same order as the input list. See EmailRecipientResolutionResult for more information.
 */
resolveRecipientsAsync(
recipients: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously saves the mailbox to the email store.
 * @return An async action indicating that the operation has completed.
 */
saveAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously saves a draft email message.
 * @param message The draft email message to save.
 * @return An async action indicating that the operation has completed.
 */
saveDraftAsync(
message: Windows$ApplicationModel$Email$EmailMessage): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously sends the specified email message.
 * @param message The email message to send.
 * @return An async action indicating that the operation has completed.
 */
sendMessageAsync(
message: Windows$ApplicationModel$Email$EmailMessage): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously sends the specified email message.
 * @param message The email message to send.
 * @param smartSend True to send only the updated text, false to include the full message thread.
 * @return An async action indicating that the operation has completed.
 */
sendMessageAsync(
message: Windows$ApplicationModel$Email$EmailMessage,
smartSend: boolean): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the display name of the source mailbox.
 */
sourceDisplayName: string;

/**
 * Gets the sync manager for the mailbox.
 */
syncManager: Windows$ApplicationModel$Email$EmailMailboxSyncManager;

/**
 * Asynchronously attempts to create a new email folder.
 * @param parentFolderId The Id of the parent email folder.
 * @param name The name for the new folder.
 * @return An async operation with an EmailMailboxCreateFolderResult containing the newly created folder and the status of the create operation.
 */
tryCreateFolderAsync(
parentFolderId: string,
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailMailboxCreateFolderResult>;

/**
 * Asynchronously attempts to delete an email folder.
 * @param folderId The Id of the folder to delete.
 * @return An async operation with an EmailMailboxDeleteFolderStatus value representing the status of the delete operation.
 */
tryDeleteFolderAsync(
folderId: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$Email$EmailMailboxDeleteFolderStatus>>;

/**
 * Asynchronously attempt to delete the contents of an email folder.
 * @param folderId The Id of the folder to empty.
 * @return An async operation with an EmailMailboxEmptyFolderStatus value representing the status of the delete operation.
 */
tryEmptyFolderAsync(
folderId: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$Email$EmailMailboxEmptyFolderStatus>>;

/**
 * Asynchronously attempts to forward a meeting request.
 * @param meeting The meeting to forward.
 * @param recipients The list of new recipients.
 * @param subject The subject of the email.
 * @param forwardHeaderType The email message format, HTML or plain text.
 * @param forwardHeader The email forward header.
 * @param comment The body of the message.
 * @return A Boolean value indicating if the meeting was successfully forwarded.
 */
tryForwardMeetingAsync(
meeting: Windows$ApplicationModel$Email$EmailMessage,
recipients: Windows$Foundation$Collections$IIterable<Windows$ApplicationModel$Email$EmailRecipient>,
subject: string,
forwardHeaderType: $Values<typeof Windows$ApplicationModel$Email$EmailMessageBodyKind>,
forwardHeader: string,
comment: string): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously attempts to get the auto-reply settings for the mailbox.
 * @param requestedFormat The requested text format of the auto-reply message, HTML or plain text.
 * @return The auto-reply settings.
 */
tryGetAutoReplySettingsAsync(
requestedFormat: $Values<typeof Windows$ApplicationModel$Email$EmailMailboxAutoReplyMessageResponseKind>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailMailboxAutoReplySettings>;

/**
 * Asynchronously attempts to move the specified email folder.
 * @param folderId The folder to move.
 * @param newParentFolderId The new parent for the folder specified in the folderId parameter.
 * @return A Boolean value indicating if the move was successful.
 */
tryMoveFolderAsync(
folderId: string,
newParentFolderId: string): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously attempts to move the specified email folder and rename it in the process.
 * @param folderId The folder to move.
 * @param newParentFolderId The new parent for the folder specified in the folderId parameter.
 * @param newFolderName The name for the folder in the new location.
 * @return A Boolean value indicating if the move was successful.
 */
tryMoveFolderAsync(
folderId: string,
newParentFolderId: string,
newFolderName: string): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously attempts to move the specified email message.
 * @param messageId The ID of the email message to move.
 * @param newParentFolderId The ID of the new folder where the email message should reside.
 * @return A Boolean value indicating if the move was successful.
 */
tryMoveMessageAsync(
messageId: string,
newParentFolderId: string): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously attempts to send a meeting request proposing a new time.
 * @param meeting The meeting for which to propose a new time.
 * @param newStartTime The proposed new time for the meeting to start.
 * @param newDuration The proposed duration of the meeting.
 * @param subject The subject of the meeting email.
 * @param comment The body of the message.
 * @return A Boolean value indicating if the proposed meeting message was successfully sent.
 */
tryProposeNewTimeForMeetingAsync(
meeting: Windows$ApplicationModel$Email$EmailMessage,
newStartTime: Date,
newDuration: number,
subject: string,
comment: string): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously attempts to set the auto-reply settings for the mailbox.
 * @param autoReplySettings The new auto-reply settings.
 * @return A Boolean value indicating if the operation was successful.
 */
trySetAutoReplySettingsAsync(
autoReplySettings: Windows$ApplicationModel$Email$EmailMailboxAutoReplySettings): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously attempts to respond to a meeting request.
 * @param meeting The meeting request.
 * @param response The response to the meeting request, accept, decline, or tentative.
 * @param subject The subject of the response email message.
 * @param comment The body of the response email message.
 * @param sendUpdate A Boolean indicating whether or not to send a response to the meeting originator.
 * @return A Boolean value indicating if the response was sent successfully.
 */
tryUpdateMeetingResponseAsync(
meeting: Windows$ApplicationModel$Email$EmailMessage,
response: $Values<typeof Windows$ApplicationModel$Email$EmailMeetingResponseType>,
subject: string,
comment: string,
sendUpdate: boolean): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets the ID of the user data account for the mailbox.
 */
userDataAccountId: string;

/**
 * Validates the certificate against the sync provider service.
 * @param certificates The certificate to validate.
 * @return The confirmation that the certificate is valid.
 */
validateCertificatesAsync(
certificates: Windows$Foundation$Collections$IIterable<Windows$Security$Cryptography$Certificates$Certificate>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data about a change that occurred to a mailbox.
 */
declare class Windows$ApplicationModel$Email$EmailMailboxAction  {

/**
 * Gets the number that identifies the change that happened to the mailbox.
 */
changeNumber: number;

/**
 * Gets the value that represents the kind of change that happened to the mailbox.
 */
kind: $Values<typeof Windows$ApplicationModel$Email$EmailMailboxActionKind>
}


/**
 * Defines the kind of action to be taken.
 */

declare  var Windows$ApplicationModel$Email$EmailMailboxActionKind: {|
  +markMessageAsSeen: 0,// 0
+markMessageRead: 1,// 1
+changeMessageFlagState: 2,// 2
+moveMessage: 3,// 3
+saveDraft: 4,// 4
+sendMessage: 5,// 5
+createResponseReplyMessage: 6,// 6
+createResponseReplyAllMessage: 7,// 7
+createResponseForwardMessage: 8,// 8
+moveFolder: 9,// 9
+markFolderForSyncEnabled: 10,// 10

|};



/**
 * Defines the type of negotiation on encryption algorithms permitted by the server.
 */

declare  var Windows$ApplicationModel$Email$EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation: {|
  +none: 0,// 0
+strongAlgorithm: 1,// 1
+anyAlgorithm: 2,// 2

|};



/**
 * Represents an auto-reply message set on a mailbox.
 */
declare class Windows$ApplicationModel$Email$EmailMailboxAutoReply  {

/**
 * Gets or sets a Boolean value that indicates if the auto-reply message is enabled.
 */
isEnabled: boolean;

/**
 * Gets or sets the auto-reply response text.
 */
response: string
}


/**
 * Defines the encoding schema used for automatic replies.
 */

declare  var Windows$ApplicationModel$Email$EmailMailboxAutoReplyMessageResponseKind: {|
  +html: 0,// 0
+plainText: 1,// 1

|};



/**
 * Represents the settings for the automatic reply functionality of an email account.
 */
declare class Windows$ApplicationModel$Email$EmailMailboxAutoReplySettings  {

/**
 * Initializes a new instance of an EmailMailboxAutoReplySettings object.
 */
constructor(): this;

/**
 * Represents the end time for the automated reply period.
 */
endTime: Date;

/**
 * Gets the automatic reply message intended for an email message from an internal sender.
 */
internalReply: Windows$ApplicationModel$Email$EmailMailboxAutoReply;

/**
 * Gets a Boolean value indicating whether automatic replies are enabled.
 */
isEnabled: boolean;

/**
 * Gets the automatic reply message intended for an email message from a known external sender.
 */
knownExternalReply: Windows$ApplicationModel$Email$EmailMailboxAutoReply;

/**
 * Gets or sets whether the automated response email message is encoded as HTML or plain text.
 */
responseKind: $Values<typeof Windows$ApplicationModel$Email$EmailMailboxAutoReplyMessageResponseKind>;

/**
 * Represents the start time for the automated reply period.
 */
startTime: Date;

/**
 * Gets the automatic reply message intended for an email message from an unknown external sender.
 */
unknownExternalReply: Windows$ApplicationModel$Email$EmailMailboxAutoReply
}


/**
 * Represents the capabilities associated with an email mailbox.
 */
declare class Windows$ApplicationModel$Email$EmailMailboxCapabilities  {

/**
 * Gets a Boolean value indicating if folders can be created in the mailbox.
 */
canCreateFolder: boolean;

/**
 * Gets a Boolean value indicating if folders can be deleted from the mailbox.
 */
canDeleteFolder: boolean;

/**
 * Gets a Boolean value indicating if folders in the mailbox can be emptied.
 */
canEmptyFolder: boolean;
canForwardMeetings: any;
canGetAndSetExternalAutoReplies: any;
canGetAndSetInternalAutoReplies: any;

/**
 * Gets a Boolean value indicating if folders in the mailbox can be moved.
 */
canMoveFolder: boolean;
canProposeNewTimeForMeetings: any;

/**
 * Gets a Boolean value that indicates whether the email mailbox is capable of resolving recipients.
 */
canResolveRecipients: boolean;
canServerSearchFolders: any;
canServerSearchMailbox: any;
canSmartSend: any;
canUpdateMeetingResponses: any;

/**
 * Gets a Boolean value that indicates whether the email mailbox is capable of validating certificates.
 */
canValidateCertificates: boolean
}


/**
 * The functionality described in this topic is not available to all Windows and Windows Phone apps. For your code to call these APIs, Microsoft must approve your use of them and provision your developer account. Otherwise the calls will fail at runtime.
 */
declare class Windows$ApplicationModel$Email$EmailMailboxChange  {

/**
 * Gets the type of change that was made to the mailbox. This includes whether it was a folder or message that was changed and whether the item was created, deleted, or modified, or if change tracking was lost for this change.
 */
changeType: $Values<typeof Windows$ApplicationModel$Email$EmailMailboxChangeType>;

/**
 * Gets the folder to which the change applies.
 */
folder: Windows$ApplicationModel$Email$EmailFolder;

/**
 * Gets the flags that indicate what actions have been affected on the mailbox.
 */
mailboxActions: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Email$EmailMailboxAction>;

/**
 * Gets the message to which the change applies.
 */
message: Windows$ApplicationModel$Email$EmailMessage
}


/**
 * The functionality described in this topic is not available to all Windows and Windows Phone apps. For your code to call these APIs, Microsoft must approve your use of them and provision your developer account. Otherwise the calls will fail at runtime.
 */
declare class Windows$ApplicationModel$Email$EmailMailboxChangeReader  {

/**
 * Accepts all changes.
 */
acceptChanges(): void;

/**
 * Accepts all changes through the current change.
 * @param lastChangeToAcknowledge The current change.
 */
acceptChangesThrough(
lastChangeToAcknowledge: Windows$ApplicationModel$Email$EmailMailboxChange): void;

/**
 * Reads a collection of changes.
 * @return A batch of changes.
 */
readBatchAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>
}


/**
 * The functionality described in this topic is not available to all Windows and Windows Phone apps. For your code to call these APIs, Microsoft must approve your use of them and provision your developer account. Otherwise the calls will fail at runtime.
 */
declare class Windows$ApplicationModel$Email$EmailMailboxChangeTracker  {

/**
 * Enables change tracking on a mailbox.
 */
enable(): void;

/**
 * Gets a reader that will read a batch of changes.
 * @return A reader that will read a batch of changes.
 */
getChangeReader(): Windows$ApplicationModel$Email$EmailMailboxChangeReader;

/**
 * Gets a Boolean value indicating whether change tracking is active.
 */
isTracking: boolean;

/**
 * Moves the change tracking cursor to now.
 */
reset(): void
}


/**
 * Defines the type of change made to the mailbox item.
 */

declare  var Windows$ApplicationModel$Email$EmailMailboxChangeType: {|
  +messageCreated: 0,// 0
+messageModified: 1,// 1
+messageDeleted: 2,// 2
+folderCreated: 3,// 3
+folderModified: 4,// 4
+folderDeleted: 5,// 5
+changeTrackingLost: 6,// 6

|};



/**
 * Represents a deferred process that will halt a thread until the deferral is complete.
 */
declare class Windows$ApplicationModel$Email$EmailMailboxChangedDeferral  {

/**
 * Indicates to waiting processes that the deferral is complete.
 */
complete(): void
}


/**
 * Represents the deferral process.
 */
declare class Windows$ApplicationModel$Email$EmailMailboxChangedEventArgs  {

/**
 * Gets the deferral object.
 * @return The deferral object.
 */
getDeferral(): Windows$ApplicationModel$Email$EmailMailboxChangedDeferral
}


/**
 * Represents the result of a TryCreateFolderAsync operation.
 */
declare class Windows$ApplicationModel$Email$EmailMailboxCreateFolderResult  {

/**
 * Get the newly created folder after a TryCreateFolderAsync operation.
 */
folder: Windows$ApplicationModel$Email$EmailFolder;

/**
 * Gets the status of a TryCreateFolderAsync operation.
 */
status: $Values<typeof Windows$ApplicationModel$Email$EmailMailboxCreateFolderStatus>
}


/**
 * Indicates the result of a call to TryCreateFolderAsync .
 */

declare  var Windows$ApplicationModel$Email$EmailMailboxCreateFolderStatus: {|
  +success: 0,// 0
+networkError: 1,// 1
+permissionsError: 2,// 2
+serverError: 3,// 3
+unknownFailure: 4,// 4
+nameCollision: 5,// 5
+serverRejected: 6,// 6

|};



/**
 * Indicates the result of a call to TryDeleteFolderAsync .
 */

declare  var Windows$ApplicationModel$Email$EmailMailboxDeleteFolderStatus: {|
  +success: 0,// 0
+networkError: 1,// 1
+permissionsError: 2,// 2
+serverError: 3,// 3
+unknownFailure: 4,// 4
+couldNotDeleteEverything: 5,// 5

|};



/**
 * Indicates the result of a call to TryEmptyFolderAsync .
 */

declare  var Windows$ApplicationModel$Email$EmailMailboxEmptyFolderStatus: {|
  +success: 0,// 0
+networkError: 1,// 1
+permissionsError: 2,// 2
+serverError: 3,// 3
+unknownFailure: 4,// 4
+couldNotDeleteEverything: 5,// 5

|};



/**
 * Defines whether an application can read from a mailbox.
 */

declare  var Windows$ApplicationModel$Email$EmailMailboxOtherAppReadAccess: {|
  +systemOnly: 0,// 0
+full: 1,// 1

|};



/**
 * Defines whether an application can write to a mailbox.
 */

declare  var Windows$ApplicationModel$Email$EmailMailboxOtherAppWriteAccess: {|
  +none: 0,// 0
+limited: 1,// 1

|};



/**
 * Represents the encryption and signing policies associates with an email mailbox.
 */
declare class Windows$ApplicationModel$Email$EmailMailboxPolicies  {

/**
 * Gets a Boolean value that indicates whether software certificates are allowed.
 */
allowSmimeSoftCertificates: boolean;

/**
 * Gets the allowable SMIME encryption algorithms for the purpose of negotiating with an app.
 */
allowedSmimeEncryptionAlgorithmNegotiation: $Values<typeof Windows$ApplicationModel$Email$EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation>;

/**
 * Gets a Boolean value that indicates whether the sync provider that represents the email mailbox only accepts encrypted messages.
 */
mustEncryptSmimeMessages: boolean;

/**
 * Gets a Boolean value that indicates whether the sync provider that represents the email mailbox only accepts signed messages.
 */
mustSignSmimeMessages: boolean;

/**
 * Gets the required SMIME encryption algorithm.
 */
requiredSmimeEncryptionAlgorithm: $Values<typeof Windows$ApplicationModel$Email$EmailMailboxSmimeEncryptionAlgorithm>;

/**
 * Gets the required SMIME signing algorithm.
 */
requiredSmimeSigningAlgorithm: $Values<typeof Windows$ApplicationModel$Email$EmailMailboxSmimeSigningAlgorithm>
}


/**
 * Defines the encryption algorithm used for an email.
 */

declare  var Windows$ApplicationModel$Email$EmailMailboxSmimeEncryptionAlgorithm: {|
  +any: 0,// 0
+tripleDes: 1,// 1
+des: 2,// 2
+rc2128Bit: 3,// 3
+rc264Bit: 4,// 4
+rc240Bit: 5,// 5

|};



/**
 * Defines the algorithm used to sign an email.
 */

declare  var Windows$ApplicationModel$Email$EmailMailboxSmimeSigningAlgorithm: {|
  +any: 0,// 0
+sha1: 1,// 1
+md5: 2,// 2

|};



/**
 * The functionality described in this topic is not available to all Windows and Windows Phone apps. For your code to call these APIs, Microsoft must approve your use of them and provision your developer account. Otherwise the calls will fail at runtime.
 */
declare class Windows$ApplicationModel$Email$EmailMailboxSyncManager  {

/**
 * Gets the last time the mailbox attempted to sync.
 */
lastAttemptedSyncTime: Date;

/**
 * Gets the last time the mailbox was successfully synced.
 */
lastSuccessfulSyncTime: Date;

/**
 * Fires whenever a mailbox's sync status changes.
 */
onsyncstatuschanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Email$EmailMailboxSyncManager, any>;
addEventListener(
type: "syncstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Email$EmailMailboxSyncManager, any>): void;
removeEventListener(
type: "syncstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Email$EmailMailboxSyncManager, any>): void;

/**
 * Gets the sync state of the mailbox.
 */
status: $Values<typeof Windows$ApplicationModel$Email$EmailMailboxSyncStatus>;

/**
 * Initiates a sync of this mailbox.
 * @return A Boolean value indicating success.
 */
syncAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Defines the sync status of the mailbox.
 */

declare  var Windows$ApplicationModel$Email$EmailMailboxSyncStatus: {|
  +idle: 0,// 0
+syncing: 1,// 1
+upToDate: 2,// 2
+authenticationError: 3,// 3
+policyError: 4,// 4
+unknownError: 5,// 5
+manualAccountRemovalRequired: 6,// 6

|};



/**
 * Allows an application to launch the email application with a new message displayed. Use this to allow users to send email from your application.
 */
declare class Windows$ApplicationModel$Email$EmailManager  {

/**
 * Gets an email store that is within the specified scope.
 * @param accessType The enumerator of scope.
 * @return The requested email store.
 */
static requestStoreAsync(
accessType: $Values<typeof Windows$ApplicationModel$Email$EmailStoreAccessType>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailStore>;

/**
 * Launches the email application with a new message displayed.
 * @param message The email message that is displayed when the email application is launched.
 * @return An asynchronous action.
 */
static showComposeNewEmailAsync(
message: Windows$ApplicationModel$Email$EmailMessage): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Represents the information associated with a meeting.
 */
declare class Windows$ApplicationModel$Email$EmailMeetingInfo  {

/**
 * Initializes a new instance of the EmailMeetingInfo class.
 */
constructor(): this;

/**
 * Gets or sets a Boolean value indicating whether the proposal of a new time is allowed.
 */
allowNewTimeProposal: boolean;

/**
 * Gets or sets the start time for a meeting.
 */
appointmentOriginalStartTime: Date;

/**
 * Gets or sets the server identifier for the appointment associated with an email message.
 */
appointmentRoamingId: string;

/**
 * Gets or sets the duration of the meeting.
 */
duration: number;

/**
 * Gets or sets a Boolean value indicating whether the meeting is an all day event.
 */
isAllDay: boolean;

/**
 * Gets a Boolean value indicating if the meeting is reported as out of date by the server.
 */
isReportedOutOfDateByServer: boolean;

/**
 * Gets or sets a Boolean value indicating whether a response to the meeting request is required.
 */
isResponseRequested: boolean;

/**
 * Gets or sets the meeting location.
 */
location: string;

/**
 * Gets or sets the proposed duration for the proposed meeting change.
 */
proposedDuration: number;

/**
 * Gets or sets the proposed start time for the proposed meeting change.
 */
proposedStartTime: Date;

/**
 * Gets or sets the recurrence parameters.
 */
recurrence: Windows$ApplicationModel$Appointments$AppointmentRecurrence;

/**
 * Gets or sets the first instance of the recurrence pattern.
 */
recurrenceStartTime: Date;

/**
 * Gets or sets the change number on the server that identifies the meeting email change number.
 */
remoteChangeNumber: number;

/**
 * Gets or sets the start time for the meeting.
 */
startTime: Date
}


/**
 * Defines the type of response to a meeting request.
 */

declare  var Windows$ApplicationModel$Email$EmailMeetingResponseType: {|
  +accept: 0,// 0
+decline: 1,// 1
+tentative: 2,// 2

|};



/**
 * Represents an email message.
 */
declare class Windows$ApplicationModel$Email$EmailMessage  {

/**
 * Creates an instance of the EmailMessage class.
 */
constructor(): this;

/**
 * Gets or sets a Boolean value indicating whether images may be embedded in the html encoded email message.
 */
allowInternetImages: boolean;

/**
 * Gets the attachments of the email message.
 */
attachments: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Email$EmailAttachment>;

/**
 * Gets the recipients BCC'd to the email message.
 */
bcc: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Email$EmailRecipient>;

/**
 * Gets or sets the body of the email message.
 */
body: string;

/**
 * Gets the recipients CC'd to the email message.
 */
cc: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Email$EmailRecipient>;

/**
 * Gets the current change number which is incremented for each change made to an email message.
 */
changeNumber: number;

/**
 * Gets the identifier for a conversation.
 */
conversationId: string;

/**
 * Gets or sets the download status of an email message.
 */
downloadState: $Values<typeof Windows$ApplicationModel$Email$EmailMessageDownloadState>;

/**
 * Gets or sets the estimated size, in bytes, of an email message download.
 */
estimatedDownloadSizeInBytes: number;

/**
 * Represents the flag status of an email message.
 */
flagState: $Values<typeof Windows$ApplicationModel$Email$EmailFlagState>;

/**
 * Gets the identifier of a folder in the inbox.
 */
folderId: string;

/**
 * Gets the requested email stream such as plain text or HTML.
 * @param type The kind of message body; plain text or HTML.
 * @return The selected body stream.
 */
getBodyStream(
type: $Values<typeof Windows$ApplicationModel$Email$EmailMessageBodyKind>): Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets a Boolean value indicating whether this email message contains partial bodies.
 */
hasPartialBodies: boolean;

/**
 * Gets the identifier of an email message.
 */
id: string;

/**
 * Gets the importance of an email message.
 */
importance: $Values<typeof Windows$ApplicationModel$Email$EmailImportance>;

/**
 * Gets the identifier for the email message to which this message is a response.
 */
inResponseToMessageId: string;

/**
 * Gets or sets the Information Rights Management (IRM) information for this email message.
 */
irmInfo: Windows$ApplicationModel$Email$EmailIrmInfo;

/**
 * Gets a Boolean value indicating whether this message is a draft.
 */
isDraftMessage: boolean;

/**
 * Gets a Boolean value indicating whether the email message has been read.
 */
isRead: boolean;

/**
 * Gets a Boolean value indicating whether the email message has been seen.
 */
isSeen: boolean;

/**
 * Gets a Boolean value indicating whether the email message is a temporary server search message.
 */
isServerSearchMessage: boolean;

/**
 * Gets a Boolean value indicating whether the response email message is allowed to attempt a smart send, only sending that portion of the email message that has changed.
 */
isSmartSendable: boolean;

/**
 * Gets the last kind of response sent in reference to this email message.
 */
lastResponseKind: $Values<typeof Windows$ApplicationModel$Email$EmailMessageResponseKind>;

/**
 * Gets the identifier of the mailbox.
 */
mailboxId: string;

/**
 * Gets the information associated with this meeting.
 */
meetingInfo: Windows$ApplicationModel$Email$EmailMeetingInfo;

/**
 * Gets or sets a string that indicates the class of the message.
 */
messageClass: string;

/**
 * Gets the subject line of an email message stripped of additional prefixes such as fwd: and re:
 */
normalizedSubject: string;

/**
 * Gets or sets the integer that identifies the original flavor of the character set used so that when the email message is condensed from wide character format (16-bit) to ASCII or other 8-bit encoding, in cases of later encoding questions, this integer can be used to recreate the original character set.
 */
originalCodePage: number;

/**
 * Gets or sets the short preview string that represents the longer email message in the list view of emails.
 */
preview: string;

/**
 * Gets or sets the identifier that can be used by a service provider to access the email message on the client machine.
 */
remoteId: string;

/**
 * Gets or sets the mailbox from which the email message was sent.
 */
sender: Windows$ApplicationModel$Email$EmailRecipient;

/**
 * Gets or sets the time an email was sent.
 */
sentTime: Date;

/**
 * Sets the value of the specified body stream in an email message.
 * @param type Indicates which body stream, plain text or HTML.
 * @param stream The message for the specified body stream.
 */
setBodyStream(
type: $Values<typeof Windows$ApplicationModel$Email$EmailMessageBodyKind>,
stream: Windows$Storage$Streams$IRandomAccessStreamReference): void;

/**
 * Gets or sets the S/MIME data associated with an email message. For more information, see the Certificate class.
 */
smimeData: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets or sets the type of S/MIME encryption/signature for the email message.
 */
smimeKind: $Values<typeof Windows$ApplicationModel$Email$EmailMessageSmimeKind>;

/**
 * Gets or sets the subject of the email message.
 */
subject: string;

/**
 * Gets the direct recipients of the email message.
 */
to: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Email$EmailRecipient>
}


/**
 * Represents a collection of email messages.
 */
declare class Windows$ApplicationModel$Email$EmailMessageBatch  {

/**
 * Gets a batch of email messages.
 */
messages: Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Email$EmailMessage>;

/**
 * Gets the status of the email batch read.
 */
status: $Values<typeof Windows$ApplicationModel$Email$EmailBatchStatus>
}


/**
 * Defines the format of an email message.
 */

declare  var Windows$ApplicationModel$Email$EmailMessageBodyKind: {|
  +html: 0,// 0
+plainText: 1,// 1

|};



/**
 * Defines the download status of an email message.
 */

declare  var Windows$ApplicationModel$Email$EmailMessageDownloadState: {|
  +partiallyDownloaded: 0,// 0
+downloading: 1,// 1
+downloaded: 2,// 2
+failed: 3,// 3

|};



/**
 * Gets a batch of email messages.
 */
declare class Windows$ApplicationModel$Email$EmailMessageReader  {

/**
 * Reads a collection of email messages.
 * @return A batch of email messages.
 */
readBatchAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailMessageBatch>
}


/**
 * Defines the type of response to an email message.
 */

declare  var Windows$ApplicationModel$Email$EmailMessageResponseKind: {|
  +none: 0,// 0
+reply: 1,// 1
+replyAll: 2,// 2
+forward: 3,// 3

|};



/**
 * Defines the S/MIME type of an email message.
 */

declare  var Windows$ApplicationModel$Email$EmailMessageSmimeKind: {|
  +none: 0,// 0
+clearSigned: 1,// 1
+opaqueSigned: 2,// 2
+encrypted: 3,// 3

|};



/**
 * Defines the type of email query.
 */

declare  var Windows$ApplicationModel$Email$EmailQueryKind: {|
  +all: 0,// 0
+important: 1,// 1
+flagged: 2,// 2
+unread: 3,// 3
+read: 4,// 4
+unseen: 5,// 5

|};



/**
 * Represents the options selected for an email mailbox query.
 */
declare class Windows$ApplicationModel$Email$EmailQueryOptions  {

/**
 * Instantiates a new instance of the EmailQueryOptions class.
 */
constructor(): this;

/**
 * Instantiates a new instance of the EmailQueryOptions class.
 * @param text The text for which to search.
 * @param fields The fields against which to search.
 */
constructor(text: string, fields: $Values<typeof Windows$ApplicationModel$Email$EmailQuerySearchFields>): this;

/**
 * Instantiates a new instance of the EmailQueryOptions class.
 * @param text The text for which to search.
 */
constructor(text: string): this;

/**
 * Gets the identifiers for the folders in which to search.
 */
folderIds: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets or sets the kind of emails for which to query.
 */
kind: $Values<typeof Windows$ApplicationModel$Email$EmailQueryKind>;

/**
 * Gets or sets the direction of the sort for the query results.
 */
sortDirection: $Values<typeof Windows$ApplicationModel$Email$EmailQuerySortDirection>;

/**
 * Gets or sets a Boolean value indicating whether the query results should be sorted.
 */
sortProperty: $Values<typeof Windows$ApplicationModel$Email$EmailQuerySortProperty>;

/**
 * Gets the text to search for.
 */
textSearch: Windows$ApplicationModel$Email$EmailQueryTextSearch
}


/**
 * Defines the field(s) by which to search a collection of email messages. Use the OR operator to combine these values together into a single bit field.
 */

declare  var Windows$ApplicationModel$Email$EmailQuerySearchFields: {|
  +none: 0,// 0
+subject: 1,// 1
+sender: 2,// 2
+preview: 3,// 3
+recipients: 4,// 4
+all: 5,// 5

|};



/**
 * Defines the scope of a query.
 */

declare  var Windows$ApplicationModel$Email$EmailQuerySearchScope: {|
  +local: 0,// 0
+server: 1,// 1

|};



/**
 * Defines the order in which to sort query results.
 */

declare  var Windows$ApplicationModel$Email$EmailQuerySortDirection: {|
  +descending: 0,// 0
+ascending: 1,// 1

|};



/**
 * The property by which to sort. Currently limited to date.
 */

declare  var Windows$ApplicationModel$Email$EmailQuerySortProperty: {|
  +date: 0,// 0

|};



/**
 * Represents a text search query in an email mailbox.
 */
declare class Windows$ApplicationModel$Email$EmailQueryTextSearch  {

/**
 * Gets or sets the fields for an email text search query.
 */
fields: $Values<typeof Windows$ApplicationModel$Email$EmailQuerySearchFields>;

/**
 * Gets or sets the scope for an email text search query.
 */
searchScope: $Values<typeof Windows$ApplicationModel$Email$EmailQuerySearchScope>;

/**
 * Gets or sets the text string for an email text search query.
 */
text: string
}


/**
 * Represents an email recipient.
 */
declare class Windows$ApplicationModel$Email$EmailRecipient  {

/**
 * Initializes an instance of the EmailRecipient class.
 */
constructor(): this;

/**
 * Initializes an instance of the EmailRecipient class.
 * @param address The address of the recipient.
 * @param name The name of the recipient.
 */
constructor(address: string, name: string): this;

/**
 * Initializes an instance of the EmailRecipient class.
 * @param address The address of the recipient.
 */
constructor(address: string): this;

/**
 * Gets or sets the address of the email recipient.
 */
address: string;

/**
 * Gets or sets the name of the email recipient.
 */
name: string
}


/**
 * Represents the result of an attempt to resolve an email recipient.
 */
declare class Windows$ApplicationModel$Email$EmailRecipientResolutionResult  {

/**
 * Gets the public key for an email recipient.
 */
publicKeys: Windows$Foundation$Collections$IVectorView<Windows$Security$Cryptography$Certificates$Certificate>;

/**
 * Gets the state of an attempt to resolve an email recipient.
 */
status: $Values<typeof Windows$ApplicationModel$Email$EmailRecipientResolutionStatus>
}


/**
 * Describes the state of an attempt to resolve an email recipient.
 */

declare  var Windows$ApplicationModel$Email$EmailRecipientResolutionStatus: {|
  +success: 0,// 0
+recipientNotFound: 1,// 1
+ambiguousRecipient: 2,// 2
+noCertificate: 3,// 3
+certificateRequestLimitReached: 4,// 4
+cannotResolveDistributionList: 5,// 5
+serverError: 6,// 6
+unknownFailure: 7,// 7

|};



/**
 * Defines the email special folders.
 */

declare  var Windows$ApplicationModel$Email$EmailSpecialFolderKind: {|
  +none: 0,// 0
+root: 1,// 1
+inbox: 2,// 2
+outbox: 3,// 3
+drafts: 4,// 4
+deletedItems: 5,// 5
+sent: 6,// 6

|};



/**
 * The functionality described in this topic is not available to all Windows and Windows Phone apps. For your code to call these APIs, Microsoft must approve your use of them and provision your developer account. Otherwise the calls will fail at runtime.
 */
declare class Windows$ApplicationModel$Email$EmailStore  {

/**
 * Allows an app to create an email account from an account name and an email address.
 * @param accountName The name of the account.
 * @param accountAddress The email address associated with the account.
 * @return An email mailbox.
 */
createMailboxAsync(
accountName: string,
accountAddress: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailMailbox>;

/**
 * Allows an app to create an email account from an account name, an email address, and the user data account in which the mailbox will reside.
 * @param accountName The name of the account.
 * @param accountAddress The email address associated with the account.
 * @param userDataAccountId The user data account identifier associated with this user.
 * @return An email mailbox.
 */
createMailboxAsync(
accountName: string,
accountAddress: string,
userDataAccountId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailMailbox>;

/**
 * Gets all mailboxes within the current scope.
 * @return A collection of mailboxes.
 */
findMailboxesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets an email conversation from the provided identifier.
 * @param id The identifier of the conversation.
 * @return An email conversation.
 */
getConversationAsync(
id: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailConversation>;

/**
 * Gets a batch of email conversations.
 * @return A batch of email conversations.
 */
getConversationReader(): Windows$ApplicationModel$Email$EmailConversationReader;

/**
 * Gets a batch of email conversations using the specified email query options.
 * @param options The email query options.
 * @return A batch of email conversations.
 */
getConversationReader(
options: Windows$ApplicationModel$Email$EmailQueryOptions): Windows$ApplicationModel$Email$EmailConversationReader;

/**
 * Gets an email folder from an identifier.
 * @param id The identifier for the email folder.
 * @return The folder described by the identifier.
 */
getFolderAsync(
id: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailFolder>;

/**
 * Gets a mailbox from an identifier.
 * @param id The identifier for the mailbox.
 * @return The mailbox described by the identifier.
 */
getMailboxAsync(
id: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailMailbox>;

/**
 * Gets the specified email message.
 * @param id The identifier for the email message.
 * @return The specified email message.
 */
getMessageAsync(
id: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Email$EmailMessage>;

/**
 * Gets a message reader.
 * @return The email message reader.
 */
getMessageReader(): Windows$ApplicationModel$Email$EmailMessageReader;

/**
 * Gets a message reader using the specified query options.
 * @param options Specified query options.
 * @return An email message reader.
 */
getMessageReader(
options: Windows$ApplicationModel$Email$EmailQueryOptions): Windows$ApplicationModel$Email$EmailMessageReader
}


/**
 * Defines the scope for store access.
 */

declare  var Windows$ApplicationModel$Email$EmailStoreAccessType: {|
  +appMailboxesReadWrite: 0,// 0
+allMailboxesLimitedReadWrite: 1,// 1

|};



/**
 * The functionality described in this topic is not available to all Windows and Windows Phone apps. For your code to call these APIs, Microsoft must approve your use of them and provision your developer account. Otherwise the calls will fail at runtime.
 */
declare class Windows$ApplicationModel$Email$EmailStoreNotificationTriggerDetails  {}


      declare var npm$namespace$Windows$ApplicationModel$ExtendedExecution: {
        
        
        ExtendedExecutionReason: typeof Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionReason,
ExtendedExecutionResult: typeof Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionResult,
ExtendedExecutionRevokedReason: typeof Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionRevokedReason,
        ExtendedExecutionRevokedEventArgs: typeof Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionRevokedEventArgs,
ExtendedExecutionSession: typeof Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionSession,
        Foreground: typeof npm$namespace$Windows$ApplicationModel$ExtendedExecution$Foreground,
      }

/**
 * Describes the reason for the background execution request.
 */

declare  var Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionReason: {|
  +unspecified: 0,// 0
+locationTracking: 1,// 1
+savingData: 2,// 2

|};



/**
 * Specifies the possible background execution request result values.
 */

declare  var Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionResult: {|
  +allowed: 0,// 0
+denied: 1,// 1

|};



/**
 * Represents the object that is passed as a parameter to the event handler that is invoked when the system revokes background execution.
 */
declare class Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionRevokedEventArgs  {

/**
 * Gets the reason background execution was revoked.
 */
reason: $Values<typeof Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionRevokedReason>
}


/**
 * Describes the reason background execution was revoked.
 */

declare  var Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionRevokedReason: {|
  +resumed: 0,// 0
+systemPolicy: 1,// 1

|};



/**
 * Supports managing a request for background execution.
 */
declare class Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionSession  {

/**
 * Creates an ExtendedExecutionSession object.
 */
constructor(): this;

/**
 * Closes the session and removes the application's capability to run in the background.
 */
close(): void;

/**
 * Gets or sets a string to display in the shell.
 */
description: string;

/**
 * The Revoked event occurs when the system revokes background execution.
 */
onrevoked: Windows$Foundation$TypedEventHandler<any, Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionRevokedEventArgs>;
addEventListener(
type: "revoked",
listener: Windows$Foundation$TypedEventHandler<any, Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionRevokedEventArgs>): void;
removeEventListener(
type: "revoked",
listener: Windows$Foundation$TypedEventHandler<any, Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionRevokedEventArgs>): void;

/**
 * Gets or sets a value to show progress in the shell.
 */
percentProgress: number;

/**
 * Gets or sets the reason for the for the background execution request.
 */
reason: $Values<typeof Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionReason>;

/**
 * Requests background execution.
 * @return The result of the request.
 */
requestExtensionAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$ExtendedExecution$ExtendedExecutionResult>>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


      declare var npm$namespace$Windows$ApplicationModel$ExtendedExecution$Foreground: {
        
        
        ExtendedExecutionForegroundReason: typeof Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundReason,
ExtendedExecutionForegroundResult: typeof Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundResult,
ExtendedExecutionForegroundRevokedReason: typeof Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundRevokedReason,
        ExtendedExecutionForegroundRevokedEventArgs: typeof Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundRevokedEventArgs,
ExtendedExecutionForegroundSession: typeof Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundSession,
        
      }

/**
 * Describes the reason for the extended execution request.
 */

declare  var Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundReason: {|
  +unspecified: 0,// 0
+savingData: 1,// 1
+backgroundAudio: 2,// 2
+unconstrained: 3,// 3

|};



/**
 * Specifies the possible extended execution request result values.
 */

declare  var Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundResult: {|
  +allowed: 0,// 0
+denied: 1,// 1

|};



/**
 * Passed to the event handler that is invoked when the system revokes extended execution.
 */
declare class Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundRevokedEventArgs  {

/**
 * Gets the reason extended execution was revoked.
 */
reason: $Values<typeof Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundRevokedReason>
}


/**
 * Describes the reason extended execution was revoked.
 */

declare  var Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundRevokedReason: {|
  +resumed: 0,// 0
+systemPolicy: 1,// 1

|};



/**
 * Supports managing a request for extended foreground execution.
 */
declare class Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundSession  {

/**
 * Creates an ExtendedExecutionForegroundSession object
 */
constructor(): this;

/**
 * Closes the session and removes the application's extended execution capability.
 */
close(): void;

/**
 * Gets or sets a string to display in the shell.
 */
description: string;

/**
 * This event occurs when the system revokes extended execution.
 */
onrevoked: Windows$Foundation$TypedEventHandler<any, Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundRevokedEventArgs>;
addEventListener(
type: "revoked",
listener: Windows$Foundation$TypedEventHandler<any, Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundRevokedEventArgs>): void;
removeEventListener(
type: "revoked",
listener: Windows$Foundation$TypedEventHandler<any, Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundRevokedEventArgs>): void;

/**
 * Gets or sets the reason for the extended execution request.
 */
reason: $Values<typeof Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundReason>;

/**
 * Requests extended execution
 * @return The result of the request.
 */
requestExtensionAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$ExtendedExecution$Foreground$ExtendedExecutionForegroundResult>>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


      declare var npm$namespace$Windows$ApplicationModel$LockScreen: {
        
        
        
        LockApplicationHost: typeof Windows$ApplicationModel$LockScreen$LockApplicationHost,
LockScreenBadge: typeof Windows$ApplicationModel$LockScreen$LockScreenBadge,
LockScreenInfo: typeof Windows$ApplicationModel$LockScreen$LockScreenInfo,
LockScreenUnlockingDeferral: typeof Windows$ApplicationModel$LockScreen$LockScreenUnlockingDeferral,
LockScreenUnlockingEventArgs: typeof Windows$ApplicationModel$LockScreen$LockScreenUnlockingEventArgs,
        
      }

/**
 * Allows the lock screen app to request that the device unlocks, and allows the app to register to be notified when the device begins to unlock.
 */
declare class Windows$ApplicationModel$LockScreen$LockApplicationHost  {

/**
 * Gets a LockApplicationHost object.
 * @return A LockApplicationHost object.
 */
static getForCurrentView(): Windows$ApplicationModel$LockScreen$LockApplicationHost;

/**
 * Indicates the device is unlocking.
 */
onunlocking: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$LockScreen$LockApplicationHost, Windows$ApplicationModel$LockScreen$LockScreenUnlockingEventArgs>;
addEventListener(
type: "unlocking",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$LockScreen$LockApplicationHost, Windows$ApplicationModel$LockScreen$LockScreenUnlockingEventArgs>): void;
removeEventListener(
type: "unlocking",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$LockScreen$LockApplicationHost, Windows$ApplicationModel$LockScreen$LockScreenUnlockingEventArgs>): void;

/**
 * Requests that the device unlocks.
 */
requestUnlock(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a lock screen badge for an app.
 */
declare class Windows$ApplicationModel$LockScreen$LockScreenBadge  {

/**
 * Gets the name.
 */
automationName: string;

/**
 * Gets the glyph to display.
 */
glyph: Windows$Storage$Streams$IRandomAccessStream;

/**
 * Launches the app corresponding to the badge.
 */
launchApp(): void;

/**
 * Gets the logo to display with the badge.
 */
logo: Windows$Storage$Streams$IRandomAccessStream;

/**
 * Gets the number to display with the badge.
 */
number: number
}


/**
 * Provides access to the same data that the default lock screen has access to, such as wallpaper, badges, and so on.
 */
declare class Windows$ApplicationModel$LockScreen$LockScreenInfo  {

/**
 * Gets the alarm icon to display.
 */
alarmIcon: Windows$Storage$Streams$IRandomAccessStream;

/**
 * Gets the badges to display.
 */
badges: Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$LockScreen$LockScreenBadge>;

/**
 * Gets the detail text to display.
 */
detailText: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the image to display on the lock screen.
 */
lockScreenImage: Windows$Storage$Streams$IRandomAccessStream;

/**
 * Indicates the alarm icon has changed.
 */
onalarmiconchanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$LockScreen$LockScreenInfo, any>;
addEventListener(
type: "alarmiconchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$LockScreen$LockScreenInfo, any>): void;
removeEventListener(
type: "alarmiconchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$LockScreen$LockScreenInfo, any>): void;

/**
 * Indicates the badges have changed.
 */
onbadgeschanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$LockScreen$LockScreenInfo, any>;
addEventListener(
type: "badgeschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$LockScreen$LockScreenInfo, any>): void;
removeEventListener(
type: "badgeschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$LockScreen$LockScreenInfo, any>): void;

/**
 * Indicates the detail text has changed.
 */
ondetailtextchanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$LockScreen$LockScreenInfo, any>;
addEventListener(
type: "detailtextchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$LockScreen$LockScreenInfo, any>): void;
removeEventListener(
type: "detailtextchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$LockScreen$LockScreenInfo, any>): void;

/**
 * Indicates the lock screen image has changed.
 */
onlockscreenimagechanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$LockScreen$LockScreenInfo, any>;
addEventListener(
type: "lockscreenimagechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$LockScreen$LockScreenInfo, any>): void;
removeEventListener(
type: "lockscreenimagechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$LockScreen$LockScreenInfo, any>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents an unlock deferral.
 */
declare class Windows$ApplicationModel$LockScreen$LockScreenUnlockingDeferral  {

/**
 * Notifies the system that your deferral is complete. If your deferral takes too long to complete, your lock screen app will be terminated by the system and potentially removed as the users default lock app.
 */
complete(): void
}


/**
 * Represents the lock screen unlocking events.
 */
declare class Windows$ApplicationModel$LockScreen$LockScreenUnlockingEventArgs  {

/**
 * Gets the deadline by which the lock screen app must unlock the device. If your unlocking deferral takes too long, your lock screen app will be terminated by the system and potentially removed as the users default lock app.
 */
deadline: Date;

/**
 * Gets a LockScreenUnlockingDeferral , which defers the unlocking of the device.
 * @return An unlock deferral.
 */
getDeferral(): Windows$ApplicationModel$LockScreen$LockScreenUnlockingDeferral
}


/**
 * Provides information about a package.
 */
declare class Windows$ApplicationModel$Package  {

/**
 * Gets the package for the current app.
 */
static current: Windows$ApplicationModel$Package;

/**
 * Gets the packages on which the current package depends.
 */
dependencies: Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Package>;

/**
 * Gets the description of the package.
 */
description: string;

/**
 * Gets the display name of the package.
 */
displayName: string;
getAppListEntriesAsync: any;

/**
 * Windows Phone only. Returns a token that can be used to retrieve the thumbnail image associated with this application package.
 * @return A token that can be used to retrieve the thumbnail image associated with this application package.
 */
getThumbnailToken(): string;

/**
 * Gets the package identity of the current package.
 */
id: Windows$ApplicationModel$PackageId;

/**
 * Windows Phone only. Gets the date the application package was installed on the user's phone.
 */
installDate: Date;

/**
 * Gets the date on which the application package was installed or last updated.
 */
installedDate: Date;

/**
 * Gets the location of the installed package.
 */
installedLocation: Windows$Storage$StorageFolder;

/**
 * Indicates whether the package is a bundle package.
 */
isBundle: boolean;

/**
 * Indicates whether the package is installed in development mode.
 */
isDevelopmentMode: boolean;

/**
 * Indicates whether other packages can declare a dependency on this package.
 */
isFramework: boolean;

/**
 * Indicates whether the package is a resource package.
 */
isResourcePackage: boolean;

/**
 * Windows Phone only. Launches the specified application.
 * @param parameters The navigation URI that specifies the page to launch and optional parameters. Use an empty string to specify the default page for the app.
 */
launch(parameters: string): void;

/**
 * Gets the logo of the package.
 */
logo: Windows$Foundation$Uri;

/**
 * Gets the publisher display name of the package.
 */
publisherDisplayName: string;
status: any
}


/**
 * Provides package identification info, such as name, version, and publisher.
 */
declare class Windows$ApplicationModel$PackageId  {

/**
 * Gets the processor architecture for which the package was created.
 */
architecture: $Values<typeof Windows$System$ProcessorArchitecture>;

/**
 * Windows Phone only. Gets the value of the Author attribute for the specified application package.
 */
author: string;

/**
 * Gets the family name of the package.
 */
familyName: string;

/**
 * Gets the full name of the package.
 */
fullName: string;

/**
 * Gets the name of the package.
 */
name: string;

/**
 * Windows Phone only. Gets the value of the ProductID attribute associated with this application package.
 */
productId: string;

/**
 * Gets the publisher of the package.
 */
publisher: string;

/**
 * Gets the publisher ID of the package.
 */
publisherId: string;

/**
 * Gets the resource ID of the package.
 */
resourceId: string;

/**
 * Gets the package version info.
 */
version: Windows$ApplicationModel$PackageVersion
}


/**
 * Provides the status of the package.
 */
declare class Windows$ApplicationModel$PackageStatus  {

/**
 * Indicates whether the data for the package is offline.
 */
dataOffline: boolean;

/**
 * Indicates whether this package depends on a package that can't be used.
 */
dependencyIssue: boolean;

/**
 * Indicates whether the package is being serviced.
 */
deploymentInProgress: boolean;

/**
 * Indicates whether the package has been disabled.
 */
disabled: boolean;

/**
 * Indicates whether there is a problem with the license for this package.
 */
licenseIssue: boolean;

/**
 * Indicates whether the package is missing files, system information, etc.
 */
modified: boolean;

/**
 * Indicates whether the package is unusable.
 */
needsRemediation: boolean;

/**
 * Indicates whether the package is available.
 */
notAvailable: boolean;

/**
 * Indicates whether the package is offline and cannot be used.
 */
packageOffline: boolean;

/**
 * Indicates whether the package is being serviced.
 */
servicing: boolean;

/**
 * Indicates whether the package may have been tampered with.
 */
tampered: boolean;

/**
 * Indicates whether the package is in good condition and may be used.
 * @return TRUE indicates that the package is in good condition; otherwise FALSE.
 */
verifyIsOK(): boolean
}


      declare var npm$namespace$Windows$ApplicationModel$Resources: {
        
        
        
        ResourceLoader: typeof Windows$ApplicationModel$Resources$ResourceLoader,
        Core: typeof npm$namespace$Windows$ApplicationModel$Resources$Core,
Management: typeof npm$namespace$Windows$ApplicationModel$Resources$Management,
      }

      declare var npm$namespace$Windows$ApplicationModel$Resources$Core: {
        
        
        ResourceQualifierPersistence: typeof Windows$ApplicationModel$Resources$Core$ResourceQualifierPersistence,
        NamedResource: typeof Windows$ApplicationModel$Resources$Core$NamedResource,
ResourceCandidate: typeof Windows$ApplicationModel$Resources$Core$ResourceCandidate,
ResourceCandidateVectorView: typeof Windows$ApplicationModel$Resources$Core$ResourceCandidateVectorView,
ResourceContext: typeof Windows$ApplicationModel$Resources$Core$ResourceContext,
ResourceContextLanguagesVectorView: typeof Windows$ApplicationModel$Resources$Core$ResourceContextLanguagesVectorView,
ResourceManager: typeof Windows$ApplicationModel$Resources$Core$ResourceManager,
ResourceMap: typeof Windows$ApplicationModel$Resources$Core$ResourceMap,
ResourceMapIterator: typeof Windows$ApplicationModel$Resources$Core$ResourceMapIterator,
ResourceMapMapView: typeof Windows$ApplicationModel$Resources$Core$ResourceMapMapView,
ResourceMapMapViewIterator: typeof Windows$ApplicationModel$Resources$Core$ResourceMapMapViewIterator,
ResourceQualifier: typeof Windows$ApplicationModel$Resources$Core$ResourceQualifier,
ResourceQualifierMapView: typeof Windows$ApplicationModel$Resources$Core$ResourceQualifierMapView,
ResourceQualifierObservableMap: typeof Windows$ApplicationModel$Resources$Core$ResourceQualifierObservableMap,
ResourceQualifierVectorView: typeof Windows$ApplicationModel$Resources$Core$ResourceQualifierVectorView,
        
      }

/**
 * Represents a single logical, named resource, such as a string resource named 'Header1'.
 */
declare class Windows$ApplicationModel$Resources$Core$NamedResource  {

/**
 * Gets all possible candidate values for this named resource.
 */
candidates: Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Resources$Core$ResourceCandidate>;

/**
 * Resolves this NamedResource object against a supplied context and returns the most appropriate candidate.
 * @param resourceContext The context against which the NamedResource should be resolved.
 * @return The most appropriate candidate for the specified context.
 */
resolve(
resourceContext: Windows$ApplicationModel$Resources$Core$ResourceContext): Windows$ApplicationModel$Resources$Core$ResourceCandidate;

/**
 * Resolves this NamedResource object against the default context and returns the most appropriate candidate.
 * @return The most appropriate candidate for the default context.
 */
resolve(): Windows$ApplicationModel$Resources$Core$ResourceCandidate;

/**
 * Resolves this NamedResource object against a supplied context and returns a list of all possible candidates in preference order.
 * @param resourceContext The context against which the NamedResource should be resolved.
 * @return A list of ResourceCandidate objects, in order of preference. The object in first position in the list is the most appropriate candidate for the corresponding context, and the object in last position is the least appropriate.
 */
resolveAll(
resourceContext: Windows$ApplicationModel$Resources$Core$ResourceContext): Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Resources$Core$ResourceCandidate>;

/**
 * Resolves this NamedResource object against the default context and returns a list of all possible candidates in preference order.
 * @return A list of ResourceCandidate objects, in order of preference. The object in first position in the list is the most appropriate candidate for the corresponding context, and the object in last position is the least appropriate.
 */
resolveAll(
): Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Resources$Core$ResourceCandidate>;

/**
 * Gets a URI that can be used to refer to this named resource.
 */
uri: Windows$Foundation$Uri
}


/**
 * Represents a single possible value for a given NamedResource , the qualifiers associated with that resource, and how well those qualifiers match the context against which it was resolved.
 */
declare class Windows$ApplicationModel$Resources$Core$ResourceCandidate  {

/**
 * Returns the value of a qualifier, given its name.
 * @param qualifierName The name of the qualifier.
 * @return The value of the qualifier.
 */
getQualifierValue(qualifierName: string): string;

/**
 * Asynchronously returns a StorageFile that accesses the value of this ResourceCandidate . This only works on certain types of ResourceCandidates that are files.
 * @return An asynchronous operation to return the requested StorageFile .
 */
getValueAsFileAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Asynchronously returns an IRandomAccessStream that accesses the value of this ResourceCandidate .
 * @return An asynchronous operation to return the requested IRandomAccessStream .
 */
getValueAsStreamAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStream>;

/**
 * Indicates whether this ResourceCandidate can be used as a default fallback value for any context.
 */
isDefault: boolean;

/**
 * Indicates whether this ResourceCandidate matched the ResourceContext against which it was evaluated.
 */
isMatch: boolean;

/**
 * Indicates whether this ResourceCandidate matched the ResourceContext against which it was evaluated as a result of being a true match, a default fallback value, or a mixed match with default fallback (that is, a match in relation to some qualifiers but using default fallback values for other qualifiers).
 */
isMatchAsDefault: boolean;

/**
 * Gets the qualifiers associated with this ResourceCandidate .
 */
qualifiers: Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Resources$Core$ResourceQualifier>;

/**
 * Gets the value of this ResourceCandidate , expressed as a string.
 */
valueAsString: string
}


/**
 * Represents a collection of ResourceCandidate objects.
 */
declare class Windows$ApplicationModel$Resources$Core$ResourceCandidateVectorView mixins Array<Windows$ApplicationModel$Resources$Core$ResourceCandidate> {

/**
 * Returns an iterator to enumerate the items in the set of ResourceCandidate objects.
 * @return The iterator. The current position of the iterator is index 0, or the end of the set if the set is empty.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$ApplicationModel$Resources$Core$ResourceCandidate>;

/**
 * Returns the ResourceCandidate at the specified index in the set.
 * @param index The zero-based index of the ResourceCandidate in the set to return.
 * @return The ResourceCandidate at the specified index.
 */
getAt(index: number): Windows$ApplicationModel$Resources$Core$ResourceCandidate;

/**
 * Returns the ResourceCandidate objects that start at the specified index in the set.
 * @param startIndex The zero-based index of the start of the ResourceCandidate objects in the set to return.
 */
getMany(
startIndex: number): {
items: Windows$ApplicationModel$Resources$Core$ResourceCandidate,
returnValue: number
};

/**
 * Returns the index of a specified ResourceCandidate in the set.
 * @param value The ResourceCandidate to find in the set.
 */
indexOf(
value: Windows$ApplicationModel$Resources$Core$ResourceCandidate): {
index: number,
returnValue: boolean
};

/**
 * Gets the number of ResourceCandidate objects in the set.
 */
size: number;
indexOf(
value: Windows$ApplicationModel$Resources$Core$ResourceCandidate,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$ApplicationModel$Resources$Core$ResourceCandidate,
fromIndex?: number): number
}


/**
 * Encapsulates all of the factors ( ResourceQualifier s) that might affect resource selection.
 */
declare class Windows$ApplicationModel$Resources$Core$ResourceContext  {

/**
 * Creates a new ResourceContext that matches a supplied set of qualifiers.
 * @param result The list of qualifiers to be matched.
 * @return The new ResourceContext .
 */
static createMatchingContext(
result: Windows$Foundation$Collections$IIterable<Windows$ApplicationModel$Resources$Core$ResourceQualifier>): Windows$ApplicationModel$Resources$Core$ResourceContext;

/**
 * Gets a default ResourceContext associated with the current view for the currently running application.
 * @return The default context associated with the current view.
 */
static getForCurrentView(): Windows$ApplicationModel$Resources$Core$ResourceContext;

/**
 * Gets a default ResourceContext not associated with any view.
 * @return A default ResourceContext not associated with any view.
 */
static getForViewIndependentUse(): Windows$ApplicationModel$Resources$Core$ResourceContext;

/**
 * Removes any qualifier overrides from default contexts of all views across the app.
 */
static resetGlobalQualifierValues(): void;

/**
 * Removes qualifier overrides for the specified qualifiers from default contexts of all views across the app.
 * @param qualifierNames The names of the qualifiers to be reset.
 */
static resetGlobalQualifierValues(qualifierNames: Windows$Foundation$Collections$IIterable<string>): void;

/**
 * Applies a single qualifier value override to default contexts of all views for the current app.
 * @param key The name of the qualifier to override.
 * @param value The override value to set.
 */
static setGlobalQualifierValue(key: string, value: string): void;

/**
 * Applies a single qualifier value override to default contexts of all views for the current app, and specifies the persistence of the override.
 * @param key The name of the qualifier to override.
 * @param value The override value to set.
 * @param persistence The persistence of the override value.
 */
static setGlobalQualifierValue(
key: string,
value: string,
persistence: $Values<typeof Windows$ApplicationModel$Resources$Core$ResourceQualifierPersistence>): void;

/**
 * Creates a cloned ResourceContext object.
 */
constructor(): this;

/**
 * Creates a clone of this ResourceContext , with identical qualifiers.
 * @return A new, cloned ResourceContext .
 */
clone(): Windows$ApplicationModel$Resources$Core$ResourceContext;

/**
 * Gets or sets the language qualifier for this context.
 */
languages: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Overrides the qualifier values supplied by this context to match a specified list of resolved ResourceQualifier s. Typically the resolved ResourceQualifiers are associated with a resource that was looked up earlier.
 * @param result The ResourceQualifier s to be applied to the context.
 */
overrideToMatch(
result: Windows$Foundation$Collections$IIterable<Windows$ApplicationModel$Resources$Core$ResourceQualifier>): void;

/**
 * Gets a writable, observable map of all supported qualifiers, indexed by name.
 */
qualifierValues: Windows$Foundation$Collections$IObservableMap<string, string>;

/**
 * Resets the overridden values for the specified qualifiers on the given ResourceContext instance.
 * @param qualifierNames The names of the qualifiers to be reset.
 */
reset(qualifierNames: Windows$Foundation$Collections$IIterable<string>): void;

/**
 * Resets the overridden values for all qualifiers on the given ResourceContext instance.
 */
reset(): void
}


/**
 * Represents a collection of ResourceContext language qualifiers.
 */
declare class Windows$ApplicationModel$Resources$Core$ResourceContextLanguagesVectorView mixins Array<string> {

/**
 * Returns an iterator to enumerate the items in the set of ResourceContext language qualifiers.
 * @return The iterator. The current position of the iterator is index 0, or the end of the set if the set is empty.
 */
first(): Windows$Foundation$Collections$IIterator<string>;

/**
 * Returns the ResourceContext language qualifier at the specified index in the set.
 * @param index The zero-based index of the ResourceContext language qualifier in the set to return.
 * @return The ResourceContext language qualifier at the specified index.
 */
getAt(index: number): string;

/**
 * Returns the ResourceContext language qualifiers that start at the specified index in the set.
 * @param startIndex The zero-based index of the start of the ResourceContext language qualifiers in the set to return.
 */
getMany(startIndex: number): {
items: string[],
returnValue: number
};

/**
 * Returns the index of a specified ResourceContext language qualifier in the set.
 * @param value The ResourceContext language qualifier to find in the set.
 */
indexOf(value: string): {
index: number,
returnValue: boolean
};

/**
 * Gets the number of ResourceContext language qualifiers in the set.
 */
size: number;
indexOf(value: string, ...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(searchElement: string, fromIndex?: number): number
}


/**
 * Provides access to application resource maps and more advanced resource functionality.
 */
declare class Windows$ApplicationModel$Resources$Core$ResourceManager  {

/**
 * Gets the ResourceManager for the currently running application.
 */
static current: Windows$ApplicationModel$Resources$Core$ResourceManager;

/**
 * Determines whether a supplied string matches the resource reference format (an ms-resource string URI identifier).
 * @param resourceReference The string you want to match.
 * @return TRUE if the string matches.
 */
static isResourceReference(resourceReference: string): boolean;

/**
 * Gets a map of ResourceMap objects typically associated with the app packages, indexed by package name.
 */
allResourceMaps: Windows$Foundation$Collections$IMapView<string, Windows$ApplicationModel$Resources$Core$ResourceMap>;

/**
 * Gets the default ResourceContext for the currently running application. Unless explicitly overridden, the default ResourceContext is used to determine the most appropriate representation of any given named resource.
 */
defaultContext: Windows$ApplicationModel$Resources$Core$ResourceContext;

/**
 * Gets a list of all named resources for an app package.
 * @param packageName The name of the app package.
 * @param resourceLayoutInfo Specifies the resource version and the named resource count.
 * @return A list of NamedResource objects.
 */
getAllNamedResourcesForPackage(
packageName: string,
resourceLayoutInfo: Windows$ApplicationModel$Resources$Core$ResourceLayoutInfo): Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Resources$Core$NamedResource>;

/**
 * Gets a list of all collections of resource subtrees for an app package.
 * @param packageName The name of the app package.
 * @param resourceLayoutInfo Specifies the resource version and the resource subtree count.
 * @return A list of resource subtrees ( ResourceMap objects).
 */
getAllSubtreesForPackage(
packageName: string,
resourceLayoutInfo: Windows$ApplicationModel$Resources$Core$ResourceLayoutInfo): Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Resources$Core$ResourceMap>;

/**
 * Loads one or more PRI files and adds their contents to the default resource manager.
 * @param files The files you want to add.
 */
loadPriFiles(
files: Windows$Foundation$Collections$IIterable<Windows$Storage$IStorageFile>): void;

/**
 * Gets the ResourceMap that is associated with the main package of the currently running application.
 */
mainResourceMap: Windows$ApplicationModel$Resources$Core$ResourceMap;

/**
 * Unloads one or more PRI files.
 * @param files The files you want unloaded.
 */
unloadPriFiles(
files: Windows$Foundation$Collections$IIterable<Windows$Storage$IStorageFile>): void
}


/**
 * A collection of related resources, typically either for a particular app package, or a resource file for a particular package.
 */
declare class Windows$ApplicationModel$Resources$Core$ResourceMap  {

/**
 * Returns an iterator to enumerate the items in the map.
 * @return The iterator. The current position of the iterator is index 0, or the end of the set if the map is empty.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Returns a ResourceMap that represents a subtree of another ResourceMap, typically used to access a particular resource file within an app package.
 * @param reference A resource map identifier that identifies the root of the new subtree.
 * @return The subtree ResourceMap .
 */
getSubtree(reference: string): Windows$ApplicationModel$Resources$Core$ResourceMap;

/**
 * Returns the most appropriate candidate for a resource that is specified by a resource identifier for the supplied context.
 * @param resource A resource specified as a name or reference.
 * @param context The context for which to select the most appropriate candidate.
 * @return A ResourceCandidate that describes the most appropriate candidate.
 */
getValue(
resource: string,
context: Windows$ApplicationModel$Resources$Core$ResourceContext): Windows$ApplicationModel$Resources$Core$ResourceCandidate;

/**
 * Returns the most appropriate candidate for a resource that is specified by a resource identifier within the default context.
 * @param resource A resource identifier specified as a name or reference.
 * @return A ResourceCandidate that describes the most appropriate candidate.
 */
getValue(resource: string): Windows$ApplicationModel$Resources$Core$ResourceCandidate;

/**
 * Determines whether the map can retrieve a resource with the specified resource identifier.
 * @param key The resource identifier to locate in the map.
 * @return TRUE if the key is found, otherwise FALSE.
 */
hasKey(key: string): boolean;

/**
 * Returns the NamedResource at the specified resource identifier in the map.
 * @param key The resource identifier to use to locate the resource in the map.
 * @return The NamedResource associated with the specified key.
 */
lookup(key: string): Windows$ApplicationModel$Resources$Core$NamedResource;

/**
 * Gets the number of resources in the map.
 */
size: number;

/**
 * Splits the map view into two views.
 */
split(
): {
first: Windows$Foundation$Collections$IMapView<string, Windows$ApplicationModel$Resources$Core$NamedResource>,
second: Windows$Foundation$Collections$IMapView<string, Windows$ApplicationModel$Resources$Core$NamedResource>
};

/**
 * Gets a URI that can be used to refer to this ResourceMap .
 */
uri: Windows$Foundation$Uri
}


/**
 * Supports iteration over a ResourceMap .
 */
declare class Windows$ApplicationModel$Resources$Core$ResourceMapIterator  {

/**
 * Gets the current item in the ResourceMap .
 */
current: Windows$Foundation$Collections$IKeyValuePair<string, Windows$ApplicationModel$Resources$Core$NamedResource>;

/**
 * Returns all the items in the ResourceMap .
 */
getMany(
): {
items: Windows$Foundation$Collections$IKeyValuePair<any, any>,
returnValue: number
};

/**
 * Gets a value that indicates whether there is a current item, or whether the iterator is at the end of the ResourceMap .
 */
hasCurrent: boolean;

/**
 * Moves the iterator forward to the next item and returns HasCurrent .
 * @return TRUE if the iterator refers to a valid item that is in the map, and otherwise FALSE.
 */
moveNext(): boolean
}


/**
 * An unchangeable view into a map of ResourceMap objects.
 */
declare class Windows$ApplicationModel$Resources$Core$ResourceMapMapView  {

/**
 * Returns an iterator to enumerate the items in the map view.
 * @return The iterator. The current position of the iterator is index 0, or the end of the map if the map is empty.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Determines whether the map view contains the specified key.
 * @param key The key to locate in the map view.
 * @return TRUE if the key is found, otherwise FALSE if it is not found.
 */
hasKey(key: string): boolean;

/**
 * Returns the ResourceMap at the specified key in the map view.
 * @param key The key to locate in the map view.
 * @return The ResourceMap associated with the specified key.
 */
lookup(key: string): Windows$ApplicationModel$Resources$Core$ResourceMap;

/**
 * Gets the number of ResourceMap objects in the map.
 */
size: number;

/**
 * Splits the map view into two views.
 */
split(
): {
first: Windows$Foundation$Collections$IMapView<string, Windows$ApplicationModel$Resources$Core$ResourceMap>,
second: Windows$Foundation$Collections$IMapView<string, Windows$ApplicationModel$Resources$Core$ResourceMap>
}
}


/**
 * Supports iteration over a ResourceMapMapView object.
 */
declare class Windows$ApplicationModel$Resources$Core$ResourceMapMapViewIterator  {

/**
 * Gets the current item in the ResourceMapMapView .
 */
current: Windows$Foundation$Collections$IKeyValuePair<string, Windows$ApplicationModel$Resources$Core$ResourceMap>;

/**
 * Returns all the items in the ResourceMapMapView .
 */
getMany(
): {
items: Windows$Foundation$Collections$IKeyValuePair<any, any>,
returnValue: number
};

/**
 * Gets a value that indicates whether there is a current item, or whether the iterator is at the end of the ResourceMapMapView .
 */
hasCurrent: boolean;

/**
 * Moves the iterator forward to the next item and returns HasCurrent .
 * @return TRUE if the iterator refers to a valid item that is in the map view, and otherwise FALSE.
 */
moveNext(): boolean
}


/**
 * Defines the qualifiers associated with a ResourceCandidate .
 */
declare class Windows$ApplicationModel$Resources$Core$ResourceQualifier  {

/**
 * Indicates whether this qualifier should be considered as a default match when no match is found.
 */
isDefault: boolean;

/**
 * Indicates whether a given qualifier for a given candidate matched the context when a named resource is resolved to a candidate for some given context.
 */
isMatch: boolean;

/**
 * The name of the qualifier.
 */
qualifierName: string;

/**
 * The value of the qualifier.
 */
qualifierValue: string;

/**
 * A score that indicates how well the qualifier matched the context against which it was resolved.
 */
score: number
}


/**
 * An unchangeable view into a map of ResourceQualifier objects.
 */
declare class Windows$ApplicationModel$Resources$Core$ResourceQualifierMapView  {

/**
 * Returns an iterator to enumerate the items in the map view.
 * @return The iterator. The current position of the iterator is index 0, or the end of the map view if the map view is empty.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Determines whether the map view contains the specified key.
 * @param key The key to locate in the map view.
 * @return TRUE if the key is found, otherwise FALSE if it is not found.
 */
hasKey(key: string): boolean;

/**
 * Returns the qualifier name at the specified key in the map view.
 * @param key The key to locate in the map view.
 * @return The qualifier name associated with the specified key.
 */
lookup(key: string): string;

/**
 * Gets the number of ResourceQualifier objects in the map.
 */
size: number;

/**
 * Splits the map view into two views.
 */
split(
): {
first: Windows$Foundation$Collections$IMapView<string, string>,
second: Windows$Foundation$Collections$IMapView<string, string>
}
}


/**
 * Notifies listeners of dynamic changes to a map of ResourceQualifier objects, such as when items get added or removed, and allows qualifier values to change.
 */
declare class Windows$ApplicationModel$Resources$Core$ResourceQualifierObservableMap  {

/**
 * Removes all items from the observable map.
 */
clear(): void;

/**
 * Returns an iterator to enumerate the items in the observable map.
 * @return The iterator. The current position of the iterator is index 0, or the end of the observable map if the observable map is empty.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Returns an unchangeable view of the observable map.
 * @return The view of the map.
 */
getView(): Windows$Foundation$Collections$IMapView<string, string>;

/**
 * Determines whether the observable map contains the specified key.
 * @param key The key to locate in the observable map.
 * @return TRUE if the key is found, otherwise FALSE if it is not found.
 */
hasKey(key: string): boolean;

/**
 * Inserts or replaces an item in the observable map.
 * @param key The key associated with the item to insert.
 * @param value The item to insert.
 * @return TRUE if an item with the specified key is an existing item and was replaced, otherwise FALSE.
 */
insert(key: string, value: string): boolean;

/**
 * Returns the qualifier name at the specified key in the observable map.
 * @param key The key to locate in the observable map.
 * @return The qualifier name associated with the specified key.
 */
lookup(key: string): string;

/**
 * Occurs when the map changes.
 */
onmapchanged: Windows$Foundation$Collections$MapChangedEventHandler<string, string>;
addEventListener(
type: "mapchanged",
listener: Windows$Foundation$Collections$MapChangedEventHandler<string, string>): void;
removeEventListener(
type: "mapchanged",
listener: Windows$Foundation$Collections$MapChangedEventHandler<string, string>): void;

/**
 * Removes an item from the observable map.
 * @param key The key associated with the item to remove.
 */
remove(key: string): void;

/**
 * Gets the number of ResourceQualifier objects in the observable map.
 */
size: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Possible values for the persistence of a global qualifier value override.
 */

declare  var Windows$ApplicationModel$Resources$Core$ResourceQualifierPersistence: {|
  +none: 0,// 0
+localMachine: 1,// 1

|};



/**
 * An unchangeable view into a vector of ResourceQualifier objects.
 */
declare class Windows$ApplicationModel$Resources$Core$ResourceQualifierVectorView mixins Array<Windows$ApplicationModel$Resources$Core$ResourceQualifier> {

/**
 * Returns an iterator to enumerate the items in the view.
 * @return The iterator. The current position of the iterator is index 0, or the end of the view if the view is empty.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$ApplicationModel$Resources$Core$ResourceQualifier>;

/**
 * Returns the ResourceQualifier at the specified index in the view.
 * @param index The zero-based index of the ResourceQualifier in the view to return.
 * @return The ResourceQualifier at the specified index.
 */
getAt(index: number): Windows$ApplicationModel$Resources$Core$ResourceQualifier;

/**
 * Returns the ResourceQualifier objects that start at the specified index in the view.
 * @param startIndex The zero-based index of the start of the objects in the view to return.
 */
getMany(
startIndex: number): {
items: Windows$ApplicationModel$Resources$Core$ResourceQualifier,
returnValue: number
};

/**
 * Returns the index of a specified ResourceQualifier in the view.
 * @param value The ResourceQualifier to find in the set.
 */
indexOf(
value: Windows$ApplicationModel$Resources$Core$ResourceQualifier): {
index: number,
returnValue: boolean
};

/**
 * Gets the number of ResourceQualifier objects in the view.
 */
size: number;
indexOf(
value: Windows$ApplicationModel$Resources$Core$ResourceQualifier,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$ApplicationModel$Resources$Core$ResourceQualifier,
fromIndex?: number): number
}


/**
 * Structure that determines version and counts of resources returned for the app package.
 */
declare interface Windows$ApplicationModel$Resources$Core$ResourceLayoutInfo {

/**
 * Framework-generated checksum.
 */
checksum: number,

/**
 * Major version of resources to be returned.
 */
majorVersion: number,

/**
 * Minor version of resources to be returned.
 */
minorVersion: number,

/**
 * Number of named resources to be returned.
 */
namedResourceCount: number,

/**
 * Number of resource subtrees to be returned.
 */
resourceSubtreeCount: number
} 


      declare var npm$namespace$Windows$ApplicationModel$Resources$Management: {
        
        
        IndexedResourceType: typeof Windows$ApplicationModel$Resources$Management$IndexedResourceType,
        
        
      }

/**
 * Specifies whether an IndexedResourceCandidate is a file or a string.
 */

declare  var Windows$ApplicationModel$Resources$Management$IndexedResourceType: {|
  +string: 0,// 0
+path: 1,// 1
+embeddedData: 2,// 2

|};



/**
 * Provides simplified access to app resources such as app UI strings.
 */
declare class Windows$ApplicationModel$Resources$ResourceLoader  {

/**
 * Gets a ResourceLoader object for the Resources subtree of the currently running app's main ResourceMap . This ResourceLoader uses a default context associated with the current view.
 * @return A resource loader for the Resources subtree of the currently running app's main ResourceMap .
 */
static getForCurrentView(): Windows$ApplicationModel$Resources$ResourceLoader;

/**
 * Gets a ResourceLoader object for the specified ResourceMap . This ResourceLoader uses a default context associated with the current view.
 * @param name The resource identifier of the ResourceMap that the new resource loader uses for unqualified resource references. The loader can then retrieve resources relative to those references.
 * @return A resource loader for the specified ResourceMap .
 */
static getForCurrentView(name: string): Windows$ApplicationModel$Resources$ResourceLoader;

/**
 * Gets a ResourceLoader object for the specified ResourceMap . This ResourceLoader uses a default context that's not associated with any view.
 * @param name The resource identifier of the ResourceMap that the new resource loader uses for unqualified resource references. The loader can then retrieve resources relative to those references.
 * @return A resource loader for the Resources subtree of the currently running app's main ResourceMap . This ResourceLoader uses a default context that's not associated with any view. You can't use this ResourceLoader to retrieve any resource that has resource candidates qualified for scale.
 */
static getForViewIndependentUse(name: string): Windows$ApplicationModel$Resources$ResourceLoader;

/**
 * Gets a ResourceLoader object for the Resources subtree of the currently running app's main ResourceMap . This ResourceLoader uses a default context that's not associated with any view.
 * @return A resource loader for the Resources subtree of the currently running app's main ResourceMap . This ResourceLoader uses a default context that's not associated with any view. You can't use this ResourceLoader to retrieve any resource that has resource candidates qualified for scale.
 */
static getForViewIndependentUse(): Windows$ApplicationModel$Resources$ResourceLoader;

/**
 * Returns the most appropriate string value of a resource, specified as a Uri for a resource identifier, for the default ResourceContext of the currently running app.
 * @param uri A Uri that represents the resource to be retrieved.
 * @return The most appropriate string value of the specified resource for the default ResourceContext .
 */
static getStringForReference(uri: Windows$Foundation$Uri): string;

/**
 * Constructs a new ResourceLoader object for the specified ResourceMap .
 * @param name The resource identifier of the ResourceMap that the new resource loader uses for unqualified resource references. It can then retrieve resources relative to those references.
 */
constructor(name: string): this;

/**
 * Constructs a new ResourceLoader object for the "Resources" subtree of the currently running app's main ResourceMap .
 */
constructor(): this;

/**
 * Returns the most appropriate string value of a resource, specified by resource identifier, for the default ResourceContext of the view in which the ResourceLoader was obtained using ResourceLoader.GetForCurrentView .
 * @param resource The resource identifier of the resource to be resolved.
 * @return The most appropriate string value of the specified resource for the default ResourceContext .
 */
getString(resource: string): string;

/**
 * Returns the most appropriate string value of a resource, specified by a Uniform Resource Identifier (URI) resource identifier, for the default ResourceContext of the currently running app.
 * @param uri A URI that represents the resource to be retrieved.
 * @return The most appropriate string value of the specified resource for the default ResourceContext .
 */
getStringForUri(uri: Windows$Foundation$Uri): string
}


      declare var npm$namespace$Windows$ApplicationModel$Search: {
        
        
        
        LocalContentSuggestionSettings: typeof Windows$ApplicationModel$Search$LocalContentSuggestionSettings,
SearchPane: typeof Windows$ApplicationModel$Search$SearchPane,
SearchPaneQueryChangedEventArgs: typeof Windows$ApplicationModel$Search$SearchPaneQueryChangedEventArgs,
SearchPaneQueryLinguisticDetails: typeof Windows$ApplicationModel$Search$SearchPaneQueryLinguisticDetails,
SearchPaneQuerySubmittedEventArgs: typeof Windows$ApplicationModel$Search$SearchPaneQuerySubmittedEventArgs,
SearchPaneResultSuggestionChosenEventArgs: typeof Windows$ApplicationModel$Search$SearchPaneResultSuggestionChosenEventArgs,
SearchPaneSuggestionsRequest: typeof Windows$ApplicationModel$Search$SearchPaneSuggestionsRequest,
SearchPaneSuggestionsRequestDeferral: typeof Windows$ApplicationModel$Search$SearchPaneSuggestionsRequestDeferral,
SearchPaneSuggestionsRequestedEventArgs: typeof Windows$ApplicationModel$Search$SearchPaneSuggestionsRequestedEventArgs,
SearchPaneVisibilityChangedEventArgs: typeof Windows$ApplicationModel$Search$SearchPaneVisibilityChangedEventArgs,
SearchQueryLinguisticDetails: typeof Windows$ApplicationModel$Search$SearchQueryLinguisticDetails,
SearchSuggestionCollection: typeof Windows$ApplicationModel$Search$SearchSuggestionCollection,
SearchSuggestionsRequest: typeof Windows$ApplicationModel$Search$SearchSuggestionsRequest,
SearchSuggestionsRequestDeferral: typeof Windows$ApplicationModel$Search$SearchSuggestionsRequestDeferral,
        Core: typeof npm$namespace$Windows$ApplicationModel$Search$Core,
      }

      declare var npm$namespace$Windows$ApplicationModel$Search$Core: {
        
        
        SearchSuggestionKind: typeof Windows$ApplicationModel$Search$Core$SearchSuggestionKind,
        RequestingFocusOnKeyboardInputEventArgs: typeof Windows$ApplicationModel$Search$Core$RequestingFocusOnKeyboardInputEventArgs,
SearchSuggestion: typeof Windows$ApplicationModel$Search$Core$SearchSuggestion,
SearchSuggestionManager: typeof Windows$ApplicationModel$Search$Core$SearchSuggestionManager,
SearchSuggestionsRequestedEventArgs: typeof Windows$ApplicationModel$Search$Core$SearchSuggestionsRequestedEventArgs,
        
      }

/**
 * Provides data for the RequestingFocusOnKeyboardInput event.
 */
declare class Windows$ApplicationModel$Search$Core$RequestingFocusOnKeyboardInputEventArgs  {}


/**
 * Enables access to the search suggestions that the SearchSuggestionManager provides.
 */
declare class Windows$ApplicationModel$Search$Core$SearchSuggestion  {

/**
 * Gets the value that was passed to the detailText parameter of the AppendResultSuggestion method.
 */
detailText: string;

/**
 * Gets the value that was passed to the image parameter of the AppendResultSuggestion method.
 */
image: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets the value that was passed to the imageAlternateText parameter of the AppendResultSuggestion method.
 */
imageAlternateText: string;

/**
 * Gets the type of suggestion.
 */
kind: $Values<typeof Windows$ApplicationModel$Search$Core$SearchSuggestionKind>;

/**
 * Gets the value that was passed to the tag parameter of the AppendResultSuggestion method.
 */
tag: string;

/**
 * Gets the localized text of the suggestion for display in the search suggestions UI.
 */
text: string
}


/**
 * Specifies the type of a SearchSuggestion .
 */

declare  var Windows$ApplicationModel$Search$Core$SearchSuggestionKind: {|
  +query: 0,// 0
+result: 1,// 1
+separator: 2,// 2

|};



/**
 * Manages access to search suggestions for the in-app SearchBox control.
 */
declare class Windows$ApplicationModel$Search$Core$SearchSuggestionManager  {

/**
 * Initializes a new instance of the SearchSuggestionManager class.
 */
constructor(): this;

/**
 * Stores the specified query and input language in the search history.
 * @param queryText The query.
 * @param language The input language. The input language ensures that the query string is displayed in the search history for the correct language.
 */
addToHistory(queryText: string, language: string): void;

/**
 * Stores the specified query in the search history.
 * @param queryText The query.
 */
addToHistory(queryText: string): void;

/**
 * Clears all search history contexts for the current app.
 */
clearHistory(): void;

/**
 * Raised when the user presses a key that initiates type-to-search.
 */
onrequestingfocusonkeyboardinput: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$Core$SearchSuggestionManager, Windows$ApplicationModel$Search$Core$RequestingFocusOnKeyboardInputEventArgs>;
addEventListener(
type: "requestingfocusonkeyboardinput",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$Core$SearchSuggestionManager, Windows$ApplicationModel$Search$Core$RequestingFocusOnKeyboardInputEventArgs>): void;
removeEventListener(
type: "requestingfocusonkeyboardinput",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$Core$SearchSuggestionManager, Windows$ApplicationModel$Search$Core$RequestingFocusOnKeyboardInputEventArgs>): void;

/**
 * Raised when the user's query text changes and the app needs to provide new suggestions to display in the search box.
 */
onsuggestionsrequested: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$Core$SearchSuggestionManager, Windows$ApplicationModel$Search$Core$SearchSuggestionsRequestedEventArgs>;
addEventListener(
type: "suggestionsrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$Core$SearchSuggestionManager, Windows$ApplicationModel$Search$Core$SearchSuggestionsRequestedEventArgs>): void;
removeEventListener(
type: "suggestionsrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$Core$SearchSuggestionManager, Windows$ApplicationModel$Search$Core$SearchSuggestionsRequestedEventArgs>): void;

/**
 * Identifies the context of the search and is used to store the user's search history with the app.
 */
searchHistoryContext: string;

/**
 * Indicates whether the user's previous searches with the app are automatically tracked and used to provide suggestions.
 */
searchHistoryEnabled: boolean;

/**
 * Specifies whether suggestions based on local files are added automatically to the Suggestions collection, and defines the criteria that Windows uses to locate and filter these suggestions.
 * @param settings The new settings for local content suggestions.
 */
setLocalContentSuggestionSettings(settings: Windows$ApplicationModel$Search$LocalContentSuggestionSettings): void;

/**
 * Assigns the current search query with the specified input language and Input Method Editor (IME) info.
 * @param queryText The query.
 * @param language The input language.
 * @param linguisticDetails Info about the query text that the user enters through an IME.
 */
setQuery(
queryText: string,
language: string,
linguisticDetails: Windows$ApplicationModel$Search$SearchQueryLinguisticDetails): void;

/**
 * Assigns the current search query.
 * @param queryText The query.
 */
setQuery(queryText: string): void;

/**
 * Assigns the current search query with the specified input language.
 * @param queryText The query.
 * @param language The input language.
 */
setQuery(queryText: string, language: string): void;

/**
 * Gets the search suggestions for the current search query.
 */
suggestions: Windows$Foundation$Collections$IObservableVector<Windows$ApplicationModel$Search$Core$SearchSuggestion>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the SuggestionsRequested event.
 */
declare class Windows$ApplicationModel$Search$Core$SearchSuggestionsRequestedEventArgs  {

/**
 * Gets the Internet Engineering Task Force (IETF) language tag (BCP 47 standard) that identifies the language currently associated with the user's text input device.
 */
language: string;

/**
 * Gets an object that provides linguistic information about query text that the user is entering through an Input Method Editor (IME).
 */
linguisticDetails: Windows$ApplicationModel$Search$SearchQueryLinguisticDetails;

/**
 * The text that the app should provide suggestions for and that was in the search box when the SuggestionsRequested event was raised.
 */
queryText: string;

/**
 * Gets an object that stores suggestions and information about the request.
 */
request: Windows$ApplicationModel$Search$SearchSuggestionsRequest
}


/**
 * Stores settings that determine whether the app provides suggestions based on local files, and that define the criteria used to locate and filter these suggestions.
 */
declare class Windows$ApplicationModel$Search$LocalContentSuggestionSettings  {

/**
 * Creates a new instance of the localContentSuggestionSettings class.
 */
constructor(): this;

/**
 * An Advanced Query Syntax (AQS) string that limits the types and kinds of files that are used to provide suggestions. If no AQS string is specified, suggestions are provided from all local files in locations specified by the locations property.
 */
aqsFilter: string;

/**
 * Indicates whether suggestions based on local files are displayed in the search pane.
 */
enabled: boolean;

/**
 * A list of the storageFolder objects that contain files that are used to provide suggestions. If the list is empty, suggestions are provided from files in all of the local libraries for which the app declared capabilities.
 */
locations: Windows$Foundation$Collections$IVector<Windows$Storage$StorageFolder>;

/**
 * A list of the file properties whose values are used to provide suggestions from local files. If the list is empty, all of the file properties that are available for suggestions are used.
 */
propertiesToMatch: Windows$Foundation$Collections$IVector<string>
}


/**
 * Represents and manages the search pane that opens when a user activates the Search charm. The search pane provides a consistent, touch-friendly search box and optional search suggestions.
 */
declare class Windows$ApplicationModel$Search$SearchPane  {

/**
 * Retrieves an instance of the search pane from which users can search within the app.
 * @return An instance of the search pane, which provides a consistent, touch-friendly search box and optional search suggestions for searching within the current application.
 */
static getForCurrentView(): Windows$ApplicationModel$Search$SearchPane;

/**
 * Hides the current app's UI.
 */
static hideThisApplication(): void;

/**
 * The Internet Engineering Task Force (IETF) language tag (BCP 47 standard) that identifies the language currently associated with the user's text input device.
 */
language: string;

/**
 * Fires when the user changes the text in the search box.
 */
onquerychanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$SearchPane, Windows$ApplicationModel$Search$SearchPaneQueryChangedEventArgs>;
addEventListener(
type: "querychanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$SearchPane, Windows$ApplicationModel$Search$SearchPaneQueryChangedEventArgs>): void;
removeEventListener(
type: "querychanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$SearchPane, Windows$ApplicationModel$Search$SearchPaneQueryChangedEventArgs>): void;

/**
 * Fires when the user submits the text in the search box and the app needs to display search results.
 */
onquerysubmitted: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$SearchPane, Windows$ApplicationModel$Search$SearchPaneQuerySubmittedEventArgs>;
addEventListener(
type: "querysubmitted",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$SearchPane, Windows$ApplicationModel$Search$SearchPaneQuerySubmittedEventArgs>): void;
removeEventListener(
type: "querysubmitted",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$SearchPane, Windows$ApplicationModel$Search$SearchPaneQuerySubmittedEventArgs>): void;

/**
 * Fires when the user selects one of the suggested results that was provided by the app and displayed in the search pane.
 */
onresultsuggestionchosen: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$SearchPane, Windows$ApplicationModel$Search$SearchPaneResultSuggestionChosenEventArgs>;
addEventListener(
type: "resultsuggestionchosen",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$SearchPane, Windows$ApplicationModel$Search$SearchPaneResultSuggestionChosenEventArgs>): void;
removeEventListener(
type: "resultsuggestionchosen",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$SearchPane, Windows$ApplicationModel$Search$SearchPaneResultSuggestionChosenEventArgs>): void;

/**
 * Fires when the user's query text changes and the app needs to provide new suggestions to display in the search pane.
 */
onsuggestionsrequested: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$SearchPane, Windows$ApplicationModel$Search$SearchPaneSuggestionsRequestedEventArgs>;
addEventListener(
type: "suggestionsrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$SearchPane, Windows$ApplicationModel$Search$SearchPaneSuggestionsRequestedEventArgs>): void;
removeEventListener(
type: "suggestionsrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$SearchPane, Windows$ApplicationModel$Search$SearchPaneSuggestionsRequestedEventArgs>): void;

/**
 * Fires when the user opens or closes the search pane.
 */
onvisibilitychanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$SearchPane, Windows$ApplicationModel$Search$SearchPaneVisibilityChangedEventArgs>;
addEventListener(
type: "visibilitychanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$SearchPane, Windows$ApplicationModel$Search$SearchPaneVisibilityChangedEventArgs>): void;
removeEventListener(
type: "visibilitychanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Search$SearchPane, Windows$ApplicationModel$Search$SearchPaneVisibilityChangedEventArgs>): void;

/**
 * The placeholder text in the search box when the user hasn't entered any characters.
 */
placeholderText: string;

/**
 * The current text in the search box of the search pane.
 */
queryText: string;

/**
 * A string that identifies the context of the search and is used to store the user's search history with the app.
 */
searchHistoryContext: string;

/**
 * Indicates whether the user's previous searches with the app are automatically tracked and used to provide suggestions.
 */
searchHistoryEnabled: boolean;

/**
 * Specifies whether suggestions based on local files are automatically displayed in the search pane, and defines the criteria that Windows uses to locate and filter these suggestions.
 * @param settings The new settings for local content suggestions.
 */
setLocalContentSuggestionSettings(settings: Windows$ApplicationModel$Search$LocalContentSuggestionSettings): void;

/**
 * Shows the search pane.
 */
show(): void;

/**
 * Shows the search pane with the specified initial query string.
 * @param query The initial query string.
 */
show(query: string): void;

/**
 * Gets or sets whether the user can open the search pane by typing.
 */
showOnKeyboardInput: boolean;

/**
 * Attempts to set the text in the search box of the search pane.
 * @param query The query text to show in the search pane's search box.
 * @return True if the search box text was set successfully. Otherwise, false.
 */
trySetQueryText(query: string): boolean;

/**
 * Indicates whether the search pane is open.
 */
visible: boolean;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for a querychanged event that is associated with a searchPane object.
 */
declare class Windows$ApplicationModel$Search$SearchPaneQueryChangedEventArgs  {

/**
 * The Internet Engineering Task Force (IETF) language tag (BCP 47 standard) that identifies the language currently associated with the user's text input device.
 */
language: string;

/**
 * An object that provides linguistic information about query text that the user is entering through an Input Method Editor (IME).
 */
linguisticDetails: Windows$ApplicationModel$Search$SearchPaneQueryLinguisticDetails;

/**
 * The text in the search box when the querychanged event fired.
 */
queryText: string
}


/**
 * Provides information about query text that the user enters through an Input Method Editor (IME).
 */
declare class Windows$ApplicationModel$Search$SearchPaneQueryLinguisticDetails  {

/**
 * A list of the text alternatives for the current query text. These alternatives account for uncomposed text the user is entering in an IME.
 */
queryTextAlternatives: Windows$Foundation$Collections$IVectorView<string>;

/**
 * The length of the portion of the query text that the user is composing with an Input Method Editor (IME).
 */
queryTextCompositionLength: number;

/**
 * The starting location of the text that the user is composing with an Input Method Editor (IME).
 */
queryTextCompositionStart: number
}


/**
 * Provides data for a querysubmitted event that is associated with a searchPane instance.
 */
declare class Windows$ApplicationModel$Search$SearchPaneQuerySubmittedEventArgs  {

/**
 * The Internet Engineering Task Force (IETF) language tag (BCP 47 standard) that identifies the language currently associated with the user's text input device.
 */
language: string;

/**
 * An object that provides linguistic information about query text that the user is entering through an Input Method Editor (IME).
 */
linguisticDetails: Windows$ApplicationModel$Search$SearchPaneQueryLinguisticDetails;

/**
 * The text that was submitted through the search pane.
 */
queryText: string
}


/**
 * Provides data for a resultsuggestionchosen event that is associated with a searchPane object.
 */
declare class Windows$ApplicationModel$Search$SearchPaneResultSuggestionChosenEventArgs  {

/**
 * The tag for the suggested result that the user selected.
 */
tag: string
}


/**
 * Stores suggestions and information about the request for suggestions.
 */
declare class Windows$ApplicationModel$Search$SearchPaneSuggestionsRequest  {

/**
 * Retrieves an object that lets an app respond to a request for suggestions asynchronously.
 * @return An object that lets an app signal when it has fulfilled the request for search suggestions.
 */
getDeferral(): Windows$ApplicationModel$Search$SearchPaneSuggestionsRequestDeferral;

/**
 * Indicates whether the request for suggestions to display is canceled.
 */
isCanceled: boolean;

/**
 * The suggestions to display in the search pane for the current query. Apps provide suggestions to display by appending them to this searchSuggestionCollection object.
 */
searchSuggestionCollection: Windows$ApplicationModel$Search$SearchSuggestionCollection
}


/**
 * Enables the app to signal when it has finished populating a searchSuggestionCollection object while handling the suggestionsrequested event. Apps should use a deferral if and only if they need to respond to a request for suggestions asynchronously.
 */
declare class Windows$ApplicationModel$Search$SearchPaneSuggestionsRequestDeferral  {

/**
 * Signals that the app has finished populating a searchSuggestionCollection object while handling the suggestionsrequested event.
 */
complete(): void
}


/**
 * Provides data for a suggestionsrequested event that is associated with a searchPane object.
 */
declare class Windows$ApplicationModel$Search$SearchPaneSuggestionsRequestedEventArgs  {

/**
 * The Internet Engineering Task Force (IETF) language tag (BCP 47 standard) that identifies the language currently associated with the user's text input device.
 */
language: string;

/**
 * An object that provides linguistic information about query text that the user is entering through an Input Method Editor (IME).
 */
linguisticDetails: Windows$ApplicationModel$Search$SearchPaneQueryLinguisticDetails;

/**
 * The text that the app should provide suggestions for and that was in the search box when the suggestionsrequested event fired.
 */
queryText: string;

/**
 * An object that stores suggestions and information about the request.
 */
request: Windows$ApplicationModel$Search$SearchPaneSuggestionsRequest
}


/**
 * Provides data for a visibilitychanged event that is associated with a searchPane object.
 */
declare class Windows$ApplicationModel$Search$SearchPaneVisibilityChangedEventArgs  {

/**
 * Indicates whether the search pane is open.
 */
visible: boolean
}


/**
 * Provides information about query text that the user enters through an Input Method Editor (IME).
 */
declare class Windows$ApplicationModel$Search$SearchQueryLinguisticDetails  {

/**
 * Initializes a new instance of the SearchQueryLinguisticDetails class.
 * @param queryTextAlternatives A list of the text alternatives for the current query text.
 * @param queryTextCompositionStart The starting location of the text that the user is composing with an IME.
 * @param queryTextCompositionLength The length of the portion of the query text that the user is composing with an IME.
 */
constructor(queryTextAlternatives: Windows$Foundation$Collections$IIterable<string>, queryTextCompositionStart: number, queryTextCompositionLength: number): this;

/**
 * A list of the text alternatives for the current query text. These alternatives account for uncomposed text the user is entering in an IME.
 */
queryTextAlternatives: Windows$Foundation$Collections$IVectorView<string>;

/**
 * The length of the portion of the query text that the user is composing with an Input Method Editor (IME).
 */
queryTextCompositionLength: number;

/**
 * The starting location of the text that the user is composing with an Input Method Editor (IME).
 */
queryTextCompositionStart: number
}


/**
 * Represents a collection of search suggestions to be displayed in the search pane in response to a suggestionsrequested event.
 */
declare class Windows$ApplicationModel$Search$SearchSuggestionCollection  {

/**
 * Appends a query suggestion to the list of search suggestions for the search pane.
 * @param text The text of the query suggestion.
 */
appendQuerySuggestion(text: string): void;

/**
 * Appends a list of query suggestions to the list of search suggestions for the search pane.
 * @param suggestions The list of query suggestions.
 */
appendQuerySuggestions(suggestions: Windows$Foundation$Collections$IIterable<string>): void;

/**
 * Appends a suggested search result to the list of suggestions to display in the search pane.
 * @param text The text of the suggested result.
 * @param detailText The detail text for the suggested result.
 * @param tag The unique tag that identifies this suggested result.
 * @param image The image to accompany the results suggestion.
 * @param imageAlternateText The alternate text for the image.
 */
appendResultSuggestion(
text: string,
detailText: string,
tag: string,
image: Windows$Storage$Streams$IRandomAccessStreamReference,
imageAlternateText: string): void;

/**
 * Appends a text label that is used to separate groups of suggestions in the search pane.
 * @param label The text to use as a separator. This text should be descriptive of any suggestions that are appended after it.
 */
appendSearchSeparator(label: string): void;

/**
 * The number of suggestions in the collection.
 */
size: number
}


/**
 * Stores suggestions and information about the request for suggestions.
 */
declare class Windows$ApplicationModel$Search$SearchSuggestionsRequest  {

/**
 * Gets an object that lets an app respond to a request for suggestions asynchronously.
 * @return An object that lets an app signal when it has fulfilled the request for search suggestions.
 */
getDeferral(): Windows$ApplicationModel$Search$SearchSuggestionsRequestDeferral;

/**
 * Indicates whether the request for suggestions to display is canceled.
 */
isCanceled: boolean;

/**
 * The suggestions to display in the search pane or in-app search box for the current query. Apps provide suggestions to display by appending them to this SearchSuggestionCollection object.
 */
searchSuggestionCollection: Windows$ApplicationModel$Search$SearchSuggestionCollection
}


/**
 * Enables the app to signal when it has finished populating a SearchSuggestionCollection object while handling the SuggestionsRequested event. Use a deferral if and only if your app needs to respond to a request for suggestions asynchronously.
 */
declare class Windows$ApplicationModel$Search$SearchSuggestionsRequestDeferral  {

/**
 * Signals that the app has finished populating a SearchSuggestionCollection object while handling the SuggestionsRequested event.
 */
complete(): void
}


      declare var npm$namespace$Windows$ApplicationModel$Store: {
        
        
        FulfillmentResult: typeof Windows$ApplicationModel$Store$FulfillmentResult,
ProductPurchaseStatus: typeof Windows$ApplicationModel$Store$ProductPurchaseStatus,
ProductType: typeof Windows$ApplicationModel$Store$ProductType,
        CurrentApp: typeof Windows$ApplicationModel$Store$CurrentApp,
CurrentAppSimulator: typeof Windows$ApplicationModel$Store$CurrentAppSimulator,
LicenseInformation: typeof Windows$ApplicationModel$Store$LicenseInformation,
ListingInformation: typeof Windows$ApplicationModel$Store$ListingInformation,
ProductLicense: typeof Windows$ApplicationModel$Store$ProductLicense,
ProductListing: typeof Windows$ApplicationModel$Store$ProductListing,
ProductPurchaseDisplayProperties: typeof Windows$ApplicationModel$Store$ProductPurchaseDisplayProperties,
PurchaseResults: typeof Windows$ApplicationModel$Store$PurchaseResults,
UnfulfilledConsumable: typeof Windows$ApplicationModel$Store$UnfulfilledConsumable,
        Preview: typeof npm$namespace$Windows$ApplicationModel$Store$Preview,
      }

/**
 * Defines methods and properties you can use to get license and listing info about the current app and perform in-app product purchases.
 */
declare class Windows$ApplicationModel$Store$CurrentApp  {

/**
 * Gets the GUID generated by the Windows Store when your app has been certified for listing in the Windows Store.
 */
static appId: string;

/**
 * Retrieves the promotion campaign ID for the current app.
 * @return The advertising campaign ID for your app.
 */
static getAppPurchaseCampaignIdAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Requests all receipts for the purchase of the app and any in-app products. For examples of how receipt information can be used, see Using receipts to verify product purchases.
 * @return An XML-formatted string that contains all receipt information for the purchase of the app and any in-app products.
 */
static getAppReceiptAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<string>;
static getCustomerCollectionsIdAsync: any;
static getCustomerPurchaseIdAsync: any;

/**
 * Requests the receipt for the productId specified. For examples of how receipt information can be used, see Using receipts to verify product purchases.
 * @param productId The unique identifier for the product that you specified this identifier when you submitted the app to the Windows Store
 * @return An XML-formatted string that contains the receipt for the specified productId.
 */
static getProductReceiptAsync(productId: string): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Returns a list of purchased consumable in-app products that have not been reported to the Windows Store as fulfilled.
 * @return When the operation completes, a list of consumable in-app products not yet reported as fulfilled is returned ( UnfulfilledConsumable objects). Each item of this list provides the product ID, offer ID, and transaction ID associated with a product.
 */
static getUnfulfilledConsumablesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the license metadata for the current app.
 */
static licenseInformation: Windows$ApplicationModel$Store$LicenseInformation;

/**
 * Gets the Uniform Resource Identifier (URI) of the app's listing page in the web catalog of the Windows Store.
 */
static linkUri: Windows$Foundation$Uri;

/**
 * Loads the app's listing information asynchronously. Implements the IAsyncInfo interface.
 * @return The apps' listing information. If the method fails, it returns an HRESULT error code.
 */
static loadListingInformationAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$ListingInformation>;

/**
 * Windows Phone only. Loads the app listing information asynchronously, returning features and products in the ProductListings collection that match all supplied keywords. Implements the IAsyncInfo interface.
 * @param keywords The list of keywords by which to filter the ProductListings collection that is returned in the ListingInformation object.
 * @return The app's listing information, with ProductListings collection filtered by keywords. If the method fails, it returns an HRESULT error code. If no products or features are found that match all of the given keywords, the ProductListings collection will be empty.
 */
static loadListingInformationByKeywordsAsync(
keywords: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$ListingInformation>;

/**
 * Windows Phone only. Loads the app listing information asynchronously, returning features and products in the ProductListings collection that match any of the given products IDs. Implements the IAsyncInfo interface.
 * @param productIds The list of product IDs by which to filter the ProductListings collection.
 * @return The app's listing information, with ProductListings collection filtered by product IDs. If the method fails, it returns an HRESULT error code. If no products or features are found that match the given product IDs, the ProductListings collection will be empty.
 */
static loadListingInformationByProductIdsAsync(
productIds: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$ListingInformation>;

/**
 * Notifies the Windows Store that the purchase of a consumable is fulfilled and that the user has the right to access the content.
 * @param productId Identifies the consumable.
 * @param transactionId Identifies a transaction that includes the purchase of the consumable ( productId).
 * @return A value that indicates the status of fulfillment for a consumable in-app product. Possible values are defined by the FulfillmentResult enumeration.
 */
static reportConsumableFulfillmentAsync(
productId: string,
transactionId: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$Store$FulfillmentResult>>;

/**
 * Notifies the Windows Store that the application has fulfilled the in-app product. This product cannot be re-purchased until the app has confirmed fulfillment using this method.
 * @param productId The ID of the product that has been delivered to the user.
 */
static reportProductFulfillment(productId: string): void;

/**
 * Requests the purchase of a full app license.
 * @param includeReceipt Determines if this method should return the receipts for this app.
 * @return If the includeReceipt parameter is set to true, this string contains XML that represents all receipts for the app and any in-app purchases. If includeReceipt is set to false, this string is empty.
 */
static requestAppPurchaseAsync(
includeReceipt: boolean): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Requests the purchase of an in-app product. Additionally, calling this method displays the UI that is used to complete the transaction via the Windows Store.
 * @param productId Specifies the id of the in-app product.
 * @return The results of the in-app product purchase request.
 */
static requestProductPurchaseAsync(
productId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$PurchaseResults>;

/**
 * Requests the purchase of an in-app product. Additionally, calling this method displays the UI that is used to complete the transaction via the Windows Store.
 * @param productId Specifies the id of the in-app product.
 * @param offerId The specific in-app feature or content within the large purchase catalog represented on the Windows Store by the productId. This value correlates with the content your app is responsible for fulfilling. The Windows Store only uses this value to itemize the PurchaseResults .
 * @param displayProperties The name of the app feature or content offer that is displayed to the user at time of purchase.
 * @return The results of the in-app product purchase request.
 */
static requestProductPurchaseAsync(
productId: string,
offerId: string,
displayProperties: Windows$ApplicationModel$Store$ProductPurchaseDisplayProperties): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$PurchaseResults>;

/**
 * Requests the purchase of an in-app product. Additionally, calling this method displays the UI that is used to complete the transaction via the Windows Store.
 * @param productId Specifies the id of the in-app product.
 * @param includeReceipt Determines if the method should return the receipts for the specified productId.
 * @return A string providing in-app transaction details for the provided productId. If includeReceipt is set true, the returned string will include a full receipt xml.
 */
static requestProductPurchaseAsync(
productId: string,
includeReceipt: boolean): Windows$Foundation$IPromiseWithIAsyncOperation<string>
}


/**
 * Defines methods and properties used to instantiate an object that you can use to get simulated license info during testing.
 */
declare class Windows$ApplicationModel$Store$CurrentAppSimulator  {

/**
 * Gets a simulated app ID. Since CurrentAppSimulator is intended only for testing during app development, the returned CurrentAppSimulator.AppId will contain only 0's.
 */
static appId: string;

/**
 * Retrieves the promotion campaign ID for the current app.
 * @return The advertising campaign ID for your app.
 */
static getAppPurchaseCampaignIdAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Creates the async operation that the user can use to simulate requesting all receipts for this app and any in-app product purchases. For examples of how receipt information can be used, see Using receipts to verify product purchases.
 * @return An XML-formatted string that contains all receipts for this app and any in-app product purchases.
 */
static getAppReceiptAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Creates the async operation that the user can use to simulate requesting the receipt for the specified productId. For examples of how receipt information can be used, see Using receipts to verify product purchases.
 * @param productId The unique identifier for the product. This ID is that was specified when the product was submitted for the app to the Store.
 * @return An XML-formatted string that contains the receipt for the specified productId.
 */
static getProductReceiptAsync(productId: string): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Returns a list of purchased consumable in-app products that have not been fulfilled locally.
 * @return When the operation completes, a list of unfulfilled consumable in-app products ( UnfulfilledConsumable objects) is returned. Each item in this list provides the product ID, offer ID, and transaction ID associated with a product.
 */
static getUnfulfilledConsumablesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the simulated license metadata for the current app as provided by the simulation.
 */
static licenseInformation: Windows$ApplicationModel$Store$LicenseInformation;

/**
 * Gets the simulated Uniform Resource Identifier (URI) that represents a Windows Store listing page for the current app.
 */
static linkUri: Windows$Foundation$Uri;

/**
 * Loads the simulated app listing information asynchronously. Implements the IAsyncInfo interface.
 * @return The app listing information as defined by the simulation. If the method fails, it returns an HRESULT error code.
 */
static loadListingInformationAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$ListingInformation>;

/**
 * Windows Phone only. Loads the simulated app listing information asynchronously, returning in-app products in the ProductListings collection that match all supplied keywords. Implements the IAsyncInfo interface.
 * @param keywords The list of keywords by which to filter the ProductListings collection that is returned in the ListingInformation object.
 * @return The simulated app listing information, with ProductListings collection filtered by keywords. If the method fails, it returns an HRESULT error code. If no in-app products are found that match all of the given keywords, the ProductListings collection will be empty.
 */
static loadListingInformationByKeywordsAsync(
keywords: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$ListingInformation>;

/**
 * Windows Phone only. Loads the simulated app listing information asynchronously, returning available in-app products in the ProductListings collection that match any of the given products IDs. This method implements the IAsyncInfo interface.
 * @param productIds The list of product IDs by which to filter the ProductListings collection.
 * @return The simulated app listing information, with ProductListings collection filtered by product IDs. If the method fails, it returns an HRESULT error code. If no in-app products are found that match the given product IDs, the ProductListings collection will be empty.
 */
static loadListingInformationByProductIdsAsync(
productIds: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$ListingInformation>;

/**
 * Reloads the simulator using a StorageFile containing the WindowsStoreProxy.xml file.
 * @param simulatorSettingsFile The WindowsStoreProxy.xml file that the simulator uses. For more information, see CurrentAppSimulator .
 * @return The async operation that reloads the simulator.
 */
static reloadSimulatorAsync(
simulatorSettingsFile: Windows$Storage$StorageFile): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Simulates notifying the Windows Store that the purchase of a consumable in-app product is fulfilled and that the user has the right to access the content.
 * @param productId Identifies the consumable in-app product.
 * @param transactionId Identifies a simulated transaction that includes the purchase of the consumable in-app product ( productId).
 * @return A value that indicates the status of fulfillment for a simulated consumable in-app product purchase.
 */
static reportConsumableFulfillmentAsync(
productId: string,
transactionId: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$ApplicationModel$Store$FulfillmentResult>>;

/**
 * Creates the async operation that simulates a user request to buy a full license for the current app.
 * @param includeReceipt Determines if the method should return the receipts for this app.
 * @return If the includeReceipt parameter is set to true, this string contains XML that represents all receipts for the app and any in-app product purchases. If includeReceipt is set to false, this string is empty.
 */
static requestAppPurchaseAsync(
includeReceipt: boolean): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Creates the async operation that displays the UI that is used to simulate the purchase of in-app product from the Windows Store.
 * @param productId Specifies the id, as defined by the simulation, of the in-app product to buy.
 * @return A PurchaseResults object containing transaction details for the provided productId.
 */
static requestProductPurchaseAsync(
productId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$PurchaseResults>;

/**
 * Creates the async operation that displays the UI that is used to simulate the purchase of an in-app product from the Windows Store.
 * @param productId The product ID used for listing in the Windows Store.
 * @param offerId The specific in-app product within the large purchase catalog represented on the Windows Store by the productId. This value correlates with the content your app is responsible for fulfilling. The Windows Store only uses this parameter value to itemize the PurchaseResults .
 * @param displayProperties The name of the in-app product that is displayed to the user at time of purchase.
 * @return The results of the in-app product purchase.
 */
static requestProductPurchaseAsync(
productId: string,
offerId: string,
displayProperties: Windows$ApplicationModel$Store$ProductPurchaseDisplayProperties): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$PurchaseResults>;

/**
 * Creates the async operation that displays the UI that is used to simulate the purchase of an in-app product from the Windows Store.
 * @param productId Specifies the id, as defined by the simulation, of the in-app product to buy.
 * @param includeReceipt Determines if the method should return the receipts for the specified productId.
 * @return A string providing in-app product purchase details for the provided productId. If includeReceipt is set true, the returned string will include a full receipt xml.
 */
static requestProductPurchaseAsync(
productId: string,
includeReceipt: boolean): Windows$Foundation$IPromiseWithIAsyncOperation<string>
}


/**
 * Defines values used to indicate fulfillment status for a consumable in-app product.
 */

declare  var Windows$ApplicationModel$Store$FulfillmentResult: {|
  +succeeded: 0,// 0
+nothingToFulfill: 1,// 1
+purchasePending: 2,// 2
+purchaseReverted: 3,// 3
+serverError: 4,// 4

|};



/**
 * Provides access to the current app's license metadata.
 */
declare class Windows$ApplicationModel$Store$LicenseInformation  {

/**
 * Gets the license expiration date and time relative to the system clock.
 */
expirationDate: Date;

/**
 * Gets a value that indicates whether the license is active.
 */
isActive: boolean;

/**
 * Gets a value that indicates whether the license is a trial license.
 */
isTrial: boolean;

/**
 * Raises a notification event when the status of the app's license changes.
 */
onlicensechanged: Windows$ApplicationModel$Store$LicenseChangedEventHandler;
addEventListener(
type: "licensechanged",
listener: Windows$ApplicationModel$Store$LicenseChangedEventHandler): void;
removeEventListener(
type: "licensechanged",
listener: Windows$ApplicationModel$Store$LicenseChangedEventHandler): void;

/**
 * Gets the associative list of licenses for in-app products that a user is currently entitled to.
 */
productLicenses: Windows$Foundation$Collections$IMapView<string, Windows$ApplicationModel$Store$ProductLicense>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides the listing info that describes the app in the Windows Store.
 */
declare class Windows$ApplicationModel$Store$ListingInformation  {

/**
 * Gets the age rating for the app.
 */
ageRating: number;
currencyCode: any;

/**
 * Gets the country code associated with the user's location, such as US or CA, that is used to identify their market for transactions in the current session.
 */
currentMarket: string;

/**
 * Gets the app's description in the current market.
 */
description: string;
formattedBasePrice: any;

/**
 * Gets the app's purchase price formatted for the current market and currency.
 */
formattedPrice: string;
isOnSale: any;

/**
 * Gets the app's name in the current market.
 */
name: string;

/**
 * Gets information about in-app products available for purchase.
 */
productListings: Windows$Foundation$Collections$IMapView<string, Windows$ApplicationModel$Store$ProductListing>;
saleEndDate: any
}


      declare var npm$namespace$Windows$ApplicationModel$Store$Preview: {
        
        
        StorePreviewProductPurchaseStatus: typeof Windows$ApplicationModel$Store$Preview$StorePreviewProductPurchaseStatus,
StoreSystemFeature: typeof Windows$ApplicationModel$Store$Preview$StoreSystemFeature,
        StoreConfiguration: typeof Windows$ApplicationModel$Store$Preview$StoreConfiguration,
StoreHardwareManufacturerInfo: typeof Windows$ApplicationModel$Store$Preview$StoreHardwareManufacturerInfo,
StorePreview: typeof Windows$ApplicationModel$Store$Preview$StorePreview,
StorePreviewProductInfo: typeof Windows$ApplicationModel$Store$Preview$StorePreviewProductInfo,
StorePreviewPurchaseResults: typeof Windows$ApplicationModel$Store$Preview$StorePreviewPurchaseResults,
StorePreviewSkuInfo: typeof Windows$ApplicationModel$Store$Preview$StorePreviewSkuInfo,
        InstallControl: typeof npm$namespace$Windows$ApplicationModel$Store$Preview$InstallControl,
      }

      declare var npm$namespace$Windows$ApplicationModel$Store$Preview$InstallControl: {
        
        
        AppInstallState: typeof Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallState,
AppInstallType: typeof Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallType,
AutoUpdateSetting: typeof Windows$ApplicationModel$Store$Preview$InstallControl$AutoUpdateSetting,
        AppInstallItem: typeof Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem,
AppInstallManager: typeof Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManager,
AppInstallManagerItemEventArgs: typeof Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManagerItemEventArgs,
AppInstallStatus: typeof Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallStatus,
        
      }

/**
 * Represents an app that is in the installation queue.
 */
declare class Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem  {

/**
 * Cancels the installation of the current app.
 */
cancel(): void;

/**
 * Cancels the installation of the current app, with the option to generate telemetry data.
 * @param correlationVector A correlation vector string that can be used to generate telemetry data.
 */
cancel(correlationVector: string): void;

/**
 * Gets the installation status of the current app.
 * @return A value that specifies the installation status of the current app.
 */
getCurrentStatus(): Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallStatus;

/**
 * Gets the type of the current app install.
 */
installType: $Values<typeof Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallType>;

/**
 * Indicates whether the current app install was initiated by the user.
 */
isUserInitiated: boolean;

/**
 * Occurs when the installation of the current app has finished.
 */
oncompleted: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem, any>;
addEventListener(
type: "completed",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem, any>): void;
removeEventListener(
type: "completed",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem, any>): void;

/**
 * Occurs when the installation status of the current app has changed.
 */
onstatuschanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem, any>;
addEventListener(
type: "statuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem, any>): void;
removeEventListener(
type: "statuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem, any>): void;

/**
 * Gets the package family name for the current app.
 */
packageFamilyName: string;

/**
 * Pauses the installation of the current app.
 */
pause(): void;

/**
 * Pauses the installation of the current app, with the option to generate telemetry data.
 * @param correlationVector A correlation vector string that can be used to generate telemetry data.
 */
pause(correlationVector: string): void;

/**
 * Gets the product ID for the current app.
 */
productId: string;

/**
 * Restarts the installation of the current app.
 */
restart(): void;

/**
 * Restarts the installation of the current app, with the option to generate telemetry data.
 * @param correlationVector A correlation vector string that can be used to generate telemetry data.
 */
restart(correlationVector: string): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides members for programmatically installing apps, including the ability to start an app install and get a list of app installs currently in progress.
 */
declare class Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManager  {

/**
 * Creates and initializes a new instance of the AppInstallManager class
 */
constructor(): this;

/**
 * Gets or sets the user identity associated with the app installs.
 */
acquisitionIdentity: string;

/**
 * Retrieves information about all apps that are currently in the installation queue.
 */
appInstallItems: Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem>;

/**
 * Gets or sets the auto update setting for apps on the current computer or device.
 */
autoUpdateSetting: $Values<typeof Windows$ApplicationModel$Store$Preview$InstallControl$AutoUpdateSetting>;

/**
 * Cancels the installation of the specified app.
 * @param productId The product ID of the app whose installation should be canceled.
 */
cancel(productId: string): void;

/**
 * Cancels the installation of the specified app, with the option to generate telemetry data.
 * @param productId The product ID of the app whose installation should be canceled.
 * @param correlationVector A correlation vector string that can be used to generate telemetry data.
 */
cancel(productId: string, correlationVector: string): void;

/**
 * Determines whether the specified app has permission to install on the current computer or device.
 * @param productId The product ID of the app that this method will check to determine if it has permission to be installed.
 * @return An asynchronous operation that, on successful completion, returns true if the app has permission to be installed; otherwise false.
 */
getIsAppAllowedToInstallAsync(productId: string): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Determines whether the specified app has permission to install on the current computer or device, with the option to generate telemetry data.
 * @param productId The product ID of the app that this method will check to determine if it has permission to be installed.
 * @param skuId The SKU ID of the app that this method will check to determine if it has permission to be installed.
 * @param catalogId The catalog ID of the app that this method will check to determine if it has permission to be installed.
 * @param correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return An asynchronous operation that, on successful completion, returns true if the app has permission to be installed; otherwise false.
 */
getIsAppAllowedToInstallAsync(
productId: string,
skuId: string,
catalogId: string,
correlationVector: string): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Determines whether the specified app can be installed on the current computer or device.
 * @param productId The product ID of the app that this method will check to determine if it can be installed.
 * @param skuId The SKU ID of the app that this method will check to determine if it can be installed.
 * @return An asynchronous operation that, on successful completion, returns true if the app can be installed; otherwise false.
 */
getIsApplicableAsync(
productId: string,
skuId: string): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Determines whether the specified app is blocked by policy on the current computer or device.
 * @param storeClientName The name of the app that this method will check to determine if is blocked by policy.
 * @param storeClientPublisher The publisher name of the app that this method will check to determine if is blocked by policy.
 * @return An asynchronous operation that, on successful completion, returns true if the app can be installed; otherwise false.
 */
isStoreBlockedByPolicyAsync(
storeClientName: string,
storeClientPublisher: string): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Occurs when an app has finished installing.
 */
onitemcompleted: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManager, Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManagerItemEventArgs>;
addEventListener(
type: "itemcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManager, Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManagerItemEventArgs>): void;
removeEventListener(
type: "itemcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManager, Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManagerItemEventArgs>): void;

/**
 * Occurs when the status of an app in the installation queue has changed.
 */
onitemstatuschanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManager, Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManagerItemEventArgs>;
addEventListener(
type: "itemstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManager, Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManagerItemEventArgs>): void;
removeEventListener(
type: "itemstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManager, Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManagerItemEventArgs>): void;

/**
 * Pauses the installation of the specified app.
 * @param productId The product ID of the app whose installation should be paused.
 */
pause(productId: string): void;

/**
 * Pauses the installation of the specified app, with the option to generate telemetry data.
 * @param productId The product ID of the app whose installation should be paused.
 * @param correlationVector A correlation vector string that can be used to generate telemetry data.
 */
pause(productId: string, correlationVector: string): void;

/**
 * Restarts the installation of the specified app.
 * @param productId The product ID of the app whose installation should be restarted.
 */
restart(productId: string): void;

/**
 * Restarts the installation of the specified app, with the option to generate telemetry data.
 * @param productId The product ID of the app whose installation should be restarted.
 * @param correlationVector A correlation vector string that can be used to generate telemetry data.
 */
restart(productId: string, correlationVector: string): void;

/**
 * Searches for all available updates to apps installed on the current computer or device.
 * @return An asynchronous operation that, on successful completion, returns the collection of apps that have available updates. If you use Asynchronous programming, the result type is a read-only list/vector of AppInstallItem items. (You can use APIs of IVectorView<AppInstallItem> for C++ or JavaScript, APIs of IReadOnlyList<AppInstallItem> for .NET.)
 */
searchForAllUpdatesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Searches for all available updates to apps installed on the current computer or device, with the option to generate telemetry data.
 * @param correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return An asynchronous operation that, on successful completion, returns the collection of apps that have available updates. If you use Asynchronous programming, the result type is a read-only list/vector of AppInstallItem items. (You can use APIs of IVectorView<AppInstallItem> for C++ or JavaScript, APIs of IReadOnlyList<AppInstallItem> for .NET.)
 */
searchForAllUpdatesAsync(
correlationVector: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Searches for updates for the specified app.
 * @param productId The product ID of the app to be queried for updates.
 * @param skuId The SKU to be queried for updates.
 * @return An asynchronous operation that, on successful completion, returns an AppInstallItem that represents the available update.
 */
searchForUpdatesAsync(
productId: string,
skuId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem>;

/**
 * Searches for updates for the specified app, with the option to generate telemetry data.
 * @param productId The product ID of the app to be queried for updates.
 * @param skuId The SKU ID of the app to be queried for updates.
 * @param catalogId The catalog ID of the app to be queried for updates.
 * @param correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return An asynchronous operation that, on successful completion, returns an AppInstallItem that represents the available update.
 */
searchForUpdatesAsync(
productId: string,
skuId: string,
catalogId: string,
correlationVector: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem>;

/**
 * Starts the installation of the specified app.
 * @param productId The product ID of the app to install.
 * @param skuId The SKU ID of the app to install.
 * @param repair True to attempt to repair the installation of an app that is already installed; otherwise, false.
 * @param forceUseOfNonRemovableStorage True to install the app to non-removable storage even if the user has configured apps to install to SD card; false to install the app to non-removable storage or SD card according to the user's settings.
 * @return An asynchronous operation that, on successful completion, returns an AppInstallItem that represents the app that was added to the installation queue.
 */
startAppInstallAsync(
productId: string,
skuId: string,
repair: boolean,
forceUseOfNonRemovableStorage: boolean): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem>;

/**
 * Starts the installation of the specified app, with the option to generate telemetry data.
 * @param productId The product ID of the app to install.
 * @param skuId The SKU ID of the app to install.
 * @param repair True to attempt to repair the installation of an app that is already installed; otherwise, false.
 * @param forceUseOfNonRemovableStorage True to install the app to non-removable storage even if the user has configured apps to install to SD card; false to install the app to non-removable storage or SD card according to the user's settings.
 * @param catalogId The catalog ID of the app to install.
 * @param bundleId The bundle ID of the app to install.
 * @param correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return An asynchronous operation that, on successful completion, returns an AppInstallItem that represents the app that was added to the installation queue.
 */
startAppInstallAsync(
productId: string,
skuId: string,
repair: boolean,
forceUseOfNonRemovableStorage: boolean,
catalogId: string,
bundleId: string,
correlationVector: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem>;

/**
 * Starts the update of an app specified by the package family name.
 * @param packageFamilyName The package family name of the app to update.
 * @return An asynchronous operation that, on successful completion, returns an AppInstallItem that represents the app update that was added to the installation queue.
 */
updateAppByPackageFamilyNameAsync(
packageFamilyName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem>;

/**
 * Starts the update of an app specified by the package family name, with the option to generate telemetry data.
 * @param packageFamilyName The package family name of the app to update.
 * @param correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return An asynchronous operation that, on successful completion, returns an AppInstallItem that represents the app update that was added to the installation queue.
 */
updateAppByPackageFamilyNameAsync(
packageFamilyName: string,
correlationVector: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the ItemCompleted and ItemStatusChanged events.
 */
declare class Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallManagerItemEventArgs  {

/**
 * Gets an object that describes the app that has finished installing (for the ItemCompleted event) or whose installation status has changed (for the ItemStatusChanged event).
 */
item: Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallItem
}


/**
 * Defines the app install states that are returned by the InstallState property of the AppInstallStatus class.
 */

declare  var Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallState: {|
  +pending: 0,// 0
+starting: 1,// 1
+acquiringLicense: 2,// 2
+downloading: 3,// 3
+restoringData: 4,// 4
+installing: 5,// 5
+completed: 6,// 6
+canceled: 7,// 7
+paused: 8,// 8
+error: 9,// 9
+pausedLowBattery: 10,// 10
+pausedWiFiRecommended: 11,// 11
+pausedWiFiRequired: 12,// 12
+readyToDownload: 13,// 13

|};



/**
 * Describes the status of an app that is in the installation queue.
 */
declare class Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallStatus  {

/**
 * Gets the number of bytes that have been downloaded for the current app.
 */
bytesDownloaded: number;

/**
 * Gets the download size in bytes for the current app.
 */
downloadSizeInBytes: number;

/**
 * Gets the error code for an app that has encountered an installation failure.
 */
errorCode: Windows$WinRTError;

/**
 * Gets the installation state of the current app.
 */
installState: $Values<typeof Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallState>;

/**
 * Gets the completion percentage for the installation of the current app.
 */
percentComplete: number
}


/**
 * Defines the different app install types that are returned by the InstallType property of the AppInstallItem class.
 */

declare  var Windows$ApplicationModel$Store$Preview$InstallControl$AppInstallType: {|
  +install: 0,// 0
+update: 1,// 1
+repair: 2,// 2

|};



/**
 * Defines the automatic app update setting values that can be returned by the AutoUpdateSetting property of the AppInstallManager class.
 */

declare  var Windows$ApplicationModel$Store$Preview$InstallControl$AutoUpdateSetting: {|
  +disabled: 0,// 0
+enabled: 1,// 1
+disabledByPolicy: 2,// 2
+enabledByPolicy: 3,// 3

|};



/**
 * Defines static methods and properties for accessing information about the device hardware and configuring information about the system, the mobile operator, and the active user account. These members are used in various Windows Store scenarios.
 */
declare class Windows$ApplicationModel$Store$Preview$StoreConfiguration  {

/**
 * Given a list of hardware features, this method returns a modified list that contains only the hardware features that are supported on the current device.
 * @param systemFeatures A list of StoreSystemFeature objects that represent the hardware features to be queried on the current device.
 * @return An asynchronous operation that, on successful completion, returns a list of hardware features that are supported on the current device. If you use Asynchronous programming, the result type is a read-only list/vector of StoreSystemFeature items. (You can use APIs of IVectorView<StoreSystemFeature> for C++ or JavaScript, APIs of IReadOnlyList<StoreSystemFeature> for .NET.)
 */
static filterUnsupportedSystemFeaturesAsync(
systemFeatures: Windows$Foundation$Collections$IIterable<$Values<typeof Windows$ApplicationModel$Store$Preview$StoreSystemFeature>>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets hardware manufacturer information for the current device.
 */
static hardwareManufacturerInfo: Windows$ApplicationModel$Store$Preview$StoreHardwareManufacturerInfo;

/**
 * Determines whether a given user ID is also being used to sign in to the Windows Store. Typically, this method is used to determine whether a user ID that is currently signed in to an app is also signed in to the Windows Store.
 * @param webAccountId The user ID (typically obtained from the WebAccount.Id property) to check.
 * @return True if the user account specified by webAccountId is the same account that is signed in to the Windows Store; otherwise false.
 */
static isStoreWebAccountId(webAccountId: string): boolean;

/**
 * Gets or sets a value that indicates whether the Windows Store prompts the user before making a purchase.
 */
static purchasePromptingPolicy: number;

/**
 * Configures mobile operator information for the device.
 * @param mobileOperatorId The mobile operator ID.
 * @param appDownloadLimitInMegabytes The maximum app download size defined by the mobile operator, in MB.
 * @param updateDownloadLimitInMegabytes The maximum OS update download size defined by the mobile operator, in MB.
 */
static setMobileOperatorConfiguration(
mobileOperatorId: string,
appDownloadLimitInMegabytes: number,
updateDownloadLimitInMegabytes: number): void;

/**
 * Sets the ID of the user account that is signed in to the Windows Store so that other apps can query against this ID.
 * @param webAccountId The user account ID (typically obtained from the WebAccount.Id property) that is signed in to the Windows Store.
 */
static setStoreWebAccountId(webAccountId: string): void;

/**
 * Configures miscellaneous system information for the device.
 * @param catalogHardwareManufacturerId The ID of the hardware manufacturer.
 * @param catalogStoreContentModifierId The ID of the Windows Store content modifier.
 * @param systemConfigurationExpiration The expiration date for the system configuration.
 * @param catalogHardwareDescriptor A descriptor string that specifies the hardware components supported by the device.
 */
static setSystemConfiguration(
catalogHardwareManufacturerId: string,
catalogStoreContentModifierId: string,
systemConfigurationExpiration: Date,
catalogHardwareDescriptor: string): void
}


/**
 * Provides information about the manufacturer for the current device.
 */
declare class Windows$ApplicationModel$Store$Preview$StoreHardwareManufacturerInfo  {

/**
 * Gets the hardware manufacture ID for the current device.
 */
hardwareManufacturerId: string;

/**
 * Gets the name of the hardware manufacturer for the current device.
 */
manufacturerName: string;

/**
 * Gets the model name for the current device.
 */
modelName: string;

/**
 * Gets the ID of the Windows Store content modifier.
 */
storeContentModifierId: string
}


/**
 * Defines static methods for retrieving the in-app product SKUs available for the current app and requesting the purchase of an in-app product SKU for the app.
 */
declare class Windows$ApplicationModel$Store$Preview$StorePreview  {

/**
 * Retrieves the in-app products available for the current app asynchronously, including the available SKUs for each product.
 * @return An asynchronous operation that, on successful completion, returns the collection of in-app products for the current app (including the available SKUs for each product). If you use Asynchronous programming, the result type is a read-only list/vector of StorePreviewProductInfo items. (You can use APIs of IVectorView<StorePreviewProductInfo> for C++ or JavaScript, APIs of IReadOnlyList<StorePreviewProductInfo> for .NET.)
 */
static loadAddOnProductInfosAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Requests the purchase of a SKU for an in-app product that is associated with the current app. Calling this method displays the UI that is used to complete the transaction via the Windows Store.
 * @param productId Specifies the ID of the in-app product. This corresponds to the StorePreviewProductInfo.ProductId value and the StorePreviewSkuInfo.ProductId values for all SKUs of the in-app product.
 * @param skuId Specifies the ID of the SKU for the in-app product. This corresponds to the StorePreviewSkuInfo.SkuId value.
 * @return An asynchronous operation that, on successful completion, returns a StorePreviewPurchaseResults that contains the results of the in-app product purchase request.
 */
static requestProductPurchaseByProductIdAndSkuIdAsync(
productId: string,
skuId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Store$Preview$StorePreviewPurchaseResults>
}


/**
 * Provides information about an in-app product, including details about available SKUs.
 */
declare class Windows$ApplicationModel$Store$Preview$StorePreviewProductInfo  {

/**
 * Gets the description of the in-app product.
 */
description: string;

/**
 * Gets the ID of the in-app product.
 */
productId: string;

/**
 * Gets the type of the in-app product.
 */
productType: string;

/**
 * Gets information about the available SKUs for the in-app product.
 */
skuInfoList: Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Store$Preview$StorePreviewSkuInfo>;

/**
 * Gets the name of the in-app product that is displayed to customers.
 */
title: string
}


/**
 * Defines values that are used to indicate the transaction status when purchasing an in-app product SKU by using the RequestProductPurchaseByProductIdAndSkuIdAsync method.
 */

declare  var Windows$ApplicationModel$Store$Preview$StorePreviewProductPurchaseStatus: {|
  +succeeded: 0,// 0
+alreadyPurchased: 1,// 1
+notFulfilled: 2,// 2
+notPurchased: 3,// 3

|};



/**
 * Contains information about the results of a purchase transaction for an in-app product SKU that was purchased by using the RequestProductPurchaseByProductIdAndSkuIdAsync method.
 */
declare class Windows$ApplicationModel$Store$Preview$StorePreviewPurchaseResults  {

/**
 * Gets the current state of the purchase transaction for an in-app product SKU that was purchased by using the RequestProductPurchaseByProductIdAndSkuIdAsync method.
 */
productPurchaseStatus: $Values<typeof Windows$ApplicationModel$Store$Preview$StorePreviewProductPurchaseStatus>
}


/**
 * Provides information about the available SKUs for an in-app product.
 */
declare class Windows$ApplicationModel$Store$Preview$StorePreviewSkuInfo  {

/**
 * Gets the currency code for the current market.
 */
currencyCode: string;

/**
 * Gets custom developer data for the current SKU.
 */
customDeveloperData: string;

/**
 * Gets the description for the current SKU.
 */
description: string;

/**
 * Gets extended data for the current SKU.
 */
extendedData: string;

/**
 * Gets the current SKU's purchase price with the appropriate formatting for the current market.
 */
formattedListPrice: string;

/**
 * Gets the ID of the product that this SKU is associated with.
 */
productId: string;

/**
 * Gets the ID of this SKU.
 */
skuId: string;

/**
 * Gets a string that specifies the type of the in-app product SKU.
 */
skuType: string;

/**
 * Gets the name of the in-app product SKU that is displayed to customers.
 */
title: string
}


/**
 * Defines values that represent hardware features that can be queried for the current device by using the FilterUnsupportedSystemFeaturesAsync method.
 */

declare  var Windows$ApplicationModel$Store$Preview$StoreSystemFeature: {|
  +architectureX86: 0,// 0
+architectureX64: 1,// 1
+architectureArm: 2,// 2
+directX9: 3,// 3
+directX10: 4,// 4
+directX11: 5,// 5
+d3D12HardwareFL11: 6,// 6
+d3D12HardwareFL12: 7,// 7
+memory300MB: 8,// 8
+memory750MB: 9,// 9
+memory1GB: 10,// 10
+memory2GB: 11,// 11
+cameraFront: 12,// 12
+cameraRear: 13,// 13
+gyroscope: 14,// 14
+hover: 15,// 15
+magnetometer: 16,// 16
+nfc: 17,// 17
+resolution720P: 18,// 18
+resolutionWvga: 19,// 19
+resolutionWvgaOr720P: 20,// 20
+resolutionWxga: 21,// 21
+resolutionWvgaOrWxga: 22,// 22
+resolutionWxgaOr720P: 23,// 23

|};



/**
 * Provides info about a license that is associated with an in-app product.
 */
declare class Windows$ApplicationModel$Store$ProductLicense  {

/**
 * Gets the current expiration date and time of the in-app product license.
 */
expirationDate: Date;

/**
 * Indicates if the in-app product license is currently active.
 */
isActive: boolean;

/**
 * Indicates if the in-app product is consumable. A consumable product is a product that can be purchased, used, and purchased again.
 */
isConsumable: boolean;

/**
 * Gets the ID of an in-app product. This ID is used by the app to get info about the product or feature that is enabled when the customer buys it through an in-app purchase.
 */
productId: string
}


/**
 * Provides localized information that details an in-app product.
 */
declare class Windows$ApplicationModel$Store$ProductListing  {
currencyCode: any;

/**
 * Gets the description for the in-app product.
 */
description: string;
formattedBasePrice: any;

/**
 * Gets the purchase price for the in-app product with the appropriate formatting for the current market.
 */
formattedPrice: string;

/**
 * Gets the URI of the image associated with the in-app product.
 */
imageUri: Windows$Foundation$Uri;
isOnSale: any;

/**
 * Gets the list of keywords associated with the in-app product. These keywords are useful for filtering product lists by keyword, for example, when calling LoadListingInformationByKeywordsAsync .
 */
keywords: Windows$Foundation$Collections$IIterable<string>;

/**
 * Gets the descriptive name of the in-app product that is displayed customers in the current market.
 */
name: string;

/**
 * Gets the in-app product ID.
 */
productId: string;

/**
 * Gets the type of this in-app product. Possible values are defined by ProductType .
 */
productType: $Values<typeof Windows$ApplicationModel$Store$ProductType>;

/**
 * Gets the end date of the sale period for the in-app product.
 */
saleEndDate: Date;

/**
 * Gets the tag string that contains custom information about an in-app product.
 */
tag: string
}


/**
 * Used to provide the product name that is displayed to the user at time of purchase.
 */
declare class Windows$ApplicationModel$Store$ProductPurchaseDisplayProperties  {

/**
 * Creates an instance of ProductPurchaseDisplayProperties .
 */
constructor(): this;

/**
 * Creates an instance of ProductPurchaseDisplayProperties that includes the specified product name to display to the user.
 * @param name The product name displayed to the user.
 */
constructor(name: string): this;

/**
 * Windows Phone only. This is an internal product description.
 */
description: string;

/**
 * Windows Phone only. Gets or sets the location of an image used to represent the product at time of purchase.
 */
image: Windows$Foundation$Uri;

/**
 * Gets or sets the product name that is displayed to the user at time of purchase.
 */
name: string
}


/**
 * Defines values used to indicate the transaction status when purchasing an in-app product.
 */

declare  var Windows$ApplicationModel$Store$ProductPurchaseStatus: {|
  +succeeded: 0,// 0
+alreadyPurchased: 1,// 1
+notFulfilled: 2,// 2
+notPurchased: 3,// 3

|};



/**
 * Specifies the product type for an in-app product.
 */

declare  var Windows$ApplicationModel$Store$ProductType: {|
  +unknown: 0,// 0
+durable: 1,// 1
+consumable: 2,// 2

|};



/**
 * Contains information detailing the results of an in-app product purchase transaction.
 */
declare class Windows$ApplicationModel$Store$PurchaseResults  {

/**
 * A unique ID used to identify a specific in-app product within a large catalog.
 */
offerId: string;

/**
 * A full receipt that provides a transaction history for the purchase of an in-app product
 */
receiptXml: string;

/**
 * The current state of the purchase transaction for an in-app product.
 */
status: $Values<typeof Windows$ApplicationModel$Store$ProductPurchaseStatus>;

/**
 * A unique transaction ID associated with the purchase of a consumable in-app product.
 */
transactionId: string
}


/**
 * Contains purchase and product information for an unfulfilled consumable in-app product.
 */
declare class Windows$ApplicationModel$Store$UnfulfilledConsumable  {

/**
 * A unique ID used to identify a consumable in-app product within a large purchase catalog.
 */
offerId: string;

/**
 * A unique ID used to identify a consumable in-app product. This ID is used by the app to get info about the product or feature that is enabled when the customer buys it through an in-app purchase.
 */
productId: string;

/**
 * A unique ID used to identify the transaction that included the purchase of a consumable in-app product.
 */
transactionId: string
}


/**
 * Represents the method that will handle the LicenseChanged event.
 */
declare type Windows$ApplicationModel$Store$LicenseChangedEventHandler = (ev: Windows$WinRTEvent<void>) => void;


/**
 * Manages a delayed app suspending operation.
 */
declare class Windows$ApplicationModel$SuspendingDeferral  {

/**
 * Notifies the operating system that the app has saved its data and is ready to be suspended.
 */
complete(): void
}


/**
 * Provides data for an app suspending event.
 */
declare class Windows$ApplicationModel$SuspendingEventArgs  {

/**
 * Gets the app suspending operation.
 */
suspendingOperation: Windows$ApplicationModel$SuspendingOperation
}


/**
 * Provides info about an app suspending operation.
 */
declare class Windows$ApplicationModel$SuspendingOperation  {

/**
 * Gets the time remaining before a delayed app suspending operation continues.
 */
deadline: Date;

/**
 * Requests that the app suspending operation be delayed.
 * @return The suspension deferral.
 */
getDeferral(): Windows$ApplicationModel$SuspendingDeferral
}


      declare var npm$namespace$Windows$ApplicationModel$UserDataAccounts: {
        
        
        UserDataAccountContentKinds: typeof Windows$ApplicationModel$UserDataAccounts$UserDataAccountContentKinds,
UserDataAccountOtherAppReadAccess: typeof Windows$ApplicationModel$UserDataAccounts$UserDataAccountOtherAppReadAccess,
UserDataAccountStoreAccessType: typeof Windows$ApplicationModel$UserDataAccounts$UserDataAccountStoreAccessType,
        UserDataAccount: typeof Windows$ApplicationModel$UserDataAccounts$UserDataAccount,
UserDataAccountManager: typeof Windows$ApplicationModel$UserDataAccounts$UserDataAccountManager,
UserDataAccountStore: typeof Windows$ApplicationModel$UserDataAccounts$UserDataAccountStore,
        SystemAccess: typeof npm$namespace$Windows$ApplicationModel$UserDataAccounts$SystemAccess,
      }

      declare var npm$namespace$Windows$ApplicationModel$UserDataAccounts$SystemAccess: {
        
        
        DeviceAccountServerType: typeof Windows$ApplicationModel$UserDataAccounts$SystemAccess$DeviceAccountServerType,
        DeviceAccountConfiguration: typeof Windows$ApplicationModel$UserDataAccounts$SystemAccess$DeviceAccountConfiguration,
UserDataAccountSystemAccessManager: typeof Windows$ApplicationModel$UserDataAccounts$SystemAccess$UserDataAccountSystemAccessManager,
        
      }

/**
 * Represents device settings for app sync relationships.
 */
declare class Windows$ApplicationModel$UserDataAccounts$SystemAccess$DeviceAccountConfiguration  {

/**
 * Initializes a new instance of the DeviceAccountConfiguration class.
 */
constructor(): this;

/**
 * Gets or sets the name that identifies the device account.
 */
accountName: string;

/**
 * Gets or sets a Boolean value indicating if calendar syncing is enabled.
 */
calendarSyncEnabled: boolean;

/**
 * Gets or sets a Boolean value indicating if contacts syncing is enabled.
 */
contactsSyncEnabled: boolean;

/**
 * Gets or sets the value that identifies the device account type.
 */
deviceAccountTypeId: string;

/**
 * Gets or sets the network domain of the device.
 */
domain: string;

/**
 * Gets or sets the email address of the current user.
 */
emailAddress: string;

/**
 * Gets or sets a Boolean value indicating if email syncing is enabled.
 */
emailSyncEnabled: boolean;

/**
 * Gets or sets the incoming email server address.
 */
incomingServerAddress: string;

/**
 * Gets or sets the port number to use to connect to the incoming email server.
 */
incomingServerPort: number;

/**
 * Gets or sets a Boolean value indicating if Secure Sockets Layer (SSL) should be used when connecting to the incoming email server.
 */
incomingServerRequiresSsl: boolean;

/**
 * Gets or sets the username to use when connecting to the incoming email server.
 */
incomingServerUsername: string;

/**
 * Gets or sets the outgoing email server address.
 */
outgoingServerAddress: string;

/**
 * Gets or sets the port number to use to connect to the outgoing email server.
 */
outgoingServerPort: number;

/**
 * Gets or sets a Boolean value indicating if Secure Sockets Layer (SSL) should be used when connecting to the outgoing email server.
 */
outgoingServerRequiresSsl: boolean;

/**
 * Gets or sets the username to use when connecting to the outgoing email server.
 */
outgoingServerUsername: string;

/**
 * Gets or sets a value indicating the type of the server.
 */
serverType: $Values<typeof Windows$ApplicationModel$UserDataAccounts$SystemAccess$DeviceAccountServerType>
}


/**
 * Defines the server types for syncing.
 */

declare  var Windows$ApplicationModel$UserDataAccounts$SystemAccess$DeviceAccountServerType: {|
  +exchange: 0,// 0
+pop: 1,// 1
+imap: 2,// 2

|};



/**
 * Provides the ability to display the system UI for managing sync relationships.
 */
declare class Windows$ApplicationModel$UserDataAccounts$SystemAccess$UserDataAccountSystemAccessManager  {

/**
 * Asynchronously displays the system UI to manage the sync relationships for the specified accounts.
 * @param accounts The list of accounts to manage in the system UI.
 * @return Returns an updated list of accounts.
 */
static addAndShowDeviceAccountsAsync(
accounts: Windows$Foundation$Collections$IIterable<Windows$ApplicationModel$UserDataAccounts$SystemAccess$DeviceAccountConfiguration>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>
}


/**
 * Represents a user data account used to access email, contacts, calendars, and so on.
 */
declare class Windows$ApplicationModel$UserDataAccounts$UserDataAccount  {

/**
 * Asynchronously deletes all the contact, calendar and email data associated with the account.
 * @return An async action indicating success or failure.
 */
deleteAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the unique identifier for the type of the account.
 */
deviceAccountTypeId: string;

/**
 * Gets the enterprise identity associated with the user account.
 */
enterpriseId: string;

/**
 * Returns a collection of AppointmentCalendar instances associated with the UserDataAccount .
 * @return A collection of AppointmentCalendar instances associated with the UserDataAccount .
 */
findAppointmentCalendarsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Returns a collection of ContactAnnotationList instances associated with the UserDataAccount .
 * @return A collection of ContactAnnotationList instances associated with the UserDataAccount .
 */
findContactAnnotationListsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Returns a collection of ContactList instances associated with the UserDataAccount .
 * @return A collection of ContactList instances associated with the UserDataAccount .
 */
findContactListsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Returns a collection of EmailMailbox instances associated with the UserDataAccount .
 * @return A collection of EmailMailbox instances associated with the UserDataAccount .
 */
findEmailMailboxesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the icon associated with the UserDataAccount .
 */
icon: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets a string that uniquely identifies the UserDataAccount on the local device.
 */
id: string;

/**
 * Gets a Boolean value indicating if the user account data is encrypted when the device becomes locked.
 */
isProtectedUnderLock: boolean;

/**
 * Gets or sets a value indicating whether other apps on the device have read access to the UserDataAccount .
 */
otherAppReadAccess: $Values<typeof Windows$ApplicationModel$UserDataAccounts$UserDataAccountOtherAppReadAccess>;

/**
 * Gets the unique identifier for the app package that created the UserDataAccount .
 */
packageFamilyName: string;

/**
 * Asynchronously persists the UserDataAccount to the database.
 * @return Async action that indicates completion of the save operation.
 */
saveAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets or sets a user name associated with the UserDataAccount that is suitable for displaying.
 */
userDisplayName: string
}


/**
 * The type of user data content.
 */

declare  var Windows$ApplicationModel$UserDataAccounts$UserDataAccountContentKinds: {|
  +email: 0,// 0
+contact: 1,// 1
+appointment: 2,// 2

|};



/**
 * Provides APIs to interact with the users data accounts including those implemented by the operating system.
 */
declare class Windows$ApplicationModel$UserDataAccounts$UserDataAccountManager  {

/**
 * Asynchronously returns the UserDataAccountStore from the system.
 * @param storeAccessType Specifies the access type, such as read-only for all accounts or read/write for the calling app's accounts.
 * @return Returns the UserDataAccountStore .
 */
static requestStoreAsync(
storeAccessType: $Values<typeof Windows$ApplicationModel$UserDataAccounts$UserDataAccountStoreAccessType>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$UserDataAccounts$UserDataAccountStore>;

/**
 * This method shows the resolve message for an account error.
 * @param id The user data account ID.
 * @return An async action indicating success or failure.
 */
static showAccountErrorResolverAsync(id: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * This method shows the account settings.
 * @param id The user data account ID.
 * @return An async action indicating success or failure.
 */
static showAccountSettingsAsync(id: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Shows the add account UI.
 * @param contentKinds The type of user data content.
 * @return Returns the newly added or already existing account.
 */
static showAddAccountAsync(
contentKinds: $Values<typeof Windows$ApplicationModel$UserDataAccounts$UserDataAccountContentKinds>): Windows$Foundation$IPromiseWithIAsyncOperation<string>
}


/**
 * Specifies the rights granted to other apps for reading this UserDataAccount .
 */

declare  var Windows$ApplicationModel$UserDataAccounts$UserDataAccountOtherAppReadAccess: {|
  +systemOnly: 0,// 0
+full: 1,// 1

|};



/**
 * Represents a data store that contains user accounts.
 */
declare class Windows$ApplicationModel$UserDataAccounts$UserDataAccountStore  {

/**
 * Asynchronously creates a user data account.
 * @param userDisplayName A string containing the user name that is suitable for display.
 * @return Returns the newly created UserDataAccount .
 */
createAccountAsync(
userDisplayName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$UserDataAccounts$UserDataAccount>;

/**
 * Returns a collection of UserDataAccount objects from the store based on the UserDataAccountStoreAccessType value passed into RequestStoreAsync .
 * @return Returns the collection of user data accounts, scoped by access request.
 */
findAccountsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously gets the specified account.
 * @param id The Id string identifying the account.
 * @return Returns the UserDataAccount identified by the id parameter.
 */
getAccountAsync(
id: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$UserDataAccounts$UserDataAccount>
}


/**
 * Specifies the requested access type in a call to RequestStoreAsync .
 */

declare  var Windows$ApplicationModel$UserDataAccounts$UserDataAccountStoreAccessType: {|
  +allAccountsReadOnly: 0,// 0
+appAccountsReadWrite: 1,// 1

|};



      declare var npm$namespace$Windows$ApplicationModel$VoiceCommands: {
        
        
        VoiceCommandCompletionReason: typeof Windows$ApplicationModel$VoiceCommands$VoiceCommandCompletionReason,
VoiceCommandContentTileType: typeof Windows$ApplicationModel$VoiceCommands$VoiceCommandContentTileType,
        VoiceCommand: typeof Windows$ApplicationModel$VoiceCommands$VoiceCommand,
VoiceCommandCompletedEventArgs: typeof Windows$ApplicationModel$VoiceCommands$VoiceCommandCompletedEventArgs,
VoiceCommandConfirmationResult: typeof Windows$ApplicationModel$VoiceCommands$VoiceCommandConfirmationResult,
VoiceCommandContentTile: typeof Windows$ApplicationModel$VoiceCommands$VoiceCommandContentTile,
VoiceCommandDefinition: typeof Windows$ApplicationModel$VoiceCommands$VoiceCommandDefinition,
VoiceCommandDefinitionManager: typeof Windows$ApplicationModel$VoiceCommands$VoiceCommandDefinitionManager,
VoiceCommandDisambiguationResult: typeof Windows$ApplicationModel$VoiceCommands$VoiceCommandDisambiguationResult,
VoiceCommandResponse: typeof Windows$ApplicationModel$VoiceCommands$VoiceCommandResponse,
VoiceCommandServiceConnection: typeof Windows$ApplicationModel$VoiceCommands$VoiceCommandServiceConnection,
VoiceCommandUserMessage: typeof Windows$ApplicationModel$VoiceCommands$VoiceCommandUserMessage,
        
      }

/**
 * The command given to Cortana, using either speech or text, and routed to a background app.
 */
declare class Windows$ApplicationModel$VoiceCommands$VoiceCommand  {

/**
 * Gets the value of the Name attribute for the Command element declared in the Voice Command Definition (VCD) file.
 */
commandName: string;

/**
 * Gets a dictionary containing the semantic properties of the recognized phrase in the voice command.
 */
properties: Windows$Foundation$Collections$IMapView<string, Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the SpeechRecognitionResult object representing the results returned by the voice command.
 */
speechRecognitionResult: Windows$Media$SpeechRecognition$SpeechRecognitionResult
}


/**
 * Contains event data for the VoiceCommandCompleted event.
 */
declare class Windows$ApplicationModel$VoiceCommands$VoiceCommandCompletedEventArgs  {

/**
 * The reason the voice command completed.
 */
reason: $Values<typeof Windows$ApplicationModel$VoiceCommands$VoiceCommandCompletionReason>
}


/**
 * Specifies the possible reasons the voice command completed.
 */

declare  var Windows$ApplicationModel$VoiceCommands$VoiceCommandCompletionReason: {|
  +unknown: 0,// 0
+communicationFailed: 1,// 1
+resourceLimitsExceeded: 2,// 2
+canceled: 3,// 3
+timeoutExceeded: 4,// 4
+appLaunched: 5,// 5
+completed: 6,// 6

|};



/**
 * The response to the question specified by the background app and shown on the Cortana confirmation screen. This screen is displayed when the background app service calls RequestConfirmationAsync .
 */
declare class Windows$ApplicationModel$VoiceCommands$VoiceCommandConfirmationResult  {

/**
 * Gets the response to the question specified by the background app and shown on the Cortana confirmation screen.
 */
confirmed: boolean
}


/**
 * An asset, containing image, text, and link data, provided by the background app service for display on the Cortana canvas.
 */
declare class Windows$ApplicationModel$VoiceCommands$VoiceCommandContentTile  {

/**
 * Creates an instance of the VoiceCommandContentTile class.
 */
constructor(): this;

/**
 * Gets or sets supplementary information the background app service can associate with the content tile. This information is not used by Cortana.
 */
appContext: any;

/**
 * Gets or sets a string as a launch parameter that can be associated with the response by the background app service.
 */
appLaunchArgument: string;

/**
 * Gets or sets the layout template used to display the content tile on the Cortana canvas.
 */
contentTileType: $Values<typeof Windows$ApplicationModel$VoiceCommands$VoiceCommandContentTileType>;

/**
 * Gets or sets an image the background app service can associate with the content tile.
 */
image: Windows$Storage$IStorageFile;

/**
 * Gets or sets the first line of text the background app service can associate with the content tile.
 */
textLine1: string;

/**
 * Gets or sets the second line of text the background app service can associate with the content tile.
 */
textLine2: string;

/**
 * Gets or sets the third line of text the background app service can associate with the content tile.
 */
textLine3: string;

/**
 * Gets or sets the title the background app service can associate with the content tile.
 */
title: string
}


/**
 * The layout template used to display a content tile on the Cortana canvas.
 */

declare  var Windows$ApplicationModel$VoiceCommands$VoiceCommandContentTileType: {|
  +titleOnly: 0,// 0
+titleWithText: 1,// 1
+titleWith68x68Icon: 2,// 2
+titleWith68x68IconAndText: 3,// 3
+titleWith68x92Icon: 4,// 4
+titleWith68x92IconAndText: 5,// 5
+titleWith280x140Icon: 6,// 6
+titleWith280x140IconAndText: 7,// 7

|};



/**
 * Enables operations on a specific installed command set.
 */
declare class Windows$ApplicationModel$VoiceCommands$VoiceCommandDefinition  {

/**
 * Gets the language ( xml:lang ) value of the CommandSet element in the Voice Command Definition (VCD) file.
 */
language: string;

/**
 * Gets the Name attribute value of the CommandSet element in the Voice Command Definition (VCD) file.
 */
name: string;

/**
 * Populates a PhraseList element with an array of Item elements.
 * @param phraseListName The string that corresponds to the label attribute of the PhraseList element.
 * @param phraseList A string array of values that will be added to the PhraseList element as Item elements.
 * @return A string array of values that will be added to the PhraseList element as Item elements.
 */
setPhraseListAsync(
phraseListName: string,
phraseList: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * A static class that enables installing command sets from a Voice Command Definition (VCD) file, and getting installed command sets.
 */
declare class Windows$ApplicationModel$VoiceCommands$VoiceCommandDefinitionManager  {

/**
 * Installs the CommandSet elements in a Voice Command Definition (VCD) file.
 * @param file An object representing a VCD file.
 * @return An asynchronous handler called when the operation is complete.
 */
static installCommandDefinitionsFromStorageFileAsync(file: Windows$Storage$StorageFile): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * A dictionary that contains all installed command sets that have a Name attribute set in the Voice Command Definition (VCD) file.
 */
static installedCommandDefinitions: Windows$Foundation$Collections$IMapView<string, Windows$ApplicationModel$VoiceCommands$VoiceCommandDefinition>
}


/**
 * The result obtained from the disambiguation screen displayed on the Cortana canvas.
 */
declare class Windows$ApplicationModel$VoiceCommands$VoiceCommandDisambiguationResult  {

/**
 * The item selected from the list of items displayed on the Cortana disambiguation screen.
 */
selectedItem: Windows$ApplicationModel$VoiceCommands$VoiceCommandContentTile
}


/**
 * The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
 */
declare class Windows$ApplicationModel$VoiceCommands$VoiceCommandResponse  {

/**
 * Creates a VoiceCommandResponse object used in calls to ReportProgressAsync , ReportSuccessAsync or ReportFailureAsync .
 * @param message The message that is spoken by Cortana and shown on the Cortana canvas.
 * @param contentTiles The collection of assets, containing image and text data, shown on the Cortana canvas.
 * @return The response from the background app service for progress, completion, confirmation, or disambiguation screens displayed on the Cortana canvas.
 */
static createResponse(
message: Windows$ApplicationModel$VoiceCommands$VoiceCommandUserMessage,
contentTiles: Windows$Foundation$Collections$IIterable<Windows$ApplicationModel$VoiceCommands$VoiceCommandContentTile>): Windows$ApplicationModel$VoiceCommands$VoiceCommandResponse;

/**
 * Creates a VoiceCommandResponse object used in calls to ReportProgressAsync , ReportSuccessAsync or ReportFailureAsync .
 * @param userMessage The message that is spoken by Cortana and shown on the Cortana canvas.
 * @return The response from the background app service for progress, completion, confirmation, or disambiguation screens displayed on the Cortana canvas.
 */
static createResponse(
userMessage: Windows$ApplicationModel$VoiceCommands$VoiceCommandUserMessage): Windows$ApplicationModel$VoiceCommands$VoiceCommandResponse;

/**
 * Creates a VoiceCommandResponse object used in calls to RequestConfirmationAsync or RequestDisambiguationAsync .
 * @param message The initial message that is spoken by Cortana and shown on the Cortana canvas.
 * @param repeatMessage The secondary message that is spoken by Cortana and shown on the Cortana canvas, if a response was not understood.
 * @param contentTiles The collection of assets, containing image and text data, shown on the Cortana canvas.
 * @return The response from the background app service for progress, completion, confirmation, or disambiguation screens displayed on the Cortana canvas.
 */
static createResponseForPrompt(
message: Windows$ApplicationModel$VoiceCommands$VoiceCommandUserMessage,
repeatMessage: Windows$ApplicationModel$VoiceCommands$VoiceCommandUserMessage,
contentTiles: Windows$Foundation$Collections$IIterable<Windows$ApplicationModel$VoiceCommands$VoiceCommandContentTile>): Windows$ApplicationModel$VoiceCommands$VoiceCommandResponse;

/**
 * Creates a VoiceCommandResponse object used in calls to RequestConfirmationAsync or RequestDisambiguationAsync .
 * @param message The initial message that is spoken by Cortana and shown on the Cortana canvas.
 * @param repeatMessage The secondary message that is spoken by Cortana and shown on the Cortana canvas, if a response was not understood.
 * @return The response from the background app service for progress, completion, confirmation, or disambiguation screens displayed on the Cortana canvas.
 */
static createResponseForPrompt(
message: Windows$ApplicationModel$VoiceCommands$VoiceCommandUserMessage,
repeatMessage: Windows$ApplicationModel$VoiceCommands$VoiceCommandUserMessage): Windows$ApplicationModel$VoiceCommands$VoiceCommandResponse;

/**
 * Gets the maximum number of content tiles the background app service can display on the Cortana canvas.
 */
static maxSupportedVoiceCommandContentTiles: number;

/**
 * Gets or sets a string as a launch parameter that can be associated with the response by the background app service.
 */
appLaunchArgument: string;

/**
 * The initial message that is spoken by Cortana and shown on the Cortana canvas.
 */
message: Windows$ApplicationModel$VoiceCommands$VoiceCommandUserMessage;

/**
 * The secondary message (for disambiguation and confirmation screens only) that is spoken by Cortana and shown on the Cortana canvas, if a response was not understood.
 */
repeatMessage: Windows$ApplicationModel$VoiceCommands$VoiceCommandUserMessage;

/**
 * The collection of assets, containing image and text data, provided by the background app service for display on the Cortana canvas.
 */
voiceCommandContentTiles: Windows$Foundation$Collections$IVector<Windows$ApplicationModel$VoiceCommands$VoiceCommandContentTile>
}


/**
 * The background app service connection to Cortana.
 */
declare class Windows$ApplicationModel$VoiceCommands$VoiceCommandServiceConnection  {

/**
 * Retrieves a VoiceCommandServiceConnection object from the AppServiceTriggerDetails that contains info associated with the background task for the app service.
 * @param triggerDetails Contains info associated with the background task for the app service.
 * @return The background app service connection to Cortana.
 */
static fromAppServiceTriggerDetails(
triggerDetails: Windows$ApplicationModel$AppService$AppServiceTriggerDetails): Windows$ApplicationModel$VoiceCommands$VoiceCommandServiceConnection;

/**
 * Retrieves the voice command that the user submitted to Cortana by voice or text.
 * @return The VoiceCommand .
 */
getVoiceCommandAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$VoiceCommands$VoiceCommand>;

/**
 * Gets the locale for the voice command.
 */
language: Windows$Globalization$Language;

/**
 * Event raised when the voice command is completed and the background app service is about to be terminated.
 */
onvoicecommandcompleted: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$VoiceCommands$VoiceCommandServiceConnection, Windows$ApplicationModel$VoiceCommands$VoiceCommandCompletedEventArgs>;
addEventListener(
type: "voicecommandcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$VoiceCommands$VoiceCommandServiceConnection, Windows$ApplicationModel$VoiceCommands$VoiceCommandCompletedEventArgs>): void;
removeEventListener(
type: "voicecommandcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$VoiceCommands$VoiceCommandServiceConnection, Windows$ApplicationModel$VoiceCommands$VoiceCommandCompletedEventArgs>): void;

/**
 * Sends a response to Cortana indicating the voice command has failed.
 * @param response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
 * @return An asynchronous handler called when the operation is complete.
 */
reportFailureAsync(
response: Windows$ApplicationModel$VoiceCommands$VoiceCommandResponse): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Sends a response to Cortana indicating voice command is being processed.
 * @param response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
 * @return An asynchronous handler called when the operation is complete.
 */
reportProgressAsync(
response: Windows$ApplicationModel$VoiceCommands$VoiceCommandResponse): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Sends a response to Cortana indicating the voice command has succeeded.
 * @param response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
 * @return An asynchronous handler called when the operation is complete.
 */
reportSuccessAsync(
response: Windows$ApplicationModel$VoiceCommands$VoiceCommandResponse): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Sends a response to Cortana indicating the command should be handled by the app in the foreground.
 * @param response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
 * @return An asynchronous handler called when the operation is complete.
 */
requestAppLaunchAsync(
response: Windows$ApplicationModel$VoiceCommands$VoiceCommandResponse): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Sends a response to Cortana indicating the voice command requires confirmation.
 * @param response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
 * @return The VoiceCommandConfirmationResult object with the user's response.
 */
requestConfirmationAsync(
response: Windows$ApplicationModel$VoiceCommands$VoiceCommandResponse): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$VoiceCommands$VoiceCommandConfirmationResult>;

/**
 * Sends a response to Cortana indicating the voice command returned more than one result and requires the user to select one.
 * @param response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
 * @return The VoiceCommandDisambiguationResult object with the user's response.
 */
requestDisambiguationAsync(
response: Windows$ApplicationModel$VoiceCommands$VoiceCommandResponse): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$VoiceCommands$VoiceCommandDisambiguationResult>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * The message that is spoken by Cortana and shown on the Cortana canvas.
 */
declare class Windows$ApplicationModel$VoiceCommands$VoiceCommandUserMessage  {

/**
 * Creates an instance of the VoiceCommandUserMessage class.
 */
constructor(): this;

/**
 * Gets or sets the message that is shown on the Cortana canvas.
 */
displayMessage: string;

/**
 * The message that is spoken by Cortana.
 */
spokenMessage: string
}


      declare var npm$namespace$Windows$ApplicationModel$Wallet: {
        
        
        WalletActionKind: typeof Windows$ApplicationModel$Wallet$WalletActionKind,
WalletBarcodeSymbology: typeof Windows$ApplicationModel$Wallet$WalletBarcodeSymbology,
WalletDetailViewPosition: typeof Windows$ApplicationModel$Wallet$WalletDetailViewPosition,
WalletItemKind: typeof Windows$ApplicationModel$Wallet$WalletItemKind,
WalletSummaryViewPosition: typeof Windows$ApplicationModel$Wallet$WalletSummaryViewPosition,
        WalletBarcode: typeof Windows$ApplicationModel$Wallet$WalletBarcode,
WalletItem: typeof Windows$ApplicationModel$Wallet$WalletItem,
WalletItemCustomProperty: typeof Windows$ApplicationModel$Wallet$WalletItemCustomProperty,
WalletItemStore: typeof Windows$ApplicationModel$Wallet$WalletItemStore,
WalletManager: typeof Windows$ApplicationModel$Wallet$WalletManager,
WalletRelevantLocation: typeof Windows$ApplicationModel$Wallet$WalletRelevantLocation,
WalletTransaction: typeof Windows$ApplicationModel$Wallet$WalletTransaction,
WalletVerb: typeof Windows$ApplicationModel$Wallet$WalletVerb,
        System: typeof npm$namespace$Windows$ApplicationModel$Wallet$System,
      }

      declare var npm$namespace$Windows$ApplicationModel$Wallet$System: {
        
        
        WalletItemAppAssociation: typeof Windows$ApplicationModel$Wallet$System$WalletItemAppAssociation,
        WalletItemSystemStore: typeof Windows$ApplicationModel$Wallet$System$WalletItemSystemStore,
WalletManagerSystem: typeof Windows$ApplicationModel$Wallet$System$WalletManagerSystem,
        
      }

/**
 * Defines values used by the GetAppStatusForItem method indicating if an app is installed for the specified WalletItem .
 */

declare  var Windows$ApplicationModel$Wallet$System$WalletItemAppAssociation: {|
  +none: 0,// 0
+appInstalled: 1,// 1
+appNotInstalled: 2,// 2

|};



/**
 * Defines a set of asynchronous actions and operations that manage the wallet items in the system wallet database. These can be used to read the existing items, or to add and remove items.
 */
declare class Windows$ApplicationModel$Wallet$System$WalletItemSystemStore  {

/**
 * Asynchronously removes a specific wallet item with the given ID from the wallet system data store.
 * @param item The ID of the wallet item to remove from the system data store.
 * @return An asynchronous action. If you use Asynchronous programming, the result type is void.
 */
deleteAsync(
item: Windows$ApplicationModel$Wallet$WalletItem): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets a WalletItemAppAssociation value indicating if an app is installed for the specified WalletItem .
 * @param item The item for which to retrieve the status.
 * @return The WalletItemAppAssociation value indicating if an app is installed for the specified WalletItem specified by the item parameter.
 */
getAppStatusForItem(
item: Windows$ApplicationModel$Wallet$WalletItem): $Values<typeof Windows$ApplicationModel$Wallet$System$WalletItemAppAssociation>;

/**
 * Returns the collection of all system wallet items owned by this app.
 * @return An asynchronous operation that, on successful completion, returns the collection of wallet items accessible by this app. If you use Asynchronous programming, the result type is a read-only list/vector of WalletItem items. (You can use APIs of IVectorView<WalletItem> for C++ or JavaScript, APIs of IReadOnlyList<WalletItem> for .NET.)
 */
getItemsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Imports data from a ".mswallet" XML file into the system wallet store.
 * @param stream The ".mswallet" file to import.
 * @return An asynchronous operation that, on successful completion, returns the wallet item that was imported into the wallet. If you use Asynchronous programming, the result type on successful completion is a single WalletItem .
 */
importItemAsync(
stream: Windows$Storage$Streams$IRandomAccessStreamReference): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Wallet$WalletItem>;

/**
 * Launches the app that is associated with the given wallet item.
 * @param item The wallet item to launch an app for.
 * @return An async action indicating that the operation has completed.
 */
launchAppForItemAsync(
item: Windows$ApplicationModel$Wallet$WalletItem): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Occurs when items in the WalletItemSystemStore have changed.
 */
onitemschanged: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Wallet$System$WalletItemSystemStore, any>;
addEventListener(
type: "itemschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Wallet$System$WalletItemSystemStore, any>): void;
removeEventListener(
type: "itemschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$ApplicationModel$Wallet$System$WalletItemSystemStore, any>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides a static method to get an instance of the system wallet store for this app.
 */
declare class Windows$ApplicationModel$Wallet$System$WalletManagerSystem  {

/**
 * Requests an instance of the system wallet store for the app.
 * @return An asynchronous operation that, on successful completion, returns an instance of the default wallet store. If you use Asynchronous programming, the result type is a single WalletItemSystemStore object.
 */
static requestStoreAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Wallet$System$WalletItemSystemStore>
}


/**
 * Represents the action that was taken on the item that caused your app to launch.
 */

declare  var Windows$ApplicationModel$Wallet$WalletActionKind: {|
  +openItem: 0,// 0
+transaction: 1,// 1
+moreTransactions: 2,// 2
+message: 3,// 3
+verb: 4,// 4

|};



/**
 * Represents a bar code assigned to a wallet item.
 */
declare class Windows$ApplicationModel$Wallet$WalletBarcode  {

/**
 * Initializes a new instance of the WalletBarcode class.
 * @param streamToBarcodeImage A stream representing the bar code image.
 */
constructor(streamToBarcodeImage: Windows$Storage$Streams$IRandomAccessStreamReference): this;

/**
 * Initializes a new instance of the WalletBarcode class.
 * @param symbology The symbology type for this barcode. Use one of the supported symbologies, such as Upca. Don't set to Invalid or Custom.
 * @param value The message ( Value ) that the barcode represents.
 */
constructor(symbology: $Values<typeof Windows$ApplicationModel$Wallet$WalletBarcodeSymbology>, value: string): this;

/**
 * Creates and returns a bitmap image stream for the barcode (or returns the custom image used during instantiation).
 * @return An asynchronous operation. If you use Asynchronous programming, the result type on successful completion is an IRandomAccessStreamReference instance. This can be assigned as the source for an image (with some additional code).
 */
getImageAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStreamReference>;

/**
 * Gets the symbology used by the bar code.
 */
symbology: $Values<typeof Windows$ApplicationModel$Wallet$WalletBarcodeSymbology>;

/**
 * Gets a string representation of the barcode (its message).
 */
value: string
}


/**
 * Represents the barcode symbology types that are supported for a WalletItem .
 */

declare  var Windows$ApplicationModel$Wallet$WalletBarcodeSymbology: {|
  +invalid: 0,// 0
+upca: 1,// 1
+upce: 2,// 2
+ean13: 3,// 3
+ean8: 4,// 4
+itf: 5,// 5
+code39: 6,// 6
+code128: 7,// 7
+qr: 8,// 8
+pdf417: 9,// 9
+aztec: 10,// 10
+custom: 11,// 11

|};



/**
 * Describes the position in the detail view of a wallet item that a WalletItemCustomProperty record should be displayed at.
 */

declare  var Windows$ApplicationModel$Wallet$WalletDetailViewPosition: {|
  +hidden: 0,// 0
+headerField1: 1,// 1
+headerField2: 2,// 2
+primaryField1: 3,// 3
+primaryField2: 4,// 4
+secondaryField1: 5,// 5
+secondaryField2: 6,// 6
+secondaryField3: 7,// 7
+secondaryField4: 8,// 8
+secondaryField5: 9,// 9
+centerField1: 10,// 10
+footerField1: 11,// 11
+footerField2: 12,// 12
+footerField3: 13,// 13
+footerField4: 14,// 14

|};



/**
 * Represents an item (data) that is stored in the wallet.
 */
declare class Windows$ApplicationModel$Wallet$WalletItem  {

/**
 * Initializes a new instance of the WalletItem class.
 * @param kind The type of wallet item.
 * @param displayName The display name of the item.
 */
constructor(kind: $Values<typeof Windows$ApplicationModel$Wallet$WalletItemKind>, displayName: string): this;

/**
 * Gets or sets the barcode that's representative of the wallet item.
 */
barcode: Windows$ApplicationModel$Wallet$WalletBarcode;

/**
 * Gets or sets the background image of the body of the wallet item (uses a stream).
 */
bodyBackgroundImage: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets or sets the body color of the wallet item.
 */
bodyColor: Windows$UI$Color;

/**
 * Gets or sets the body font color of the wallet item.
 */
bodyFontColor: Windows$UI$Color;

/**
 * Gets or sets a string that appears next to the app name in About info.
 */
displayMessage: string;

/**
 * Gets or sets the name or title to be displayed to the user.
 */
displayName: string;

/**
 * Gets the collection of WalletItemCustomProperty objects associated with the wallet item.
 */
displayProperties: Windows$Foundation$Collections$IMap<string, Windows$ApplicationModel$Wallet$WalletItemCustomProperty>;

/**
 * Gets or sets the expiration date of the wallet item.
 */
expirationDate: Date;

/**
 * Gets or sets the header background image of the wallet item.
 */
headerBackgroundImage: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets or sets the header color of the wallet item.
 */
headerColor: Windows$UI$Color;

/**
 * Gets or sets the header font color of the wallet item.
 */
headerFontColor: Windows$UI$Color;

/**
 * Gets the unique identifier of the wallet item.
 */
id: string;

/**
 * Gets or sets whether this item is acknowledged by the app.
 */
isAcknowledged: boolean;

/**
 * Gets or sets whether to launch your app when the user taps on the DisplayMessage .
 */
isDisplayMessageLaunchable: boolean;

/**
 * Gets or sets whether your app should be launched when the user taps "see more transaction history".
 */
isMoreTransactionHistoryLaunchable: boolean;

/**
 * Gets or sets the issuer name of the wallet item.
 */
issuerDisplayName: string;

/**
 * Gets the type of the wallet item.
 */
kind: $Values<typeof Windows$ApplicationModel$Wallet$WalletItemKind>;

/**
 * Gets or sets the date and time the data for this item was last updated.
 */
lastUpdated: Date;

/**
 * Gets or sets the medium (159 x 159) logo image of the wallet item.
 */
logo159x159: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets or sets the large (336 x 336) logo image of the wallet item.
 */
logo336x336: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets or sets the small (99 x 99) logo image of the wallet item.
 */
logo99x99: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets or sets the logo image of the wallet item.
 */
logoImage: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets or sets the logo text of the wallet item.
 */
logoText: string;

/**
 * Gets or sets the promotional image of the wallet item.
 */
promotionalImage: Windows$Storage$Streams$IRandomAccessStreamReference;

/**
 * Gets or sets the date on which the item is valid.
 */
relevantDate: Date;

/**
 * Gets or sets the description of the relevant date of the wallet item.
 */
relevantDateDisplayMessage: string;

/**
 * Gets a collection of all relevant locations for the wallet item.
 */
relevantLocations: Windows$Foundation$Collections$IMap<string, Windows$ApplicationModel$Wallet$WalletRelevantLocation>;

/**
 * Gets the transaction history collection of the wallet item.
 */
transactionHistory: Windows$Foundation$Collections$IMap<string, Windows$ApplicationModel$Wallet$WalletTransaction>;

/**
 * Gets the collection of WalletVerb objects associated with the wallet item.
 */
verbs: Windows$Foundation$Collections$IMap<string, Windows$ApplicationModel$Wallet$WalletVerb>
}


/**
 * Defines a custom property on a wallet item. Apps can show data in the details view or back of card view of the item.
 */
declare class Windows$ApplicationModel$Wallet$WalletItemCustomProperty  {

/**
 * Initializes a new instance of the WalletItemCustomProperty class.
 * @param name The custom property label. Sets the initial Name value.
 * @param value The value of the property. Sets the initial Value value.
 */
constructor(name: string, value: string): this;

/**
 * Gets or sets whether this WalletItemCustomProperty is entity-extracted and actionable upon display.
 */
autoDetectLinks: boolean;

/**
 * Gets or sets the optional position of this property when shown in the wallet item's detail view.
 */
detailViewPosition: $Values<typeof Windows$ApplicationModel$Wallet$WalletDetailViewPosition>;

/**
 * Gets or sets the custom property label.
 */
name: string;

/**
 * Gets or sets the optional position of this property when shown in the summary view for a wallet item.
 */
summaryViewPosition: $Values<typeof Windows$ApplicationModel$Wallet$WalletSummaryViewPosition>;

/**
 * Gets or sets the custom property value.
 */
value: string
}


/**
 * Represents the kinds (classifications) of wallet items supported.
 */

declare  var Windows$ApplicationModel$Wallet$WalletItemKind: {|
  +invalid: 0,// 0
+deal: 1,// 1
+general: 2,// 2
+paymentInstrument: 3,// 3
+ticket: 4,// 4
+boardingPass: 5,// 5
+membershipCard: 6,// 6

|};



/**
 * Defines a set of asynchronous actions and operations that manage the wallet items in the wallet database. These can be used to read the existing items, or to add and remove items.
 */
declare class Windows$ApplicationModel$Wallet$WalletItemStore  {

/**
 * Adds a new wallet item to the wallet.
 * @param id The identifier of the wallet item. This value must be unique. This sets the initial WalletItem.Id value (the identifier is for the WalletItemStore store, and isn't part of the initialization of a WalletItem object.
 * @param item The wallet item to add to the wallet.
 * @return An asynchronous action. If you use Asynchronous programming, the return type is void.
 */
addAsync(
id: string,
item: Windows$ApplicationModel$Wallet$WalletItem): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Clears all app-owned wallet items from the wallet data store.
 * @return An asynchronous action. If you use Asynchronous programming, the result type is void.
 */
clearAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Removes a specific wallet item with the given ID from the wallet data store.
 * @param id The ID of the wallet item to remove from the data store.
 * @return An asynchronous action. If you use Asynchronous programming, the result type is void.
 */
deleteAsync(id: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Returns the collection of all wallet items owned by this app.
 * @return An asynchronous operation that, on successful completion, returns the collection of wallet items accessible by this app. If you use Asynchronous programming, the result type is a read-only list/vector of WalletItem items. (You can use APIs of IVectorView<WalletItem> for C++ or JavaScript, APIs of IReadOnlyList<WalletItem> for .NET.)
 */
getItemsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$Wallet$WalletItem>>;

/**
 * Returns the collection of wallet items of the given type that are owned by this app.
 * @param kind The type of wallet item to retrieve.
 * @return An asynchronous operation that, on successful completion, returns the collection of wallet items of the specified type that are accessible by this app. If you use Asynchronous programming, the result type is a read-only list/vector of WalletItem items. (You can use APIs of IVectorView<WalletItem> for C++ or JavaScript, APIs of IReadOnlyList<WalletItem> for .NET.)
 */
getItemsAsync(
kind: $Values<typeof Windows$ApplicationModel$Wallet$WalletItemKind>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets an individual wallet item with the given ID from the wallet database. The item requested must be owned by this app.
 * @param id The ID of the wallet item.
 * @return An asynchronous operation that, on successful completion, returns the wallet item with the specified ID that is owned by this app. If you use Asynchronous programming, the result type is a single WalletItem (or null, see Remarks).
 */
getWalletItemAsync(
id: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Wallet$WalletItem>;

/**
 * Imports data from a ".mswallet" XML file into the wallet store.
 * @param stream The ".mswallet" file to import.
 * @return An asynchronous operation that, on successful completion, returns the wallet item that was imported into the wallet. If you use Asynchronous programming, the result type on successful completion is a single WalletItem .
 */
importItemAsync(
stream: Windows$Storage$Streams$IRandomAccessStreamReference): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Wallet$WalletItem>;

/**
 * Displays the item with the given ID in the Wallet UI.
 * @param id The ID of the item to display.
 * @return An asynchronous action. If you use Asynchronous programming, the result type is void.
 */
showAsync(id: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Displays the Wallet UI.
 * @return An asynchronous action. If you use Asynchronous programming, the result type is void.
 */
showAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Updates a wallet item in the shared store, based on the changed values in the WalletItem object provided.
 * @param item The updated data for the wallet item.
 * @return An asynchronous action. If you use Asynchronous programming, the result type is void.
 */
updateAsync(
item: Windows$ApplicationModel$Wallet$WalletItem): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Provides a static method to get an instance of the default wallet store for this app.
 */
declare class Windows$ApplicationModel$Wallet$WalletManager  {

/**
 * Requests an instance of the default wallet store for the app.
 * @return An asynchronous operation that, on successful completion, returns an instance of the default wallet store. If you use Asynchronous programming, the result type is a single WalletItemStore object.
 */
static requestStoreAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$ApplicationModel$Wallet$WalletItemStore>
}


/**
 * Represents relevant location data for a wallet item.
 */
declare class Windows$ApplicationModel$Wallet$WalletRelevantLocation  {

/**
 * Initializes a new instance of the WalletRelevantLocation class.
 */
constructor(): this;

/**
 * Gets or sets the message associated with a relevant location.
 */
displayMessage: string;

/**
 * Gets or sets the basic geographic position information of the location.
 */
position: Windows$Devices$Geolocation$BasicGeoposition
}


/**
 * Describes the position in the summary view of a wallet item that a WalletItemCustomProperty should be displayed.
 */

declare  var Windows$ApplicationModel$Wallet$WalletSummaryViewPosition: {|
  +hidden: 0,// 0
+field1: 1,// 1
+field2: 2,// 2

|};



/**
 * Represents a single wallet transaction in the transaction history.
 */
declare class Windows$ApplicationModel$Wallet$WalletTransaction  {

/**
 * Initializes a new instance of the WalletTransaction class.
 */
constructor(): this;

/**
 * Gets or sets the summary description (suitable for user UI) of the transaction.
 */
description: string;

/**
 * Gets or sets the transaction amount.
 */
displayAmount: string;

/**
 * Gets or sets a description (suitable for user UI) of the transaction location.
 */
displayLocation: string;

/**
 * Gets or sets whether to display the time of the transaction.
 */
ignoreTimeOfDay: boolean;

/**
 * Gets or sets whether to launch your app when the user taps "see more transaction history".
 */
isLaunchable: boolean;

/**
 * Gets or sets the date and time of the transaction.
 */
transactionDate: Date
}


/**
 * Represents a wallet verb, which is potentially used for app activation. This is a string suitable for UI that is descriptive of the action.
 */
declare class Windows$ApplicationModel$Wallet$WalletVerb  {

/**
 * Initializes a new instance of the WalletVerb class.
 * @param name The name of the custom verb. Sets the value of the Name property.
 */
constructor(name: string): this;

/**
 * Gets or sets the custom verb name.
 */
name: string
}


/**
 * Represents the package version info.
 */
declare interface Windows$ApplicationModel$PackageVersion {

/**
 * The build version number of the package.
 */
build: number,

/**
 * The major version number of the package.
 */
major: number,

/**
 * The minor version number of the package.
 */
minor: number,

/**
 * The revision version number of the package.
 */
revision: number
} 


/**
 * Provides data for an app suspending event.
 */
declare interface Windows$ApplicationModel$ISuspendingEventArgs {

/**
 * Gets the app suspending operation.
 */
suspendingOperation: Windows$ApplicationModel$SuspendingOperation
} 


      declare var npm$namespace$Windows$Data: {
        
        
        
        
        Pdf: typeof npm$namespace$Windows$Data$Pdf,
Text: typeof npm$namespace$Windows$Data$Text,
Xml: typeof npm$namespace$Windows$Data$Xml,
      }





      declare var npm$namespace$Windows$Data$Pdf: {
        
        
        PdfPageRotation: typeof Windows$Data$Pdf$PdfPageRotation,
        PdfDocument: typeof Windows$Data$Pdf$PdfDocument,
PdfPage: typeof Windows$Data$Pdf$PdfPage,
PdfPageDimensions: typeof Windows$Data$Pdf$PdfPageDimensions,
PdfPageRenderOptions: typeof Windows$Data$Pdf$PdfPageRenderOptions,
        
      }

/**
 * Represents a Portable Document Format (PDF) document.
 */
declare class Windows$Data$Pdf$PdfDocument  {

/**
 * Outputs an asynchronous operation. When the operation completes, a PdfDocument object is returned, which represents a Portable Document Format (PDF) document. Use this method if the PDF document is password-protected.
 * @param file The file, which represents a PDF document.
 * @param password The password to open the PDF document, if it requires one.
 * @return The asynchronous operation.
 */
static loadFromFileAsync(
file: Windows$Storage$IStorageFile,
password: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Data$Pdf$PdfDocument>;

/**
 * Outputs an asynchronous operation. When the operation completes, a PdfDocument object is returned, which represents a Portable Document Format (PDF) document.
 * @param file The file, which represents a PDF document.
 * @return The asynchronous operation.
 */
static loadFromFileAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Data$Pdf$PdfDocument>;

/**
 * Creates a PdfDocument object, representing a Portable Document Format (PDF) document, from a stream of data that represents a PDF document in the file system. Use this method if the PDF document is password-protected.
 * @param inputStream The stream of data, which represents a PDF document.
 * @param password The password to open the PDF document, if it requires one.
 * @return The asynchronous operation.
 */
static loadFromStreamAsync(
inputStream: Windows$Storage$Streams$IRandomAccessStream,
password: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Data$Pdf$PdfDocument>;

/**
 * Creates a PdfDocument object, representing a Portable Document Format (PDF) document, from a stream of data that represents a PDF document in the file system.
 * @param inputStream The stream of data, which represents a PDF document.
 * @return The asynchronous operation.
 */
static loadFromStreamAsync(
inputStream: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Data$Pdf$PdfDocument>;

/**
 * Gets a page from a Portable Document Format (PDF) document.
 * @param pageIndex The location of the PDF page relative to its parent document.
 * @return The PDF page.
 */
getPage(pageIndex: number): Windows$Data$Pdf$PdfPage;

/**
 * Gets whether the Portable Document Format (PDF) document is password-protected.
 */
isPasswordProtected: boolean;

/**
 * Gets the number of pages in the Portable Document Format (PDF) document.
 */
pageCount: number
}


/**
 * Represents a single page in a Portable Document Format (PDF) document.
 */
declare class Windows$Data$Pdf$PdfPage  {

/**
 * Releases all resources associated with the Portable Document Format (PDF) page.
 */
close(): void;

/**
 * Gets the group of dimension properties for a single page in a Portable Document Format (PDF) document.
 */
dimensions: Windows$Data$Pdf$PdfPageDimensions;

/**
 * Gets the relative position of the Portable Document Format (PDF) page within its parent PDF document.
 */
index: number;

/**
 * Gets the Portable Document Format (PDF) page's preferred magnification factor.
 */
preferredZoom: number;

/**
 * Begins building the Portable Document Format (PDF) page. After this method finishes, the PDF page is completely built.
 * @return Represents the fully-built PDF page.
 */
preparePageAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Outputs a stream of data, which represents a Portable Document Format (PDF) page's contents, as an asynchronous action. This asynchronous action can be used to create an image of the PDF page.
 * @param outputStream The stream of data, which represents a PDF page's content.
 * @return The asynchronous action.
 */
renderToStreamAsync(
outputStream: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Takes a set of display settings, applies them to the output of a Portable Document Format (PDF) page's contents, and creates a stream with the customized, rendered output as an asynchronous action. This asynchronous action can be used to create a customized display image of the PDF page.
 * @param outputStream The stream of data, which represents a PDF page's contents.
 * @param options The requested set of display settings to apply to the display image that is output based on the PDF page.
 * @return The asynchronous action.
 */
renderToStreamAsync(
outputStream: Windows$Storage$Streams$IRandomAccessStream,
options: Windows$Data$Pdf$PdfPageRenderOptions): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the number of degrees that the Portable Document Format (PDF) page will be rotated when it's displayed or printed.
 */
rotation: $Values<typeof Windows$Data$Pdf$PdfPageRotation>;

/**
 * Gets the Portable Document Format (PDF) page's size based on its related CropBox , MediaBox , and Rotation property values.
 */
size: Windows$Foundation$Size
}


/**
 * Represents the dimensions of a single page in a Portable Document Format (PDF) document.
 */
declare class Windows$Data$Pdf$PdfPageDimensions  {

/**
 * Gets the size of a rectangle that contains the Portable Document Format (PDF) page's contents, including any meaningful surrounding white space, as intended by the PDF page's creator.
 */
artBox: Windows$Foundation$Rect;

/**
 * Gets the size of a rectangle that specifies the clipped region of a Portable Document Format (PDF) page's contents when it is displayed.
 */
bleedBox: Windows$Foundation$Rect;

/**
 * Gets the size of a rectangle that specifies the cropped region of a Portable Document Format (PDF) page's contents when it is displayed.
 */
cropBox: Windows$Foundation$Rect;

/**
 * Gets the size of a rectangle that defines the boundaries of the area that the Portable Document Format (PDF) page will be displayed or printed to.
 */
mediaBox: Windows$Foundation$Rect;

/**
 * Gets the size of a rectangle that specifies the intended dimensions of the Portable Document Format (PDF) page after it has been trimmed.
 */
trimBox: Windows$Foundation$Rect
}


/**
 * Represents display settings for a single page of a Portable Document Format (PDF) document, such as the page's background color and its encoding type.
 */
declare class Windows$Data$Pdf$PdfPageRenderOptions  {

/**
 * Creates and initializes a new instance of display settings for a single page of a Portable Document Format (PDF) document.
 */
constructor(): this;

/**
 * Gets or sets the Portable Document Format (PDF) page's background color.
 */
backgroundColor: Windows$UI$Color;

/**
 * Gets or sets the Portable Document Format (PDF) page's encoding type to be used while the page is being converted to a bitmap.
 */
bitmapEncoderId: string;

/**
 * Gets or sets the final size of the rendering of the Portable Document Format (PDF) page in device-independent pixels (DIPs).
 */
destinationHeight: number;

/**
 * Gets or sets the final size of the rendering of the Portable Document Format (PDF) page in device-independent pixels (DIPs).
 */
destinationWidth: number;

/**
 * Gets or sets whether the Portable Document Format (PDF) page uses the system's high contrast display setting.
 */
isIgnoringHighContrast: boolean;

/**
 * Gets or sets a portion of the Portable Document Format (PDF) page to be displayed.
 */
sourceRect: Windows$Foundation$Rect
}


/**
 * Specifies the number of degrees that a page in a Portable Document Format (PDF) document is rotated in the rendered output.
 */

declare  var Windows$Data$Pdf$PdfPageRotation: {|
  +normal: 0,// 0
+rotate90: 1,// 1
+rotate180: 2,// 2
+rotate270: 3,// 3

|};



      declare var npm$namespace$Windows$Data$Text: {
        
        
        AlternateNormalizationFormat: typeof Windows$Data$Text$AlternateNormalizationFormat,
UnicodeGeneralCategory: typeof Windows$Data$Text$UnicodeGeneralCategory,
UnicodeNumericType: typeof Windows$Data$Text$UnicodeNumericType,
        AlternateWordForm: typeof Windows$Data$Text$AlternateWordForm,
SelectableWordSegment: typeof Windows$Data$Text$SelectableWordSegment,
SelectableWordsSegmenter: typeof Windows$Data$Text$SelectableWordsSegmenter,
SemanticTextQuery: typeof Windows$Data$Text$SemanticTextQuery,
TextConversionGenerator: typeof Windows$Data$Text$TextConversionGenerator,
TextPredictionGenerator: typeof Windows$Data$Text$TextPredictionGenerator,
TextReverseConversionGenerator: typeof Windows$Data$Text$TextReverseConversionGenerator,
UnicodeCharacters: typeof Windows$Data$Text$UnicodeCharacters,
WordSegment: typeof Windows$Data$Text$WordSegment,
WordsSegmenter: typeof Windows$Data$Text$WordsSegmenter,
        
      }

/**
 * Identifies the normalization format of an AlternateWordForm object.
 */

declare  var Windows$Data$Text$AlternateNormalizationFormat: {|
  +notNormalized: 0,// 0
+number: 1,// 1
+currency: 2,// 2
+date: 3,// 3
+time: 4,// 4

|};



/**
 * Identifies an alternate form of the word represented by a WordSegment object.. For example, this may contain a number in a normalized format.
 */
declare class Windows$Data$Text$AlternateWordForm  {

/**
 * Gets the text of the alternate word form identified by this AlternateWordForm object.
 */
alternateText: string;

/**
 * Gets the normalization format for this current AlternateWordForm object.
 */
normalizationFormat: $Values<typeof Windows$Data$Text$AlternateNormalizationFormat>;

/**
 * Gets the TextSegment that identifies the source text's sub-string for which this AlternateWordForm object is an alternate.
 */
sourceTextSegment: Windows$Data$Text$TextSegment
}


/**
 * Represents a segment from your provided text that includes a word and any trailing whitespace and/or punctuation after this word.
 */
declare class Windows$Data$Text$SelectableWordSegment  {

/**
 * Gets the TextSegment that identifies the source text's sub-string that is the selected word.
 */
sourceTextSegment: Windows$Data$Text$TextSegment;

/**
 * Gets the text of the selected word identified by this SelectableWordSegment object.
 */
text: string
}


/**
 * A segmenter class that is able to segment provided text into units appropriate for selecting text by words.
 */
declare class Windows$Data$Text$SelectableWordsSegmenter  {

/**
 * Creates a SelectableWordsSegmenter object. See the introduction in SelectableWordsSegmenter for a description of how the language supplied to this constructor is used.
 * @param language A BCP-47 language tag.
 */
constructor(language: string): this;

/**
 * Determines and returns the selectable word which contains or follows a specified index into the provided text.
 * @param text Provided text in which a word is to be selected.
 * @param startIndex A zero-based index into text. It must be less than the length of text.
 * @return A SelectableWordSegment that represents the selected word.
 */
getTokenAt(text: string, startIndex: number): Windows$Data$Text$SelectableWordSegment;

/**
 * Determines and returns all of the selectable words in the provided text.
 * @param text Provided text containing words to be selected.
 * @return A collection of SelectableWordSegment objects that represent the selectable words.
 */
getTokens(
text: string): Windows$Foundation$Collections$IVectorView<Windows$Data$Text$SelectableWordSegment>;

/**
 * Gets the language of the rules used by this SelectableWordsSegmenter object.
 */
resolvedLanguage: string;

/**
 * Calls the provided handler with two iterators that iterate through the selectable words prior to and following a given index into the provided text.
 * @param text Provided text containing words to be selected.
 * @param startIndex A zero-based index into text. It must be less than the length of text.
 * @param handler The function that receives the iterators.
 */
tokenize(
text: string,
startIndex: number,
handler: Windows$Data$Text$SelectableWordSegmentsTokenizingHandler): void
}


/**
 * Permits apps to perform text queries using Advanced Query Syntax (AQS) strings, with the option of providing a language tag to be employed in the query.
 */
declare class Windows$Data$Text$SemanticTextQuery  {

/**
 * Creates a SemanticTextQuery from an Advanced Query Syntax (AQS) query string and a language tag.
 * @param aqsFilter An AQS string that contains the desired query. Learn more about AQS in Advanced Query Syntax (AQS).
 * @param filterLanguage The BCP-47 language tag to be employed in the query.
 */
constructor(aqsFilter: string, filterLanguage: string): this;

/**
 * Creates a SemanticTextQuery from an Advanced Query Syntax (AQS) query string.
 * @param aqsFilter An AQS string that contains the desired query. Learn more about AQS in Advanced Query Syntax (AQS).
 */
constructor(aqsFilter: string): this;

/**
 * Returns segments of a source string that match the SemanticTextQuery object's query.
 * @param content A source string to be queried.
 * @return A collection of TextSegment structures that represent hits from the query.
 */
find(
content: string): Windows$Foundation$Collections$IVectorView<Windows$Data$Text$TextSegment>;

/**
 * Returns segments of a source string that match the SemanticTextQuery object's query over properties.
 * @param propertyContent A source string to be queried.
 * @param propertyName The name of the property.
 * @return A collection of TextSegment structures that represent hits from the query.
 */
findInProperty(
propertyContent: string,
propertyName: string): Windows$Foundation$Collections$IVectorView<Windows$Data$Text$TextSegment>
}


/**
 * Converts input phonetic characters into a collection of corresponding ideographic characters (Chinese characters).
 */
declare class Windows$Data$Text$TextConversionGenerator  {

/**
 * Constructs a TextConversionGenerator object based on a specific BCP-47 language tag.
 * @param languageTag The BCP-47 language tag of the language in which the words are to be projected. Japanese ("ja") and Simplified Chinese ("zh-Hans") are supported.
 */
constructor(languageTag: string): this;

/**
 * Asynchronously gets a list of candidate words based on the provided phonetic characters.
 * @param input The phonetic characters of the words to be returned.
 * @return An asynchronous operation to return an IVectorView of the list of candidate words.
 */
getCandidatesAsync(
input: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously gets a list of candidate words, up to a maximum count, based on the provided phonetic characters.
 * @param input The phonetic characters of the words to be returned.
 * @param maxCandidates The maximum number of candidate words to return.
 * @return An asynchronous operation to return an IVectorView of the list of candidate words.
 */
getCandidatesAsync(
input: string,
maxCandidates: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Determines if the language tag specified is available for conversions, but is not installed on the user's device.
 */
languageAvailableButNotInstalled: boolean;

/**
 * Gets the language tag of the successfully created TextConversionGenerator object.
 */
resolvedLanguage: string
}


/**
 * Predicts Japanese words based on a phonetic characters prefix.
 */
declare class Windows$Data$Text$TextPredictionGenerator  {

/**
 * Constructs a TextPredictionGenerator object based on a specific BCP-47 language tag.
 * @param languageTag The BCP-47 language tag of the language in which the words are to be projected. Only Japanese ("ja") is supported.
 */
constructor(languageTag: string): this;

/**
 * Asynchronously gets a list of candidate words based on the provided phonetic characters prefix.
 * @param input The beginning phonetic characters of the words to be returned.
 * @return An asynchronous operation to return an IVectorView of the list of predicted words.
 */
getCandidatesAsync(
input: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously gets a list of candidate words, up to a maximum count, based on the provided phonetic characters prefix.
 * @param input The beginning phonetic characters of the words to be returned.
 * @param maxCandidates The maximum number of predicted words to return.
 * @return An asynchronous operation to return an IVectorView of the list of predicted words.
 */
getCandidatesAsync(
input: string,
maxCandidates: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Determines if the language tag specified is available for generating predictions, but is not installed on the user's device.
 */
languageAvailableButNotInstalled: boolean;

/**
 * Gets the language tag of the successfully created TextPredictionGenerator object.
 */
resolvedLanguage: string
}


/**
 * Reverse-converts a Japanese string which is mix of phonetic and ideographic characters, to a string of phonetic characters.
 */
declare class Windows$Data$Text$TextReverseConversionGenerator  {

/**
 * Constructs a TextReverseConversionGenerator object based on a specific BCP-47 language tag.
 * @param languageTag The BCP-47 language tag of the language in which the words are to be reverse-converted. Only Japanese ("ja") is supported.
 */
constructor(languageTag: string): this;

/**
 * Asynchronously reverse-converts a string which contains ideographic characters to a phonetic expression.
 * @param input The string containing ideographic characters to be reverse-converted.
 * @return An asynchronous operation to return the phonetic expression.
 */
convertBackAsync(input: string): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Determines if the language tag specified is available for reverse conversions, but is not installed on the user's device.
 */
languageAvailableButNotInstalled: boolean;

/**
 * Gets the language tag of the successfully created TextReverseConversionGenerator object.
 */
resolvedLanguage: string
}


/**
 * Provides a way for apps to get information about Unicode characters.
 */
declare class Windows$Data$Text$UnicodeCharacters  {

/**
 * Returns the supplementary Unicode character for the specified high and low surrogate pair.
 * @param highSurrogate The high surrogate value. This must be in the proper range: 0xD800 <= highSurrogate <= 0xDBFF.
 * @param lowSurrogate The low surrogate value. This must be in the proper range: 0xDC00 <= lowSurrogate <= 0xDFFF.
 * @return The supplementary Unicode character.
 */
static getCodepointFromSurrogatePair(highSurrogate: number, lowSurrogate: number): number;

/**
 * Returns the UnicodeGeneralCategory of the specified Unicode character.
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return The Unicode general category for codepoint.
 */
static getGeneralCategory(codepoint: number): $Values<typeof Windows$Data$Text$UnicodeGeneralCategory>;

/**
 * Returns the UnicodeNumericType of the specified Unicode character.
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return The Unicode numeric type for codepoint.
 */
static getNumericType(codepoint: number): $Values<typeof Windows$Data$Text$UnicodeNumericType>;

/**
 * Returns the high and low surrogate pair values for the specified supplementary Unicode character.
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 */
static getSurrogatePairFromCodepoint(codepoint: number): {
highSurrogate: string,
lowSurrogate: string
};

/**
 * Determines if a specified Unicode character can be considered alphabetic.
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return TRUE if codepoint is alphabetic; otherwise FALSE.
 */
static isAlphabetic(codepoint: number): boolean;

/**
 * Determines if a specified Unicode character can be considered cased (uppercase, lowercase or titlecase).
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return TRUE if codepoint is cased; otherwise FALSE.
 */
static isCased(codepoint: number): boolean;

/**
 * Determines if a specified Unicode character can be considered the beginning of a grapheme.
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return TRUE if codepoint is the beginning of a grapheme; otherwise FALSE.
 */
static isGraphemeBase(codepoint: number): boolean;

/**
 * Determines if a specified Unicode character can be considered to continue a previous grapheme.
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return TRUE if codepoint continues the previous grapheme; otherwise FALSE.
 */
static isGraphemeExtend(codepoint: number): boolean;

/**
 * Determines if a specified Unicode character is a high surrogate.
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return TRUE if codepoint is a high surrogate; otherwise FALSE.
 */
static isHighSurrogate(codepoint: number): boolean;

/**
 * Determines if a specified Unicode character can be considered a continuation character of an identifier in programming.
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return TRUE if codepoint is a continuation character of an identifier in programming; otherwise FALSE.
 */
static isIdContinue(codepoint: number): boolean;

/**
 * Determines if a specified Unicode character can be considered the start character of an identifier in programming.
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return TRUE if codepoint is the start character of an identifier in programming; otherwise FALSE.
 */
static isIdStart(codepoint: number): boolean;

/**
 * Determines if a specified Unicode character is a low surrogate.
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return TRUE if codepoint is a low surrogate; otherwise FALSE.
 */
static isLowSurrogate(codepoint: number): boolean;

/**
 * Determines if a specified Unicode character can be considered a lower case character.
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return TRUE if codepoint is a lower case character; otherwise FALSE.
 */
static isLowercase(codepoint: number): boolean;

/**
 * Determines if a specified codepoint is a non-character.
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return TRUE if codepoint is a non-character; otherwise FALSE.
 */
static isNoncharacter(codepoint: number): boolean;

/**
 * Determines if a specified Unicode character is a supplementary character.
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return TRUE if codepoint is a supplementary character; otherwise FALSE.
 */
static isSupplementary(codepoint: number): boolean;

/**
 * Determines if a specified Unicode character can be considered an upper case character.
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return TRUE if codepoint is an upper case character; otherwise FALSE.
 */
static isUppercase(codepoint: number): boolean;

/**
 * Determines if a specified Unicode character can be considered whitespace.
 * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return TRUE if codepoint is whitespace; otherwise FALSE.
 */
static isWhitespace(codepoint: number): boolean
}


/**
 * Defines the Unicode general category of a character.
 */

declare  var Windows$Data$Text$UnicodeGeneralCategory: {|
  +uppercaseLetter: 0,// 0
+lowercaseLetter: 1,// 1
+titlecaseLetter: 2,// 2
+modifierLetter: 3,// 3
+otherLetter: 4,// 4
+nonspacingMark: 5,// 5
+spacingCombiningMark: 6,// 6
+enclosingMark: 7,// 7
+decimalDigitNumber: 8,// 8
+letterNumber: 9,// 9
+otherNumber: 10,// 10
+spaceSeparator: 11,// 11
+lineSeparator: 12,// 12
+paragraphSeparator: 13,// 13
+control: 14,// 14
+format: 15,// 15
+surrogate: 16,// 16
+privateUse: 17,// 17
+connectorPunctuation: 18,// 18
+dashPunctuation: 19,// 19
+openPunctuation: 20,// 20
+closePunctuation: 21,// 21
+initialQuotePunctuation: 22,// 22
+finalQuotePunctuation: 23,// 23
+otherPunctuation: 24,// 24
+mathSymbol: 25,// 25
+currencySymbol: 26,// 26
+modifierSymbol: 27,// 27
+otherSymbol: 28,// 28
+notAssigned: 29,// 29

|};



/**
 * Defines the type of numeral when a Unicode character represents a number.
 */

declare  var Windows$Data$Text$UnicodeNumericType: {|
  +none: 0,// 0
+decimal: 1,// 1
+digit: 2,// 2
+numeric: 3,// 3

|};



/**
 * Represents a word from your provided text.
 */
declare class Windows$Data$Text$WordSegment  {

/**
 * Gets the alternate forms (if any) associated with the current word.
 */
alternateForms: Windows$Foundation$Collections$IVectorView<Windows$Data$Text$AlternateWordForm>;

/**
 * Gets the TextSegment that identifies the source text's sub-string that is a word.
 */
sourceTextSegment: Windows$Data$Text$TextSegment;

/**
 * Gets the text of the word identified by this WordSegment object.
 */
text: string
}


/**
 * A segmenter class that is able to segment provided text into words.
 */
declare class Windows$Data$Text$WordsSegmenter  {

/**
 * Creates a WordsSegmenter object. See the introduction in WordsSegmenter for a description of how the language supplied to this constructor is used.
 * @param language A BCP-47 language tag.
 */
constructor(language: string): this;

/**
 * Determines and returns the word which contains or follows a specified index into the provided text.
 * @param text Provided text from which the word is to be returned.
 * @param startIndex A zero-based index into text. It must be less than the length of text.
 * @return A WordSegment that represents the word.
 */
getTokenAt(text: string, startIndex: number): Windows$Data$Text$WordSegment;

/**
 * Determines and returns all of the words in the provided text.
 * @param text Provided text containing words to be returned.
 * @return A collection of WordSegment objects that represent the words.
 */
getTokens(
text: string): Windows$Foundation$Collections$IVectorView<Windows$Data$Text$WordSegment>;

/**
 * Gets the language of the rules used by this WordsSegmenter object.
 */
resolvedLanguage: string;

/**
 * Calls the provided handler with two iterators that iterate through the words prior to and following a given index into the provided text.
 * @param text Provided text containing words to be returned.
 * @param startIndex A zero-based index into text. It must be less than the length of text.
 * @param handler The function that receives the iterators.
 */
tokenize(
text: string,
startIndex: number,
handler: Windows$Data$Text$WordSegmentsTokenizingHandler): void
}


/**
 * Identifies a sub-string of a source text string. Your app can use this structure to obtain the segment of your provided text that is identified by AlternateWordForm , SelectableWordSegment , WordSegment , or SemanticTextQuery .
 */
declare interface Windows$Data$Text$TextSegment {

/**
 * The number of characters in the associated text segment.
 */
length: number,

/**
 * The zero-based index of the start of the associated text segment.
 */
startPosition: number
} 


/**
 * Defines the signature of a function that is provided to SelectableWordsSegmenter.Tokenize .
 */
declare type Windows$Data$Text$SelectableWordSegmentsTokenizingHandler = (
precedingWords: Windows$Foundation$Collections$IIterable<Windows$Data$Text$SelectableWordSegment>,
words: Windows$Foundation$Collections$IIterable<Windows$Data$Text$SelectableWordSegment>) => void;


/**
 * Defines the signature of a function that is provided to WordsSegmenter.Tokenize .
 */
declare type Windows$Data$Text$WordSegmentsTokenizingHandler = (
precedingWords: Windows$Foundation$Collections$IIterable<Windows$Data$Text$WordSegment>,
words: Windows$Foundation$Collections$IIterable<Windows$Data$Text$WordSegment>) => void;


      declare var npm$namespace$Windows$Data$Xml: {
        
        
        
        
        Dom: typeof npm$namespace$Windows$Data$Xml$Dom,
Xsl: typeof npm$namespace$Windows$Data$Xml$Xsl,
      }

      declare var npm$namespace$Windows$Data$Xml$Dom: {
        
        
        NodeType: typeof Windows$Data$Xml$Dom$NodeType,
        DtdEntity: typeof Windows$Data$Xml$Dom$DtdEntity,
DtdNotation: typeof Windows$Data$Xml$Dom$DtdNotation,
XmlAttribute: typeof Windows$Data$Xml$Dom$XmlAttribute,
XmlCDataSection: typeof Windows$Data$Xml$Dom$XmlCDataSection,
XmlComment: typeof Windows$Data$Xml$Dom$XmlComment,
XmlDocument: typeof Windows$Data$Xml$Dom$XmlDocument,
XmlDocumentFragment: typeof Windows$Data$Xml$Dom$XmlDocumentFragment,
XmlDocumentType: typeof Windows$Data$Xml$Dom$XmlDocumentType,
XmlDomImplementation: typeof Windows$Data$Xml$Dom$XmlDomImplementation,
XmlElement: typeof Windows$Data$Xml$Dom$XmlElement,
XmlEntityReference: typeof Windows$Data$Xml$Dom$XmlEntityReference,
XmlLoadSettings: typeof Windows$Data$Xml$Dom$XmlLoadSettings,
XmlNamedNodeMap: typeof Windows$Data$Xml$Dom$XmlNamedNodeMap,
XmlNodeList: typeof Windows$Data$Xml$Dom$XmlNodeList,
XmlProcessingInstruction: typeof Windows$Data$Xml$Dom$XmlProcessingInstruction,
XmlText: typeof Windows$Data$Xml$Dom$XmlText,
        
      }

/**
 * Represents a parsed or unparsed entity in the XML document.
 */
declare class Windows$Data$Xml$Dom$DtdEntity  {

/**
 * Appends a new child node as the last child of the node.
 * @param newChild The new child node to be appended to the end of the list of children of this node.
 * @return The new child node successfully appended to the list. If null, no object is created.
 */
appendChild(newChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the list of attributes of this node.
 */
attributes: Windows$Data$Xml$Dom$XmlNamedNodeMap;

/**
 * Gets a list of children in the current node.
 */
childNodes: Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Clones a new node.
 * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return The newly created clone node.
 */
cloneNode(deep: boolean): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the first child node.
 */
firstChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the XML representation of the node and all its descendants.
 * @return The XML representation of the node and all its descendants.
 */
getXml(): string;

/**
 * Determines whether a node has children.
 * @return True if this node has children; otherwise false.
 */
hasChildNodes(): boolean;

/**
 * Gets the text from inside the XML.
 */
innerText: string;

/**
 * Inserts a child node to the left of the specified node, or at the end of the child node list.
 * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return On success, the child node that was inserted. If null, no object is created.
 */
insertBefore(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the last child node.
 */
lastChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML.
 */
localName: any;

/**
 * Returns the Uniform Resource Identifier (URI) for the namespace.
 */
namespaceUri: any;

/**
 * Gets the next sibling of the node in the parent's child list.
 */
nextSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types.
 */
nodeName: string;

/**
 * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes.
 */
nodeType: $Values<typeof Windows$Data$Xml$Dom$NodeType>;

/**
 * Gets or sets the text associated with the node. This value is always NULL.
 */
nodeValue: any;

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 */
normalize(): void;

/**
 * Gets the notation name.
 */
notationName: any;

/**
 * Returns the root of the document that contains the node.
 */
ownerDocument: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets the parent node of the node instance.
 */
parentNode: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the namespace prefix.
 */
prefix: any;

/**
 * Gets the previous sibling of the node in the parent's child list.
 */
previousSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the public identifier associated with the entity.
 */
publicId: any;

/**
 * Removes the specified child node from the list of children and returns it.
 * @param childNode The child node to be removed from the list of children of this node.
 * @return The removed child node. If null, the childNode object is not removed.
 */
removeChild(childNode: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param referenceChild The old child that is to be replaced by the new child.
 * @return The old child that is replaced. If null, no object is created.
 */
replaceChild(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
selectNodes(xpath: string): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
selectNodesNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
selectSingleNode(xpath: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the system identifier associated with the entity.
 */
systemId: any
}


/**
 * Contains a notation declared in the DTD or schema.
 */
declare class Windows$Data$Xml$Dom$DtdNotation  {

/**
 * Appends a new child node as the last child of the node.
 * @param newChild The new child node to be appended to the end of the list of children of this node.
 * @return The new child node successfully appended to the list. If null, no object is created.
 */
appendChild(newChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the list of attributes of this node.
 */
attributes: Windows$Data$Xml$Dom$XmlNamedNodeMap;

/**
 * Gets a list of children in the current node.
 */
childNodes: Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Clones a new node.
 * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return The newly created clone node.
 */
cloneNode(deep: boolean): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the first child node.
 */
firstChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the XML representation of the node and all its descendants.
 * @return The XML representation of the node and all its descendants.
 */
getXml(): string;

/**
 * Determines whether a node has children.
 * @return True if this node has children; otherwise false.
 */
hasChildNodes(): boolean;

/**
 * Gets the text from inside the XML.
 */
innerText: string;

/**
 * Inserts a child node to the left of the specified node, or at the end of the child node list.
 * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return On success, the child node that was inserted. If null, no object is created.
 */
insertBefore(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the last child node.
 */
lastChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML.
 */
localName: any;

/**
 * Returns the Uniform Resource Identifier (URI) for the namespace.
 */
namespaceUri: any;

/**
 * Gets the next sibling of the node in the parent's child list.
 */
nextSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types.
 */
nodeName: string;

/**
 * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes.
 */
nodeType: $Values<typeof Windows$Data$Xml$Dom$NodeType>;

/**
 * Gets or sets the text associated with the node.
 */
nodeValue: any;

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 */
normalize(): void;

/**
 * Returns the root of the document that contains the node.
 */
ownerDocument: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets the parent node of the node instance.
 */
parentNode: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets or sets the namespace prefix.
 */
prefix: any;

/**
 * Gets the previous sibling of the node in the parent's child list.
 */
previousSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the public identifier for the notation.
 */
publicId: any;

/**
 * Removes the specified child node from the list of children and returns it.
 * @param childNode The child node to be removed from the list of children of this node.
 * @return The removed child node. If null, the childNode object is not removed.
 */
removeChild(childNode: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param referenceChild The old child that is to be replaced by the new child.
 * @return The old child that is replaced. If null, no object is created.
 */
replaceChild(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList.
 * @param xpath Specifies an XPath expression.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
selectNodes(xpath: string): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList.
 * @param xpath Specifies an XPath expresssion.
 * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
selectNodesNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
selectSingleNode(xpath: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the system identifier for the notation.
 */
systemId: any
}


/**
 * The type of an IXmlNode, as returned by the NodeType property.
 */

declare  var Windows$Data$Xml$Dom$NodeType: {|
  +invalid: 0,// 0
+elementNode: 1,// 1
+attributeNode: 2,// 2
+textNode: 3,// 3
+dataSectionNode: 4,// 4
+entityReferenceNode: 5,// 5
+entityNode: 6,// 6
+processingInstructionNode: 7,// 7
+commentNode: 8,// 8
+documentNode: 9,// 9
+documentTypeNode: 10,// 10
+documentFragmentNode: 11,// 11
+notationNode: 12,// 12

|};



/**
 * Represents an attribute of an XmlElement. Valid and default values for the attribute are defined in a document type definition (DTD) or schema.
 */
declare class Windows$Data$Xml$Dom$XmlAttribute  {

/**
 * This method is not applicable to this class and will throw an exception.
 * @param newChild The new child node to be appended to the end of the list of children of this node.
 * @return The new child node successfully appended to the list. If null, no object is created.
 */
appendChild(newChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * This method is not applicable to this class and will throw an exception.
 */
attributes: Windows$Data$Xml$Dom$XmlNamedNodeMap;

/**
 * Gets a list of children in the current node.
 */
childNodes: Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Clones a new node.
 * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return The newly created clone node.
 */
cloneNode(deep: boolean): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the first child node.
 */
firstChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the XML representation of the node and all its descendants.
 * @return The XML representation of the node and all its descendants.
 */
getXml(): string;

/**
 * Determines whether a node has children.
 * @return True if this node has children; otherwise false.
 */
hasChildNodes(): boolean;

/**
 * Gets the text from inside the XML.
 */
innerText: string;

/**
 * Inserts a child node to the left of the specified node, or at the end of the child node list.
 * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return On success, the child node that was inserted. If null, no object is created.
 */
insertBefore(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the last child node.
 */
lastChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML.
 */
localName: any;

/**
 * Returns the attribute name.
 */
name: string;

/**
 * Returns the Uniform Resource Identifier (URI) for the namespace.
 */
namespaceUri: any;

/**
 * This property is not applicable to this class and will always return null.
 */
nextSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types.
 */
nodeName: string;

/**
 * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes.
 */
nodeType: $Values<typeof Windows$Data$Xml$Dom$NodeType>;

/**
 * Gets or sets the text associated with the node.
 */
nodeValue: any;

/**
 * This method is not applicable to this class and will throw an exception.
 */
normalize(): void;

/**
 * Returns the root of the document that contains the node.
 */
ownerDocument: Windows$Data$Xml$Dom$XmlDocument;

/**
 * This property is not applicable to this class and will throw an exception.
 */
parentNode: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets or sets the namespace prefix.
 */
prefix: any;

/**
 * This property is not applicable to this class and will throw an exception.
 */
previousSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Removes the specified child node from the list of children and returns it.
 * @param childNode The child node to be removed from the list of children of this node.
 * @return The removed child node. If null, the childNode object is not removed.
 */
removeChild(childNode: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param referenceChild The old child that is to be replaced by the new child.
 * @return The old child that is replaced. If null, no object is created.
 */
replaceChild(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
selectNodes(xpath: string): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expresssion.
 * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
selectNodesNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
selectSingleNode(xpath: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets a value that indicates whether the attribute is explicitly specified or derived from a default value in the document type definition (DTD) or schema.
 */
specified: boolean;

/**
 * Gets or sets the attribute value.
 */
value: string
}


/**
 * Represents a CDATA section of an XML document.
 */
declare class Windows$Data$Xml$Dom$XmlCDataSection  {

/**
 * This method is not applicable to this class. The CDataSection does not have children. This method will throw an exception.
 * @param newChild The new child node to be appended to the end of the list of children of this node.
 * @return The new child node successfully appended to the list. If null, no object is created.
 */
appendChild(newChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Appends the supplied string to the existing string data.
 * @param data The data to be appended to the existing string.
 */
appendData(data: string): void;

/**
 * Gets the list of attributes of this node.
 */
attributes: Windows$Data$Xml$Dom$XmlNamedNodeMap;

/**
 * Gets a list of children in the current node. This property always returns NULL.
 */
childNodes: Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Clones a new node.
 * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return The newly created clone node.
 */
cloneNode(deep: boolean): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets or sets the node data depending on the node type.
 */
data: string;

/**
 * Deletes specified data.
 * @param offset The offset, in characters, at which to start deleting the string data.
 * @param count The number of characters to delete.
 */
deleteData(offset: number, count: number): void;

/**
 * Gets the first child node. This property always returns NULL.
 */
firstChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the XML representation of the node and all its descendants.
 * @return The XML representation of the node and all its descendants.
 */
getXml(): string;

/**
 * Determines whether a node has children. The CDataSection does not have children. This method always returns false.
 * @return True if this node has children; otherwise false. This method always returns false.
 */
hasChildNodes(): boolean;

/**
 * Gets the text from inside the XML.
 */
innerText: string;

/**
 * Inserts a child node to the left of the specified node, or at the end of the child node list. This method is not applicable to this class and will throw an exception.
 * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return On success, the child node that was inserted. If null, no object is created.
 */
insertBefore(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Inserts a string at the specified offset.
 * @param offset The offset, in characters, at which to insert the supplied string data.
 * @param data The data to be inserted into the existing string.
 */
insertData(offset: number, data: string): void;

/**
 * Gets the last child node. This property always returns NULL because the CDataSection does not have children.
 */
lastChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the length of the data, in Unicode characters.
 */
length: number;

/**
 * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML.
 */
localName: any;

/**
 * Returns the Uniform Resource Identifier (URI) for the namespace.
 */
namespaceUri: any;

/**
 * Gets the next sibling of the node in the parent's child list.
 */
nextSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types.
 */
nodeName: string;

/**
 * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes.
 */
nodeType: $Values<typeof Windows$Data$Xml$Dom$NodeType>;

/**
 * Gets or sets the text associated with the node.
 */
nodeValue: any;

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 */
normalize(): void;

/**
 * Returns the root of the document that contains the node.
 */
ownerDocument: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets the parent node of the node instance.
 */
parentNode: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets or sets the namespace prefix.
 */
prefix: any;

/**
 * Gets the previous sibling of the node in the parent's child list.
 */
previousSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Removes the specified child node from the list of children and returns it. This method is not applicable to this class as the CDataSection does not have children. This method will throw an exception.
 * @param childNode The child node to be removed from the list of children of this node.
 * @return The removed child node. If null, the childNode object is not removed.
 */
removeChild(childNode: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Replaces the specified old child node with the supplied new child node. This method is not applicable to this class as the CDataSection does not have children. This method will throw an exception.
 * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param referenceChild The old child that is to be replaced by the new child.
 * @return The old child that is replaced. If null, no object is created.
 */
replaceChild(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Replaces the specified number of characters with the supplied string.
 * @param offset The offset, in characters, at which to start replacing string data.
 * @param count The number of characters to replace.
 * @param data The new data that replaces the old string data.
 */
replaceData(offset: number, count: number, data: string): void;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList . This method is not applicable to this class and will throw an exception.
 * @param xpath Specifies an XPath expression.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
selectNodes(xpath: string): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList . This method is not applicable to this class and will throw an exception.
 * @param xpath Specifies an XPath expresssion.
 * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
selectNodesNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node. This method is not applicable to this class and will throw an exception.
 * @param xpath Specifies an XPath expression.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
selectSingleNode(xpath: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node. This method is not applicable to this class and will throw an exception.
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Splits this text node into two text nodes at the specified offset and inserts the new text node into the tree as a sibling that immediately follows this node.
 * @param offset The number of characters at which to split this text node into two nodes, starting from zero.
 * @return The new text node.
 */
splitText(offset: number): Windows$Data$Xml$Dom$IXmlText;

/**
 * Retrieves a substring of the full string from the specified range.
 * @param offset Specifies the offset, in characters, from the beginning of the string. An offset of zero indicates copying from the start of the data.
 * @param count Specifies the number of characters to retrieve from the specified offset.
 * @return The returned substring.
 */
substringData(offset: number, count: number): string
}


/**
 * Represents an XML comment.
 */
declare class Windows$Data$Xml$Dom$XmlComment  {

/**
 * Appends a new child node as the last child of the node. This method is not applicable to this class and it will throw an exception.
 * @param newChild The new child node to be appended to the end of the list of children of this node.
 * @return The new child node successfully appended to the list. If null, no object is created.
 */
appendChild(newChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Appends the supplied string to the existing string data.
 * @param data The data to be appended to the existing string.
 */
appendData(data: string): void;

/**
 * Gets the list of attributes of this node.
 */
attributes: Windows$Data$Xml$Dom$XmlNamedNodeMap;

/**
 * Gets a list of children in the current node. This method always returns NULL.
 */
childNodes: Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Clones a new node.
 * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return The newly created clone node.
 */
cloneNode(deep: boolean): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets or sets the node data depending on the node type.
 */
data: string;

/**
 * Deletes the specified data.
 * @param offset The offset, in characters, at which to start deleting the string data.
 * @param count The number of characters to delete.
 */
deleteData(offset: number, count: number): void;

/**
 * Gets the first child node. This property always returns NULL.
 */
firstChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the XML representation of the node and all its descendants.
 * @return The XML representation of the node and all its descendants.
 */
getXml(): string;

/**
 * Determines whether a node has children.
 * @return True if this node has children; otherwise false.
 */
hasChildNodes(): boolean;

/**
 * Gets the text from inside the XML.
 */
innerText: string;

/**
 * Inserts a child node to the left of the specified node, or at the end of the list. This method is not applicable to this class and will throw an exception.
 * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return On success, the child node that was inserted. If null, no object is created.
 */
insertBefore(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Inserts a string at the specified offset.
 * @param offset The offset, in characters, at which to insert the supplied string data.
 * @param data The data to be inserted into the existing string.
 */
insertData(offset: number, data: string): void;

/**
 * Gets the last child node. This property always returns NULL.
 */
lastChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the length of the data in Unicode characters.
 */
length: number;

/**
 * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML.
 */
localName: any;

/**
 * Returns the Uniform Resource Identifier (URI) for the namespace.
 */
namespaceUri: any;

/**
 * Gets the next sibling of the node in the parent's child list.
 */
nextSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types.
 */
nodeName: string;

/**
 * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes.
 */
nodeType: $Values<typeof Windows$Data$Xml$Dom$NodeType>;

/**
 * Gets or sets the text associated with the node.
 */
nodeValue: any;

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 */
normalize(): void;

/**
 * Returns the root of the document that contains the node.
 */
ownerDocument: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets the parent node of the node instance.
 */
parentNode: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets or sets the namespace prefix.
 */
prefix: any;

/**
 * Gets the previous sibling of the node in the parent's child list.
 */
previousSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Removes the specified child node from the list of children and returns it. This method is not applicable to this class and will throw an exception.
 * @param childNode The child node to be removed from the list of children of this node.
 * @return The removed child node. If null, the childNode object is not removed.
 */
removeChild(childNode: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Replaces the specified old child node with the supplied new child node. This method is not applicable to this class and will throw an exception.
 * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param referenceChild The old child that is to be replaced by the new child.
 * @return The old child that is replaced. If null, no object is created.
 */
replaceChild(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Replaces the specified number of characters with the supplied string.
 * @param offset The offset, in characters, at which to start replacing string data.
 * @param count The number of characters to replace.
 * @param data The new data that replaces the old string data.
 */
replaceData(offset: number, count: number, data: string): void;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList . This method is not applicable to this class and will throw an exception.
 * @param xpath Specifies an XPath expression.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
selectNodes(xpath: string): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList . This method is not applicable to this class and will throw an exception.
 * @param xpath Specifies an XPath expresssion.
 * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
selectNodesNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node. This method is not applicable to this class and will throw an exception.
 * @param xpath Specifies an XPath expression.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
selectSingleNode(xpath: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node. This method is not applicable to this class and will throw an exception.
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Retrieves a substring of the full string from the specified range.
 * @param offset Specifies the offset, in characters, from the beginning of the string. An offset of zero indicates copying from the start of the data.
 * @param count Specifies the number of characters to retrieve from the specified offset.
 * @return The returned substring.
 */
substringData(offset: number, count: number): string
}


/**
 * Represents the top level of the XML source. This class includes members for retrieving and creating all other XML objects.
 */
declare class Windows$Data$Xml$Dom$XmlDocument  {

/**
 * Asynchronously loads an XML document from the specified file. The document is parsed using the provided settings.
 * @param file The file from which to load the document.
 * @param loadSettings Settings for customizing parser behavior.
 * @return The object that must be used to start the operation.
 */
static loadFromFileAsync(
file: Windows$Storage$IStorageFile,
loadSettings: Windows$Data$Xml$Dom$XmlLoadSettings): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Data$Xml$Dom$XmlDocument>;

/**
 * Asynchronously loads an XML document from the specified file. The document is parsed using the default parser settings.
 * @param file The file from which to load the document.
 * @return The object that must be used to start the operation.
 */
static loadFromFileAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Data$Xml$Dom$XmlDocument>;

/**
 * Asynchronously loads an XML document from the specified location. The document is parsed using the provided settings.
 * @param uri A URL that specifies the location of the XML file.
 * @param loadSettings Customizes parser behavior.
 * @return An object that must be used to start the operation.
 */
static loadFromUriAsync(
uri: Windows$Foundation$Uri,
loadSettings: Windows$Data$Xml$Dom$XmlLoadSettings): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Data$Xml$Dom$XmlDocument>;

/**
 * Asynchronously loads an XML document from the specified location. The document is parsed using the default parser settings.
 * @param uri A URL that specifies the location of the XML file.
 * @return The object that must be used to start the operation.
 */
static loadFromUriAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Data$Xml$Dom$XmlDocument>;

/**
 * Creates a new instance of the XmlDocument class.
 */
constructor(): this;

/**
 * Appends a new child node as the last child of the node.
 * @param newChild The new child node to be appended to the end of the list of children of this node.
 * @return The new child node successfully appended to the list. If null, no object is created.
 */
appendChild(newChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the list of attributes of this node.
 */
attributes: Windows$Data$Xml$Dom$XmlNamedNodeMap;

/**
 * Gets a list of children in the current node.
 */
childNodes: Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Clones a new node.
 * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return The newly created clone node.
 */
cloneNode(deep: boolean): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Creates a new attribute with the specified name.
 * @param name The name of the new attribute object. This name is subsequently available as the new node's NodeName property.
 * @return The newly created attribute.
 */
createAttribute(name: string): Windows$Data$Xml$Dom$XmlAttribute;

/**
 * Creates a new attribute with the specified namespace and name.
 * @param namespaceUri The name of the desired namespace or a null value if no namespace is desired.
 * @param qualifiedName The name of the new attribute object. This name is subsequently available as the new node's NodeName property.
 * @return The newly created attribute.
 */
createAttributeNS(namespaceUri: any, qualifiedName: string): Windows$Data$Xml$Dom$XmlAttribute;

/**
 * Creates a CDATA section node that contains the supplied data.
 * @param data The value to be supplied to the new CDATA section object's NodeValue property.
 * @return The newly created object.
 */
createCDataSection(data: string): Windows$Data$Xml$Dom$XmlCDataSection;

/**
 * Creates a comment node that contains the supplied data.
 * @param data The value to be supplied to the new comment object's NodeValue .
 * @return The newly created comment node.
 */
createComment(data: string): Windows$Data$Xml$Dom$XmlComment;

/**
 * Creates an empty XmlDocumentFragment object.
 * @return The newly created object.
 */
createDocumentFragment(): Windows$Data$Xml$Dom$XmlDocumentFragment;

/**
 * Creates an element node using the specified name.
 * @param tagName The name for the new element node. The string is case-sensitive. This name is subsequently available as the element node's NodeName property.
 * @return The newly created object.
 */
createElement(tagName: string): Windows$Data$Xml$Dom$XmlElement;

/**
 * Creates an element node using the specified namespace and name.
 * @param namespaceUri The name of the desired namespace or a null value if no namespace is desired.
 * @param qualifiedName The name for the new element node. It is case-sensitive. This name is subsequently available as the element node's NodeName property.
 * @return The newly created object.
 */
createElementNS(namespaceUri: any, qualifiedName: string): Windows$Data$Xml$Dom$XmlElement;

/**
 * Creates a new XmlEntityReference object.
 * @param name The name of the entity referenced. This name is subsequently available as the new object's NodeName property.
 * @return The newly created object.
 */
createEntityReference(name: string): Windows$Data$Xml$Dom$XmlEntityReference;

/**
 * Creates a processing instruction node that contains the supplied target and data.
 * @param target The target part of the processing instruction. It supplies the NodeName property of the new object.
 * @param data The remainder of the processing instruction preceding the closing ?> characters. It supplies the NodeValue property for the new object.
 * @return The newly created object.
 */
createProcessingInstruction(target: string, data: string): Windows$Data$Xml$Dom$XmlProcessingInstruction;

/**
 * Creates a text node that contains the supplied data.
 * @param data The value to be supplied to the new text object's NodeValue .
 * @return The created text node.
 */
createTextNode(data: string): Windows$Data$Xml$Dom$XmlText;

/**
 * For XML, this property gets the address of the node that specifies the DTD. This property returns Null for for HTML documents and XML documents without a DTD.
 */
doctype: Windows$Data$Xml$Dom$XmlDocumentType;

/**
 * Gets the root element of the document.
 */
documentElement: Windows$Data$Xml$Dom$XmlElement;

/**
 * Returns the URL for the last loaded XML document.
 */
documentUri: string;

/**
 * Gets the first child node.
 */
firstChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the element that matches the ID attribute.
 * @param elementId The ID to match.
 * @return The element that matches the supplied ID. If no elements match, this method returns Null.
 */
getElementById(elementId: string): Windows$Data$Xml$Dom$XmlElement;

/**
 * Returns a collection of elements that have the specified name.
 * @param tagName The element name to find. The value "*" returns all elements in the document.
 * @return The collection of elements that match the specified name.
 */
getElementsByTagName(tagName: string): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Returns the XML representation of the node and all its descendants.
 * @return The XML representation of the node and all its descendants.
 */
getXml(): string;

/**
 * Determines whether a node has children.
 * @return True if this node has children; otherwise false.
 */
hasChildNodes(): boolean;

/**
 * Gets the Implementation object for the document.
 */
implementation: Windows$Data$Xml$Dom$XmlDomImplementation;

/**
 * Imports a node from another document to this document.
 * @param node The object to be cloned.
 * @param deep If true, any children of node will be cloned as well. If false, no children of the node will be cloned.
 * @return The imported node.
 */
importNode(
node: Windows$Data$Xml$Dom$IXmlNode,
deep: boolean): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the text from inside the XML.
 */
innerText: string;

/**
 * Inserts a child node to the left of the specified node, or at the end of the child node list.
 * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return On success, the child node that was inserted. If null, no object is created.
 */
insertBefore(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the last child node.
 */
lastChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Loads an XML document using the supplied string. The document is parsed using the settings provided.
 * @param xml The XML string to load into this XML document object. This string can contain an entire XML document or a well-formed fragment.
 * @param loadSettings The settings for parsing the document.
 */
loadXml(xml: string, loadSettings: Windows$Data$Xml$Dom$XmlLoadSettings): void;

/**
 * Loads an XML document using the supplied string. The document is parsed using the default parser settings.
 * @param xml The XML string to load into this XML document object. This string can contain an entire XML document or a well-formed fragment.
 */
loadXml(xml: string): void;

/**
 * Loads an XML document using the buffer. The document is parsed using the default parser settings.
 * @param buffer The buffer to load into this XML document object. This buffer can contain an entire XML document or a well-formed fragment.
 */
loadXmlFromBuffer(buffer: Windows$Storage$Streams$IBuffer): void;

/**
 * Loads an XML document using the buffer. The document is parsed using the settings provided.
 * @param buffer The buffer to load into this XML document object. This buffer can contain an entire XML document or a well-formed fragment.
 * @param loadSettings The settings for parsing the document.
 */
loadXmlFromBuffer(
buffer: Windows$Storage$Streams$IBuffer,
loadSettings: Windows$Data$Xml$Dom$XmlLoadSettings): void;

/**
 * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML.
 */
localName: any;

/**
 * Returns the Uniform Resource Identifier (URI) for the namespace.
 */
namespaceUri: any;

/**
 * Gets the next sibling of the node in the parent's child list. This property is not applicable to this class.
 */
nextSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types.
 */
nodeName: string;

/**
 * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes.
 */
nodeType: $Values<typeof Windows$Data$Xml$Dom$NodeType>;

/**
 * Gets or sets the text associated with the node.
 */
nodeValue: any;

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 */
normalize(): void;

/**
 * Returns the root of the document that contains the node.
 */
ownerDocument: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets the parent node of the node instance.
 */
parentNode: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets or sets the namespace prefix.
 */
prefix: any;

/**
 * Gets the previous sibling of the node in the parent's child list. This property is not applicable to this class.
 */
previousSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Removes the specified child node from the list of children and returns it.
 * @param childNode The child node to be removed from the list of children of this node.
 * @return The removed child node. If null, the childNode object is not removed.
 */
removeChild(childNode: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param referenceChild The old child that is to be replaced by the new child.
 * @return The old child that is replaced. If null, no object is created.
 */
replaceChild(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Asynchronously saves an XML document to the specified file.
 * @param file The file to save the document to.
 * @return The object that must be used to start the operation.
 */
saveToFileAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
selectNodes(xpath: string): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
selectNodesNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
selectSingleNode(xpath: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$IXmlNode
}


/**
 * Represents a lightweight object that is useful for tree insertion operations.
 */
declare class Windows$Data$Xml$Dom$XmlDocumentFragment  {

/**
 * Appends a new child node as the last child of the node.
 * @param newChild The new child node to be appended to the end of the list of children of this node.
 * @return The new child node successfully appended to the list. If null, no object is created.
 */
appendChild(newChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the list of attributes of this node.
 */
attributes: Windows$Data$Xml$Dom$XmlNamedNodeMap;

/**
 * Gets a list of children in the current node.
 */
childNodes: Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Clones a new node.
 * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return The newly created clone node.
 */
cloneNode(deep: boolean): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the first child node.
 */
firstChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the XML representation of the node and all its descendants.
 * @return The XML representation of the node and all its descendants.
 */
getXml(): string;

/**
 * Determines whether a node has children.
 * @return True if this node has children; otherwise false.
 */
hasChildNodes(): boolean;

/**
 * Gets the text from inside the XML.
 */
innerText: string;

/**
 * Inserts a child node to the left of the specified node, or at the end of the list.
 * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return On success, the child node that was inserted. If null, no object is created.
 */
insertBefore(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the last child node.
 */
lastChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML.
 */
localName: any;

/**
 * Returns the Uniform Resource Identifier (URI) for the namespace.
 */
namespaceUri: any;

/**
 * Gets the next sibling of the node in the parent's child list.
 */
nextSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types.
 */
nodeName: string;

/**
 * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes.
 */
nodeType: $Values<typeof Windows$Data$Xml$Dom$NodeType>;

/**
 * Gets or sets the text associated with the node.
 */
nodeValue: any;

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 */
normalize(): void;

/**
 * Returns the root of the document that contains the node.
 */
ownerDocument: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets the parent node of the node instance. This property is not applicable to this class.
 */
parentNode: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets or sets the namespace prefix.
 */
prefix: any;

/**
 * Gets the previous sibling of the node in the parent's child list. This property is not applicable to this class.
 */
previousSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Removes the specified child node from the list of children and returns it.
 * @param childNode The child node to be removed from the list of children of this node.
 * @return The removed child node. If null, the childNode object is not removed.
 */
removeChild(childNode: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param referenceChild The old child that is to be replaced by the new child.
 * @return The old child that is replaced. If null, no object is created.
 */
replaceChild(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
selectNodes(xpath: string): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
selectNodesNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
selectSingleNode(xpath: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$IXmlNode
}


/**
 * Contains information associated with the document type.
 */
declare class Windows$Data$Xml$Dom$XmlDocumentType  {

/**
 * Appends a new child node as the last child of the node.
 * @param newChild The new child node to be appended to the end of the list of children of this node.
 * @return The new child node successfully appended to the list. If null, no object is created.
 */
appendChild(newChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the list of attributes of this node.
 */
attributes: Windows$Data$Xml$Dom$XmlNamedNodeMap;

/**
 * Gets a list of children in the current node.
 */
childNodes: Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Clones a new node.
 * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return The newly created clone node.
 */
cloneNode(deep: boolean): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets a list of the entities declared in the <!DOCTYPE> declaration.
 */
entities: Windows$Data$Xml$Dom$XmlNamedNodeMap;

/**
 * Gets the first child node.
 */
firstChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the XML representation of the node and all its descendants.
 * @return The XML representation of the node and all its descendants.
 */
getXml(): string;

/**
 * Determines whether a node has children.
 * @return True if this node has children; otherwise false.
 */
hasChildNodes(): boolean;

/**
 * Gets the text from inside the XML.
 */
innerText: string;

/**
 * Inserts a child node to the left of the specified node, or at the end of the list.
 * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return On success, the child node that was inserted. If null, no object is created.
 */
insertBefore(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the last child node.
 */
lastChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML.
 */
localName: any;

/**
 * A list of the general entities, both external and internal, that are present in this document.
 */
name: string;

/**
 * Returns the Uniform Resource Identifier (URI) for the namespace.
 */
namespaceUri: any;

/**
 * Gets the next sibling of the node in the parent's child list.
 */
nextSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types.
 */
nodeName: string;

/**
 * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes.
 */
nodeType: $Values<typeof Windows$Data$Xml$Dom$NodeType>;

/**
 * Gets or sets the text associated with the node.
 */
nodeValue: any;

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 */
normalize(): void;

/**
 * Returns a list of the DtdNotation members that are present in the document type declaration.
 */
notations: Windows$Data$Xml$Dom$XmlNamedNodeMap;

/**
 * Returns the root of the document that contains the node.
 */
ownerDocument: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets the parent node of the node instance.
 */
parentNode: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets or sets the namespace prefix.
 */
prefix: any;

/**
 * Gets the previous sibling of the node in the parent's child list.
 */
previousSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Removes the specified child node from the list of children and returns it.
 * @param childNode The child node to be removed from the list of children of this node.
 * @return The removed child node. If null, the childNode object is not removed.
 */
removeChild(childNode: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param referenceChild The old child that is to be replaced by the new child.
 * @return The old child that is replaced. If null, no object is created.
 */
replaceChild(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
selectNodes(xpath: string): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
selectNodesNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
selectSingleNode(xpath: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$IXmlNode
}


/**
 * Provides methods that are independent of any particular instance of the document object model.
 */
declare class Windows$Data$Xml$Dom$XmlDomImplementation  {

/**
 * Indicates support for the specified feature.
 * @param feature Specifies the feature to test. In Level 1, valid feature values are "XML", "DOM", and "MS-DOM" (case-insensitive).
 * @param version Specifies the version number to test. If NULL, tests for implementation of the feature in any version. In Level 1, "1.0" is the valid version value.
 * @return True if the specified feature is implemented; otherwise false.
 */
hasFeature(feature: string, version: any): boolean
}


/**
 * Encapsulates information specific to XML Element nodes.
 */
declare class Windows$Data$Xml$Dom$XmlElement  {

/**
 * Appends a new child node as the last child of the node.
 * @param newChild The new child node to be appended to the end of the list of children of this node.
 * @return The new child node successfully appended to the list. If null, no object is created.
 */
appendChild(newChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the list of attributes of this node.
 */
attributes: Windows$Data$Xml$Dom$XmlNamedNodeMap;

/**
 * Gets a list of children in the current node.
 */
childNodes: Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Clones a new node.
 * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return The newly created clone node.
 */
cloneNode(deep: boolean): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the first child node.
 */
firstChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the value of the attribute.
 * @param attributeName The name of the required attribute.
 * @return The string value of the attribute.
 */
getAttribute(attributeName: string): string;

/**
 * Returns the value of the attribute.
 * @param namespaceUri The namespace of the attribute to get.
 * @param localName The name of the attribute without the namespace prefix.
 * @return The string value of the attribute.
 */
getAttributeNS(namespaceUri: any, localName: string): string;

/**
 * Returns the attribute node.
 * @param attributeName The name of the required attribute.
 * @return The returned attribute pointer.
 */
getAttributeNode(attributeName: string): Windows$Data$Xml$Dom$XmlAttribute;

/**
 * Returns the specified attribute from the specified namespace.
 * @param namespaceUri The namespace of the attribute to get.
 * @param localName The name of the attribute without the namespace prefix.
 * @return The returned attribute pointer.
 */
getAttributeNodeNS(namespaceUri: any, localName: string): Windows$Data$Xml$Dom$XmlAttribute;

/**
 * Returns a list of all descendant elements that match the supplied name.
 * @param tagName The tag of the required elements.
 * @return The required elements. The list can be empty.
 */
getElementsByTagName(tagName: string): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Returns the XML representation of the node and all its descendants.
 * @return The XML representation of the node and all its descendants.
 */
getXml(): string;

/**
 * Determines whether a node has children.
 * @return True if this node has children; otherwise false.
 */
hasChildNodes(): boolean;

/**
 * Gets the text from inside the XML.
 */
innerText: string;

/**
 * Inserts a child node to the left of the specified node, or at the end of the list.
 * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return On success, the child node that was inserted. If null, no object is created.
 */
insertBefore(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the last child node.
 */
lastChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML.
 */
localName: any;

/**
 * Returns the Uniform Resource Identifier (URI) for the namespace.
 */
namespaceUri: any;

/**
 * Gets the next sibling of the node in the parent's child list.
 */
nextSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types.
 */
nodeName: string;

/**
 * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes.
 */
nodeType: $Values<typeof Windows$Data$Xml$Dom$NodeType>;

/**
 * Gets or sets the text associated with the node.
 */
nodeValue: any;

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 */
normalize(): void;

/**
 * Returns the root of the document that contains the node.
 */
ownerDocument: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets the parent node of the node instance.
 */
parentNode: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets or sets the namespace prefix.
 */
prefix: any;

/**
 * Gets the previous sibling of the node in the parent's child list.
 */
previousSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Removes or replaces the named attribute.
 * @param attributeName The name of the attribute to be removed.
 */
removeAttribute(attributeName: string): void;

/**
 * Removes the specified attribute from this element in the specified namespace.
 * @param namespaceUri The namespace of attribute to be removed.
 * @param localName The name of the attribute without the namespace prefix.
 */
removeAttributeNS(namespaceUri: any, localName: string): void;

/**
 * Removes the specified attribute from this element.
 * @param attributeNode The attribute to be removed.
 * @return The removed attribute, if any.
 */
removeAttributeNode(
attributeNode: Windows$Data$Xml$Dom$XmlAttribute): Windows$Data$Xml$Dom$XmlAttribute;

/**
 * Removes the specified child node from the list of children and returns it.
 * @param childNode The child node to be removed from the list of children of this node.
 * @return The removed child node. If null, the childNode object is not removed.
 */
removeChild(childNode: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param referenceChild The old child that is to be replaced by the new child.
 * @return The old child that is replaced. If null, no object is created.
 */
replaceChild(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
selectNodes(xpath: string): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
selectNodesNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
selectSingleNode(xpath: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Sets the value of the named attribute.
 * @param attributeName The name of the required attribute.
 * @param attributeValue The new value for the attribute.
 */
setAttribute(attributeName: string, attributeValue: string): void;

/**
 * Sets the value of the named attribute in the given namespace.
 * @param namespaceUri The namespace of the attribute being set.
 * @param qualifiedName The name of the attribute being set.
 * @param value The new value for the attribute.
 */
setAttributeNS(namespaceUri: any, qualifiedName: string, value: string): void;

/**
 * Sets or updates the supplied attribute node on this element.
 * @param newAttribute A pointer to the new attribute.
 * @return The returned pointer to the previous attribute (if any) with the same name.
 */
setAttributeNode(
newAttribute: Windows$Data$Xml$Dom$XmlAttribute): Windows$Data$Xml$Dom$XmlAttribute;

/**
 * Sets or updates the supplied attribute node on this element. If you are not using any namespaces, then use the SetAttributeNode method.
 * @param newAttribute The node to add to the collection.
 * @return The attribute successfully added to the collection. If Null, no object is created.
 */
setAttributeNodeNS(
newAttribute: Windows$Data$Xml$Dom$XmlAttribute): Windows$Data$Xml$Dom$XmlAttribute;

/**
 * Gets the element name.
 */
tagName: string
}


/**
 * Represents an entity reference node.
 */
declare class Windows$Data$Xml$Dom$XmlEntityReference  {

/**
 * Appends a new child node as the last child of the node.
 * @param newChild The new child node to be appended to the end of the list of children of this node.
 * @return The new child node successfully appended to the list. If null, no object is created.
 */
appendChild(newChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the list of attributes of this node.
 */
attributes: Windows$Data$Xml$Dom$XmlNamedNodeMap;

/**
 * Gets a list of children in the current node.
 */
childNodes: Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Clones a new node.
 * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return The newly created clone node.
 */
cloneNode(deep: boolean): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the first child node.
 */
firstChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the XML representation of the node and all its descendants.
 * @return The XML representation of the node and all its descendants.
 */
getXml(): string;

/**
 * Determines whether a node has children.
 * @return True if this node has children; otherwise false.
 */
hasChildNodes(): boolean;

/**
 * Gets the text from inside the XML.
 */
innerText: string;

/**
 * Inserts a child node to the left of the specified node, or at the end of the list.
 * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return On success, the child node that was inserted. If null, no object is created.
 */
insertBefore(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the last child node.
 */
lastChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML.
 */
localName: any;

/**
 * Returns the Uniform Resource Identifier (URI) for the namespace.
 */
namespaceUri: any;

/**
 * Gets the next sibling of the node in the parent's child list.
 */
nextSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types.
 */
nodeName: string;

/**
 * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes.
 */
nodeType: $Values<typeof Windows$Data$Xml$Dom$NodeType>;

/**
 * Gets or sets the text associated with the node.
 */
nodeValue: any;

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 */
normalize(): void;

/**
 * Returns the root of the document that contains the node.
 */
ownerDocument: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets the parent node of the node instance.
 */
parentNode: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets or sets the namespace prefix.
 */
prefix: any;

/**
 * Gets the previous sibling of the node in the parent's child list.
 */
previousSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Removes the specified child node from the list of children and returns it.
 * @param childNode The child node to be removed from the list of children of this node.
 * @return The removed child node. If null, the childNode object is not removed.
 */
removeChild(childNode: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param referenceChild The old child that is to be replaced by the new child.
 * @return The old child that is replaced. If null, no object is created.
 */
replaceChild(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
selectNodes(xpath: string): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
selectNodesNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
selectSingleNode(xpath: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$IXmlNode
}


/**
 * Contains settings that are used during loading and parsing of XML documents. The default settings are chosen for the highest security. This class can be instantiated and is accepted by LoadXml , LoadFromUriAsync , and LoadFromFileAsync .
 */
declare class Windows$Data$Xml$Dom$XmlLoadSettings  {

/**
 * Creates a new XmlLoadSettings object.
 */
constructor(): this;

/**
 * Specifies whether default handling preserves white space.
 */
elementContentWhiteSpace: boolean;

/**
 * Gets and sets the limits of the element depth of an XML document to be loaded into a DOM object.
 */
maxElementDepth: number;

/**
 * Gets or sets a value that specifies whether to prohibit or allow the inclusion of a DTD in the XML DOM document.
 */
prohibitDtd: boolean;

/**
 * Gets or sets a value that specifies whether external definitions, resolvable namespaces, external subsets of document type definitions (DTDs), and external entity references are to be resolved at the time the document is parsed.
 */
resolveExternals: boolean;

/**
 * Gets or sets a value that specifies whether the XML parser should validate this document against the document type definition (DTD) on loading.
 */
validateOnParse: boolean
}


/**
 * Encapsulates iteration through the collection of attribute nodes.
 */
declare class Windows$Data$Xml$Dom$XmlNamedNodeMap mixins Array<Windows$Data$Xml$Dom$IXmlNode> {

/**
 * Returns an iterator that iterates over the items in the collection.
 * @return The iterator.
 */
first(): Windows$Foundation$Collections$IIterator<Windows$Data$Xml$Dom$IXmlNode>;

/**
 * Returns the item at the specified index in the vector view.
 * @param index The zero-based index of the item in the vector view to return.
 * @return The item in the vector view at the specified index.
 */
getAt(index: number): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the items that start at the specified index of the vector view.
 * @param startIndex The zero-based index of the start of the items in the vector to return.
 */
getMany(
startIndex: number): {
items: Windows$Data$Xml$Dom$IXmlNode,
returnValue: number
};

/**
 * Retrieves the attribute with the specified name.
 * @param name The name of the attribute.
 * @return The returned attribute with the specified name. This method returns Null if the attribute node is not in this collection.
 */
getNamedItem(name: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Retrieves the attribute with the specified namespace and name.
 * @param namespaceUri The namespace name of the attribute.
 * @param name The name of the attribute.
 * @return The attribute with the specified namespace and name. This method returns Null if the attribute node is not in this collection.
 */
getNamedItemNS(namespaceUri: any, name: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the index of a specified item in the vector view.
 * @param value The item to find in the vector view.
 */
indexOf(value: Windows$Data$Xml$Dom$IXmlNode): {
index: number,
returnValue: boolean
};

/**
 * Allows random access to individual nodes within the collection.
 * @param index The index of the item within the collection. The first item is zero.
 * @return The object to access. This method returns null if the index is out of range.
 */
item(index: number): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the length of the list of nodes.
 */
length: number;

/**
 * Removes the specified item.
 * @param name The name of the attribute to remove from the collection.
 * @return The node removed from the collection. This method returns Null if the named node is not an attribute.
 */
removeNamedItem(name: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Removes an item that is specified by a namespace and local name.
 * @param namespaceUri The namespace name of the attribute.
 * @param name The name of the attribute.
 * @return The node removed from the collection. This method returns Null if the named node is not an attribute.
 */
removeNamedItemNS(namespaceUri: any, name: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Adds the specified node to the collection.
 * @param node The node to add to the collection.
 * @return The attribute successfully added to the collection. If Null, no object is created.
 */
setNamedItem(node: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Adds the specified node to the collection in the specified namespace. If you are not using any namespaces, then use the SetNamedItem method.
 * @param node The node to add to the collection.
 * @return The attribute successfully added to the collection. If Null, no object is created.
 */
setNamedItemNS(node: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the number of elements in the vector view.
 */
size: number;
indexOf(
value: Windows$Data$Xml$Dom$IXmlNode,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(searchElement: Windows$Data$Xml$Dom$IXmlNode, fromIndex?: number): number
}


/**
 * Describes a collection of nodes.
 */
declare class Windows$Data$Xml$Dom$XmlNodeList mixins Array<Windows$Data$Xml$Dom$IXmlNode> {

/**
 * Returns an iterator that iterates over the items in the collection.
 * @return The iterator.
 */
first(): Windows$Foundation$Collections$IIterator<Windows$Data$Xml$Dom$IXmlNode>;

/**
 * Returns the item at the specified index in the vector view.
 * @param index The zero-based index of the item in the vector view to return.
 * @return The item in the vector view at the specified index.
 */
getAt(index: number): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the items that start at the specified index of the vector view.
 * @param startIndex The zero-based index of the start of the items in the vector to return.
 */
getMany(
startIndex: number): {
items: Windows$Data$Xml$Dom$IXmlNode,
returnValue: number
};

/**
 * Returns the index of a specified item in the vector.
 * @param value The item to find in the vector.
 */
indexOf(value: Windows$Data$Xml$Dom$IXmlNode): {
index: number,
returnValue: boolean
};

/**
 * Returns the item in the list at the specified index.
 * @param index The zero-based index of the requested item.
 * @return The requested item. This method returns NULL if the index is not valid.
 */
item(index: number): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the length of the list.
 */
length: number;

/**
 * Gets the number of elements in the vector view.
 */
size: number;
indexOf(
value: Windows$Data$Xml$Dom$IXmlNode,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(searchElement: Windows$Data$Xml$Dom$IXmlNode, fromIndex?: number): number
}


/**
 * Represents a processing instruction, which XML defines to keep processor-specific information in the text of the document.
 */
declare class Windows$Data$Xml$Dom$XmlProcessingInstruction  {

/**
 * Appends a new child node as the last child of the node.
 * @param newChild The new child node to be appended to the end of the list of children of this node.
 * @return The new child node successfully appended to the list. If null, no object is created.
 */
appendChild(newChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the list of attributes of this node.
 */
attributes: Windows$Data$Xml$Dom$XmlNamedNodeMap;

/**
 * Gets a list of children in the current node.
 */
childNodes: Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Clones a new node.
 * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return The newly created clone node.
 */
cloneNode(deep: boolean): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets or sets the content of the processing instruction, excluding the target.
 */
data: string;

/**
 * Gets the first child node.
 */
firstChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the XML representation of the node and all its descendants.
 * @return The XML representation of the node and all its descendants.
 */
getXml(): string;

/**
 * Determines whether a node has children.
 * @return True if this node has children; otherwise false.
 */
hasChildNodes(): boolean;

/**
 * Gets the text from inside the XML.
 */
innerText: string;

/**
 * Inserts a child node to the left of the specified node, or at the end of the list.
 * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return On success, the child node that was inserted. If null, no object is created.
 */
insertBefore(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the last child node.
 */
lastChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML.
 */
localName: any;

/**
 * Returns the Uniform Resource Identifier (URI) for the namespace.
 */
namespaceUri: any;

/**
 * Gets the next sibling of the node in the parent's child list.
 */
nextSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types.
 */
nodeName: string;

/**
 * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes.
 */
nodeType: $Values<typeof Windows$Data$Xml$Dom$NodeType>;

/**
 * Gets or sets the text associated with the node.
 */
nodeValue: any;

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 */
normalize(): void;

/**
 * Returns the root of the document that contains the node.
 */
ownerDocument: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets the parent node of the node instance.
 */
parentNode: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets or sets the namespace prefix.
 */
prefix: any;

/**
 * Gets the previous sibling of the node in the parent's child list.
 */
previousSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Removes the specified child node from the list of children and returns it.
 * @param childNode The child node to be removed from the list of children of this node.
 * @return The removed child node. If null, the childNode object is not removed.
 */
removeChild(childNode: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param referenceChild The old child that is to be replaced by the new child.
 * @return The old child that is replaced. If null, no object is created.
 */
replaceChild(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
selectNodes(xpath: string): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
selectNodesNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
selectSingleNode(xpath: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the target for the processing instruction.
 */
target: string
}


/**
 * Represents the text content of an element.
 */
declare class Windows$Data$Xml$Dom$XmlText  {

/**
 * Appends a new child node as the last child of the node.
 * @param newChild The new child node to be appended to the end of the list of children of this node.
 * @return The new child node successfully appended to the list. If null, no object is created.
 */
appendChild(newChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Appends the supplied string to the existing string data.
 * @param data The data to be appended to the existing string.
 */
appendData(data: string): void;

/**
 * Gets the list of attributes of this node.
 */
attributes: Windows$Data$Xml$Dom$XmlNamedNodeMap;

/**
 * Gets a list of children in the current node.
 */
childNodes: Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Clones a new node.
 * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return The newly created clone node.
 */
cloneNode(deep: boolean): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets or sets the node data depending on the node type.
 */
data: string;

/**
 * Deletes specified data.
 * @param offset The offset, in characters, at which to start deleting the string data.
 * @param count The number of characters to delete.
 */
deleteData(offset: number, count: number): void;

/**
 * Gets the first child node.
 */
firstChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the XML representation of the node and all its descendants.
 * @return The XML representation of the node and all its descendants.
 */
getXml(): string;

/**
 * Determines whether a node has children.
 * @return True if this node has children; otherwise false.
 */
hasChildNodes(): boolean;

/**
 * Gets the text from inside the XML.
 */
innerText: string;

/**
 * Inserts a child node to the left of the specified node, or at the end of the list.
 * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return On success, the child node that was inserted. If null, no object is created.
 */
insertBefore(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Inserts a string at the specified offset.
 * @param offset The offset, in characters, at which to insert the supplied string data.
 * @param data The data to be inserted into the existing string.
 */
insertData(offset: number, data: string): void;

/**
 * Gets the last child node.
 */
lastChild: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets the length of the data, in Unicode characters.
 */
length: number;

/**
 * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML.
 */
localName: any;

/**
 * Returns the Uniform Resource Identifier (URI) for the namespace.
 */
namespaceUri: any;

/**
 * Gets the next sibling of the node in the parent's child list.
 */
nextSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types.
 */
nodeName: string;

/**
 * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes.
 */
nodeType: $Values<typeof Windows$Data$Xml$Dom$NodeType>;

/**
 * Gets or sets the text associated with the node.
 */
nodeValue: any;

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 */
normalize(): void;

/**
 * Returns the root of the document that contains the node.
 */
ownerDocument: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets the parent node of the node instance.
 */
parentNode: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Gets or sets the namespace prefix.
 */
prefix: any;

/**
 * Gets the previous sibling of the node in the parent's child list.
 */
previousSibling: Windows$Data$Xml$Dom$IXmlNode;

/**
 * Removes the specified child node from the list of children and returns it.
 * @param childNode The child node to be removed from the list of children of this node.
 * @return The removed child node. If null, the childNode object is not removed.
 */
removeChild(childNode: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param referenceChild The old child that is to be replaced by the new child.
 * @return The old child that is replaced. If null, no object is created.
 */
replaceChild(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Replaces the specified number of characters with the supplied string.
 * @param offset The offset, in characters, at which to start replacing string data.
 * @param count The number of characters to replace.
 * @param data The new data that replaces the old string data.
 */
replaceData(offset: number, count: number, data: string): void;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
selectNodes(xpath: string): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
selectNodesNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$XmlNodeList;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
selectSingleNode(xpath: string): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$IXmlNode;

/**
 * Splits this text node into two text nodes at the specified offset and inserts the new text node into the tree as a sibling that immediately follows this node.
 * @param offset The number of characters at which to split this text node into two nodes, starting from zero.
 * @return The new text node.
 */
splitText(offset: number): Windows$Data$Xml$Dom$IXmlText;

/**
 * Retrieves a substring of the full string from the specified range.
 * @param offset The offset, in characters, from the beginning of the string. An offset of zero indicates copying from the start of the data.
 * @param count The number of characters to retrieve from the specified offset.
 * @return The returned substring.
 */
substringData(offset: number, count: number): string
}


/**
 * Contains information for the entire Document Object Model. This interface represents a single node in the document tree. While all objects that implement this interface expose methods for dealing with children, not all objects that implement this interface may have children.
 */
declare type Windows$Data$Xml$Dom$IXmlNode = {

/**
 * Appends a new child node as the last child of the node.
 * @param newChild The new child node to be appended to the end of the list of children of this node.
 * @return The new child node successfully appended to the list. If null, no object is created.
 */
appendChild(newChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode,

/**
 * Clones a new node.
 * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return The newly created clone node.
 */
cloneNode(deep: boolean): Windows$Data$Xml$Dom$IXmlNode,

/**
 * Determines whether a node has children.
 * @return True if this node has children; otherwise false.
 */
hasChildNodes(): boolean,

/**
 * Inserts a child node to the left of the specified node, or at the end of the list.
 * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return On success, the child node that was inserted. If null, no object is created.
 */
insertBefore(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode,

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 */
normalize(): void,

/**
 * Removes the specified child node from the list of children and returns it.
 * @param childNode The child node to be removed from the list of children of this node.
 * @return The removed child node. If null, the childNode object is not removed.
 */
removeChild(childNode: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode,

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param referenceChild The old child that is to be replaced by the new child.
 * @return The old child that is replaced. If null, no object is created.
 */
replaceChild(
newChild: Windows$Data$Xml$Dom$IXmlNode,
referenceChild: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$IXmlNode,

/**
 * Gets the list of attributes of this node.
 */
attributes: Windows$Data$Xml$Dom$XmlNamedNodeMap,

/**
 * Gets a list of children in the current node.
 */
childNodes: Windows$Data$Xml$Dom$XmlNodeList,

/**
 * Gets the first child node.
 */
firstChild: Windows$Data$Xml$Dom$IXmlNode,

/**
 * Gets the last child node.
 */
lastChild: Windows$Data$Xml$Dom$IXmlNode,

/**
 * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML.
 */
localName: any,

/**
 * Returns the Uniform Resource Identifier (URI) for the namespace.
 */
namespaceUri: any,

/**
 * Gets the next sibling of the node in the parent's child list.
 */
nextSibling: Windows$Data$Xml$Dom$IXmlNode,

/**
 * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types.
 */
nodeName: string,

/**
 * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes.
 */
nodeType: $Values<typeof Windows$Data$Xml$Dom$NodeType>,

/**
 * Gets or sets the text associated with the node.
 */
nodeValue: any,

/**
 * Returns the root of the document that contains the node.
 */
ownerDocument: Windows$Data$Xml$Dom$XmlDocument,

/**
 * Gets the parent node of the node instance.
 */
parentNode: Windows$Data$Xml$Dom$IXmlNode,

/**
 * Gets or sets the namespace prefix.
 */
prefix: any,

/**
 * Gets the previous sibling of the node in the parent's child list.
 */
previousSibling: Windows$Data$Xml$Dom$IXmlNode
} & Windows$Data$Xml$Dom$IXmlNodeSelector & Windows$Data$Xml$Dom$IXmlNodeSerializer



/**
 * Represents the text content of an element or attribute.
 */
declare type Windows$Data$Xml$Dom$IXmlText = {

/**
 * Splits this text node into two text nodes at the specified offset and inserts the new text node into the tree as a sibling that immediately follows this node.
 * @param offset The number of characters at which to split this text node into two nodes, starting from zero.
 * @return The new text node.
 */
splitText(offset: number): Windows$Data$Xml$Dom$IXmlText
} & Windows$Data$Xml$Dom$IXmlCharacterData & Windows$Data$Xml$Dom$IXmlNode & Windows$Data$Xml$Dom$IXmlNodeSelector & Windows$Data$Xml$Dom$IXmlNodeSerializer



/**
 * Encapsulates the methods needed to execute XPath queries on an XML DOM tree or subtree.
 */
declare interface Windows$Data$Xml$Dom$IXmlNodeSelector {

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList.
 * @param xpath Specifies an XPath expression.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
selectNodes(xpath: string): Windows$Data$Xml$Dom$XmlNodeList,

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList.
 * @param xpath Specifies an XPath expresssion.
 * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
selectNodesNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$XmlNodeList,

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
selectSingleNode(xpath: string): Windows$Data$Xml$Dom$IXmlNode,

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param xpath Specifies an XPath expression.
 * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Data$Xml$Dom$IXmlNode
} 


/**
 * Encapsulates the methods needed to serialize a DOM tree or subtree to a string representation.
 */
declare interface Windows$Data$Xml$Dom$IXmlNodeSerializer {

/**
 * Returns the XML representation of the node and all its descendants.
 * @return The XML representation of the node and all its descendants.
 */
getXml(): string,

/**
 * Gets and sets the text from inside the XML.
 */
innerText: string
} 


/**
 * Provides text manipulation methods that are used by several objects.
 */
declare type Windows$Data$Xml$Dom$IXmlCharacterData = {

/**
 * Appends the supplied string to the existing string data.
 * @param data The data to be appended to the existing string.
 */
appendData(data: string): void,

/**
 * Deletes specified data.
 * @param offset The offset, in characters, at which to start deleting the string data.
 * @param count The number of characters to delete.
 */
deleteData(offset: number, count: number): void,

/**
 * Inserts a string at the specified offset.
 * @param offset The offset, in characters, at which to insert the supplied string data.
 * @param data The data to be inserted into the existing string.
 */
insertData(offset: number, data: string): void,

/**
 * Replaces the specified number of characters with the supplied string.
 * @param offset The offset, in characters, at which to start replacing string data.
 * @param count The number of characters to replace.
 * @param data The new data that replaces the old string data.
 */
replaceData(offset: number, count: number, data: string): void,

/**
 * Retrieves a substring of the full string from the specified range.
 * @param offset Specifies the offset, in characters, from the beginning of the string. An offset of zero indicates copying from the start of the data.
 * @param count Specifies the number of characters to retrieve from the specified offset.
 * @return The returned substring.
 */
substringData(offset: number, count: number): string,

/**
 * Gets or sets the node data depending on the node type.
 */
data: string,

/**
 * Gets the length of the data, in Unicode characters.
 */
length: number
} & Windows$Data$Xml$Dom$IXmlNode & Windows$Data$Xml$Dom$IXmlNodeSelector & Windows$Data$Xml$Dom$IXmlNodeSerializer



      declare var npm$namespace$Windows$Data$Xml$Xsl: {
        
        
        
        XsltProcessor: typeof Windows$Data$Xml$Xsl$XsltProcessor,
        
      }

/**
 * Provides the methods needed by the Xslt processor.
 */
declare class Windows$Data$Xml$Xsl$XsltProcessor  {

/**
 * Creates a new XsltProcessor object from the document provided.
 * @param document The XSLT to process.
 */
constructor(document: Windows$Data$Xml$Dom$XmlDocument): this;

/**
 * Processes a node and its children and returns the resulting XmlDocument .
 * @param inputNode The node to process.
 * @return The resulting transformation.
 */
transformToDocument(inputNode: Windows$Data$Xml$Dom$IXmlNode): Windows$Data$Xml$Dom$XmlDocument;

/**
 * Processes a node and its children and returns the resulting string transformation.
 * @param inputNode The node to process.
 * @return The resulting transformation.
 */
transformToString(inputNode: Windows$Data$Xml$Dom$IXmlNode): string
}


      declare var npm$namespace$Windows$Devices: {
        
        
        
        LowLevelDevicesAggregateProvider: typeof Windows$Devices$LowLevelDevicesAggregateProvider,
LowLevelDevicesController: typeof Windows$Devices$LowLevelDevicesController,
        Adc: typeof npm$namespace$Windows$Devices$Adc,
AllJoyn: typeof npm$namespace$Windows$Devices$AllJoyn,
Background: typeof npm$namespace$Windows$Devices$Background,
Bluetooth: typeof npm$namespace$Windows$Devices$Bluetooth,
Custom: typeof npm$namespace$Windows$Devices$Custom,
Enumeration: typeof npm$namespace$Windows$Devices$Enumeration,
Geolocation: typeof npm$namespace$Windows$Devices$Geolocation,
Gpio: typeof npm$namespace$Windows$Devices$Gpio,
HumanInterfaceDevice: typeof npm$namespace$Windows$Devices$HumanInterfaceDevice,
I2c: typeof npm$namespace$Windows$Devices$I2c,
Input: typeof npm$namespace$Windows$Devices$Input,
Lights: typeof npm$namespace$Windows$Devices$Lights,
Midi: typeof npm$namespace$Windows$Devices$Midi,
Perception: typeof npm$namespace$Windows$Devices$Perception,
PointOfService: typeof npm$namespace$Windows$Devices$PointOfService,
Portable: typeof npm$namespace$Windows$Devices$Portable,
Power: typeof npm$namespace$Windows$Devices$Power,
Printers: typeof npm$namespace$Windows$Devices$Printers,
Pwm: typeof npm$namespace$Windows$Devices$Pwm,
Radios: typeof npm$namespace$Windows$Devices$Radios,
Scanners: typeof npm$namespace$Windows$Devices$Scanners,
Sensors: typeof npm$namespace$Windows$Devices$Sensors,
SerialCommunication: typeof npm$namespace$Windows$Devices$SerialCommunication,
SmartCards: typeof npm$namespace$Windows$Devices$SmartCards,
Sms: typeof npm$namespace$Windows$Devices$Sms,
Spi: typeof npm$namespace$Windows$Devices$Spi,
Usb: typeof npm$namespace$Windows$Devices$Usb,
WiFi: typeof npm$namespace$Windows$Devices$WiFi,
WiFiDirect: typeof npm$namespace$Windows$Devices$WiFiDirect,
      }

      declare var npm$namespace$Windows$Devices$Adc: {
        
        
        AdcChannelMode: typeof Windows$Devices$Adc$AdcChannelMode,
        AdcChannel: typeof Windows$Devices$Adc$AdcChannel,
AdcController: typeof Windows$Devices$Adc$AdcController,
        Provider: typeof npm$namespace$Windows$Devices$Adc$Provider,
      }

/**
 * Represents a single ADC channel.
 */
declare class Windows$Devices$Adc$AdcChannel  {

/**
 * Closes the connection on this channel, making it available to be opened by others.
 */
close(): void;

/**
 * Gets the ADC controller for this channel.
 */
controller: Windows$Devices$Adc$AdcController;

/**
 * Reads the value as a percentage of the max value possible for this controller.
 * @return The value as percentage of the max value.
 */
readRatio(): number;

/**
 * Reads the digital representation of the analog value from the ADC.
 * @return The digital value.
 */
readValue(): number
}


/**
 * Describes the channel modes that the ADC controller can use for input.
 */

declare  var Windows$Devices$Adc$AdcChannelMode: {|
  +singleEnded: 0,// 0
+differential: 1,// 1

|};



/**
 * Represents an ADC controller on the system
 */
declare class Windows$Devices$Adc$AdcController  {

/**
 * Gets all the controllers that are connected to the system asynchronously .
 * @param provider The ADC provider for the controllers on the system.
 * @return When the method completes successfully, it returns a list of values that represent the controllers available on the system.
 */
static getControllersAsync(
provider: Windows$Devices$Adc$Provider$IAdcProvider): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the default ADC controller on the system.
 * @return The default ADC controller on the system, or null if the system has no ADC controller.
 */
static getDefaultAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Adc$AdcController>;

/**
 * The number of channels available on the ADC controller.
 */
channelCount: number;

/**
 * Gets or sets the channel mode for the ADC controller.
 */
channelMode: $Values<typeof Windows$Devices$Adc$AdcChannelMode>;

/**
 * Verifies that the specified channel mode is supported by the controller.
 * @param channelMode The channel mode.
 * @return True if the specified channel mode is supported, otherwise false.
 */
isChannelModeSupported(channelMode: $Values<typeof Windows$Devices$Adc$AdcChannelMode>): boolean;

/**
 * Gets the maximum value that the controller can report.
 */
maxValue: number;

/**
 * The minimum value the controller can report.
 */
minValue: number;

/**
 * Opens a connection to the specified ADC channel.
 * @param channelNumber The channel to connect to.
 * @return The ADC channel.
 */
openChannel(channelNumber: number): Windows$Devices$Adc$AdcChannel;

/**
 * Gets the resolution of the controller as number of bits it has. For example, if we have a 10-bit ADC, that means it can detect 1024 (2^10) discrete levels.
 */
resolutionInBits: number
}


      declare var npm$namespace$Windows$Devices$Adc$Provider: {
        
        
        ProviderAdcChannelMode: typeof Windows$Devices$Adc$Provider$ProviderAdcChannelMode,
        
        
      }

/**
 * Determines how the pin value is represented. Implementation of specifics are decided by the provider, so differential may be fully or pseudo differential.
 */

declare  var Windows$Devices$Adc$Provider$ProviderAdcChannelMode: {|
  +singleEnded: 0,// 0
+differential: 1,// 1

|};



/**
 * Represents methods common to all ADC providers.
 */
declare interface Windows$Devices$Adc$Provider$IAdcProvider {

/**
 * Gets the ADC controllers available on the system.
 * @return When this method completes it returns a list of all the available controllers on the system.
 */
getControllers(
): Windows$Foundation$Collections$IVectorView<Windows$Devices$Adc$Provider$IAdcControllerProvider>
} 


/**
 * Represents properties and methods common to all ADC controllers.
 */
declare interface Windows$Devices$Adc$Provider$IAdcControllerProvider {

/**
 * Acquires a connection to the specified channel.
 * @param channel Which channel to connect to.
 */
acquireChannel(channel: number): void,

/**
 * Determines if the specified channel mode is supported by the controller.
 * @param channelMode The channel mode in question.
 * @return True if the specified channel mode is supported, otherwise false.
 */
isChannelModeSupported(
channelMode: $Values<typeof Windows$Devices$Adc$Provider$ProviderAdcChannelMode>): boolean,

/**
 * Gets the digital representation of the analog value on the specified channel.
 * @param channelNumber Which channel to read from.
 * @return The digital representation of the analog value.
 */
readValue(channelNumber: number): number,

/**
 * Releases the channel connection, opening that channel for others to use.
 * @param channel Which channel to close the connection to.
 */
releaseChannel(channel: number): void,

/**
 * Gets the number of channels available on for the controller.
 */
channelCount: number,

/**
 * Gets or sets the controller channel mode.
 */
channelMode: $Values<typeof Windows$Devices$Adc$Provider$ProviderAdcChannelMode>,

/**
 * Gets the maximum value that the controller can return.
 */
maxValue: number,

/**
 * Gets the minimum value that the controller can return.
 */
minValue: number,

/**
 * Gets the resolution of the controller as number of bits it has.
 */
resolutionInBits: number
} 


      declare var npm$namespace$Windows$Devices$AllJoyn: {
        
        
        AllJoynAuthenticationMechanism: typeof Windows$Devices$AllJoyn$AllJoynAuthenticationMechanism,
AllJoynBusAttachmentState: typeof Windows$Devices$AllJoyn$AllJoynBusAttachmentState,
AllJoynSessionLostReason: typeof Windows$Devices$AllJoyn$AllJoynSessionLostReason,
AllJoynTrafficType: typeof Windows$Devices$AllJoyn$AllJoynTrafficType,
        AllJoynAboutData: typeof Windows$Devices$AllJoyn$AllJoynAboutData,
AllJoynAboutDataView: typeof Windows$Devices$AllJoyn$AllJoynAboutDataView,
AllJoynAcceptSessionJoinerEventArgs: typeof Windows$Devices$AllJoyn$AllJoynAcceptSessionJoinerEventArgs,
AllJoynAuthenticationCompleteEventArgs: typeof Windows$Devices$AllJoyn$AllJoynAuthenticationCompleteEventArgs,
AllJoynBusAttachment: typeof Windows$Devices$AllJoyn$AllJoynBusAttachment,
AllJoynBusAttachmentStateChangedEventArgs: typeof Windows$Devices$AllJoyn$AllJoynBusAttachmentStateChangedEventArgs,
AllJoynCredentials: typeof Windows$Devices$AllJoyn$AllJoynCredentials,
AllJoynCredentialsRequestedEventArgs: typeof Windows$Devices$AllJoyn$AllJoynCredentialsRequestedEventArgs,
AllJoynCredentialsVerificationRequestedEventArgs: typeof Windows$Devices$AllJoyn$AllJoynCredentialsVerificationRequestedEventArgs,
AllJoynMessageInfo: typeof Windows$Devices$AllJoyn$AllJoynMessageInfo,
AllJoynProducerStoppedEventArgs: typeof Windows$Devices$AllJoyn$AllJoynProducerStoppedEventArgs,
AllJoynServiceInfo: typeof Windows$Devices$AllJoyn$AllJoynServiceInfo,
AllJoynServiceInfoRemovedEventArgs: typeof Windows$Devices$AllJoyn$AllJoynServiceInfoRemovedEventArgs,
AllJoynSessionLostEventArgs: typeof Windows$Devices$AllJoyn$AllJoynSessionLostEventArgs,
AllJoynSessionMemberAddedEventArgs: typeof Windows$Devices$AllJoyn$AllJoynSessionMemberAddedEventArgs,
AllJoynSessionMemberRemovedEventArgs: typeof Windows$Devices$AllJoyn$AllJoynSessionMemberRemovedEventArgs,
AllJoynStatus: typeof Windows$Devices$AllJoyn$AllJoynStatus,
AllJoynWatcherStoppedEventArgs: typeof Windows$Devices$AllJoyn$AllJoynWatcherStoppedEventArgs,
        
      }

/**
 * Used to set descriptive information about the app and the device it is running on.
 */
declare class Windows$Devices$AllJoyn$AllJoynAboutData  {

/**
 * A globally unique identifier associated with the app.
 */
appId: string;

/**
 * A collection of language-specific app names.
 */
appNames: Windows$Foundation$Collections$IMap<string, string>;

/**
 * The date of manufacture.
 */
dateOfManufacture: Date;

/**
 * The default app name assigned by the manufacturer- either the developer or the OEM. This property is a shortcut to the entry in the AppNames property for the DefaultLanguage .
 */
defaultAppName: string;

/**
 * The default description of the app. This property is a shortcut to the entry in the Descriptions property for the DefaultLanguage .
 */
defaultDescription: string;

/**
 * The name of the manufacturer of the app. This property is a shortcut to the entry in the Manufacturers property for the DefaultLanguage .
 */
defaultManufacturer: string;

/**
 * A collection of language-specific app description strings.
 */
descriptions: Windows$Foundation$Collections$IMap<string, string>;

/**
 * Indicates if the service should advertise the provided AllJoynAboutData values.
 */
isEnabled: boolean;

/**
 * A collection of language-specific manufacturer name strings.
 */
manufacturers: Windows$Foundation$Collections$IMap<string, string>;

/**
 * The model number of the device running the app.
 */
modelNumber: string;

/**
 * The version number of the app. Use of this property applies to Producer apps.
 */
softwareVersion: string;

/**
 * A URL to the manufacturer or developer support portal.
 */
supportUrl: Windows$Foundation$Uri
}


/**
 * Used to view data about another app and the device it is running on.
 */
declare class Windows$Devices$AllJoyn$AllJoynAboutDataView  {

/**
 * Gets the About data for a session in a particular language.
 * @param uniqueName The unique name.
 * @param busAttachment The bus attachment supporting the session.
 * @param sessionPort The port used to connect to the session.
 * @param language The language to return the descriptive data in.
 * @return An object containing About data for the session in the set language.
 */
static getDataBySessionPortAsync(
uniqueName: string,
busAttachment: Windows$Devices$AllJoyn$AllJoynBusAttachment,
sessionPort: number,
language: Windows$Globalization$Language): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$AllJoyn$AllJoynAboutDataView>;

/**
 * Gets the About data for a session.
 * @param uniqueName The unique name.
 * @param busAttachment The bus attachment supporting the session.
 * @param sessionPort The port used to connect to the session.
 * @return An object containing About data for the session.
 */
static getDataBySessionPortAsync(
uniqueName: string,
busAttachment: Windows$Devices$AllJoyn$AllJoynBusAttachment,
sessionPort: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$AllJoyn$AllJoynAboutDataView>;

/**
 * The version number for the implemented AllJoyn platform software.
 */
ajSoftwareVersion: string;

/**
 * A globally unique identifier associated with the app.
 */
appId: string;

/**
 * The name of the app.
 */
appName: string;

/**
 * The date of manufacture.
 */
dateOfManufacture: Date;

/**
 * The default language of the app.
 */
defaultLanguage: Windows$Globalization$Language;

/**
 * An app description provided by the manufacturer.
 */
description: string;

/**
 * The device ID used during advertising.
 */
deviceId: string;

/**
 * Name of the device.
 */
deviceName: string;

/**
 * The current version of the hardware that the app is running on. This field is optional, presenting as an empty string if not set.
 */
hardwareVersion: string;

/**
 * The name of the manufacturer.
 */
manufacturer: string;

/**
 * The model number of the device running the app.
 */
modelNumber: string;

/**
 * This is a set of fields, where each other named AllJoynAboutDataView property is also accessible. For example, ModelNumber is Properties ["ModelNumber"]. Additionally, this property can be used to get custom properties.
 */
properties: Windows$Foundation$Collections$IMapView<string, any>;

/**
 * The version number of the app.
 */
softwareVersion: string;

/**
 * The status returned by the GetDataBySessionPortAsync operation that created the AllJoynAboutDataView object.
 */
status: number;

/**
 * A URL to the manufacturer or developer support portal.
 */
supportUrl: Windows$Foundation$Uri;

/**
 * A list of languages supported by the app and will always include the DefaultLanguage .
 */
supportedLanguages: Windows$Foundation$Collections$IVectorView<Windows$Globalization$Language>
}


/**
 * Contains information about a join session request that is used to determine if the request will be accepted and initiate the session connection.
 */
declare class Windows$Devices$AllJoyn$AllJoynAcceptSessionJoinerEventArgs  {

/**
 * Generates an object containing information about the connection being accepted to the session and the method that completes the session join.
 * @param uniqueName The unique bus name.
 * @param sessionPort The session port used for the connection.
 * @param trafficType The type of traffic provided over the connection.
 * @param proximity Indicates network proximity.
 * @param acceptSessionJoiner The IAllJoynAcceptSessionJoiner object used to complete the session join.
 */
constructor(uniqueName: string, sessionPort: number, trafficType: $Values<typeof Windows$Devices$AllJoyn$AllJoynTrafficType>, proximity: number, acceptSessionJoiner: Windows$Devices$AllJoyn$IAllJoynAcceptSessionJoiner): this;

/**
 * Called to accept the session connection.
 */
accept(): void;

/**
 * Indicates if the app joining the session is on the same network.
 */
sameNetwork: boolean;

/**
 * The app joining the session is on the same physical node.
 */
samePhysicalNode: boolean;

/**
 * The session port being used to connect to the session.
 */
sessionPort: number;

/**
 * The traffic type supported during the session.
 */
trafficType: $Values<typeof Windows$Devices$AllJoyn$AllJoynTrafficType>;

/**
 * The unique bus name of the app requesting a session connection.
 */
uniqueName: string
}


/**
 * Contains information about a successful or unsuccessful completion of an authentication operation.
 */
declare class Windows$Devices$AllJoyn$AllJoynAuthenticationCompleteEventArgs  {

/**
 * The mechanism used during authentication.
 */
authenticationMechanism: $Values<typeof Windows$Devices$AllJoyn$AllJoynAuthenticationMechanism>;

/**
 * The unique bus name of the Consumer being authenticated. On the initiating side this will be the unique bus name of the remote app being authenticated. On the accepting side this will be the unique bus name for the remote app.
 */
peerUniqueName: string;

/**
 * Indicates if the remote app was authenticated.
 */
succeeded: boolean
}


/**
 * Defines values used to indicate the mechanism used in authentication operations.
 */

declare  var Windows$Devices$AllJoyn$AllJoynAuthenticationMechanism: {|
  +none: 0,// 0
+srpAnonymous: 1,// 1
+srpLogon: 2,// 2
+ecdheNull: 3,// 3
+ecdhePsk: 4,// 4
+ecdheEcdsa: 5,// 5

|};



/**
 * Represents a connection to the underlying communication pipeline (transport agnostic) that AllJoyn uses to communicate with other endpoints regardless of the transport.
 */
declare class Windows$Devices$AllJoyn$AllJoynBusAttachment  {

/**
 * Generates an AllJoynBusAttachment object using the default named pipe connection specification.
 */
constructor(): this;

/**
 * Generates an AllJoynBusAttachment object using the provided connection specification.
 * @param connectionSpecification Specification used to initiate and maintain connections to a router node (bus). Windows 10 supports the 'npipe:' transport, formatted according to the D-Bus Specification.
 */
constructor(connectionSpecification: string): this;

/**
 * This property returns an AllJoynAboutData object containing the descriptive data that the platform may advertise on behalf of the app.
 */
aboutData: Windows$Devices$AllJoyn$AllJoynAboutData;

/**
 * A list of AllJoynAuthenticationMechanism objects representing the acceptable authentication mechanisms. Default values include Rsa and None.
 */
authenticationMechanisms: Windows$Foundation$Collections$IVector<$Values<typeof Windows$Devices$AllJoyn$AllJoynAuthenticationMechanism>>;

/**
 * Initiates the connection.
 */
connect(): void;

/**
 * The connection specification used to establish and maintain the bus attachment. If a specification was not provided, this property will retrieve a default named pipe specification.
 */
connectionSpecification: string;

/**
 * Initiates a disconnect operation from the router node (bus).
 */
disconnect(): void;

/**
 * Occurs when verification of supplied credentials is complete.
 */
onauthenticationcomplete: Windows$Foundation$TypedEventHandler<Windows$Devices$AllJoyn$AllJoynBusAttachment, Windows$Devices$AllJoyn$AllJoynAuthenticationCompleteEventArgs>;
addEventListener(
type: "authenticationcomplete",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$AllJoyn$AllJoynBusAttachment, Windows$Devices$AllJoyn$AllJoynAuthenticationCompleteEventArgs>): void;
removeEventListener(
type: "authenticationcomplete",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$AllJoyn$AllJoynBusAttachment, Windows$Devices$AllJoyn$AllJoynAuthenticationCompleteEventArgs>): void;

/**
 * Occurs when credentials are requested for authentication.
 */
oncredentialsrequested: Windows$Foundation$TypedEventHandler<Windows$Devices$AllJoyn$AllJoynBusAttachment, Windows$Devices$AllJoyn$AllJoynCredentialsRequestedEventArgs>;
addEventListener(
type: "credentialsrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$AllJoyn$AllJoynBusAttachment, Windows$Devices$AllJoyn$AllJoynCredentialsRequestedEventArgs>): void;
removeEventListener(
type: "credentialsrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$AllJoyn$AllJoynBusAttachment, Windows$Devices$AllJoyn$AllJoynCredentialsRequestedEventArgs>): void;

/**
 * Occurs when credentials have been provided by a remote Consumer for verification.
 */
oncredentialsverificationrequested: Windows$Foundation$TypedEventHandler<Windows$Devices$AllJoyn$AllJoynBusAttachment, Windows$Devices$AllJoyn$AllJoynCredentialsVerificationRequestedEventArgs>;
addEventListener(
type: "credentialsverificationrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$AllJoyn$AllJoynBusAttachment, Windows$Devices$AllJoyn$AllJoynCredentialsVerificationRequestedEventArgs>): void;
removeEventListener(
type: "credentialsverificationrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$AllJoyn$AllJoynBusAttachment, Windows$Devices$AllJoyn$AllJoynCredentialsVerificationRequestedEventArgs>): void;

/**
 * Occurs when the state of the bus attachment changes. The AllJoynBusAttachmentState enumeration defines the possible state values.
 */
onstatechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$AllJoyn$AllJoynBusAttachment, Windows$Devices$AllJoyn$AllJoynBusAttachmentStateChangedEventArgs>;
addEventListener(
type: "statechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$AllJoyn$AllJoynBusAttachment, Windows$Devices$AllJoyn$AllJoynBusAttachmentStateChangedEventArgs>): void;
removeEventListener(
type: "statechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$AllJoyn$AllJoynBusAttachment, Windows$Devices$AllJoyn$AllJoynBusAttachmentStateChangedEventArgs>): void;

/**
 * Pings the specified connection asynchronously.
 * @param uniqueName The unique name associated with the connection.
 * @return An AllJoyn status code.
 */
pingAsync(uniqueName: string): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * The current state of the bus attachment. State changes are surfaced via StateChanged events. Possible values are defined by the AllJoynBusAttachmentState enumeration.
 */
state: $Values<typeof Windows$Devices$AllJoyn$AllJoynBusAttachmentState>;

/**
 * The unique bus name associated with the remote app. This unique bus name is used to represent it on the bus via the bus attachment.
 */
uniqueName: string;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Defines values used to indicate the state of a connection with an AllJoyn bus that is managed by an AllJoynBusAttachment object.
 */

declare  var Windows$Devices$AllJoyn$AllJoynBusAttachmentState: {|
  +disconnected: 0,// 0
+connecting: 1,// 1
+connected: 2,// 2
+disconnecting: 3,// 3

|};



/**
 * Contains information about state and status changes to an AllJoyn bus connection managed by an AllJoynBusAttachment object.
 */
declare class Windows$Devices$AllJoyn$AllJoynBusAttachmentStateChangedEventArgs  {

/**
 * Indicates the current state of a connection to an AllJoyn bus.
 */
state: $Values<typeof Windows$Devices$AllJoyn$AllJoynBusAttachmentState>;

/**
 * Contains a status code that provides status information for AllJoynBusAttachment change events. Properties used in the generation of possible values are defined by AllJoynStatus .
 */
status: number
}


/**
 * Defines properties used when passing credentials during authentication.
 */
declare class Windows$Devices$AllJoyn$AllJoynCredentials  {

/**
 * The mechanism used for credential authentication.
 */
authenticationMechanism: $Values<typeof Windows$Devices$AllJoyn$AllJoynAuthenticationMechanism>;

/**
 * The cryptography certificate used for the Rsa and EcdheEcdsa authentication mechanisms.
 */
certificate: Windows$Security$Cryptography$Certificates$Certificate;

/**
 * The user name, if any, and password used for authentication.
 */
passwordCredential: Windows$Security$Credentials$PasswordCredential;

/**
 * The period of time before provided credentials expire.
 */
timeout: number
}


/**
 * Contains information about a request for credentials in order to authenticate to a peer.
 */
declare class Windows$Devices$AllJoyn$AllJoynCredentialsRequestedEventArgs  {

/**
 * The number of times the credential request has been tried.
 */
attemptCount: number;

/**
 * The authentication credentials to be filled in by the app.
 */
credentials: Windows$Devices$AllJoyn$AllJoynCredentials;

/**
 * Allows JavaScript Windows Store apps to handle the verification of provided of credentials asynchronously.
 * @return The credential request deferral.
 */
getDeferral(): Windows$Foundation$Deferral;

/**
 * The unique bus name of the remote app that provided the requested credentials.
 */
peerUniqueName: string;

/**
 * A user name value used by mechanisms that accept a user name/password pair.
 */
requestedUserName: string
}


/**
 * Used to allow the application to indicate whether the credentials provided by a peer are valid.
 */
declare class Windows$Devices$AllJoyn$AllJoynCredentialsVerificationRequestedEventArgs  {

/**
 * Calling this method indicates that the credentials provided for authentication are valid.
 */
accept(): void;

/**
 * The mechanism used to authenticate credentials.
 */
authenticationMechanism: $Values<typeof Windows$Devices$AllJoyn$AllJoynAuthenticationMechanism>;

/**
 * Conducts verification of provided of credentials asynchronously.
 * @return The verification deferral.
 */
getDeferral(): Windows$Foundation$Deferral;

/**
 * The cryptography certificate provided for authentication.
 */
peerCertificate: Windows$Security$Cryptography$Certificates$Certificate;

/**
 * The category of an errors encountered authenticating the cryptography certificate.
 */
peerCertificateErrorSeverity: $Values<typeof Windows$Networking$Sockets$SocketSslErrorSeverity>;

/**
 * A list of errors that occurred during authentication of the provided cryptography certificate.
 */
peerCertificateErrors: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Security$Cryptography$Certificates$ChainValidationResult>>;

/**
 * Retrieves the intermediate certificates sent during authentication.
 */
peerIntermediateCertificates: Windows$Foundation$Collections$IVectorView<Windows$Security$Cryptography$Certificates$Certificate>;

/**
 * The unique bus name of the remote app being authenticated.
 */
peerUniqueName: string
}


/**
 * Exposes information about the sender of a message being processed.
 */
declare class Windows$Devices$AllJoyn$AllJoynMessageInfo  {

/**
 * Generates an AllJoynMessageInfo object that contains the unique name of the sender that sent the message being processed.
 * @param senderUniqueName The unique name of the sender.
 */
constructor(senderUniqueName: string): this;

/**
 * The unique bus name of the message sender.
 */
senderUniqueName: string
}


/**
 * Contains status information that indicates why a Producer app was stopped.
 */
declare class Windows$Devices$AllJoyn$AllJoynProducerStoppedEventArgs  {

/**
 * Generates an object containing status information for the stopped Producer app.
 * @param status An AllJoyn status code that indicates why the Producer was stopped.
 */
constructor(status: number): this;

/**
 * Returns an AllJoyn status code that indicates why the Producer was stopped. Common values are defined by AllJoynStatus .
 */
status: number
}


/**
 * Exposes unique name and transport information for an advertising app.
 */
declare class Windows$Devices$AllJoyn$AllJoynServiceInfo  {

/**
 * Generates an AllJoynServiceInfo object that represents an advertising app. This object provides the unique bus name, object path and transport information.
 * @param uniqueName The unique bus name.
 * @param objectPath The object path.
 * @param sessionPort The port for this session.
 */
constructor(uniqueName: string, objectPath: string, sessionPort: number): this;

/**
 * The path to the service object. This path is used to match communications with service objects connected to the session.
 */
objectPath: string;

/**
 * The port used to connect to the session.
 */
sessionPort: number;

/**
 * The unique bus name associated with the advertising app.
 */
uniqueName: string
}


/**
 * Contains information that identifies an advertising app that is no longer available.
 */
declare class Windows$Devices$AllJoyn$AllJoynServiceInfoRemovedEventArgs  {

/**
 * Generates an object containing information about an advertising app that is no longer available.
 * @param uniqueName The unique app name.
 */
constructor(uniqueName: string): this;

/**
 * The unique bus name of the advertising app that is no longer available.
 */
uniqueName: string
}


/**
 * Contains information that identifies the reason for a lost session.
 */
declare class Windows$Devices$AllJoyn$AllJoynSessionLostEventArgs  {

/**
 * Generates an AllJoynSessionLostEventArgs object containing information that identifies the reason for the lost session.
 * @param reason The reason the session was lost.
 */
constructor(reason: $Values<typeof Windows$Devices$AllJoyn$AllJoynSessionLostReason>): this;

/**
 * Retrieves a value that indicates the reason for a lost session.
 */
reason: $Values<typeof Windows$Devices$AllJoyn$AllJoynSessionLostReason>
}


/**
 * Defines values used by AllJoynSessionLostEventArgs to indicate the reason for a lost session.
 */

declare  var Windows$Devices$AllJoyn$AllJoynSessionLostReason: {|
  +none: 0,// 0
+producerLeftSession: 1,// 1
+producerClosedAbruptly: 2,// 2
+removedByProducer: 3,// 3
+linkTimeout: 4,// 4
+other: 5,// 5

|};



/**
 * Contains information about a peer that was added to a session.
 */
declare class Windows$Devices$AllJoyn$AllJoynSessionMemberAddedEventArgs  {

/**
 * Generates an object that contains information about the remote app added to the session.
 * @param uniqueName The unique Consumer name.
 */
constructor(uniqueName: string): this;

/**
 * The unique bus name of the remote app new to the session.
 */
uniqueName: string
}


/**
 * Contains information about a remote app removed from a session.
 */
declare class Windows$Devices$AllJoyn$AllJoynSessionMemberRemovedEventArgs  {

/**
 * Generates an object containing information about a remote app removed from a session.
 * @param uniqueName The unique bus name of the remote app removed from the session.
 */
constructor(uniqueName: string): this;

/**
 * The unique bus name of the remote app removed from the session.
 */
uniqueName: string
}


/**
 * Defines a collection of properties used to convey meaning for AllJoyn status codes. For possible status values, refer to the AllJoyn standard documentation.
 */
declare class Windows$Devices$AllJoyn$AllJoynStatus  {

/**
 * Indicates that authentication could not be completed.
 */
static authenticationFailed: number;

/**
 * Authentication was rejected by the advertising app.
 */
static authenticationRejectedByUser: number;

/**
 * The connection to the session was refused.
 */
static connectionRefused: number;

/**
 * The operation has failed.
 */
static fail: number;

/**
 * Insufficient security provided for session connections.
 */
static insufficientSecurity: number;

/**
 * Function call argument 1 is invalid.
 */
static invalidArgument1: number;

/**
 * Function call argument 2 is invalid.
 */
static invalidArgument2: number;

/**
 * Function call argument 3 is invalid.
 */
static invalidArgument3: number;

/**
 * Function call argument 4 is invalid.
 */
static invalidArgument4: number;

/**
 * Function call argument 5 is invalid.
 */
static invalidArgument5: number;

/**
 * Function call argument 6 is invalid.
 */
static invalidArgument6: number;

/**
 * Function call argument 7 is invalid.
 */
static invalidArgument7: number;

/**
 * Function call argument 8 is invalid.
 */
static invalidArgument8: number;

/**
 * Operation successful.
 */
static ok: number;

/**
 * The operation timed out.
 */
static operationTimedOut: number;

/**
 * The Producer end of the session connection was closed.
 */
static otherEndClosed: number;

/**
 * The SSL connection has failed.
 */
static sslConnectFailed: number;

/**
 * The SSL verification failed. Review provided SSL credentials.
 */
static sslIdentityVerificationFailed: number
}


/**
 * Defines values used to indicate the type of data carried in session traffic.
 */

declare  var Windows$Devices$AllJoyn$AllJoynTrafficType: {|
  +unknown: 0,// 0
+messages: 1,// 1
+rawUnreliable: 2,// 2
+rawReliable: 3,// 3

|};



/**
 * Contains information about the stopped session watcher object.
 */
declare class Windows$Devices$AllJoyn$AllJoynWatcherStoppedEventArgs  {

/**
 * Generates an AllJoynWatcherStoppedEventArgs object that contains status information that identifies the reason the watcher object was stopped.
 * @param status The AllJoyn status code.
 */
constructor(status: number): this;

/**
 * Returns a status code that was returned when the watcher object is stopped. This value is represented by AllJoynStatus .
 */
status: number
}


/**
 * Use this interface to accept requests from peers to join a session.
 */
declare interface Windows$Devices$AllJoyn$IAllJoynAcceptSessionJoiner {

/**
 * Accept an incoming request to join the session.
 */
accept(): void
} 


      declare var npm$namespace$Windows$Devices$Background: {
        
        
        
        DeviceServicingDetails: typeof Windows$Devices$Background$DeviceServicingDetails,
DeviceUseDetails: typeof Windows$Devices$Background$DeviceUseDetails,
        
      }

/**
 * Used to provide the DeviceInformation.ID , expected duration, and arguments given by the app that triggered the background servicing task.
 */
declare class Windows$Devices$Background$DeviceServicingDetails  {

/**
 * Gets the arguments string provided by the app when it called RequestAsync on the DeviceServicingTrigger . This allows the app to easily pass parameters to the task when it invokes it.
 */
arguments: string;

/**
 * Gets the DeviceInformation.ID of the device the task is targeting. The background task can provide this to the FromIdAsync method of the appropriate device access class to open the device. For example, call UsbDevice.FromIdAsync in the Windows.Devices.Usb namespace to open a USB device.
 */
deviceId: string;

/**
 * Gets the estimated duration provided by the app when it called RequestAsync on the DeviceServicingTrigger .
 */
expectedDuration: number
}


/**
 * Used to provide the DeviceInformation.ID and arguments given by the app that triggered the background sync task.
 */
declare class Windows$Devices$Background$DeviceUseDetails  {

/**
 * Gets the arguments string provided by the app when it called RequestAsync on the DeviceUseTrigger . This allows the app to easily pass parameters to the task when it invokes it.
 */
arguments: string;

/**
 * Gets the DeviceInformation.ID of the device the task is targeting. The background task can provide this to the FromIdAsync method of the appropriate device access class to open the device. For example, call UsbDevice.FromIdAsync in the Windows.Devices.Usb namespace to open a USB device.
 */
deviceId: string
}


      declare var npm$namespace$Windows$Devices$Bluetooth: {
        
        
        BluetoothAddressType: typeof Windows$Devices$Bluetooth$BluetoothAddressType,
BluetoothCacheMode: typeof Windows$Devices$Bluetooth$BluetoothCacheMode,
BluetoothConnectionStatus: typeof Windows$Devices$Bluetooth$BluetoothConnectionStatus,
BluetoothError: typeof Windows$Devices$Bluetooth$BluetoothError,
BluetoothMajorClass: typeof Windows$Devices$Bluetooth$BluetoothMajorClass,
BluetoothMinorClass: typeof Windows$Devices$Bluetooth$BluetoothMinorClass,
BluetoothServiceCapabilities: typeof Windows$Devices$Bluetooth$BluetoothServiceCapabilities,
        BluetoothClassOfDevice: typeof Windows$Devices$Bluetooth$BluetoothClassOfDevice,
BluetoothDevice: typeof Windows$Devices$Bluetooth$BluetoothDevice,
BluetoothLEAppearance: typeof Windows$Devices$Bluetooth$BluetoothLEAppearance,
BluetoothLEAppearanceCategories: typeof Windows$Devices$Bluetooth$BluetoothLEAppearanceCategories,
BluetoothLEAppearanceSubcategories: typeof Windows$Devices$Bluetooth$BluetoothLEAppearanceSubcategories,
BluetoothLEDevice: typeof Windows$Devices$Bluetooth$BluetoothLEDevice,
BluetoothSignalStrengthFilter: typeof Windows$Devices$Bluetooth$BluetoothSignalStrengthFilter,
        Advertisement: typeof npm$namespace$Windows$Devices$Bluetooth$Advertisement,
Background: typeof npm$namespace$Windows$Devices$Bluetooth$Background,
GenericAttributeProfile: typeof npm$namespace$Windows$Devices$Bluetooth$GenericAttributeProfile,
Rfcomm: typeof npm$namespace$Windows$Devices$Bluetooth$Rfcomm,
      }

      declare var npm$namespace$Windows$Devices$Bluetooth$Advertisement: {
        
        
        BluetoothLEAdvertisementFlags: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementFlags,
BluetoothLEAdvertisementPublisherStatus: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementPublisherStatus,
BluetoothLEAdvertisementType: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementType,
BluetoothLEAdvertisementWatcherStatus: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcherStatus,
BluetoothLEScanningMode: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEScanningMode,
        BluetoothLEAdvertisement: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisement,
BluetoothLEAdvertisementBytePattern: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementBytePattern,
BluetoothLEAdvertisementDataSection: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementDataSection,
BluetoothLEAdvertisementDataTypes: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementDataTypes,
BluetoothLEAdvertisementFilter: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementFilter,
BluetoothLEAdvertisementPublisher: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementPublisher,
BluetoothLEAdvertisementPublisherStatusChangedEventArgs: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementPublisherStatusChangedEventArgs,
BluetoothLEAdvertisementReceivedEventArgs: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementReceivedEventArgs,
BluetoothLEAdvertisementWatcher: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcher,
BluetoothLEAdvertisementWatcherStoppedEventArgs: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcherStoppedEventArgs,
BluetoothLEManufacturerData: typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEManufacturerData,
        
      }

/**
 * A representation of a Bluetooth LE advertisement payload.
 */
declare class Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisement  {

/**
 * Creates a new BluetoothLEAdvertisement object.
 */
constructor(): this;

/**
 * Gets the list of raw data sections.
 */
dataSections: Windows$Foundation$Collections$IVector<Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementDataSection>;

/**
 * Bluetooth LE advertisement flags.
 */
flags: $Values<typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementFlags>;

/**
 * Return a list of all manufacturer data sections in the BluetoothLEAdvertisement payload matching the specified company ID.
 * @param companyId The company identifier code defined by the Bluetooth Special Interest Group (SIG).
 * @return A vector of BluetoothLEManufacturerData contained within the payload.
 */
getManufacturerDataByCompanyId(
companyId: number): Windows$Foundation$Collections$IVectorView<Windows$Devices$Bluetooth$Advertisement$BluetoothLEManufacturerData>;

/**
 * Return a list of advertisement data sections that matches a given advertisement section type in a BluetoothLEAdvertisement .
 * @param type The advertisement section type
 * @return A vector of all the BluetoothLEAdvertisementDataSection matching the given advertisement type.
 */
getSectionsByType(
type: number): Windows$Foundation$Collections$IVectorView<Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementDataSection>;

/**
 * The local name contained within the advertisement.
 */
localName: string;

/**
 * Gets the list of manufacturer-specific data sections in a BluetoothLEAdvertisement .
 */
manufacturerData: Windows$Foundation$Collections$IVector<Windows$Devices$Bluetooth$Advertisement$BluetoothLEManufacturerData>;

/**
 * The list of service UUIDs in 128-bit GUID format in a BluetoothLEAdvertisement .
 */
serviceUuids: Windows$Foundation$Collections$IVector<string>
}


/**
 * A Bluetooth LE advertisement byte pattern for filters to match.
 */
declare class Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementBytePattern  {

/**
 * Create a new BluetoothLEAdvertisementBytePattern object.
 */
constructor(): this;

/**
 * Create a new BluetoothLEAdvertisementBytePattern object with an advertisement data type to match, the advertisement data byte pattern to match, and the offset of the byte pattern from the beginning of the advertisement data section.
 * @param dataType The Bluetooth LE advertisement data type to match.
 * @param offset The offset of byte pattern from beginning of advertisement data section.
 * @param data The Bluetooth LE advertisement data byte pattern to match.
 */
constructor(dataType: number, offset: number, data: Windows$Storage$Streams$IBuffer): this;

/**
 * The Bluetooth LE advertisement data byte pattern to match.
 */
data: Windows$Storage$Streams$IBuffer;

/**
 * The Bluetooth LE advertisement data type defined by the Bluetooth Special Interest Group (SIG) to match.
 */
dataType: number;

/**
 * The offset of byte pattern from beginning of advertisement data section.
 */
offset: number
}


/**
 * A Bluetooth LE advertisement section.
 */
declare class Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementDataSection  {

/**
 * Creates a new BluetoothLEAdvertisementDataSection object.
 */
constructor(): this;

/**
 * Creates a new BluetoothLEAdvertisementDataSection object with the Bluetooth LE advertisement data type and the payload.
 * @param dataType The Bluetooth LE advertisement data type as defined by the Bluetooth Special Interest Group (SIG).
 * @param data The Bluetooth LE advertisement data payload.
 */
constructor(dataType: number, data: Windows$Storage$Streams$IBuffer): this;

/**
 * The Bluetooth LE advertisement data payload.
 */
data: Windows$Storage$Streams$IBuffer;

/**
 * The Bluetooth LE advertisement data type as defined by the Bluetooth Special Interest Group (SIG).
 */
dataType: number
}


/**
 * Some of the Bluetooth LE advertisement types defined in the Generic Access Profile (GAP) by the Bluetooth Special Interest Group (SIG).
 */
declare class Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementDataTypes  {

/**
 * Section data type for the Bluetooth LE advertising interval.
 */
static advertisingInterval: number;

/**
 * Section data type for the Bluetooth LE advertising appearance.
 */
static appearance: number;

/**
 * Section data type for the Bluetooth LE complete local name.
 */
static completeLocalName: number;

/**
 * Section data type for the complete list of 128-bit Bluetooth LE service UUIDs
 */
static completeService128BitUuids: number;

/**
 * Section data type for the complete list of 16-bit Bluetooth LE service UUIDs
 */
static completeService16BitUuids: number;

/**
 * Section data type for the complete list of 32-bit Bluetooth LE service UUIDs
 */
static completeService32BitUuids: number;

/**
 * Section data type for a set of flags for internal use.
 */
static flags: number;

/**
 * Section data type for an incomplete list of 128-bit Bluetooth LE service UUIDs.
 */
static incompleteService128BitUuids: number;

/**
 * Section data type for an incomplete list of 16-bit Bluetooth LE service UUIDs.
 */
static incompleteService16BitUuids: number;

/**
 * Section data type for an incomplete list of 32-bit Bluetooth LE service UUIDs.
 */
static incompleteService32BitUuids: number;

/**
 * Section data type for manufacturer-specific data for a Bluetooth LE advertisements.
 */
static manufacturerSpecificData: number;

/**
 * Section data type for a list of public Bluetooth LE target addresses.
 */
static publicTargetAddress: number;

/**
 * Section data type for a list of random Bluetooth LE target addresses.
 */
static randomTargetAddress: number;

/**
 * Section data type for service data for 128-bit Bluetooth LE UUIDs.
 */
static serviceData128BitUuids: number;

/**
 * Section data type for service data for 16-bit Bluetooth LE UUIDs.
 */
static serviceData16BitUuids: number;

/**
 * Section data type for service data for 32-bit Bluetooth LE UUIDs..
 */
static serviceData32BitUuids: number;

/**
 * Section data type for a list of 128-bit Bluetooth LE service solicitation UUIDs.
 */
static serviceSolicitation128BitUuids: number;

/**
 * Section data type for a list of 16-bit Bluetooth LE service solicitation UUIDs.
 */
static serviceSolicitation16BitUuids: number;

/**
 * Section data type for a list of 32-bit Bluetooth LE service solicitation UUIDs.
 */
static serviceSolicitation32BitUuids: number;

/**
 * Section data type for a shortened local name.
 */
static shortenedLocalName: number;

/**
 * Section data type for the slave connection interval range.
 */
static slaveConnectionIntervalRange: number;

/**
 * Section data type for the Bluetooth LE transmit power level.
 */
static txPowerLevel: number
}


/**
 * Groups parameters used to configure payload-based filtering of received Bluetooth LE advertisements.
 */
declare class Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementFilter  {

/**
 * Creates a new BluetoothLEAdvertisementFilter object.
 */
constructor(): this;

/**
 * A BluetoothLEAdvertisement object that can be applied as filters to received Bluetooth LE advertisements.
 */
advertisement: Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisement;

/**
 * Gets a vector of byte patterns with offsets to match advertisement sections in a received Bluetooth LE advertisement.
 */
bytePatterns: Windows$Foundation$Collections$IVector<Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementBytePattern>
}


/**
 * Specifies flags used to match flags contained inside a Bluetooth LE advertisement payload.
 */

declare  var Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementFlags: {|
  +none: 0,// 0
+limitedDiscoverableMode: 1,// 1
+generalDiscoverableMode: 2,// 2
+classicNotSupported: 3,// 3
+dualModeControllerCapable: 4,// 4
+dualModeHostCapable: 5,// 5

|};



/**
 * An object to send Bluetooth Low Energy (LE) advertisements.
 */
declare class Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementPublisher  {

/**
 * Creates a new BluetoothLEAdvertisementPublisher object.
 */
constructor(): this;

/**
 * Creates a new BluetoothLEAdvertisementPublisher object with the Bluetooth LE advertisement to publish.
 * @param advertisement The Bluetooth LE advertisement to publish.
 */
constructor(advertisement: Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisement): this;

/**
 * Gets a copy of the Bluetooth LE advertisement to publish.
 */
advertisement: Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisement;

/**
 * Notification that the status of the BluetoothLEAdvertisementPublisher has changed.
 */
onstatuschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementPublisher, Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementPublisherStatusChangedEventArgs>;
addEventListener(
type: "statuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementPublisher, Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementPublisherStatusChangedEventArgs>): void;
removeEventListener(
type: "statuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementPublisher, Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementPublisherStatusChangedEventArgs>): void;

/**
 * Start advertising a Bluetooth LE advertisement payload.
 */
start(): void;

/**
 * Gets the current status of the BluetoothLEAdvertisementPublisher .
 */
status: $Values<typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementPublisherStatus>;

/**
 * Stop the publisher and stop advertising a Bluetooth LE advertisement payload.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the possible states of the BluetoothLEAdvertisementPublisher .
 */

declare  var Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementPublisherStatus: {|
  +created: 0,// 0
+waiting: 1,// 1
+started: 2,// 2
+stopping: 3,// 3
+stopped: 4,// 4
+aborted: 5,// 5

|};



/**
 * Provides data for a StatusChanged event on a BluetoothLEAdvertisementPublisher .
 */
declare class Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementPublisherStatusChangedEventArgs  {

/**
 * Gets the error status for a StatusChanged event on a BluetoothLEAdvertisementPublisher .
 */
error: $Values<typeof Windows$Devices$Bluetooth$BluetoothError>;

/**
 * Gets the new status of the BluetoothLEAdvertisementPublisher .
 */
status: $Values<typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementPublisherStatus>
}


/**
 * Provides data for a Received event on a BluetoothLEAdvertisementWatcher .
 */
declare class Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementReceivedEventArgs  {

/**
 * Gets the Bluetooth LE advertisement payload data received.
 */
advertisement: Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisement;

/**
 * Gets the type of the received Bluetooth LE advertisement packet.
 */
advertisementType: $Values<typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementType>;

/**
 * Gets the Bluetooth address of the device sending the Bluetooth LE advertisement.
 */
bluetoothAddress: number;

/**
 * Gets the received signal strength indicator (RSSI) value, in dBm, for this received Bluetooth LE advertisement event.
 */
rawSignalStrengthInDBm: number;

/**
 * Gets the timestamp when the Received event occurred.
 */
timestamp: Date
}


/**
 * Specifies the different types of Bluetooth LE advertisement payloads.
 */

declare  var Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementType: {|
  +connectableUndirected: 0,// 0
+connectableDirected: 1,// 1
+scannableUndirected: 2,// 2
+nonConnectableUndirected: 3,// 3
+scanResponse: 4,// 4

|};



/**
 * An object to receive Bluetooth Low Energy (LE) advertisements.
 */
declare class Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcher  {

/**
 * Creates a new BluetoothLEAdvertisementWatcher object with an advertisement filter to initialize the watcher.
 * @param advertisementFilter The advertisement filter to initialize the watcher.
 */
constructor(advertisementFilter: Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementFilter): this;

/**
 * Creates a new BluetoothLEAdvertisementWatcher object.
 */
constructor(): this;

/**
 * Gets or sets a BluetoothLEAdvertisementFilter object used for configuration of Bluetooth LE advertisement filtering that uses payload section-based filtering.
 */
advertisementFilter: Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementFilter;

/**
 * Gets the maximum out of range timeout.
 */
maxOutOfRangeTimeout: number;

/**
 * Gets the maximum sampling interval.
 */
maxSamplingInterval: number;

/**
 * Gets the minimum out of range timeout.
 */
minOutOfRangeTimeout: number;

/**
 * Gets the minimum sampling interval.
 */
minSamplingInterval: number;

/**
 * Notification for new Bluetooth LE advertisement events received.
 */
onreceived: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcher, Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementReceivedEventArgs>;
addEventListener(
type: "received",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcher, Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementReceivedEventArgs>): void;
removeEventListener(
type: "received",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcher, Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementReceivedEventArgs>): void;

/**
 * Notification to the app that the Bluetooth LE scanning for advertisements has been cancelled or aborted either by the app or due to an error.
 */
onstopped: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcher, Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcherStoppedEventArgs>;
addEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcher, Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcherStoppedEventArgs>): void;
removeEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcher, Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcherStoppedEventArgs>): void;

/**
 * Gets or sets the Bluetooth LE scanning mode.
 */
scanningMode: $Values<typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEScanningMode>;

/**
 * Gets or sets a BluetoothSignalStrengthFilter object used for configuration of Bluetooth LE advertisement filtering that uses signal strength-based filtering.
 */
signalStrengthFilter: Windows$Devices$Bluetooth$BluetoothSignalStrengthFilter;

/**
 * Start the BluetoothLEAdvertisementWatcher to scan for Bluetooth LE advertisements.
 */
start(): void;

/**
 * Gets the current status of the BluetoothLEAdvertisementWatcher .
 */
status: $Values<typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcherStatus>;

/**
 * Stop the BluetoothLEAdvertisementWatcher and disable the scanning for Bluetooth LE advertisements.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the possible states of the BluetoothLEAdvertisementWatcher .
 */

declare  var Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcherStatus: {|
  +created: 0,// 0
+started: 1,// 1
+stopping: 2,// 2
+stopped: 3,// 3
+aborted: 4,// 4

|};



/**
 * Provides data for a Stopped event on a BluetoothLEAdvertisementWatcher .
 */
declare class Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementWatcherStoppedEventArgs  {

/**
 * Gets the error status for Stopped event.
 */
error: $Values<typeof Windows$Devices$Bluetooth$BluetoothError>
}


/**
 * A Bluetooth LE manufacturer-specific data section (one particular type of LE advertisement section)
 */
declare class Windows$Devices$Bluetooth$Advertisement$BluetoothLEManufacturerData  {

/**
 * Creates a new BluetoothLEManufacturerData object.
 */
constructor(): this;

/**
 * Creates a new BluetoothLEManufacturerData object with a company identifier code and manufacterer-specific section data.
 * @param companyId The Bluetooth LE company identifier code as defined by the Bluetooth Special Interest Group (SIG).
 * @param data Bluetooth LE manufacturer-specific section data.
 */
constructor(companyId: number, data: Windows$Storage$Streams$IBuffer): this;

/**
 * The Bluetooth LE company identifier code as defined by the Bluetooth Special Interest Group (SIG).
 */
companyId: number;

/**
 * Bluetooth LE manufacturer-specific section data.
 */
data: Windows$Storage$Streams$IBuffer
}


/**
 * Specifies the Bluetooth LE scanning mode.
 */

declare  var Windows$Devices$Bluetooth$Advertisement$BluetoothLEScanningMode: {|
  +passive: 0,// 0
+active: 1,// 1

|};



      declare var npm$namespace$Windows$Devices$Bluetooth$Background: {
        
        
        
        BluetoothLEAdvertisementPublisherTriggerDetails: typeof Windows$Devices$Bluetooth$Background$BluetoothLEAdvertisementPublisherTriggerDetails,
BluetoothLEAdvertisementWatcherTriggerDetails: typeof Windows$Devices$Bluetooth$Background$BluetoothLEAdvertisementWatcherTriggerDetails,
GattCharacteristicNotificationTriggerDetails: typeof Windows$Devices$Bluetooth$Background$GattCharacteristicNotificationTriggerDetails,
RfcommConnectionTriggerDetails: typeof Windows$Devices$Bluetooth$Background$RfcommConnectionTriggerDetails,
RfcommInboundConnectionInformation: typeof Windows$Devices$Bluetooth$Background$RfcommInboundConnectionInformation,
RfcommOutboundConnectionInformation: typeof Windows$Devices$Bluetooth$Background$RfcommOutboundConnectionInformation,
        
      }

/**
 * Provides information about a BluetoothLEAdvertisementPublisher trigger.
 */
declare class Windows$Devices$Bluetooth$Background$BluetoothLEAdvertisementPublisherTriggerDetails  {

/**
 * Gets the error status for the trigger.
 */
error: $Values<typeof Windows$Devices$Bluetooth$BluetoothError>;

/**
 * Gets the current status of the BluetoothLEAdvertisementPublisher .
 */
status: $Values<typeof Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementPublisherStatus>
}


/**
 * Provides information about a BluetoothLEAdvertisementWatcher trigger.
 */
declare class Windows$Devices$Bluetooth$Background$BluetoothLEAdvertisementWatcherTriggerDetails  {

/**
 * Gets a collection of Bluetooth LE advertisements.
 */
advertisements: Windows$Foundation$Collections$IVectorView<Windows$Devices$Bluetooth$Advertisement$BluetoothLEAdvertisementReceivedEventArgs>;

/**
 * Gets the error status for the trigger.
 */
error: $Values<typeof Windows$Devices$Bluetooth$BluetoothError>;

/**
 * Gets the parameters used to configure received signal strength indicator (RSSI)-based filtering.
 */
signalStrengthFilter: Windows$Devices$Bluetooth$BluetoothSignalStrengthFilter
}


/**
 * Provides information about the Bluetooth LE device that caused this trigger to fire.
 */
declare class Windows$Devices$Bluetooth$Background$GattCharacteristicNotificationTriggerDetails  {

/**
 * Gets the GATT characteristic that changed.
 */
characteristic: Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristic;

/**
 * Gets a byte stream containing the new value of the characteristic.
 */
value: Windows$Storage$Streams$IBuffer
}


/**
 * Provides information about the Bluetooth device that caused this trigger to fire.
 */
declare class Windows$Devices$Bluetooth$Background$RfcommConnectionTriggerDetails  {

/**
 * Gets whether this is an incoming connection.
 */
incoming: boolean;

/**
 * Gets the BluetoothDevice object that represents the remote device.
 */
remoteDevice: Windows$Devices$Bluetooth$BluetoothDevice;

/**
 * Gets a reference to the underlying StreamSocket of this connection.
 */
socket: Windows$Networking$Sockets$StreamSocket
}


/**
 * Provides information about incoming RFCOMM connections. If an app wants the system to listen for incoming connections on behalf of an RfcommConnectionTrigger , the app must create this object and attach it to the RfcommConnectionTrigger.
 */
declare class Windows$Devices$Bluetooth$Background$RfcommInboundConnectionInformation  {

/**
 * Gets or sets the service UUID that will be advertised in the SDP record.
 */
localServiceId: Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId;

/**
 * Gets or sets the Bluetooth SDP record that the system will advertise on behalf of the app.
 */
sdpRecord: Windows$Storage$Streams$IBuffer;

/**
 * Gets or sets the service capabilities that will be advertised.
 */
serviceCapabilities: $Values<typeof Windows$Devices$Bluetooth$BluetoothServiceCapabilities>
}


/**
 * Provides information for RFCOMM outbound connections. If an app wants the system to create outbound connections on its behalf, the app must create this object and attach it to the RfcommConnectionTrigger .
 */
declare class Windows$Devices$Bluetooth$Background$RfcommOutboundConnectionInformation  {

/**
 * Gets or sets the service UUID of the remote service to which the system will connect on behalf of the app.
 */
remoteServiceId: Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId
}


/**
 * Describes the Bluetooth address type.
 */

declare  var Windows$Devices$Bluetooth$BluetoothAddressType: {|
  +public: 0,// 0
+random: 1,// 1

|};



/**
 * Indicates whether certain Bluetooth API methods should operate on values cached in the system or retrieve those values from the Bluetooth device.
 */

declare  var Windows$Devices$Bluetooth$BluetoothCacheMode: {|
  +cached: 0,// 0
+uncached: 1,// 1

|};



/**
 * Provides functionality to determine the Bluetooth Class Of Device (Bluetooth COD) information for a device.
 */
declare class Windows$Devices$Bluetooth$BluetoothClassOfDevice  {

/**
 * Creates a BluetoothClassOfDevice object by supplying values for BluetoothMajorClass , BluetoothMinorClass and BluetoothClassOfDevice.
 * @param majorClass One of the enumeration values that specifies the device's main function.
 * @param minorClass One of the enumeration values that specifies the minor class value to be used.
 * @param serviceCapabilities One of the enumeration values that specifies the service the device supports.
 * @return A BluetoothClassOfDevice object.
 */
static fromParts(
majorClass: $Values<typeof Windows$Devices$Bluetooth$BluetoothMajorClass>,
minorClass: $Values<typeof Windows$Devices$Bluetooth$BluetoothMinorClass>,
serviceCapabilities: $Values<typeof Windows$Devices$Bluetooth$BluetoothServiceCapabilities>): Windows$Devices$Bluetooth$BluetoothClassOfDevice;

/**
 * Creates a BluetoothClassOfDevice object from a raw integer value representing the Major Class, Minor Class and Service Capabilities of the device.
 * @param rawValue The raw integer value from which to create the BluetoothClassOfDevice object.
 * @return A BluetoothClassOfDevice object.
 */
static fromRawValue(rawValue: number): Windows$Devices$Bluetooth$BluetoothClassOfDevice;

/**
 * Gets the Major Class code of the Bluetooth device.
 */
majorClass: $Values<typeof Windows$Devices$Bluetooth$BluetoothMajorClass>;

/**
 * Gets the Minor Class code of the device.
 */
minorClass: $Values<typeof Windows$Devices$Bluetooth$BluetoothMinorClass>;

/**
 * Gets the Bluetooth Class Of Device information, represented as an integer value.
 */
rawValue: number;

/**
 * Gets the service capabilities of the device.
 */
serviceCapabilities: $Values<typeof Windows$Devices$Bluetooth$BluetoothServiceCapabilities>
}


/**
 * Indicates the connection status of the device.
 */

declare  var Windows$Devices$Bluetooth$BluetoothConnectionStatus: {|
  +disconnected: 0,// 0
+connected: 1,// 1

|};



/**
 * Represents a Bluetooth device.
 */
declare class Windows$Devices$Bluetooth$BluetoothDevice  {

/**
 * Returns a BluetoothDevice object for the given BluetoothAddress .
 * @param address The address of the Bluetooth device.
 * @return After the asynchronous operation completes, returns the BluetoothDevice object with the given BluetoothAddress or null if the address does not resolve to a valid device.
 */
static fromBluetoothAddressAsync(
address: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Bluetooth$BluetoothDevice>;

/**
 * Returns a BluetoothDevice object identified by the given HostName .
 * @param hostName The HostName that identifies the BluetoothDevice instance.
 * @return After the asynchronous operation completes, returns the BluetoothDevice object identified by the given HostName .
 */
static fromHostNameAsync(
hostName: Windows$Networking$HostName): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Bluetooth$BluetoothDevice>;

/**
 * Returns a BluetoothDevice object identified by the given DeviceId .
 * @param deviceId The DeviceId value that identifies the BluetoothDevice instance.
 * @return After the asynchronous operation completes, returns the BluetoothDevice object identified by the given DeviceId .
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Bluetooth$BluetoothDevice>;

/**
 * Gets an Advanced Query Syntax (AQS) string for identifying instances of this device. This string is passed to the FindAllAsync or CreateWatcher method.
 * @return The device selector for this device.
 */
static getDeviceSelector(): string;

/**
 * Creates an Advanced Query Syntax (AQS) filter string from a 64-bit address that represents a Bluetooth device. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects.
 * @param bluetoothAddress A 64-bit Bluetooth device address used for constructing the AQS string.
 * @return An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
static getDeviceSelectorFromBluetoothAddress(bluetoothAddress: number): string;

/**
 * Creates an Advanced Query Syntax (AQS) filter string from a BluetoothClassOfDevice object. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects.
 * @param classOfDevice The class of device used for constructing the AQS string.
 * @return An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
static getDeviceSelectorFromClassOfDevice(classOfDevice: Windows$Devices$Bluetooth$BluetoothClassOfDevice): string;

/**
 * Creates an Advanced Query Syntax (AQS) filter string that contains a query for Bluetooth devices with the indicated BluetoothConnectionStatus . The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects with the indicated Bluetooth connection status.
 * @param connectionStatus The connection status used for constructing the AQS string.
 * @return An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
static getDeviceSelectorFromConnectionStatus(
connectionStatus: $Values<typeof Windows$Devices$Bluetooth$BluetoothConnectionStatus>): string;

/**
 * Creates an Advanced Query Syntax (AQS) filter string that contains a query for the Bluetooth device name. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects containing the specified Bluetooth device name.
 * @param deviceName The Bluetooth device name used for constructing the AQS string.
 * @return An AQS string that is passed as a parameter to the CreateWatcher method.
 */
static getDeviceSelectorFromDeviceName(deviceName: string): string;

/**
 * Creates an Advanced Query Syntax (AQS) filter string that contains a query for Bluetooth devices that are either paired or unpaired. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects.
 * @param pairingState The current pairing state for Bluetooth devices used for constructing the AQS string. Bluetooth devices can be either paired (true) or unpaired (false). The AQS Filter string will request scanning to be performed when the pairingState is false.
 * @return An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
static getDeviceSelectorFromPairingState(pairingState: boolean): string;

/**
 * Gets the device address.
 */
bluetoothAddress: number;

/**
 * Gets the Bluetooth Class Of Device information of the device.
 */
classOfDevice: Windows$Devices$Bluetooth$BluetoothClassOfDevice;

/**
 * Closes the Bluetooth device.
 */
close(): void;

/**
 * Gets the connection status of the device.
 */
connectionStatus: $Values<typeof Windows$Devices$Bluetooth$BluetoothConnectionStatus>;

/**
 * Gets the device ID.
 */
deviceId: string;

/**
 * Gets the DeviceInformation object for the Bluetooth device.
 */
deviceInformation: Windows$Devices$Enumeration$DeviceInformation;

/**
 * Gets the HostName of the device.
 */
hostName: Windows$Networking$HostName;

/**
 * Gets the Name of the device.
 */
name: string;

/**
 * Occurs when the connection status of the device has changed.
 */
onconnectionstatuschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothDevice, any>;
addEventListener(
type: "connectionstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothDevice, any>): void;
removeEventListener(
type: "connectionstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothDevice, any>): void;

/**
 * Occurs when the name of the device has changed.
 */
onnamechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothDevice, any>;
addEventListener(
type: "namechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothDevice, any>): void;
removeEventListener(
type: "namechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothDevice, any>): void;

/**
 * Occurs when the list SDP records for the device has changed.
 */
onsdprecordschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothDevice, any>;
addEventListener(
type: "sdprecordschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothDevice, any>): void;
removeEventListener(
type: "sdprecordschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothDevice, any>): void;

/**
 * Gets the read-only list of RFCOMM services supported by the device.
 */
rfcommServices: Windows$Foundation$Collections$IVectorView<Windows$Devices$Bluetooth$Rfcomm$RfcommDeviceService>;

/**
 * Gets the read-only list of Service Discovery Protocol (SDP) records for the device.
 */
sdpRecords: Windows$Foundation$Collections$IVectorView<Windows$Storage$Streams$IBuffer>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies common Bluetooth error cases.
 */

declare  var Windows$Devices$Bluetooth$BluetoothError: {|
  +success: 0,// 0
+radioNotAvailable: 1,// 1
+resourceInUse: 2,// 2
+deviceNotConnected: 3,// 3
+otherError: 4,// 4
+disabledByPolicy: 5,// 5
+notSupported: 6,// 6
+disabledByUser: 7,// 7

|};



/**
 * Provides functionality to determine the Bluetooth Low Energy (LE) Appearance information for a device.
 */
declare class Windows$Devices$Bluetooth$BluetoothLEAppearance  {

/**
 * Creates a BluetoothLEAppearance object by supplying values for Category (see BluetoothLEAppearanceCategories ) and Subcategory (see BluetoothLEAppearanceSubcategories ) of the Bluetooth LE device.
 * @param appearanceCategory The Bluetooth LE appearance category. See BluetoothLEAppearanceSubcategories .
 * @param appearanceSubCategory The Bluetooth LE appearance subcategory. See BluetoothLEAppearanceSubcategories .
 * @return The Bluetooth LE appearance object that was created from the appearance category and subcategory.
 */
static fromParts(
appearanceCategory: number,
appearanceSubCategory: number): Windows$Devices$Bluetooth$BluetoothLEAppearance;

/**
 * Creates a BluetoothLEAppearance object by supplying for raw integer values representing the Category and Subcategory of the Bluetooth LE device.
 * @param rawValue The raw integer value representing the appearance category and subcategory.
 * @return The Bluetooth LE appearance object that was created from the appearance category and subcategory.
 */
static fromRawValue(rawValue: number): Windows$Devices$Bluetooth$BluetoothLEAppearance;

/**
 * Gets the appearance category value of the Bluetooth LE device.
 */
category: number;

/**
 * Gets the appearance raw value of the Bluetooth LE device.
 */
rawValue: number;

/**
 * Gets the appearance subcategory value of the Bluetooth LE device.
 */
subCategory: number
}


/**
 * Indicates the appearance category code of the Bluetooth LE device.
 */
declare class Windows$Devices$Bluetooth$BluetoothLEAppearanceCategories  {

/**
 * Gets the barcode scanner appearance category code.
 */
static barcodeScanner: number;

/**
 * Gets the blood pressure appearance category code.
 */
static bloodPressure: number;

/**
 * Gets the clock appearance category code.
 */
static clock: number;

/**
 * Gets the computer appearance category code.
 */
static computer: number;

/**
 * Gets the cycling appearance category code.
 */
static cycling: number;

/**
 * Gets the display appearance category code.
 */
static display: number;

/**
 * Gets the eye glasses appearance category code.
 */
static eyeGlasses: number;

/**
 * Gets the glucose meter appearance category code.
 */
static glucoseMeter: number;

/**
 * Gets the heart rate appearance category code.
 */
static heartRate: number;

/**
 * Gets the human interface device appearance category code.
 */
static humanInterfaceDevice: number;

/**
 * Gets the key ring appearance category code.
 */
static keyring: number;

/**
 * Gets the media player appearance category code.
 */
static mediaPlayer: number;

/**
 * Gets the outdoor sport activity appearance category code.
 */
static outdoorSportActivity: number;

/**
 * Gets the phone appearance category code.
 */
static phone: number;

/**
 * Gets the pulse oximeter appearance category code.
 */
static pulseOximeter: number;

/**
 * Gets the remote control appearance category code.
 */
static remoteControl: number;

/**
 * Gets the running or walking appearance category code.
 */
static runningWalking: number;

/**
 * Gets the tag appearance category code.
 */
static tag: number;

/**
 * Gets the thermometer appearance category code.
 */
static thermometer: number;

/**
 * Gets the uncategorized appearance category code.
 */
static uncategorized: number;

/**
 * Gets the watch appearance category code.
 */
static watch: number;

/**
 * Gets the weight scale appearance category code.
 */
static weightScale: number
}


/**
 * Indicates the appearance subcategory code of the Bluetooth LE device.
 */
declare class Windows$Devices$Bluetooth$BluetoothLEAppearanceSubcategories  {

/**
 * Gets the pulse barcode scanner appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category.
 */
static barcodeScanner: number;

/**
 * Gets the blood pressure arm appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.BloodPressure appearance category.
 */
static bloodPressureArm: number;

/**
 * Gets the blood pressure wrist appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.BloodPressure appearance category.
 */
static bloodPressureWrist: number;

/**
 * Gets the card reader appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category.
 */
static cardReader: number;

/**
 * Gets the cycling cadence sensor appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.Cycling appearance category.
 */
static cyclingCadenceSensor: number;

/**
 * Gets the cycling computer appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.Cycling appearance category.
 */
static cyclingComputer: number;

/**
 * Gets the cycling power sensor appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.Cycling appearance category.
 */
static cyclingPowerSensor: number;

/**
 * Gets the cycling speed cadence sensor appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.Cycling appearance category.
 */
static cyclingSpeedCadenceSensor: number;

/**
 * Gets the cycling speed sensor appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.Cycling appearance category.
 */
static cyclingSpeedSensor: number;

/**
 * Gets the digital pen appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category.
 */
static digitalPen: number;

/**
 * Gets the digitizer tablet appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category.
 */
static digitizerTablet: number;

/**
 * Gets the gamepad appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category.
 */
static gamepad: number;

/**
 * Gets the generic appearance subcategory code.
 */
static generic: number;

/**
 * Gets the heart rate belt appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HeartRate appearance category.
 */
static heartRateBelt: number;

/**
 * Gets the joystick appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category.
 */
static joystick: number;

/**
 * Gets the keyboard appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category.
 */
static keyboard: number;

/**
 * Gets the location display appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.OutdoorSportActivity appearance category.
 */
static locationDisplay: number;

/**
 * Gets the location navigation display appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.OutdoorSportActivity appearance category.
 */
static locationNavigationDisplay: number;

/**
 * Gets the location navigation pod appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.OutdoorSportActivity appearance category.
 */
static locationNavigationPod: number;

/**
 * Gets the location pod appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.OutdoorSportActivity appearance category.
 */
static locationPod: number;

/**
 * Gets the mouse appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category.
 */
static mouse: number;

/**
 * Gets the oximeter fingertip appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.PulseOximeter appearance category.
 */
static oximeterFingertip: number;

/**
 * Gets the oximeter wrist worn appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.PulseOximeter appearance category.
 */
static oximeterWristWorn: number;

/**
 * Gets the running or walking in shoe appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.RunningWalking appearance category.
 */
static runningWalkingInShoe: number;

/**
 * Gets the running or walking on hip appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.RunningWalking appearance category.
 */
static runningWalkingOnHip: number;

/**
 * Gets the running or walking on shoe appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.RunningWalking appearance category.
 */
static runningWalkingOnShoe: number;

/**
 * Gets the sports watch appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.RunningWalking appearance category.
 */
static sportsWatch: number;

/**
 * Gets the ear thermometer appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.RunningWalking appearance category.
 */
static thermometerEar: number
}


/**
 * Represents a Bluetooth LE device.
 */
declare class Windows$Devices$Bluetooth$BluetoothLEDevice  {

/**
 * Returns a BluetoothLEDevice object for the given BluetoothAddress value and BluetoothAddressType value.
 * @param bluetoothAddress The 64-bit address of the Bluetooth LE device.
 * @param bluetoothAddressType The address type of the Bluetooth LE device.
 * @return Returns an asynchronous operation that completes with the BluetoothLEDevice object.
 */
static fromBluetoothAddressAsync(
bluetoothAddress: number,
bluetoothAddressType: $Values<typeof Windows$Devices$Bluetooth$BluetoothAddressType>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Bluetooth$BluetoothLEDevice>;

/**
 * Returns a BluetoothLEDevice object for the given Id.
 * @param deviceId The Id of the Bluetooth LE device.
 * @return After the asynchronous operation completes, returns the BluetoothLEDevice object with the given Id.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Bluetooth$BluetoothLEDevice>;

/**
 * Gets an Advanced Query Syntax (AQS) string for identifying all Bluetooth Low Energy (LE) devices. This string is passed to the FindAllAsync or CreateWatcher method in order to get a list of Bluetooth LE devices.
 * @return The device selector for this device.
 */
static getDeviceSelector(): string;

/**
 * Creates an Advanced Query Syntax (AQS) filter string from a BluetoothLEAppearance object. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects with the specified appearance.
 * @param appearance The Bluetooth LE appearance used for constructing the AQS string.
 * @return An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
static getDeviceSelectorFromAppearance(appearance: Windows$Devices$Bluetooth$BluetoothLEAppearance): string;

/**
 * Creates an Advanced Query Syntax (AQS) filter string from a 64-bit address that represents a Bluetooth LE device. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects.
 * @param bluetoothAddress A 64-bit Bluetooth LE device address used for constructing the AQS string.
 * @return An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
static getDeviceSelectorFromBluetoothAddress(bluetoothAddress: number): string;

/**
 * Creates an Advanced Query Syntax (AQS) filter string from a 64-bit address and address type that represents a Bluetooth LE device. The AQS string is passed into the CreateWatcher method.
 * @param bluetoothAddress A 64-bit Bluetooth LE device address used for constructing the AQS string.
 * @param bluetoothAddressType The Bluetooth LE device address type.
 * @return An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
static getDeviceSelectorFromBluetoothAddress(
bluetoothAddress: number,
bluetoothAddressType: $Values<typeof Windows$Devices$Bluetooth$BluetoothAddressType>): string;

/**
 * Creates an Advanced Query Syntax (AQS) filter string that contains a query for Bluetooth LE devices with the indicated BluetoothConnectionStatus . The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects with the indicated Bluetooth connection status.
 * @param connectionStatus The connection status used for constructing the AQS string.
 * @return An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
static getDeviceSelectorFromConnectionStatus(
connectionStatus: $Values<typeof Windows$Devices$Bluetooth$BluetoothConnectionStatus>): string;

/**
 * Creates an Advanced Query Syntax (AQS) filter string that contains a query for the Bluetooth LE device name. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects containing the specified Bluetooth LE device name.
 * @param deviceName The Bluetooth LE device name used for constructing the AQS string.
 * @return An AQS string that is passed as a parameter to the CreateWatcher method.
 */
static getDeviceSelectorFromDeviceName(deviceName: string): string;

/**
 * Creates an Advanced Query Syntax (AQS) filter string that contains a query for Bluetooth LE devices that are either paired or unpaired. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects.
 * @param pairingState The current pairing state for Bluetooth LE devices used for constructing the AQS string. Bluetooth LE devices can be either paired (true) or unpaired (false). The AQS Filter string will request scanning to be performed when the pairingState is false.
 * @return An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
static getDeviceSelectorFromPairingState(pairingState: boolean): string;

/**
 * Gets the BluetoothLEAppearance object for the Bluetooth LE device.
 */
appearance: Windows$Devices$Bluetooth$BluetoothLEAppearance;

/**
 * Gets the device address.
 */
bluetoothAddress: number;

/**
 * Gets the address type for the Bluetooth LE device.
 */
bluetoothAddressType: $Values<typeof Windows$Devices$Bluetooth$BluetoothAddressType>;

/**
 * Closes this Bluetooth LE device.
 */
close(): void;

/**
 * Gets the connection status of the device.
 */
connectionStatus: $Values<typeof Windows$Devices$Bluetooth$BluetoothConnectionStatus>;

/**
 * Gets the device Id.
 */
deviceId: string;

/**
 * Gets the DeviceInformation object for the Bluetooth LE device.
 */
deviceInformation: Windows$Devices$Enumeration$DeviceInformation;

/**
 * Gets the read-only list of GATT services supported by the device.
 */
gattServices: Windows$Foundation$Collections$IVectorView<Windows$Devices$Bluetooth$GenericAttributeProfile$GattDeviceService>;

/**
 * Returns the GATT service with the given service Id.
 * @param serviceUuid The service Id of the GATT service.
 * @return The GATT service represented by the given service Id.
 */
getGattService(
serviceUuid: string): Windows$Devices$Bluetooth$GenericAttributeProfile$GattDeviceService;

/**
 * Gets the name of the Bluetooth LE device.
 */
name: string;

/**
 * Occurs when the connection status for the device has changed.
 */
onconnectionstatuschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothLEDevice, any>;
addEventListener(
type: "connectionstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothLEDevice, any>): void;
removeEventListener(
type: "connectionstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothLEDevice, any>): void;

/**
 * Occurs when the list of GATT services supported by the device has changed.
 */
ongattserviceschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothLEDevice, any>;
addEventListener(
type: "gattserviceschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothLEDevice, any>): void;
removeEventListener(
type: "gattserviceschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothLEDevice, any>): void;

/**
 * Occurs when the name of the device has changed.
 */
onnamechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothLEDevice, any>;
addEventListener(
type: "namechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothLEDevice, any>): void;
removeEventListener(
type: "namechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$BluetoothLEDevice, any>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Indicates the Major Class code of the device, which is the general family of device with which the device is associated.
 */

declare  var Windows$Devices$Bluetooth$BluetoothMajorClass: {|
  +miscellaneous: 0,// 0
+computer: 1,// 1
+phone: 2,// 2
+networkAccessPoint: 3,// 3
+audioVideo: 4,// 4
+peripheral: 5,// 5
+imaging: 6,// 6
+wearable: 7,// 7
+toy: 8,// 8
+health: 9,// 9

|};



/**
 * Indicates the Minor Class code of the device. These are interpreted in the context of the Major Class codes.
 */

declare  var Windows$Devices$Bluetooth$BluetoothMinorClass: {|
  +uncategorized: 0,// 0
+computerDesktop: 1,// 1
+computerServer: 2,// 2
+computerLaptop: 3,// 3
+computerHandheld: 4,// 4
+computerPalmSize: 5,// 5
+computerWearable: 6,// 6
+computerTablet: 7,// 7
+phoneCellular: 8,// 8
+phoneCordless: 9,// 9
+phoneSmartPhone: 10,// 10
+phoneWired: 11,// 11
+phoneIsdn: 12,// 12
+networkFullyAvailable: 13,// 13
+networkUsed01To17Percent: 14,// 14
+networkUsed17To33Percent: 15,// 15
+networkUsed33To50Percent: 16,// 16
+networkUsed50To67Percent: 17,// 17
+networkUsed67To83Percent: 18,// 18
+networkUsed83To99Percent: 19,// 19
+networkNoServiceAvailable: 20,// 20
+audioVideoWearableHeadset: 21,// 21
+audioVideoHandsFree: 22,// 22
+audioVideoMicrophone: 23,// 23
+audioVideoLoudspeaker: 24,// 24
+audioVideoHeadphones: 25,// 25
+audioVideoPortableAudio: 26,// 26
+audioVideoCarAudio: 27,// 27
+audioVideoSetTopBox: 28,// 28
+audioVideoHifiAudioDevice: 29,// 29
+audioVideoVcr: 30,// 30
+audioVideoVideoCamera: 31,// 31
+audioVideoCamcorder: 32,// 32
+audioVideoVideoMonitor: 33,// 33
+audioVideoVideoDisplayAndLoudspeaker: 34,// 34
+audioVideoVideoConferencing: 35,// 35
+audioVideoGamingOrToy: 36,// 36
+peripheralJoystick: 37,// 37
+peripheralGamepad: 38,// 38
+peripheralRemoteControl: 39,// 39
+peripheralSensing: 40,// 40
+peripheralDigitizerTablet: 41,// 41
+peripheralCardReader: 42,// 42
+peripheralDigitalPen: 43,// 43
+peripheralHandheldScanner: 44,// 44
+peripheralHandheldGesture: 45,// 45
+wearableWristwatch: 46,// 46
+wearablePager: 47,// 47
+wearableJacket: 48,// 48
+wearableHelmet: 49,// 49
+wearableGlasses: 50,// 50
+toyRobot: 51,// 51
+toyVehicle: 52,// 52
+toyDoll: 53,// 53
+toyController: 54,// 54
+toyGame: 55,// 55
+healthBloodPressureMonitor: 56,// 56
+healthThermometer: 57,// 57
+healthWeighingScale: 58,// 58
+healthGlucoseMeter: 59,// 59
+healthPulseOximeter: 60,// 60
+healthHeartRateMonitor: 61,// 61
+healthHealthDataDisplay: 62,// 62
+healthStepCounter: 63,// 63
+healthBodyCompositionAnalyzer: 64,// 64
+healthPeakFlowMonitor: 65,// 65
+healthMedicationMonitor: 66,// 66
+healthKneeProsthesis: 67,// 67
+healthAnkleProsthesis: 68,// 68
+healthGenericHealthManager: 69,// 69
+healthPersonalMobilityDevice: 70,// 70

|};



/**
 * Indicates the service capabilities of a device.
 */

declare  var Windows$Devices$Bluetooth$BluetoothServiceCapabilities: {|
  +none: 0,// 0
+limitedDiscoverableMode: 1,// 1
+positioningService: 2,// 2
+networkingService: 3,// 3
+renderingService: 4,// 4
+capturingService: 5,// 5
+objectTransferService: 6,// 6
+audioService: 7,// 7
+telephoneService: 8,// 8
+informationService: 9,// 9

|};



/**
 * Groups parameters used to configure received signal strength indicator (RSSI)-based filtering.
 */
declare class Windows$Devices$Bluetooth$BluetoothSignalStrengthFilter  {

/**
 * Create a new BluetoothSignalStrengthFilter object.
 */
constructor(): this;

/**
 * The minimum received signal strength indicator (RSSI) value in dBm on which RSSI events will be propagated or considered in range if the previous events were considered out of range.
 */
inRangeThresholdInDBm: number;

/**
 * The minimum received signal strength indicator (RSSI) value in dBm on which RSSI events will be considered out of range.
 */
outOfRangeThresholdInDBm: number;

/**
 * The timeout for a received signal strength indicator (RSSI) event to be considered out of range.
 */
outOfRangeTimeout: number;

/**
 * The interval at which received signal strength indicator (RSSI) events are sampled.
 */
samplingInterval: number
}


      declare var npm$namespace$Windows$Devices$Bluetooth$GenericAttributeProfile: {
        
        
        GattCharacteristicProperties: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristicProperties,
GattClientCharacteristicConfigurationDescriptorValue: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattClientCharacteristicConfigurationDescriptorValue,
GattCommunicationStatus: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattCommunicationStatus,
GattProtectionLevel: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattProtectionLevel,
GattWriteOption: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattWriteOption,
        GattCharacteristic: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristic,
GattCharacteristicUuids: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristicUuids,
GattDescriptor: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattDescriptor,
GattDescriptorUuids: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattDescriptorUuids,
GattDeviceService: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattDeviceService,
GattPresentationFormat: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattPresentationFormat,
GattPresentationFormatTypes: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattPresentationFormatTypes,
GattReadClientCharacteristicConfigurationDescriptorResult: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattReadClientCharacteristicConfigurationDescriptorResult,
GattReadResult: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattReadResult,
GattReliableWriteTransaction: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattReliableWriteTransaction,
GattServiceUuids: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattServiceUuids,
GattValueChangedEventArgs: typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattValueChangedEventArgs,
        
      }

/**
 * Represents a Characteristic of a GATT service.
 */
declare class Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristic  {

/**
 * Converts a Bluetooth SIG defined short Id to a full GATT UUID.
 * @param shortId A 16-bit Bluetooth GATT Service UUID.
 * @return The corresponding 128-bit GATT Characteristic UUID, that uniquely identifies this characteristic.
 */
static convertShortIdToUuid(shortId: number): string;

/**
 * Gets the handle used to uniquely identify GATT-based characteristic attributes as declared on the Bluetooth LE device.
 */
attributeHandle: number;

/**
 * Gets the GATT characteristic properties, as defined by the GATT profile.
 */
characteristicProperties: $Values<typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristicProperties>;

/**
 * Gets the collection of all descriptors belonging to this GattCharacteristic instance.
 * @return The collection of all descriptors belonging to this GattCharacteristic instance.
 */
getAllDescriptors(
): Windows$Foundation$Collections$IVectorView<Windows$Devices$Bluetooth$GenericAttributeProfile$GattDescriptor>;

/**
 * Returns a vector of descriptors, that are identified by the specified UUID, and belong to this GattCharacteristic instance.
 * @param descriptorUuid The UUID for the descriptors to be retrieved.
 * @return A vector of descriptors whose UUIDs match descriptorUuid.
 */
getDescriptors(
descriptorUuid: string): Windows$Foundation$Collections$IVectorView<Windows$Devices$Bluetooth$GenericAttributeProfile$GattDescriptor>;

/**
 * An App can register an event handler in order to receive events when notification or indications are received from a device, after setting the Client Characteristic Configuration Descriptor.
 */
onvaluechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristic, Windows$Devices$Bluetooth$GenericAttributeProfile$GattValueChangedEventArgs>;
addEventListener(
type: "valuechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristic, Windows$Devices$Bluetooth$GenericAttributeProfile$GattValueChangedEventArgs>): void;
removeEventListener(
type: "valuechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristic, Windows$Devices$Bluetooth$GenericAttributeProfile$GattValueChangedEventArgs>): void;

/**
 * Gets the list of presentation format descriptors associated with this GattCharacteristic, in the order specified by the Aggregate Format Descriptor.
 */
presentationFormats: Windows$Foundation$Collections$IVectorView<Windows$Devices$Bluetooth$GenericAttributeProfile$GattPresentationFormat>;

/**
 * Gets or sets the desired GATT security options for over the air communication with the device.
 */
protectionLevel: $Values<typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattProtectionLevel>;

/**
 * Reads the current value of the ClientCharacteristicConfigurationDescriptor.
 * @return The object that manages the asynchronous operation. Upon completion of the asynchronous method, the IAsyncOperation(GattReadClientCharacteristicConfigurationDescriptorResult) contains the result of the read operation, which contains the status of completed operation.
 */
readClientCharacteristicConfigurationDescriptorAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Bluetooth$GenericAttributeProfile$GattReadClientCharacteristicConfigurationDescriptorResult>;

/**
 * Performs a Characteristic Value read either from the value cache maintained by Windows, or directly from the device.
 * @param cacheMode Specifies whether to read the value directly from the device or from a value cache maintained by Windows.
 * @return The object required to manage the asynchronous operation, which, upon completion, returns a GattReadResult object, which in turn contains the completion status of the asynchronous operation and, if successful, the data read from the device.
 */
readValueAsync(
cacheMode: $Values<typeof Windows$Devices$Bluetooth$BluetoothCacheMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Bluetooth$GenericAttributeProfile$GattReadResult>;

/**
 * Performs a Characteristic Value read from the value cache maintained by Windows.
 * @return The object required to manage the asynchronous operation, which, upon completion, returns a GattReadResult object, which in turn contains the completion status of the asynchronous operation and, if successful, the data read from the device.
 */
readValueAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Bluetooth$GenericAttributeProfile$GattReadResult>;

/**
 * Gets the GattDeviceService of which this characteristic is a member.
 */
service: Windows$Devices$Bluetooth$GenericAttributeProfile$GattDeviceService;

/**
 * Get the user friendly description for this GattCharacteristic, if the User Description Descriptor is present, otherwise this will be an empty string.
 */
userDescription: string;

/**
 * Gets the GATT Characteristic UUID for this GattCharacteristic.
 */
uuid: string;

/**
 * Writes the ClientCharacteristicConfigurationDescriptor to the Bluetooth LE device, and if the value to be written represents an indication or a notification and a ValueChanged event handler is registered, enables receiving ValueChanged events from the device.
 * @param clientCharacteristicConfigurationDescriptorValue Specifies a new value for the ClientCharacteristicConfigurationDescriptor of this Characteristic object.
 * @return The object that manages the asynchronous operation, which, upon completion, returns the status with which the operation completed.
 */
writeClientCharacteristicConfigurationDescriptorAsync(
clientCharacteristicConfigurationDescriptorValue: $Values<typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattClientCharacteristicConfigurationDescriptorValue>): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattCommunicationStatus>>;

/**
 * Performs a Characteristic Value write to a Bluetooth LE device.
 * @param value A Windows.Storage.Streams.IBuffer object which contains the data to be written to the Bluetooth LE device.
 * @return The object that manages the asynchronous operation, which, upon completion, returns the status with which the operation completed.
 */
writeValueAsync(
value: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattCommunicationStatus>>;

/**
 * Performs a Characteristic Value write to a Bluetooth LE device.
 * @param value A Windows.Storage.Streams.IBuffer object which contains the data to be written to the Bluetooth LE device.
 * @param writeOption Specifies what type of GATT write should be performed.
 * @return The object that manages the asynchronous operation, which, upon completion, returns the status with which the operation completed.
 */
writeValueAsync(
value: Windows$Storage$Streams$IBuffer,
writeOption: $Values<typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattWriteOption>): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattCommunicationStatus>>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies the values for the GATT characteristic properties as well as the GATT Extended Characteristic Properties Descriptor.
 */

declare  var Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristicProperties: {|
  +none: 0,// 0
+broadcast: 1,// 1
+read: 2,// 2
+writeWithoutResponse: 3,// 3
+write: 4,// 4
+notify: 5,// 5
+indicate: 6,// 6
+authenticatedSignedWrites: 7,// 7
+extendedProperties: 8,// 8
+reliableWrites: 9,// 9
+writableAuxiliaries: 10,// 10

|};



/**
 * Represents an enumeration of the most well known Characteristic UUID values, and provides convenience methods for working with GATT characteristic UUIDs, and static properties providing characteristic UUIDs for common GATT characteristics.
 */
declare class Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristicUuids  {

/**
 * Gets the Bluetooth SIG-defined AlertCategoryId characteristic UUID.
 */
static alertCategoryId: string;

/**
 * Gets the Bluetooth SIG-Defined AlertCategoryIdBitMask characteristic UUID.
 */
static alertCategoryIdBitMask: string;

/**
 * Gets the Bluetooth SIG-defined AlertLevel characteristic UUID.
 */
static alertLevel: string;

/**
 * Gets the Bluetooth SIG-defined AlertNotificationControlPoint characteristic UUID.
 */
static alertNotificationControlPoint: string;

/**
 * Gets the Bluetooth SIG-defined AlertStatus characteristic UUID.
 */
static alertStatus: string;

/**
 * Gets the Bluetooth SIG-defined Battery Level Characteristic UUID.
 */
static batteryLevel: string;

/**
 * Gets the Bluetooth SIG-defined Blood Pressure Feature Characteristic UUID.
 */
static bloodPressureFeature: string;

/**
 * Gets the Bluetooth SIG-defined Blood Pressure Measurement Characteristic UUID.
 */
static bloodPressureMeasurement: string;

/**
 * Gets the Bluetooth SIG-defined Body Sensor Location Characteristic UUID.
 */
static bodySensorLocation: string;

/**
 * Gets the Bluetooth SIG-defined BootKeyboardInputReport characteristic UUID.
 */
static bootKeyboardInputReport: string;

/**
 * Gets the Bluetooth SIG-defined BootKeyboardOutputReport characteristic UUID.
 */
static bootKeyboardOutputReport: string;

/**
 * Gets the Bluetooth SIG-defined BootMouseInputReport characteristic UUID.
 */
static bootMouseInputReport: string;

/**
 * Gets the Bluetooth SIG-defined Csc Feature Characteristic UUID.
 */
static cscFeature: string;

/**
 * Gets the Bluetooth SIG-defined Csc Measurement Characteristic UUID.
 */
static cscMeasurement: string;

/**
 * Gets the Bluetooth SIG-defined CurrentTime characteristic UUID.
 */
static currentTime: string;

/**
 * Gets the Bluetooth SIG-defined CyclingPowerControlPoint characteristic UUID.
 */
static cyclingPowerControlPoint: string;

/**
 * Gets the Bluetooth SIG-defined CyclingPowerFeature characteristic UUID.
 */
static cyclingPowerFeature: string;

/**
 * Gets the Bluetooth SIG-defined CyclingPowerMeasurement characteristic UUID.
 */
static cyclingPowerMeasurement: string;

/**
 * Gets the Bluetooth SIG-defined CyclingPowerVector characteristic UUID.
 */
static cyclingPowerVector: string;

/**
 * Gets the Bluetooth SIG-defined DateTime characteristic UUID.
 */
static dateTime: string;

/**
 * Gets the Bluetooth SIG-defined DayDateTime characteristic UUID.
 */
static dayDateTime: string;

/**
 * Gets the Bluetooth SIG-defined DayOfWeek characteristic UUID.
 */
static dayOfWeek: string;

/**
 * Gets the Bluetooth SIG-defined DstOffset characteristic UUID.
 */
static dstOffset: string;

/**
 * Gets the Bluetooth SIG-defined ExactTime256 characteristic UUID.
 */
static exactTime256: string;

/**
 * Gets the Bluetooth SIG-defined FirmwareRevisionString characteristic UUID.
 */
static firmwareRevisionString: string;

/**
 * Gets the Bluetooth SIG-defined GapAppearance characteristic UUID.
 */
static gapAppearance: string;

/**
 * Gets the Bluetooth SIG-defined GapDeviceName characteristic UUID.
 */
static gapDeviceName: string;

/**
 * Gets the Bluetooth SIG-defined GapPeripheralPreferredConnectionParameters characteristic UUID.
 */
static gapPeripheralPreferredConnectionParameters: string;

/**
 * Gets the Bluetooth GapPeripheralPrivacyFlag characterisitc UUID.
 */
static gapPeripheralPrivacyFlag: string;

/**
 * Gets the Bluetooth SIG-defined GapReconnectionAddress characteristic UUID.
 */
static gapReconnectionAddress: string;

/**
 * Gets the Bluetooth SIG-defined GattServiceChanged characteristic UUID.
 */
static gattServiceChanged: string;

/**
 * Gets the Bluetooth SIG-defined Glucose Feature Characteristic UUID.
 */
static glucoseFeature: string;

/**
 * Gets the Bluetooth SIG-defined Glucose Measurement Characteristic UUID.
 */
static glucoseMeasurement: string;

/**
 * Gets the Bluetooth SIG-defined Glucose Measurement Context Characteristic UUID.
 */
static glucoseMeasurementContext: string;

/**
 * Gets the Bluetooth SIG-defined HardwareRevisionString characterisitc UUID.
 */
static hardwareRevisionString: string;

/**
 * Gets the Bluetooth SIG-defined Heart Rate Control Point Characteristic UUID.
 */
static heartRateControlPoint: string;

/**
 * Gets the Bluetooth SIG-defined Heart Rate Measurement Characteristic UUID.
 */
static heartRateMeasurement: string;

/**
 * Gets the Bluetooth SIG-defined HidControlPoint characteristic UUID.
 */
static hidControlPoint: string;

/**
 * Gets the Bluetooth SIG-defined HidInformation characteristic UUID.
 */
static hidInformation: string;

/**
 * Gets the Bluetooth SIG-defined Ieee1107320601RegulatoryCertificationDataList characteristic UUID.
 */
static ieee1107320601RegulatoryCertificationDataList: string;

/**
 * Gets the Bluetooth SIG-defined Intermediate Cuff Pressure Characteristic UUID.
 */
static intermediateCuffPressure: string;

/**
 * Gets the Bluetooth SIG-defined Intermediate Temperature Characteristic UUID.
 */
static intermediateTemperature: string;

/**
 * Gets the Bluetooth SIG-defined LnControlPoint characteristic UUID.
 */
static lnControlPoint: string;

/**
 * Gets the Bluetooth SIG-defined LnFeature characteristic UUID.
 */
static lnFeature: string;

/**
 * Gets the Bluetooth SIG-defined LocalTimeInformation characteristic UUID.
 */
static localTimeInformation: string;

/**
 * Gets the Bluetooth SIG-defined LocationAndSpeed characteristic UUID.
 */
static locationAndSpeed: string;

/**
 * Gets the Bluetooth SIG-defined ManufacturerNameString characteristic UUID.
 */
static manufacturerNameString: string;

/**
 * Gets the Bluetooth SIG-defined Measurement Interval Characteristic UUID.
 */
static measurementInterval: string;

/**
 * Gets the Bluetooth SIG-defined ModelNumberString UUID.
 */
static modelNumberString: string;

/**
 * Gets the Bluetooth SIG-defined Navigation characteristic UUID.
 */
static navigation: string;

/**
 * Gets the Bluetooth SIG-defined NewAlert characteristic UUID.
 */
static newAlert: string;

/**
 * Gets the Bluetooth SIG-defined PnpId characteristic UUID.
 */
static pnpId: string;

/**
 * Gets the Bluetooth SIG-defined PositionQuality characteristic UUID.
 */
static positionQuality: string;

/**
 * Gets the Bluetooth SIG-defined ProtocolMode characteristic UUID.
 */
static protocolMode: string;

/**
 * Gets the Bluetooth SIG-defined Record Access Control Point Characteristic UUID.
 */
static recordAccessControlPoint: string;

/**
 * Gets the Bluetooth SIG-defined ReferenceTimeInformation characteristic UUID.
 */
static referenceTimeInformation: string;

/**
 * Gets the Bluetooth SIG-defined Report characteristic UUID.
 */
static report: string;

/**
 * Gets the Bluetooth SIG-defined ReportMap characteristic UUID.
 */
static reportMap: string;

/**
 * Gets the Bluetooth SIG-defined RingerControlPoint characteristic UUID.
 */
static ringerControlPoint: string;

/**
 * Gets the Bluetooth SIG-defined RingerSetting characteristic UUID.
 */
static ringerSetting: string;

/**
 * Gets the Bluetooth SIG-defined Rsc Feature Characteristic UUID.
 */
static rscFeature: string;

/**
 * Gets the Bluetooth SIG-defined Rsc Measurement Characteristic UUID.
 */
static rscMeasurement: string;

/**
 * Gets the Bluetooth SIG-defined SC Control Point Characteristic UUID.
 */
static scControlPoint: string;

/**
 * Gets the Bluetooth SIG-defined ScanIntervalWindow characteristic UUID.
 */
static scanIntervalWindow: string;

/**
 * Gets the Bluetooth SIG-defined ScanRefresh characteristic UUID.
 */
static scanRefresh: string;

/**
 * Gets the Bluetooth SIG-defined Sensor Location Characteristic UUID.
 */
static sensorLocation: string;

/**
 * Gets the Bluetooth SIG-defined SerialNumberString characteristic UUID.
 */
static serialNumberString: string;

/**
 * Gets the Bluetooth SIG-defined SoftwareRevisionString characteristic UUID.
 */
static softwareRevisionString: string;

/**
 * Gets the Bluetooth SIG-defined SupportUnreadAlertCategory characteristic UUID.
 */
static supportUnreadAlertCategory: string;

/**
 * Gets the Bluetooth SIG-defined SupportedNewAlertCategory characteristic UUID.
 */
static supportedNewAlertCategory: string;

/**
 * Gets the Bluetooth SIG-defined SystemId characteristic UUID.
 */
static systemId: string;

/**
 * Gets the Bluetooth SIG-defined Temperature Measurement Characteristic UUID.
 */
static temperatureMeasurement: string;

/**
 * Gets the Bluetooth SIG-defined Temperature Type Characteristic UUID.
 */
static temperatureType: string;

/**
 * Gets the Bluetooth SIG-defined TimeAccuracy characteristic UUID.
 */
static timeAccuracy: string;

/**
 * Gets the Bluetooth SIG-defined TimeSource characteristic UUID.
 */
static timeSource: string;

/**
 * Gets the Bluetooth SIG-defined TimeUpdateControlPoint characteristic UUID.
 */
static timeUpdateControlPoint: string;

/**
 * Gets the Bluetooth SIG-defined TimeUpdateState characteristic UUID.
 */
static timeUpdateState: string;

/**
 * Gets the Bluetooth SIG-defined TimeWithDst characteristic UUID.
 */
static timeWithDst: string;

/**
 * Gets the Bluetooth SIG-defined TimeZone characteristic UUID.
 */
static timeZone: string;

/**
 * Gets the Bluetooth SIG-defined TxPowerLevel characteristic UUID.
 */
static txPowerLevel: string;

/**
 * Gets the Bluetooth SIG-defined UnreadAlertStatus characteristic UUID.
 */
static unreadAlertStatus: string
}


/**
 * Represents the value of the GATT ClientCharacteristicConfigurationDescriptor.
 */

declare  var Windows$Devices$Bluetooth$GenericAttributeProfile$GattClientCharacteristicConfigurationDescriptorValue: {|
  +none: 0,// 0
+notify: 1,// 1
+indicate: 2,// 2

|};



/**
 * Represents the return status of a WinRT GATT API related Async operation.
 */

declare  var Windows$Devices$Bluetooth$GenericAttributeProfile$GattCommunicationStatus: {|
  +success: 0,// 0
+unreachable: 1,// 1

|};



/**
 * Represents a Descriptor of a GATT Characteristic.
 */
declare class Windows$Devices$Bluetooth$GenericAttributeProfile$GattDescriptor  {

/**
 * Converts a Bluetooth SIG defined short Id to a full GATT UUID.
 * @param shortId A 16-bit Bluetooth GATT Descriptor UUID.
 * @return The corresponding 128-bit GATT Descriptor UUID, that uniquely identifies this descriptor.
 */
static convertShortIdToUuid(shortId: number): string;

/**
 * Gets the GATT Attribute handle used to uniquely identify this attribute on the GATT Server Device.
 */
attributeHandle: number;

/**
 * Gets or sets the desired GATT security options for over the air communication with the device.
 */
protectionLevel: $Values<typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattProtectionLevel>;

/**
 * Performs a Descriptor Value read either from the value cache maintained by Windows, or directly from the device.
 * @param cacheMode Specifies whether to read the value directly from the device or from a value cache maintained by Windows.
 * @return The object required to manage the asynchronous operation, which, upon completion, returns a GattReadResult object, which in turn contains the completion status of the asynchronous operation and, if successful, the data read from the device.
 */
readValueAsync(
cacheMode: $Values<typeof Windows$Devices$Bluetooth$BluetoothCacheMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Bluetooth$GenericAttributeProfile$GattReadResult>;

/**
 * Performs a Descriptor Value read from a value cache maintained by Windows.
 * @return The object required to manage the asynchronous operation, which, upon completion, returns a GattReadResult object, which in turn contains the completion status of the asynchronous operation and, if successful, the data read from the device.
 */
readValueAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Bluetooth$GenericAttributeProfile$GattReadResult>;

/**
 * Gets the GATT Descriptor UUID for this GattDescriptor.
 */
uuid: string;

/**
 * Performs a Descriptor Value write to a Bluetooth LE device.
 * @param value A Windows.Storage.Streams.IBuffer object which contains the data to be written to the Bluetooth LE device.
 * @return The object that manages the asynchronous operation, which, upon completion, returns the status with which the operation completed.
 */
writeValueAsync(
value: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattCommunicationStatus>>
}


/**
 * Represents an enumeration of the most well known Descriptor UUID values, and provides convenience methods for working with GATT descriptor UUIDs, and static properties providing descriptor UUIDs for common GATT descriptors.
 */
declare class Windows$Devices$Bluetooth$GenericAttributeProfile$GattDescriptorUuids  {

/**
 * Gets the Bluetooth SIG-defined Characteristic Aggregate Format Descriptor UUID.
 */
static characteristicAggregateFormat: string;

/**
 * Gets the Bluetooth SIG-defined Characteristic Extended Properties Descriptor UUID.
 */
static characteristicExtendedProperties: string;

/**
 * Gets the Bluetooth SIG-defined Characteristic Presentation Format Descriptor UUID.
 */
static characteristicPresentationFormat: string;

/**
 * Gets the Bluetooth SIG-defined Characteristic User Description Descriptor UUID.
 */
static characteristicUserDescription: string;

/**
 * Gets the Bluetooth SIG-defined Client Characteristic Configuration Descriptor UUID.
 */
static clientCharacteristicConfiguration: string;

/**
 * Gets the Bluetooth SIG-defined Server Characteristic Configuration Descriptor UUID.
 */
static serverCharacteristicConfiguration: string
}


/**
 * Represents a GATT Primary Service on a Bluetooth device.
 */
declare class Windows$Devices$Bluetooth$GenericAttributeProfile$GattDeviceService  {

/**
 * Converts a Bluetooth SIG defined short Id to a full GATT UUID.
 * @param shortId A 16-bit Bluetooth GATT Service UUID.
 * @return The corresponding 128-bit GATT Service UUID, that uniquely identifies this service.
 */
static convertShortIdToUuid(shortId: number): string;

/**
 * Instantiates a new GattDeviceService from the device ID.
 * @param deviceId The GATT device ID.
 * @return The object for managing the asynchronous operation, which, upon completion, returns the newly instantiated GattDeviceService.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Bluetooth$GenericAttributeProfile$GattDeviceService>;

/**
 * Creates a suitable AQS Filter string for use with the CreateWatcher method, from a 16-bit Bluetooth GATT Service UUID.
 * @param serviceShortId A 16-bit Bluetooth GATT Service UUID.
 * @return A suitable AQS Selector String which can be passed as a parameter to the CreateWatcher method, in order to retrieve a GATT service instance path
 */
static getDeviceSelectorFromShortId(serviceShortId: number): string;

/**
 * Creates a suitable AQS Filter string for use with the CreateWatcher method, from a Bluetooth service UUID.
 * @param serviceUuid A 128-bit Bluetooth GATT Service UUID, represented as a standard GUID object.
 * @return A suitable AQS Selector String which can be passed as a parameter to the CreateWatcher method, in order to retrieve a GATT service instance path.
 */
static getDeviceSelectorFromUuid(serviceUuid: string): string;

/**
 * Gets the handle used to uniquely identify GATT-based service attributes as declared on the Bluetooth LE device.
 */
attributeHandle: number;

/**
 * Releases the resources associated with the GattDeviceService class. This allows other apps to access the resources of the GattDeviceService in question. A GattDeviceService object should not be used after Close is invoked, instead a new GattDeviceService object should be instantiated using the FromIdAsync method.
 */
close(): void;

/**
 * Gets the BluetoothLEDevice object describing the device associated with the current GattDeviceService object.
 */
device: Windows$Devices$Bluetooth$BluetoothLEDevice;

/**
 * Get the string that represents the GATT service instance path used to instantiate the GattDeviceService.
 */
deviceId: string;

/**
 * Gets the collection of all characteristics belonging to this GattDeviceService instance.
 * @return The collection of all characteristics belonging to this GattDeviceService instance.
 */
getAllCharacteristics(
): Windows$Foundation$Collections$IVectorView<Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristic>;

/**
 * Gets the collection of all included services belonging to this GattDeviceService instance.
 * @return The collection of all included services belonging to this GattDeviceService instance.
 */
getAllIncludedServices(
): Windows$Foundation$Collections$IVectorView<Windows$Devices$Bluetooth$GenericAttributeProfile$GattDeviceService>;

/**
 * Returns a vector of characteristics, that are identified by the specified UUID and belong to this GattDeviceService instance.
 * @param characteristicUuid The UUID for the characteristics to be retrieved.
 * @return A vector of GattCharacteristic objects whose UUIDs match characteristicUuid.
 */
getCharacteristics(
characteristicUuid: string): Windows$Foundation$Collections$IVectorView<Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristic>;

/**
 * Returns a vector of included services, that are identified by the specified UUID and belong to this GattDeviceService instance.
 * @param serviceUuid The UUID for the included services to be retrieved.
 * @return A vector of included services whose UUIDs match serviceUuid.
 */
getIncludedServices(
serviceUuid: string): Windows$Foundation$Collections$IVectorView<Windows$Devices$Bluetooth$GenericAttributeProfile$GattDeviceService>;

/**
 * Gets the read-only list of parent services for this service.
 */
parentServices: Windows$Foundation$Collections$IVectorView<Windows$Devices$Bluetooth$GenericAttributeProfile$GattDeviceService>;

/**
 * The GATT Service UUID associated with this GattDeviceService.
 */
uuid: string
}


/**
 * Represents the value of a single Presentation Format GATT Descriptor.
 */
declare class Windows$Devices$Bluetooth$GenericAttributeProfile$GattPresentationFormat  {

/**
 * Gets the value of the Bluetooth SIG Assigned Numbers Namespace.
 */
static bluetoothSigAssignedNumbers: number;

/**
 * Gets the Description of the GattPresentationFormat object.
 */
description: number;

/**
 * Gets the Exponent of the GattPresentationFormat object.
 */
exponent: number;

/**
 * Gets the Format Type of the GattPresentationFormat object.
 */
formatType: number;

/**
 * Gets the Namespace of the GattPresentationFormat object.
 */
namespace: number;

/**
 * Gets the Unit of the GattPresentationFormat object.
 */
unit: number
}


/**
 * Represents the different well-known values that the GattPresentationFormat.FormatType property can take.
 */
declare class Windows$Devices$Bluetooth$GenericAttributeProfile$GattPresentationFormatTypes  {

/**
 * Gets the value of the Bit2 Format Type.
 */
static bit2: number;

/**
 * Gets the value of the Boolean Format Type.
 */
static boolean: number;

/**
 * Gets the value of the DUInt16 Format Type.
 */
static duInt16: number;

/**
 * Gets the value of the Float Format Type.
 */
static float: number;

/**
 * Gets the value of the Float32 Format Type.
 */
static float32: number;

/**
 * Gets the value of the Float64 Format Type.
 */
static float64: number;

/**
 * Gets the value of the Nibble Format Type.
 */
static nibble: number;

/**
 * Gets the value of the SFloat Format Type.
 */
static sfloat: number;

/**
 * Gets the value of the SInt12 Format Type.
 */
static sint12: number;

/**
 * Gets the value of the SInt128 Format Type.
 */
static sint128: number;

/**
 * Gets the value of the SInt16 Format Type.
 */
static sint16: number;

/**
 * Gets the value of the SInt24 Format Type.
 */
static sint24: number;

/**
 * Gets the value of the SInt32 Format Type.
 */
static sint32: number;

/**
 * Gets the value of the SInt48 Format Type.
 */
static sint48: number;

/**
 * Gets the value of the SInt64 Format Type.
 */
static sint64: number;

/**
 * Gets the value of the SInt8 Format Type.
 */
static sint8: number;

/**
 * Gets the value of the Struct Format Type.
 */
static struct: number;

/**
 * Gets the value of the UInt12 Format Type.
 */
static uint12: number;

/**
 * Gets the value of the UInt128 Format Type.
 */
static uint128: number;

/**
 * Gets the value of the UInt16 Format Type.
 */
static uint16: number;

/**
 * Gets the value of the UInt24 Format Type.
 */
static uint24: number;

/**
 * Gets the value of the UInt32 Format Type.
 */
static uint32: number;

/**
 * Gets the value of the UInt48 Format Type.
 */
static uint48: number;

/**
 * Gets the value of the UInt64 Format Type.
 */
static uint64: number;

/**
 * Gets the value of the UInt8 Format Type.
 */
static uint8: number;

/**
 * Gets the value of the Utf16 Format Type.
 */
static utf16: number;

/**
 * Gets the value of the Utf8 Format Type.
 */
static utf8: number
}


/**
 * Represents the desired security level.
 */

declare  var Windows$Devices$Bluetooth$GenericAttributeProfile$GattProtectionLevel: {|
  +plain: 0,// 0
+authenticationRequired: 1,// 1
+encryptionRequired: 2,// 2
+encryptionAndAuthenticationRequired: 3,// 3

|};



/**
 * Represents the result of reading a GATT Client CharacteristicConfigurationClientDescriptor value.
 */
declare class Windows$Devices$Bluetooth$GenericAttributeProfile$GattReadClientCharacteristicConfigurationDescriptorResult  {

/**
 * Gets the result of an asynchronous read operation.
 */
clientCharacteristicConfigurationDescriptor: $Values<typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattClientCharacteristicConfigurationDescriptorValue>;

/**
 * Gets the status of an asynchronous operation.
 */
status: $Values<typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattCommunicationStatus>
}


/**
 * Represents the result of an asynchronous read operation of a GATT Characteristic or Descriptor value.
 */
declare class Windows$Devices$Bluetooth$GenericAttributeProfile$GattReadResult  {

/**
 * Gets the status of an asynchronous operation.
 */
status: $Values<typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattCommunicationStatus>;

/**
 * Gets the value read from the device.
 */
value: Windows$Storage$Streams$IBuffer
}


/**
 * Performs GATT reliable writes on the Bluetooth LE device, in the form of a transaction write operation.
 */
declare class Windows$Devices$Bluetooth$GenericAttributeProfile$GattReliableWriteTransaction  {

/**
 * Creates a new GattReliableWriteTransaction object.
 */
constructor(): this;

/**
 * Performs all the queued writes, in sequence, writing the data to the device. Once a transaction object has been committed, no further operations are possible on the GattReliableWriteTransaction object.
 * @return The object used to manage the asynchronous operation, which, upon completion, will return the status of the asynchronous operation.
 */
commitAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Devices$Bluetooth$GenericAttributeProfile$GattCommunicationStatus>>;

/**
 * Adds a new write operation to the transaction object.
 * @param characteristic The GattCharacteristic object on which to perform the write operation.
 * @param value The Characteristic Value to be written to characteristic.
 */
writeValue(
characteristic: Windows$Devices$Bluetooth$GenericAttributeProfile$GattCharacteristic,
value: Windows$Storage$Streams$IBuffer): void
}


/**
 * Represents an enumeration of the most well known Service UUID values, and provides convenience methods for working with GATT service UUIDs, and static properties providing service UUIDs for common GATT services.
 */
declare class Windows$Devices$Bluetooth$GenericAttributeProfile$GattServiceUuids  {

/**
 * Gets the Bluetooth SIG-defined AlertNotification Service UUID.
 */
static alertNotification: string;

/**
 * Gets the Bluetooth SIG-defined Battery Service UUID.
 */
static battery: string;

/**
 * Gets the Bluetooth SIG-defined Blood Pressure Service UUID.
 */
static bloodPressure: string;

/**
 * Gets the Bluetooth SIG-defined CurrentTime service UUID.
 */
static currentTime: string;

/**
 * Gets the Bluetooth SIG-defined CyclingPower service UUID.
 */
static cyclingPower: string;

/**
 * Gets the Bluetooth SIG-defined Cycling Speed And Cadence Service UUID.
 */
static cyclingSpeedAndCadence: string;

/**
 * Gets the Bluetooth SIG-defined DeviceInformation service UUID.
 */
static deviceInformation: string;

/**
 * Gets the Bluetooth SIG-defined UUID for the Generic Access Service.
 */
static genericAccess: string;

/**
 * Gets the Bluetooth SIG-defined UUID for the Generic Attribute Service.
 */
static genericAttribute: string;

/**
 * Gets the Bluetooth SIG-defined Glucose Service UUID.
 */
static glucose: string;

/**
 * Gets the Bluetooth SIG-defined Health Thermometer Service UUID.
 */
static healthThermometer: string;

/**
 * Gets the Bluetooth SIG-defined Heart Rate Service UUID.
 */
static heartRate: string;

/**
 * Gets the Bluetooth SIG-defined HumanInterfaceDevice service UUID.
 */
static humanInterfaceDevice: string;

/**
 * Gets the Bluetooth SIG-defined ImmediateAlert service UUID.
 */
static immediateAlert: string;

/**
 * Gets the Bluetooth SIG-defined LinkLoss service UUID.
 */
static linkLoss: string;

/**
 * Gets the Bluetooth SIG-defined LocationAndNavigation service UUID.
 */
static locationAndNavigation: string;

/**
 * Gets the Bluetooth SIG-defined NextDstChange service UUID.
 */
static nextDstChange: string;

/**
 * Gets the Bluetooth SIG-defined PhoneAlertStatus service UUID.
 */
static phoneAlertStatus: string;

/**
 * Gets the Bluetooth SIG-defined ReferenceTimeUpdate service UUID.
 */
static referenceTimeUpdate: string;

/**
 * Gets the Bluetooth SIG-defined Running Speed And Cadence Service UUID.
 */
static runningSpeedAndCadence: string;

/**
 * Gets the Bluetooth SIG-defined ScanParameters service UUID.
 */
static scanParameters: string;

/**
 * Gets the Bluetooth SIG-defined TxPower service UUID.
 */
static txPower: string
}


/**
 * Represents the value received when registering to receive notifications or indications from a Bluetooth LE device.
 */
declare class Windows$Devices$Bluetooth$GenericAttributeProfile$GattValueChangedEventArgs  {

/**
 * Gets the new Characteristic Value.
 */
characteristicValue: Windows$Storage$Streams$IBuffer;

/**
 * Gets the time at which the system was notified of the Characteristic Value change.
 */
timestamp: Date
}


/**
 * Indicates what type of write operation is to be performed.
 */

declare  var Windows$Devices$Bluetooth$GenericAttributeProfile$GattWriteOption: {|
  +writeWithResponse: 0,// 0
+writeWithoutResponse: 1,// 1

|};



      declare var npm$namespace$Windows$Devices$Bluetooth$Rfcomm: {
        
        
        
        RfcommDeviceService: typeof Windows$Devices$Bluetooth$Rfcomm$RfcommDeviceService,
RfcommServiceId: typeof Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId,
RfcommServiceProvider: typeof Windows$Devices$Bluetooth$Rfcomm$RfcommServiceProvider,
        
      }

/**
 * Represents an instance of a service on a Bluetooth BR device.
 */
declare class Windows$Devices$Bluetooth$Rfcomm$RfcommDeviceService  {

/**
 * Gets an RfcommDeviceService object from a DeviceInformation Id for an RFCOMM service instance.
 * @param deviceId The DeviceInformation Id that identifies the RFCOMM service instance. This id can be retrieved from Windows.Devices.Enumeration .
 * @return The RfcommDeviceService object that represents the RFCOMM service instance.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Bluetooth$Rfcomm$RfcommDeviceService>;

/**
 * Gets an Advanced Query Syntax (AQS) string for identifying instances of an RFCOMM service. This string is passed to the CreateWatcher method.
 * @param serviceId The service id for which to query.
 * @return An AQS string for identifying RFCOMM service instances.
 */
static getDeviceSelector(serviceId: Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId): string;

/**
 * Closes the RFCOMM device.
 */
close(): void;

/**
 * Gets the connection host name of the RFCOMM service instance, which is used to connect to the remote device.
 */
connectionHostName: Windows$Networking$HostName;

/**
 * Gets the connection service name of the RFCOMM service instance, which is used to connect to the remote device.
 */
connectionServiceName: string;

/**
 * Gets the BluetoothDevice object describing the device associated with the current RfcommDeviceService object.
 */
device: Windows$Devices$Bluetooth$BluetoothDevice;

/**
 * Gets the cached SDP attributes of the RFCOMM service instance.
 * @return The SDP attributes of the RFCOMM service instance.
 */
getSdpRawAttributesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IMapView<any, any>>;

/**
 * Gets the SDP attributes of the RFCOMM service instance.
 * @param cacheMode Indicates whether SDP attributes should be retrieved from the cache or from the device.
 * @return The SDP attributes of the RFCOMM service instance.
 */
getSdpRawAttributesAsync(
cacheMode: $Values<typeof Windows$Devices$Bluetooth$BluetoothCacheMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IMapView<any, any>>;

/**
 * Gets the maximum SocketProtectionLevel supported by this RFCOMM service instance.
 */
maxProtectionLevel: $Values<typeof Windows$Networking$Sockets$SocketProtectionLevel>;

/**
 * Gets the current SocketProtectionLevel of the RFCOMM service instance.
 */
protectionLevel: $Values<typeof Windows$Networking$Sockets$SocketProtectionLevel>;

/**
 * Gets the RfcommServiceId of this RFCOMM service instance.
 */
serviceId: Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId
}


/**
 * Represents an RFCOMM service ID.
 */
declare class Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId  {

/**
 * Creates a RfcommServiceId object from a 32-bit service id.
 * @param shortId The 32-bit service id.
 * @return The RfcommServiceId object.
 */
static fromShortId(shortId: number): Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId;

/**
 * Creates a RfcommServiceId object from a 128-bit service id.
 * @param uuid The 128-bit service id.
 * @return The RfcommServiceId object.
 */
static fromUuid(uuid: string): Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId;

/**
 * Creates a RfcommServiceId object corresponding to the service id for the standardized Generic File Transfer service (with short id 0x1202).
 */
static genericFileTransfer: Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId;

/**
 * Creates a RfcommServiceId object corresponding to the service id for the standardized OBEX File Transfer service (with short id 0x1106).
 */
static obexFileTransfer: Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId;

/**
 * Creates a RfcommServiceId object corresponding to the service id for the standardized OBEX Object Push service (with short id 0x1105).
 */
static obexObjectPush: Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId;

/**
 * Creates a RfcommServiceId object corresponding to the service id for the standardized Phone Book Access (PCE) service (with short id 0x112E).
 */
static phoneBookAccessPce: Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId;

/**
 * Creates a RfcommServiceId object corresponding to the service id for the standardized Phone Book Access (PSE) service (with short id 0x112F).
 */
static phoneBookAccessPse: Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId;

/**
 * Creates a RfcommServiceId object corresponding to the service id for the standardized Serial Port service (with short id 0x1101).
 */
static serialPort: Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId;

/**
 * Converts the RfcommServiceId to a 32-bit service id if possible.
 * @return Returns the 32-bit service id if the RfcommServiceId represents a standardized service.
 */
asShortId(): number;

/**
 * Converts the RfcommServiceId to a string.
 * @return Returns the string representation of the 128-bit service id.
 */
asString(): string;

/**
 * Retrieves the 128-bit service id.
 */
uuid: string
}


/**
 * Represents an instance of a local RFCOMM service.
 */
declare class Windows$Devices$Bluetooth$Rfcomm$RfcommServiceProvider  {

/**
 * Gets a RfcommServiceProvider object from a DeviceInformation Id for a RFCOMM service instance.
 * @param serviceId The RfcommServiceId to be hosted locally.
 * @return The RfcommServiceProvider object that represents the local RFCOMM service instance.
 */
static createAsync(
serviceId: Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Bluetooth$Rfcomm$RfcommServiceProvider>;

/**
 * Gets a collection of SDP attributes for advertising.
 */
sdpRawAttributes: Windows$Foundation$Collections$IMap<number, Windows$Storage$Streams$IBuffer>;

/**
 * Gets the RfcommServiceId of this local RFCOMM service instance.
 */
serviceId: Windows$Devices$Bluetooth$Rfcomm$RfcommServiceId;

/**
 * Begins advertising the SDP attributes.
 * @param listener The StreamSocketListener that is listening for incoming connections.
 */
startAdvertising(listener: Windows$Networking$Sockets$StreamSocketListener): void;

/**
 * Begins advertising the SDP attributes.
 * @param listener The StreamSocketListener that is listening for incoming connections.
 * @param radioDiscoverable Indicates whether the radio is discoverable (true) or not (false).
 */
startAdvertising(
listener: Windows$Networking$Sockets$StreamSocketListener,
radioDiscoverable: boolean): void;

/**
 * Stops advertising the SDP attributes.
 */
stopAdvertising(): void
}


      declare var npm$namespace$Windows$Devices$Custom: {
        
        
        DeviceAccessMode: typeof Windows$Devices$Custom$DeviceAccessMode,
DeviceSharingMode: typeof Windows$Devices$Custom$DeviceSharingMode,
IOControlAccessMode: typeof Windows$Devices$Custom$IOControlAccessMode,
IOControlBufferingMethod: typeof Windows$Devices$Custom$IOControlBufferingMethod,
        CustomDevice: typeof Windows$Devices$Custom$CustomDevice,
IOControlCode: typeof Windows$Devices$Custom$IOControlCode,
KnownDeviceTypes: typeof Windows$Devices$Custom$KnownDeviceTypes,
        
      }

/**
 * Represents a custom device.
 */
declare class Windows$Devices$Custom$CustomDevice  {

/**
 * Creates a CustomDevice object asynchronously for the specified DeviceInformation.Id .
 * @param deviceId The DeviceInformation.Id of the device .
 * @param desiredAccess The desired access.
 * @param sharingMode The sharing mode.
 * @return Returns a custom device.
 */
static fromIdAsync(
deviceId: string,
desiredAccess: $Values<typeof Windows$Devices$Custom$DeviceAccessMode>,
sharingMode: $Values<typeof Windows$Devices$Custom$DeviceSharingMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Custom$CustomDevice>;

/**
 * Gets a device selector.
 * @param classGuid The Device Interface Class GUID of the device interface to create a device selector for.
 * @return The device selector.
 */
static getDeviceSelector(classGuid: string): string;

/**
 * The input stream.
 */
inputStream: Windows$Storage$Streams$IInputStream;

/**
 * The output stream.
 */
outputStream: Windows$Storage$Streams$IOutputStream;

/**
 * Sends an IO control code.
 * @param ioControlCode The IO control code.
 * @param inputBuffer The input buffer.
 * @param outputBuffer The output buffer.
 * @return The result of the async operation.
 */
sendIOControlAsync(
ioControlCode: Windows$Devices$Custom$IIOControlCode,
inputBuffer: Windows$Storage$Streams$IBuffer,
outputBuffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * Sends an IO control code. A return value indicates whether the operation succeeded.
 * @param ioControlCode The IO control code.
 * @param inputBuffer The input buffer.
 * @param outputBuffer The output buffer.
 * @return true if the operation is successful; otherwise, false.
 */
trySendIOControlAsync(
ioControlCode: Windows$Devices$Custom$IIOControlCode,
inputBuffer: Windows$Storage$Streams$IBuffer,
outputBuffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>
}


/**
 * The device access mode.
 */

declare  var Windows$Devices$Custom$DeviceAccessMode: {|
  +read: 0,// 0
+write: 1,// 1
+readWrite: 2,// 2

|};



/**
 * The device sharing mode.
 */

declare  var Windows$Devices$Custom$DeviceSharingMode: {|
  +shared: 0,// 0
+exclusive: 1,// 1

|};



/**
 * Identifies the access mode.
 */

declare  var Windows$Devices$Custom$IOControlAccessMode: {|
  +any: 0,// 0
+read: 1,// 1
+write: 2,// 2
+readWrite: 3,// 3

|};



/**
 * Identifies the buffering method.
 */

declare  var Windows$Devices$Custom$IOControlBufferingMethod: {|
  +buffered: 0,// 0
+directInput: 1,// 1
+directOutput: 2,// 2
+neither: 3,// 3

|};



/**
 * Represents the control code.
 */
declare class Windows$Devices$Custom$IOControlCode  {

/**
 * The control code.
 * @param deviceType The device type.
 * @param function The device function.
 * @param accessMode The access mode.
 * @param bufferingMethod The buffering method.
 */
constructor(deviceType: number, func: number, accessMode: $Values<typeof Windows$Devices$Custom$IOControlAccessMode>, bufferingMethod: $Values<typeof Windows$Devices$Custom$IOControlBufferingMethod>): this;

/**
 * The access mode.
 */
accessMode: $Values<typeof Windows$Devices$Custom$IOControlAccessMode>;

/**
 * The buffering method.
 */
bufferingMethod: $Values<typeof Windows$Devices$Custom$IOControlBufferingMethod>;

/**
 * The control code.
 */
controlCode: number;

/**
 * The device type.
 */
deviceType: number;

/**
 * The function.
 */
function: number
}


/**
 * Represents know device types.
 */
declare class Windows$Devices$Custom$KnownDeviceTypes  {

/**
 * Defined by the device vendor.
 */
static unknown: number
}


/**
 * Represents IO control code.
 */
declare interface Windows$Devices$Custom$IIOControlCode {

/**
 * The access mode.
 */
accessMode: $Values<typeof Windows$Devices$Custom$IOControlAccessMode>,

/**
 * The buffering method.
 */
bufferingMethod: $Values<typeof Windows$Devices$Custom$IOControlBufferingMethod>,

/**
 * The control code.
 */
controlCode: number,

/**
 * The device type.
 */
deviceType: number,

/**
 * The function.
 */
function: number
} 


      declare var npm$namespace$Windows$Devices$Enumeration: {
        
        
        DeviceAccessStatus: typeof Windows$Devices$Enumeration$DeviceAccessStatus,
DeviceClass: typeof Windows$Devices$Enumeration$DeviceClass,
DeviceInformationKind: typeof Windows$Devices$Enumeration$DeviceInformationKind,
DevicePairingKinds: typeof Windows$Devices$Enumeration$DevicePairingKinds,
DevicePairingProtectionLevel: typeof Windows$Devices$Enumeration$DevicePairingProtectionLevel,
DevicePairingResultStatus: typeof Windows$Devices$Enumeration$DevicePairingResultStatus,
DevicePickerDisplayStatusOptions: typeof Windows$Devices$Enumeration$DevicePickerDisplayStatusOptions,
DeviceUnpairingResultStatus: typeof Windows$Devices$Enumeration$DeviceUnpairingResultStatus,
DeviceWatcherEventKind: typeof Windows$Devices$Enumeration$DeviceWatcherEventKind,
DeviceWatcherStatus: typeof Windows$Devices$Enumeration$DeviceWatcherStatus,
Panel: typeof Windows$Devices$Enumeration$Panel,
        DeviceAccessChangedEventArgs: typeof Windows$Devices$Enumeration$DeviceAccessChangedEventArgs,
DeviceAccessInformation: typeof Windows$Devices$Enumeration$DeviceAccessInformation,
DeviceConnectionChangeTriggerDetails: typeof Windows$Devices$Enumeration$DeviceConnectionChangeTriggerDetails,
DeviceDisconnectButtonClickedEventArgs: typeof Windows$Devices$Enumeration$DeviceDisconnectButtonClickedEventArgs,
DeviceInformation: typeof Windows$Devices$Enumeration$DeviceInformation,
DeviceInformationCollection: typeof Windows$Devices$Enumeration$DeviceInformationCollection,
DeviceInformationCustomPairing: typeof Windows$Devices$Enumeration$DeviceInformationCustomPairing,
DeviceInformationPairing: typeof Windows$Devices$Enumeration$DeviceInformationPairing,
DeviceInformationUpdate: typeof Windows$Devices$Enumeration$DeviceInformationUpdate,
DevicePairingRequestedEventArgs: typeof Windows$Devices$Enumeration$DevicePairingRequestedEventArgs,
DevicePairingResult: typeof Windows$Devices$Enumeration$DevicePairingResult,
DevicePicker: typeof Windows$Devices$Enumeration$DevicePicker,
DevicePickerAppearance: typeof Windows$Devices$Enumeration$DevicePickerAppearance,
DevicePickerFilter: typeof Windows$Devices$Enumeration$DevicePickerFilter,
DeviceSelectedEventArgs: typeof Windows$Devices$Enumeration$DeviceSelectedEventArgs,
DeviceThumbnail: typeof Windows$Devices$Enumeration$DeviceThumbnail,
DeviceUnpairingResult: typeof Windows$Devices$Enumeration$DeviceUnpairingResult,
DeviceWatcher: typeof Windows$Devices$Enumeration$DeviceWatcher,
DeviceWatcherEvent: typeof Windows$Devices$Enumeration$DeviceWatcherEvent,
DeviceWatcherTriggerDetails: typeof Windows$Devices$Enumeration$DeviceWatcherTriggerDetails,
EnclosureLocation: typeof Windows$Devices$Enumeration$EnclosureLocation,
        Pnp: typeof npm$namespace$Windows$Devices$Enumeration$Pnp,
      }

/**
 * Provides data for the AccessChanged event.
 */
declare class Windows$Devices$Enumeration$DeviceAccessChangedEventArgs  {

/**
 * The new status of access to a device.
 */
status: $Values<typeof Windows$Devices$Enumeration$DeviceAccessStatus>
}


/**
 * Contains the information about access to a device.
 */
declare class Windows$Devices$Enumeration$DeviceAccessInformation  {

/**
 * Initializes a DeviceAccessInformation object based on a given DeviceClass .
 * @param deviceClass Device class to get DeviceAccessInformation about.
 * @return The DeviceAccessInformation object for the given DeviceClass .
 */
static createFromDeviceClass(
deviceClass: $Values<typeof Windows$Devices$Enumeration$DeviceClass>): Windows$Devices$Enumeration$DeviceAccessInformation;

/**
 * Initializes a DeviceAccessInformation object based on a device class id.
 * @param deviceClassId Id of the device class to get DeviceAccessInformation about.
 * @return The DeviceAccessInformation object for the given device class id.
 */
static createFromDeviceClassId(deviceClassId: string): Windows$Devices$Enumeration$DeviceAccessInformation;

/**
 * Initializes a DeviceAccessInformation object based on a device id.
 * @param deviceId Id of the device to get DeviceAccessInformation about.
 * @return The DeviceAccessInformation object for the given device id.
 */
static createFromId(deviceId: string): Windows$Devices$Enumeration$DeviceAccessInformation;

/**
 * The current device access status.
 */
currentStatus: $Values<typeof Windows$Devices$Enumeration$DeviceAccessStatus>;

/**
 * Raised when access to a device has changed.
 */
onaccesschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceAccessInformation, Windows$Devices$Enumeration$DeviceAccessChangedEventArgs>;
addEventListener(
type: "accesschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceAccessInformation, Windows$Devices$Enumeration$DeviceAccessChangedEventArgs>): void;
removeEventListener(
type: "accesschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceAccessInformation, Windows$Devices$Enumeration$DeviceAccessChangedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Indicates the status of the access to a device.
 */

declare  var Windows$Devices$Enumeration$DeviceAccessStatus: {|
  +unspecified: 0,// 0
+allowed: 1,// 1
+deniedByUser: 2,// 2
+deniedBySystem: 3,// 3

|};



/**
 * Indicates the type of devices that the user wants to enumerate.
 */

declare  var Windows$Devices$Enumeration$DeviceClass: {|
  +all: 0,// 0
+audioCapture: 1,// 1
+audioRender: 2,// 2
+portableStorageDevice: 3,// 3
+videoCapture: 4,// 4
+imageScanner: 5,// 5
+location: 6,// 6

|};



/**
 * Provides information about the device that caused this trigger to fire.
 */
declare class Windows$Devices$Enumeration$DeviceConnectionChangeTriggerDetails  {

/**
 * Gets the device Id of the device that caused this trigger to fire.
 */
deviceId: string
}


/**
 * Provides data for the DisconnectButtonClicked event on the DevicePicker object.
 */
declare class Windows$Devices$Enumeration$DeviceDisconnectButtonClickedEventArgs  {

/**
 * The device that the user clicked the disconnect button for.
 */
device: Windows$Devices$Enumeration$DeviceInformation
}


/**
 * Represents a device. This class allows access to well-known device properties as well as additional properties specified during device enumeration.
 */
declare class Windows$Devices$Enumeration$DeviceInformation  {

/**
 * Creates a DeviceInformation object from a DeviceInformation ID and a list of additional properties.
 * @param deviceId A string containing the DeviceInformation ID.
 * @param additionalProperties An iterable list of additional properties to include in the Properties property of the DeviceInformation objects in the enumeration results. For more info on what the properties represent, see Device information properties.
 * @return An object for starting and managing the asynchronous creation of the DeviceInformation object.
 */
static createFromIdAsync(
deviceId: string,
additionalProperties: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DeviceInformation>;

/**
 * Creates a DeviceInformation object from a DeviceInformation ID.
 * @param deviceId The device ID.
 * @return An object for starting and managing the asynchronous creation of the DeviceInformation object.
 */
static createFromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DeviceInformation>;

/**
 * Creates a DeviceInformation object from a DeviceInformation ID, a list of additional properties, and a DeviceInformationKind parameter.
 * @param deviceId A string containing the DeviceInformation ID.
 * @param additionalProperties An iterable list of additional properties to include in the Properties property of the DeviceInformation objects in the enumeration results. For more info on what the properties represent, see Device information properties.
 * @param kind The type of DeviceInformation object you want to create.
 * @return An object for starting and managing the asynchronous creation of the DeviceInformation object.
 */
static createFromIdAsync(
deviceId: string,
additionalProperties: Windows$Foundation$Collections$IIterable<string>,
kind: $Values<typeof Windows$Devices$Enumeration$DeviceInformationKind>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DeviceInformation>;

/**
 * Creates a DeviceWatcher for all devices.
 * @return The created DeviceWatcher .
 */
static createWatcher(): Windows$Devices$Enumeration$DeviceWatcher;

/**
 * Creates a DeviceWatcher for devices matching the specified Advanced Query Syntax (AQS) string and the specified collection of properties.
 * @param aqsFilter An AQS string that filters the DeviceInformation objects to enumerate. Typically this string is retrieved from the GetDeviceSelector method of a class that interacts with devices. For example, GetDeviceSelector retrieves the string for the StorageDevice class.
 * @param additionalProperties An iterable list of additional properties to include in the Properties property of the DeviceInformation objects in the enumeration results. For more info on what the properties represent, see Device information properties.
 * @return The created DeviceWatcher .
 */
static createWatcher(
aqsFilter: string,
additionalProperties: Windows$Foundation$Collections$IIterable<string>): Windows$Devices$Enumeration$DeviceWatcher;

/**
 * Creates a DeviceWatcher for devices matching the specified Advanced Query Syntax (AQS) string.
 * @param aqsFilter An AQS string that filters the DeviceInformation objects to enumerate. Typically this string is retrieved from the GetDeviceSelector method of a class that interacts with devices. For example, GetDeviceSelector retrieves the string for the StorageDevice class.
 * @return The created DeviceWatcher .
 */
static createWatcher(aqsFilter: string): Windows$Devices$Enumeration$DeviceWatcher;

/**
 * Creates a DeviceWatcher for devices matching the specified DeviceClass .
 * @param deviceClass The class of device to enumerate using the DeviceWatcher .
 * @return The created DeviceWatcher .
 */
static createWatcher(
deviceClass: $Values<typeof Windows$Devices$Enumeration$DeviceClass>): Windows$Devices$Enumeration$DeviceWatcher;

/**
 * Creates a DeviceWatcher for devices matching the specified Advanced Query Syntax (AQS) string, the specified collection of properties, and the kind of devices.
 * @param aqsFilter An AQS string that filters the DeviceInformation objects to enumerate. Typically this string is retrieved from the GetDeviceSelector method of a class that interacts with devices. For example, GetDeviceSelector retrieves the string for the StorageDevice class.
 * @param additionalProperties An iterable list of additional properties to include in the Properties property of the DeviceInformation objects in the enumeration results. For more info on what the properties represent, see Device information properties.
 * @param kind The specific types of devices the DeviceWatcher is interested in.
 * @return The created DeviceWatcher .
 */
static createWatcher(
aqsFilter: string,
additionalProperties: Windows$Foundation$Collections$IIterable<string>,
kind: $Values<typeof Windows$Devices$Enumeration$DeviceInformationKind>): Windows$Devices$Enumeration$DeviceWatcher;

/**
 * Enumerates DeviceInformation objects matching the specified Advanced Query Syntax (AQS) string and including the specified collection of properties.
 * @param aqsFilter An AQS string that filters the DeviceInformation objects to enumerate. Typically this string is retrieved from the GetDeviceSelector method of a class that interacts with devices. For example, GetDeviceSelector retrieves the string for the StorageDevice class.
 * @param additionalProperties An iterable list of additional properties to include in the Properties property of the DeviceInformation objects in the enumeration results. For more info on what the properties represent, see Device information properties.
 * @return The object for managing the asynchronous operation.
 */
static findAllAsync(
aqsFilter: string,
additionalProperties: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DeviceInformationCollection>;

/**
 * Enumerates DeviceInformation objects of the specified class.
 * @param deviceClass The class of devices to enumerate.
 * @return The object for managing the asynchronous operation.
 */
static findAllAsync(
deviceClass: $Values<typeof Windows$Devices$Enumeration$DeviceClass>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DeviceInformationCollection>;

/**
 * Enumerates DeviceInformation objects matching the specified Advanced Query Syntax (AQS) string.
 * @param aqsFilter An AQS string that filters the DeviceInformation objects to enumerate. Typically this string is retrieved from the GetDeviceSelector method of a class that interacts with devices. For example, GetDeviceSelector retrieves the string for the StorageDevice class.
 * @return The object for managing the asynchronous operation.
 */
static findAllAsync(
aqsFilter: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DeviceInformationCollection>;

/**
 * Enumerates all DeviceInformation objects.
 * @return The object for managing the asynchronous operation.
 */
static findAllAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DeviceInformationCollection>;

/**
 * Enumerates DeviceInformation objects matching the specified Advanced Query Syntax (AQS) string, the device kind, and including the specified collection of properties.
 * @param aqsFilter An AQS string that filters the DeviceInformation objects to enumerate. Typically this string is retrieved from the GetDeviceSelector method of a class that interacts with devices. For example, GetDeviceSelector retrieves the string for the StorageDevice class.
 * @param additionalProperties An iterable list of additional properties to include in the Properties property of the DeviceInformation objects in the enumeration results. For more info on what the properties represent, see Device information properties.
 * @param kind The specific type of device to find.
 * @return The object for managing the asynchronous operation.
 */
static findAllAsync(
aqsFilter: string,
additionalProperties: Windows$Foundation$Collections$IIterable<string>,
kind: $Values<typeof Windows$Devices$Enumeration$DeviceInformationKind>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DeviceInformationCollection>;

/**
 * Creates a filter to use to enumerate through a subset of device types.
 * @param deviceClass The type of devices that you want to create a filter for.
 * @return The Advanced Query Syntax (AQS) filter used to specifically enumerate through the device type specified by deviceClass.
 */
static getAqsFilterFromDeviceClass(deviceClass: $Values<typeof Windows$Devices$Enumeration$DeviceClass>): string;

/**
 * The physical location of the device in its enclosure. For example, it may describe the location of a webcam inside a laptop.
 */
enclosureLocation: Windows$Devices$Enumeration$EnclosureLocation;

/**
 * Gets a glyph for the device.
 * @return The object for managing the asynchronous operation that will return a DeviceThumbnail
 */
getGlyphThumbnailAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DeviceThumbnail>;

/**
 * Returns a thumbnail image for the device.
 * @return The object for managing the asynchronous operation that will return a DeviceThumbnail .
 */
getThumbnailAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DeviceThumbnail>;

/**
 * A string representing the identity of the device.
 */
id: string;

/**
 * Indicates whether this device is the default device for the class.
 */
isDefault: boolean;

/**
 * Indicates whether this device is enabled.
 */
isEnabled: boolean;

/**
 * Gets the type of DeviceInformation represented by this object.
 */
kind: $Values<typeof Windows$Devices$Enumeration$DeviceInformationKind>;

/**
 * The name of the device. This name is in the best available language for the app.
 */
name: string;

/**
 * Gets the information about the capabilities for this device to pair.
 */
pairing: Windows$Devices$Enumeration$DeviceInformationPairing;

/**
 * Property store containing well-known values as well as additional properties that can be specified during device enumeration.
 */
properties: Windows$Foundation$Collections$IMapView<string, any>;

/**
 * Updates the properties of an existing DeviceInformation object.
 * @param updateInfo Indicates the properties to update.
 */
update(updateInfo: Windows$Devices$Enumeration$DeviceInformationUpdate): void
}


/**
 * Represents a collection of DeviceInformation objects.
 */
declare class Windows$Devices$Enumeration$DeviceInformationCollection mixins Array<Windows$Devices$Enumeration$DeviceInformation> {

/**
 * Gets an object that can iterate through the enumerated DeviceInformation objects, starting with the first.
 * @return An object that can iterate through the enumerated devices, starting with the first.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Devices$Enumeration$DeviceInformation>;

/**
 * Gets the DeviceInformation object at the specified index.
 * @param index The index.
 * @return The DeviceInformation object at the specified index.
 */
getAt(index: number): Windows$Devices$Enumeration$DeviceInformation;

/**
 * Gets a range of DeviceInformation objects.
 * @param startIndex The index at which to start retrieving DeviceInformation objects.
 */
getMany(
startIndex: number): {
items: Windows$Devices$Enumeration$DeviceInformation,
returnValue: number
};

/**
 * Returns the index of the specified DeviceInformation object in the collection.
 * @param value The DeviceInformation object in the collection.
 */
indexOf(
value: Windows$Devices$Enumeration$DeviceInformation): {
index: number,
returnValue: boolean
};

/**
 * The number of DeviceInformation objects in the collection.
 */
size: number;
indexOf(
value: Windows$Devices$Enumeration$DeviceInformation,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Devices$Enumeration$DeviceInformation,
fromIndex?: number): number
}


/**
 * Represents a custom pairing for a DeviceInformation object.
 */
declare class Windows$Devices$Enumeration$DeviceInformationCustomPairing  {

/**
 * Raised when a pairing action is requested.
 */
onpairingrequested: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceInformationCustomPairing, Windows$Devices$Enumeration$DevicePairingRequestedEventArgs>;
addEventListener(
type: "pairingrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceInformationCustomPairing, Windows$Devices$Enumeration$DevicePairingRequestedEventArgs>): void;
removeEventListener(
type: "pairingrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceInformationCustomPairing, Windows$Devices$Enumeration$DevicePairingRequestedEventArgs>): void;

/**
 * Attempts to pair the device.
 * @param pairingKindsSupported The different pairing kinds supported by this DeviceInformation object.
 * @return The result of the pairing action.
 */
pairAsync(
pairingKindsSupported: $Values<typeof Windows$Devices$Enumeration$DevicePairingKinds>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DevicePairingResult>;

/**
 * Attempts to pair a device using a minimum protection level and custom settings.
 * @param pairingKindsSupported The different pairing kinds supported by this DeviceInformation object.
 * @param minProtectionLevel The minimum protection level this DeviceInformation object requires in order to pair.
 * @param devicePairingSettings The custom device pairing settings.
 * @return The result of the pairing action.
 */
pairAsync(
pairingKindsSupported: $Values<typeof Windows$Devices$Enumeration$DevicePairingKinds>,
minProtectionLevel: $Values<typeof Windows$Devices$Enumeration$DevicePairingProtectionLevel>,
devicePairingSettings: Windows$Devices$Enumeration$IDevicePairingSettings): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DevicePairingResult>;

/**
 * Attempts to pair a device using a minimum protection level.
 * @param pairingKindsSupported The different pairing kinds supported by this DeviceInformation object.
 * @param minProtectionLevel The minimum protection level this DeviceInformation object requires in order to pair.
 * @return The result of the pairing action.
 */
pairAsync(
pairingKindsSupported: $Values<typeof Windows$Devices$Enumeration$DevicePairingKinds>,
minProtectionLevel: $Values<typeof Windows$Devices$Enumeration$DevicePairingProtectionLevel>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DevicePairingResult>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the kind of DeviceInformation object.
 */

declare  var Windows$Devices$Enumeration$DeviceInformationKind: {|
  +unknown: 0,// 0
+deviceInterface: 1,// 1
+deviceContainer: 2,// 2
+device: 3,// 3
+deviceInterfaceClass: 4,// 4
+associationEndpoint: 5,// 5
+associationEndpointContainer: 6,// 6
+associationEndpointService: 7,// 7

|};



/**
 * Contains information and enables pairing for a device.
 */
declare class Windows$Devices$Enumeration$DeviceInformationPairing  {

/**
 * Attempts to pair for all inbound pairing requests
 * @param pairingKindsSupported The pairing kinds this device supports.
 * @return Whether or not the attempt was successful.
 */
static tryRegisterForAllInboundPairingRequests(
pairingKindsSupported: $Values<typeof Windows$Devices$Enumeration$DevicePairingKinds>): boolean;

/**
 * Gets a value that indicates whether the device can be paired.
 */
canPair: boolean;

/**
 * Gets the DeviceInformationCustomPairing object necessary for custom pairing.
 */
custom: Windows$Devices$Enumeration$DeviceInformationCustomPairing;

/**
 * Gets a value that indicates whether the device is currently paired.
 */
isPaired: boolean;

/**
 * Attempts to pair the device.
 * @return The result of the pairing action.
 */
pairAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DevicePairingResult>;

/**
 * Attempts to pair the device using a provided level of protection.
 * @param minProtectionLevel The required level of protection to use for the pairing action.
 * @return The result of the pairing action.
 */
pairAsync(
minProtectionLevel: $Values<typeof Windows$Devices$Enumeration$DevicePairingProtectionLevel>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DevicePairingResult>;

/**
 * Attempts to pair a device object with a specified protection level and custom settings.
 * @param minProtectionLevel The required level of protection to use for the pairing action.
 * @param devicePairingSettings The custom device pairing settings.
 * @return The result of the pairing action.
 */
pairAsync(
minProtectionLevel: $Values<typeof Windows$Devices$Enumeration$DevicePairingProtectionLevel>,
devicePairingSettings: Windows$Devices$Enumeration$IDevicePairingSettings): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DevicePairingResult>;

/**
 * Gets the level of protection used to pair the device.
 */
protectionLevel: $Values<typeof Windows$Devices$Enumeration$DevicePairingProtectionLevel>;

/**
 * Attempts to unpair the device.
 * @return The result of the unpairing action.
 */
unpairAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DeviceUnpairingResult>
}


/**
 * Contains updated properties for a DeviceInformation object.
 */
declare class Windows$Devices$Enumeration$DeviceInformationUpdate  {

/**
 * The DeviceInformation ID of the updated device.
 */
id: string;

/**
 * Gets the type of device for the updated device.
 */
kind: $Values<typeof Windows$Devices$Enumeration$DeviceInformationKind>;

/**
 * The changed properties in a update to a DeviceInformation object.
 */
properties: Windows$Foundation$Collections$IMapView<string, any>
}


/**
 * Indicates the action the user will need to take in order to complete the pairing or unpairing action.
 */

declare  var Windows$Devices$Enumeration$DevicePairingKinds: {|
  +none: 0,// 0
+confirmOnly: 1,// 1
+displayPin: 2,// 2
+providePin: 3,// 3
+confirmPinMatch: 4,// 4

|};



/**
 * The level of protection for pairing.
 */

declare  var Windows$Devices$Enumeration$DevicePairingProtectionLevel: {|
  +default: 0,// 0
+none: 1,// 1
+encryption: 2,// 2
+encryptionAndAuthentication: 3,// 3

|};



/**
 * Provides data for the PairingRequested event.
 */
declare class Windows$Devices$Enumeration$DevicePairingRequestedEventArgs  {

/**
 * Accepts a PairingRequested event and pairs the device with the application.
 */
accept(): void;

/**
 * Accepts a PairingRequested event and pairs the device with the application. Requires a pin for pairing purposes.
 * @param pin The pin to use for attempting to pair a device.
 */
accept(pin: string): void;

/**
 * Gets the DeviceInformation object associated with this pairing request.
 */
deviceInformation: Windows$Devices$Enumeration$DeviceInformation;

/**
 * Requests a Deferral to support asynchronous operations.
 * @return The deferral necessary to support asynchronous actions.
 */
getDeferral(): Windows$Foundation$Deferral;

/**
 * Gets the kind of pairing associated with this pairing event.
 */
pairingKind: $Values<typeof Windows$Devices$Enumeration$DevicePairingKinds>;

/**
 * Gets the pin associated with a pairing request.
 */
pin: string
}


/**
 * Contains information about the result of attempting to pair a device.
 */
declare class Windows$Devices$Enumeration$DevicePairingResult  {

/**
 * Gets the level of protection used to pair the device.
 */
protectionLevelUsed: $Values<typeof Windows$Devices$Enumeration$DevicePairingProtectionLevel>;

/**
 * Gets the paired status of the device after the pairing action completed.
 */
status: $Values<typeof Windows$Devices$Enumeration$DevicePairingResultStatus>
}


/**
 * The result of the pairing action with an Association Endpoint (AEP) device object. For more information about AEP objects, see DeviceInformationKind .
 */

declare  var Windows$Devices$Enumeration$DevicePairingResultStatus: {|
  +paired: 0,// 0
+notReadyToPair: 1,// 1
+notPaired: 2,// 2
+alreadyPaired: 3,// 3
+connectionRejected: 4,// 4
+tooManyConnections: 5,// 5
+hardwareFailure: 6,// 6
+authenticationTimeout: 7,// 7
+authenticationNotAllowed: 8,// 8
+authenticationFailure: 9,// 9
+noSupportedProfiles: 10,// 10
+protectionLevelCouldNotBeMet: 11,// 11
+accessDenied: 12,// 12
+invalidCeremonyData: 13,// 13
+pairingCanceled: 14,// 14
+operationAlreadyInProgress: 15,// 15
+requiredHandlerNotRegistered: 16,// 16
+rejectedByHandler: 17,// 17
+remoteDeviceHasAssociation: 18,// 18
+failed: 19,// 19

|};



/**
 * Represents a picker flyout that contains a list of devices for the user to choose from.
 */
declare class Windows$Devices$Enumeration$DevicePicker  {

/**
 * Creates a DevicePicker object.
 */
constructor(): this;

/**
 * Gets the colors of the picker.
 */
appearance: Windows$Devices$Enumeration$DevicePickerAppearance;

/**
 * Gets the filter used to choose what devices to show in the picker.
 */
filter: Windows$Devices$Enumeration$DevicePickerFilter;

/**
 * Hides the picker.
 */
hide(): void;

/**
 * Indicates that the device picker was light dismissed by the user. Light dismiss happens when the user clicks somewhere other than the picker UI and the picker UI disappears.
 */
ondevicepickerdismissed: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DevicePicker, any>;
addEventListener(
type: "devicepickerdismissed",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DevicePicker, any>): void;
removeEventListener(
type: "devicepickerdismissed",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DevicePicker, any>): void;

/**
 * Indicates that the user selected a device in the picker.
 */
ondeviceselected: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DevicePicker, Windows$Devices$Enumeration$DeviceSelectedEventArgs>;
addEventListener(
type: "deviceselected",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DevicePicker, Windows$Devices$Enumeration$DeviceSelectedEventArgs>): void;
removeEventListener(
type: "deviceselected",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DevicePicker, Windows$Devices$Enumeration$DeviceSelectedEventArgs>): void;

/**
 * Indicates that the user clicked or tapped the disconnect button for a device in the picker.
 */
ondisconnectbuttonclicked: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DevicePicker, Windows$Devices$Enumeration$DeviceDisconnectButtonClickedEventArgs>;
addEventListener(
type: "disconnectbuttonclicked",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DevicePicker, Windows$Devices$Enumeration$DeviceDisconnectButtonClickedEventArgs>): void;
removeEventListener(
type: "disconnectbuttonclicked",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DevicePicker, Windows$Devices$Enumeration$DeviceDisconnectButtonClickedEventArgs>): void;

/**
 * Shows the picker UI and returns the selected device; does not require you to register for an event. The picker flies out from the specified edge of the specified rectangle.
 * @param selection The rectangle from which you want the picker to fly out.
 * @param placement The edge of the rectangle from which you want the picker to fly out.
 * @return The device selected.
 */
pickSingleDeviceAsync(
selection: Windows$Foundation$Rect,
placement: $Values<typeof Windows$UI$Popups$Placement>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DeviceInformation>;

/**
 * Shows the picker UI and returns the selected device; does not require you to register for an event. The picker flies out from the edge of the specified rectangle.
 * @param selection The rectangle from which you want the picker to fly out.
 * @return The device selected by the user.
 */
pickSingleDeviceAsync(
selection: Windows$Foundation$Rect): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$DeviceInformation>;

/**
 * Gets a collection of properties for the returned device information object.
 */
requestedProperties: Windows$Foundation$Collections$IVector<string>;

/**
 * Updates the picker UI to reflect the provided status and display options for a specified device.
 * @param device The device information.
 * @param status The status to display.
 * @param options The display options for the device.
 */
setDisplayStatus(
device: Windows$Devices$Enumeration$DeviceInformation,
status: string,
options: $Values<typeof Windows$Devices$Enumeration$DevicePickerDisplayStatusOptions>): void;

/**
 * Shows the picker UI. The picker flies out from the specified edge of the specified rectangle.
 * @param selection The rectangle from which you want the picker to fly out.
 * @param placement The edge of the rectangle from which you want the picker to fly out.
 */
show(
selection: Windows$Foundation$Rect,
placement: $Values<typeof Windows$UI$Popups$Placement>): void;

/**
 * Shows the picker UI. The picker flies out from the edge of the specified rectangle.
 * @param selection The rectangle from which you want the picker to fly out.
 */
show(selection: Windows$Foundation$Rect): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the appearance of a device picker.
 */
declare class Windows$Devices$Enumeration$DevicePickerAppearance  {

/**
 * Gets and sets the accent color of the picker UI.
 */
accentColor: Windows$UI$Color;

/**
 * Gets and sets the background color of the picker UI.
 */
backgroundColor: Windows$UI$Color;

/**
 * Gets and sets the foreground color of the picker UI.
 */
foregroundColor: Windows$UI$Color;

/**
 * Gets and sets the accent color for a device that has been selected in the picker.
 */
selectedAccentColor: Windows$UI$Color;

/**
 * Gets and sets the background color for a device that is selected in the picker.
 */
selectedBackgroundColor: Windows$UI$Color;

/**
 * Gets and sets the foreground color for a device that is selected in the picker.
 */
selectedForegroundColor: Windows$UI$Color;

/**
 * Gets and sets the title for the picker UI.
 */
title: string
}


/**
 * Indicates what you'd like the device picker to show about a given device. Used with the SetDisplayStatus method on the DevicePicker object.
 */

declare  var Windows$Devices$Enumeration$DevicePickerDisplayStatusOptions: {|
  +none: 0,// 0
+showProgress: 1,// 1
+showDisconnectButton: 2,// 2
+showRetryButton: 3,// 3

|};



/**
 * Represents the filter used to determine which devices to show in the device picker. The filter parameters are OR-ed together to build the resulting filter.
 */
declare class Windows$Devices$Enumeration$DevicePickerFilter  {

/**
 * Gets a list of supported device classes to show in the picker. This defaults to an empty list (no filter). You can add device classes to this vector and filter the devices list to those that are in one or more of the provided classes.
 */
supportedDeviceClasses: Windows$Foundation$Collections$IVector<$Values<typeof Windows$Devices$Enumeration$DeviceClass>>;

/**
 * Gets a list of AQS filter strings. This defaults to empty list (no filter). You can add one or more AQS filter strings to this vector and filter the devices list to those that meet one or more of the provided filters.
 */
supportedDeviceSelectors: Windows$Foundation$Collections$IVector<string>
}


/**
 * Provides data for the DeviceSelected event on the DevicePicker object.
 */
declare class Windows$Devices$Enumeration$DeviceSelectedEventArgs  {

/**
 * The device selected by the user in the picker.
 */
selectedDevice: Windows$Devices$Enumeration$DeviceInformation
}


/**
 * Represents the thumbnail image for a device.
 */
declare class Windows$Devices$Enumeration$DeviceThumbnail  {

/**
 * Gets a value that indicates whether the stream can be read from.
 */
canRead: boolean;

/**
 * Gets a value that indicates whether the stream can be written to.
 */
canWrite: boolean;

/**
 * Creates a new instance of a IRandomAccessStream over the same resource as the current stream.
 * @return The new stream. The initial, internal position of the stream is 0.
 */
cloneStream(): Windows$Storage$Streams$IRandomAccessStream;

/**
 * Closes the current stream and releases system resources.
 */
close(): void;

/**
 * Returns the content type of the thumbnail image.
 */
contentType: string;

/**
 * Flushes data asynchronously in a sequential stream.
 * @return The stream flush operation.
 */
flushAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Returns a pointer to an input stream starting at the specified location.
 * @param position The position in the input stream.
 * @return A pointer to an input stream.
 */
getInputStreamAt(position: number): Windows$Storage$Streams$IInputStream;

/**
 * Returns a pointer to an output stream starting at the specified location.
 * @param position The position in the output stream.
 * @return A pointer to an output stream.
 */
getOutputStreamAt(position: number): Windows$Storage$Streams$IOutputStream;

/**
 * Gets the byte offset of the stream.
 */
position: number;

/**
 * Returns an asynchronous byte reader object.
 * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param count The number of bytes to read.
 * @param options Specifies the type of the asynchronous read operation.
 * @return The asynchronous operation.
 */
readAsync(
buffer: Windows$Storage$Streams$IBuffer,
count: number,
options: $Values<typeof Windows$Storage$Streams$InputStreamOptions>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>;

/**
 * Sets the position of the stream to the specified value.
 * @param position The new position of the stream.
 */
seek(position: number): void;

/**
 * Gets or sets the size of the device thumbnail image.
 */
size: number;

/**
 * Writes data asynchronously in a sequential stream.
 * @param buffer The buffer into which the asynchronous writer operation writes.
 * @return The byte writer operation.
 */
writeAsync(
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Contains information about the result of attempting to unpair a device.
 */
declare class Windows$Devices$Enumeration$DeviceUnpairingResult  {

/**
 * Gets the paired status of the device after the unpairing action completed.
 */
status: $Values<typeof Windows$Devices$Enumeration$DeviceUnpairingResultStatus>
}


/**
 * The result of the unpairing action.
 */

declare  var Windows$Devices$Enumeration$DeviceUnpairingResultStatus: {|
  +unpaired: 0,// 0
+alreadyUnpaired: 1,// 1
+operationAlreadyInProgress: 2,// 2
+accessDenied: 3,// 3
+failed: 4,// 4

|};



/**
 * Enumerates devices dynamically, so that the app receives notifications if devices are added, removed, or changed after the initial enumeration is complete.
 */
declare class Windows$Devices$Enumeration$DeviceWatcher  {

/**
 * Gets a DeviceWatcherTrigger object monitoring for changes to the list of devices.
 * @param requestedEventKinds A list of the specific updates you want to monitor.
 * @return The watcher trigger to monitor for the specified changes.
 */
getBackgroundTrigger(
requestedEventKinds: Windows$Foundation$Collections$IIterable<$Values<typeof Windows$Devices$Enumeration$DeviceWatcherEventKind>>): Windows$ApplicationModel$Background$DeviceWatcherTrigger;

/**
 * Event that is raised when a device is added to the collection enumerated by the DeviceWatcher .
 */
onadded: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceWatcher, Windows$Devices$Enumeration$DeviceInformation>;
addEventListener(
type: "added",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceWatcher, Windows$Devices$Enumeration$DeviceInformation>): void;
removeEventListener(
type: "added",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceWatcher, Windows$Devices$Enumeration$DeviceInformation>): void;

/**
 * Event that is raised when the enumeration of devices completes.
 */
onenumerationcompleted: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceWatcher, any>;
addEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceWatcher, any>): void;
removeEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceWatcher, any>): void;

/**
 * Event that is raised when a device is removed from the collection of enumerated devices.
 */
onremoved: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceWatcher, Windows$Devices$Enumeration$DeviceInformationUpdate>;
addEventListener(
type: "removed",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceWatcher, Windows$Devices$Enumeration$DeviceInformationUpdate>): void;
removeEventListener(
type: "removed",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceWatcher, Windows$Devices$Enumeration$DeviceInformationUpdate>): void;

/**
 * Event that is raised when the enumeration operation has been stopped.
 */
onstopped: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceWatcher, any>;
addEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceWatcher, any>): void;
removeEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceWatcher, any>): void;

/**
 * Event that is raised when a device is updated in the collection of enumerated devices.
 */
onupdated: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceWatcher, Windows$Devices$Enumeration$DeviceInformationUpdate>;
addEventListener(
type: "updated",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceWatcher, Windows$Devices$Enumeration$DeviceInformationUpdate>): void;
removeEventListener(
type: "updated",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$DeviceWatcher, Windows$Devices$Enumeration$DeviceInformationUpdate>): void;

/**
 * Starts a search for devices, and subscribes to device enumeration events.
 */
start(): void;

/**
 * The status of the DeviceWatcher .
 */
status: $Values<typeof Windows$Devices$Enumeration$DeviceWatcherStatus>;

/**
 * Stop raising the events that add, update and remove enumeration results.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Triggered when the list of devices is updated after the initial enumeration is complete.
 */
declare class Windows$Devices$Enumeration$DeviceWatcherEvent  {

/**
 * Gets the information for the device associated with the DeviceWatcherEvent .
 */
deviceInformation: Windows$Devices$Enumeration$DeviceInformation;

/**
 * Gets updated information for a device updated by the DeviceWatcherEvent .
 */
deviceInformationUpdate: Windows$Devices$Enumeration$DeviceInformationUpdate;

/**
 * Gets the type for the device indicated by the DeviceWatcherEvent .
 */
kind: $Values<typeof Windows$Devices$Enumeration$DeviceWatcherEventKind>
}


/**
 * The type of event.
 */

declare  var Windows$Devices$Enumeration$DeviceWatcherEventKind: {|
  +add: 0,// 0
+update: 1,// 1
+remove: 2,// 2

|};



/**
 * Describes the state of a DeviceWatcher object.
 */

declare  var Windows$Devices$Enumeration$DeviceWatcherStatus: {|
  +created: 0,// 0
+started: 1,// 1
+enumerationCompleted: 2,// 2
+stopping: 3,// 3
+stopped: 4,// 4
+aborted: 5,// 5

|};



/**
 * Provides details about the device updates that invoked the trigger.
 */
declare class Windows$Devices$Enumeration$DeviceWatcherTriggerDetails  {

/**
 * Gets the events that activated the trigger.
 */
deviceWatcherEvents: Windows$Foundation$Collections$IVectorView<Windows$Devices$Enumeration$DeviceWatcherEvent>
}


/**
 * Describes the physical location of a device in its enclosure.
 */
declare class Windows$Devices$Enumeration$EnclosureLocation  {

/**
 * Indicates whether the device is physically located in the docking station of the portable computer.
 */
inDock: boolean;

/**
 * Indicates whether the device is physically located in the lid of the portable computer.
 */
inLid: boolean;

/**
 * Indicates which panel of the computer the device is physically located on.
 */
panel: $Values<typeof Windows$Devices$Enumeration$Panel>
}


/**
 * Indicates the location of a panel on a computer. This enumeration is used for indicating the physical location of a device.
 */

declare  var Windows$Devices$Enumeration$Panel: {|
  +unknown: 0,// 0
+front: 1,// 1
+back: 2,// 2
+top: 3,// 3
+bottom: 4,// 4
+left: 5,// 5
+right: 6,// 6

|};



      declare var npm$namespace$Windows$Devices$Enumeration$Pnp: {
        
        
        PnpObjectType: typeof Windows$Devices$Enumeration$Pnp$PnpObjectType,
        PnpObject: typeof Windows$Devices$Enumeration$Pnp$PnpObject,
PnpObjectCollection: typeof Windows$Devices$Enumeration$Pnp$PnpObjectCollection,
PnpObjectUpdate: typeof Windows$Devices$Enumeration$Pnp$PnpObjectUpdate,
PnpObjectWatcher: typeof Windows$Devices$Enumeration$Pnp$PnpObjectWatcher,
        
      }

/**
 * Represents a PnP object. This class allows access to well-known properties of a PnP object as well as a property store of additional properties that are specified to be retrieved from the the PnP object.
 */
declare class Windows$Devices$Enumeration$Pnp$PnpObject  {

/**
 * Creates a PnpObject object asynchronously from a previously saved DeviceInformation ID.
 * @param type The type of the PnpObject .
 * @param id The string value identifying the PnpObject .
 * @param requestedProperties An iterable list of additional properties to include in the Properties property of the PnpObject object to create. For more info on what the properties represent, see Device information properties.
 * @return The PnpObject created from the previously saved DeviceInformation ID.
 */
static createFromIdAsync(
type: $Values<typeof Windows$Devices$Enumeration$Pnp$PnpObjectType>,
id: string,
requestedProperties: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$Pnp$PnpObject>;

/**
 * Returns a PnpObjectWatcher object that is used to enumerate a filtered collection of PnP objects using events.
 * @param type The type of the PnpObject .
 * @param requestedProperties An iterable list of additional properties to include in the Properties property of the PnpObject objects included in enumeration results. For more info on what the properties represent, see Device information properties.
 * @param aqsFilter An AQS string that filters the PnP objects that will be returned. Typically, this string is retrieved from the GetDeviceSelector method of a class that interacts with devices.
 * @return A PnpObjectWatcher object used to enumerate the collection by registering event notification delegates and by issuing start and stop event notifications.
 */
static createWatcher(
type: $Values<typeof Windows$Devices$Enumeration$Pnp$PnpObjectType>,
requestedProperties: Windows$Foundation$Collections$IIterable<string>,
aqsFilter: string): Windows$Devices$Enumeration$Pnp$PnpObjectWatcher;

/**
 * Returns a PnpObjectWatcher object that is used to enumerate the PnP objects in the collection using events.
 * @param type The type of the PnpObject .
 * @param requestedProperties An iterable list of additional properties to include in the Properties property of the PnpObject objects included in enumeration results. For more info on what the properties represent, see Device information properties.
 * @return A PnpObjectWatcher object used to enumerate the collection by registering event notification delegates and by issuing start and stop event notifications.
 */
static createWatcher(
type: $Values<typeof Windows$Devices$Enumeration$Pnp$PnpObjectType>,
requestedProperties: Windows$Foundation$Collections$IIterable<string>): Windows$Devices$Enumeration$Pnp$PnpObjectWatcher;

/**
 * Returns all of the PnP objects of a specified type that match the specified filter.
 * @param type The type of the PnpObject .
 * @param requestedProperties An iterable list of additional properties to include in the Properties property of the PnpObject objects included in enumeration results. For more info on what the properties represent, see Device information properties.
 * @param aqsFilter An AQS string that filters the PnP objects that will be returned. Typically, this string is retrieved from the GetDeviceSelector method of a class that interacts with devices.
 * @return An object that represents the asynchronous operation.
 */
static findAllAsync(
type: $Values<typeof Windows$Devices$Enumeration$Pnp$PnpObjectType>,
requestedProperties: Windows$Foundation$Collections$IIterable<string>,
aqsFilter: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$Pnp$PnpObjectCollection>;

/**
 * Returns all of the PnP objects of a specified type that match the specified criteria.
 * @param type The type of the PnpObject .
 * @param requestedProperties An iterable list of additional properties to include in the Properties property of the PnpObject objects included in enumeration results. For more info on what the properties represent, see Device information properties.
 * @return An object that represents the asynchronous operation.
 */
static findAllAsync(
type: $Values<typeof Windows$Devices$Enumeration$Pnp$PnpObjectType>,
requestedProperties: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Enumeration$Pnp$PnpObjectCollection>;

/**
 * A string representing the identity of the PnpObject .
 */
id: string;

/**
 * A property store containing well-known values as well as additional specified properties.
 */
properties: Windows$Foundation$Collections$IMapView<string, any>;

/**
 * The type of the PnpObject .
 */
type: $Values<typeof Windows$Devices$Enumeration$Pnp$PnpObjectType>;

/**
 * Updates the properties of an existing PnpObject by applying the changes described in a PnpObjectUpdate object.
 * @param updateInfo Indicates the properties to update.
 */
update(updateInfo: Windows$Devices$Enumeration$Pnp$PnpObjectUpdate): void
}


/**
 * Represents an iterable collection of Pnp device objects.
 */
declare class Windows$Devices$Enumeration$Pnp$PnpObjectCollection mixins Array<Windows$Devices$Enumeration$Pnp$PnpObject> {

/**
 * Returns the iterator for iteration over the items in the collection.
 * @return The iterator object. The iterator's current position is at the 0-index position, or at the end of the collection if the collection is empty.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Devices$Enumeration$Pnp$PnpObject>;

/**
 * Returns the PnpObject located at the specified index.
 * @param index The integer index for the value to retrieve.
 * @return The PnpObject at the specified index.
 */
getAt(index: number): Windows$Devices$Enumeration$Pnp$PnpObject;

/**
 * Retrieves multiple elements in a single pass through the iterator.
 * @param startIndex The index from which to start retrieval.
 */
getMany(
startIndex: number): {
items: Windows$Devices$Enumeration$Pnp$PnpObject,
returnValue: number
};

/**
 * Retrieves the index of the specified item.
 * @param value The value to find in the collection.
 */
indexOf(
value: Windows$Devices$Enumeration$Pnp$PnpObject): {
index: number,
returnValue: boolean
};

/**
 * Returns the number of items in the collection.
 */
size: number;
indexOf(
value: Windows$Devices$Enumeration$Pnp$PnpObject,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Devices$Enumeration$Pnp$PnpObject,
fromIndex?: number): number
}


/**
 * Indicates the device type of a PnpObject .
 */

declare  var Windows$Devices$Enumeration$Pnp$PnpObjectType: {|
  +unknown: 0,// 0
+deviceInterface: 1,// 1
+deviceContainer: 2,// 2
+device: 3,// 3
+deviceInterfaceClass: 4,// 4
+associationEndpoint: 5,// 5
+associationEndpointContainer: 6,// 6
+associationEndpointService: 7,// 7

|};



/**
 * Contains the updated properties of a PnpObject .
 */
declare class Windows$Devices$Enumeration$Pnp$PnpObjectUpdate  {

/**
 * The identifier of the PnpObject .
 */
id: string;

/**
 * The changed properties in an update to a PnpObject .
 */
properties: Windows$Foundation$Collections$IMapView<string, any>;

/**
 * The type of the PnpObject . One of the values of the PnpObjectType enumeration.
 */
type: $Values<typeof Windows$Devices$Enumeration$Pnp$PnpObjectType>
}


/**
 * Raises events to notify the client that a PnpObject has been added, updated, or removed from an enumerated collection of Pnp device objects in an incremental and asynchronous way.
 */
declare class Windows$Devices$Enumeration$Pnp$PnpObjectWatcher  {

/**
 * Occurs when a PnpObject is added to the collection enumerated by the PnpObjectWatcher .
 */
onadded: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$Pnp$PnpObjectWatcher, Windows$Devices$Enumeration$Pnp$PnpObject>;
addEventListener(
type: "added",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$Pnp$PnpObjectWatcher, Windows$Devices$Enumeration$Pnp$PnpObject>): void;
removeEventListener(
type: "added",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$Pnp$PnpObjectWatcher, Windows$Devices$Enumeration$Pnp$PnpObject>): void;

/**
 * Occurs when the enumeration of Pnp device objects has been completed.
 */
onenumerationcompleted: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$Pnp$PnpObjectWatcher, any>;
addEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$Pnp$PnpObjectWatcher, any>): void;
removeEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$Pnp$PnpObjectWatcher, any>): void;

/**
 * Occurs when a PnpObject is removed from the collection enumerated by the PnpObjectWatcher .
 */
onremoved: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$Pnp$PnpObjectWatcher, Windows$Devices$Enumeration$Pnp$PnpObjectUpdate>;
addEventListener(
type: "removed",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$Pnp$PnpObjectWatcher, Windows$Devices$Enumeration$Pnp$PnpObjectUpdate>): void;
removeEventListener(
type: "removed",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$Pnp$PnpObjectWatcher, Windows$Devices$Enumeration$Pnp$PnpObjectUpdate>): void;

/**
 * Occurs when the PnpObjectWatcher has stopped monitoring changes to the collection of Pnp device objects.
 */
onstopped: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$Pnp$PnpObjectWatcher, any>;
addEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$Pnp$PnpObjectWatcher, any>): void;
removeEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$Pnp$PnpObjectWatcher, any>): void;

/**
 * Occurs when the properties of a PnpObject in the collection enumerated by the PnpObjectWatcher are updated.
 */
onupdated: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$Pnp$PnpObjectWatcher, Windows$Devices$Enumeration$Pnp$PnpObjectUpdate>;
addEventListener(
type: "updated",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$Pnp$PnpObjectWatcher, Windows$Devices$Enumeration$Pnp$PnpObjectUpdate>): void;
removeEventListener(
type: "updated",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Enumeration$Pnp$PnpObjectWatcher, Windows$Devices$Enumeration$Pnp$PnpObjectUpdate>): void;

/**
 * Starts raising the events to inform the client that a PnpObject has been added, updated, or removed.
 */
start(): void;

/**
 * The status associated with the asynchronous operation.
 */
status: $Values<typeof Windows$Devices$Enumeration$DeviceWatcherStatus>;

/**
 * Stops raising the events to inform the client that a PnpObject has been added, updated, or removed.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Identifies a collection of settings for device pairing.
 */
declare interface Windows$Devices$Enumeration$IDevicePairingSettings {} 


      declare var npm$namespace$Windows$Devices$Geolocation: {
        
        
        AltitudeReferenceSystem: typeof Windows$Devices$Geolocation$AltitudeReferenceSystem,
GeolocationAccessStatus: typeof Windows$Devices$Geolocation$GeolocationAccessStatus,
GeoshapeType: typeof Windows$Devices$Geolocation$GeoshapeType,
PositionAccuracy: typeof Windows$Devices$Geolocation$PositionAccuracy,
PositionSource: typeof Windows$Devices$Geolocation$PositionSource,
PositionStatus: typeof Windows$Devices$Geolocation$PositionStatus,
        CivicAddress: typeof Windows$Devices$Geolocation$CivicAddress,
GeoboundingBox: typeof Windows$Devices$Geolocation$GeoboundingBox,
Geocircle: typeof Windows$Devices$Geolocation$Geocircle,
Geocoordinate: typeof Windows$Devices$Geolocation$Geocoordinate,
GeocoordinateSatelliteData: typeof Windows$Devices$Geolocation$GeocoordinateSatelliteData,
Geolocator: typeof Windows$Devices$Geolocation$Geolocator,
Geopath: typeof Windows$Devices$Geolocation$Geopath,
Geopoint: typeof Windows$Devices$Geolocation$Geopoint,
Geoposition: typeof Windows$Devices$Geolocation$Geoposition,
PositionChangedEventArgs: typeof Windows$Devices$Geolocation$PositionChangedEventArgs,
StatusChangedEventArgs: typeof Windows$Devices$Geolocation$StatusChangedEventArgs,
VenueData: typeof Windows$Devices$Geolocation$VenueData,
        Geofencing: typeof npm$namespace$Windows$Devices$Geolocation$Geofencing,
      }

/**
 * Indicates the altitude reference system to be used in defining a geographic shape.
 */

declare  var Windows$Devices$Geolocation$AltitudeReferenceSystem: {|
  +unspecified: 0,// 0
+terrain: 1,// 1
+ellipsoid: 2,// 2
+geoid: 3,// 3
+surface: 4,// 4

|};



/**
 * Unsupported API.
 */
declare class Windows$Devices$Geolocation$CivicAddress  {

/**
 * Unsupported API.
 */
city: string;

/**
 * Unsupported API.
 */
country: string;

/**
 * Unsupported API.
 */
postalCode: string;

/**
 * Unsupported API.
 */
state: string;

/**
 * Unsupported API.
 */
timestamp: Date
}


/**
 * Represents a rectangle that defines a geographic area.
 */
declare class Windows$Devices$Geolocation$GeoboundingBox  {

/**
 * Calculates a GeoboundingBox that contains the specified set of geographic positions.
 * @param positions A collection of geographic positions to include inside the GeoboundingBox .
 * @return The calculated rectangle that contains the specified set of geographic positions.
 */
static tryCompute(
positions: Windows$Foundation$Collections$IIterable<Windows$Devices$Geolocation$BasicGeoposition>): Windows$Devices$Geolocation$GeoboundingBox;

/**
 * Calculates a GeoboundingBox that contains the specified set of geographic positions and uses the specified altitude reference system and spatial reference ID (SRID).
 * @param positions A collection of geographic positions to include inside the GeoboundingBox .
 * @param altitudeRefSystem The altitude reference system to use for the GeoboundingBox . For more info, see the AltitudeReferenceSystem property.
 * @param spatialReferenceId The spatial reference ID (SRID) to use for the GeoboundingBox . For more info, see the SpatialReferenceId property.
 * @return The calculated rectangle that contains the specified set of geographic positions.
 */
static tryCompute(
positions: Windows$Foundation$Collections$IIterable<Windows$Devices$Geolocation$BasicGeoposition>,
altitudeRefSystem: $Values<typeof Windows$Devices$Geolocation$AltitudeReferenceSystem>,
spatialReferenceId: number): Windows$Devices$Geolocation$GeoboundingBox;

/**
 * Calculates a GeoboundingBox that contains the specified set of geographic positions and uses the specified altitude reference system.
 * @param positions A collection of geographic positions to include inside the GeoboundingBox .
 * @param altitudeRefSystem The altitude reference system to use for the GeoboundingBox . For more info, see the AltitudeReferenceSystem property.
 * @return The calculated rectangle that contains the specified set of geographic positions.
 */
static tryCompute(
positions: Windows$Foundation$Collections$IIterable<Windows$Devices$Geolocation$BasicGeoposition>,
altitudeRefSystem: $Values<typeof Windows$Devices$Geolocation$AltitudeReferenceSystem>): Windows$Devices$Geolocation$GeoboundingBox;

/**
 * Initializes a new instance of the GeoboundingBox class that has the specified corners.
 * @param northwestCorner The northwest corner to use for the new GeoboundingBox . For more info, see the NorthwestCorner property.
 * @param southeastCorner The southeast corner to use for the new GeoboundingBox . For more info, see the SoutheastCorner property.
 */
constructor(northwestCorner: Windows$Devices$Geolocation$BasicGeoposition, southeastCorner: Windows$Devices$Geolocation$BasicGeoposition): this;

/**
 * Initializes a new instance of the GeoboundingBox class that has the specified corners and uses the specified altitude reference system.
 * @param northwestCorner The northwest corner to use for the new GeoboundingBox . For more info, see the NorthwestCorner property.
 * @param southeastCorner The southeast corner to use for the new GeoboundingBox . For more info, see the SoutheastCorner property.
 * @param altitudeReferenceSystem The altitude reference system to use for the new GeoboundingBox . For more info, see the AltitudeReferenceSystem property.
 */
constructor(northwestCorner: Windows$Devices$Geolocation$BasicGeoposition, southeastCorner: Windows$Devices$Geolocation$BasicGeoposition, altitudeReferenceSystem: $Values<typeof Windows$Devices$Geolocation$AltitudeReferenceSystem>): this;

/**
 * Initializes a new instance of the GeoboundingBox class that has the specified corners and uses the specified altitude reference system and spatial reference ID (SRID).
 * @param northwestCorner The northwest corner to use for the new GeoboundingBox . For more info, see the NorthwestCorner property.
 * @param southeastCorner The southeast corner to use for the new GeoboundingBox . For more info, see the SoutheastCorner property.
 * @param altitudeReferenceSystem The altitude reference system to use for the new GeoboundingBox . For more info, see the AltitudeReferenceSystem property.
 * @param spatialReferenceId The spatial reference ID (SRID) to use for the new GeoboundingBox . For more info, see the SpatialReferenceId property.
 */
constructor(northwestCorner: Windows$Devices$Geolocation$BasicGeoposition, southeastCorner: Windows$Devices$Geolocation$BasicGeoposition, altitudeReferenceSystem: $Values<typeof Windows$Devices$Geolocation$AltitudeReferenceSystem>, spatialReferenceId: number): this;

/**
 * Gets the altitude reference system used by the GeoboundingBox .
 */
altitudeReferenceSystem: $Values<typeof Windows$Devices$Geolocation$AltitudeReferenceSystem>;

/**
 * Gets the center of the GeoboundingBox .
 */
center: Windows$Devices$Geolocation$BasicGeoposition;

/**
 * Gets the type of geographic shape represented by the GeoboundingBox .
 */
geoshapeType: $Values<typeof Windows$Devices$Geolocation$GeoshapeType>;

/**
 * Gets the altitude of the highest corner of the GeoboundingBox .
 */
maxAltitude: number;

/**
 * Gets the altitude of the lowest corner of the GeoboundingBox .
 */
minAltitude: number;

/**
 * Gets the northwest corner of the GeoboundingBox .
 */
northwestCorner: Windows$Devices$Geolocation$BasicGeoposition;

/**
 * Gets the southeast corner of the GeoboundingBox .
 */
southeastCorner: Windows$Devices$Geolocation$BasicGeoposition;

/**
 * Gets the spatial reference ID (SRID) used by the GeoboundingBox .
 */
spatialReferenceId: number
}


/**
 * Describes a geographic circle with a center point and a radius.
 */
declare class Windows$Devices$Geolocation$Geocircle  {

/**
 * Create a geographic circle object for the given position and radius.
 * @param position The geographic position of the new circle.
 * @param radius The radius of the new circle, in meters.
 */
constructor(position: Windows$Devices$Geolocation$BasicGeoposition, radius: number): this;

/**
 * Create a geographic circle object for the given position, radius, altitude reference system, and spatial reference id.
 * @param position The geographic position of the new circle.
 * @param radius The radius of the new circle, in meters.
 * @param altitudeReferenceSystem The altitude reference system of the new circle.
 * @param spatialReferenceId The spatial reference Id of the new circle.
 */
constructor(position: Windows$Devices$Geolocation$BasicGeoposition, radius: number, altitudeReferenceSystem: $Values<typeof Windows$Devices$Geolocation$AltitudeReferenceSystem>, spatialReferenceId: number): this;

/**
 * Create a geographic circle object for the given position, radius and altitude reference system.
 * @param position The geographic position of the new circle.
 * @param radius The radius of the new circle, in meters.
 * @param altitudeReferenceSystem The altitude reference system of the new circle.
 */
constructor(position: Windows$Devices$Geolocation$BasicGeoposition, radius: number, altitudeReferenceSystem: $Values<typeof Windows$Devices$Geolocation$AltitudeReferenceSystem>): this;

/**
 * The altitude reference system of the geographic circle.
 */
altitudeReferenceSystem: $Values<typeof Windows$Devices$Geolocation$AltitudeReferenceSystem>;

/**
 * The center point of a geographic circle.
 */
center: Windows$Devices$Geolocation$BasicGeoposition;

/**
 * The type of geographic shape.
 */
geoshapeType: $Values<typeof Windows$Devices$Geolocation$GeoshapeType>;

/**
 * The radius of a geographic circle in meters.
 */
radius: number;

/**
 * The spatial reference identifier for the geographic circle, corresponding to a spatial reference system based on the specific ellipsoid used for either flat-earth mapping or round-earth mapping.
 */
spatialReferenceId: number
}


/**
 * Contains the information for identifying a geographic location.
 */
declare class Windows$Devices$Geolocation$Geocoordinate  {

/**
 * The accuracy of the location in meters.
 */
accuracy: number;

/**
 * The altitude of the location, in meters.
 */
altitude: number;

/**
 * The accuracy of the altitude, in meters.
 */
altitudeAccuracy: number;

/**
 * The current heading in degrees relative to true north.
 */
heading: number;

/**
 * The latitude in degrees.
 */
latitude: number;

/**
 * The longitude in degrees.
 */
longitude: number;

/**
 * The location of the Geocoordinate.
 */
point: Windows$Devices$Geolocation$Geopoint;

/**
 * Gets the source used to obtain a Geocoordinate.
 */
positionSource: $Values<typeof Windows$Devices$Geolocation$PositionSource>;

/**
 * Gets the time at which the associated Geocoordinate position was calculated.
 */
positionSourceTimestamp: Date;

/**
 * Gets information about the satellites used to obtain a Geocoordinate.
 */
satelliteData: Windows$Devices$Geolocation$GeocoordinateSatelliteData;

/**
 * The speed in meters per second.
 */
speed: number;

/**
 * The system time at which the location was determined.
 */
timestamp: Date
}


/**
 * Provides additional information about a Geocoordinate . This information is only applicable to position estimates obtained using satellite signals.
 */
declare class Windows$Devices$Geolocation$GeocoordinateSatelliteData  {

/**
 * Gets the horizontal dilution of precision (HDOP) of a Geocoordinate .
 */
horizontalDilutionOfPrecision: number;

/**
 * Gets the position dilution of precision (PDOP) of a Geocoordinate .
 */
positionDilutionOfPrecision: number;

/**
 * Gets the vertical dilution of precision (VDOP) of a Geocoordinate .
 */
verticalDilutionOfPrecision: number
}


      declare var npm$namespace$Windows$Devices$Geolocation$Geofencing: {
        
        
        GeofenceMonitorStatus: typeof Windows$Devices$Geolocation$Geofencing$GeofenceMonitorStatus,
GeofenceRemovalReason: typeof Windows$Devices$Geolocation$Geofencing$GeofenceRemovalReason,
GeofenceState: typeof Windows$Devices$Geolocation$Geofencing$GeofenceState,
MonitoredGeofenceStates: typeof Windows$Devices$Geolocation$Geofencing$MonitoredGeofenceStates,
        Geofence: typeof Windows$Devices$Geolocation$Geofencing$Geofence,
GeofenceMonitor: typeof Windows$Devices$Geolocation$Geofencing$GeofenceMonitor,
GeofenceStateChangeReport: typeof Windows$Devices$Geolocation$Geofencing$GeofenceStateChangeReport,
        
      }

/**
 * Contains the information to define a geofence, an area of interest, to monitor.
 */
declare class Windows$Devices$Geolocation$Geofencing$Geofence  {

/**
 * Initializes a new Geofence object given the id, the shape of the geofence, the states to monitor the geofence for, the singleUse flag, the dwellTime for the geofence, the time to start monitoring the geofence, and the duration of the geofence.
 * @param id The Id of the geofence.
 * @param geoshape The area that defines the geofence to monitor.
 * @param monitoredStates The states to monitor the geofence for.
 * @param singleUse True indicates the geofence should be monitored only for one use. False indicates the geofence should be monitored for multiple uses.
 * @param dwellTime The time that a position has to be in or out of the geofence in order for the notification to be triggered.
 * @param startTime The time to start monitoring the geofence.
 * @param duration The duration of time to monitor the geofence for. The duration begins at the startTime.
 */
constructor(id: string, geoshape: Windows$Devices$Geolocation$IGeoshape, monitoredStates: $Values<typeof Windows$Devices$Geolocation$Geofencing$MonitoredGeofenceStates>, singleUse: boolean, dwellTime: number, startTime: Date, duration: number): this;

/**
 * Initializes a new Geofence object given the id, the shape of the geofence, the states to monitor the geofence for, and the singleUse flag.
 * @param id The Id of the geofence.
 * @param geoshape The area that defines the geofence to monitor.
 * @param monitoredStates The states to monitor the geofence for.
 * @param singleUse True indicates the geofence should be monitored only for one use. False indicates the geofence should be monitored for multiple uses.
 */
constructor(id: string, geoshape: Windows$Devices$Geolocation$IGeoshape, monitoredStates: $Values<typeof Windows$Devices$Geolocation$Geofencing$MonitoredGeofenceStates>, singleUse: boolean): this;

/**
 * Initializes a new Geofence object given the id and the shape of the geofence.
 * @param id The Id of the geofence.
 * @param geoshape The area that defines the geofence to monitor.
 */
constructor(id: string, geoshape: Windows$Devices$Geolocation$IGeoshape): this;

/**
 * Initializes a new Geofence object given the id, the shape of the geofence, the states to monitor the geofence for, the singleUse flag, and the dwellTime for the geofence.
 * @param id The Id of the geofence.
 * @param geoshape The area that defines the geofence to monitor.
 * @param monitoredStates The states to monitor the geofence for.
 * @param singleUse True indicates the geofence should be monitored only for one use. False indicates the geofence should be monitored for multiple uses.
 * @param dwellTime The time that a position has to be in or out of the geofence in order for the notification to be triggered.
 */
constructor(id: string, geoshape: Windows$Devices$Geolocation$IGeoshape, monitoredStates: $Values<typeof Windows$Devices$Geolocation$Geofencing$MonitoredGeofenceStates>, singleUse: boolean, dwellTime: number): this;

/**
 * Gets the time window, beginning after the StartTime , during which the Geofence is monitored.
 */
duration: number;

/**
 * The minimum time that a position has to be inside or outside of the Geofence in order for the notification to be triggered.
 */
dwellTime: number;

/**
 * The shape of the geofence region.
 */
geoshape: Windows$Devices$Geolocation$IGeoshape;

/**
 * The id of the Geofence .
 */
id: string;

/**
 * Indicates the states that the Geofence is being monitored for.
 */
monitoredStates: $Values<typeof Windows$Devices$Geolocation$Geofencing$MonitoredGeofenceStates>;

/**
 * Indicates whether the Geofence should be triggered once or multiple times.
 */
singleUse: boolean;

/**
 * The time to start monitoring the Geofence .
 */
startTime: Date
}


/**
 * Contains the information about the monitored Geofence objects.
 */
declare class Windows$Devices$Geolocation$Geofencing$GeofenceMonitor  {

/**
 * Gets the GeofenceMonitor object which contains all of an app's Geofence information.
 */
static current: Windows$Devices$Geolocation$Geofencing$GeofenceMonitor;

/**
 * Returns a vector of the app's Geofence objects currently registered with the system wide GeofenceMonitor .
 */
geofences: Windows$Foundation$Collections$IVector<Windows$Devices$Geolocation$Geofencing$Geofence>;

/**
 * Last reading of the device's location.
 */
lastKnownGeoposition: Windows$Devices$Geolocation$Geoposition;

/**
 * Raised when the state of one or more Geofence objects in the Geofences collection of the GeofenceMonitor has changed
 */
ongeofencestatechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Geolocation$Geofencing$GeofenceMonitor, any>;
addEventListener(
type: "geofencestatechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Geolocation$Geofencing$GeofenceMonitor, any>): void;
removeEventListener(
type: "geofencestatechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Geolocation$Geofencing$GeofenceMonitor, any>): void;

/**
 * Raised when the status of the GeofenceMonitor has changed.
 */
onstatuschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Geolocation$Geofencing$GeofenceMonitor, any>;
addEventListener(
type: "statuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Geolocation$Geofencing$GeofenceMonitor, any>): void;
removeEventListener(
type: "statuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Geolocation$Geofencing$GeofenceMonitor, any>): void;

/**
 * Gets a collection of status changes to the Geofence objects in the Geofences collection of the GeofenceMonitor .
 * @return collection of status changes to the GeofenceMonitor .
 */
readReports(
): Windows$Foundation$Collections$IVectorView<Windows$Devices$Geolocation$Geofencing$GeofenceStateChangeReport>;

/**
 * Indicates the current state of the GeofenceMonitor .
 */
status: $Values<typeof Windows$Devices$Geolocation$Geofencing$GeofenceMonitorStatus>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Indicates the current state of a GeofenceMonitor .
 */

declare  var Windows$Devices$Geolocation$Geofencing$GeofenceMonitorStatus: {|
  +ready: 0,// 0
+initializing: 1,// 1
+noData: 2,// 2
+disabled: 3,// 3
+notInitialized: 4,// 4
+notAvailable: 5,// 5

|};



/**
 * Indicates the reason a Geofence was removed.
 */

declare  var Windows$Devices$Geolocation$Geofencing$GeofenceRemovalReason: {|
  +used: 0,// 0
+expired: 1,// 1

|};



/**
 * Indicates the current state of a Geofence .
 */

declare  var Windows$Devices$Geolocation$Geofencing$GeofenceState: {|
  +none: 0,// 0
+entered: 1,// 1
+exited: 2,// 2
+removed: 3,// 3

|};



/**
 * Contains the information about the state changes for a Geofence .
 */
declare class Windows$Devices$Geolocation$Geofencing$GeofenceStateChangeReport  {

/**
 * The Geofence object whose state has changed.
 */
geofence: Windows$Devices$Geolocation$Geofencing$Geofence;

/**
 * The position of the Geofence object whose state has changed.
 */
geoposition: Windows$Devices$Geolocation$Geoposition;

/**
 * The new state of the Geofence object whose state has changed.
 */
newState: $Values<typeof Windows$Devices$Geolocation$Geofencing$GeofenceState>;

/**
 * Indicates the reason a Geofence was removed.
 */
removalReason: $Values<typeof Windows$Devices$Geolocation$Geofencing$GeofenceRemovalReason>
}


/**
 * Indicates the state or states of the Geofences that are currently being monitored by the system.
 */

declare  var Windows$Devices$Geolocation$Geofencing$MonitoredGeofenceStates: {|
  +none: 0,// 0
+entered: 1,// 1
+exited: 2,// 2
+removed: 3,// 3

|};



/**
 * Indicates if your app has permission to access location data.
 */

declare  var Windows$Devices$Geolocation$GeolocationAccessStatus: {|
  +unspecified: 0,// 0
+allowed: 1,// 1
+denied: 2,// 2

|};



/**
 * Provides access to the current geographic location.
 */
declare class Windows$Devices$Geolocation$Geolocator  {

/**
 * Starts an asynchronous operation to retrieve the location history of the device.
 * @param startTime Represents the beginning of the time span for which positions are to be returned.
 * @return Positions (of type Geoposition ) that were collected during the specified time span.
 */
static getGeopositionHistoryAsync(
startTime: Date): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Starts an asynchronous operation to retrieve the location history of the device.
 * @param startTime Represents the beginning of the time span for which positions are to be returned.
 * @param duration Represents the length of time after startTime for which positions are to be returned.
 * @return Positions (of type Geoposition ) that were collected during the specified time span.
 */
static getGeopositionHistoryAsync(
startTime: Date,
duration: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Requests permission to access location data.
 * @return A GeolocationAccessStatus that indicates if permission to location data has been granted.
 */
static requestAccessAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Devices$Geolocation$GeolocationAccessStatus>>;

/**
 * Initializes a new Geolocator object.
 */
constructor(): this;

/**
 * The accuracy level at which the Geolocator provides location updates.
 */
desiredAccuracy: $Values<typeof Windows$Devices$Geolocation$PositionAccuracy>;

/**
 * Gets or sets the desired accuracy in meters for data returned from the location service.
 */
desiredAccuracyInMeters: number;

/**
 * Starts an asynchronous operation to retrieve the current location of the device.
 * @return Provides methods for starting the asynchronous request for location data and handling its completion.
 */
getGeopositionAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Geolocation$Geoposition>;

/**
 * Starts an asynchronous operation to retrieve the current location of the device.
 * @param maximumAge The maximum acceptable age of cached location data. A TimeSpan is a time period expressed in 100-nanosecond units.
 * @param timeout The timeout. A TimeSpan is a time period expressed in 100-nanosecond units.
 * @return Provides methods for starting the asynchronous request for location data and handling its completion.
 */
getGeopositionAsync(
maximumAge: number,
timeout: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Geolocation$Geoposition>;

/**
 * The status that indicates the ability of the Geolocator to provide location updates.
 */
locationStatus: $Values<typeof Windows$Devices$Geolocation$PositionStatus>;

/**
 * Gets and sets the distance of movement, in meters, relative to the coordinate from the last PositionChanged event, that is required for the Geolocator to raise a PositionChanged event.
 */
movementThreshold: number;

/**
 * Raised when the location is updated.
 */
onpositionchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Geolocation$Geolocator, Windows$Devices$Geolocation$PositionChangedEventArgs>;
addEventListener(
type: "positionchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Geolocation$Geolocator, Windows$Devices$Geolocation$PositionChangedEventArgs>): void;
removeEventListener(
type: "positionchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Geolocation$Geolocator, Windows$Devices$Geolocation$PositionChangedEventArgs>): void;

/**
 * Raised when the ability of the Geolocator to provide updated location changes.
 */
onstatuschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Geolocation$Geolocator, Windows$Devices$Geolocation$StatusChangedEventArgs>;
addEventListener(
type: "statuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Geolocation$Geolocator, Windows$Devices$Geolocation$StatusChangedEventArgs>): void;
removeEventListener(
type: "statuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Geolocation$Geolocator, Windows$Devices$Geolocation$StatusChangedEventArgs>): void;

/**
 * The requested minimum time interval between location updates, in milliseconds. If your application requires updates infrequently, set this value so that location services can conserve power by calculating location only when needed.
 */
reportInterval: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents an ordered series of geographic points.
 */
declare class Windows$Devices$Geolocation$Geopath  {

/**
 * Initializes a new instance of the Geopath class with the specified collection of positions.
 * @param positions The collection of positions to use to create the new Geopath . For more info, see the Positions property.
 */
constructor(positions: Windows$Foundation$Collections$IIterable<Windows$Devices$Geolocation$BasicGeoposition>): this;

/**
 * Initializes a new instance of the Geopath class with the specified collection of positions and with the specified altitude reference system and spatial reference ID (SRID).
 * @param positions The collection of positions to use to create the new Geopath . For more info, see the Positions property.
 * @param altitudeReferenceSystem The altitude reference system to use to create the new Geopath . For more info, see the AltitudeReferenceSystem property.
 * @param spatialReferenceId The spatial reference ID (SRID) to use to create the new Geopath . For more info, see the SpatialReferenceId property.
 */
constructor(positions: Windows$Foundation$Collections$IIterable<Windows$Devices$Geolocation$BasicGeoposition>, altitudeReferenceSystem: $Values<typeof Windows$Devices$Geolocation$AltitudeReferenceSystem>, spatialReferenceId: number): this;

/**
 * Initializes a new instance of the Geopath class with the specified collection of positions and with the specified altitude reference system.
 * @param positions The collection of positions to use to create the new Geopath . For more info, see the Positions property.
 * @param altitudeReferenceSystem The altitude reference system to use to create the new Geopath . For more info, see the AltitudeReferenceSystem property.
 */
constructor(positions: Windows$Foundation$Collections$IIterable<Windows$Devices$Geolocation$BasicGeoposition>, altitudeReferenceSystem: $Values<typeof Windows$Devices$Geolocation$AltitudeReferenceSystem>): this;

/**
 * Gets the altitude reference system used by the Geopath .
 */
altitudeReferenceSystem: $Values<typeof Windows$Devices$Geolocation$AltitudeReferenceSystem>;

/**
 * Gets the type of geographic shape represented by the Geopath .
 */
geoshapeType: $Values<typeof Windows$Devices$Geolocation$GeoshapeType>;

/**
 * Gets the collection of geographic points that define the Geopath .
 */
positions: Windows$Foundation$Collections$IVectorView<Windows$Devices$Geolocation$BasicGeoposition>;

/**
 * Gets the spatial reference ID (SRID) used by the Geopath .
 */
spatialReferenceId: number
}


/**
 * Describes a geographic point.
 */
declare class Windows$Devices$Geolocation$Geopoint  {

/**
 * Create a geographic point object for the given position.
 * @param position Create a geographic point object for the given position.
 */
constructor(position: Windows$Devices$Geolocation$BasicGeoposition): this;

/**
 * Create a geographic point object for the given position, altitude reference system, and spatial reference Id.
 * @param position Create a geographic point object for the given position.
 * @param altitudeReferenceSystem The altitude reference system of the new point.
 * @param spatialReferenceId The spatial reference Id of the new point.
 */
constructor(position: Windows$Devices$Geolocation$BasicGeoposition, altitudeReferenceSystem: $Values<typeof Windows$Devices$Geolocation$AltitudeReferenceSystem>, spatialReferenceId: number): this;

/**
 * Create a geographic point object for the given position and altitude reference system.
 * @param position Create a geographic point object for the given position.
 * @param altitudeReferenceSystem The altitude reference system of the new point.
 */
constructor(position: Windows$Devices$Geolocation$BasicGeoposition, altitudeReferenceSystem: $Values<typeof Windows$Devices$Geolocation$AltitudeReferenceSystem>): this;

/**
 * The altitude reference system of the geographic point.
 */
altitudeReferenceSystem: $Values<typeof Windows$Devices$Geolocation$AltitudeReferenceSystem>;

/**
 * The type of geographic shape.
 */
geoshapeType: $Values<typeof Windows$Devices$Geolocation$GeoshapeType>;

/**
 * The position of a geographic point.
 */
position: Windows$Devices$Geolocation$BasicGeoposition;

/**
 * The spatial reference identifier for the geographic point, corresponding to a spatial reference system based on the specific ellipsoid used for either flat-earth mapping or round-earth mapping.
 */
spatialReferenceId: number
}


/**
 * Represents a location that may contain latitude and longitude data or venue data.
 */
declare class Windows$Devices$Geolocation$Geoposition  {

/**
 * Unsupported API.
 */
civicAddress: Windows$Devices$Geolocation$CivicAddress;

/**
 * The latitude and longitude associated with a geographic location.
 */
coordinate: Windows$Devices$Geolocation$Geocoordinate;

/**
 * Represents the venue associated with a geographic location.
 */
venueData: Windows$Devices$Geolocation$VenueData
}


/**
 * Indicates the shape of a geographic region.
 */

declare  var Windows$Devices$Geolocation$GeoshapeType: {|
  +geopoint: 0,// 0
+geocircle: 1,// 1
+geopath: 2,// 2
+geoboundingBox: 3,// 3

|};



/**
 * Indicates the requested accuracy level for the location data that the application uses.
 */

declare  var Windows$Devices$Geolocation$PositionAccuracy: {|
  +default: 0,// 0
+high: 1,// 1

|};



/**
 * Provides data for the PositionChanged event.
 */
declare class Windows$Devices$Geolocation$PositionChangedEventArgs  {

/**
 * The location data associated with the PositionChanged event.
 */
position: Windows$Devices$Geolocation$Geoposition
}


/**
 * Indicates the source used to obtain a Geocoordinate .
 */

declare  var Windows$Devices$Geolocation$PositionSource: {|
  +cellular: 0,// 0
+satellite: 1,// 1
+wiFi: 2,// 2
+ipAddress: 3,// 3
+unknown: 4,// 4

|};



/**
 * Indicates the ability of the Geolocator object to provide location data.
 */

declare  var Windows$Devices$Geolocation$PositionStatus: {|
  +ready: 0,// 0
+initializing: 1,// 1
+noData: 2,// 2
+disabled: 3,// 3
+notInitialized: 4,// 4
+notAvailable: 5,// 5

|};



/**
 * Provides information for the StatusChanged event.
 */
declare class Windows$Devices$Geolocation$StatusChangedEventArgs  {

/**
 * The updated status of the Geolocator object.
 */
status: $Values<typeof Windows$Devices$Geolocation$PositionStatus>
}


/**
 * Represents the venue associated with a geographic location.
 */
declare class Windows$Devices$Geolocation$VenueData  {

/**
 * Gets the identifier (ID) of the venue.
 */
id: string;

/**
 * Gets the identifier (ID) of the building level.
 */
level: string
}


/**
 * The basic information to describe a geographic position.
 */
declare interface Windows$Devices$Geolocation$BasicGeoposition {

/**
 * The altitude of the geographic position in meters.
 */
altitude: number,

/**
 * The latitude of the geographic position. The valid range of latitude values is from -90.0 to 90.0 degrees.
 */
latitude: number,

/**
 * The longitude of the geographic position. This can be any value. For values less than or equal to-180.0 or values greater than 180.0, the value may be wrapped and stored appropriately before it is used. For example, a longitude of 183.0 degrees would become -177.0 degrees.
 */
longitude: number
} 


/**
 * Interface to define a geographic shape.
 */
declare interface Windows$Devices$Geolocation$IGeoshape {

/**
 * The altitude reference system of the geographic shape.
 */
altitudeReferenceSystem: $Values<typeof Windows$Devices$Geolocation$AltitudeReferenceSystem>,

/**
 * The type of geographic shape.
 */
geoshapeType: $Values<typeof Windows$Devices$Geolocation$GeoshapeType>,

/**
 * The spatial reference identifier for the geographic shape, corresponding to a spatial reference system based on the specific ellipsoid used for either flat-earth mapping or round-earth mapping.
 */
spatialReferenceId: number
} 


      declare var npm$namespace$Windows$Devices$Gpio: {
        
        
        GpioOpenStatus: typeof Windows$Devices$Gpio$GpioOpenStatus,
GpioPinDriveMode: typeof Windows$Devices$Gpio$GpioPinDriveMode,
GpioPinEdge: typeof Windows$Devices$Gpio$GpioPinEdge,
GpioPinValue: typeof Windows$Devices$Gpio$GpioPinValue,
GpioSharingMode: typeof Windows$Devices$Gpio$GpioSharingMode,
        GpioController: typeof Windows$Devices$Gpio$GpioController,
GpioPin: typeof Windows$Devices$Gpio$GpioPin,
GpioPinValueChangedEventArgs: typeof Windows$Devices$Gpio$GpioPinValueChangedEventArgs,
        Provider: typeof npm$namespace$Windows$Devices$Gpio$Provider,
      }

/**
 * Represents the default general-purpose I/O (GPIO) controller for the system.
 */
declare class Windows$Devices$Gpio$GpioController  {

/**
 * Gets all the controllers that are connected to the system asynchronously.
 * @param provider The GPIO provider for the controllers on the system.
 * @return When the method completes successfully, it returns a list of values that represent the controllers available on the system.
 */
static getControllersAsync(
provider: Windows$Devices$Gpio$Provider$IGpioProvider): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the default general-purpose I/O (GPIO) controller for the system.
 * @return The default GPIO controller for the system, or null if the system has no GPIO controller.
 */
static getDefault(): Windows$Devices$Gpio$GpioController;

/**
 * Gets the default general-purpose I/O (GPIO) controller for the system.
 * @return The default GPIO controller for the system, or null if the system has no GPIO controller.
 */
static getDefaultAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Gpio$GpioController>;

/**
 * Opens a connection to the specified general-purpose I/O (GPIO) pin in exclusive mode.
 * @param pinNumber The pin number of the GPIO pin that you want to open. Some pins may not be available in user mode. For information about how the pin numbers correspond to physical pins, see the documentation for your circuit board.
 * @return The opened GPIO pin.
 */
openPin(pinNumber: number): Windows$Devices$Gpio$GpioPin;

/**
 * Opens the specified general-purpose I/O (GPIO) pin in the specified mode.
 * @param pinNumber The pin number of the GPIO pin that you want to open. Some pins may not be available in user mode. For information about how the pin numbers correspond to physical pins, see the documentation for your circuit board.
 * @param sharingMode The mode in which you want to open the GPIO pin, which determines whether other connections to the pin can be opened while you have the pin open.
 * @return The opened GPIO pin.
 */
openPin(
pinNumber: number,
sharingMode: $Values<typeof Windows$Devices$Gpio$GpioSharingMode>): Windows$Devices$Gpio$GpioPin;

/**
 * Gets the number of pins on the general-purpose I/O (GPIO) controller.
 */
pinCount: number;

/**
 * Opens the specified general-purpose I/O (GPIO) pin in the specified mode, and gets a status value that you can use to handle a failure to open the pin programmatically.
 * @param pinNumber The pin number of the GPIO pin that you want to open. Some pins may not be available in user mode. For information about how the pin numbers correspond to physical pins, see the documentation for your circuit board.
 * @param sharingMode The mode in which you want to open the GPIO pin, which determines whether other connections to the pin can be opened while you have the pin open.
 */
tryOpenPin(
pinNumber: number,
sharingMode: $Values<typeof Windows$Devices$Gpio$GpioSharingMode>): {
pin: Windows$Devices$Gpio$GpioPin,
openStatus: $Values<typeof Windows$Devices$Gpio$GpioOpenStatus>,
returnValue: boolean
}
}


/**
 * Describes the possible results of opening a pin with the GpioPin.TryOpenPin method.
 */

declare  var Windows$Devices$Gpio$GpioOpenStatus: {|
  +pinOpened: 0,// 0
+pinUnavailable: 1,// 1
+sharingViolation: 2,// 2

|};



/**
 * Represents a general-purpose I/O (GPIO) pin.
 */
declare class Windows$Devices$Gpio$GpioPin  {

/**
 * Closes the general-purpose I/O (GPIO) pin and releases the resources associated with it.
 */
close(): void;

/**
 * Gets or sets the debounce timeout for the general-purpose I/O (GPIO) pin, which is an interval during which changes to the value of the pin are filtered out and do not generate ValueChanged events.
 */
debounceTimeout: number;

/**
 * Gets the current drive mode for the general-purpose I/O (GPIO) pin. The drive mode specifies whether the pin is configured as an input or an output, and determines how values are driven onto the pin.
 * @return An enumeration value that indicates the current drive mode for the GPIO pin. The drive mode specifies whether the pin is configured as an input or an output, and determines how values are driven onto the pin.
 */
getDriveMode(): $Values<typeof Windows$Devices$Gpio$GpioPinDriveMode>;

/**
 * Gets whether the general-purpose I/O (GPIO) pin supports the specified drive mode.
 * @param driveMode The drive mode that you want to check for support.
 * @return True if the GPIO pin supports the drive mode that driveMode specifies; otherwise false. If you specify a drive mode for which this method returns false when you call SetDriveMode , SetDriveMode generates an exception.
 */
isDriveModeSupported(driveMode: $Values<typeof Windows$Devices$Gpio$GpioPinDriveMode>): boolean;

/**
 * Occurs when the value of the general-purpose I/O (GPIO) pin changes, either because of an external stimulus when the pin is configured as an input, or when a value is written to the pin when the pin in configured as an output.
 */
onvaluechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Gpio$GpioPin, Windows$Devices$Gpio$GpioPinValueChangedEventArgs>;
addEventListener(
type: "valuechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Gpio$GpioPin, Windows$Devices$Gpio$GpioPinValueChangedEventArgs>): void;
removeEventListener(
type: "valuechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Gpio$GpioPin, Windows$Devices$Gpio$GpioPinValueChangedEventArgs>): void;

/**
 * Gets the pin number of the general-purpose I/O (GPIO) pin.
 */
pinNumber: number;

/**
 * Reads the current value of the general-purpose I/O (GPIO) pin.
 * @return The current value of the GPIO pin. If the pin is configured as an output, this value is the last value written to the pin.
 */
read(): $Values<typeof Windows$Devices$Gpio$GpioPinValue>;

/**
 * Sets the drive mode of the general-purpose I/O (GPIO) pin. The drive mode specifies whether the pin is configured as an input or an output, and determines how values are driven onto the pin.
 * @param value An enumeration value that specifies drive mode to use for the GPIO pin. The drive mode specifies whether the pin is configured as an input or an output, and determines how values are driven onto the pin.
 */
setDriveMode(value: $Values<typeof Windows$Devices$Gpio$GpioPinDriveMode>): void;

/**
 * Gets the sharing mode in which the general-purpose I/O (GPIO) pin is open.
 */
sharingMode: $Values<typeof Windows$Devices$Gpio$GpioSharingMode>;

/**
 * Drives the specified value onto the general purpose I/O (GPIO) pin according to the current drive mode for the pin if the pin is configured as an output, or updates the latched output value for the pin if the pin is configured as an input.
 * @param value The enumeration value to write to the GPIO pin.
 */
write(value: $Values<typeof Windows$Devices$Gpio$GpioPinValue>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Describes whether a general-purpose I/O (GPIO) pin is configured as an input or an output, and how values are driven onto the pin.
 */

declare  var Windows$Devices$Gpio$GpioPinDriveMode: {|
  +input: 0,// 0
+output: 1,// 1
+inputPullUp: 2,// 2
+inputPullDown: 3,// 3
+outputOpenDrain: 4,// 4
+outputOpenDrainPullUp: 5,// 5
+outputOpenSource: 6,// 6
+outputOpenSourcePullDown: 7,// 7

|};



/**
 * Describes the possible types of change that can occur to the value of the general-purpose I/O (GPIO) pin for the GpioPin.ValueChanged event.
 */

declare  var Windows$Devices$Gpio$GpioPinEdge: {|
  +fallingEdge: 0,// 0
+risingEdge: 1,// 1

|};



/**
 * Describes the possible values for a general-purpose I/O (GPIO) pin.
 */

declare  var Windows$Devices$Gpio$GpioPinValue: {|
  +low: 0,// 0
+high: 1,// 1

|};



/**
 * Provides data about the GpioPin.ValueChanged event that occurs when the value of the general-purpose I/O (GPIO) pin changes, either because of an external stimulus when the pin is configured as an input, or when a value is written to the pin when the pin in configured as an output.
 */
declare class Windows$Devices$Gpio$GpioPinValueChangedEventArgs  {

/**
 * Gets the type of change that occurred to the value of the general-purpose I/O (GPIO) pin for the GpioPin.ValueChanged event.
 */
edge: $Values<typeof Windows$Devices$Gpio$GpioPinEdge>
}


/**
 * Describes the modes in which you can open a general-purpose I/O (GPIO) pin. These modes determine whether other connections to the GPIO pin can be opened while you have the pin open.
 */

declare  var Windows$Devices$Gpio$GpioSharingMode: {|
  +exclusive: 0,// 0
+sharedReadOnly: 1,// 1

|};



      declare var npm$namespace$Windows$Devices$Gpio$Provider: {
        
        
        
        GpioPinProviderValueChangedEventArgs: typeof Windows$Devices$Gpio$Provider$GpioPinProviderValueChangedEventArgs,
        ProviderGpioPinDriveMode: typeof npm$namespace$Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode,
ProviderGpioPinEdge: typeof npm$namespace$Windows$Devices$Gpio$Provider$ProviderGpioPinEdge,
ProviderGpioPinValue: typeof npm$namespace$Windows$Devices$Gpio$Provider$ProviderGpioPinValue,
ProviderGpioSharingMode: typeof npm$namespace$Windows$Devices$Gpio$Provider$ProviderGpioSharingMode,
      }
declare class Windows$Devices$Gpio$Provider$GpioPinProviderValueChangedEventArgs  {
edge: any
}


      declare var npm$namespace$Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode: {
        
        input: typeof Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$input,
output: typeof Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$output,
inputPullUp: typeof Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$inputPullUp,
inputPullDown: typeof Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$inputPullDown,
outputOpenDrain: typeof Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$outputOpenDrain,
outputOpenDrainPullUp: typeof Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$outputOpenDrainPullUp,
outputOpenSource: typeof Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$outputOpenSource,
outputOpenSourcePullDown: typeof Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$outputOpenSourcePullDown,
        
        
        
      }
declare var Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$input: any;

declare var Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$output: any;

declare var Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$inputPullUp: any;

declare var Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$inputPullDown: any;

declare var Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$outputOpenDrain: any;

declare var Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$outputOpenDrainPullUp: any;

declare var Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$outputOpenSource: any;

declare var Windows$Devices$Gpio$Provider$ProviderGpioPinDriveMode$outputOpenSourcePullDown: any;


      declare var npm$namespace$Windows$Devices$Gpio$Provider$ProviderGpioPinEdge: {
        
        fallingEdge: typeof Windows$Devices$Gpio$Provider$ProviderGpioPinEdge$fallingEdge,
risingEdge: typeof Windows$Devices$Gpio$Provider$ProviderGpioPinEdge$risingEdge,
        
        
        
      }
declare var Windows$Devices$Gpio$Provider$ProviderGpioPinEdge$fallingEdge: any;

declare var Windows$Devices$Gpio$Provider$ProviderGpioPinEdge$risingEdge: any;


      declare var npm$namespace$Windows$Devices$Gpio$Provider$ProviderGpioPinValue: {
        
        low: typeof Windows$Devices$Gpio$Provider$ProviderGpioPinValue$low,
high: typeof Windows$Devices$Gpio$Provider$ProviderGpioPinValue$high,
        
        
        
      }
declare var Windows$Devices$Gpio$Provider$ProviderGpioPinValue$low: any;

declare var Windows$Devices$Gpio$Provider$ProviderGpioPinValue$high: any;


      declare var npm$namespace$Windows$Devices$Gpio$Provider$ProviderGpioSharingMode: {
        
        exclusive: typeof Windows$Devices$Gpio$Provider$ProviderGpioSharingMode$exclusive,
sharedReadOnly: typeof Windows$Devices$Gpio$Provider$ProviderGpioSharingMode$sharedReadOnly,
        
        
        
      }
declare var Windows$Devices$Gpio$Provider$ProviderGpioSharingMode$exclusive: any;

declare var Windows$Devices$Gpio$Provider$ProviderGpioSharingMode$sharedReadOnly: any;


/**
 * Represents actions common to general-purpose I/O (GPIO) controller providers.
 */
declare interface Windows$Devices$Gpio$Provider$IGpioProvider {
getControllers: any
} 


      declare var npm$namespace$Windows$Devices$HumanInterfaceDevice: {
        
        
        HidCollectionType: typeof Windows$Devices$HumanInterfaceDevice$HidCollectionType,
HidReportType: typeof Windows$Devices$HumanInterfaceDevice$HidReportType,
        HidBooleanControl: typeof Windows$Devices$HumanInterfaceDevice$HidBooleanControl,
HidBooleanControlDescription: typeof Windows$Devices$HumanInterfaceDevice$HidBooleanControlDescription,
HidCollection: typeof Windows$Devices$HumanInterfaceDevice$HidCollection,
HidDevice: typeof Windows$Devices$HumanInterfaceDevice$HidDevice,
HidFeatureReport: typeof Windows$Devices$HumanInterfaceDevice$HidFeatureReport,
HidInputReport: typeof Windows$Devices$HumanInterfaceDevice$HidInputReport,
HidInputReportReceivedEventArgs: typeof Windows$Devices$HumanInterfaceDevice$HidInputReportReceivedEventArgs,
HidNumericControl: typeof Windows$Devices$HumanInterfaceDevice$HidNumericControl,
HidNumericControlDescription: typeof Windows$Devices$HumanInterfaceDevice$HidNumericControlDescription,
HidOutputReport: typeof Windows$Devices$HumanInterfaceDevice$HidOutputReport,
        
      }

/**
 * Represents a simple Boolean control on a HID device that returns on/off values. An example would be the LED light on a keyboard.
 */
declare class Windows$Devices$HumanInterfaceDevice$HidBooleanControl  {

/**
 * Retrieves a description of the given Boolean control.
 */
controlDescription: Windows$Devices$HumanInterfaceDevice$HidBooleanControlDescription;

/**
 * Retrieves the identifier for a given Boolean control.
 */
id: number;

/**
 * Retrieves a Boolean value indicating whether the given Boolean control is active.
 */
isActive: boolean;

/**
 * Retrieves the usage identifier associated with the given Boolean control.
 */
usageId: number;

/**
 * Retrieves the usage page for a given Boolean control.
 */
usagePage: number
}


/**
 * Describes a Boolean control for a given HID device.
 */
declare class Windows$Devices$HumanInterfaceDevice$HidBooleanControlDescription  {

/**
 * Retrieves the identifier for a given Boolean control.
 */
id: number;

/**
 * Retrieves the parent collection for a given Boolean control.
 */
parentCollections: Windows$Foundation$Collections$IVectorView<Windows$Devices$HumanInterfaceDevice$HidCollection>;

/**
 * Retrieves the identifier for the report associated with the given Boolean control.
 */
reportId: number;

/**
 * Retrieves the report type for the report associated with the given Boolean control.
 */
reportType: $Values<typeof Windows$Devices$HumanInterfaceDevice$HidReportType>;

/**
 * Retrieves the usage identifier associated with the given Boolean control.
 */
usageId: number;

/**
 * Retrieves the usage page associated with the given Boolean control.
 */
usagePage: number
}


/**
 * Retrieves the collection information for a group of related controls.
 */
declare class Windows$Devices$HumanInterfaceDevice$HidCollection  {

/**
 * Retrieves the identifier for a collection of HID controls.
 */
id: number;

/**
 * Retrieves the collection type.
 */
type: $Values<typeof Windows$Devices$HumanInterfaceDevice$HidCollectionType>;

/**
 * Retrieves the usage identifier for the given control collection.
 */
usageId: number;

/**
 * Retrieves the usage page for the given control collection.
 */
usagePage: number
}


/**
 * Identifies the relationship that defines a grouping of controls on the device.
 */

declare  var Windows$Devices$HumanInterfaceDevice$HidCollectionType: {|
  +physical: 0,// 0
+application: 1,// 1
+logical: 2,// 2
+report: 3,// 3
+namedArray: 4,// 4
+usageSwitch: 5,// 5
+usageModifier: 6,// 6
+other: 7,// 7

|};



/**
 * Represents a top-level collection and the corresponding device.
 */
declare class Windows$Devices$HumanInterfaceDevice$HidDevice  {

/**
 * Opens a handle to the device identified by the deviceId parameter. The acess type is specified by the accessMode parameter.
 * @param deviceId The DeviceInformation ID that identifies the HID device.
 * @param accessMode Specifies the access mode. The supported access modes are Read and ReadWrite.
 * @return A HidDevice object.
 */
static fromIdAsync(
deviceId: string,
accessMode: $Values<typeof Windows$Storage$FileAccessMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$HumanInterfaceDevice$HidDevice>;

/**
 * Retrieves an Advanced Query Syntax (AQS) string based on the given usagePage and usageId.
 * @param usagePage Specifies the usage page of the top-level collection for the given HID device.
 * @param usageId Specifies the usage identifier of the top-level collection for the given HID device.
 * @return An Advanced Query Syntax (AQS) string that represents a device selector.
 */
static getDeviceSelector(usagePage: number, usageId: number): string;

/**
 * Retrieves an Advanced Query Syntax (AQS) string based on the given usagePage, usageId, vendorId, and productId.
 * @param usagePage Specifies the usage page of the top-level collection for the given HID device.
 * @param usageId Specifies the usage identifier of the top-level collection for the given HID device.
 * @param vendorId Identifies the device vendor.
 * @param productId Identifies the product.
 * @return An Advanced Query Syntax (AQS) string that represents a device selector.
 */
static getDeviceSelector(
usagePage: number,
usageId: number,
vendorId: number,
productId: number): string;

/**
 * Closes the connection between the host and the given HID device.
 */
close(): void;

/**
 * Creates the only, or default, feature report that the host will send to the device.
 * @return A HidFeatureReport object.
 */
createFeatureReport(): Windows$Devices$HumanInterfaceDevice$HidFeatureReport;

/**
 * Creates a feature report, identified by the reportId parameter, that the host will send to the device.
 * @param reportId Identifies the report being created.
 * @return A HidFeatureReport object.
 */
createFeatureReport(reportId: number): Windows$Devices$HumanInterfaceDevice$HidFeatureReport;

/**
 * Creates the only, or default, output report that the host will send to the device.
 * @return A HidOutputReport object.
 */
createOutputReport(): Windows$Devices$HumanInterfaceDevice$HidOutputReport;

/**
 * Creates an output report, identified by the reportId parameter, that the host will send to the device.
 * @param reportId Identifies the report being created.
 * @return A HidOutputReport object.
 */
createOutputReport(reportId: number): Windows$Devices$HumanInterfaceDevice$HidOutputReport;

/**
 * Retrieves the descriptions of the boolean controls for the given HID device.
 * @param reportType Specifies the type of report for which the control descriptions are requested.
 * @param usagePage Identifies the usage page associated with the controls.
 * @param usageId Identifies the usage associated with the controls.
 * @return A vector of HidBooleanControlDescription objects.
 */
getBooleanControlDescriptions(
reportType: $Values<typeof Windows$Devices$HumanInterfaceDevice$HidReportType>,
usagePage: number,
usageId: number): Windows$Foundation$Collections$IVectorView<Windows$Devices$HumanInterfaceDevice$HidBooleanControlDescription>;

/**
 * Asynchronously retrieves a feature report, identified by the reportId parameter, for the given HID device.
 * @param reportId Identifies the requested feature report.
 * @return A HidFeatureReport object.
 */
getFeatureReportAsync(
reportId: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$HumanInterfaceDevice$HidFeatureReport>;

/**
 * Asynchronously retrieves the first, or default, feature report from the given HID device.
 * @return A HidFeatureReport object.
 */
getFeatureReportAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$HumanInterfaceDevice$HidFeatureReport>;

/**
 * Asynchronously retrieves the default, or first, input report from the given HID device.
 * @return A HidInputReport object.
 */
getInputReportAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$HumanInterfaceDevice$HidInputReport>;

/**
 * Asynchronously retrieves an input report, identified by the reportId parameter, from the given HID device.
 * @param reportId Identifies the requested input report.
 * @return A HidInputReport object.
 */
getInputReportAsync(
reportId: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$HumanInterfaceDevice$HidInputReport>;

/**
 * Retrieves the descriptions of the numeric controls for the given HID device.
 * @param reportType Specifies the type of report for which the control descriptions are requested.
 * @param usagePage Identifies the usage page associated with the controls.
 * @param usageId Identifies the usage associated with the controls.
 * @return A vector of HidNumericControlDescription objects.
 */
getNumericControlDescriptions(
reportType: $Values<typeof Windows$Devices$HumanInterfaceDevice$HidReportType>,
usagePage: number,
usageId: number): Windows$Foundation$Collections$IVectorView<Windows$Devices$HumanInterfaceDevice$HidNumericControlDescription>;

/**
 * Establishes an event listener which handles input reports issued by the device.
 */
oninputreportreceived: Windows$Foundation$TypedEventHandler<Windows$Devices$HumanInterfaceDevice$HidDevice, Windows$Devices$HumanInterfaceDevice$HidInputReportReceivedEventArgs>;
addEventListener(
type: "inputreportreceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$HumanInterfaceDevice$HidDevice, Windows$Devices$HumanInterfaceDevice$HidInputReportReceivedEventArgs>): void;
removeEventListener(
type: "inputreportreceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$HumanInterfaceDevice$HidDevice, Windows$Devices$HumanInterfaceDevice$HidInputReportReceivedEventArgs>): void;

/**
 * Gets the product identifier for the given HID device.
 */
productId: number;

/**
 * Sends an feature report asynchronously from the host to the device.
 * @param featureReport The feature report which the host sends to the device.
 * @return The result of the asynchronous operation.
 */
sendFeatureReportAsync(
featureReport: Windows$Devices$HumanInterfaceDevice$HidFeatureReport): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * Sends an output report asynchronously from the host to the device.
 * @param outputReport The output report which the host sends to the device.
 * @return Specifies the count of bytes written to the device.
 */
sendOutputReportAsync(
outputReport: Windows$Devices$HumanInterfaceDevice$HidOutputReport): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * Gets the usage identifier for the given HID device.
 */
usageId: number;

/**
 * Gets the usage page of the top-level collection.
 */
usagePage: number;

/**
 * Gets the vendor identifier for the given HID device.
 */
vendorId: number;

/**
 * Gets the version, or revision, number for the given HID device.
 */
version: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a feature report.
 */
declare class Windows$Devices$HumanInterfaceDevice$HidFeatureReport  {

/**
 * Retrieves, or sets, the data associated with a given feature report.
 */
data: Windows$Storage$Streams$IBuffer;

/**
 * Retrieves the Boolean control associated with the usagePage and usageIdparameter and found in the given feature report.
 * @param usagePage The usage page of the top-level collection for the given HID device.
 * @param usageId The usage identifier of the top-level collection for the given HID device.
 * @return A HidBooleanControl object.
 */
getBooleanControl(
usagePage: number,
usageId: number): Windows$Devices$HumanInterfaceDevice$HidBooleanControl;

/**
 * Retrieves the Boolean control described by the controlDescription parameter and found in the given feature report.
 * @param controlDescription A HidBooleanControlDescription object.
 * @return A HidBooleanControl object.
 */
getBooleanControlByDescription(
controlDescription: Windows$Devices$HumanInterfaceDevice$HidBooleanControlDescription): Windows$Devices$HumanInterfaceDevice$HidBooleanControl;

/**
 * Retrieves the numeric control associated with the usagePage and usageId parameters and found in the given feature report.
 * @param usagePage The usage page of the top-level collection for the given HID device.
 * @param usageId The usage identifier of the top-level collection for the given HID device.
 * @return A HidNumericControl object.
 */
getNumericControl(
usagePage: number,
usageId: number): Windows$Devices$HumanInterfaceDevice$HidNumericControl;

/**
 * Retrieves the numeric control described by the controlDescription parameter and found in the given feature report.
 * @param controlDescription A HidNumericControlDescription object.
 * @return A HidNumericControl object.
 */
getNumericControlByDescription(
controlDescription: Windows$Devices$HumanInterfaceDevice$HidNumericControlDescription): Windows$Devices$HumanInterfaceDevice$HidNumericControl;

/**
 * Retrieves the identifier associated with a given feature report.
 */
id: number
}


/**
 * Represents an input report.
 */
declare class Windows$Devices$HumanInterfaceDevice$HidInputReport  {

/**
 * Retrieves the currently activated Boolean controls for the given HID device.
 */
activatedBooleanControls: Windows$Foundation$Collections$IVectorView<Windows$Devices$HumanInterfaceDevice$HidBooleanControl>;

/**
 * Retrieves the data associated with a given input report.
 */
data: Windows$Storage$Streams$IBuffer;
getBooleanControl: any;

/**
 * Retrieves the Boolean control described by the controlDescription parameter and found in the given input report.
 * @param controlDescription A HidBooleanControlDescription object.
 * @return A HidBooleanControl object.
 */
getBooleanControlByDescription(
controlDescription: Windows$Devices$HumanInterfaceDevice$HidBooleanControlDescription): Windows$Devices$HumanInterfaceDevice$HidBooleanControl;
getNumericControl: any;

/**
 * Retrieves the numeric control described by the controlDescription parameter and found in the given input report.
 * @param controlDescription A HidNumericControlDescription object.
 * @return A HidNumericControl object.
 */
getNumericControlByDescription(
controlDescription: Windows$Devices$HumanInterfaceDevice$HidNumericControlDescription): Windows$Devices$HumanInterfaceDevice$HidNumericControl;

/**
 * Retrieves the identifier associated with a given input report.
 */
id: number;

/**
 * Retrieves the recently transitioned Boolean controls for the given HID device.
 */
transitionedBooleanControls: Windows$Foundation$Collections$IVectorView<Windows$Devices$HumanInterfaceDevice$HidBooleanControl>
}


/**
 * Represents the arguments which the HID API sends as part of an input-report event.
 */
declare class Windows$Devices$HumanInterfaceDevice$HidInputReportReceivedEventArgs  {

/**
 * Retrieves the input report.
 */
report: Windows$Devices$HumanInterfaceDevice$HidInputReport
}


/**
 * Represents a numeric control on a HID device that returns a range of values. An example would be the volume control on a speaker.
 */
declare class Windows$Devices$HumanInterfaceDevice$HidNumericControl  {

/**
 * Retrieves a control description for the given numeric control.
 */
controlDescription: Windows$Devices$HumanInterfaceDevice$HidNumericControlDescription;

/**
 * Retrieves the identifier for the given numeric control.
 */
id: number;

/**
 * Retrieves a Boolean value that indicates whether the given numeric control is grouped with other, related controls.
 */
isGrouped: boolean;

/**
 * Retrieves, or sets, a scaled numeric-value for the given control.
 */
scaledValue: number;

/**
 * Retrieves the usage identifier for the given numeric control.
 */
usageId: number;

/**
 * Retrieves the usage page for the given numeric control.
 */
usagePage: number;

/**
 * Retrieves, or sets, the numeric value for a given control.
 */
value: number
}


/**
 * Describes a numeric control for a given HID device.
 */
declare class Windows$Devices$HumanInterfaceDevice$HidNumericControlDescription  {

/**
 * Retrieves a Boolean value which indicates whether the control supports a null, or out-of-range, value.
 */
hasNull: boolean;

/**
 * Retrieves the identifier for a given numeric control.
 */
id: number;

/**
 * Retrieves a Boolean value indicating whether the given control values are absolute or relative.
 */
isAbsolute: boolean;

/**
 * Retrieves the logical maximum value for the given control.
 */
logicalMaximum: number;

/**
 * Retrieves the logical minimum value for the control.
 */
logicalMinimum: number;

/**
 * Retrieves the parent collections for a given numeric control.
 */
parentCollections: Windows$Foundation$Collections$IVectorView<Windows$Devices$HumanInterfaceDevice$HidCollection>;

/**
 * Retrieves the physical maximum-value for the given control.
 */
physicalMaximum: number;

/**
 * Retrieves the physical minimum-value for the given control.
 */
physicalMinimum: number;

/**
 * Retrieves the number of reports associated with the given control.
 */
reportCount: number;

/**
 * Retrieves the identifier for the report associated with the given numeric control.
 */
reportId: number;

/**
 * Retrieves the size, in bytes, of the given numeric control.
 */
reportSize: number;

/**
 * Retrieves the type of report associated with the given numeric control.
 */
reportType: $Values<typeof Windows$Devices$HumanInterfaceDevice$HidReportType>;

/**
 * Retrieves the unit associated with the given numeric control.
 */
unit: number;

/**
 * Retrieves the unit exponent for the given numeric control.
 */
unitExponent: number;

/**
 * Retrieves the usage identifier associated with the given numeric control.
 */
usageId: number;

/**
 * Retrieves the usage page associated with the given numeric control.
 */
usagePage: number
}


/**
 * Represents an output report.
 */
declare class Windows$Devices$HumanInterfaceDevice$HidOutputReport  {

/**
 * Retrieves, or sets, the data associated with a given output report.
 */
data: Windows$Storage$Streams$IBuffer;
getBooleanControl: any;

/**
 * Retrieves the boolean control associated with the given controlDescription.
 * @param controlDescription Describes the Boolean control.
 * @return A HidBooleanControl object.
 */
getBooleanControlByDescription(
controlDescription: Windows$Devices$HumanInterfaceDevice$HidBooleanControlDescription): Windows$Devices$HumanInterfaceDevice$HidBooleanControl;
getNumericControl: any;

/**
 * Retrieves the numeric control associated with the given controlDescription.
 * @param controlDescription Describes the numeric control.
 * @return A HidNumericControl object.
 */
getNumericControlByDescription(
controlDescription: Windows$Devices$HumanInterfaceDevice$HidNumericControlDescription): Windows$Devices$HumanInterfaceDevice$HidNumericControl;

/**
 * Retrieves the identifier associated with a given output report.
 */
id: number
}


/**
 * Specifies a HID report type.
 */

declare  var Windows$Devices$HumanInterfaceDevice$HidReportType: {|
  +input: 0,// 0
+output: 1,// 1
+feature: 2,// 2

|};



      declare var npm$namespace$Windows$Devices$I2c: {
        
        
        I2cBusSpeed: typeof Windows$Devices$I2c$I2cBusSpeed,
I2cSharingMode: typeof Windows$Devices$I2c$I2cSharingMode,
I2cTransferStatus: typeof Windows$Devices$I2c$I2cTransferStatus,
        I2cConnectionSettings: typeof Windows$Devices$I2c$I2cConnectionSettings,
I2cController: typeof Windows$Devices$I2c$I2cController,
I2cDevice: typeof Windows$Devices$I2c$I2cDevice,
        Provider: typeof npm$namespace$Windows$Devices$I2c$Provider,
      }

/**
 * Describes the bus speeds that are available for connecting to an inter-integrated circuit (IC) device. The bus speed is the frequency at which to clock the IC bus when accessing the device.
 */

declare  var Windows$Devices$I2c$I2cBusSpeed: {|
  +standardMode: 0,// 0
+fastMode: 1,// 1

|};



/**
 * Represents the connection settings you want to use for an inter-integrated circuit (IC) device.
 */
declare class Windows$Devices$I2c$I2cConnectionSettings  {

/**
 * Creates and initializes a new instance of the I2cConnectionSettings class for inter-integrated circuit (IC) device with specified bus address, using the default settings of the standard mode for the bus speed and exclusive sharing mode.
 * @param slaveAddress The bus address of the inter-integrated circuit (IC) device to which the settings of the I2cConnectionSettings should apply. Only 7-bit addressing is supported, so the range of values that are valid is from 8 to 119.
 */
constructor(slaveAddress: number): this;

/**
 * Gets or sets the bus speed to use for connecting to an inter-integrated circuit (IC) device. The bus speed is the frequency at which to clock the IC bus when accessing the device.
 */
busSpeed: $Values<typeof Windows$Devices$I2c$I2cBusSpeed>;

/**
 * Gets or sets the sharing mode to use to connect to the inter-integrated circuit (IC) bus address. This mode determines whether other connections to the IC bus address can be opened while you are connect to the IC bus address.
 */
sharingMode: $Values<typeof Windows$Devices$I2c$I2cSharingMode>;

/**
 * Gets or sets the bus address of the inter-integrated circuit (IC) device.
 */
slaveAddress: number
}


/**
 * Represents the IC controller for the system.
 */
declare class Windows$Devices$I2c$I2cController  {

/**
 * Gets all the IC controllers that are on the system.
 * @param provider The IC provider for the controllers on the system.
 * @return When the method completes successfully, it returns a list of values that represent the available IC controllers on the system.
 */
static getControllersAsync(
provider: Windows$Devices$I2c$Provider$II2cProvider): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the default IC controller on the system.
 * @return The default IC controller on the system, or null if the system has no IC controller.
 */
static getDefaultAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$I2c$I2cController>;

/**
 * Gets the IC device with the specified settings.
 * @param settings The desired connection settings.
 * @return The IC device.
 */
getDevice(
settings: Windows$Devices$I2c$I2cConnectionSettings): Windows$Devices$I2c$I2cDevice
}


/**
 * Represents a communications channel to a device on an inter-integrated circuit (IC) bus.
 */
declare class Windows$Devices$I2c$I2cDevice  {

/**
 * Retrieves an I2cDevice object asynchronously for the inter-integrated circuit (IC) bus controller that has the specified plug and play device identifier, using the specified connection settings.
 * @param deviceId The plug and play device identifier of the IC bus controller for which you want to create an I2cDevice object.
 * @param settings The connection settings to use for communication with the IC bus controller that deviceId specifies.
 * @return An asynchronous operation that returns the I2cDevice object.
 */
static fromIdAsync(
deviceId: string,
settings: Windows$Devices$I2c$I2cConnectionSettings): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$I2c$I2cDevice>;

/**
 * Retrieves an Advanced Query Syntax (AQS) string for the inter-integrated circuit (IC) bus that has the specified friendly name. You can use this string with the DeviceInformation.FindAllAsync method to get a DeviceInformation object for that bus.
 * @param friendlyName A friendly name for the particular IC bus on a particular hardware platform for which you want to get the AQS string.
 * @return An AQS string for the IC bus that friendlyName specifies, which you can use with the DeviceInformation.FindAllAsync method to get a DeviceInformation object for that bus.
 */
static getDeviceSelector(friendlyName: string): string;

/**
 * Retrieves an Advanced Query Syntax (AQS) string for all of the inter-integrated circuit (IC) bus controllers on the system. You can use this string with the DeviceInformation.FindAllAsync method to get DeviceInformation objects for those bus controllers.
 * @return An AQS string for all of the IC bus controllers on the system, which you can use with the DeviceInformation.FindAllAsync method to get DeviceInformation objects for those bus controllers.
 */
static getDeviceSelector(): string;

/**
 * Closes the connection to the inter-integrated circuit (IC) device.
 */
close(): void;

/**
 * Gets the connection settings used for communication with the inter-integrated circuit (IC) device.
 */
connectionSettings: Windows$Devices$I2c$I2cConnectionSettings;

/**
 * Gets the plug and play device identifier of the inter-integrated circuit (IC) bus controller for the device.
 */
deviceId: string;

/**
 * Reads data from the inter-integrated circuit (IC) bus on which the device is connected into the specified buffer.
 * @param buffer The buffer to which you want to read the data from the IC bus. The length of the buffer determines how much data to request from the device.
 */
read(buffer: number[]): void;

/**
 * Reads data from the inter-integrated circuit (IC) bus on which the device is connected into the specified buffer, and returns information about the success of the operation that you can use for error handling.
 * @param buffer The buffer to which you want to read the data from the IC bus. The length of the buffer determines how much data to request from the device.
 * @return A structure that contains information about the success of the read operation and the actual number of bytes that the operation read into the buffer.
 */
readPartial(buffer: number[]): Windows$Devices$I2c$I2cTransferResult;

/**
 * Writes data to the inter-integrated circuit (IC) bus on which the device is connected, based on the bus address specified in the I2cConnectionSetting s object that you used to create the I2cDevice object.
 * @param buffer A buffer that contains the data that you want to write to the IC device. This data should not include the bus address.
 */
write(buffer: number[]): void;

/**
 * Writes data to the inter-integrated circuit (IC) bus on which the device is connected, and returns information about the success of the operation that you can use for error handling.
 * @param buffer A buffer that contains the data that you want to write to the IC device. This data should not include the bus address.
 * @return A structure that contains information about the success of the write operation and the actual number of bytes that the operation wrote into the buffer.
 */
writePartial(buffer: number[]): Windows$Devices$I2c$I2cTransferResult;

/**
 * Performs an atomic operation to write data to and then read data from the inter-integrated circuit (IC) bus on which the device is connected, and sends a restart condition between the write and read operations.
 * @param writeBuffer A buffer that contains the data that you want to write to the IC device. This data should not include the bus address.
 * @param readBuffer The buffer to which you want to read the data from the IC bus. The length of the buffer determines how much data to request from the device.
 */
writeRead(writeBuffer: number[], readBuffer: number[]): void;

/**
 * Performs an atomic operation to write data to and then read data from the inter-integrated circuit (IC) bus on which the device is connected, and returns information about the success of the operation that you can use for error handling.
 * @param writeBuffer A buffer that contains the data that you want to write to the IC device. This data should not include the bus address.
 * @param readBuffer The buffer to which you want to read the data from the IC bus. The length of the buffer determines how much data to request from the device.
 * @return A structure that contains information about whether both the read and write parts of the operation succeeded and the sum of the actual number of bytes that the operation wrote and the actual number of bytes that the operation read.
 */
writeReadPartial(
writeBuffer: number[],
readBuffer: number[]): Windows$Devices$I2c$I2cTransferResult
}


/**
 * Describes the modes in which you can connect to an inter-integrated circuit (IC) bus address. These modes determine whether other connections to the IC bus address can be opened while you are connected to the IC bus address.
 */

declare  var Windows$Devices$I2c$I2cSharingMode: {|
  +exclusive: 0,// 0
+shared: 1,// 1

|};



/**
 * Describes whether the data transfers that the ReadPartial , WritePartial , or WriteReadPartial method performed succeeded, or provides the reason that the transfers did not succeed.
 */

declare  var Windows$Devices$I2c$I2cTransferStatus: {|
  +fullTransfer: 0,// 0
+partialTransfer: 1,// 1
+slaveAddressNotAcknowledged: 2,// 2

|};



      declare var npm$namespace$Windows$Devices$I2c$Provider: {
        
        
        
        ProviderI2cConnectionSettings: typeof Windows$Devices$I2c$Provider$ProviderI2cConnectionSettings,
        ProviderI2cBusSpeed: typeof npm$namespace$Windows$Devices$I2c$Provider$ProviderI2cBusSpeed,
ProviderI2cSharingMode: typeof npm$namespace$Windows$Devices$I2c$Provider$ProviderI2cSharingMode,
ProviderI2cTransferStatus: typeof npm$namespace$Windows$Devices$I2c$Provider$ProviderI2cTransferStatus,
      }

      declare var npm$namespace$Windows$Devices$I2c$Provider$ProviderI2cBusSpeed: {
        
        standardMode: typeof Windows$Devices$I2c$Provider$ProviderI2cBusSpeed$standardMode,
fastMode: typeof Windows$Devices$I2c$Provider$ProviderI2cBusSpeed$fastMode,
        
        
        
      }
declare var Windows$Devices$I2c$Provider$ProviderI2cBusSpeed$standardMode: any;

declare var Windows$Devices$I2c$Provider$ProviderI2cBusSpeed$fastMode: any;

declare class Windows$Devices$I2c$Provider$ProviderI2cConnectionSettings  {
busSpeed: any;
sharingMode: any;
slaveAddress: any
}


      declare var npm$namespace$Windows$Devices$I2c$Provider$ProviderI2cSharingMode: {
        
        exclusive: typeof Windows$Devices$I2c$Provider$ProviderI2cSharingMode$exclusive,
shared: typeof Windows$Devices$I2c$Provider$ProviderI2cSharingMode$shared,
        
        
        
      }
declare var Windows$Devices$I2c$Provider$ProviderI2cSharingMode$exclusive: any;

declare var Windows$Devices$I2c$Provider$ProviderI2cSharingMode$shared: any;


      declare var npm$namespace$Windows$Devices$I2c$Provider$ProviderI2cTransferStatus: {
        
        fullTransfer: typeof Windows$Devices$I2c$Provider$ProviderI2cTransferStatus$fullTransfer,
partialTransfer: typeof Windows$Devices$I2c$Provider$ProviderI2cTransferStatus$partialTransfer,
slaveAddressNotAcknowledged: typeof Windows$Devices$I2c$Provider$ProviderI2cTransferStatus$slaveAddressNotAcknowledged,
        
        
        
      }
declare var Windows$Devices$I2c$Provider$ProviderI2cTransferStatus$fullTransfer: any;

declare var Windows$Devices$I2c$Provider$ProviderI2cTransferStatus$partialTransfer: any;

declare var Windows$Devices$I2c$Provider$ProviderI2cTransferStatus$slaveAddressNotAcknowledged: any;


/**
 * Represents actions common to all IC providers.
 */
declare interface Windows$Devices$I2c$Provider$II2cProvider {
getControllersAsync: any
} 


/**
 * Provides information about whether the data transfers that the ReadPartial , WritePartial , or WriteReadPartial method performed succeeded, and the actual number of bytes the method transferred.
 */
declare interface Windows$Devices$I2c$I2cTransferResult {

/**
 * The actual number of bytes that the operation actually transferred. The following table describes what this value represents for each method.
 */
bytesTransferred: number,

/**
 * An enumeration value that indicates if the read or write operation transferred the full number of bytes that the method requested, or the reason that the full transfer did not succeed. For WriteReadPartial , the value indicates whether the data for both the write and the read operations was entirely transferred.
 */
status: $Values<typeof Windows$Devices$I2c$I2cTransferStatus>
} 


      declare var npm$namespace$Windows$Devices$Input: {
        
        
        PointerDeviceType: typeof Windows$Devices$Input$PointerDeviceType,
        KeyboardCapabilities: typeof Windows$Devices$Input$KeyboardCapabilities,
MouseCapabilities: typeof Windows$Devices$Input$MouseCapabilities,
MouseDevice: typeof Windows$Devices$Input$MouseDevice,
MouseEventArgs: typeof Windows$Devices$Input$MouseEventArgs,
PointerDevice: typeof Windows$Devices$Input$PointerDevice,
TouchCapabilities: typeof Windows$Devices$Input$TouchCapabilities,
        
      }

/**
 * Supports the ability to determine the capabilities of any connected hardware keyboards.
 */
declare class Windows$Devices$Input$KeyboardCapabilities  {

/**
 * Initializes a new instance of the KeyboardCapabilities class.
 */
constructor(): this;

/**
 * Gets a value that indicates whether a hardware keyboard is detected.
 */
keyboardPresent: number
}


/**
 * Supports the ability to determine the capabilities of any connected mouse devices.
 */
declare class Windows$Devices$Input$MouseCapabilities  {

/**
 * Initializes a new instance of the MouseCapabilities class.
 */
constructor(): this;

/**
 * Gets a value indicating whether any of the mice connected to the computer have a scroll wheel that tilts left and right (usually for horizontal scrolling).
 */
horizontalWheelPresent: number;

/**
 * Gets a value that indicates whether a mouse device is detected.
 */
mousePresent: number;

/**
 * Gets a value representing the number of buttons on the mouse. If multiple mice are present, it returns the number of buttons of the mouse which has maximum number of buttons.
 */
numberOfButtons: number;

/**
 * Gets a value indicating whether any of the mice connected to the computer has swapped left and right buttons.
 */
swapButtons: number;

/**
 * Gets a value indicating whether any of the mice connected to the computer have a scroll wheel that rolls up and down (usually for vertical scrolling).
 */
verticalWheelPresent: number
}


/**
 * Supports the ability to identify and track connected mouse devices.
 */
declare class Windows$Devices$Input$MouseDevice  {

/**
 * Retrieves the mouse device that is associated with the current view.
 * @return The mouse device.
 */
static getForCurrentView(): Windows$Devices$Input$MouseDevice;

/**
 * Occurs when the mouse pointer is moved.
 */
onmousemoved: Windows$Foundation$TypedEventHandler<Windows$Devices$Input$MouseDevice, Windows$Devices$Input$MouseEventArgs>;
addEventListener(
type: "mousemoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Input$MouseDevice, Windows$Devices$Input$MouseEventArgs>): void;
removeEventListener(
type: "mousemoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Input$MouseDevice, Windows$Devices$Input$MouseEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Contains event data for the MouseMoved event.
 */
declare class Windows$Devices$Input$MouseEventArgs  {

/**
 * Gets a value that indicates the change in the screen location of the mouse pointer since the last mouse event.
 */
mouseDelta: Windows$Devices$Input$MouseDelta
}


/**
 * Supports the ability to identify the connected pointer devices and determine their capabilities.
 */
declare class Windows$Devices$Input$PointerDevice  {

/**
 * Gets information about the pointer device associated with the specified input pointer ID.
 * @param pointerId The ID of the pointer input.
 * @return The PointerDevice object that represents the associated pointer device.
 */
static getPointerDevice(pointerId: number): Windows$Devices$Input$PointerDevice;

/**
 * Gets information about the pointer devices attached to the system.
 * @return The collection of PointerDevice objects that represent the pointer devices attached to the system.
 */
static getPointerDevices(
): Windows$Foundation$Collections$IVectorView<Windows$Devices$Input$PointerDevice>;

/**
 * Gets a value indicating whether the pointer device is an integrated device. For example, a video display with an integrated touch digitizer compared to an external pen/stylus digitizer.
 */
isIntegrated: boolean;

/**
 * Gets a value indicating the maximum number of contacts supported by the input device.
 */
maxContacts: number;
maxPointersWithZDistance: any;

/**
 * Gets the coordinates of the bounding rectangle supported by the input device.
 */
physicalDeviceRect: Windows$Foundation$Rect;

/**
 * Gets the pointer device type.
 */
pointerDeviceType: $Values<typeof Windows$Devices$Input$PointerDeviceType>;

/**
 * Gets the screen coordinates that are mapped to the bounding rectangle supported by the input device.
 */
screenRect: Windows$Foundation$Rect;

/**
 * Gets a collection containing the supported pointer device usages .
 */
supportedUsages: Windows$Foundation$Collections$IVectorView<Windows$Devices$Input$PointerDeviceUsage>
}


/**
 * Enumerates pointer device types.
 */

declare  var Windows$Devices$Input$PointerDeviceType: {|
  +touch: 0,// 0
+pen: 1,// 1
+mouse: 2,// 2

|};



/**
 * Supports the ability to determine the touch capabilities of any connected touch digitizers.
 */
declare class Windows$Devices$Input$TouchCapabilities  {

/**
 * Initializes a new instance of the TouchCapabilities class.
 */
constructor(): this;

/**
 * Gets the minimum number of contacts supported by all the digitizers.
 */
contacts: number;

/**
 * Gets a value that indicates whether a touch digitizer is detected.
 */
touchPresent: number
}


/**
 * Identifies the change in screen location of the mouse pointer, relative to the location of the last mouse event.
 */
declare interface Windows$Devices$Input$MouseDelta {

/**
 * The x-coordinate of the mouse pointer, relative to the location of the last mouse event.
 */
x: number,

/**
 * The y-coordinate of the mouse pointer, relative to the location of the last mouse event.
 */
y: number
} 


/**
 * Identifies the Human Interface Device (HID) usage details for the input device.
 */
declare interface Windows$Devices$Input$PointerDeviceUsage {

/**
 * The maximum logical value for Usage.
 */
maxLogical: number,

/**
 * The maximum physical value for Usage.
 */
maxPhysical: number,

/**
 * The minimum logical value for Usage.
 */
minLogical: number,

/**
 * The minimum physical value for Usage.
 */
minPhysical: number,

/**
 * The multiplier used to convert the usage value reported by the device to a physical value in units of Unit. (Valid only for usages that indicate a static or dynamic value associated with a control, such as pressure or width and height of the touch contact.)
 */
physicalMultiplier: number,

/**
 * The HID unit of measure.
 */
unit: number,

/**
 * The HID pointer device usage ID that specifies a device or property in the UsagePage. For example, 0x04 indicates a touch screen device and 0x47 indicates touch confidence.
 */
usage: number,

/**
 * The HID usage page of the pointer device.
 */
usagePage: number
} 


      declare var npm$namespace$Windows$Devices$Lights: {
        
        
        
        Lamp: typeof Windows$Devices$Lights$Lamp,
LampAvailabilityChangedEventArgs: typeof Windows$Devices$Lights$LampAvailabilityChangedEventArgs,
        
      }

/**
 * Represents a lamp device.
 */
declare class Windows$Devices$Lights$Lamp  {

/**
 * Gets a Lamp object representing the lamp device with the specified ID.
 * @param deviceId The ID of the requested lamp device.
 * @return An asynchronous operation that returns a Lamp object upon successful completion.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Lights$Lamp>;

/**
 * Gets a Lamp object representing the default lamp for the device.
 * @return An asynchronous operation that returns a Lamp object upon successful completion.
 */
static getDefaultAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Lights$Lamp>;

/**
 * Returns the class selection string that you can use to enumerate lamp devices.
 * @return The class selection string for lamp devices.
 */
static getDeviceSelector(): string;

/**
 * Gets or sets a value indicating the current brightness level of the lamp, where 0.0 is completely off and 1.0 is maximum brightness.
 */
brightnessLevel: number;

/**
 * Releases the lamp device.
 */
close(): void;

/**
 * Gets or sets the color of the lamp.
 */
color: Windows$UI$Color;

/**
 * Gets the DeviceInformation Id for a lamp device.
 */
deviceId: string;

/**
 * Gets a value indicating whether you can set the Color property of the lamp device.
 */
isColorSettable: boolean;

/**
 * Gets a value indicating whether the lamp device is enabled.
 */
isEnabled: boolean;

/**
 * Occurs when the availability of the lamp device changes.
 */
onavailabilitychanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Lights$Lamp, Windows$Devices$Lights$LampAvailabilityChangedEventArgs>;
addEventListener(
type: "availabilitychanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Lights$Lamp, Windows$Devices$Lights$LampAvailabilityChangedEventArgs>): void;
removeEventListener(
type: "availabilitychanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Lights$Lamp, Windows$Devices$Lights$LampAvailabilityChangedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the AvailabilityChanged event.
 */
declare class Windows$Devices$Lights$LampAvailabilityChangedEventArgs  {

/**
 * Gets a value indicating whether the lamp device that triggered the event is available.
 */
isAvailable: boolean
}

declare class Windows$Devices$LowLevelDevicesAggregateProvider  {
adcControllerProvider: any;
gpioControllerProvider: any;
i2cControllerProvider: any;
pwmControllerProvider: any;
spiControllerProvider: any
}

declare class Windows$Devices$LowLevelDevicesController  {
static defaultProvider: any
}


      declare var npm$namespace$Windows$Devices$Midi: {
        
        
        MidiMessageType: typeof Windows$Devices$Midi$MidiMessageType,
        MidiActiveSensingMessage: typeof Windows$Devices$Midi$MidiActiveSensingMessage,
MidiChannelPressureMessage: typeof Windows$Devices$Midi$MidiChannelPressureMessage,
MidiContinueMessage: typeof Windows$Devices$Midi$MidiContinueMessage,
MidiControlChangeMessage: typeof Windows$Devices$Midi$MidiControlChangeMessage,
MidiInPort: typeof Windows$Devices$Midi$MidiInPort,
MidiMessageReceivedEventArgs: typeof Windows$Devices$Midi$MidiMessageReceivedEventArgs,
MidiNoteOffMessage: typeof Windows$Devices$Midi$MidiNoteOffMessage,
MidiNoteOnMessage: typeof Windows$Devices$Midi$MidiNoteOnMessage,
MidiOutPort: typeof Windows$Devices$Midi$MidiOutPort,
MidiPitchBendChangeMessage: typeof Windows$Devices$Midi$MidiPitchBendChangeMessage,
MidiPolyphonicKeyPressureMessage: typeof Windows$Devices$Midi$MidiPolyphonicKeyPressureMessage,
MidiProgramChangeMessage: typeof Windows$Devices$Midi$MidiProgramChangeMessage,
MidiSongPositionPointerMessage: typeof Windows$Devices$Midi$MidiSongPositionPointerMessage,
MidiSongSelectMessage: typeof Windows$Devices$Midi$MidiSongSelectMessage,
MidiStartMessage: typeof Windows$Devices$Midi$MidiStartMessage,
MidiStopMessage: typeof Windows$Devices$Midi$MidiStopMessage,
MidiSynthesizer: typeof Windows$Devices$Midi$MidiSynthesizer,
MidiSystemExclusiveMessage: typeof Windows$Devices$Midi$MidiSystemExclusiveMessage,
MidiSystemResetMessage: typeof Windows$Devices$Midi$MidiSystemResetMessage,
MidiTimeCodeMessage: typeof Windows$Devices$Midi$MidiTimeCodeMessage,
MidiTimingClockMessage: typeof Windows$Devices$Midi$MidiTimingClockMessage,
MidiTuneRequestMessage: typeof Windows$Devices$Midi$MidiTuneRequestMessage,
        
      }

/**
 * Represents a MIDI message that specifies active sensing.
 */
declare class Windows$Devices$Midi$MidiActiveSensingMessage  {

/**
 * Creates a new MidiActiveSensingMessage object.
 */
constructor(): this;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
}


/**
 * Represents a MIDI message that specifies the channel pressure.
 */
declare class Windows$Devices$Midi$MidiChannelPressureMessage  {

/**
 * Creates a new MidiChannelPressureMessage object.
 * @param channel The channel from 0-15 that this message applies to.
 * @param pressure The pressure from 0-127.
 */
constructor(channel: number, pressure: number): this;

/**
 * Gets the channel from 0-15 that this message applies to.
 */
channel: number;

/**
 * Gets the pressure from 0-127.
 */
pressure: number;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
}


/**
 * Represents a MIDI message that specifies a continue message.
 */
declare class Windows$Devices$Midi$MidiContinueMessage  {

/**
 * Creates a new MidiContinueMessage object.
 */
constructor(): this;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
}


/**
 * Represents a MIDI message that specifies a control change.
 */
declare class Windows$Devices$Midi$MidiControlChangeMessage  {

/**
 * Creates a new MidiControlChangeMessage object.
 * @param channel The channel from 0-15 that this message applies to.
 * @param controller The controller from 0-127 to receive this message.
 * @param controlValue The value from 0-127 to apply to the controller .
 */
constructor(channel: number, controller: number, controlValue: number): this;

/**
 * Gets the channel from 0-15 that this message applies to.
 */
channel: number;

/**
 * Gets the value from 0-127 to apply to the controller .
 */
controlValue: number;

/**
 * Gets controller from 0-127 to receive this message.
 */
controller: number;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
}


/**
 * Represents a port used to receive MIDI messages from a MIDI device.
 */
declare class Windows$Devices$Midi$MidiInPort  {

/**
 * Creates a MidiInPort object for the specified device.
 * @param deviceId The device ID, which can be obtained by enumerating the devices on the system Windows.Devices.Enumeration.DeviceInformation.FindAllAsync .
 * @return The asynchronous operation. Upon completion, IAsyncOperation.GetResults returns a MidiInPort object.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Midi$MidiInPort>;

/**
 * Gets a query string that can be used to enumerate all MidiInPort objects on the system.
 * @return The query string used to enumerate the MidiInPort objects on the system.
 */
static getDeviceSelector(): string;

/**
 * Closes the MidiInPort .
 */
close(): void;

/**
 * Gets the id of the device that was used to initialize the MidiInPort .
 */
deviceId: string;

/**
 * Occurs when the MidiInPort receives data.
 */
onmessagereceived: Windows$Foundation$TypedEventHandler<Windows$Devices$Midi$MidiInPort, Windows$Devices$Midi$MidiMessageReceivedEventArgs>;
addEventListener(
type: "messagereceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Midi$MidiInPort, Windows$Devices$Midi$MidiMessageReceivedEventArgs>): void;
removeEventListener(
type: "messagereceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Midi$MidiInPort, Windows$Devices$Midi$MidiMessageReceivedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the MessageReceived event.
 */
declare class Windows$Devices$Midi$MidiMessageReceivedEventArgs  {

/**
 * The MIDI message.
 */
message: Windows$Devices$Midi$IMidiMessage
}


/**
 * Provides constants used to map MIDI message types into their corresponding byte codes.
 */

declare  var Windows$Devices$Midi$MidiMessageType: {|
  +none: 0,// 0
+noteOff: 1,// 1
+noteOn: 2,// 2
+polyphonicKeyPressure: 3,// 3
+controlChange: 4,// 4
+programChange: 5,// 5
+channelPressure: 6,// 6
+pitchBendChange: 7,// 7
+systemExclusive: 8,// 8
+midiTimeCode: 9,// 9
+songPositionPointer: 10,// 10
+songSelect: 11,// 11
+tuneRequest: 12,// 12
+timingClock: 13,// 13
+start: 14,// 14
+continue: 15,// 15
+stop: 16,// 16
+activeSensing: 17,// 17
+systemReset: 18,// 18

|};



/**
 * Represents a MIDI messages that specifies a MIDI note to turn off.
 */
declare class Windows$Devices$Midi$MidiNoteOffMessage  {

/**
 * Creates a new MidiNoteOffMessage object.
 * @param channel The channel from 0-15 that this message applies to.
 * @param note The note which is specified as a value from 0-127.
 * @param velocity The velocity which is specified as a value from 0-127.
 */
constructor(channel: number, note: number, velocity: number): this;

/**
 * Gets the channel from 0-15 that this message applies to.
 */
channel: number;

/**
 * Gets the note to turn off which is specified as a value from 0-127.
 */
note: number;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>;

/**
 * Gets the value of the velocity from 0-127.
 */
velocity: number
}


/**
 * Represents a MIDI message that specifies a MIDI note to turn on.
 */
declare class Windows$Devices$Midi$MidiNoteOnMessage  {

/**
 * Creates a new MidiNoteOnMessage object.
 * @param channel The channel from 0-15 that this message applies to.
 * @param note The note which is specified as a value from 0-127.
 * @param velocity The velocity which is specified as a value from 0-127.
 */
constructor(channel: number, note: number, velocity: number): this;

/**
 * Gets the channel from 0-15 that this message applies to.
 */
channel: number;

/**
 * Gets the note to turn on which is specified as a value from 0-127.
 */
note: number;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>;

/**
 * Gets the value of the velocity from 0-127.
 */
velocity: number
}


/**
 * Represents a port used to send MIDI messages to a MIDI device.
 */
declare class Windows$Devices$Midi$MidiOutPort  {

/**
 * Creates a MidiOutPort object for the specified device.
 * @param deviceId The device ID, which can be obtained by enumerating the devices on the system Windows.Devices.Enumeration.DeviceInformation.FindAllAsync .
 * @return The asynchronous operation. Upon completion, IAsyncOperation.GetResults returns a MidiOutPort object.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Midi$IMidiOutPort>;

/**
 * Gets a query string that can be used to enumerate all MidiOutPort objects on the system.
 * @return The query string used to enumerate the MidiOutPort objects on the system.
 */
static getDeviceSelector(): string;

/**
 * Closes the MidiOutPort .
 */
close(): void;

/**
 * Gets the id of the device that was used to initialize the MidiOutPort .
 */
deviceId: string;

/**
 * Send the specified data buffer to the device associated with this MidiOutPort .
 * @param midiData The data to send to the device.
 */
sendBuffer(midiData: Windows$Storage$Streams$IBuffer): void;

/**
 * Send the data in the specified MIDI message to the device associated with this MidiOutPort .
 * @param midiMessage The MIDI message to send to the device.
 */
sendMessage(midiMessage: Windows$Devices$Midi$IMidiMessage): void
}


/**
 * Represents a MIDI message that specifies a pitch bend change.
 */
declare class Windows$Devices$Midi$MidiPitchBendChangeMessage  {

/**
 * Creates a new MidiPitchBendChangeMessage object.
 * @param channel The channel from 0-15 that this message applies to.
 * @param bend The pitch bend value which is specified as a 14-bit value from 0-16383.
 */
constructor(channel: number, bend: number): this;

/**
 * Gets the pitch bend value which is specified as a 14-bit value from 0-16383.
 */
bend: number;

/**
 * Gets the channel from 0-15 that this message applies to.
 */
channel: number;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
}


/**
 * Represents a MIDI message that specifies the polyphonic key pressure.
 */
declare class Windows$Devices$Midi$MidiPolyphonicKeyPressureMessage  {

/**
 * Creates a new MidiPolyphonicKeyPressureMessage object.
 * @param channel The channel from 0-15 that this message applies to.
 * @param note The note which is specified as a value from 0-127.
 * @param pressure The polyphonic key pressure which is specified as a value from 0-127.
 */
constructor(channel: number, note: number, pressure: number): this;

/**
 * Gets the channel from 0-15 that this message applies to.
 */
channel: number;

/**
 * Gets the note which is specified as a value from 0-127.
 */
note: number;

/**
 * Gets the polyphonic key pressure which is specified as a value from 0-127.
 */
pressure: number;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
}


/**
 * Represents a MIDI message that specifies a program change.
 */
declare class Windows$Devices$Midi$MidiProgramChangeMessage  {

/**
 * Creates a new MidiProgramChangeMessage object.
 * @param channel The channel from 0-15 that this message applies to.
 * @param program The program to change from 0-127.
 */
constructor(channel: number, program: number): this;

/**
 * Gets the channel from 0-15 that this message applies to.
 */
channel: number;

/**
 * Gets the program to change from 0-127.
 */
program: number;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
}


/**
 * Represents a MIDI message that specifies a song position pointer.
 */
declare class Windows$Devices$Midi$MidiSongPositionPointerMessage  {

/**
 * Creates a new MidiSongPositionPointerMessage object.
 * @param beats The song position pointer encoded in a 14-bit value from 0-16383.
 */
constructor(beats: number): this;

/**
 * Gets the song position pointer encoded in a 14-bit value from 0-16383.
 */
beats: number;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
}


/**
 * Represents a MIDI message that specifies the selected song.
 */
declare class Windows$Devices$Midi$MidiSongSelectMessage  {

/**
 * Creates a new MidiSongSelectMessage object.
 * @param song The song to select from 0-127.
 */
constructor(song: number): this;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the song to select from 0-127.
 */
song: number;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
}


/**
 * Represents a MIDI message that specifies a start message.
 */
declare class Windows$Devices$Midi$MidiStartMessage  {

/**
 * Creates a new MidiStartMessage object.
 */
constructor(): this;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
}


/**
 * Represents a MIDI message that specifies a stop message.
 */
declare class Windows$Devices$Midi$MidiStopMessage  {

/**
 * Creates a new MidiStopMessage object.
 */
constructor(): this;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
}


/**
 * Represents the Microsoft GS wavetable software synthesizer, included in Windows. This synthesizer provides a Roland GS sound set, which includes and extends the General MIDI sound set.
 */
declare class Windows$Devices$Midi$MidiSynthesizer  {

/**
 * Creates a new instance of the Microsoft MIDI synthesizer with a specified audio output device.
 * @param audioDevice The audio output device.
 * @return An instance of the Microsoft MIDI synthesizer.
 */
static createAsync(
audioDevice: Windows$Devices$Enumeration$DeviceInformation): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Midi$MidiSynthesizer>;

/**
 * Creates a new instance of the Microsoft MIDI synthesizer that uses the system's default audio output device.
 * @return An instance of the Windows MIDI synthesizer.
 */
static createAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Midi$MidiSynthesizer>;

/**
 * Determines whether a particular device is an instance of the Microsoft MIDI synthesizer. When all MIDI out ports on the system are enumerated, this method can be used to identify which of them is the Microsoft MIDI synthesizer.
 * @param midiDevice An object that represents the device in question.
 * @return True if the device is the Microsoft MIDI synthesizer; otherwise, false.
 */
static isSynthesizer(midiDevice: Windows$Devices$Enumeration$DeviceInformation): boolean;

/**
 * Gets the audio output device being used by this instance of the Microsoft MIDI synthesizer.
 */
audioDevice: Windows$Devices$Enumeration$DeviceInformation;

/**
 * Closes this instance of the Microsoft MIDI synthesizer. It is a best practice for the caller to use this method to clear resources used by the MIDI object.
 */
close(): void;

/**
 * Gets the device ID of the Microsoft MIDI synthesizer. Note that all instances of the synthesizer have the same ID.
 */
deviceId: string;

/**
 * Sends an array of bytes through the synthesizer's out port . This enables you to send your data as a byte array instead of as a defined MIDI message.
 * @param midiData The array of bytes to send.
 */
sendBuffer(midiData: Windows$Storage$Streams$IBuffer): void;

/**
 * Sends a MIDI message through the Microsoft MIDI synthesizer's out port .
 * @param midiMessage The MIDI message to send.
 */
sendMessage(midiMessage: Windows$Devices$Midi$IMidiMessage): void;

/**
 * Gets or sets the output volume of this instance of the Microsoft MIDI synthesizer.
 */
volume: number
}


/**
 * Represents a MIDI message that specifies a system exclusive message.
 */
declare class Windows$Devices$Midi$MidiSystemExclusiveMessage  {

/**
 * Creates a new MidiSystemExclusiveMessage object.
 * @param rawData The system exclusive data.
 */
constructor(rawData: Windows$Storage$Streams$IBuffer): this;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
}


/**
 * Represents a MIDI message that specifies a system reset.
 */
declare class Windows$Devices$Midi$MidiSystemResetMessage  {

/**
 * Creates a new MidiSystemResetMessage object.
 */
constructor(): this;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
}


/**
 * Represents a MIDI message that specifies a time code.
 */
declare class Windows$Devices$Midi$MidiTimeCodeMessage  {

/**
 * Creates a new MidiTimeCodeMessage object.
 * @param frameType The frame type from 0-7.
 * @param values The time code from 0-32.
 */
constructor(frameType: number, values: number): this;

/**
 * Gets the value of the frame type from 0-7.
 */
frameType: number;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>;

/**
 * Gets the time code value from 0-32.
 */
values: number
}


/**
 * Represents a MIDI message that specifies a timing clock.
 */
declare class Windows$Devices$Midi$MidiTimingClockMessage  {

/**
 * Creates a new MidiTimingClockMessage object.
 */
constructor(): this;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
}


/**
 * Represents a MIDI message that specifies a tune request.
 */
declare class Windows$Devices$Midi$MidiTuneRequestMessage  {

/**
 * Creates a new MidiTuneRequestMessage object.
 */
constructor(): this;

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number;

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
}


/**
 * Represents a MIDI message which is implemented by all MIDI message classes.
 */
declare interface Windows$Devices$Midi$IMidiMessage {

/**
 * Gets the array of bytes associated with the MIDI message, including status byte.
 */
rawData: Windows$Storage$Streams$IBuffer,

/**
 * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning.
 */
timestamp: number,

/**
 * Gets the type of this MIDI message.
 */
type: $Values<typeof Windows$Devices$Midi$MidiMessageType>
} 


/**
 * Represents a single MIDI out port.
 */
declare type Windows$Devices$Midi$IMidiOutPort = {

/**
 * Sends the contents of the buffer through the MIDI out port.
 * @param midiData The data to send to the device.
 */
sendBuffer(midiData: Windows$Storage$Streams$IBuffer): void,

/**
 * Send the data in the specified MIDI message to the device associated with this MidiOutPort .
 * @param midiMessage The MIDI message to send to the device.
 */
sendMessage(midiMessage: Windows$Devices$Midi$IMidiMessage): void,

/**
 * Gets the ID of the device that contains the MIDI out port.
 */
deviceId: string
} & Windows$Foundation$IClosable



      declare var npm$namespace$Windows$Devices$Perception: {
        
        
        PerceptionFrameSourceAccessStatus: typeof Windows$Devices$Perception$PerceptionFrameSourceAccessStatus,
PerceptionFrameSourcePropertyChangeStatus: typeof Windows$Devices$Perception$PerceptionFrameSourcePropertyChangeStatus,
        KnownCameraIntrinsicsProperties: typeof Windows$Devices$Perception$KnownCameraIntrinsicsProperties,
KnownPerceptionColorFrameSourceProperties: typeof Windows$Devices$Perception$KnownPerceptionColorFrameSourceProperties,
KnownPerceptionDepthFrameSourceProperties: typeof Windows$Devices$Perception$KnownPerceptionDepthFrameSourceProperties,
KnownPerceptionFrameSourceProperties: typeof Windows$Devices$Perception$KnownPerceptionFrameSourceProperties,
KnownPerceptionInfraredFrameSourceProperties: typeof Windows$Devices$Perception$KnownPerceptionInfraredFrameSourceProperties,
KnownPerceptionVideoFrameSourceProperties: typeof Windows$Devices$Perception$KnownPerceptionVideoFrameSourceProperties,
KnownPerceptionVideoProfileProperties: typeof Windows$Devices$Perception$KnownPerceptionVideoProfileProperties,
PerceptionColorFrame: typeof Windows$Devices$Perception$PerceptionColorFrame,
PerceptionColorFrameArrivedEventArgs: typeof Windows$Devices$Perception$PerceptionColorFrameArrivedEventArgs,
PerceptionColorFrameReader: typeof Windows$Devices$Perception$PerceptionColorFrameReader,
PerceptionColorFrameSource: typeof Windows$Devices$Perception$PerceptionColorFrameSource,
PerceptionColorFrameSourceAddedEventArgs: typeof Windows$Devices$Perception$PerceptionColorFrameSourceAddedEventArgs,
PerceptionColorFrameSourceRemovedEventArgs: typeof Windows$Devices$Perception$PerceptionColorFrameSourceRemovedEventArgs,
PerceptionColorFrameSourceWatcher: typeof Windows$Devices$Perception$PerceptionColorFrameSourceWatcher,
PerceptionControlSession: typeof Windows$Devices$Perception$PerceptionControlSession,
PerceptionDepthCorrelatedCameraIntrinsics: typeof Windows$Devices$Perception$PerceptionDepthCorrelatedCameraIntrinsics,
PerceptionDepthCorrelatedCoordinateMapper: typeof Windows$Devices$Perception$PerceptionDepthCorrelatedCoordinateMapper,
PerceptionDepthFrame: typeof Windows$Devices$Perception$PerceptionDepthFrame,
PerceptionDepthFrameArrivedEventArgs: typeof Windows$Devices$Perception$PerceptionDepthFrameArrivedEventArgs,
PerceptionDepthFrameReader: typeof Windows$Devices$Perception$PerceptionDepthFrameReader,
PerceptionDepthFrameSource: typeof Windows$Devices$Perception$PerceptionDepthFrameSource,
PerceptionDepthFrameSourceAddedEventArgs: typeof Windows$Devices$Perception$PerceptionDepthFrameSourceAddedEventArgs,
PerceptionDepthFrameSourceRemovedEventArgs: typeof Windows$Devices$Perception$PerceptionDepthFrameSourceRemovedEventArgs,
PerceptionDepthFrameSourceWatcher: typeof Windows$Devices$Perception$PerceptionDepthFrameSourceWatcher,
PerceptionFrameSourcePropertiesChangedEventArgs: typeof Windows$Devices$Perception$PerceptionFrameSourcePropertiesChangedEventArgs,
PerceptionFrameSourcePropertyChangeResult: typeof Windows$Devices$Perception$PerceptionFrameSourcePropertyChangeResult,
PerceptionInfraredFrame: typeof Windows$Devices$Perception$PerceptionInfraredFrame,
PerceptionInfraredFrameArrivedEventArgs: typeof Windows$Devices$Perception$PerceptionInfraredFrameArrivedEventArgs,
PerceptionInfraredFrameReader: typeof Windows$Devices$Perception$PerceptionInfraredFrameReader,
PerceptionInfraredFrameSource: typeof Windows$Devices$Perception$PerceptionInfraredFrameSource,
PerceptionInfraredFrameSourceAddedEventArgs: typeof Windows$Devices$Perception$PerceptionInfraredFrameSourceAddedEventArgs,
PerceptionInfraredFrameSourceRemovedEventArgs: typeof Windows$Devices$Perception$PerceptionInfraredFrameSourceRemovedEventArgs,
PerceptionInfraredFrameSourceWatcher: typeof Windows$Devices$Perception$PerceptionInfraredFrameSourceWatcher,
PerceptionVideoProfile: typeof Windows$Devices$Perception$PerceptionVideoProfile,
        Provider: typeof npm$namespace$Windows$Devices$Perception$Provider,
      }

/**
 * Provides static methods for retrieving intrinsic properties of a camera.
 */
declare class Windows$Devices$Perception$KnownCameraIntrinsicsProperties  {

/**
 * Gets a string key used to retrieve an array of single-precision, floating-point property values indicating the focal length of the camera.
 */
static focalLength: string;

/**
 * Gets a string key used to retrieve an array of single-precision, floating-point property values indicating the principal point, relative to the camera.
 */
static principalPoint: string;

/**
 * Gets a string key used to retrieve an array of single-precision, floating-point property values indicating the radial distortion of the camera.
 */
static radialDistortion: string;

/**
 * Gets a string key used to retrieve an array of single-precision, floating-point property values indicating the tangential distortion of the camera.
 */
static tangentialDistortion: string
}


/**
 * Provides static properties of color frame sources.
 */
declare class Windows$Devices$Perception$KnownPerceptionColorFrameSourceProperties  {

/**
 * Gets a string key used to retrieve a Boolean property indicating whether or not auto exposure is enabled.
 */
static autoExposureEnabled: string;

/**
 * Gets a string key used to retrieve a TimeSpan property indicating the current exposure duration of the camera.
 */
static exposure: string;

/**
 * Gets a string key used to retrieve a single-precision, floating-point property indicating the exposure compensation.
 */
static exposureCompensation: string
}


/**
 * Provides static properties of depth frame sources.
 */
declare class Windows$Devices$Perception$KnownPerceptionDepthFrameSourceProperties  {

/**
 * Gets a string key used to retrieve a 16-bit unsigned integer property indicating the maximum depth of the depth frame source.
 */
static maxDepth: string;

/**
 * Gets a string key used to retrieve a 16-bit unsigned integer property indicating the minimum depth of the depth frame source.
 */
static minDepth: string
}


/**
 * Provides static properties that are applicable to all types of frame sources.
 */
declare class Windows$Devices$Perception$KnownPerceptionFrameSourceProperties  {
static deviceId: any;

/**
 * Gets a string key used to look up a string property with the device, model, version string for the physical sensor device this frame source represents.
 */
static deviceModelVersion: string;

/**
 * Gets a string key used to look up an enumeration property indicating the physical location of the sensor on the Windows device.
 */
static enclosureLocation: string;

/**
 * Gets a string key used to look up a string property that is a string key indicating the kind of frame the source provides.
 */
static frameKind: string;

/**
 * Gets a string key used to look up a string property with the unique ID of the frame source.
 */
static id: string;

/**
 * Gets a string key used to look up a string array property containing the physical device IDs of the sensor this frame source represents.
 */
static physicalDeviceIds: string
}


/**
 * Provides static properties of infrared frame sources.
 */
declare class Windows$Devices$Perception$KnownPerceptionInfraredFrameSourceProperties  {

/**
 * Gets a string key used to retrieve a Boolean property indicating whether or not active IR illumination is enabled.
 */
static activeIlluminationEnabled: string;

/**
 * Gets a string key used to retrieve a Boolean property indicating whether or not ambient IR light subtraction is enabled.
 */
static ambientSubtractionEnabled: string;

/**
 * Gets a string key used to retrieve a Boolean property indicating whether or not auto exposure is enabled.
 */
static autoExposureEnabled: string;

/**
 * Gets a string key used to retrieve a TimeSpan property indicating the current exposure duration of the camera.
 */
static exposure: string;

/**
 * Gets a string key used to retrieve a single-precision, floating-point property indicating the amount of exposure compensation.
 */
static exposureCompensation: string;

/**
 * Gets a string key used to retrieve a Boolean property indicating whether or not interleaved illumination is enabled.
 */
static interleavedIlluminationEnabled: string;

/**
 * Gets a string key used to retrieve a Boolean property indicating whether or not the structured light pattern is enabled.
 */
static structureLightPatternEnabled: string
}


/**
 * Provides static properties of video frame sources.
 */
declare class Windows$Devices$Perception$KnownPerceptionVideoFrameSourceProperties  {

/**
 * Gets a string key used to retrieve a boolean property indicating the supported video profiles that are currently available.
 */
static availableVideoProfiles: string;

/**
 * Gets a string key used to retrieve a CameraIntrinsics property defining the physical properties of the camera device. The CameraIntrinsics object also provides convenience methods for sensor-related geometry, including camera space to image space projections.
 */
static cameraIntrinsics: string;

/**
 * Gets a string key used to retrieve a boolean property indicating whether or not the video frame source is providing mirrored video frames.
 */
static isMirrored: string;

/**
 * Gets a string key used to retrieve the supported video profiles property.
 */
static supportedVideoProfiles: string;

/**
 * Gets a string key used to retrieve the current video profile property.
 */
static videoProfile: string
}


/**
 * Provides static properties of a video profile.
 */
declare class Windows$Devices$Perception$KnownPerceptionVideoProfileProperties  {

/**
 * Gets a string key used to retrieve an enumeration property indicating the bitmap alpha mode.
 */
static bitmapAlphaMode: string;

/**
 * Gets a string key used to retrieve an enumeration property indicating the bitmap pixel format.
 */
static bitmapPixelFormat: string;

/**
 * Gets a string key used to retrieve a TimeSpan property indicating the time duration of each frame.
 */
static frameDuration: string;

/**
 * Gets a string key used to retrieve a 32-bit unsigned integer property indicating the frame height, in pixels.
 */
static height: string;

/**
 * Gets a string key used to retrieve a 32-bit unsigned integer property indicating the frame width, in pixels.
 */
static width: string
}


/**
 * Contains a Windows.Media.VideoFrame with the color frame data.
 */
declare class Windows$Devices$Perception$PerceptionColorFrame  {

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 */
close(): void;

/**
 * Gets a Windows.Media.VideoFrame with the color frame data.
 */
videoFrame: Windows$Media$VideoFrame
}


/**
 * Contains information about a color frame arrived event.
 */
declare class Windows$Devices$Perception$PerceptionColorFrameArrivedEventArgs  {

/**
 * Gets the relative time of this frame.
 */
relativeTime: number;

/**
 * Attempts to open the color frame that has arrived.
 * @return If the attempt is successful, this method returns the newly-arrived color frame. If the attempt is unsuccessful, this value is unchanged.
 */
tryOpenFrame(): Windows$Devices$Perception$PerceptionColorFrame
}


/**
 * Reads color frames from a color frame source.
 */
declare class Windows$Devices$Perception$PerceptionColorFrameReader  {

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 */
close(): void;

/**
 * Gets or sets a boolean value indicating whether or not this reader is paused.
 */
isPaused: boolean;

/**
 * Subscribes to the FrameArrived event. This event is fired whenever a new frame arrives from the color frame source.
 */
onframearrived: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameReader, Windows$Devices$Perception$PerceptionColorFrameArrivedEventArgs>;
addEventListener(
type: "framearrived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameReader, Windows$Devices$Perception$PerceptionColorFrameArrivedEventArgs>): void;
removeEventListener(
type: "framearrived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameReader, Windows$Devices$Perception$PerceptionColorFrameArrivedEventArgs>): void;

/**
 * Gets the color frame source this reader gets frames from.
 */
source: Windows$Devices$Perception$PerceptionColorFrameSource;

/**
 * Attempts to read the most recent frame that is available to this color frame reader.
 * @return If the attempt was successful, this method returns the most recent frame that is available to this color frame reader. If the attempt was not successful, this method returns null.
 */
tryReadLatestFrame(): Windows$Devices$Perception$PerceptionColorFrame;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * A frame source that provides color frames.
 */
declare class Windows$Devices$Perception$PerceptionColorFrameSource  {

/**
 * Creates a new color frame source watcher.
 * @return A new color frame source watcher.
 */
static createWatcher(): Windows$Devices$Perception$PerceptionColorFrameSourceWatcher;

/**
 * Finds all color frame sources.
 * @return When the method completes, it asynchronously returns a list of color frame sources.
 */
static findAllAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Finds an color frame source by looking up its unique ID.
 * @param id The unique ID of the color frame source.
 * @return When this method completes, it asynchronously returns a color frame source if one exists with the specified ID. Otherwise, this method asynchronously returns null.
 */
static fromIdAsync(
id: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Perception$PerceptionColorFrameSource>;

/**
 * Requests access to use color frame sources.
 * @return When this method completes, it asynchronously returns a PerceptionFrameSourceAccessStatus indicating the result of the access request.
 */
static requestAccessAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Devices$Perception$PerceptionFrameSourceAccessStatus>>;

/**
 * Attempts to acquire Controller Mode on the color frame source.
 * @return If the attempt is successful, this returns a PerceptionControlSession object that can be used to control properties of the color frame source. Otherwise, this returns null.
 */
acquireControlSession(): Windows$Devices$Perception$PerceptionControlSession;

/**
 * Gets a boolean value indicating whether or not the source is active.
 */
active: boolean;

/**
 * Gets a boolean value indicating whether or not the source is available.
 */
available: boolean;

/**
 * Gets a read-only collection of video profiles that are currently available from the color frame source.
 */
availableVideoProfiles: Windows$Foundation$Collections$IVectorView<Windows$Devices$Perception$PerceptionVideoProfile>;

/**
 * Gets a CameraIntrinsics value specifying the intrinsic properties of the color frame source camera device.
 */
cameraIntrinsics: Windows$Media$Devices$Core$CameraIntrinsics;

/**
 * This method returns a boolean value indicating whether or not the color frame source can be controlled separately from another frame source.
 * @param targetId A string representing the unique ID of the other frame source.
 * @return Returns true if the two sources can be controlled independently of one another, otherwise returns false.
 */
canControlIndependentlyFrom(targetId: string): boolean;
deviceId: any;

/**
 * Gets a string value indicating the kind of physical device that generates the color frames for this source.
 */
deviceKind: string;

/**
 * Gets a string value indicating the display name of the color frame source.
 */
displayName: string;

/**
 * Gets a string value indicating the unique ID of the color frame source.
 */
id: string;

/**
 * Gets a boolean value indicating whether or not the source is the subject of controller mode.
 */
isControlled: boolean;

/**
 * Checks whether or not the color frame source is correlated with the target entity. If the result is true, a transform matrix can be retrieved to change coordinate basis from this color frame source to the entity, or vice versa.
 * @param targetId The unique ID of the target entity.
 * @return Returns true if a correlation exists, otherwise returns false.
 */
isCorrelatedWith(targetId: string): boolean;

/**
 * Subscribes to the ActiveChanged event.
 */
onactivechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSource, any>;
addEventListener(
type: "activechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSource, any>): void;
removeEventListener(
type: "activechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSource, any>): void;

/**
 * Subscribes to the AvailableChanged event.
 */
onavailablechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSource, any>;
addEventListener(
type: "availablechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSource, any>): void;
removeEventListener(
type: "availablechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSource, any>): void;

/**
 * Subscribes to the CameraIntrinsicsChanged event.
 */
oncameraintrinsicschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSource, any>;
addEventListener(
type: "cameraintrinsicschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSource, any>): void;
removeEventListener(
type: "cameraintrinsicschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSource, any>): void;

/**
 * Subscribes to the PropertiesChanged event.
 */
onpropertieschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSource, Windows$Devices$Perception$PerceptionFrameSourcePropertiesChangedEventArgs>;
addEventListener(
type: "propertieschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSource, Windows$Devices$Perception$PerceptionFrameSourcePropertiesChangedEventArgs>): void;
removeEventListener(
type: "propertieschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSource, Windows$Devices$Perception$PerceptionFrameSourcePropertiesChangedEventArgs>): void;

/**
 * Subscribes to the VideoProfileChanged event.
 */
onvideoprofilechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSource, any>;
addEventListener(
type: "videoprofilechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSource, any>): void;
removeEventListener(
type: "videoprofilechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSource, any>): void;

/**
 * Gets a frame reader that reads frames from this color frame source.
 * @return Returns a frame reader that reads frames from this color frame source.
 */
openReader(): Windows$Devices$Perception$PerceptionColorFrameReader;

/**
 * Gets a read-only collection of frame source properties.
 */
properties: Windows$Foundation$Collections$IMapView<string, any>;

/**
 * Gets a read-only collection of video profiles that are supported by the color frame source.
 */
supportedVideoProfiles: Windows$Foundation$Collections$IVectorView<Windows$Devices$Perception$PerceptionVideoProfile>;

/**
 * Attempts to get the intrinsic properties of the depth camera that is correlated with this color source.
 * @param correlatedDepthFrameSource The depth frame source to try to get intrinsic properties of.
 * @return If the attempt is successful, this will return a read-only collection of PerceptionDepthCorrelatedCameraIntrinsics objects specifying the intrinsic properties of the camera used by the correlated depth frame source. Otherwise, this returns null.
 */
tryGetDepthCorrelatedCameraIntrinsicsAsync(
correlatedDepthFrameSource: Windows$Devices$Perception$PerceptionDepthFrameSource): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Perception$PerceptionDepthCorrelatedCameraIntrinsics>;

/**
 * Attempts to get a coordinate mapper that maps from color frame image space to depth frame space.
 * @param targetSourceId The unique ID of the depth frame source to try to map to.
 * @param correlatedDepthFrameSource The depth frame source to try to map to. This should be in a correlation group with the color frame source.
 * @return If the two sources are correlated, this method returns a PerceptionDepthCorrelatedCoordinateMapper. Otherwise, it returns null. This method returns asynchronously.
 */
tryGetDepthCorrelatedCoordinateMapperAsync(
targetSourceId: string,
correlatedDepthFrameSource: Windows$Devices$Perception$PerceptionDepthFrameSource): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Perception$PerceptionDepthCorrelatedCoordinateMapper>;

/**
 * This method returns the transform from the color frame source to the target entity and sets hasResult to true, if a correlation exists. If a correlation does not exist, hasResult is set to false and result is not modified.
 * @param targetId The unique ID of the target entity.
 */
tryGetTransformTo(
targetId: string): {
result: Windows$Foundation$Numerics$Matrix4x4,
returnValue: boolean
};

/**
 * Attempts to set a video profile on this color frame source. Requires an active Controller Mode control session on this frame source.
 * @param controlSession A PerceptionControlSession representing active control of this frame source.
 * @param profile The video profile to set.
 * @return This method returns an PerceptionFrameSourcePropertyChangeResult object asynchonously. If the control session was still active when the video profile was set, and if the video profile is supported and can be activated, this will be a result that indicates success.
 */
trySetVideoProfileAsync(
controlSession: Windows$Devices$Perception$PerceptionControlSession,
profile: Windows$Devices$Perception$PerceptionVideoProfile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Perception$PerceptionFrameSourcePropertyChangeResult>;

/**
 * Gets a PerceptionVideoProfile object indicating the current video profile.
 */
videoProfile: Windows$Devices$Perception$PerceptionVideoProfile;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Event data for color frame source added events.
 */
declare class Windows$Devices$Perception$PerceptionColorFrameSourceAddedEventArgs  {

/**
 * Gets the color frame source that was added.
 */
frameSource: Windows$Devices$Perception$PerceptionColorFrameSource
}


/**
 * Event data for color frame source added events.
 */
declare class Windows$Devices$Perception$PerceptionColorFrameSourceRemovedEventArgs  {

/**
 * Gets the color frame source that was removed.
 */
frameSource: Windows$Devices$Perception$PerceptionColorFrameSource
}


/**
 * Monitors changes to the list of color frame sources, and provides notifications when the list changes.
 */
declare class Windows$Devices$Perception$PerceptionColorFrameSourceWatcher  {

/**
 * Subscribes to the EnumerationCompleted event. This event is fired after the initial enumeration of known color frame sources is complete.
 */
onenumerationcompleted: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSourceWatcher, any>;
addEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSourceWatcher, any>): void;
removeEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSourceWatcher, any>): void;

/**
 * Subscribes to the SourceAdded event.
 */
onsourceadded: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSourceWatcher, Windows$Devices$Perception$PerceptionColorFrameSourceAddedEventArgs>;
addEventListener(
type: "sourceadded",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSourceWatcher, Windows$Devices$Perception$PerceptionColorFrameSourceAddedEventArgs>): void;
removeEventListener(
type: "sourceadded",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSourceWatcher, Windows$Devices$Perception$PerceptionColorFrameSourceAddedEventArgs>): void;

/**
 * Subscribes to the SourceRemoved event. This event is fired once for every color frame source that is removed.
 */
onsourceremoved: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSourceWatcher, Windows$Devices$Perception$PerceptionColorFrameSourceRemovedEventArgs>;
addEventListener(
type: "sourceremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSourceWatcher, Windows$Devices$Perception$PerceptionColorFrameSourceRemovedEventArgs>): void;
removeEventListener(
type: "sourceremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSourceWatcher, Windows$Devices$Perception$PerceptionColorFrameSourceRemovedEventArgs>): void;

/**
 * Subscribes to the Stopped event. This event is fired when the IPerceptionColorFrameSourceWatcher has stopped listening for changes to the list of color frame sources.
 */
onstopped: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSourceWatcher, any>;
addEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSourceWatcher, any>): void;
removeEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionColorFrameSourceWatcher, any>): void;

/**
 * When this method is called, the color frame source watcher enumerates any existing color frame sources it has not already enumerated by firing a SourceAdded event for each one. An EnumerationCompleted event is fired when this enumeration is complete. The color frame source then starts watching for new color frame sources.
 */
start(): void;

/**
 * Gets the operational status of the color frame source watcher.
 */
status: $Values<typeof Windows$Devices$Enumeration$DeviceWatcherStatus>;

/**
 * When this method is called, the color frame source watcher stops looking for changes to the color frame source list. This operation is not immediate; the Stopped event will be triggered when the Stop operation is complete.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a control session on a controllable frame source.
 */
declare class Windows$Devices$Perception$PerceptionControlSession  {

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 */
close(): void;

/**
 * Subscribes to the ControlLost event. This event is triggered when control of the session is lost to another client.
 */
oncontrollost: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionControlSession, any>;
addEventListener(
type: "controllost",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionControlSession, any>): void;
removeEventListener(
type: "controllost",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionControlSession, any>): void;

/**
 * Creates a property change request. This request is asynchronously processed, and is not guaranteed to succeed. The property change result should be inspected to determine if the property change was actually accepted and, if it was not, the reason why the property change was not accepted.
 * @param name The name of the property to change.
 * @param value The new property value.
 * @return This method asynchronously returns the result of the property change request.
 */
trySetPropertyAsync(
name: string,
value: any): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Perception$PerceptionFrameSourcePropertyChangeResult>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides convenience methods to facilitate geometric math for a camera device, combining the intrinsic properties of that camera with correlated depth frames to provide screen-space pixel to camera-space coordinate projections.
 */
declare class Windows$Devices$Perception$PerceptionDepthCorrelatedCameraIntrinsics  {

/**
 * Unprojects all pixels in an image from camera image space out into the coordinate frame of the camera device, using the corresponding depth values from a correlated depth camera.
 * @param depthFrame The depth frame containing the depth value to use when projecting the points into camera space. The coordinates of each pixel in the image will be mapped from camera image space to depth image space, and then used to look up the depth in this depth frame.
 */
unprojectAllPixelsAtCorrelatedDepthAsync(
depthFrame: Windows$Devices$Perception$PerceptionDepthFrame): {
results: Windows$Foundation$Numerics$Vector3,
returnValue: Windows$Foundation$IPromiseWithIAsyncAction
};

/**
 * Unprojects a point in camera image space out into the coordinate frame of the camera device, using the corresponding depth from a correlated depth camera.
 * @param pixelCoordinate A point, relative to the camera frame.
 * @param depthFrame The depth frame containing the depth value to use when projecting the point into camera space. The pixelCoordinate will be mapped from camera image space to depth image space, and then used to look up the depth in depthFrame.
 * @return An unprojected coordinate, relative to the coordinate system of the camera device. The coordinate is located in front of the camera, at the depth of the corresponding pixel in depthFrame.
 */
unprojectPixelAtCorrelatedDepth(
pixelCoordinate: Windows$Foundation$Point,
depthFrame: Windows$Devices$Perception$PerceptionDepthFrame): Windows$Foundation$Numerics$Vector3;

/**
 * Unprojects a set of points in camera image space out into the coordinate frame of the camera device, using the corresponding depth values from a correlated depth camera.
 * @param sourceCoordinates A set of points, relative to the camera frame.
 * @param depthFrame The depth frame containing the depth value to use when projecting the points into camera space. The pixelCoordinate will be mapped from camera image space to depth image space, and then used to look up the depth in depthFrame.
 * @return A set of coordinates, relative to the coordinate system of the camera device and with correlated depth values.
 */
unprojectPixelsAtCorrelatedDepth(
sourceCoordinates: Windows$Foundation$Point,
depthFrame: Windows$Devices$Perception$PerceptionDepthFrame): Windows$Foundation$Numerics$Vector3;

/**
 * Unprojects a region of pixels in an image from camera image space out into the coordinate frame of the camera device, using the corresponding depth values from a correlated depth camera.
 * @param region The region of pixels to project from camera image space out into the coordinate frame of the camera device.
 * @param depthFrame The depth frame containing the depth value to use when projecting the points into camera space. The pixelCoordinates will be mapped from camera image space to depth image space, and then used to look up the depth in depthFrame.
 */
unprojectRegionPixelsAtCorrelatedDepthAsync(
region: Windows$Foundation$Rect,
depthFrame: Windows$Devices$Perception$PerceptionDepthFrame): {
results: Windows$Foundation$Numerics$Vector3,
returnValue: Windows$Foundation$IPromiseWithIAsyncAction
}
}


/**
 * Provides convenience methods to map pixel coordinates in camera image space to depth image space.
 */
declare class Windows$Devices$Perception$PerceptionDepthCorrelatedCoordinateMapper  {

/**
 * Maps all pixels in an image from camera image space to depth image space.
 * @param depthFrame The depth frame to map the pixels to.
 */
mapAllPixelsToTargetAsync(
depthFrame: Windows$Devices$Perception$PerceptionDepthFrame): {
targetCoordinates: Windows$Foundation$Point,
returnValue: Windows$Foundation$IPromiseWithIAsyncAction
};

/**
 * Maps a pixel from camera image space to depth image space.
 * @param sourcePixelCoordinate A pixel coordinate, in camera image space.
 * @param depthFrame The depth frame to map the pixel to.
 * @return Returns the mapping of the pixel coordinate to depth image space.
 */
mapPixelToTarget(
sourcePixelCoordinate: Windows$Foundation$Point,
depthFrame: Windows$Devices$Perception$PerceptionDepthFrame): Windows$Foundation$Point;

/**
 * Maps a set of pixels from camera image space to depth image space.
 * @param sourceCoordinates A set of pixel coordinates, in camera image space.
 * @param depthFrame The depth frame to map the pixels to.
 * @return The mapping of the pixel coordinate to depth image space.
 */
mapPixelsToTarget(
sourceCoordinates: Windows$Foundation$Point,
depthFrame: Windows$Devices$Perception$PerceptionDepthFrame): Windows$Foundation$Point;

/**
 * Maps a region of pixels from camera image space to depth image space.
 * @param region The region of pixels to map from camera image space to depth image space.
 * @param depthFrame The depth frame to map the region of pixels to.
 */
mapRegionOfPixelsToTargetAsync(
region: Windows$Foundation$Rect,
depthFrame: Windows$Devices$Perception$PerceptionDepthFrame): {
targetCoordinates: Windows$Foundation$Point,
returnValue: Windows$Foundation$IPromiseWithIAsyncAction
}
}


/**
 * Contains a Windows.Media.VideoFrame with the depth frame data.
 */
declare class Windows$Devices$Perception$PerceptionDepthFrame  {

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 */
close(): void;

/**
 * Gets a Windows.Media.VideoFrame with the depth frame data.
 */
videoFrame: Windows$Media$VideoFrame
}


/**
 * Contains information about a depth frame arrived event.
 */
declare class Windows$Devices$Perception$PerceptionDepthFrameArrivedEventArgs  {

/**
 * Gets the relative time of this frame.
 */
relativeTime: number;

/**
 * Attempts to open the depth frame that has arrived. Existing frames should be closed before opening new frames. If an app has three or more frames still open when this method is called, TryOpenFrame will fail.
 * @return If the attempt is successful, this method returns the newly-arrived depth frame. If the attempt is unsuccessful, this value is unchanged.
 */
tryOpenFrame(): Windows$Devices$Perception$PerceptionDepthFrame
}


/**
 * Reads depth frames from a depth frame source.
 */
declare class Windows$Devices$Perception$PerceptionDepthFrameReader  {

/**
 * Releases system resources that are exposed by a Windows Runtime object
 */
close(): void;

/**
 * Gets a boolean value indicating whether or not this reader is paused.
 */
isPaused: boolean;

/**
 * Subscribes to the FrameArrived event. This event is fired whenever a new frame arrives from the depth frame source.
 */
onframearrived: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameReader, Windows$Devices$Perception$PerceptionDepthFrameArrivedEventArgs>;
addEventListener(
type: "framearrived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameReader, Windows$Devices$Perception$PerceptionDepthFrameArrivedEventArgs>): void;
removeEventListener(
type: "framearrived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameReader, Windows$Devices$Perception$PerceptionDepthFrameArrivedEventArgs>): void;

/**
 * Gets the depth frame source this reader gets frames from.
 */
source: Windows$Devices$Perception$PerceptionDepthFrameSource;

/**
 * Attempts to read the most recent frame that is available to this depth frame reader.
 * @return If the attempt was successful, this method returns the most recent frame that is available to this depth frame reader. If the attempt was not successful, this method returns null.
 */
tryReadLatestFrame(): Windows$Devices$Perception$PerceptionDepthFrame;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * A frame source that provides depth frames.
 */
declare class Windows$Devices$Perception$PerceptionDepthFrameSource  {

/**
 * Creates a new depth frame source watcher.
 * @return A new depth frame source watcher.
 */
static createWatcher(): Windows$Devices$Perception$PerceptionDepthFrameSourceWatcher;

/**
 * Finds all depth frame sources.
 * @return When the method completes, it asynchronously returns a list of depth frame sources.
 */
static findAllAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Finds an depth frame source by looking up its unique ID.
 * @param id The unique ID of the depth frame source.
 * @return When this method completes, it asynchronously returns a depth frame source if one exists with the specified ID. Otherwise, this method asynchronously returns null.
 */
static fromIdAsync(
id: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Perception$PerceptionDepthFrameSource>;

/**
 * Requests access to use depth frame sources.
 * @return When this method completes, it asynchronously returns a PerceptionFrameSourceAccessStatus indicating the result of the access request.
 */
static requestAccessAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Devices$Perception$PerceptionFrameSourceAccessStatus>>;

/**
 * Attempts to acquire Controller Mode on the depth frame source.
 * @return If the attempt is successful, this returns a PerceptionControlSession object that can be used to control properties of the depth frame source. Otherwise, this returns null.
 */
acquireControlSession(): Windows$Devices$Perception$PerceptionControlSession;

/**
 * Gets a boolean value indicating whether or not the source is active.
 */
active: boolean;

/**
 * Gets a boolean value indicating whether or not the source is available.
 */
available: boolean;

/**
 * Gets a read-only collection of video profiles that are currently available from the depth frame source.
 */
availableVideoProfiles: Windows$Foundation$Collections$IVectorView<Windows$Devices$Perception$PerceptionVideoProfile>;

/**
 * Gets a CameraIntrinsics value specifying the intrinsic properties of the depth frame source camera device.
 */
cameraIntrinsics: Windows$Media$Devices$Core$CameraIntrinsics;

/**
 * This method returns a boolean value indicating whether or not the depth frame source can be controlled separately from another frame source.
 * @param targetId A string representing the unique ID of the other frame source.
 * @return True if the two sources can be controlled independently of one another; otherwise, false.
 */
canControlIndependentlyFrom(targetId: string): boolean;
deviceId: any;

/**
 * Gets a string value indicating the kind of physical device that generates the depth frames.
 */
deviceKind: string;

/**
 * Gets a string value indicating the display name of the depth frame source.
 */
displayName: string;

/**
 * Gets a string value indicating the unique ID of the depth frame source.
 */
id: string;

/**
 * Gets a boolean value indicating whether or not the source is the subject of controller mode.
 */
isControlled: boolean;

/**
 * Checks whether or not the depth frame source is correlated with the target entity. If the result is true, a transform matrix can be retrieved to change coordinate basis from this depth frame source to the entity, or vice versa.
 * @param targetId The unique ID of the target entity.
 * @return True if a correlation exists, otherwise false.
 */
isCorrelatedWith(targetId: string): boolean;

/**
 * Subscribes to the ActiveChanged event.
 */
onactivechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSource, any>;
addEventListener(
type: "activechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSource, any>): void;
removeEventListener(
type: "activechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSource, any>): void;

/**
 * Subscribes to the AvailableChanged event.
 */
onavailablechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSource, any>;
addEventListener(
type: "availablechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSource, any>): void;
removeEventListener(
type: "availablechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSource, any>): void;

/**
 * Subscribes to the CameraIntrinsicsChanged event.
 */
oncameraintrinsicschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSource, any>;
addEventListener(
type: "cameraintrinsicschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSource, any>): void;
removeEventListener(
type: "cameraintrinsicschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSource, any>): void;

/**
 * Subscribes to the PropertiesChanged event.
 */
onpropertieschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSource, Windows$Devices$Perception$PerceptionFrameSourcePropertiesChangedEventArgs>;
addEventListener(
type: "propertieschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSource, Windows$Devices$Perception$PerceptionFrameSourcePropertiesChangedEventArgs>): void;
removeEventListener(
type: "propertieschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSource, Windows$Devices$Perception$PerceptionFrameSourcePropertiesChangedEventArgs>): void;

/**
 * Subscribes to the VideoProfileChanged event.
 */
onvideoprofilechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSource, any>;
addEventListener(
type: "videoprofilechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSource, any>): void;
removeEventListener(
type: "videoprofilechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSource, any>): void;

/**
 * Gets a frame reader that reads frames from this depth frame source.
 * @return A frame reader that reads frames from this depth frame source.
 */
openReader(): Windows$Devices$Perception$PerceptionDepthFrameReader;

/**
 * Gets a read-only collection of frame source properties.
 */
properties: Windows$Foundation$Collections$IMapView<string, any>;

/**
 * Gets a read-only collection of video profiles that are supported by the depth frame source.
 */
supportedVideoProfiles: Windows$Foundation$Collections$IVectorView<Windows$Devices$Perception$PerceptionVideoProfile>;

/**
 * Attempts to get the intrinsic properties of the depth camera that is correlated with this depth source.
 * @param target The depth frame source to try to get intrinsic properties of.
 * @return If the attempt is successful, this returns a read-only collection of PerceptionDepthCorrelatedCameraIntrinsics objects specifying the intrinsic properties of the camera used by the correlated depth frame source. Otherwise, this returns null.
 */
tryGetDepthCorrelatedCameraIntrinsicsAsync(
target: Windows$Devices$Perception$PerceptionDepthFrameSource): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Perception$PerceptionDepthCorrelatedCameraIntrinsics>;

/**
 * Attempts to get a coordinate mapper that maps from depth frame image space to depth frame space.
 * @param targetId The unique ID of the depth frame source to try to map to.
 * @param depthFrameSourceToMapWith The depth frame source to try to map to. This should be in a correlation group with the depth frame source.
 * @return If the two sources are correlated, this method returns a PerceptionDepthCorrelatedCoordinateMapper. Otherwise, it returns null. This method returns asynchronously.
 */
tryGetDepthCorrelatedCoordinateMapperAsync(
targetId: string,
depthFrameSourceToMapWith: Windows$Devices$Perception$PerceptionDepthFrameSource): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Perception$PerceptionDepthCorrelatedCoordinateMapper>;

/**
 * Gets the transform from the depth frame source to the target entity and sets hasResult to true, if a correlation exists. If a correlation does not exist, hasResult is set to false and result is not modified.
 * @param targetId The unique ID of the target entity.
 */
tryGetTransformTo(
targetId: string): {
result: Windows$Foundation$Numerics$Matrix4x4,
returnValue: boolean
};

/**
 * Attempts to set a video profile on this depth frame source. Requires an active Controller Mode control session on this frame source.
 * @param controlSession A PerceptionControlSession representing active control of this frame source.
 * @param profile The video profile to set.
 * @return This method returns an PerceptionFrameSourcePropertyChangeResult object asynchronously. If the control session was still active when the video profile was set, and if the video profile is supported and can be activated, this will be a result indicating success.
 */
trySetVideoProfileAsync(
controlSession: Windows$Devices$Perception$PerceptionControlSession,
profile: Windows$Devices$Perception$PerceptionVideoProfile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Perception$PerceptionFrameSourcePropertyChangeResult>;

/**
 * Gets a PerceptionVideoProfile object indicating the current video profile.
 */
videoProfile: Windows$Devices$Perception$PerceptionVideoProfile;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Event data for depth frame source added events.
 */
declare class Windows$Devices$Perception$PerceptionDepthFrameSourceAddedEventArgs  {

/**
 * Gets the depth frame source that was added.
 */
frameSource: Windows$Devices$Perception$PerceptionDepthFrameSource
}


/**
 * Event data for depth frame source removed events.
 */
declare class Windows$Devices$Perception$PerceptionDepthFrameSourceRemovedEventArgs  {

/**
 * Gets the depth frame source that was removed.
 */
frameSource: Windows$Devices$Perception$PerceptionDepthFrameSource
}


/**
 * Monitors changes to the list of depth frame sources, and provides notifications when the list changes.
 */
declare class Windows$Devices$Perception$PerceptionDepthFrameSourceWatcher  {

/**
 * Subscribes to the EnumerationCompleted event. This event is fired after the initial enumeration of known depth frame sources is complete.
 */
onenumerationcompleted: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSourceWatcher, any>;
addEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSourceWatcher, any>): void;
removeEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSourceWatcher, any>): void;

/**
 * Subscribes to the SourceAdded event.
 */
onsourceadded: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSourceWatcher, Windows$Devices$Perception$PerceptionDepthFrameSourceAddedEventArgs>;
addEventListener(
type: "sourceadded",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSourceWatcher, Windows$Devices$Perception$PerceptionDepthFrameSourceAddedEventArgs>): void;
removeEventListener(
type: "sourceadded",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSourceWatcher, Windows$Devices$Perception$PerceptionDepthFrameSourceAddedEventArgs>): void;

/**
 * Subscribes to the SourceRemoved event. This event is fired once for every depth frame source that is removed.
 */
onsourceremoved: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSourceWatcher, Windows$Devices$Perception$PerceptionDepthFrameSourceRemovedEventArgs>;
addEventListener(
type: "sourceremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSourceWatcher, Windows$Devices$Perception$PerceptionDepthFrameSourceRemovedEventArgs>): void;
removeEventListener(
type: "sourceremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSourceWatcher, Windows$Devices$Perception$PerceptionDepthFrameSourceRemovedEventArgs>): void;

/**
 * Subscribes to the Stopped event. This event is fired when the IPerceptionColorFrameSourceWatcher has stopped listening for changes to the list of depth frame sources.
 */
onstopped: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSourceWatcher, any>;
addEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSourceWatcher, any>): void;
removeEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionDepthFrameSourceWatcher, any>): void;

/**
 * When this method is called, the depth frame source watcher enumerates any existing depth frame sources it has not already enumerated by firing a SourceAdded event for each one. An EnumerationCompleted event is fired when this enumeration is complete. The depth frame source then starts watching for new depth frame sources.
 */
start(): void;

/**
 * Gets the operational status of the depth frame source watcher.
 */
status: $Values<typeof Windows$Devices$Enumeration$DeviceWatcherStatus>;

/**
 * When this method is called, the depth frame source watcher stops looking for changes to the depth frame source list. This operation is not immediate; the Stopped event will be triggered when the Stop operation is complete.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Indicates the access status an app is allowed for a particular type of frame source.
 */

declare  var Windows$Devices$Perception$PerceptionFrameSourceAccessStatus: {|
  +unspecified: 0,// 0
+allowed: 1,// 1
+deniedByUser: 2,// 2
+deniedBySystem: 3,// 3

|};



/**
 * Contains information about an attempt to change properties on a frame source.
 */
declare class Windows$Devices$Perception$PerceptionFrameSourcePropertiesChangedEventArgs  {

/**
 * Gets the type of change that occurred as a result of the property change request.
 */
collectionChange: $Values<typeof Windows$Foundation$Collections$CollectionChange>;

/**
 * Gets a string key indicating the location of the change in the collection.
 */
key: string
}


/**
 * Contains information about an attempted property change on a frame source.
 */
declare class Windows$Devices$Perception$PerceptionFrameSourcePropertyChangeResult  {

/**
 * Gets a PerceptionFrameSourcePropertyChangeStatus indicating the status of the change request, including whether or not the change took effect.
 */
newValue: any;

/**
 * Gets the value of the property after the change request has been processed.
 */
status: $Values<typeof Windows$Devices$Perception$PerceptionFrameSourcePropertyChangeStatus>
}


/**
 * Indicates the status of a property change that an app requested of a frame source.
 */

declare  var Windows$Devices$Perception$PerceptionFrameSourcePropertyChangeStatus: {|
  +unknown: 0,// 0
+accepted: 1,// 1
+lostControl: 2,// 2
+propertyNotSupported: 3,// 3
+propertyReadOnly: 4,// 4
+valueOutOfRange: 5,// 5

|};



/**
 * Contains a Windows.Media.VideoFrame with the infrared frame data.
 */
declare class Windows$Devices$Perception$PerceptionInfraredFrame  {

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 */
close(): void;

/**
 * Gets a Windows.Media.VideoFrame with the infrared frame data.
 */
videoFrame: Windows$Media$VideoFrame
}


/**
 * Contains information about a infrared frame arrived event.
 */
declare class Windows$Devices$Perception$PerceptionInfraredFrameArrivedEventArgs  {

/**
 * Gets the relative time of this frame.
 */
relativeTime: number;

/**
 * Attempts to open the infrared frame that has arrived.
 * @return If the attempt is successful, this method returns the newly-arrived infrared frame. If the attempt is unsuccessful, this value is unchanged.
 */
tryOpenFrame(): Windows$Devices$Perception$PerceptionInfraredFrame
}


/**
 * Reads infrared frames from a infrared frame source.
 */
declare class Windows$Devices$Perception$PerceptionInfraredFrameReader  {

/**
 * Releases system resources that are exposed by a Windows Runtime object
 */
close(): void;

/**
 * Gets a boolean value indicating whether or not this reader is paused.
 */
isPaused: boolean;

/**
 * Subscribes to the FrameArrived event. This event is fired whenever a new frame arrives from the infrared frame source.
 */
onframearrived: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameReader, Windows$Devices$Perception$PerceptionInfraredFrameArrivedEventArgs>;
addEventListener(
type: "framearrived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameReader, Windows$Devices$Perception$PerceptionInfraredFrameArrivedEventArgs>): void;
removeEventListener(
type: "framearrived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameReader, Windows$Devices$Perception$PerceptionInfraredFrameArrivedEventArgs>): void;

/**
 * Gets the infrared frame source this reader gets frames from.
 */
source: Windows$Devices$Perception$PerceptionInfraredFrameSource;

/**
 * Attempts to read the most recent frame that is available to this infrared frame reader.
 * @return If the attempt was successful, this method returns the most recent frame that is available to this infrared frame reader. If the attempt was not successful, this method returns null.
 */
tryReadLatestFrame(): Windows$Devices$Perception$PerceptionInfraredFrame;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * A frame source that provides infrared frames.
 */
declare class Windows$Devices$Perception$PerceptionInfraredFrameSource  {

/**
 * Creates a new infrared frame source watcher.
 * @return A new infrared frame source watcher.
 */
static createWatcher(): Windows$Devices$Perception$PerceptionInfraredFrameSourceWatcher;

/**
 * Finds all infrared frame sources.
 * @return When the method completes, it asynchronously returns a list of infrared frame sources.
 */
static findAllAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Finds an infrared frame source by looking up its unique ID.
 * @param id The unique ID of the infrared frame source.
 * @return When the method completes, it asynchronously returns an infrared frame source if one exists with the specified ID. Otherwise, this method asynchronously returns nullptr.
 */
static fromIdAsync(
id: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Perception$PerceptionInfraredFrameSource>;

/**
 * Requests access to use infrared frame sources.
 * @return When this method completes, it asynchronously returns a PerceptionFrameSourceAccessStatus indicating the result of the access request.
 */
static requestAccessAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Devices$Perception$PerceptionFrameSourceAccessStatus>>;

/**
 * Attempts to acquire Controller Mode on the infrared frame source.
 * @return If the attempt is successful, this returns a PerceptionControlSession object that can be used to control properties of the infrared frame source. Otherwise, this returns null.
 */
acquireControlSession(): Windows$Devices$Perception$PerceptionControlSession;

/**
 * Gets a boolean value indicating whether or not the source is active.
 */
active: boolean;

/**
 * Gets a boolean value indicating whether or not the source is available.
 */
available: boolean;

/**
 * Gets a read-only collection of video profiles that are currently available from the infrared frame source.
 */
availableVideoProfiles: Windows$Foundation$Collections$IVectorView<Windows$Devices$Perception$PerceptionVideoProfile>;

/**
 * Gets a CameraIntrinsics value specifying the intrinsic properties of the infrared frame source camera device.
 */
cameraIntrinsics: Windows$Media$Devices$Core$CameraIntrinsics;

/**
 * Retrieves a boolean value indicating whether or not the infrared frame source can be controlled separately from another frame source.
 * @param targetId A string representing the unique ID of the other frame source.
 * @return True if the two sources can be controlled independently of one another, otherwise false.
 */
canControlIndependentlyFrom(targetId: string): boolean;
deviceId: any;

/**
 * Gets a string value indicating the kind of physical device that generates the infrared frames.
 */
deviceKind: string;

/**
 * Gets a string value indicating the display name of the infrared frame source.
 */
displayName: string;

/**
 * Gets a string value indicating the unique ID of the infrared frame source.
 */
id: string;

/**
 * Gets a boolean value indicating whether or not the source is the subject of controller mode.
 */
isControlled: boolean;

/**
 * Checks whether or not the infrared frame source is correlated with the target entity.
 * @param targetId The unique ID of the target entity.
 * @return True if a correlation exists, otherwise false. If the result is true, a transform matrix can be retrieved to change coordinate basis from this infrared frame source to the entity, or vice versa.
 */
isCorrelatedWith(targetId: string): boolean;

/**
 * Subscribes to the ActiveChanged event.
 */
onactivechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSource, any>;
addEventListener(
type: "activechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSource, any>): void;
removeEventListener(
type: "activechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSource, any>): void;

/**
 * Subscribes to the AvailableChanged event.
 */
onavailablechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSource, any>;
addEventListener(
type: "availablechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSource, any>): void;
removeEventListener(
type: "availablechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSource, any>): void;

/**
 * Subscribes to the CameraIntrinsicsChanged event.
 */
oncameraintrinsicschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSource, any>;
addEventListener(
type: "cameraintrinsicschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSource, any>): void;
removeEventListener(
type: "cameraintrinsicschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSource, any>): void;

/**
 * Subscribes to the PropertiesChanged event.
 */
onpropertieschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSource, Windows$Devices$Perception$PerceptionFrameSourcePropertiesChangedEventArgs>;
addEventListener(
type: "propertieschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSource, Windows$Devices$Perception$PerceptionFrameSourcePropertiesChangedEventArgs>): void;
removeEventListener(
type: "propertieschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSource, Windows$Devices$Perception$PerceptionFrameSourcePropertiesChangedEventArgs>): void;

/**
 * Subscribes to the VideoProfileChanged event.
 */
onvideoprofilechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSource, any>;
addEventListener(
type: "videoprofilechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSource, any>): void;
removeEventListener(
type: "videoprofilechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSource, any>): void;

/**
 * Gets a frame reader that reads frames from this infrared frame source.
 * @return A frame reader that reads frames from this infrared frame source.
 */
openReader(): Windows$Devices$Perception$PerceptionInfraredFrameReader;

/**
 * Gets a read-only collection of frame source properties.
 */
properties: Windows$Foundation$Collections$IMapView<string, any>;

/**
 * Gets a read-only collection of video profiles that are supported by the infrared frame source.
 */
supportedVideoProfiles: Windows$Foundation$Collections$IVectorView<Windows$Devices$Perception$PerceptionVideoProfile>;

/**
 * Attempts to get the intrinsic properties of the depth camera that is correlated with this infrared source.
 * @param target The depth frame source to try to get intrinsic properties of.
 * @return If the attempt is successful, this returns a read-only collection of PerceptionDepthCorrelatedCameraIntrinsics objects specifying the intrinsic properties of the camera used by the correlated depth frame source. Otherwise, this returns null.
 */
tryGetDepthCorrelatedCameraIntrinsicsAsync(
target: Windows$Devices$Perception$PerceptionDepthFrameSource): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Perception$PerceptionDepthCorrelatedCameraIntrinsics>;

/**
 * Attempts to get a coordinate mapper that maps from infrared frame image space to depth frame space.
 * @param targetId The unique ID of the depth frame source to try to map to.
 * @param depthFrameSourceToMapWith The depth frame source to try to map to. This should be in a correlation group with the infrared frame source.
 * @return If the two sources are correlated, this method returns a PerceptionDepthCorrelatedCoordinateMapper. Otherwise, it returns null. This method returns asynchronously.
 */
tryGetDepthCorrelatedCoordinateMapperAsync(
targetId: string,
depthFrameSourceToMapWith: Windows$Devices$Perception$PerceptionDepthFrameSource): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Perception$PerceptionDepthCorrelatedCoordinateMapper>;

/**
 * Gets the transform from the infrared frame source to the target entity and sets hasResult to true, if a correlation exists. If a correlation does not exist, hasResult is set to false and result is not modified.
 * @param targetId The unique ID of the target entity.
 */
tryGetTransformTo(
targetId: string): {
result: Windows$Foundation$Numerics$Matrix4x4,
returnValue: boolean
};

/**
 * Attempts to set a video profile on this infrared frame source. Requires an active Controller Mode control session on this frame source.
 * @param controlSession A PerceptionControlSession representing active control of this frame source.
 * @param profile The video profile to set.
 * @return This method returns an PerceptionFrameSourcePropertyChangeResult object asynchonously. If the control session was still active when the video profile was set, and if the video profile is supported and can be activated, this will be a success result.
 */
trySetVideoProfileAsync(
controlSession: Windows$Devices$Perception$PerceptionControlSession,
profile: Windows$Devices$Perception$PerceptionVideoProfile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Perception$PerceptionFrameSourcePropertyChangeResult>;

/**
 * Gets a PerceptionVideoProfile object indicating the current video profile.
 */
videoProfile: Windows$Devices$Perception$PerceptionVideoProfile;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Event data for infrared frame source added events.
 */
declare class Windows$Devices$Perception$PerceptionInfraredFrameSourceAddedEventArgs  {

/**
 * Gets the infrared frame source that was added.
 */
frameSource: Windows$Devices$Perception$PerceptionInfraredFrameSource
}


/**
 * Event data for infrared frame source removed events.
 */
declare class Windows$Devices$Perception$PerceptionInfraredFrameSourceRemovedEventArgs  {

/**
 * Gets the infrared frame source that was removed.
 */
frameSource: Windows$Devices$Perception$PerceptionInfraredFrameSource
}


/**
 * Monitors changes to the list of infrared frame sources, and provides notifications when the list changes.
 */
declare class Windows$Devices$Perception$PerceptionInfraredFrameSourceWatcher  {

/**
 * Subscribes to the EnumerationCompleted event. This event is fired after the initial enumeration of known infrared frame sources is complete.
 */
onenumerationcompleted: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSourceWatcher, any>;
addEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSourceWatcher, any>): void;
removeEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSourceWatcher, any>): void;

/**
 * Subscribes to the SourceAdded event.
 */
onsourceadded: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSourceWatcher, Windows$Devices$Perception$PerceptionInfraredFrameSourceAddedEventArgs>;
addEventListener(
type: "sourceadded",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSourceWatcher, Windows$Devices$Perception$PerceptionInfraredFrameSourceAddedEventArgs>): void;
removeEventListener(
type: "sourceadded",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSourceWatcher, Windows$Devices$Perception$PerceptionInfraredFrameSourceAddedEventArgs>): void;

/**
 * Subscribes to the SourceRemoved event. This event is fired once for every infrared frame source that is removed.
 */
onsourceremoved: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSourceWatcher, Windows$Devices$Perception$PerceptionInfraredFrameSourceRemovedEventArgs>;
addEventListener(
type: "sourceremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSourceWatcher, Windows$Devices$Perception$PerceptionInfraredFrameSourceRemovedEventArgs>): void;
removeEventListener(
type: "sourceremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSourceWatcher, Windows$Devices$Perception$PerceptionInfraredFrameSourceRemovedEventArgs>): void;

/**
 * Subscribes to the Stopped event. This event is fired when the IPerceptionColorFrameSourceWatcher has stopped listeningfor changes to the list of infrared frame sources.
 */
onstopped: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSourceWatcher, any>;
addEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSourceWatcher, any>): void;
removeEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Perception$PerceptionInfraredFrameSourceWatcher, any>): void;

/**
 * When this method is called, the infrared frame source watcher enumerates any existing infrared frame sources it has not already enumerated by firing a SourceAdded event for each one. An EnumerationCompleted event is fired when this enumeration is complete. The infrared frame source then starts watching for new infrared frame sources.
 */
start(): void;

/**
 * Gets the operational status of the infrared frame source watcher.
 */
status: $Values<typeof Windows$Devices$Enumeration$DeviceWatcherStatus>;

/**
 * When this method is called, the infrared frame source watcher stops looking for changes to the infrared frame source list. This operation is not immediate; the Stopped event will be triggered when the Stop operation is complete.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a Windows.Devices.Perception video profile.
 */
declare class Windows$Devices$Perception$PerceptionVideoProfile  {

/**
 * Gets the bitmap alpha mode.
 */
bitmapAlphaMode: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>;

/**
 * Gets the bitmap pixel format.
 */
bitmapPixelFormat: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>;

/**
 * Gets the time duration of each frame.
 */
frameDuration: number;

/**
 * Gets the frame height, in pixels.
 */
height: number;

/**
 * A comparison function used to determine if two IPerceptionVideoProfile objects are equivalent.
 * @param other The IPerceptionVideoProfile object to compare to this one.
 * @return True if the two video profiles are equivalent, otherwise false.
 */
isEqual(other: Windows$Devices$Perception$PerceptionVideoProfile): boolean;

/**
 * Gets the frame width, in pixels.
 */
width: number
}


      declare var npm$namespace$Windows$Devices$Perception$Provider: {
        
        
        
        KnownPerceptionFrameKind: typeof Windows$Devices$Perception$Provider$KnownPerceptionFrameKind,
PerceptionControlGroup: typeof Windows$Devices$Perception$Provider$PerceptionControlGroup,
PerceptionCorrelation: typeof Windows$Devices$Perception$Provider$PerceptionCorrelation,
PerceptionCorrelationGroup: typeof Windows$Devices$Perception$Provider$PerceptionCorrelationGroup,
PerceptionFaceAuthenticationGroup: typeof Windows$Devices$Perception$Provider$PerceptionFaceAuthenticationGroup,
PerceptionFrame: typeof Windows$Devices$Perception$Provider$PerceptionFrame,
PerceptionFrameProviderInfo: typeof Windows$Devices$Perception$Provider$PerceptionFrameProviderInfo,
PerceptionFrameProviderManagerService: typeof Windows$Devices$Perception$Provider$PerceptionFrameProviderManagerService,
PerceptionPropertyChangeRequest: typeof Windows$Devices$Perception$Provider$PerceptionPropertyChangeRequest,
PerceptionVideoFrameAllocator: typeof Windows$Devices$Perception$Provider$PerceptionVideoFrameAllocator,
        
      }

/**
 * A string used to identify the type classification of a frame.
 */
declare class Windows$Devices$Perception$Provider$KnownPerceptionFrameKind  {

/**
 * Gets the string representing the Color FrameKind of a PerceptionFrameProviderInfo.
 */
static color: string;

/**
 * Gets the string representing the Depth FrameKind of a PerceptionFrameProviderInfo.
 */
static depth: string;

/**
 * Gets the string representing the Infrared FrameKind of a PerceptionFrameProviderInfo.
 */
static infrared: string
}


/**
 * A group of IPerceptionFrameProvider identifiers to be controlled together.
 */
declare class Windows$Devices$Perception$Provider$PerceptionControlGroup  {

/**
 * Creates a PerceptionControlGroup containing the IPerceptionFrameProviders with the ids specified.
 * @param ids A list of the unique identifiers associated with the grouped IPerceptionFrameProviders. To be controllable, the id must match the associated PerceptionFrameProviderInfo::Id property.
 */
constructor(ids: Windows$Foundation$Collections$IIterable<string>): this;

/**
 * The id(s) of the IPerceptionFrameProvider(s) controlled by this group.
 */
frameProviderIds: Windows$Foundation$Collections$IVectorView<string>
}


/**
 * A description of the physical position and orientation of a device specified by the IPerceptionFrameProvider's unique identifier (PerceptionFrameProviderInfo::Id) sharing a common coordinate frame of other PerceptionCorrelations that will be combined into a PerceptionCorrelationGroup.
 */
declare class Windows$Devices$Perception$Provider$PerceptionCorrelation  {

/**
 * Initializes a new PerceptionCorrelation instance.
 * @param targetId The unique identifier of the IPerceptionFrameProvider being described.
 * @param position The position of the device in a common coordinate frame of all members of a PerceptionCorrelationGroup.
 * @param orientation The orientation of the device in a common coordinate frame of all members of a PerceptionCorrelationGroup.
 */
constructor(targetId: string, position: Windows$Foundation$Numerics$Vector3, orientation: Windows$Foundation$Numerics$Quaternion): this;

/**
 * The orientation of the device in the common coordinate frame shared by other PerceptionCorrelations in the PerceptionCorrelationGroup.
 */
orientation: Windows$Foundation$Numerics$Quaternion;

/**
 * The position of the device in the common coordinate frame shared by other PerceptionCorrelations in the PerceptionCorrelationGroup.
 */
position: Windows$Foundation$Numerics$Vector3;

/**
 * The unique identifier of the described device.
 */
targetId: string
}


/**
 * A collection of PerceptionCorrelations describing multiple unique providers in a common coordinate frame.
 */
declare class Windows$Devices$Perception$Provider$PerceptionCorrelationGroup  {

/**
 * Initializes a new PerceptionCorrelationGroup from a collection of one or more PerceptionCorrelation objects describing multiple providers in a common coordinate frame.
 * @param relativeLocations The collection of PerceptionCorrelations describing multiple providers in a common coordinate frame.
 */
constructor(relativeLocations: Windows$Foundation$Collections$IIterable<Windows$Devices$Perception$Provider$PerceptionCorrelation>): this;

/**
 * The collection of PerceptionCorrelations describing multiple unique providers in a common coordinate frame.
 */
relativeLocations: Windows$Foundation$Collections$IVectorView<Windows$Devices$Perception$Provider$PerceptionCorrelation>
}


/**
 * A group of unique identifiers specifying IPerceptionFrameProviders that share handlers for entering and exiting Face Authentication mode.
 */
declare class Windows$Devices$Perception$Provider$PerceptionFaceAuthenticationGroup  {

/**
 * Initializes a new PerceptionFaceAuthenticationGroup instance.
 * @param ids The collection of unique identifiers which maps to IPerceptionFrameProviders via PerceptionFrameProviderInfo::Id.
 * @param startHandler The handler to invoke when this group is requested to enter Face Authentication mode returning if it's ready.
 * @param stopHandler The handler to invoke when this group is leaving Face Authentication mode after startHandler is called and returned true.
 */
constructor(ids: Windows$Foundation$Collections$IIterable<string>, startHandler: Windows$Devices$Perception$Provider$PerceptionStartFaceAuthenticationHandler, stopHandler: Windows$Devices$Perception$Provider$PerceptionStopFaceAuthenticationHandler): this;

/**
 * The id(s) of the IPerceptionFrameProvider(s) referenced by this group.
 */
frameProviderIds: Windows$Foundation$Collections$IVectorView<string>
}


/**
 * Represents a frame of data from the device.
 */
declare class Windows$Devices$Perception$Provider$PerceptionFrame  {

/**
 * The actual bytes of the frame which can be consumed as described by the Properties of the IPerceptionFrameProvider which produced the frame.
 */
frameData: Windows$Foundation$IMemoryBuffer;

/**
 * Gets the Properties for this frame.
 */
properties: Windows$Foundation$Collections$ValueSet;

/**
 * Gets or sets the Relative Time of this frame relative to other frames from this IPerceptionFrameProvider.
 */
relativeTime: number
}


/**
 * A specific set of properties describing a unique IPerceptionFrameProvider.
 */
declare class Windows$Devices$Perception$Provider$PerceptionFrameProviderInfo  {

/**
 * Initializes a new PerceptionFrameProviderInfo instance.
 */
constructor(): this;

/**
 * Gets or sets the descriptor of the kind of FrameProvider categorically, for example, "com.contoso.depthcamera.x500".
 */
deviceKind: string;

/**
 * Gets or sets the friendly name for the device, for example, "Contoso Depth Camera x500".
 */
displayName: string;

/**
 * Gets or sets the type of frames the device creates.
 */
frameKind: string;

/**
 * Gets or sets a value indicating whether the device enumerates via FindAllAsync or device-added events on source watchers.
 */
hidden: boolean;

/**
 * Gets or sets the unique identifier of the IPerceptionFrameProvider.
 */
id: string
}


/**
 * Static methods for managing IPerceptionFrameProvider registration and unregistration, PerceptionFaceAuthenticationGroup registration and unregistration, PerceptionControlGroup registration and unregistration, PerceptionCorrelationGroup registration and unregistration, IPerceptionFrameProvider availablity, and publishing a new PerceptionFrame for an IPerceptionFrameProvider.
 */
declare class Windows$Devices$Perception$Provider$PerceptionFrameProviderManagerService  {

/**
 * Sends the PerceptionFrame to the service to tell any apps listening for frames for the provided provider. Frames aren't expected to be published before IPerceptionFrameProvider::Start() is called or after IPerceptionFrameProvider::Stop() is called.
 * @param provider The IPerceptionFrameProvider which produced the frame.
 * @param frame The PerceptionFrame that was produced and should be sent to apps.
 */
static publishFrameForProvider(
provider: Windows$Devices$Perception$Provider$IPerceptionFrameProvider,
frame: Windows$Devices$Perception$Provider$PerceptionFrame): void;

/**
 * Registers a PerceptionControlGroup associated with the IPerceptionFrameProviderManager.
 * @param manager The manager that owns the lifetime of the group.
 * @param controlGroup The group of IPerceptionFrameProvider(s) to control atomically.
 */
static registerControlGroup(
manager: Windows$Devices$Perception$Provider$IPerceptionFrameProviderManager,
controlGroup: Windows$Devices$Perception$Provider$PerceptionControlGroup): void;

/**
 * Registers a PerceptionCorrelationGroup associated with the IPerceptionFrameProviderManager.
 * @param manager The manager that owns the lifetime of the group.
 * @param correlationGroup The group of PerceptionCorrelations(s) to control atomically.
 */
static registerCorrelationGroup(
manager: Windows$Devices$Perception$Provider$IPerceptionFrameProviderManager,
correlationGroup: Windows$Devices$Perception$Provider$PerceptionCorrelationGroup): void;

/**
 * Registers a PerceptionFaceAuthenticationGroup associated with the given IPerceptionProviderManager.
 * @param manager The manager that owns the lifetime of the group.
 * @param faceAuthenticationGroup The group of IPerceptionFrameProvider(s) to atomically control.
 */
static registerFaceAuthenticationGroup(
manager: Windows$Devices$Perception$Provider$IPerceptionFrameProviderManager,
faceAuthenticationGroup: Windows$Devices$Perception$Provider$PerceptionFaceAuthenticationGroup): void;

/**
 * Registers the PerceptionFrameProviderInfo in association with the given IPerceptionFrameProviderManager.
 * @param manager The manager which can provide the IPerceptionFrameProvider associated with the info.
 * @param frameProviderInfo The PerceptionFrameProviderInfo which identifies the available IPerceptionFrameProvider.
 */
static registerFrameProviderInfo(
manager: Windows$Devices$Perception$Provider$IPerceptionFrameProviderManager,
frameProviderInfo: Windows$Devices$Perception$Provider$PerceptionFrameProviderInfo): void;

/**
 * Removes the registration of a previously registered PerceptionControlGroup.
 * @param manager The manager that owns the lifetime of the group.
 * @param controlGroup The group of IPerceptionFrameProvider(s) to prevent from being controlled.
 */
static unregisterControlGroup(
manager: Windows$Devices$Perception$Provider$IPerceptionFrameProviderManager,
controlGroup: Windows$Devices$Perception$Provider$PerceptionControlGroup): void;

/**
 * Unregisters a PerceptionCorrelationGroup associated with the IPerceptionFrameProviderManager.
 * @param manager The manager that owns the lifetime of the group.
 * @param correlationGroup The PerceptionCorrelationGroup to unregister.
 */
static unregisterCorrelationGroup(
manager: Windows$Devices$Perception$Provider$IPerceptionFrameProviderManager,
correlationGroup: Windows$Devices$Perception$Provider$PerceptionCorrelationGroup): void;

/**
 * Unregisters a PerceptionFaceAuthenticationGroup in association with the given IPerceptionProviderManager.
 * @param manager The manager that owns the lifetime of the group.
 * @param faceAuthenticationGroup The PerceptionFaceAuthenticationGroup to unregister.
 */
static unregisterFaceAuthenticationGroup(
manager: Windows$Devices$Perception$Provider$IPerceptionFrameProviderManager,
faceAuthenticationGroup: Windows$Devices$Perception$Provider$PerceptionFaceAuthenticationGroup): void;

/**
 * Unregisters the PerceptionFrameProviderInfo in association with the given IPerceptionProviderManager.
 * @param manager The manager which previously registered this info.
 * @param frameProviderInfo The PerceptionFrameProviderInfo which identifies the IPerceptionFrameProvider.
 */
static unregisterFrameProviderInfo(
manager: Windows$Devices$Perception$Provider$IPerceptionFrameProviderManager,
frameProviderInfo: Windows$Devices$Perception$Provider$PerceptionFrameProviderInfo): void;

/**
 * Sets whether or not the IPerceptionFrameProvider is available.
 * @param provider The provider to set availability for.
 * @param available Whether or not the provider is available.
 */
static updateAvailabilityForProvider(
provider: Windows$Devices$Perception$Provider$IPerceptionFrameProvider,
available: boolean): void
}


/**
 * A request from an app that's in control of this IPerceptionFrameProvider to update a property.
 */
declare class Windows$Devices$Perception$Provider$PerceptionPropertyChangeRequest  {

/**
 * Gets a Windows::Foundation::Deferral object to allow background processing if needed.
 * @return The Deferral object.
 */
getDeferral(): Windows$Foundation$Deferral;

/**
 * Gets the name of the property to change.
 */
name: string;

/**
 * Sets the new status of the request after processing the request.
 */
status: $Values<typeof Windows$Devices$Perception$PerceptionFrameSourcePropertyChangeStatus>;

/**
 * Gets the requested new value of the property.
 */
value: any
}


/**
 * An allocator that can create PerceptionFrames directly which can be written into or copied from Windows::Media::VideoFrame into a PerceptionFrame.
 */
declare class Windows$Devices$Perception$Provider$PerceptionVideoFrameAllocator  {

/**
 * Initializes a new PerceptionVideoFrameAllocator with the required properties for use by the IPerceptionFrameProvider to create PerceptionFrames published via PerceptionFrameProviderManagerService::PublishFrameForProvider.
 * @param maxOutstandingFrameCountForWrite This is the number of buffers in flight required by the FrameProvider to produce its * frames at framerate. The suggestion is at least 2.
 * @param format The Windows::Graphics::Imaging::BitmapPixelFormat describing the format of the bytes of the frame.
 * @param resolution The resolution in pixels of the frame.
 * @param alpha The Windows::Graphics::Imaging::BitmapAlphaMode describing how transparency is handled in the pixels.
 */
constructor(maxOutstandingFrameCountForWrite: number, format: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>, resolution: Windows$Foundation$Size, alpha: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>): this;

/**
 * Creates an empty PerceptionFrame with the properties specified when creating the PerceptionVideoFrameAllocator.
 * @return The empty frame with the properties specified when creating the PerceptionVideoFrameAllocator.
 */
allocateFrame(): Windows$Devices$Perception$Provider$PerceptionFrame;

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 */
close(): void;

/**
 * Creates a deep copy of the video FrameProvider with the bytes already filled in with the resulting PerceptionFrame.
 * @param frame The input frame from which to copy the pixel data.
 * @return The resulting filled PerceptionFrame.
 */
copyFromVideoFrame(
frame: Windows$Media$VideoFrame): Windows$Devices$Perception$Provider$PerceptionFrame
}


/**
 * Invoked when a PerceptionFaceAuthenticationGroup enters Face Authentication mode.
 */
declare type Windows$Devices$Perception$Provider$PerceptionStartFaceAuthenticationHandler = (
sender: Windows$Devices$Perception$Provider$PerceptionFaceAuthenticationGroup) => void;


/**
 * Invoked when a PerceptionFaceAuthenticationGroup exits Face Authentication mode. This will only be invoked after the group received a PerceptionStartFaceAuthenticationHandler from which it returned true.
 */
declare type Windows$Devices$Perception$Provider$PerceptionStopFaceAuthenticationHandler = (
sender: Windows$Devices$Perception$Provider$PerceptionFaceAuthenticationGroup) => void;


/**
 * Represents an object that can produce PerceptionFrames.
 */
declare type Windows$Devices$Perception$Provider$IPerceptionFrameProvider = {

/**
 * The device is requested to update one of its Properties to a new value.
 * @param value Success or failure will be conveyed to the app.
 */
setProperty(
value: Windows$Devices$Perception$Provider$PerceptionPropertyChangeRequest): void,

/**
 * Tells the device to start producing frames. If success is returned, PerceptionFrameProviderManagerService::PublishFrameForProvider is expected to be called by this Provider.
 */
start(): void,

/**
 * Tells the device to stop producing frames. Called only after Start is called and only if Start returns success.
 */
stop(): void,

/**
 * Gets a value indicating whether or not the device is ready to start producing PerceptionFrames.
 */
available: boolean,

/**
 * Gets the PerceptionFrameProviderInfo describing this device.
 */
frameProviderInfo: Windows$Devices$Perception$Provider$PerceptionFrameProviderInfo,

/**
 * The properties describing the device and the frames produced by the device.
 */
properties: Windows$Foundation$Collections$IPropertySet
} & Windows$Foundation$IClosable



/**
 * The IPerceptionFrameProviderManager is expected to provide any IPerceptionFrameProvider that has been registered via PerceptionFrameProviderManagerService::RegisterFrameProviderInfo().
 */
declare type Windows$Devices$Perception$Provider$IPerceptionFrameProviderManager = {

/**
 * The method to request an IPerceptionFrameProvider associated with a registered PerceptionFrameProviderInfo.
 * @param frameProviderInfo The info specifying the desired IPerceptionFrameProvider.
 * @return The associated IPerceptionFrameProvider, or nullptr if there is no such registerd provider.
 */
getFrameProvider(
frameProviderInfo: Windows$Devices$Perception$Provider$PerceptionFrameProviderInfo): Windows$Devices$Perception$Provider$IPerceptionFrameProvider
} & Windows$Foundation$IClosable



      declare var npm$namespace$Windows$Devices$PointOfService: {
        
        
        BarcodeScannerStatus: typeof Windows$Devices$PointOfService$BarcodeScannerStatus,
CashDrawerStatusKind: typeof Windows$Devices$PointOfService$CashDrawerStatusKind,
MagneticStripeReaderAuthenticationLevel: typeof Windows$Devices$PointOfService$MagneticStripeReaderAuthenticationLevel,
MagneticStripeReaderAuthenticationProtocol: typeof Windows$Devices$PointOfService$MagneticStripeReaderAuthenticationProtocol,
MagneticStripeReaderErrorReportingType: typeof Windows$Devices$PointOfService$MagneticStripeReaderErrorReportingType,
MagneticStripeReaderStatus: typeof Windows$Devices$PointOfService$MagneticStripeReaderStatus,
MagneticStripeReaderTrackErrorType: typeof Windows$Devices$PointOfService$MagneticStripeReaderTrackErrorType,
MagneticStripeReaderTrackIds: typeof Windows$Devices$PointOfService$MagneticStripeReaderTrackIds,
PosPrinterAlignment: typeof Windows$Devices$PointOfService$PosPrinterAlignment,
PosPrinterBarcodeTextPosition: typeof Windows$Devices$PointOfService$PosPrinterBarcodeTextPosition,
PosPrinterCartridgeSensors: typeof Windows$Devices$PointOfService$PosPrinterCartridgeSensors,
PosPrinterColorCapabilities: typeof Windows$Devices$PointOfService$PosPrinterColorCapabilities,
PosPrinterColorCartridge: typeof Windows$Devices$PointOfService$PosPrinterColorCartridge,
PosPrinterLineDirection: typeof Windows$Devices$PointOfService$PosPrinterLineDirection,
PosPrinterLineStyle: typeof Windows$Devices$PointOfService$PosPrinterLineStyle,
PosPrinterMapMode: typeof Windows$Devices$PointOfService$PosPrinterMapMode,
PosPrinterMarkFeedCapabilities: typeof Windows$Devices$PointOfService$PosPrinterMarkFeedCapabilities,
PosPrinterMarkFeedKind: typeof Windows$Devices$PointOfService$PosPrinterMarkFeedKind,
PosPrinterPrintSide: typeof Windows$Devices$PointOfService$PosPrinterPrintSide,
PosPrinterRotation: typeof Windows$Devices$PointOfService$PosPrinterRotation,
PosPrinterRuledLineCapabilities: typeof Windows$Devices$PointOfService$PosPrinterRuledLineCapabilities,
PosPrinterStatusKind: typeof Windows$Devices$PointOfService$PosPrinterStatusKind,
UnifiedPosErrorReason: typeof Windows$Devices$PointOfService$UnifiedPosErrorReason,
UnifiedPosErrorSeverity: typeof Windows$Devices$PointOfService$UnifiedPosErrorSeverity,
UnifiedPosHealthCheckLevel: typeof Windows$Devices$PointOfService$UnifiedPosHealthCheckLevel,
UnifiedPosPowerReportingType: typeof Windows$Devices$PointOfService$UnifiedPosPowerReportingType,
        BarcodeScanner: typeof Windows$Devices$PointOfService$BarcodeScanner,
BarcodeScannerCapabilities: typeof Windows$Devices$PointOfService$BarcodeScannerCapabilities,
BarcodeScannerDataReceivedEventArgs: typeof Windows$Devices$PointOfService$BarcodeScannerDataReceivedEventArgs,
BarcodeScannerErrorOccurredEventArgs: typeof Windows$Devices$PointOfService$BarcodeScannerErrorOccurredEventArgs,
BarcodeScannerImagePreviewReceivedEventArgs: typeof Windows$Devices$PointOfService$BarcodeScannerImagePreviewReceivedEventArgs,
BarcodeScannerReport: typeof Windows$Devices$PointOfService$BarcodeScannerReport,
BarcodeScannerStatusUpdatedEventArgs: typeof Windows$Devices$PointOfService$BarcodeScannerStatusUpdatedEventArgs,
BarcodeSymbologies: typeof Windows$Devices$PointOfService$BarcodeSymbologies,
CashDrawer: typeof Windows$Devices$PointOfService$CashDrawer,
CashDrawerCapabilities: typeof Windows$Devices$PointOfService$CashDrawerCapabilities,
CashDrawerCloseAlarm: typeof Windows$Devices$PointOfService$CashDrawerCloseAlarm,
CashDrawerClosedEventArgs: typeof Windows$Devices$PointOfService$CashDrawerClosedEventArgs,
CashDrawerEventSource: typeof Windows$Devices$PointOfService$CashDrawerEventSource,
CashDrawerOpenedEventArgs: typeof Windows$Devices$PointOfService$CashDrawerOpenedEventArgs,
CashDrawerStatus: typeof Windows$Devices$PointOfService$CashDrawerStatus,
CashDrawerStatusUpdatedEventArgs: typeof Windows$Devices$PointOfService$CashDrawerStatusUpdatedEventArgs,
ClaimedBarcodeScanner: typeof Windows$Devices$PointOfService$ClaimedBarcodeScanner,
ClaimedCashDrawer: typeof Windows$Devices$PointOfService$ClaimedCashDrawer,
ClaimedJournalPrinter: typeof Windows$Devices$PointOfService$ClaimedJournalPrinter,
ClaimedMagneticStripeReader: typeof Windows$Devices$PointOfService$ClaimedMagneticStripeReader,
ClaimedPosPrinter: typeof Windows$Devices$PointOfService$ClaimedPosPrinter,
ClaimedReceiptPrinter: typeof Windows$Devices$PointOfService$ClaimedReceiptPrinter,
ClaimedSlipPrinter: typeof Windows$Devices$PointOfService$ClaimedSlipPrinter,
JournalPrintJob: typeof Windows$Devices$PointOfService$JournalPrintJob,
JournalPrinterCapabilities: typeof Windows$Devices$PointOfService$JournalPrinterCapabilities,
MagneticStripeReader: typeof Windows$Devices$PointOfService$MagneticStripeReader,
MagneticStripeReaderAamvaCardDataReceivedEventArgs: typeof Windows$Devices$PointOfService$MagneticStripeReaderAamvaCardDataReceivedEventArgs,
MagneticStripeReaderBankCardDataReceivedEventArgs: typeof Windows$Devices$PointOfService$MagneticStripeReaderBankCardDataReceivedEventArgs,
MagneticStripeReaderCapabilities: typeof Windows$Devices$PointOfService$MagneticStripeReaderCapabilities,
MagneticStripeReaderCardTypes: typeof Windows$Devices$PointOfService$MagneticStripeReaderCardTypes,
MagneticStripeReaderEncryptionAlgorithms: typeof Windows$Devices$PointOfService$MagneticStripeReaderEncryptionAlgorithms,
MagneticStripeReaderErrorOccurredEventArgs: typeof Windows$Devices$PointOfService$MagneticStripeReaderErrorOccurredEventArgs,
MagneticStripeReaderReport: typeof Windows$Devices$PointOfService$MagneticStripeReaderReport,
MagneticStripeReaderStatusUpdatedEventArgs: typeof Windows$Devices$PointOfService$MagneticStripeReaderStatusUpdatedEventArgs,
MagneticStripeReaderTrackData: typeof Windows$Devices$PointOfService$MagneticStripeReaderTrackData,
MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs: typeof Windows$Devices$PointOfService$MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs,
PosPrinter: typeof Windows$Devices$PointOfService$PosPrinter,
PosPrinterCapabilities: typeof Windows$Devices$PointOfService$PosPrinterCapabilities,
PosPrinterCharacterSetIds: typeof Windows$Devices$PointOfService$PosPrinterCharacterSetIds,
PosPrinterReleaseDeviceRequestedEventArgs: typeof Windows$Devices$PointOfService$PosPrinterReleaseDeviceRequestedEventArgs,
PosPrinterStatus: typeof Windows$Devices$PointOfService$PosPrinterStatus,
PosPrinterStatusUpdatedEventArgs: typeof Windows$Devices$PointOfService$PosPrinterStatusUpdatedEventArgs,
ReceiptPrintJob: typeof Windows$Devices$PointOfService$ReceiptPrintJob,
ReceiptPrinterCapabilities: typeof Windows$Devices$PointOfService$ReceiptPrinterCapabilities,
SlipPrintJob: typeof Windows$Devices$PointOfService$SlipPrintJob,
SlipPrinterCapabilities: typeof Windows$Devices$PointOfService$SlipPrinterCapabilities,
UnifiedPosErrorData: typeof Windows$Devices$PointOfService$UnifiedPosErrorData,
        
      }

/**
 * Represents the barcode scanner device.
 */
declare class Windows$Devices$PointOfService$BarcodeScanner  {

/**
 * Creates BarcodeScanner object from the DeviceInformation.Id .
 * @param deviceId The DeviceInformation.Id that identifies a specific barcode scanner, which can be retrieved from the DeviceId property.
 * @return The barcode scanner specified by the unique device identifier. Returns a null object in the following cases:
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$PointOfService$BarcodeScanner>;

/**
 * Returns the first available barcode scanner.
 * @return The first available barcode scanner. Returns a null object in the following cases:
 */
static getDefaultAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$PointOfService$BarcodeScanner>;

/**
 * Gets an Advanced Query Syntax (AQS) string that you can use to list the available barcode scanners.
 * @return An Advanced Query Syntax (AQS) string that is used to enumerate available barcode scanners.
 */
static getDeviceSelector(): string;

/**
 * Gets the capabilities of the specified barcode scanner.
 */
capabilities: Windows$Devices$PointOfService$BarcodeScannerCapabilities;

/**
 * Tests the state of the barcode scanner.
 * @param level The specified health check level.
 * @return A text description of the test result. Returns an error if the specified check level is not supported by the device.
 */
checkHealthAsync(
level: $Values<typeof Windows$Devices$PointOfService$UnifiedPosHealthCheckLevel>): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Attempts to get an exclusive access to the barcode scanner.
 * @return When the method completes, it returns a ClaimedBarcodeScanner .
 */
claimScannerAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$PointOfService$ClaimedBarcodeScanner>;

/**
 * Gets the DeviceInformation.Id of the barcode scanner.
 */
deviceId: string;

/**
 * Gets the list of profiles supported by the barcode scanner.
 * @return As array of strings representing the supported profiles. Returns an empty list if the scanner does not support profiles.
 */
getSupportedProfiles(): Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the symbologies supported by the claimed barcode scanner.
 * @return When the method completes successfully, it returns a list of values that represent the symbologies supported by the device.
 */
getSupportedSymbologiesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Determines whether the profile is supported.
 * @param profile Barcode scanner profile.
 * @return True if the barcode scanner supports the profile; otherwise false.
 */
isProfileSupported(profile: string): boolean;

/**
 * Determines whether the specified symbology is supported by the barcode scanner.
 * @param barcodeSymbology The specific barcode symbology.
 * @return True if the device supports the specified symbology; otherwise, false.
 */
isSymbologySupportedAsync(
barcodeSymbology: number): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Occurs when the barcode scanner detects an operation status change.
 */
onstatusupdated: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$BarcodeScanner, Windows$Devices$PointOfService$BarcodeScannerStatusUpdatedEventArgs>;
addEventListener(
type: "statusupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$BarcodeScanner, Windows$Devices$PointOfService$BarcodeScannerStatusUpdatedEventArgs>): void;
removeEventListener(
type: "statusupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$BarcodeScanner, Windows$Devices$PointOfService$BarcodeScannerStatusUpdatedEventArgs>): void;

/**
 * Retrieves the requested statistics from the barcode scanner.
 * @param statisticsCategories The list of statistics to retrieve.
 * @return IBuffer representing the requested statistics.
 */
retrieveStatisticsAsync(
statisticsCategories: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the barcode scanner capabilities.
 */
declare class Windows$Devices$PointOfService$BarcodeScannerCapabilities  {

/**
 * Indicates whether the barcode scanner supports image preview.
 */
isImagePreviewSupported: boolean;

/**
 * Indicates whether the barcode scanner supports the software trigger functionality.
 */
isSoftwareTriggerSupported: boolean;

/**
 * Indicates whether the barcode scanner supports reporting of usage statistics.
 */
isStatisticsReportingSupported: boolean;

/**
 * Indicates whether the barcode scanner supports updating or resetting of usage statistics.
 */
isStatisticsUpdatingSupported: boolean;

/**
 * Gets the power reporting type for the barcode scanner.
 */
powerReportingType: $Values<typeof Windows$Devices$PointOfService$UnifiedPosPowerReportingType>
}


/**
 * Provides the barcode data from the DataReceived event.
 */
declare class Windows$Devices$PointOfService$BarcodeScannerDataReceivedEventArgs  {

/**
 * Gets the data from the DataReceived event.
 */
report: Windows$Devices$PointOfService$BarcodeScannerReport
}


/**
 * Provides data for the ErrorOccurred event.
 */
declare class Windows$Devices$PointOfService$BarcodeScannerErrorOccurredEventArgs  {

/**
 * Gets the data associated with the ErrorOccurred event.
 */
errorData: Windows$Devices$PointOfService$UnifiedPosErrorData;

/**
 * Indicates whether it is worthwhile to make another attempt at the operation.
 */
isRetriable: boolean;

/**
 * Gets any data that was successfully read.
 */
partialInputData: Windows$Devices$PointOfService$BarcodeScannerReport
}


/**
 * Provides the data from the ImagePreviewReceived event.
 */
declare class Windows$Devices$PointOfService$BarcodeScannerImagePreviewReceivedEventArgs  {

/**
 * Gets the BitmapImage from the device representing a preview frame.
 */
preview: Windows$Storage$Streams$IRandomAccessStreamWithContentType
}


/**
 * Contains the barcode scanner data.
 */
declare class Windows$Devices$PointOfService$BarcodeScannerReport  {

/**
 * Gets the full raw data from the DataReceived event.
 */
scanData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the decoded barcode label, which does not include the header, checksum, and other miscellaneous information.
 */
scanDataLabel: Windows$Storage$Streams$IBuffer;

/**
 * Gets the decoded barcode label type. Possible values are defined in the BarcodeSymbologies class.
 */
scanDataType: number
}


/**
 * Defines the constants that indicates the barcode scanner status.
 */

declare  var Windows$Devices$PointOfService$BarcodeScannerStatus: {|
  +online: 0,// 0
+off: 1,// 1
+offline: 2,// 2
+offOrOffline: 3,// 3
+extended: 4,// 4

|};



/**
 * Provides information about an operation status change.
 */
declare class Windows$Devices$PointOfService$BarcodeScannerStatusUpdatedEventArgs  {

/**
 * Gets the vendor specific status code.
 */
extendedStatus: number;

/**
 * Gets the status change information.
 */
status: $Values<typeof Windows$Devices$PointOfService$BarcodeScannerStatus>
}


/**
 * Contains the barcode symbology.
 */
declare class Windows$Devices$PointOfService$BarcodeSymbologies  {

/**
 * Gets the Australia Postal barcode symbology.
 */
static ausPost: number;

/**
 * Gets the Aztec barcode symbology.
 */
static aztec: number;

/**
 * Gets the Canada Postal barcode symbology.
 */
static canPost: number;

/**
 * Gets the Composite Component A or B barcode symbology.
 */
static ccab: number;

/**
 * Gets the Composite Component-C barcode symbology.
 */
static ccc: number;

/**
 * Gets the China Postal barcode symbology.
 */
static chinaPost: number;

/**
 * Gets the Codabar barcode symbology.
 */
static codabar: number;

/**
 * Gets the Codablock 128 barcode symbology.
 */
static codablock128: number;

/**
 * Gets the Codablock A barcode symbology.
 */
static codablockA: number;

/**
 * Gets the Codablock F barcode symbology.
 */
static codablockF: number;

/**
 * Gets the Code 11 barcode symbology.
 */
static code11: number;

/**
 * Gets the Code 128 barcode symbology.
 */
static code128: number;

/**
 * Gets the Code 16k barcode symbology.
 */
static code16k: number;

/**
 * Gets the Code 32 barcode symbology.
 */
static code32: number;

/**
 * Gets the Code 39 barcode symbology.
 */
static code39: number;

/**
 * Gets the Code 39 Extended barcode symbology.
 */
static code39Ex: number;

/**
 * Gets the Code 49 barcode symbology.
 */
static code49: number;

/**
 * Gets the Code 93 barcode symbology.
 */
static code93: number;

/**
 * Gets the Code 93 Extended barcode symbology.
 */
static code93Ex: number;

/**
 * Gets the Data Code barcode symbology.
 */
static dataCode: number;

/**
 * Gets the Data Matric barcode symbology.
 */
static dataMatrix: number;

/**
 * Gets the Dutch Postal barcode symbology.
 */
static dutchKix: number;

/**
 * Gets the EAN (European Article Number) 13 barcode symbology.
 */
static ean13: number;

/**
 * Gets the EAN 13 with 2 digit supplement barcode symbology.
 */
static ean13Add2: number;

/**
 * Gets the EAN 13 with 5 digit supplement barcode symbology.
 */
static ean13Add5: number;

/**
 * Gets the EAN 8 barcode symbology.
 */
static ean8: number;

/**
 * Gets the EAN 8 with 2 digit supplement barcode symbology.
 */
static ean8Add2: number;

/**
 * Gets the EAN 8 with 5 digit supplement barcode symbology.
 */
static ean8Add5: number;

/**
 * Gets the EAN 99 barcode symbology.
 */
static ean99: number;

/**
 * Gets the EAN 99 with 2 digit supplement barcode symbology.
 */
static ean99Add2: number;

/**
 * Gets the EAN 99 with 5 digit supplement barcode symbology.
 */
static ean99Add5: number;

/**
 * Gets the EAN Velocity barcode symbology.
 */
static eanv: number;

/**
 * Gets the EAN Velocity with 2 digit supplement barcode symbology.
 */
static eanvAdd2: number;

/**
 * Gets the EAN Velocity with 5 digit supplement barcode symbology.
 */
static eanvAdd5: number;

/**
 * Gets the first possible OEM defined barcode symbology when the symbology type is not included in the current list.
 */
static extendedBase: number;

/**
 * Returns the barcode symbology type as a string.
 * @param scanDataType The barcode symbology type.
 * @return The barcode symbology type as a string.
 */
static getName(scanDataType: number): string;

/**
 * Gets the GS1 128 shipping container barcode symbology.
 */
static gs1128: number;

/**
 * Gets the GS1 128 Coupon barcode symbology.
 */
static gs1128Coupon: number;

/**
 * Gets the GS1 Databar Omnidirectional, GS1 Databar Stacked Omnidirectional, GS1 Databar Stacked, or GS1 Databar Truncated barcode symbology.
 */
static gs1DatabarType1: number;

/**
 * Gets the GS1 DataBar Limited or RSS Limited barcode symbology.
 */
static gs1DatabarType2: number;

/**
 * Gets the GS1 Databar Expanded, GS1 Databar Expanded Stacked, or RSS Expanded barcode symbology.
 */
static gs1DatabarType3: number;

/**
 * Gets the Han Xin barcode symbology.
 */
static hanXin: number;

/**
 * Gets the InfoMail barcode symbology.
 */
static infoMail: number;

/**
 * Gets the International Standard Book Number (ISBN), also known as Bookland or Bookland EAN, barcode symbology.
 */
static isbn: number;

/**
 * Gets the ISBN with 5 digit supplement barcode symbology.
 */
static isbnAdd5: number;

/**
 * Gets the International Society of Blood Transfusion (ISBT) 128 barcode symbology.
 */
static isbt: number;

/**
 * Gets the International Standard Music Number (ISMN) barcode symbology.
 */
static ismn: number;

/**
 * Gets the ISMN with 2 digit supplement barcode symbology.
 */
static ismnAdd2: number;

/**
 * Gets the ISMN with 5 digit supplement barcode symbology.
 */
static ismnAdd5: number;

/**
 * Gets the International Standard Serial Number (ISSN) barcode symbology.
 */
static issn: number;

/**
 * Gets the ISSN with 2 digit supplement barcode symbology.
 */
static issnAdd2: number;

/**
 * Gets the ISSN with 5 digit supplement barcode symbology.
 */
static issnAdd5: number;

/**
 * Gets the Italian Post 25 barcode symbology.
 */
static italianPost25: number;

/**
 * Gets the Italian Post 39 barcode symbology.
 */
static italianPost39: number;

/**
 * Gets the Japan Postal barcode symbology.
 */
static japanPost: number;

/**
 * Gets the Korea Postal barcode symbology.
 */
static koreanPost: number;

/**
 * Gets the MaxiCode barcode symbology.
 */
static maxicode: number;

/**
 * Gets the Magnetic Ink Character Recognition (MICR) barcode symbology.
 */
static micr: number;

/**
 * Gets the Micro PDF 417 barcode symbology.
 */
static microPdf417: number;

/**
 * Gets the Micro QR Code barcode symbology.
 */
static microQr: number;

/**
 * Gets the Microsoft tag barcode symbology.
 */
static msTag: number;

/**
 * Gets the MSI barcode symbology.
 */
static msi: number;

/**
 * Gets the OCR-A barcode symbology.
 */
static ocrA: number;

/**
 * Gets the OCR-B barcode symbology.
 */
static ocrB: number;

/**
 * Gets the PDF 417 barcode symbology.
 */
static pdf417: number;

/**
 * Gets the Plessey barcode symbology.
 */
static plessey: number;

/**
 * Gets the Pharma-Zentral-Nummer (Pzn) barcode symbology.
 */
static pzn: number;

/**
 * Gets the Quick Response (QR) Code barcode symbology.
 */
static qr: number;

/**
 * Gets the Serials Industry Systems Advisory Committee (SISAC) barcode symbology.
 */
static sisac: number;

/**
 * Gets the Sweden Postal barcode symbology.
 */
static swedenPost: number;

/**
 * Gets the Telepen barcode symbology.
 */
static telepen: number;

/**
 * Gets the Discreet 2 of 5 barcode symbology.
 */
static tfDis: number;

/**
 * Gets the 2 of 5 International Air Transportation Association (IATA) barcode symbology.
 */
static tfIata: number;

/**
 * Gets the Industrial 2 of 5 barcode symbology.
 */
static tfInd: number;

/**
 * Gets the Interleaved 2 of 5 barcode symbology.
 */
static tfInt: number;

/**
 * Gets the 2 of 5 Matrix barcode symbology.
 */
static tfMat: number;

/**
 * Gets the Standard 2 of 5 barcode symbology.
 */
static tfStd: number;

/**
 * Gets the TLC 39 barcode symbology.
 */
static tlc39: number;

/**
 * Gets the Tri-Optic Media Storage Devices barcode symbology.
 */
static trioptic39: number;

/**
 * Gets the UCC/EAN 128 barcode symbology.
 */
static uccEan128: number;

/**
 * Gets the UK Postal barcode symbology.
 */
static ukPost: number;

/**
 * Unknown barcode symbology.
 */
static unknown: number;

/**
 * Gets the UPC Coupon with supplemental barcode symbology.
 */
static upcCoupon: number;

/**
 * Gets the Universal Product Code (UPC) version A barcode symbology.
 */
static upca: number;

/**
 * Gets the UPC A with 2 digit supplemental barcode symbology.
 */
static upcaAdd2: number;

/**
 * Gets the UPC A with 5 digit supplement barcode symbology.
 */
static upcaAdd5: number;

/**
 * Gets the Universal Product Code (UPC) version E barcode symbology.
 */
static upce: number;

/**
 * Gets the UPC-E with 2 digit supplemnent barcode symbology.
 */
static upceAdd2: number;

/**
 * Gets the UPC-E with 5 digit supplement barcode symbology.
 */
static upceAdd5: number;

/**
 * Gets the United States Postal Service 4-State Flat Mail Identification Code Sort (FICS) barcode symbology.
 */
static us4StateFics: number;

/**
 * Gets the United States Postal Service (USPS) Intelligent Mail barcode symbology.
 */
static usIntelligent: number;

/**
 * Gets the United States Postal Service (USPS) Intelligent Mail Package barcode symbology.
 */
static usIntelligentPkg: number;

/**
 * Gets the United States Postal Service PLANET barcode symbology.
 */
static usPlanet: number;

/**
 * Gets the United States Postal Numeric Encoding Technique (POSTNET) barcode symbology.
 */
static usPostNet: number
}


/**
 * A cash drawer device in a retail scenario.
 */
declare class Windows$Devices$PointOfService$CashDrawer  {

/**
 * Creates CashDrawer object from the DeviceInformation.Id .
 * @param deviceId The DeviceInformation.Id that identifies a specific cash drawer, which can be retrieved from the DeviceId property.
 * @return The cash drawer specified by the unique device identifier. Returns a null object in the following cases:
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$PointOfService$CashDrawer>;

/**
 * Gets the default paired or locally-connected cash drawer.
 * @return The default locally-connected drawer. May return null if there is no drawer available.
 */
static getDefaultAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$PointOfService$CashDrawer>;

/**
 * Gets an Advanced Query Syntax (AQS) string that you can use to list the available cash drawers.
 * @return An Advanced Query Syntax (AQS) string that is used to enumerate available cash drawers.
 */
static getDeviceSelector(): string;

/**
 * The functionality of the cash drawer device as exposed by API.
 */
capabilities: Windows$Devices$PointOfService$CashDrawerCapabilities;

/**
 * Gets the device's health state asynchronously.
 * @param level The specified health check level.
 * @return This value is intended to be reflected in the app interface immediately so the user of the app can interpret it. For example, it will return OK as the health string if the device state is good.
 */
checkHealthAsync(
level: $Values<typeof Windows$Devices$PointOfService$UnifiedPosHealthCheckLevel>): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Attempts to get exclusive access on the cash drawer.
 * @return When the method completes, it returns a ClaimedCashDrawer .
 */
claimDrawerAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$PointOfService$ClaimedCashDrawer>;

/**
 * The identifier string of the cash drawer device.
 */
deviceId: string;

/**
 * Gets the CashDrawerEventSource to allow the app to detect the open/close state of the drawer. The actual current state is reported by IsDrawerOpen. .
 */
drawerEventSource: Windows$Devices$PointOfService$CashDrawerEventSource;

/**
 * Retrieves the requested statistics from the cash drawer.
 * @param statisticsCategories The list of statistics to retrieve.
 * @return String representing the requested statistics.
 */
getStatisticsAsync(
statisticsCategories: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Indicates whether the cash drawer is open.
 */
isDrawerOpen: boolean;

/**
 * Indicates there has been a change in the power availability status of the drawer.
 */
onstatusupdated: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$CashDrawer, Windows$Devices$PointOfService$CashDrawerStatusUpdatedEventArgs>;
addEventListener(
type: "statusupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$CashDrawer, Windows$Devices$PointOfService$CashDrawerStatusUpdatedEventArgs>): void;
removeEventListener(
type: "statusupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$CashDrawer, Windows$Devices$PointOfService$CashDrawerStatusUpdatedEventArgs>): void;

/**
 * Get the current power and availability status of the cash drawer.
 */
status: Windows$Devices$PointOfService$CashDrawerStatus;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the cash drawer capabilities.
 */
declare class Windows$Devices$PointOfService$CashDrawerCapabilities  {

/**
 * Indicated whether cash drawer open sensor is available.
 */
isDrawerOpenSensorAvailable: boolean;

/**
 * Whether statistics reporting is supported by the cash drawer.
 */
isStatisticsReportingSupported: boolean;

/**
 * Whether statistics updating is supported by the cash drawer.
 */
isStatisticsUpdatingSupported: boolean;

/**
 * Whether the status from multiple drawers is supported.
 */
isStatusMultiDrawerDetectSupported: boolean;

/**
 * Whether status reporting is supported by the cash drawer.
 */
isStatusReportingSupported: boolean;

/**
 * Whether the cash drawer has standard or advanced power reporting.
 */
powerReportingType: $Values<typeof Windows$Devices$PointOfService$UnifiedPosPowerReportingType>
}


/**
 * The cash drawer close alarm. Parameter defaults are provided, however the user can update them as appropriate.
 */
declare class Windows$Devices$PointOfService$CashDrawerCloseAlarm  {

/**
 * Gets or sets the alarm timeout for the cash drawer close alarm.
 */
alarmTimeout: number;

/**
 * Delay between cash drawer closed alarm beeps.
 */
beepDelay: number;

/**
 * Duration of the cash drawer close alarm beep.
 */
beepDuration: number;

/**
 * Frequency of beep tone.
 */
beepFrequency: number;

/**
 * Event allowing the app to be notified if the alarm timeout has been triggered.
 */
onalarmtimeoutexpired: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$CashDrawerCloseAlarm, any>;
addEventListener(
type: "alarmtimeoutexpired",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$CashDrawerCloseAlarm, any>): void;
removeEventListener(
type: "alarmtimeoutexpired",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$CashDrawerCloseAlarm, any>): void;

/**
 * Starts the alarm countdown, returning an awaitable object that completes when the cash drawer is closed.
 * @return True if the drawer has been closed; otherwise, false indicates a problem has occurred.
 */
startAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * This object is passed as a parameter to the event handlers for the DrawerClosed event.
 */
declare class Windows$Devices$PointOfService$CashDrawerClosedEventArgs  {

/**
 * Gets the data associated with the DrawerClosed event.
 */
cashDrawer: Windows$Devices$PointOfService$CashDrawer
}


/**
 * Provides event sources that allow a developer to detect when the cash drawer is opened or closed.
 */
declare class Windows$Devices$PointOfService$CashDrawerEventSource  {

/**
 * Occurs when the cash drawer is closed.
 */
ondrawerclosed: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$CashDrawerEventSource, Windows$Devices$PointOfService$CashDrawerClosedEventArgs>;
addEventListener(
type: "drawerclosed",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$CashDrawerEventSource, Windows$Devices$PointOfService$CashDrawerClosedEventArgs>): void;
removeEventListener(
type: "drawerclosed",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$CashDrawerEventSource, Windows$Devices$PointOfService$CashDrawerClosedEventArgs>): void;

/**
 * Occurs when the cash drawer is opened.
 */
ondraweropened: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$CashDrawerEventSource, Windows$Devices$PointOfService$CashDrawerOpenedEventArgs>;
addEventListener(
type: "draweropened",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$CashDrawerEventSource, Windows$Devices$PointOfService$CashDrawerOpenedEventArgs>): void;
removeEventListener(
type: "draweropened",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$CashDrawerEventSource, Windows$Devices$PointOfService$CashDrawerOpenedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * This object is passed as a parameter to the event handlers for the DrawerOpened event.
 */
declare class Windows$Devices$PointOfService$CashDrawerOpenedEventArgs  {

/**
 * Gets the data associated with the DrawerOpened event.
 */
cashDrawer: Windows$Devices$PointOfService$CashDrawer
}


/**
 * Provides the current power and availability status of the cash drawer.
 */
declare class Windows$Devices$PointOfService$CashDrawerStatus  {

/**
 * ExtendedStatus provides a way for a Point of Service driver or provider to send custom notifications to the app.
 */
extendedStatus: number;

/**
 * Gets the status kind for the cash drawer status.
 */
statusKind: $Values<typeof Windows$Devices$PointOfService$CashDrawerStatusKind>
}


/**
 * Defines the constants that indicate the cash drawer power status.
 */

declare  var Windows$Devices$PointOfService$CashDrawerStatusKind: {|
  +online: 0,// 0
+off: 1,// 1
+offline: 2,// 2
+offOrOffline: 3,// 3
+extended: 4,// 4

|};



/**
 * This object is passed as a parameter to the event handlers for the StatusUpdated event.
 */
declare class Windows$Devices$PointOfService$CashDrawerStatusUpdatedEventArgs  {

/**
 * Gets the data associated with the StatusUpdated event.
 */
status: Windows$Devices$PointOfService$CashDrawerStatus
}


/**
 * Represents the claimed barcode scanner.
 */
declare class Windows$Devices$PointOfService$ClaimedBarcodeScanner  {

/**
 * Releases exclusive claim to the barcode scanner.
 */
close(): void;

/**
 * Gets the DeviceInformation.Id of the claimed barcode scanner.
 */
deviceId: string;

/**
 * Puts the barcode scanner into a state where it cannot receive DataReceived events.
 * @return No object or value is returned when this method completes.
 */
disableAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the barcode scanner into a ready state for DataReceived events.
 * @return No object or value is returned when this method completes.
 */
enableAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets or sets a Boolean value that indicates whether to provide the decoded data to the service object.
 */
isDecodeDataEnabled: boolean;

/**
 * Gets or sets a Boolean value that indicates whether the barcode scanner is disabled after receiving the data.
 */
isDisabledOnDataReceived: boolean;

/**
 * Indicates whether the barcode scanner can receive DataReceived events.
 */
isEnabled: boolean;

/**
 * Occurs when the device scans a barcode.
 */
ondatareceived: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedBarcodeScanner, Windows$Devices$PointOfService$BarcodeScannerDataReceivedEventArgs>;
addEventListener(
type: "datareceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedBarcodeScanner, Windows$Devices$PointOfService$BarcodeScannerDataReceivedEventArgs>): void;
removeEventListener(
type: "datareceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedBarcodeScanner, Windows$Devices$PointOfService$BarcodeScannerDataReceivedEventArgs>): void;

/**
 * Occurs when there is a problem in reading a barcode.
 */
onerroroccurred: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedBarcodeScanner, Windows$Devices$PointOfService$BarcodeScannerErrorOccurredEventArgs>;
addEventListener(
type: "erroroccurred",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedBarcodeScanner, Windows$Devices$PointOfService$BarcodeScannerErrorOccurredEventArgs>): void;
removeEventListener(
type: "erroroccurred",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedBarcodeScanner, Windows$Devices$PointOfService$BarcodeScannerErrorOccurredEventArgs>): void;

/**
 * Occurs when the device receives the bitmap image of the scan.
 */
onimagepreviewreceived: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedBarcodeScanner, Windows$Devices$PointOfService$BarcodeScannerImagePreviewReceivedEventArgs>;
addEventListener(
type: "imagepreviewreceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedBarcodeScanner, Windows$Devices$PointOfService$BarcodeScannerImagePreviewReceivedEventArgs>): void;
removeEventListener(
type: "imagepreviewreceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedBarcodeScanner, Windows$Devices$PointOfService$BarcodeScannerImagePreviewReceivedEventArgs>): void;

/**
 * Occurs when the device gets a request to release its exclusive claim.
 */
onreleasedevicerequested: Windows$Foundation$EventHandler<any>;
addEventListener(
type: "releasedevicerequested",
listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(
type: "releasedevicerequested",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Occurs when the barcode scanner trigger or button is pressed during a scanning operation.
 */
ontriggerpressed: Windows$Foundation$EventHandler<any>;
addEventListener(type: "triggerpressed", listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: "triggerpressed", listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Occurs when the barcode scanner trigger or button is released during a scanning operation.
 */
ontriggerreleased: Windows$Foundation$EventHandler<any>;
addEventListener(type: "triggerreleased", listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: "triggerreleased", listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Resets the specified statistics to zero for all statistics that can be reset.
 * @param statisticsCategories The list of names of the statistics to reset.
 * @return No object or value is returned by this method when it completes.
 */
resetStatisticsAsync(
statisticsCategories: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Retains exclusive claim to the barcode scanner.
 */
retainDevice(): void;

/**
 * Sets the active profile on the barcode scanner.
 * @param profile The name of the profile to set on the device.
 * @return No object or value is returned when the method completes.
 */
setActiveProfileAsync(profile: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Sets the barcode symbologies for the device to use.
 * @param symbologies The specific symbologies to use.
 * @return No object or value is returned when this method completes.
 */
setActiveSymbologiesAsync(
symbologies: Windows$Foundation$Collections$IIterable<number>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Used to signal the barcode scanner to start scanning. A session is active until StopSoftwareTriggerAsync is invoked, or until the scanner ends the session on its own.
 * @return No object or value is returned when this method completes.
 */
startSoftwareTriggerAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Used to stop a session that was started with StartSoftwareTriggerAsync . No error is raised if this is called when no session is active.
 * @return No object or value is returned when this method completes.
 */
stopSoftwareTriggerAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Updates the specified statistics.
 * @param statistics The list of key-value pairs of statistics to update.
 * @return No object or value is returned by this method when it completes.
 */
updateStatisticsAsync(
statistics: Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>): Windows$Foundation$IPromiseWithIAsyncAction;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides access to exclusive and privileged methods, properties, and events on a point-of-service cash drawer device.
 */
declare class Windows$Devices$PointOfService$ClaimedCashDrawer  {

/**
 * Disposes the claimed cash drawer, releases claim on the device, and disables the device the same way as calling DisableAsync.
 */
close(): void;

/**
 * Gets the close alarm for this cash drawer. This is only valid if IsDrawerOpenSensorAvailable is true.
 */
closeAlarm: Windows$Devices$PointOfService$CashDrawerCloseAlarm;

/**
 * The identifier string of the claimed cash drawer device.
 */
deviceId: string;

/**
 * Notifies the underlying hardware to power off.
 * @return Whether the attempt to disable succeeded or not.
 */
disableAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously notifies the underlying hardware to power on for use.
 * @return Whether the attempt to enable succeeded or not.
 */
enableAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Indicates whether the cash drawer is open.
 */
isDrawerOpen: boolean;

/**
 * Indicates whether the cash drawer is operational and can be used.
 */
isEnabled: boolean;

/**
 * Occurs when the device gets a request to release its exclusive claim.
 */
onreleasedevicerequested: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedCashDrawer, any>;
addEventListener(
type: "releasedevicerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedCashDrawer, any>): void;
removeEventListener(
type: "releasedevicerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedCashDrawer, any>): void;

/**
 * Opens the cash drawer.
 * @return Boolean indicating whether the drawer was successfully opened.
 */
openDrawerAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Resets the specified device statistics to their defaults.
 * @param statisticsCategories The list of names of the statistics to reset.
 * @return True on success; otherwise false.
 */
resetStatisticsAsync(
statisticsCategories: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Retain the current claim on the cash drawer. This is usually called in response to a ReleaseDeviceRequested event notification.
 * @return True if the retain attempt succeeded; false if the retain attempt failed.
 */
retainDeviceAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Updates device statistics values using the provided key/value pair.
 * @param statistics The statistics to update.
 * @return True if update succeeded; otherwise false.
 */
updateStatisticsAsync(
statistics: Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a journal printer station that has been claimed for use.
 */
declare class Windows$Devices$PointOfService$ClaimedJournalPrinter  {

/**
 * Gets or sets the number of characters per line for the journal printer station.
 */
charactersPerLine: number;

/**
 * Gets or sets the color cartridge that the journal printer station should use when it prints. This property must agree with what is available through ColorCartridgeCapabilities .
 */
colorCartridge: $Values<typeof Windows$Devices$PointOfService$PosPrinterColorCartridge>;

/**
 * Creates a new print job for the journal printer station.
 * @return The new print job for the journal printer station.
 */
createJob(): Windows$Devices$PointOfService$JournalPrintJob;

/**
 * Gets whether the printer cartridge for the journal printer station is empty. Note, this may throw an exception if the corresponding sensor is not available on the printer. See JournalPrinterCapabilities to verify sensor availability.
 */
isCartridgeEmpty: boolean;

/**
 * Gets whether the cartridge for journal printer station has been removed. Note, this may throw an exception if the corresponding sensor is not available on the printer. See JournalPrinterCapabilities to verify sensor availability.
 */
isCartridgeRemoved: boolean;

/**
 * Gets whether the printer cover for the journal printer station is open.
 */
isCoverOpen: boolean;

/**
 * Gets whether the head for the journal printer station is currently cleaning.
 */
isHeadCleaning: boolean;

/**
 * Gets or sets whether the journal printer station prints with high quality or high speed. Note, this may throw an exception if the corresponding sensor is not available on the printer.
 */
isLetterQuality: boolean;

/**
 * Gets whether the paper is empty for the journal printer station. Note, this may throw an exception if the corresponding sensor is not available on the printer. See JournalPrinterCapabilities to verify sensor availability.
 */
isPaperEmpty: boolean;

/**
 * Gets whether the printer paper is near the end for the journal printer station. Note, this may throw an exception if the corresponding sensor is not available on the printer. See JournalPrinterCapabilities to verify sensor availability.
 */
isPaperNearEnd: boolean;

/**
 * Gets whether the journal printer station is ready to print. Note, this may throw an exception if the corresponding sensor is not available on the printer. See JournalPrinterCapabilities to verify sensor availability.
 */
isReadyToPrint: boolean;

/**
 * Gets or sets the current height of the printed line for the journal printer station, in the units that the ClaimedPosPrinter.MapMode property specifies.
 */
lineHeight: number;

/**
 * Gets or sets the spacing of each single-high print line for the journal printer station, in the units that the ClaimedPosPrinter.MapMode property specifies. This spacing includes both the height of printed line and of the white space between each pair of lines.
 */
lineSpacing: number;

/**
 * Gets the current width of the printed line for the journal printer station, in the units that the ClaimedPosPrinter.MapMode property specifies.
 */
lineWidth: number;

/**
 * Determines if a JournalPrintJob can successfully execute a print instruction with the specified data.
 * @param data The data sequence that you want to validate before you use it with the JournalPrintJob.Print method. This sequence may include printable data and escape sequences.
 * @return True if the data passes validation; otherwise false.
 */
validateData(data: string): boolean
}


/**
 * Represents the claimed magnetic stripe reader.
 */
declare class Windows$Devices$PointOfService$ClaimedMagneticStripeReader  {

/**
 * Puts the device into an authenticated state.
 * @param responseToken A buffer containing the response token generated from the challenge token retrieved from a previous call to the RetrieveDeviceAuthenticationDataAsync method.
 */
authenticateDeviceAsync(responseToken: number[]): any;

/**
 * Releases the exclusive claim to the magnetic strip reader.
 */
close(): void;

/**
 * Gets or sets the MagneticStripeReaderEncryptionAlgorithms that will be used to encrypt the track data.
 */
dataEncryptionAlgorithm: number;

/**
 * Puts the device into an unauthenticated state.
 * @param responseToken A buffer containing the response token generated from the challenge token retrieved from a previous call to the RetrieveDeviceAuthenticationDataAsync method.
 */
deAuthenticateDeviceAsync(responseToken: number[]): any;

/**
 * Gets the DeviceInformation.Id of the claimed magnetic stripe reader.
 */
deviceId: string;

/**
 * Puts the ClaimedMagneticStripeReader into a state where it cannot receive data events.
 * @return No object or value is returned when this method completes.
 */
disableAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the magnetic stripe reader into a ready state to receive data events.
 * @return No object or value is returned by this method when it completes.
 */
enableAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Indicates whether to provide raw or decoded data from the most recently swiped card.
 */
isDecodeDataEnabled: boolean;

/**
 * Indicates whether the device is authenticated.
 */
isDeviceAuthenticated: boolean;

/**
 * Gets or sets a Boolean value that indicates whether the magnetic stripe reader is disabled after receiving the data from the most recently swiped card.
 */
isDisabledOnDataReceived: boolean;

/**
 * Indicates whether the magnetic stripe reader is ready to receive data events.
 */
isEnabled: boolean;

/**
 * Indicates whether the track data contains start and end sentinel values.
 */
isTransmitSentinelsEnabled: boolean;

/**
 * Occurs when a motor vehicle card is swiped.
 */
onaamvacarddatareceived: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedMagneticStripeReader, Windows$Devices$PointOfService$MagneticStripeReaderAamvaCardDataReceivedEventArgs>;
addEventListener(
type: "aamvacarddatareceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedMagneticStripeReader, Windows$Devices$PointOfService$MagneticStripeReaderAamvaCardDataReceivedEventArgs>): void;
removeEventListener(
type: "aamvacarddatareceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedMagneticStripeReader, Windows$Devices$PointOfService$MagneticStripeReaderAamvaCardDataReceivedEventArgs>): void;

/**
 * Occurs when a bank card is swiped.
 */
onbankcarddatareceived: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedMagneticStripeReader, Windows$Devices$PointOfService$MagneticStripeReaderBankCardDataReceivedEventArgs>;
addEventListener(
type: "bankcarddatareceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedMagneticStripeReader, Windows$Devices$PointOfService$MagneticStripeReaderBankCardDataReceivedEventArgs>): void;
removeEventListener(
type: "bankcarddatareceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedMagneticStripeReader, Windows$Devices$PointOfService$MagneticStripeReaderBankCardDataReceivedEventArgs>): void;

/**
 * Occurs when the magnetic stripe reader detects an error when reading a card.
 */
onerroroccurred: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedMagneticStripeReader, Windows$Devices$PointOfService$MagneticStripeReaderErrorOccurredEventArgs>;
addEventListener(
type: "erroroccurred",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedMagneticStripeReader, Windows$Devices$PointOfService$MagneticStripeReaderErrorOccurredEventArgs>): void;
removeEventListener(
type: "erroroccurred",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedMagneticStripeReader, Windows$Devices$PointOfService$MagneticStripeReaderErrorOccurredEventArgs>): void;

/**
 * Occurs when the device gets a request to release its exclusive claim.
 */
onreleasedevicerequested: Windows$Foundation$EventHandler<any>;
addEventListener(
type: "releasedevicerequested",
listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(
type: "releasedevicerequested",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Occurs when a vendor-specific card is swiped.
 */
onvendorspecificdatareceived: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedMagneticStripeReader, Windows$Devices$PointOfService$MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>;
addEventListener(
type: "vendorspecificdatareceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedMagneticStripeReader, Windows$Devices$PointOfService$MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>): void;
removeEventListener(
type: "vendorspecificdatareceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedMagneticStripeReader, Windows$Devices$PointOfService$MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>): void;

/**
 * Resets the specified statistics to zero for all statistics that can be reset.
 * @param statisticsCategories The list of names of the statistics to reset.
 * @return No object or value is returned by this method when it completes.
 */
resetStatisticsAsync(
statisticsCategories: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Retains exclusive claim to the magnetic stripe reader.
 */
retainDevice(): void;

/**
 * Retrieves a challenge token from the device.
 * @return Buffer used to store the resulting challenge token from the device.
 */
retrieveDeviceAuthenticationDataAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>;

/**
 * Sets the type of error to report by the ErrorOccurred event.
 * @param value Error reporting type.
 */
setErrorReportingType(
value: $Values<typeof Windows$Devices$PointOfService$MagneticStripeReaderErrorReportingType>): void;

/**
 * Gets or sets the track data that the application wants to receive following a card swipe.
 */
tracksToRead: $Values<typeof Windows$Devices$PointOfService$MagneticStripeReaderTrackIds>;

/**
 * Provides a new encryption key to the device.
 * @param key The HEX-ASCII or base64-encoded value for the new key.
 * @param keyName The name used to identify the key.
 */
updateKeyAsync(key: string, keyName: string): any;

/**
 * Updates the specified statistics.
 * @param statistics The list of key-value pairs of statistics to update.
 * @return No object or value is returned by this method when it completes.
 */
updateStatisticsAsync(
statistics: Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>): Windows$Foundation$IPromiseWithIAsyncAction;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represent a point-of-service printer that has been claimed for use.
 */
declare class Windows$Devices$PointOfService$ClaimedPosPrinter  {

/**
 * Gets or sets a numeric value that indicates the character set that the application wants to use for printing characters.
 */
characterSet: number;

/**
 * Disposes the claimed point-of-service printer object synchronously, releases the exclusive claim on the printer and disables it.
 */
close(): void;

/**
 * Gets the identifier string of the claimed point-of-service printer.
 */
deviceId: string;

/**
 * Notifies the underlying hardware to turn off.
 * @return True if the attempt turn off the printer succeeded; otherwise false.
 */
disableAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Notifies the underlying hardware asynchronously to power on for use.
 * @return True if the attempt to turn on the printer succeeded; otherwise false.
 */
enableAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets or sets whether the driver or provider can map Unicode characters to characters that the point-of-service printer can print, or just sends the low byte of the Unicode character to the printer directly.
 */
isCharacterSetMappingEnabled: boolean;

/**
 * Gets whether the cover of the point-of-service printer is currently open.
 */
isCoverOpen: boolean;

/**
 * Gets whether the printer is powered on for use.
 */
isEnabled: boolean;

/**
 * Gets an object that represents the journal station for a claimed point-of-service printer.
 */
journal: Windows$Devices$PointOfService$ClaimedJournalPrinter;

/**
 * Gets or sets the mapping mode of the point-of-service printer that the app wants to use. The mapping mode defines the unit of measure used for other printer properties, such as line height and line spacing.
 */
mapMode: $Values<typeof Windows$Devices$PointOfService$PosPrinterMapMode>;

/**
 * Occurs when a point-of-service printer gets a request to release its exclusive claim.
 */
onreleasedevicerequested: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedPosPrinter, Windows$Devices$PointOfService$PosPrinterReleaseDeviceRequestedEventArgs>;
addEventListener(
type: "releasedevicerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedPosPrinter, Windows$Devices$PointOfService$PosPrinterReleaseDeviceRequestedEventArgs>): void;
removeEventListener(
type: "releasedevicerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$ClaimedPosPrinter, Windows$Devices$PointOfService$PosPrinterReleaseDeviceRequestedEventArgs>): void;

/**
 * Gets an object that represents the receipt station for a claimed point-of-service printer.
 */
receipt: Windows$Devices$PointOfService$ClaimedReceiptPrinter;

/**
 * Resets the specified statistics to zero for all statistics for the point-of-service printer that can be reset.
 * @param statisticsCategories A list of the names of the statistics that you want to reset.
 * @return An operation that returns true if the reset succeeds, or otherwise returns false.
 */
resetStatisticsAsync(
statisticsCategories: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Retains the claim on the point-of-service printer asynchronously, usually in response to the ReleaseDeviceRequested event.
 * @return True if the printer was successfully retained; otherwise, false.
 */
retainDeviceAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets an object that represents the slip station for a claimed point-of-service printer.
 */
slip: Windows$Devices$PointOfService$ClaimedSlipPrinter;

/**
 * Updates the specified statistics for the point-of-service printer.
 * @param statistics The statistics to update.
 * @return An operation that returns true if the update succeeds, or otherwise returns false.
 */
updateStatisticsAsync(
statistics: Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a receipt printer station that has been claimed for use.
 */
declare class Windows$Devices$PointOfService$ClaimedReceiptPrinter  {

/**
 * Gets or sets the number of characters the receipt printer station can print per line of text.
 */
charactersPerLine: number;

/**
 * Gets or sets the color cartridge that the receipt printer station should use when it prints.
 */
colorCartridge: $Values<typeof Windows$Devices$PointOfService$PosPrinterColorCartridge>;

/**
 * Creates a new print job for the receipt printer station.
 * @return The new print job for the receipt printer station.
 */
createJob(): Windows$Devices$PointOfService$ReceiptPrintJob;

/**
 * Gets whether the cartridge of the receipt printer station is currently out of ink or toner.
 */
isCartridgeEmpty: boolean;

/**
 * Gets whether the cartridge of the receipt printer station is currently removed.
 */
isCartridgeRemoved: boolean;

/**
 * Gets whether the cover of the receipt printer station is currently open.
 */
isCoverOpen: boolean;

/**
 * Gets whether the receipt printer station is currently cleaning its print head.
 */
isHeadCleaning: boolean;

/**
 * Gets or sets whether the receipt printer station prints with high quality or high speed.
 */
isLetterQuality: boolean;

/**
 * Gets whether the receipt printer station needs paper.
 */
isPaperEmpty: boolean;

/**
 * Gets whether the receipt printer station is almost out of paper.
 */
isPaperNearEnd: boolean;

/**
 * Gets whether the receipt printer station is on and accepting print jobs.
 */
isReadyToPrint: boolean;

/**
 * Gets or sets the current height of the printed line for the receipt printer station, in the units that the ClaimedPosPrinter.MapMode property specifies.
 */
lineHeight: number;

/**
 * Gets or sets the spacing of each single-high print line for the receipt printer station, in the units that the ClaimedPosPrinter.MapMode property specifies. This spacing includes both the height of printed line and of the white space between each pair of lines.
 */
lineSpacing: number;

/**
 * Gets the current width of the printed line for the receipt printer station, in the units that the ClaimedPosPrinter.MapMode property specifies.
 */
lineWidth: number;

/**
 * Gets the number of lines that must be advanced before cutting the receipt paper.
 */
linesToPaperCut: number;

/**
 * Gets the size of paper that the claimed receipt printer station currently uses.
 */
pageSize: Windows$Foundation$Size;

/**
 * Gets the print area for the receipt printer station, expressed in the unit of measurement that the ClaimedPosPrinter.MapMode property specifies.
 */
printArea: Windows$Foundation$Rect;

/**
 * Gets the maximum number of characters that the receipt printer station can print on each line in sideways mode.
 */
sidewaysMaxChars: number;

/**
 * Gets the maximum number of lines that the receipt printer station can print in sideways mode.
 */
sidewaysMaxLines: number;

/**
 * Determines whether a data sequence, possibly including one or more escape sequences, is valid for the receipt printer station, before you use that data sequence when you call the ReceiptPrintJob.Print and ReceiptPrintJob.ExecuteAsync methods.
 * @param data The data sequence that you want to validate before you use it with the ReceiptPrintJob.Print method. This sequence may include printable data and escape sequences.
 * @return True if the data passes validation; otherwise false.
 */
validateData(data: string): boolean
}


/**
 * Represents a slip printer station that has been claimed for use.
 */
declare class Windows$Devices$PointOfService$ClaimedSlipPrinter  {

/**
 * Changes the side of the sheet on which the claimed slip printer station is currently printing.
 * @param printSide The side of the sheet on which the claimed slip printer station is currently printing.
 */
changePrintSide(
printSide: $Values<typeof Windows$Devices$PointOfService$PosPrinterPrintSide>): void;

/**
 * Gets or sets the number of characters the slip printer station can print per line of text.
 */
charactersPerLine: number;

/**
 * Closes the mechanism that holds the slip in place while the slip printer station is printing, typically after the user inserts or removes the slip.
 */
closeJaws(): void;

/**
 * Gets or sets the color cartridge that the slip printer station should use when it prints.
 */
colorCartridge: $Values<typeof Windows$Devices$PointOfService$PosPrinterColorCartridge>;

/**
 * Creates a new print job for the slip printer stiation.
 * @return The new print job for the slip printer station.
 */
createJob(): Windows$Devices$PointOfService$SlipPrintJob;

/**
 * Waits for the user to insert a slip into the slip printer station.
 * @param timeout The interval of time that the operation should wait for the user to insert the slip before exiting.
 * @return An asynchronous operation that returns true if the user inserts the slip within the specified time span, and returns false otherwise.
 */
insertSlipAsync(timeout: number): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets whether the cartridge of the slip printer station is currently out of ink or toner.
 */
isCartridgeEmpty: boolean;

/**
 * Gets whether the cartridge of the slip printer station is currently removed.
 */
isCartridgeRemoved: boolean;

/**
 * Gets whether the cover of the slip printer station is currently open.
 */
isCoverOpen: boolean;

/**
 * Gets whether the slip printer station is currently cleaning its print head.
 */
isHeadCleaning: boolean;

/**
 * Gets or sets whether the slip printer station prints with high quality or high speed.
 */
isLetterQuality: boolean;

/**
 * Gets whether the slip printer station needs paper.
 */
isPaperEmpty: boolean;

/**
 * Gets whether the slip printer station is almost out of paper.
 */
isPaperNearEnd: boolean;

/**
 * Gets whether the slip printer station is on and accepting print jobs.
 */
isReadyToPrint: boolean;

/**
 * Gets or sets the current height of the printed line for the slip printer station, in the units that the ClaimedPosPrinter.MapMode property specifies.
 */
lineHeight: number;

/**
 * Gets or sets the spacing of each single-high print line for the slip printer station, in the units that the ClaimedPosPrinter.MapMode property specifies. This spacing includes both the height of printed line and of the white space between each pair of lines.
 */
lineSpacing: number;

/**
 * Gets the current width of the printed line for the slip printer station, in the units that the ClaimedPosPrinter.MapMode property specifies.
 */
lineWidth: number;

/**
 * Gets the number of lines that the slip printer station can print after the ClaimedSlipPrinter.IsPaperNearEnd property is set to true but before the printer reaches the end of the slip.
 */
linesNearEndToEnd: number;

/**
 * Gets the maximum number of lines that the slip printer station can print on a form.
 */
maxLines: number;

/**
 * Opens the mechanism that holds the slip in place while the slip printer station is printing, typically before the user inserts or removes the slip.
 */
openJaws(): void;

/**
 * Gets the size of paper that the claimed slip printer station currently uses, in the units that the ClaimedPosPrinter.MapMode property specifies.
 */
pageSize: Windows$Foundation$Size;

/**
 * Gets the print area for the slip printer station, expressed in the unit of measurement that the ClaimedPosPrinter.MapMode property specifies.
 */
printArea: Windows$Foundation$Rect;

/**
 * Gets the side of the sheet on which the claimed slip printer station is currently printing.
 */
printSide: $Values<typeof Windows$Devices$PointOfService$PosPrinterPrintSide>;

/**
 * Waits for the user to remove a slip from the slip printer station.
 * @param timeout The interval of time that the operation should wait for the user to remove the slip before exiting.
 * @return An asynchronous operation that returns true if the user removes the slip within the specified time span, and returns false otherwise.
 */
removeSlipAsync(timeout: number): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets the maximum number of characters that the slip printer station can print on each line in sideways mode.
 */
sidewaysMaxChars: number;

/**
 * Gets the maximum number of lines that the slip printer station can print in sideways mode.
 */
sidewaysMaxLines: number;

/**
 * Determines whether a data sequence, possibly including one or more escape sequences, is valid for the slip printer station, before you use that data sequence when you call the SlipPrintJob.Print and SlipPrintJob.ExecuteAsync methods.
 * @param data The data sequence that you want to validate before you use it with the SlipPrintJob.Print method. This sequence may include printable data and escape sequences.
 * @return True if the data passes validation; otherwise false.
 */
validateData(data: string): boolean
}


/**
 * Represents a set of printing instructions that you want to run on the journal printer station.
 */
declare class Windows$Devices$PointOfService$JournalPrintJob  {

/**
 * Runs the print job on the journal printer station asynchronously.
 * @return The operation to run the print job. This operation returns true if the print job succeeds; otherwise, the operation returns false.
 */
executeAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Adds an instruction to the print job to print the specified text on the journal printer station.
 * @param data The text to print on the journal printer.
 */
print(data: string): void;

/**
 * Adds an instruction to the print job to print the specified line of text on the journal printer station.
 * @param data The line of text to print.
 */
printLine(data: string): void;

/**
 * Adds an instruction to the print job to print a newline character on the journal printer station.
 */
printLine(): void
}


/**
 * Represents the capabilities of journal station of a point-of-service printer.
 */
declare class Windows$Devices$PointOfService$JournalPrinterCapabilities  {

/**
 * Gets information about the sensors that the journal printer station has available to report the status of the printer cartridge.
 */
cartridgeSensors: $Values<typeof Windows$Devices$PointOfService$PosPrinterCartridgeSensors>;

/**
 * Gets the color cartridges that the journal printer station can use to print in color.
 */
colorCartridgeCapabilities: $Values<typeof Windows$Devices$PointOfService$PosPrinterColorCapabilities>;

/**
 * Gets whether the journal printer station can print bold characters.
 */
isBoldSupported: boolean;

/**
 * Gets whether the journal printer station can print characters that are both double-high and double-wide.
 */
isDoubleHighDoubleWidePrintSupported: boolean;

/**
 * Gets whether the journal printer station can print double-high characters.
 */
isDoubleHighPrintSupported: boolean;

/**
 * Gets whether the journal printer station can print double-wide characters.
 */
isDoubleWidePrintSupported: boolean;

/**
 * Gets whether the journal printer station can print a dark color plus an alternate color.
 */
isDualColorSupported: boolean;

/**
 * Gets whether the journal printer station can print italic characters.
 */
isItalicSupported: boolean;

/**
 * Gets whether the journal printer station has an out-of-paper sensor.
 */
isPaperEmptySensorSupported: boolean;

/**
 * Gets whether the journal printer station has a low-paper sensor.
 */
isPaperNearEndSensorSupported: boolean;

/**
 * Gets whether a point-of-service printer with a station that functions as a journal printer station is present.
 */
isPrinterPresent: boolean;

/**
 * Gets whether the journal printer station can underline characters.
 */
isUnderlineSupported: boolean;

/**
 * Gets a collection of the line widths in characters per line that the journal printer station supports.
 */
supportedCharactersPerLine: Windows$Foundation$Collections$IVectorView<number>
}


/**
 * Represents the magnetic stripe reader device.
 */
declare class Windows$Devices$PointOfService$MagneticStripeReader  {

/**
 * Creates a MagneticStripeReader object from DeviceInformation.Id .
 * @param deviceId The DeviceInformation.Id that identifies a specific magnetic stripe reader, which can be retrieved from the DeviceId property.
 * @return The magnetic stripe reader specified by the unique device identifier. Returns a null object in the following cases:
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$PointOfService$MagneticStripeReader>;

/**
 * Returns the first magnetic stripe reader found.
 * @return The first magnetic stripe reader found. Returns a null object in the following cases:
 */
static getDefaultAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$PointOfService$MagneticStripeReader>;

/**
 * Returns an Advanced Query Syntax (AQS) string that is used to enumerate available magnetic stripe readers.
 * @return An Advanced Query Syntax (AQS) string that is used to enumerate available magnetic stripe readers.
 */
static getDeviceSelector(): string;

/**
 * Gets the capabilities of the magnetic stripe reader.
 */
capabilities: Windows$Devices$PointOfService$MagneticStripeReaderCapabilities;

/**
 * Tests the health of the magnetic stripe reader.
 * @param level The specific health check level.
 * @return A text description of the text result. Returns an error if the specified check level is not supported by the device.
 */
checkHealthAsync(
level: $Values<typeof Windows$Devices$PointOfService$UnifiedPosHealthCheckLevel>): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Attempts to get an exclusive access to the magnetic stripe reader.
 * @return When the method completes, it returns a ClaimedMagneticStripeReader or it returns null if the operation fails to claim a magnetic stripe reader.
 */
claimReaderAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$PointOfService$ClaimedMagneticStripeReader>;

/**
 * Device authentication protocol supported by the magnetic stripe reader.
 */
deviceAuthenticationProtocol: $Values<typeof Windows$Devices$PointOfService$MagneticStripeReaderAuthenticationProtocol>;

/**
 * Gets the DeviceInformation.Id of the magnetic stripe reader.
 */
deviceId: string;

/**
 * Gets the error reporting type the application wants to receive.
 * @return The error reporting type.
 */
getErrorReportingType(
): $Values<typeof Windows$Devices$PointOfService$MagneticStripeReaderErrorReportingType>;

/**
 * Occurs when the device detects an operation status change.
 */
onstatusupdated: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$MagneticStripeReader, Windows$Devices$PointOfService$MagneticStripeReaderStatusUpdatedEventArgs>;
addEventListener(
type: "statusupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$MagneticStripeReader, Windows$Devices$PointOfService$MagneticStripeReaderStatusUpdatedEventArgs>): void;
removeEventListener(
type: "statusupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$MagneticStripeReader, Windows$Devices$PointOfService$MagneticStripeReaderStatusUpdatedEventArgs>): void;

/**
 * Retrieves the requested statistics from the magnetic stripe reader.
 * @param statisticsCategories The list of statistics to retrieve.
 * @return IBuffer representing the requested statistics.
 */
retrieveStatisticsAsync(
statisticsCategories: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>;

/**
 * Gets the card types supported by the magnetic stripe reader.
 */
supportedCardTypes: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides the American Association of Motor Vehicle Administrators (AAMVA) card data from the AamvaCardDataReceived event.
 */
declare class Windows$Devices$PointOfService$MagneticStripeReaderAamvaCardDataReceivedEventArgs  {

/**
 * Gets the address from the swiped AAMVA card.
 */
address: string;

/**
 * Gets the birth date from the swiped AAMVA card.
 */
birthDate: string;

/**
 * Gets the city from the swiped AAMVA card.
 */
city: string;

/**
 * Gets the class from the swiped AAMVA card.
 */
class: string;

/**
 * Gets the endorsements from the swiped AAMVA card.
 */
endorsements: string;

/**
 * Gets the expiration date from the swiped AAMVA card.
 */
expirationDate: string;

/**
 * Gets the eye color from the swiped AAMVA card.
 */
eyeColor: string;

/**
 * Gets the first name from the swiped AAMVA card.
 */
firstName: string;

/**
 * Gets the gender from the swiped AAMVA card.
 */
gender: string;

/**
 * Gets the hair color from the swiped AAMVA card.
 */
hairColor: string;

/**
 * Gets the height from the swiped AAMVA card.
 */
height: string;

/**
 * Gets the license number from the swiped AAMVA card.
 */
licenseNumber: string;

/**
 * Gets the postal code from the swiped AAMVA card.
 */
postalCode: string;

/**
 * Gets the additional data from the swiped AAMVA card.
 */
report: Windows$Devices$PointOfService$MagneticStripeReaderReport;

/**
 * Gets the restrictions from the swiped AAMVA card.
 */
restrictions: string;

/**
 * Gets the state from the swiped AAMVA card.
 */
state: string;

/**
 * Gets the suffix from the swiped AAMVA card.
 */
suffix: string;

/**
 * Gets the surname from the swiped card.
 */
surname: string;

/**
 * Gets the weight from the swiped AAMVA card.
 */
weight: string
}


/**
 * Defines the constants that indicates the level of support for magnetic stripe reader authentication protocol: NotSupported, Optional, or Required.
 */

declare  var Windows$Devices$PointOfService$MagneticStripeReaderAuthenticationLevel: {|
  +notSupported: 0,// 0
+optional: 1,// 1
+required: 2,// 2

|};



/**
 * Defines the constants that indicates the authentication protocol supported by the device.
 */

declare  var Windows$Devices$PointOfService$MagneticStripeReaderAuthenticationProtocol: {|
  +none: 0,// 0
+challengeResponse: 1,// 1

|};



/**
 * Provides bank card data from the BankCardDataReceived event.
 */
declare class Windows$Devices$PointOfService$MagneticStripeReaderBankCardDataReceivedEventArgs  {

/**
 * Gets the account number from the swiped bank card.
 */
accountNumber: string;

/**
 * Gets the expiration date from the swiped card.
 */
expirationDate: string;

/**
 * Gets the first name from the swiped bank card.
 */
firstName: string;

/**
 * Gets the middle initial from the swiped bank card.
 */
middleInitial: string;

/**
 * Gets the data from the swiped bank card.
 */
report: Windows$Devices$PointOfService$MagneticStripeReaderReport;

/**
 * Gets the service code for the swiped bank card.
 */
serviceCode: string;

/**
 * Gets the suffix from the swiped bank card.
 */
suffix: string;

/**
 * Gets the surname from the swiped bank card.
 */
surname: string;

/**
 * Gets the title from the swiped bank card.
 */
title: string
}


/**
 * Provides capabilities information for the magnetic stripe reader.
 */
declare class Windows$Devices$PointOfService$MagneticStripeReaderCapabilities  {

/**
 * Gets the authentication level supported by the device.
 */
authenticationLevel: $Values<typeof Windows$Devices$PointOfService$MagneticStripeReaderAuthenticationLevel>;

/**
 * Gets the type of card authentication data that is supported by the device.
 */
cardAuthentication: string;

/**
 * Indicates whether the device supports ISO cards.
 */
isIsoSupported: boolean;

/**
 * Indicates whether device supports JIS Type-I cards.
 */
isJisOneSupported: boolean;

/**
 * Indicates whether the device supports JIS Type-II cards.
 */
isJisTwoSupported: boolean;

/**
 * Indicates whether the device supports reporting of usage statistics.
 */
isStatisticsReportingSupported: boolean;

/**
 * Indicates whether the device supports updating of usage statistics.
 */
isStatisticsUpdatingSupported: boolean;

/**
 * Indicates whether the device is capable of masking track data.
 */
isTrackDataMaskingSupported: boolean;

/**
 * Indicates whether the devices is able to transmit start and end sentinels.
 */
isTransmitSentinelsSupported: boolean;

/**
 * Gets the power reporting capabilities of the device.
 */
powerReportingType: $Values<typeof Windows$Devices$PointOfService$UnifiedPosPowerReportingType>;

/**
 * Gets the supported encryption algorithm.
 */
supportedEncryptionAlgorithms: number
}


/**
 * Contains the card type of the recently swiped card.
 */
declare class Windows$Devices$PointOfService$MagneticStripeReaderCardTypes  {

/**
 * Indicates the American Association of Motor Vehicle Administrators (AAMVA) card type.
 */
static aamva: number;

/**
 * Indicates a bank card type.
 */
static bank: number;

/**
 * Indicates vendor-specific card type.
 */
static extendedBase: number;

/**
 * Indicates an unknown card type.
 */
static unknown: number
}


/**
 * Contains the encryption algorithm supported by the device.
 */
declare class Windows$Devices$PointOfService$MagneticStripeReaderEncryptionAlgorithms  {

/**
 * Indicates vendor specific encryption algorithm.
 */
static extendedBase: number;

/**
 * Indicates no encryption algorithm.
 */
static none: number;

/**
 * Indicates Triple DES DUKPT (Derived Unique Key Per Transaction) encryption algorithm supported by the device.
 */
static tripleDesDukpt: number
}


/**
 * Provides error information for the ErrorOccurred event.
 */
declare class Windows$Devices$PointOfService$MagneticStripeReaderErrorOccurredEventArgs  {

/**
 * Gets the error information, such as cause of error, severity, error message, and any available vendor specific error information.
 */
errorData: Windows$Devices$PointOfService$UnifiedPosErrorData;

/**
 * Gets the track data for tracks the did not have errors.
 */
partialInputData: Windows$Devices$PointOfService$MagneticStripeReaderReport;

/**
 * Gets the Track 1 error information.
 */
track1Status: $Values<typeof Windows$Devices$PointOfService$MagneticStripeReaderTrackErrorType>;

/**
 * Gets the Track 2 error information.
 */
track2Status: $Values<typeof Windows$Devices$PointOfService$MagneticStripeReaderTrackErrorType>;

/**
 * Gets the Track 3 error information.
 */
track3Status: $Values<typeof Windows$Devices$PointOfService$MagneticStripeReaderTrackErrorType>;

/**
 * Gets the Track 4 error information.
 */
track4Status: $Values<typeof Windows$Devices$PointOfService$MagneticStripeReaderTrackErrorType>
}


/**
 * Defines the constants that indicates the error reporting type for the device.
 */

declare  var Windows$Devices$PointOfService$MagneticStripeReaderErrorReportingType: {|
  +cardLevel: 0,// 0
+trackLevel: 1,// 1

|};



/**
 * Contains data from the recently swiped card.
 */
declare class Windows$Devices$PointOfService$MagneticStripeReaderReport  {

/**
 * Gets the additional security or encryption information for the recently swiped card.
 */
additionalSecurityInformation: Windows$Storage$Streams$IBuffer;

/**
 * Gets the card authentication information for the recently swiped card.
 */
cardAuthenticationData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the length of the raw CardAuthenticationData before it is encrypted.
 */
cardAuthenticationDataLength: number;

/**
 * Gets the card type identifier for the recently swiped card.
 */
cardType: number;

/**
 * Gets a dictionary of properties for the recently swiped card.
 */
properties: Windows$Foundation$Collections$IMapView<string, string>;

/**
 * Gets the track data for Track 1.
 */
track1: Windows$Devices$PointOfService$MagneticStripeReaderTrackData;

/**
 * Gets the track data for Track 2.
 */
track2: Windows$Devices$PointOfService$MagneticStripeReaderTrackData;

/**
 * Gets the track data for Track 3.
 */
track3: Windows$Devices$PointOfService$MagneticStripeReaderTrackData;

/**
 * Gets the track data for Track 4.
 */
track4: Windows$Devices$PointOfService$MagneticStripeReaderTrackData
}


/**
 * Defines the constants that indicates the device authentication status.
 */

declare  var Windows$Devices$PointOfService$MagneticStripeReaderStatus: {|
  +unauthenticated: 0,// 0
+authenticated: 1,// 1
+extended: 2,// 2

|};



/**
 * Provides information about an operation status change.
 */
declare class Windows$Devices$PointOfService$MagneticStripeReaderStatusUpdatedEventArgs  {

/**
 * Gets the vendor specific error code.
 */
extendedStatus: number;

/**
 * Gets the status change information.
 */
status: $Values<typeof Windows$Devices$PointOfService$MagneticStripeReaderStatus>
}


/**
 * Contains the track data obtained following a card swipe.
 */
declare class Windows$Devices$PointOfService$MagneticStripeReaderTrackData  {

/**
 * Gets the raw or decoded data from the swiped card.
 */
data: Windows$Storage$Streams$IBuffer;

/**
 * Gets the discretionary data from the swiped card.
 */
discretionaryData: Windows$Storage$Streams$IBuffer;

/**
 * Gets the encrypted data from the swiped card.
 */
encryptedData: Windows$Storage$Streams$IBuffer
}


/**
 * Defines the constants that indicates the track error type.
 */

declare  var Windows$Devices$PointOfService$MagneticStripeReaderTrackErrorType: {|
  +none: 0,// 0
+startSentinelError: 1,// 1
+endSentinelError: 2,// 2
+parityError: 3,// 3
+lrcError: 4,// 4
+unknown: 5,// 5

|};



/**
 * Defines the constants that indicates the device track ID to read.
 */

declare  var Windows$Devices$PointOfService$MagneticStripeReaderTrackIds: {|
  +none: 0,// 0
+track1: 1,// 1
+track2: 2,// 2
+track3: 3,// 3
+track4: 4,// 4

|};



/**
 * Provides data for the recently swiped vendor card.
 */
declare class Windows$Devices$PointOfService$MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs  {

/**
 * Gets data for the recently swiped vendor card.
 */
report: Windows$Devices$PointOfService$MagneticStripeReaderReport
}


/**
 * Represents a point-of-service printer.
 */
declare class Windows$Devices$PointOfService$PosPrinter  {

/**
 * Creates a PosPrinter object for point-of-service printer with the specified DeviceInformation.Id .
 * @param deviceId The DeviceInformation.Id that identifies a specific point-of-service printer.
 * @return The point-of-service printer that the unique device identifier identifies. Returns a null object in the following cases:
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$PointOfService$PosPrinter>;

/**
 * Gets the default paired or locally-connected printer.
 * @return The default locally-connected printer.
 */
static getDefaultAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$PointOfService$PosPrinter>;

/**
 * Gets an Advanced Query Syntax (AQS) string that you can use to list the available point-of-service printers.
 * @return An Advanced Query Syntax (AQS) string that you can use to list the available point-of-service printers.
 */
static getDeviceSelector(): string;

/**
 * Gets the capabilities of the point-of-service printer.
 */
capabilities: Windows$Devices$PointOfService$PosPrinterCapabilities;

/**
 * Gets the health state of the point-of-service printer asynchronously.
 * @param level The type of health check that you want to perform for the point-of-service printer. Only level POSInternal(1) should be used, as any other UnifiedPosHealthCheckLevel levels will result in an error.
 * @return An asynchronous operation that returns the health state of the point-of-service printer. You should display this value in the app interface immediately so the user of the app can interpret the value. For example, the operation returns OK as the health state if the state of the point-of-service printer is good.
 */
checkHealthAsync(
level: $Values<typeof Windows$Devices$PointOfService$UnifiedPosHealthCheckLevel>): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Claims the point-of-service printer for use, and gets an instance of the ClaimedPosPrinter class for the point-of-service printer.
 * @return The claimed point-of-service printer.
 */
claimPrinterAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$PointOfService$ClaimedPosPrinter>;

/**
 * Gets the identifier of the point-of-service printer.
 */
deviceId: string;

/**
 * Gets the specified statistics from the point-of-service printer.
 * @param statisticsCategories The list of statistics to retrieve.
 * @return The requested statistics.
 */
getStatisticsAsync(
statisticsCategories: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Occurs when the status of the power or availability of the point-of-service printer changes.
 */
onstatusupdated: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$PosPrinter, Windows$Devices$PointOfService$PosPrinterStatusUpdatedEventArgs>;
addEventListener(
type: "statusupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$PosPrinter, Windows$Devices$PointOfService$PosPrinterStatusUpdatedEventArgs>): void;
removeEventListener(
type: "statusupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$PointOfService$PosPrinter, Windows$Devices$PointOfService$PosPrinterStatusUpdatedEventArgs>): void;

/**
 * Gets the current status of the power and availability of the point-of-service printer.
 */
status: Windows$Devices$PointOfService$PosPrinterStatus;

/**
 * Gets the list of character sets that the point-of-service printer supports.
 */
supportedCharacterSets: Windows$Foundation$Collections$IVectorView<number>;

/**
 * Gets the fonts and typefaces that the point-of-service printer supports.
 */
supportedTypeFaces: Windows$Foundation$Collections$IVectorView<string>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Describes the possible horizontal alignments of the text that a point-of-service printer prints on the page.
 */

declare  var Windows$Devices$PointOfService$PosPrinterAlignment: {|
  +left: 0,// 0
+center: 1,// 1
+right: 2,// 2

|};



/**
 * Describes the possible vertical positions in which a point-of-service printer prints the barcode text relative to the barcode.
 */

declare  var Windows$Devices$PointOfService$PosPrinterBarcodeTextPosition: {|
  +none: 0,// 0
+above: 1,// 1
+below: 2,// 2

|};



/**
 * Represents the capabilities of the point-of-service printer.
 */
declare class Windows$Devices$PointOfService$PosPrinterCapabilities  {

/**
 * Gets whether the point-of-service printer can map the characters that the application sends (in the character set that the ClaimedPosPrinter.CharacterSet property defines) to the character sets that the PosPrinter.SupportedCharacterSets property defines.
 */
canMapCharacterSet: boolean;

/**
 * Gets the character set that the point-of-service printer uses by default.
 */
defaultCharacterSet: number;

/**
 * Gets whether the point-of-service printer has a sensor that detects if the printer cover is open.
 */
hasCoverSensor: boolean;

/**
 * Gets whether the point-of-service printer supports reporting statistics.
 */
isStatisticsReportingSupported: boolean;

/**
 * Gets whether the point-of-service printer supports updating statistics.
 */
isStatisticsUpdatingSupported: boolean;

/**
 * Gets whether the point-of-service printer supports printer transactions.
 */
isTransactionSupported: boolean;

/**
 * Gets the capabilities of the journal station for the point-of-service printer.
 */
journal: Windows$Devices$PointOfService$JournalPrinterCapabilities;

/**
 * Gets the power reporting capabilities of the point-of-service printer.
 */
powerReportingType: $Values<typeof Windows$Devices$PointOfService$UnifiedPosPowerReportingType>;

/**
 * Gets the capabilities of the receipt station for the point-of-service printer.
 */
receipt: Windows$Devices$PointOfService$ReceiptPrinterCapabilities;

/**
 * Gets the capabilities of the slip station for the point-of-service printer.
 */
slip: Windows$Devices$PointOfService$SlipPrinterCapabilities
}


/**
 * Describes the possible sensors available for a printer station of a point-of-service printer to use to report the status of the printer.
 */

declare  var Windows$Devices$PointOfService$PosPrinterCartridgeSensors: {|
  +none: 0,// 0
+removed: 1,// 1
+empty: 2,// 2
+headCleaning: 3,// 3
+nearEnd: 4,// 4

|};



/**
 * Represents the set of identifiers for the character sets that a point-of-service printer can use.
 */
declare class Windows$Devices$PointOfService$PosPrinterCharacterSetIds  {

/**
 * Gets the identifier for the ANSI character set.
 */
static ansi: number;

/**
 * Gets the identifier for the ASCII character set.
 */
static ascii: number;

/**
 * Gets the identifier for the UTF16LE character set.
 */
static utf16LE: number
}


/**
 * Describes the possible color cartridges that a point-of-service printer can support.
 */

declare  var Windows$Devices$PointOfService$PosPrinterColorCapabilities: {|
  +none: 0,// 0
+primary: 1,// 1
+custom1: 2,// 2
+custom2: 3,// 3
+custom3: 4,// 4
+custom4: 5,// 5
+custom5: 6,// 6
+custom6: 7,// 7
+cyan: 8,// 8
+magenta: 9,// 9
+yellow: 10,// 10
+full: 11,// 11

|};



/**
 * Describes the color cartridges that the point-of-service printer can use for printing.
 */

declare  var Windows$Devices$PointOfService$PosPrinterColorCartridge: {|
  +unknown: 0,// 0
+primary: 1,// 1
+custom1: 2,// 2
+custom2: 3,// 3
+custom3: 4,// 4
+custom4: 5,// 5
+custom5: 6,// 6
+custom6: 7,// 7
+cyan: 8,// 8
+magenta: 9,// 9
+yellow: 10,// 10

|};



/**
 * Describes the possible directions that a receipt or slip printer station can use to print a ruled line.
 */

declare  var Windows$Devices$PointOfService$PosPrinterLineDirection: {|
  +horizontal: 0,// 0
+vertical: 1,// 1

|};



/**
 * Describes the line styles that a receipt or slip printer station can use to print a ruled line.
 */

declare  var Windows$Devices$PointOfService$PosPrinterLineStyle: {|
  +singleSolid: 0,// 0
+doubleSolid: 1,// 1
+broken: 2,// 2
+chain: 3,// 3

|};



/**
 * Describes the valid units of measure for point-of-service printers.
 */

declare  var Windows$Devices$PointOfService$PosPrinterMapMode: {|
  +dots: 0,// 0
+twips: 1,// 1
+english: 2,// 2
+metric: 3,// 3

|};



/**
 * Describes the capabilities of a receipt printer station for handling mark-sensed paper.
 */

declare  var Windows$Devices$PointOfService$PosPrinterMarkFeedCapabilities: {|
  +none: 0,// 0
+toTakeUp: 1,// 1
+toCutter: 2,// 2
+toCurrentTopOfForm: 3,// 3
+toNextTopOfForm: 4,// 4

|};



/**
 * Describes the ways the receipt printer station should feed the mark-sensed paper when you call the ReceiptPrintJob.MarkFeed method.
 */

declare  var Windows$Devices$PointOfService$PosPrinterMarkFeedKind: {|
  +toTakeUp: 0,// 0
+toCutter: 1,// 1
+toCurrentTopOfForm: 2,// 2
+toNextTopOfForm: 3,// 3

|};



/**
 * Describes the sides of the sheet of paper on which the point-of-service printer prints.
 */

declare  var Windows$Devices$PointOfService$PosPrinterPrintSide: {|
  +unknown: 0,// 0
+side1: 1,// 1
+side2: 2,// 2

|};



/**
 * Provides information about the ClaimedPosPrinter.ReleaseDeviceRequested event that occurs when a point-of-service printer gets a request to release its exclusive claim.
 */
declare class Windows$Devices$PointOfService$PosPrinterReleaseDeviceRequestedEventArgs  {}


/**
 * Describes the possible ways that a point-of-service printer can rotate the text or image on the page.
 */

declare  var Windows$Devices$PointOfService$PosPrinterRotation: {|
  +normal: 0,// 0
+right90: 1,// 1
+left90: 2,// 2
+rotate180: 3,// 3

|};



/**
 * Describes the capabilities of the point-of-service printer to draw ruled lines.
 */

declare  var Windows$Devices$PointOfService$PosPrinterRuledLineCapabilities: {|
  +none: 0,// 0
+horizontal: 1,// 1
+vertical: 2,// 2

|};



/**
 * Provides information about the status of a point-of-service printer, such as the power state of the printer.
 */
declare class Windows$Devices$PointOfService$PosPrinterStatus  {

/**
 * Gets extended information about the power state of the point-of-service printer that the original equipment manufacturer (OEM) defines. Value is only valid if the PosPrinterStatus.StatusKind property is PosPrinterStatusKind.Extended.
 */
extendedStatus: number;

/**
 * Gets the power state of a point-of-service printer.
 */
statusKind: $Values<typeof Windows$Devices$PointOfService$PosPrinterStatusKind>
}


/**
 * Describes the power state for a point-of-service printer.
 */

declare  var Windows$Devices$PointOfService$PosPrinterStatusKind: {|
  +online: 0,// 0
+off: 1,// 1
+offline: 2,// 2
+offOrOffline: 3,// 3
+extended: 4,// 4

|};



/**
 * Provides information about the PosPrinter.StatusUpdated event that occurs when the status of a point-of-service printer changes.
 */
declare class Windows$Devices$PointOfService$PosPrinterStatusUpdatedEventArgs  {

/**
 * Gets the new status of the point-of-service printer after the status of the printer changes.
 */
status: Windows$Devices$PointOfService$PosPrinterStatus
}


/**
 * Represents a set of printing instructions that you want to run on the receipt printer.
 */
declare class Windows$Devices$PointOfService$ReceiptPrintJob  {

/**
 * Adds an instruction to the printer job to cut the receipt paper completely.
 */
cutPaper(): void;

/**
 * Adds an instruction to the printer job to cut the specified percentage of the receipt paper.
 * @param percentage Decimal representation of the percentage of the receipt that the receipt printer should cut.
 */
cutPaper(percentage: number): void;

/**
 * Adds an instruction to the print job to print a drawn, ruled line on the paper of the receipt printer station.
 * @param positionList The position parameters for the ruled line. The character string for positionList differs depending on whether lineDirection specifies a horizontal ruled line or a vertical ruled line.
 * @param lineDirection The direction in which to print the ruled line.
 * @param lineWidth The width of the ruled line that the print should print. The unit of width is dot. If an unsupported value is specified, the best fit value for the printer is used.
 * @param lineStyle The appearance of the ruled line, such as whether it is solid or broken, or single or double.
 * @param lineColor The color of the ruled line, as an integer value that is equal to the value of the cartridge constant used in the ClaimedReceiptPrinter.ColorCartridge property. If an unsupported value is specified, the printing results may be unpredictable.
 */
drawRuledLine(
positionList: string,
lineDirection: $Values<typeof Windows$Devices$PointOfService$PosPrinterLineDirection>,
lineWidth: number,
lineStyle: $Values<typeof Windows$Devices$PointOfService$PosPrinterLineStyle>,
lineColor: number): void;

/**
 * Runs the print job on the receipt printer station asynchronously.
 * @return The operation to run the print job. This operation returns true if the print job succeeds; otherwise, the operation returns false.
 */
executeAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Adds an instruction to the printer job to use the mark sensor of the receipt printer station to position the receipt paper.
 * @param kind An enumeration value that specifies how to position the receipt paper.
 */
markFeed(
kind: $Values<typeof Windows$Devices$PointOfService$PosPrinterMarkFeedKind>): void;

/**
 * Adds an instruction to the print job to print the specified text on the receipt printer station.
 * @param data The text to print on the receipt printer station.
 */
print(data: string): void;

/**
 * Adds an instruction to the print job to print a barcode with the specified data and symbology on the receipt printer station.
 * @param data The data to be represented as a barcode.
 * @param symbology The symbology (encoding) of the barcode. This can be determined based on the BarcodeSymbologies class static methods.
 * @param height The height of the barcode, in pixels.
 * @param width The width of the barcode, in pixels.
 * @param textPosition The vertical position of the barcode text relative to the barcode.
 * @param alignment The horizontal alignment of the barcode on the page.
 */
printBarcode(
data: string,
symbology: number,
height: number,
width: number,
textPosition: $Values<typeof Windows$Devices$PointOfService$PosPrinterBarcodeTextPosition>,
alignment: $Values<typeof Windows$Devices$PointOfService$PosPrinterAlignment>): void;

/**
 * Adds an instruction to the print job to print a barcode with the specified data, symbology, and custom alignment on the receipt printer station.
 * @param data The data to be represented as a barcode.
 * @param symbology The symbology (encoding) of the barcode.
 * @param height The height of the barcode, in pixels.
 * @param width The width of the barcode, in pixels.
 * @param textPosition The vertical position of the barcode text relative to the barcode.
 * @param alignmentDistance The distance from the leftmost print column to the start of the barcode, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 */
printBarcodeCustomAlign(
data: string,
symbology: number,
height: number,
width: number,
textPosition: $Values<typeof Windows$Devices$PointOfService$PosPrinterBarcodeTextPosition>,
alignmentDistance: number): void;

/**
 * Adds an instruction to the print job to print the specified bitmap with the specified width and a standard horizontal placement on the receipt printer station.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
 * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 */
printBitmap(
bitmap: Windows$Graphics$Imaging$BitmapFrame,
alignment: $Values<typeof Windows$Devices$PointOfService$PosPrinterAlignment>,
width: number): void;

/**
 * Adds an instruction to the print job to print the specified bitmap with the specified standard horizontal placement on the receipt printer station.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
 */
printBitmap(
bitmap: Windows$Graphics$Imaging$BitmapFrame,
alignment: $Values<typeof Windows$Devices$PointOfService$PosPrinterAlignment>): void;

/**
 * Adds an instruction to the print job to print the specified bitmap at the specified distance from the leftmost print column on the receipt printer station.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 */
printCustomAlignedBitmap(bitmap: Windows$Graphics$Imaging$BitmapFrame, alignmentDistance: number): void;

/**
 * Adds an instruction to the print job to print the specified bitmap with the specified width and at the specified distance from the leftmost print column on the receipt printer station.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPriinter.MapMode property.
 */
printCustomAlignedBitmap(
bitmap: Windows$Graphics$Imaging$BitmapFrame,
alignmentDistance: number,
width: number): void;

/**
 * Adds an instruction to the print job to print a line of text on the receipt printer station.
 * @param data The line of text to print.
 */
printLine(data: string): void;

/**
 * Adds an instruction to the print job to print a newline character on the receipt printer station.
 */
printLine(): void;

/**
 * Adds an instruction to the print job to print a bitmap on the receipt printer station by using the bitmap and information saved to the printer via SetBitmap or SetCustomAlignedBitmap .
 * @param bitmapNumber The number that you assigned to the bitmap that you want to print when you called SetBitmap or SetCustomAlignedBitmap .
 */
printSavedBitmap(bitmapNumber: number): void;

/**
 * Sets the rotation of the barcode on the page on the receipt printer station.
 * @param value The rotation of the barcode on the page.
 */
setBarcodeRotation(value: $Values<typeof Windows$Devices$PointOfService$PosPrinterRotation>): void;

/**
 * Saves information about a bitmap and a standard horizontal placement that you want to use to print that bitmap on the receipt printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
 */
setBitmap(
bitmapNumber: number,
bitmap: Windows$Graphics$Imaging$BitmapFrame,
alignment: $Values<typeof Windows$Devices$PointOfService$PosPrinterAlignment>): void;

/**
 * Saves information about a bitmap, along with the width and a standard horizontal placement that you want to use to print that bitmap on the receipt printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
 * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 */
setBitmap(
bitmapNumber: number,
bitmap: Windows$Graphics$Imaging$BitmapFrame,
alignment: $Values<typeof Windows$Devices$PointOfService$PosPrinterAlignment>,
width: number): void;

/**
 * Saves information about a bitmap and the distance from the leftmost print column at which you want to print that bitmap on the receipt printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 */
setCustomAlignedBitmap(
bitmapNumber: number,
bitmap: Windows$Graphics$Imaging$BitmapFrame,
alignmentDistance: number): void;

/**
 * Saves information about a bitmap, along with the width and the distance from the leftmost print column that you want to use to print that bitmap on the receipt printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 */
setCustomAlignedBitmap(
bitmapNumber: number,
bitmap: Windows$Graphics$Imaging$BitmapFrame,
alignmentDistance: number,
width: number): void;

/**
 * Sets the area of the page on which the receipt printer station can print the job.
 * @param value The area of the page on which the receipt printer can print the job.
 */
setPrintArea(value: Windows$Foundation$Rect): void;

/**
 * Sets the rotation of the text or image on the page for the receipt printer station.
 * @param value The rotation of the text or image on the page for the receipt printer station.
 * @param includeBitmaps Whether bitmaps should also be rotated. This setting takes effect only for subsequent calls to PrintBitmap , and may not apply to saved bitmaps that you print using PrintSavedBitmap .
 */
setPrintRotation(
value: $Values<typeof Windows$Devices$PointOfService$PosPrinterRotation>,
includeBitmaps: boolean): void
}


/**
 * Represents the capabilities of receipt station of a point-of-service printer.
 */
declare class Windows$Devices$PointOfService$ReceiptPrinterCapabilities  {

/**
 * Gets whether the receipt printer station can perform paper cuts.
 */
canCutPaper: boolean;

/**
 * Gets information about the sensors that the receipt printer station has available to report the status of the printer station.
 */
cartridgeSensors: $Values<typeof Windows$Devices$PointOfService$PosPrinterCartridgeSensors>;

/**
 * Gets the color cartridges that the receipt printer station can use to print in color.
 */
colorCartridgeCapabilities: $Values<typeof Windows$Devices$PointOfService$PosPrinterColorCapabilities>;

/**
 * Gets whether the receipt printer station can print in a rotated upside-down mode.
 */
is180RotationSupported: boolean;

/**
 * Gets whether the receipt printer station can print barcodes.
 */
isBarcodeSupported: boolean;

/**
 * Gets whether the receipt printer station can print bitmaps.
 */
isBitmapSupported: boolean;

/**
 * Gets whether the receipt printer station can print bold characters.
 */
isBoldSupported: boolean;

/**
 * Gets whether the receipt printer station can print characters that are both double-high and double-wide.
 */
isDoubleHighDoubleWidePrintSupported: boolean;

/**
 * Gets whether the receipt printer station can print double-high characters.
 */
isDoubleHighPrintSupported: boolean;

/**
 * Gets whether the receipt printer station can print double-wide characters.
 */
isDoubleWidePrintSupported: boolean;

/**
 * Gets whether the receipt printer station can print a dark color plus an alternate color.
 */
isDualColorSupported: boolean;

/**
 * Gets whether the receipt printer station can print italic characters.
 */
isItalicSupported: boolean;

/**
 * Gets whether the receipt printer station can print information rotated 90 degrees to the left.
 */
isLeft90RotationSupported: boolean;

/**
 * Gets whether the receipt printer station has an out-of-paper sensor.
 */
isPaperEmptySensorSupported: boolean;

/**
 * Gets whether the receipt printer station has a low-paper sensor.
 */
isPaperNearEndSensorSupported: boolean;

/**
 * Gets whether the receipt printer station supports setting a custom size for the area of the page on which the printer should print.
 */
isPrintAreaSupported: boolean;

/**
 * Gets whether a point-of-service printer with a station that prints receipts is present.
 */
isPrinterPresent: boolean;

/**
 * Gets whether the receipt printer station can print information rotated 90 degrees to the right.
 */
isRight90RotationSupported: boolean;

/**
 * Gets whether the receipt printer station has a stamp capability.
 */
isStampSupported: boolean;

/**
 * Gets whether the receipt printer station can underline characters.
 */
isUnderlineSupported: boolean;

/**
 * Gets the type of mark-sensed paper handling that is available for the receipt printer station.
 */
markFeedCapabilities: $Values<typeof Windows$Devices$PointOfService$PosPrinterMarkFeedCapabilities>;

/**
 * Gets information about the capabilities of the receipt printer station to draw ruled lines.
 */
ruledLineCapabilities: $Values<typeof Windows$Devices$PointOfService$PosPrinterRuledLineCapabilities>;

/**
 * Gets a list of the directions in which the receipt printer station can rotate a barcode when printing.
 */
supportedBarcodeRotations: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Devices$PointOfService$PosPrinterRotation>>;

/**
 * Gets a list of the directions in which the receipt printer station can rotate a bitmap when printing.
 */
supportedBitmapRotations: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Devices$PointOfService$PosPrinterRotation>>;

/**
 * Gets a collection of the line widths in characters per line that the receipt printer station supports.
 */
supportedCharactersPerLine: Windows$Foundation$Collections$IVectorView<number>
}


/**
 * Represents a set of printing instructions that you want to run on the slip printer station.
 */
declare class Windows$Devices$PointOfService$SlipPrintJob  {

/**
 * Adds an instruction to the print job to print a drawn, ruled line on the paper of the slip printer station.
 * @param positionList The position parameters for the ruled line. The character string for positionList differs depending on whether lineDirection specifies a horizontal ruled line or a vertical ruled line.
 * @param lineDirection The direction in which to print the ruled line.
 * @param lineWidth The width of the ruled line that the print should print. The unit of width is dot. If an unsupported value is specified, the best fit value for the printer is used.
 * @param lineStyle The appearance of the ruled line, such as whether it is solid or broken, or single or double.
 * @param lineColor The color of the ruled line, as an integer value that is equal to the value of the cartridge constant used in the ClaimedSlipPrinter.ColorCartridge property. If an unsupported value is specified, the printing results may be unpredictable.
 */
drawRuledLine(
positionList: string,
lineDirection: $Values<typeof Windows$Devices$PointOfService$PosPrinterLineDirection>,
lineWidth: number,
lineStyle: $Values<typeof Windows$Devices$PointOfService$PosPrinterLineStyle>,
lineColor: number): void;

/**
 * Runs the print job on the slip printer station asynchronously.
 * @return The operation to run the print job. This operation returns true if the print job succeeds; otherwise, the operation returns false.
 */
executeAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Adds an instruction to the print job to print the specified text on the slip printer station.
 * @param data The text to print on the slip printer station.
 */
print(data: string): void;

/**
 * Adds an instruction to the print job to print a barcode on the slip printer station with the specified data and symbology.
 * @param data The data to represent as a barcode.
 * @param symbology The symbology (encoding) of the barcode.
 * @param height The height of the barcode, in pixels.
 * @param width The width of the barcode, in pixels.
 * @param textPosition The vertical position of the barcode text relative to the barcode.
 * @param alignment The horizontal alignment of the barcode on the page.
 */
printBarcode(
data: string,
symbology: number,
height: number,
width: number,
textPosition: $Values<typeof Windows$Devices$PointOfService$PosPrinterBarcodeTextPosition>,
alignment: $Values<typeof Windows$Devices$PointOfService$PosPrinterAlignment>): void;

/**
 * Adds an instruction to the print job to print a barcode on the slip printer station with the specified data, symbology, and custom alignment.
 * @param data The data to represent as a barcode.
 * @param symbology The symbology (encoding) of the barcode.
 * @param height The height of the barcode, in pixels.
 * @param width The width of the barcode, in pixels.
 * @param textPosition The vertical position of the barcode text relative to the barcode.
 * @param alignmentDistance The distance from the leftmost print column to the start of the barcode, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 */
printBarcodeCustomAlign(
data: string,
symbology: number,
height: number,
width: number,
textPosition: $Values<typeof Windows$Devices$PointOfService$PosPrinterBarcodeTextPosition>,
alignmentDistance: number): void;

/**
 * Adds an instruction to the print job to print the specified bitmap with the specified width and a standard horizontal placement on the slip printer station.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
 * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 */
printBitmap(
bitmap: Windows$Graphics$Imaging$BitmapFrame,
alignment: $Values<typeof Windows$Devices$PointOfService$PosPrinterAlignment>,
width: number): void;

/**
 * Adds an instruction to the print job to print the specified bitmap with the specified standard horizontal placement on the slip printer station.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
 */
printBitmap(
bitmap: Windows$Graphics$Imaging$BitmapFrame,
alignment: $Values<typeof Windows$Devices$PointOfService$PosPrinterAlignment>): void;

/**
 * Adds an instruction to the print job to print the specified bitmap at the specified distance from the leftmost print column on the slip printer station.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 */
printCustomAlignedBitmap(bitmap: Windows$Graphics$Imaging$BitmapFrame, alignmentDistance: number): void;

/**
 * Adds an instruction to the print job to print the specified bitmap with the specified width and at the specified distance from the leftmost print column on the slip printer station.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 */
printCustomAlignedBitmap(
bitmap: Windows$Graphics$Imaging$BitmapFrame,
alignmentDistance: number,
width: number): void;

/**
 * Adds an instruction to the print job to print a line of text on the slip printer station.
 * @param data The line of text to print.
 */
printLine(data: string): void;

/**
 * Adds an instruction to the print job to print a newline character on the slip printer station.
 */
printLine(): void;

/**
 * Adds an instruction to the print job to print a bitmap on the slip printer station by using the information that you saved about the bitmap and how to print it when you called the SetBitmap or SetCustomAlignedBitmap method.
 * @param bitmapNumber The number that you assigned to the bitmap that you want to print when you called SetBitmap or SetCustomAlignedBitmap .
 */
printSavedBitmap(bitmapNumber: number): void;

/**
 * Sets the rotation of the barcode on the page on the slip printer station.
 * @param value The rotation of the barcode on the page on the slip printer station.
 */
setBarcodeRotation(value: $Values<typeof Windows$Devices$PointOfService$PosPrinterRotation>): void;

/**
 * Saves information about a bitmap and a standard horizontal placement that you want to use to print that bitmap on the slip printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
 */
setBitmap(
bitmapNumber: number,
bitmap: Windows$Graphics$Imaging$BitmapFrame,
alignment: $Values<typeof Windows$Devices$PointOfService$PosPrinterAlignment>): void;

/**
 * Saves information about a bitmap, along with the width and a standard horizontal placement that you want to use to print that bitmap on the slip printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
 * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 */
setBitmap(
bitmapNumber: number,
bitmap: Windows$Graphics$Imaging$BitmapFrame,
alignment: $Values<typeof Windows$Devices$PointOfService$PosPrinterAlignment>,
width: number): void;

/**
 * Saves information about a bitmap and the distance from the leftmost print column at which you want to print that bitmap on the slip printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 */
setCustomAlignedBitmap(
bitmapNumber: number,
bitmap: Windows$Graphics$Imaging$BitmapFrame,
alignmentDistance: number): void;

/**
 * Saves information about a bitmap, along with the width and the distance from the leftmost print column that you want to use to print that bitmap on the slip printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
 * @param bitmap Information about the bitmap that you want to print.
 * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 */
setCustomAlignedBitmap(
bitmapNumber: number,
bitmap: Windows$Graphics$Imaging$BitmapFrame,
alignmentDistance: number,
width: number): void;

/**
 * Sets the area of the page on which the slip printer station can print the job.
 * @param value The area of the page on which the slip printer station can print the job.
 */
setPrintArea(value: Windows$Foundation$Rect): void;

/**
 * Sets the rotation of the text or image on the page on the slip printer station.
 * @param value The rotation of the text or image on the page.
 * @param includeBitmaps Whether bitmaps should also be rotated. This setting takes effect only for subsequent calls to PrintBitmap , and may not apply to saved bitmaps that you print using PrintSavedBitmap .
 */
setPrintRotation(
value: $Values<typeof Windows$Devices$PointOfService$PosPrinterRotation>,
includeBitmaps: boolean): void
}


/**
 * Represents the capabilities of slip station of a point-of-service printer.
 */
declare class Windows$Devices$PointOfService$SlipPrinterCapabilities  {

/**
 * Gets information about the sensors that the slip printer station has available to report the status of the printer station.
 */
cartridgeSensors: $Values<typeof Windows$Devices$PointOfService$PosPrinterCartridgeSensors>;

/**
 * Gets the color cartridges that the slip printer station can use to print in color.
 */
colorCartridgeCapabilities: $Values<typeof Windows$Devices$PointOfService$PosPrinterColorCapabilities>;

/**
 * Gets whether the slip printer station can print in a rotated upside-down mode.
 */
is180RotationSupported: boolean;

/**
 * Gets whether the slip printer station can print barcodes.
 */
isBarcodeSupported: boolean;

/**
 * Gets whether the slip printer station can print bitmaps.
 */
isBitmapSupported: boolean;

/**
 * Gets whether the slip printer station can print bold characters.
 */
isBoldSupported: boolean;

/**
 * Gets whether the slip printer station supports printing on both sides of the document.
 */
isBothSidesPrintingSupported: boolean;

/**
 * Gets whether the slip printer station can print characters that are both double-high and double-wide.
 */
isDoubleHighDoubleWidePrintSupported: boolean;

/**
 * Gets whether the slip printer station can print double-high characters.
 */
isDoubleHighPrintSupported: boolean;

/**
 * Gets whether the slip printer station can print double-wide characters.
 */
isDoubleWidePrintSupported: boolean;

/**
 * Gets whether the slip printer station can print a dark color plus an alternate color.
 */
isDualColorSupported: boolean;

/**
 * Gets whether the slip printer station can print full-length forms.
 */
isFullLengthSupported: boolean;

/**
 * Gets whether the slip printer station can print italic characters.
 */
isItalicSupported: boolean;

/**
 * Gets whether the slip printer station can print information rotated 90 degrees to the left.
 */
isLeft90RotationSupported: boolean;

/**
 * Gets whether the slip printer station has an out-of-paper sensor.
 */
isPaperEmptySensorSupported: boolean;

/**
 * Gets whether the slip printer station has a low-paper sensor.
 */
isPaperNearEndSensorSupported: boolean;

/**
 * Gets whether the slip printer station supports setting a custom size for the area of the page on which the printer station should print.
 */
isPrintAreaSupported: boolean;

/**
 * Gets whether a point-of-service printer with a station that prints forms such as checks or credit card slips is present.
 */
isPrinterPresent: boolean;

/**
 * Gets whether the slip printer station can print information rotated 90 degrees to the right.
 */
isRight90RotationSupported: boolean;

/**
 * Gets whether the slip printer station can underline characters.
 */
isUnderlineSupported: boolean;

/**
 * Gets information about the capabilities of the slip printer station to draw ruled lines.
 */
ruledLineCapabilities: $Values<typeof Windows$Devices$PointOfService$PosPrinterRuledLineCapabilities>;

/**
 * Gets a list of the directions in which the slip printer station can rotate a barcode when printing.
 */
supportedBarcodeRotations: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Devices$PointOfService$PosPrinterRotation>>;

/**
 * Gets a list of the directions in which the slip printer station can rotate a bitmap when printing.
 */
supportedBitmapRotations: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Devices$PointOfService$PosPrinterRotation>>;

/**
 * Gets a collection of the line widths in characters per line that the slip printer station supports.
 */
supportedCharactersPerLine: Windows$Foundation$Collections$IVectorView<number>
}


/**
 * Provides error information.
 */
declare class Windows$Devices$PointOfService$UnifiedPosErrorData  {

/**
 * Gets the vendor specific error information.
 */
extendedReason: number;

/**
 * Gets the error message.
 */
message: string;

/**
 * Gets the cause of the error.
 */
reason: $Values<typeof Windows$Devices$PointOfService$UnifiedPosErrorReason>;

/**
 * Gets the error severity.
 */
severity: $Values<typeof Windows$Devices$PointOfService$UnifiedPosErrorSeverity>
}


/**
 * Defines the constants that indicates the reason for the error event.
 */

declare  var Windows$Devices$PointOfService$UnifiedPosErrorReason: {|
  +unknownErrorReason: 0,// 0
+noService: 1,// 1
+disabled: 2,// 2
+illegal: 3,// 3
+noHardware: 4,// 4
+closed: 5,// 5
+offline: 6,// 6
+failure: 7,// 7
+timeout: 8,// 8
+busy: 9,// 9
+extended: 10,// 10

|};



/**
 * Defines the constants that indicates the error severity.
 */

declare  var Windows$Devices$PointOfService$UnifiedPosErrorSeverity: {|
  +unknownErrorSeverity: 0,// 0
+warning: 1,// 1
+recoverable: 2,// 2
+unrecoverable: 3,// 3
+assistanceRequired: 4,// 4
+fatal: 5,// 5

|};



/**
 * Defines the constants that indicates the type of health check that can be performed on the devices.
 */

declare  var Windows$Devices$PointOfService$UnifiedPosHealthCheckLevel: {|
  +unknownHealthCheckLevel: 0,// 0
+posinternal: 1,// 1
+external: 2,// 2
+interactive: 3,// 3

|};



/**
 * Defines the constants that indicates power reporting capabilities of the Point of Service (POS) device.
 */

declare  var Windows$Devices$PointOfService$UnifiedPosPowerReportingType: {|
  +unknownPowerReportingType: 0,// 0
+standard: 1,// 1
+advanced: 2,// 2

|};



      declare var npm$namespace$Windows$Devices$Portable: {
        
        
        ServiceDeviceType: typeof Windows$Devices$Portable$ServiceDeviceType,
        ServiceDevice: typeof Windows$Devices$Portable$ServiceDevice,
StorageDevice: typeof Windows$Devices$Portable$StorageDevice,
        
      }

/**
 * Provides methods for identifying a device service for a portable device that supports WPD (Windows Portable Devices) for device enumeration.
 */
declare class Windows$Devices$Portable$ServiceDevice  {

/**
 * Returns an Advanced Query Syntax (AQS) string that is used to enumerate device services of the specified ServiceDeviceType . This string is passed to the FindAllAsync or CreateWatcher method.
 * @param serviceType The type of service to identify.
 * @return The AQS string.
 */
static getDeviceSelector(
serviceType: $Values<typeof Windows$Devices$Portable$ServiceDeviceType>): string;

/**
 * An Advanced Query Syntax (AQS) string for identifying a device service by its GUIDs. This string is passed to the FindAllAsync or CreateWatcher method.
 * @param serviceId The service identifier.
 * @return The AQS string.
 */
static getDeviceSelectorFromServiceId(serviceId: string): string
}


/**
 * Indicates the type of a portable device service.
 */

declare  var Windows$Devices$Portable$ServiceDeviceType: {|
  +calendarService: 0,// 0
+contactsService: 1,// 1
+deviceStatusService: 2,// 2
+notesService: 3,// 3
+ringtonesService: 4,// 4
+smsService: 5,// 5
+tasksService: 6,// 6

|};



/**
 * Provides methods for accessing the storage functionality of a portable device that supports WPD.
 */
declare class Windows$Devices$Portable$StorageDevice  {

/**
 * Gets a StorageFolder object from a DeviceInformation Id for a removable storage device.
 * @param DeviceId The DeviceInformation ID that identifies the removable storage device. This id can be retrieved from Windows.Devices.Enumeration or the DeviceInformationId property of the AutoPlay device event arguments. For more information, see Quickstart: Register an app for an AutoPlay device. In order for FromId to succeed, the app must declare both the removableStorage capability as shown in the App capability declarations and file type associations for the files it wishes to access on the device as shown in How to handle file activation. For more information, see the Removable Storage sample.
 * @return The storage folder object that represents the removable storage device and provides access to content on the device.
 */
static fromId(DeviceId: string): Windows$Storage$StorageFolder;

/**
 * An Advanced Query Syntax (AQS) string for identifying removable storage devices. This string is passed to the FindAllAsync or CreateWatcher method.
 * @return An AQS string for identifying storage devices.
 */
static getDeviceSelector(): string
}


      declare var npm$namespace$Windows$Devices$Power: {
        
        
        
        Battery: typeof Windows$Devices$Power$Battery,
BatteryReport: typeof Windows$Devices$Power$BatteryReport,
        
      }

/**
 * Provides information about a battery controller that is currently connected to the device. For more info, see Get battery information.
 */
declare class Windows$Devices$Power$Battery  {

/**
 * Gets a Battery object that represents all battery controllers connected to the device.
 */
static aggregateBattery: Windows$Devices$Power$Battery;

/**
 * Gets a Battery object that represents an individual battery controller connected to the device.
 * @param deviceId The device ID of the battery controller ( DeviceId ).
 * @return A Battery object that corresponds to the specified battery controller.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Power$Battery>;

/**
 * Gets an Advanced Query Syntax (AQS) string that can be used to find all battery controllers that are connected to the device.
 * @return An AQS string that can be used to find all battery controllers connected to the device.
 */
static getDeviceSelector(): string;

/**
 * Gets the identifier (ID) for an individual battery controller.
 */
deviceId: string;

/**
 * Gets a BatteryReport object that indicates the charge, capacity, and status of the battery or aggregate.
 * @return Indicates the charge, capacity, and status of the battery or aggregate.
 */
getReport(): Windows$Devices$Power$BatteryReport;

/**
 * Occurs when the charge, capacity, or status of a battery changes.
 */
onreportupdated: Windows$Foundation$TypedEventHandler<Windows$Devices$Power$Battery, any>;
addEventListener(
type: "reportupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Power$Battery, any>): void;
removeEventListener(
type: "reportupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Power$Battery, any>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides properties that indicate the charge, capacity, and status of the battery. For more info, see Get battery information.
 */
declare class Windows$Devices$Power$BatteryReport  {

/**
 * Gets the rate that the battery is charging.
 */
chargeRateInMilliwatts: number;

/**
 * Gets the estimated energy capacity of a new battery of this type.
 */
designCapacityInMilliwattHours: number;

/**
 * Gets the fully-charged energy capacity of the battery.
 */
fullChargeCapacityInMilliwattHours: number;

/**
 * Gets the remaining power capacity of the battery.
 */
remainingCapacityInMilliwattHours: number;

/**
 * Gets a BatteryStatus enumeration that indicates the status of the battery.
 */
status: $Values<typeof Windows$System$Power$BatteryStatus>
}


      declare var npm$namespace$Windows$Devices$Printers: {
        
        
        
        Print3DDevice: typeof Windows$Devices$Printers$Print3DDevice,
PrintSchema: typeof Windows$Devices$Printers$PrintSchema,
        Extensions: typeof npm$namespace$Windows$Devices$Printers$Extensions,
      }

      declare var npm$namespace$Windows$Devices$Printers$Extensions: {
        
        
        Print3DWorkflowDetail: typeof Windows$Devices$Printers$Extensions$Print3DWorkflowDetail,
Print3DWorkflowStatus: typeof Windows$Devices$Printers$Extensions$Print3DWorkflowStatus,
        Print3DWorkflow: typeof Windows$Devices$Printers$Extensions$Print3DWorkflow,
Print3DWorkflowPrintRequestedEventArgs: typeof Windows$Devices$Printers$Extensions$Print3DWorkflowPrintRequestedEventArgs,
PrintExtensionContext: typeof Windows$Devices$Printers$Extensions$PrintExtensionContext,
PrintNotificationEventDetails: typeof Windows$Devices$Printers$Extensions$PrintNotificationEventDetails,
PrintTaskConfiguration: typeof Windows$Devices$Printers$Extensions$PrintTaskConfiguration,
PrintTaskConfigurationSaveRequest: typeof Windows$Devices$Printers$Extensions$PrintTaskConfigurationSaveRequest,
PrintTaskConfigurationSaveRequestedDeferral: typeof Windows$Devices$Printers$Extensions$PrintTaskConfigurationSaveRequestedDeferral,
PrintTaskConfigurationSaveRequestedEventArgs: typeof Windows$Devices$Printers$Extensions$PrintTaskConfigurationSaveRequestedEventArgs,
        
      }

/**
 * Represents a customized printing experience for a 3D printer.
 */
declare class Windows$Devices$Printers$Extensions$Print3DWorkflow  {

/**
 * Gets the device identifier of the 3D printer.
 */
deviceID: string;

/**
 * Gets the model of the 3D object to be printed.
 * @return The model of the 3D object to be printed.
 */
getPrintModelPackage(): any;

/**
 * Gets or sets a value that indicates the 3D object is ready for printing and no further user interaction is required.
 */
isPrintReady: boolean;

/**
 * Occurs when the user initiates printing.
 */
onprintrequested: Windows$Foundation$TypedEventHandler<Windows$Devices$Printers$Extensions$Print3DWorkflow, Windows$Devices$Printers$Extensions$Print3DWorkflowPrintRequestedEventArgs>;
addEventListener(
type: "printrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Printers$Extensions$Print3DWorkflow, Windows$Devices$Printers$Extensions$Print3DWorkflowPrintRequestedEventArgs>): void;
removeEventListener(
type: "printrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Printers$Extensions$Print3DWorkflow, Windows$Devices$Printers$Extensions$Print3DWorkflowPrintRequestedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies the types of errors that may be encountered by the Print3DWorkflow class.
 */

declare  var Windows$Devices$Printers$Extensions$Print3DWorkflowDetail: {|
  +unknown: 0,// 0
+modelExceedsPrintBed: 1,// 1
+uploadFailed: 2,// 2
+invalidMaterialSelection: 3,// 3
+invalidModel: 4,// 4
+modelNotManifold: 5,// 5
+invalidPrintTicket: 6,// 6

|};



/**
 * Provides data about the print request to the app that initiated the request.
 */
declare class Windows$Devices$Printers$Extensions$Print3DWorkflowPrintRequestedEventArgs  {

/**
 * Sets the extended status of the print request.
 * @param value The extended status of the print request.
 */
setExtendedStatus(
value: $Values<typeof Windows$Devices$Printers$Extensions$Print3DWorkflowDetail>): void;

/**
 * Sets the latest model data, including any updates made by the Print3DWorkflow .
 * @param source The latest model data, including any updates made by the Print3DWorkflow .
 */
setSource(source: any): void;

/**
 * Indicates if the data model has been updated by the Print3DWorkflow .
 * @param value Returns true if the data model has been updated; otherwise, false.
 */
setSourceChanged(value: boolean): void;

/**
 * Gets the status of the print request.
 */
status: $Values<typeof Windows$Devices$Printers$Extensions$Print3DWorkflowStatus>
}


/**
 * Specifies the status of the Print3DWorkflow class.
 */

declare  var Windows$Devices$Printers$Extensions$Print3DWorkflowStatus: {|
  +abandoned: 0,// 0
+canceled: 1,// 1
+failed: 2,// 2
+slicing: 3,// 3
+submitted: 4,// 4

|};



/**
 * Provides the context for the printer extension object.
 */
declare class Windows$Devices$Printers$Extensions$PrintExtensionContext  {

/**
 * Gets the context for the printer extension object based on the DeviceInformation ID.
 * @param deviceId The device information ID for the print device.
 * @return Pointer to the context.
 */
static fromDeviceId(deviceId: string): any
}


/**
 * Contains properties that allow a client to access and/or manipulate print event data and print device name information.
 */
declare class Windows$Devices$Printers$Extensions$PrintNotificationEventDetails  {

/**
 * Gets or sets the event data for a print notification event.
 */
eventData: string;

/**
 * Gets the name of the print device associated with the print notification.
 */
printerName: string
}


/**
 * Allows a client to retrieve the print task extension context, and also to add an event handler to the print task.
 */
declare class Windows$Devices$Printers$Extensions$PrintTaskConfiguration  {

/**
 * Raised by the print window for your app to notify the device app that the print ticket must be updated.
 */
onsaverequested: Windows$Foundation$TypedEventHandler<Windows$Devices$Printers$Extensions$PrintTaskConfiguration, Windows$Devices$Printers$Extensions$PrintTaskConfigurationSaveRequestedEventArgs>;
addEventListener(
type: "saverequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Printers$Extensions$PrintTaskConfiguration, Windows$Devices$Printers$Extensions$PrintTaskConfigurationSaveRequestedEventArgs>): void;
removeEventListener(
type: "saverequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Printers$Extensions$PrintTaskConfiguration, Windows$Devices$Printers$Extensions$PrintTaskConfigurationSaveRequestedEventArgs>): void;

/**
 * Gets the context for the print task extension.
 */
printerExtensionContext: any;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Called when the print dialog for your app raises a SaveRequested event.
 */
declare class Windows$Devices$Printers$Extensions$PrintTaskConfigurationSaveRequest  {

/**
 * Called by the device app to cancel the client's request to save the print task configuration.
 */
cancel(): void;

/**
 * Gets the date-time object that provides the deadline information for the print task.
 */
deadline: Date;

/**
 * Called by the device app when it has to complete some asynchronous tasks before it can save the print task configuration information.
 * @return The object that represents the deferral for the print task configuration save request.
 */
getDeferral(
): Windows$Devices$Printers$Extensions$PrintTaskConfigurationSaveRequestedDeferral;

/**
 * Called by the device app to save the print task configuration.
 * @param printerExtensionContext The object that represents the print task extension context.
 */
save(printerExtensionContext: any): void
}


/**
 * Called by the device app to provide an update of the status of the deferral.
 */
declare class Windows$Devices$Printers$Extensions$PrintTaskConfigurationSaveRequestedDeferral  {

/**
 * Called by the device app when the deferral is completed.
 */
complete(): void
}


/**
 * Called to notify the device app that the print task configuration must be saved.
 */
declare class Windows$Devices$Printers$Extensions$PrintTaskConfigurationSaveRequestedEventArgs  {

/**
 * Gets the information that is required for updating the print task configuration.
 */
request: Windows$Devices$Printers$Extensions$PrintTaskConfigurationSaveRequest
}


/**
 * Represents a 3D printer.
 */
declare class Windows$Devices$Printers$Print3DDevice  {

/**
 * Creates a Print3DDevice object that represents a 3D printer connected to the device.
 * @param deviceId The device ID of the 3D printer.
 * @return A Print3DDevice object that corresponds to the specified 3D printer.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Printers$Print3DDevice>;

/**
 * Gets an Advanced Query Syntax (AQS) string that can be used to find all 3D printers that are connected to the device.
 * @return An AQS string that can be used to find all 3D printers connected to the device.
 */
static getDeviceSelector(): string;

/**
 * Gets the PrintSchema object for obtaining capabilities and print ticket information.
 */
printSchema: Windows$Devices$Printers$PrintSchema
}


/**
 * Provides APIs to access a 3D printer's capabilities and print tickets.
 */
declare class Windows$Devices$Printers$PrintSchema  {

/**
 * Gets the 3D printer capabilities.
 * @param constrainTicket The print ticket.
 * @return An XML PrintCapabilities document containing 3D printer capabilities.
 */
getCapabilitiesAsync(
constrainTicket: Windows$Storage$Streams$IRandomAccessStreamWithContentType): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStreamWithContentType>;

/**
 * Gets the 3D printer's default print ticket.
 * @return An XML PrintTicket document containing the 3D printer's default print ticket.
 */
getDefaultPrintTicketAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStreamWithContentType>;

/**
 * Creates a new print ticket by merging the users selection with the default print ticket and validating that it will work for the device.
 * @param deltaTicket The delta print ticket, specifies the differences between the default print ticket and the user's selections.
 * @return An XML PrintTicket document containing the suggested print ticket.
 */
mergeAndValidateWithDefaultPrintTicketAsync(
deltaTicket: Windows$Storage$Streams$IRandomAccessStreamWithContentType): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStreamWithContentType>
}


      declare var npm$namespace$Windows$Devices$Pwm: {
        
        
        
        PwmController: typeof Windows$Devices$Pwm$PwmController,
PwmPin: typeof Windows$Devices$Pwm$PwmPin,
        PwmPulsePolarity: typeof npm$namespace$Windows$Devices$Pwm$PwmPulsePolarity,
      }


declare class Windows$Devices$Pwm$PwmController  {
static getControllersAsync: any;
static getDefaultAsync: any;
actualFrequency: any;
maxFrequency: any;
minFrequency: any;
openPin: any;
pinCount: any;
setDesiredFrequency: any
}

declare class Windows$Devices$Pwm$PwmPin  {
close: any;
controller: any;
getActiveDutyCyclePercentage: any;
isStarted: any;
polarity: any;
setActiveDutyCyclePercentage: any;
start: any;
stop: any
}


      declare var npm$namespace$Windows$Devices$Pwm$PwmPulsePolarity: {
        
        activeHigh: typeof Windows$Devices$Pwm$PwmPulsePolarity$activeHigh,
activeLow: typeof Windows$Devices$Pwm$PwmPulsePolarity$activeLow,
        
        
        
      }
declare var Windows$Devices$Pwm$PwmPulsePolarity$activeHigh: any;

declare var Windows$Devices$Pwm$PwmPulsePolarity$activeLow: any;


      declare var npm$namespace$Windows$Devices$Radios: {
        
        
        RadioAccessStatus: typeof Windows$Devices$Radios$RadioAccessStatus,
RadioKind: typeof Windows$Devices$Radios$RadioKind,
RadioState: typeof Windows$Devices$Radios$RadioState,
        Radio: typeof Windows$Devices$Radios$Radio,
        
      }

/**
 * Represents a radio device on the system.
 */
declare class Windows$Devices$Radios$Radio  {

/**
 * A static method that retrieves a Radio object corresponding to a device Id obtained through Windows.Devices.Enumeration.DeviceInformation.FindAllAsync and related APIs.
 * @param deviceId A string that identifies a particular radio device.
 * @return An asynchronous retrieval operation. On successful completion, it contains a Radio object that represents the specified radio device.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Radios$Radio>;

/**
 * A static method that returns an Advanced Query Syntax (AQS) string to be used to enumerate or monitor Radio devices with Windows.Devices.Enumeration.DeviceInformation.FindAllAsync and related methods.
 * @return An identifier to be used to enumerate radio devices.
 */
static getDeviceSelector(): string;

/**
 * A static, asynchronous method that retrieves a collection of Windows.Devices.Radios.Radio objects representing radio devices existing on the system.
 * @return An asynchronous retrieval operation. When the operation is complete, contains a list of Windows.Devices.Radios.Radio objects describing available radios.
 */
static getRadiosAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * An asynchronous method that retrieves a value indicating what access the current user has to the radio represented by this object. In circumstances where user permission is required to access the radio, this method prompts the user for permission. Consequently, always call this method on the UI thread.
 * @return An asynchronous status retrieval operation. On successful completion, contains an enumeration value describing the current user's access to this radio.
 */
static requestAccessAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Devices$Radios$RadioAccessStatus>>;

/**
 * Gets an enumeration value that describes what kind of radio this object represents.
 */
kind: $Values<typeof Windows$Devices$Radios$RadioKind>;

/**
 * Gets the name of the radio represented by this object.
 */
name: string;

/**
 * Event raised by a state change in the radio represented by this object.
 */
onstatechanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Radios$Radio, any>;
addEventListener(
type: "statechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Radios$Radio, any>): void;
removeEventListener(
type: "statechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Radios$Radio, any>): void;

/**
 * An asynchronous operation that attempts to set the state of the radio represented by this object.
 * @param value The desired radio state.
 * @return An asynchronous state setting operation. On successful completion, contains an enumeration value describing status of the state change request.
 */
setStateAsync(
value: $Values<typeof Windows$Devices$Radios$RadioState>): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Devices$Radios$RadioAccessStatus>>;

/**
 * Gets the current state of the radio represented by this object.
 */
state: $Values<typeof Windows$Devices$Radios$RadioState>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Enumeration that describes possible access states that a user can have to a given radio.
 */

declare  var Windows$Devices$Radios$RadioAccessStatus: {|
  +unspecified: 0,// 0
+allowed: 1,// 1
+deniedByUser: 2,// 2
+deniedBySystem: 3,// 3

|};



/**
 * Enumeration that represents the kinds of radio devices.
 */

declare  var Windows$Devices$Radios$RadioKind: {|
  +other: 0,// 0
+wiFi: 1,// 1
+mobileBroadband: 2,// 2
+bluetooth: 3,// 3
+fm: 4,// 4

|};



/**
 * Enumeration that describes possible radio states.
 */

declare  var Windows$Devices$Radios$RadioState: {|
  +unknown: 0,// 0
+on: 1,// 1
+off: 2,// 2
+disabled: 3,// 3

|};



      declare var npm$namespace$Windows$Devices$Scanners: {
        
        
        ImageScannerAutoCroppingMode: typeof Windows$Devices$Scanners$ImageScannerAutoCroppingMode,
ImageScannerColorMode: typeof Windows$Devices$Scanners$ImageScannerColorMode,
ImageScannerFormat: typeof Windows$Devices$Scanners$ImageScannerFormat,
ImageScannerScanSource: typeof Windows$Devices$Scanners$ImageScannerScanSource,
        ImageScanner: typeof Windows$Devices$Scanners$ImageScanner,
ImageScannerAutoConfiguration: typeof Windows$Devices$Scanners$ImageScannerAutoConfiguration,
ImageScannerFeederConfiguration: typeof Windows$Devices$Scanners$ImageScannerFeederConfiguration,
ImageScannerFlatbedConfiguration: typeof Windows$Devices$Scanners$ImageScannerFlatbedConfiguration,
ImageScannerPreviewResult: typeof Windows$Devices$Scanners$ImageScannerPreviewResult,
ImageScannerScanResult: typeof Windows$Devices$Scanners$ImageScannerScanResult,
        
      }

/**
 * Represents the properties of images to scan.
 */
declare class Windows$Devices$Scanners$ImageScanner  {

/**
 * Creates an instance of a ImageScanner object based on a scanners device information ID. This method is required for broker device enumeration.
 * @param deviceId The device information ID. See DeviceInformation.Id property.
 * @return The ImageScanner object.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Scanners$ImageScanner>;

/**
 * Returns the class selection string that apps can use to enumerate scanner devices. This method is required for the brokered device enumeration.
 * @return The class selection.
 */
static getDeviceSelector(): string;

/**
 * Gets and sets the scan settings of the auto-configured scan unit, like the file format, including compression to deliver the scanned data in. This property is ignored if the scanner is not capable of auto-configuration.
 */
autoConfiguration: Windows$Devices$Scanners$ImageScannerAutoConfiguration;

/**
 * Gets the default scan source chosen for this scanner device.
 */
defaultScanSource: $Values<typeof Windows$Devices$Scanners$ImageScannerScanSource>;

/**
 * Gets the PnP device identifier of this scanner device.
 */
deviceId: string;

/**
 * Gets or sets the scan settings of the Feeder scan unit, like page size, orientation, and scan resolution.
 */
feederConfiguration: Windows$Devices$Scanners$ImageScannerFeederConfiguration;

/**
 * Gets and sets the scan settings of the Flatbed scan unit, like scan resolution and color mode.
 */
flatbedConfiguration: Windows$Devices$Scanners$ImageScannerFlatbedConfiguration;

/**
 * Determines if the specified scan source supports scan preview.
 * @param scanSource The scan source.
 * @return Returns True if the specified scan source supports preview; otherwise False.
 */
isPreviewSupported(
scanSource: $Values<typeof Windows$Devices$Scanners$ImageScannerScanSource>): boolean;

/**
 * Determines if the specified scan source is available on the scanner.
 * @param value The scan source.
 * @return True if the scan source, Flatbed or Feeder, is available; otherwise False.
 */
isScanSourceSupported(
value: $Values<typeof Windows$Devices$Scanners$ImageScannerScanSource>): boolean;

/**
 * Starts a scan job with the specified scan source and writes one or multiple images to one multi-page file like TIFF, XPS, and PDF; or one or multiple single-page files like DIB, PNG, JPG, and TIFF to the specified folder location. Returns the progress of the scan.
 * @param scanSource The image scan source.
 * @param storageFolder The target folder location of the scanned file.
 * @return The list of scanned image files from ImageScannerScanResult and the progress of the WIA scan job from UInt32, which indicates how many files were transferred to the target folder.
 */
scanFilesToFolderAsync(
scanSource: $Values<typeof Windows$Devices$Scanners$ImageScannerScanSource>,
storageFolder: Windows$Storage$StorageFolder): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Devices$Scanners$ImageScannerScanResult, number>;

/**
 * Scans one image from the specified scan source and applies the lowest scan resolution with the selected image file format.
 * @param scanSource The image scan source.
 * @param targetStream The scanned image file.
 * @return The progress of the scan and the scanned file format.
 */
scanPreviewToStreamAsync(
scanSource: $Values<typeof Windows$Devices$Scanners$ImageScannerScanSource>,
targetStream: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Scanners$ImageScannerPreviewResult>
}


/**
 * Represents the auto-configured scan source of the scanner.
 */
declare class Windows$Devices$Scanners$ImageScannerAutoConfiguration  {

/**
 * The default file format for the scan source at the beginning of a new scan session.
 */
defaultFormat: $Values<typeof Windows$Devices$Scanners$ImageScannerFormat>;

/**
 * Gets or sets the current file transfer format for image data acquisition from the device to the client app.
 */
format: $Values<typeof Windows$Devices$Scanners$ImageScannerFormat>;

/**
 * Determines if the input scanner supports the specified file format.
 * @param value The file type.
 * @return True if the specified file type is supported; otherwise False.
 */
isFormatSupported(value: $Values<typeof Windows$Devices$Scanners$ImageScannerFormat>): boolean
}


/**
 * Specifies the automatic crop mode of the scanning device.
 */

declare  var Windows$Devices$Scanners$ImageScannerAutoCroppingMode: {|
  +disabled: 0,// 0
+singleRegion: 1,// 1
+multipleRegion: 2,// 2

|};



/**
 * Specifies the color modes for the scan source.
 */

declare  var Windows$Devices$Scanners$ImageScannerColorMode: {|
  +color: 0,// 0
+grayscale: 1,// 1
+monochrome: 2,// 2
+autoColor: 3,// 3

|};



/**
 * Represents the Feeder scan source of the scanner.
 */
declare class Windows$Devices$Scanners$ImageScannerFeederConfiguration  {

/**
 * Gets the actual horizontal and vertical scan resolution for the scanner's Feeder, in DPI.
 */
actualResolution: Windows$Devices$Scanners$ImageScannerResolution;

/**
 * Gets or sets the automatic crop mode.
 */
autoCroppingMode: $Values<typeof Windows$Devices$Scanners$ImageScannerAutoCroppingMode>;

/**
 * Gets or sets the page size automatic detection feature for the scanner's Feeder.
 */
autoDetectPageSize: boolean;

/**
 * Gets or sets the current brightness level for capturing image data from the scanner's Feeder. At the beginning of a new scan session, this property is set to the DefaultBrightness property.
 */
brightness: number;

/**
 * Gets the step size at which the brightness levels of the data source can be increased or decreased between the minimum and maximum values.
 */
brightnessStep: number;

/**
 * Returns True if the device can automatically detect at scan time the size of the document pages scanned through the Feeder; otherwise returns False.
 */
canAutoDetectPageSize: boolean;

/**
 * Gets whether the scanner device is capable of scanning ahead from its Feeder.
 */
canScanAhead: boolean;

/**
 * Gets whether the scanner's Feeder is capable of duplex scanning (scanning both document page sides, front and back). When scanning in duplex mode the same scan settings (such as color mode and scan resolution) are applied to scan both page sides.
 */
canScanDuplex: boolean;

/**
 * Gets or sets the color mode for the scanner's Feeder.
 */
colorMode: $Values<typeof Windows$Devices$Scanners$ImageScannerColorMode>;

/**
 * Sets or gets the current contrast level for capturing image data from the scanner's Feeder. At the beginning of a new scan session this property is set to the DefaultContrast property.
 */
contrast: number;

/**
 * Gets the step size at which the contrast levels of the data source can increase or decrease between the minimum and maximum values.
 */
contrastStep: number;

/**
 * Gets the default brightness level for the scanner's Feeder.
 */
defaultBrightness: number;

/**
 * Gets the default color mode for the scanner's Feeder.
 */
defaultColorMode: $Values<typeof Windows$Devices$Scanners$ImageScannerColorMode>;

/**
 * Gets the default contrast level for the scanner's Feeder.
 */
defaultContrast: number;

/**
 * Gets the default file format for the scanner's Feeder at the beginning of a new scan session.
 */
defaultFormat: $Values<typeof Windows$Devices$Scanners$ImageScannerFormat>;

/**
 * Gets or sets the horizontal and vertical scan resolution for the scanner's Feeder that the app requests, in DPI.
 */
desiredResolution: Windows$Devices$Scanners$ImageScannerResolution;

/**
 * Indicates whether the scanner's Feeder can scan both document page sides.
 */
duplex: boolean;

/**
 * Gets or sets the current file transfer format for image data acquisition from the scanner's Feeder to the client app.
 */
format: $Values<typeof Windows$Devices$Scanners$ImageScannerFormat>;

/**
 * Returns whether the scanner's Feeder supports the specified ImageScannerAutoCroppingMode .
 * @param value The auto crop mode of the image to scan.
 * @return Indicates whether the device supports value mode.
 */
isAutoCroppingModeSupported(
value: $Values<typeof Windows$Devices$Scanners$ImageScannerAutoCroppingMode>): boolean;

/**
 * Returns whether the scanner's Feeder can scan and transfer images in the specified color mode.
 * @param value The color mode.
 * @return Indicates whether the scanner can scan images in value mode.
 */
isColorModeSupported(value: $Values<typeof Windows$Devices$Scanners$ImageScannerColorMode>): boolean;

/**
 * Determines whether the scanner's Feeder supports the specified file format or not.
 * @param value The file type.
 * @return Indicates whether the specified file type is supported.
 */
isFormatSupported(value: $Values<typeof Windows$Devices$Scanners$ImageScannerFormat>): boolean;

/**
 * Returns whether the Feeder can scan documents in the specified page size and orientation.
 * @param pageSize The page size.
 * @param pageOrientation The page orientation.
 * @return Indicates the scanner can scan with pageSize and pageOrientation values.
 */
isPageSizeSupported(
pageSize: $Values<typeof Windows$Graphics$Printing$PrintMediaSize>,
pageOrientation: $Values<typeof Windows$Graphics$Printing$PrintOrientation>): boolean;

/**
 * Gets the maximum brightness level supported by the scanner's Feeder.
 */
maxBrightness: number;

/**
 * Gets the maximum contrast level supported by the scanner's Feeder.
 */
maxContrast: number;

/**
 * Gets or sets the maximum number of pages-not images, the app can scan in one scan job, before the scanner stops.
 */
maxNumberOfPages: number;

/**
 * Gets the maximum horizontal and vertical scan resolution of the scanner's Feeder in DPI.
 */
maxResolution: Windows$Devices$Scanners$ImageScannerResolution;

/**
 * Gets the maximum scan area dimensions in inches. The maximum scan width is the widest a document can be in order for the scanner's Feeder to scan it.
 */
maxScanArea: Windows$Foundation$Size;

/**
 * Gets the minimum brightness level supported by the scanner's Feeder.
 */
minBrightness: number;

/**
 * Gets the minimum contrast level supported by the scanner's Feeder.
 */
minContrast: number;

/**
 * Gets the minimum horizontal and vertical scan resolution of the scanner's Feeder in DPI.
 */
minResolution: Windows$Devices$Scanners$ImageScannerResolution;

/**
 * Gets the minimum scan area in inches. The minimum scan area is the smallest size a document can have in order for a Feeder to scan it.
 */
minScanArea: Windows$Foundation$Size;

/**
 * Gets the optical horizontal and vertical scan resolution of the scanner's Feeder in DPI.
 */
opticalResolution: Windows$Devices$Scanners$ImageScannerResolution;

/**
 * Gets or sets the currently selected page orientation that tells how to place the documents in the scanner's Feeder input tray.
 */
pageOrientation: $Values<typeof Windows$Graphics$Printing$PrintOrientation>;

/**
 * Gets or sets the currently selected page size to scan from the Feeder.
 */
pageSize: $Values<typeof Windows$Graphics$Printing$PrintMediaSize>;

/**
 * Gets the dimensions (width and height) and orientation of the selected page size, in mil units (1/1000").
 */
pageSizeDimensions: Windows$Foundation$Size;

/**
 * Indicates whether or not to scan ahead.
 */
scanAhead: boolean;

/**
 * Gets or sets the origin coordinates (horizontal and vertical) and dimensions (width and height) of the selected scan area, in inches. This property is ignored when the AutoCroppingMode property is not Disabled.
 */
selectedScanRegion: Windows$Foundation$Rect
}


/**
 * Represents the Flatbed scan source of the scanner.
 */
declare class Windows$Devices$Scanners$ImageScannerFlatbedConfiguration  {

/**
 * Gets the actual horizontal and vertical scan resolution for the Flatbed scanner, in DPI.
 */
actualResolution: Windows$Devices$Scanners$ImageScannerResolution;

/**
 * Gets or sets the automatic crop mode.
 */
autoCroppingMode: $Values<typeof Windows$Devices$Scanners$ImageScannerAutoCroppingMode>;

/**
 * Gets or sets the current brightness level for capturing image data from the scanner's Flatbed. At the beginning of a new scan session, this property is set to the DefaultBrightness property.
 */
brightness: number;

/**
 * Gets the step size at which the brightness levels of the data source can be increased or decreased between the minimum and maximum values.
 */
brightnessStep: number;

/**
 * Gets or sets the color mode for the Flatbed scanner.
 */
colorMode: $Values<typeof Windows$Devices$Scanners$ImageScannerColorMode>;

/**
 * Sets or gets the current contrast level for capturing image data from the scan source. At the beginning of a new scan session this property is set to the DefaultContrast property.
 */
contrast: number;

/**
 * Gets the step size at which the contrast levels of the data source can increase or decrease between the minimum and maximum values.
 */
contrastStep: number;

/**
 * Gets the default brightness level for the scanner's Flatbed.
 */
defaultBrightness: number;

/**
 * Gets the default color mode for the scanner's Flatbed.
 */
defaultColorMode: $Values<typeof Windows$Devices$Scanners$ImageScannerColorMode>;

/**
 * Gets the default contrast level for the scanner's Flatbed.
 */
defaultContrast: number;

/**
 * Gets the default file format for the scanner's Flatbed at the beginning of a new scan session.
 */
defaultFormat: $Values<typeof Windows$Devices$Scanners$ImageScannerFormat>;

/**
 * Gets or sets the horizontal and vertical scan resolution for the scanner's Flatbed that the app requests, in DPI.
 */
desiredResolution: Windows$Devices$Scanners$ImageScannerResolution;

/**
 * Gets or sets the current file transfer format for image data acquisition from the scanner's Flatbed to the client app.
 */
format: $Values<typeof Windows$Devices$Scanners$ImageScannerFormat>;

/**
 * Returns whether the scanner's Flatbed supports the specified ImageScannerAutoCroppingMode .
 * @param value The auto crop mode of the image to scan.
 * @return Indicates whether the device supports value mode.
 */
isAutoCroppingModeSupported(
value: $Values<typeof Windows$Devices$Scanners$ImageScannerAutoCroppingMode>): boolean;

/**
 * Returns whether the scanner's Flatbed can scan and transfer images in the specified color mode.
 * @param value The color mode.
 * @return Indicates whether the scanner can scan images in value mode.
 */
isColorModeSupported(value: $Values<typeof Windows$Devices$Scanners$ImageScannerColorMode>): boolean;

/**
 * Determines whether the scanner's Flatbed supports the specified file format or not.
 * @param value The file type.
 * @return Indicates whether the specified file type is supported.
 */
isFormatSupported(value: $Values<typeof Windows$Devices$Scanners$ImageScannerFormat>): boolean;

/**
 * Gets the maximum brightness level supported by the scanner's Flatbed.
 */
maxBrightness: number;

/**
 * Gets the maximum contrast level supported by the scanner's Flatbed.
 */
maxContrast: number;

/**
 * Gets the maximum horizontal and vertical scan resolution of the scanner's Flatbed in DPI.
 */
maxResolution: Windows$Devices$Scanners$ImageScannerResolution;

/**
 * Gets the maximum scan area dimensions in inches. The maximum scan width is the widest a document can be in order for the scanner's Flatbed to scan it.
 */
maxScanArea: Windows$Foundation$Size;

/**
 * Gets the minimum brightness level supported by the scanner's Flatbed.
 */
minBrightness: number;

/**
 * Gets the minimum contrast level supported by the scanner's Flatbed.
 */
minContrast: number;

/**
 * Gets the minimum horizontal and vertical scan resolution of the scanner's Flatbed in DPI.
 */
minResolution: Windows$Devices$Scanners$ImageScannerResolution;

/**
 * Gets the minimum scan area in inches. The minimum scan area is the smallest size a document can have in order for a Flatbed to scan it.
 */
minScanArea: Windows$Foundation$Size;

/**
 * Gets the optical scan resolution of the Flatbed scanner in DPI.
 */
opticalResolution: Windows$Devices$Scanners$ImageScannerResolution;

/**
 * Gets or sets the origin coordinates (horizontal and vertical) and dimensions (width and height) of the selected scan area, in inches. This property is ignored when the AutoCroppingMode property is not Disabled.
 */
selectedScanRegion: Windows$Foundation$Rect
}


/**
 * The type of files to scan to.
 */

declare  var Windows$Devices$Scanners$ImageScannerFormat: {|
  +jpeg: 0,// 0
+png: 1,// 1
+deviceIndependentBitmap: 2,// 2
+tiff: 3,// 3
+xps: 4,// 4
+openXps: 5,// 5
+pdf: 6,// 6

|};



/**
 * Represents the result of a preview scan job.
 */
declare class Windows$Devices$Scanners$ImageScannerPreviewResult  {

/**
 * Gets the format of the data for the scan preview. After preview this property is restored to the value before preview.
 */
format: $Values<typeof Windows$Devices$Scanners$ImageScannerFormat>;

/**
 * Gets whether the scan preview was successful.
 */
succeeded: boolean
}


/**
 * Represents the result of a scan job.
 */
declare class Windows$Devices$Scanners$ImageScannerScanResult  {

/**
 * Gets the list of scanned image files that was produced by the completed scan job.
 */
scannedFiles: Windows$Foundation$Collections$IVectorView<Windows$Storage$StorageFile>
}


/**
 * The types of scan source for the scanning device.
 */

declare  var Windows$Devices$Scanners$ImageScannerScanSource: {|
  +default: 0,// 0
+flatbed: 1,// 1
+feeder: 2,// 2
+autoConfigured: 3,// 3

|};



/**
 * Specifies the scan resolution.
 */
declare interface Windows$Devices$Scanners$ImageScannerResolution {

/**
 * The horizontal size.
 */
dpiX: number,

/**
 * The vertical size.
 */
dpiY: number
} 


      declare var npm$namespace$Windows$Devices$Sensors: {
        
        
        ActivitySensorReadingConfidence: typeof Windows$Devices$Sensors$ActivitySensorReadingConfidence,
ActivityType: typeof Windows$Devices$Sensors$ActivityType,
MagnetometerAccuracy: typeof Windows$Devices$Sensors$MagnetometerAccuracy,
PedometerStepKind: typeof Windows$Devices$Sensors$PedometerStepKind,
SensorReadingType: typeof Windows$Devices$Sensors$SensorReadingType,
SensorType: typeof Windows$Devices$Sensors$SensorType,
SimpleOrientation: typeof Windows$Devices$Sensors$SimpleOrientation,
        Accelerometer: typeof Windows$Devices$Sensors$Accelerometer,
AccelerometerReading: typeof Windows$Devices$Sensors$AccelerometerReading,
AccelerometerReadingChangedEventArgs: typeof Windows$Devices$Sensors$AccelerometerReadingChangedEventArgs,
AccelerometerShakenEventArgs: typeof Windows$Devices$Sensors$AccelerometerShakenEventArgs,
ActivitySensor: typeof Windows$Devices$Sensors$ActivitySensor,
ActivitySensorReading: typeof Windows$Devices$Sensors$ActivitySensorReading,
ActivitySensorReadingChangeReport: typeof Windows$Devices$Sensors$ActivitySensorReadingChangeReport,
ActivitySensorReadingChangedEventArgs: typeof Windows$Devices$Sensors$ActivitySensorReadingChangedEventArgs,
ActivitySensorTriggerDetails: typeof Windows$Devices$Sensors$ActivitySensorTriggerDetails,
Altimeter: typeof Windows$Devices$Sensors$Altimeter,
AltimeterReading: typeof Windows$Devices$Sensors$AltimeterReading,
AltimeterReadingChangedEventArgs: typeof Windows$Devices$Sensors$AltimeterReadingChangedEventArgs,
Barometer: typeof Windows$Devices$Sensors$Barometer,
BarometerReading: typeof Windows$Devices$Sensors$BarometerReading,
BarometerReadingChangedEventArgs: typeof Windows$Devices$Sensors$BarometerReadingChangedEventArgs,
Compass: typeof Windows$Devices$Sensors$Compass,
CompassReading: typeof Windows$Devices$Sensors$CompassReading,
CompassReadingChangedEventArgs: typeof Windows$Devices$Sensors$CompassReadingChangedEventArgs,
Gyrometer: typeof Windows$Devices$Sensors$Gyrometer,
GyrometerReading: typeof Windows$Devices$Sensors$GyrometerReading,
GyrometerReadingChangedEventArgs: typeof Windows$Devices$Sensors$GyrometerReadingChangedEventArgs,
Inclinometer: typeof Windows$Devices$Sensors$Inclinometer,
InclinometerReading: typeof Windows$Devices$Sensors$InclinometerReading,
InclinometerReadingChangedEventArgs: typeof Windows$Devices$Sensors$InclinometerReadingChangedEventArgs,
LightSensor: typeof Windows$Devices$Sensors$LightSensor,
LightSensorReading: typeof Windows$Devices$Sensors$LightSensorReading,
LightSensorReadingChangedEventArgs: typeof Windows$Devices$Sensors$LightSensorReadingChangedEventArgs,
Magnetometer: typeof Windows$Devices$Sensors$Magnetometer,
MagnetometerReading: typeof Windows$Devices$Sensors$MagnetometerReading,
MagnetometerReadingChangedEventArgs: typeof Windows$Devices$Sensors$MagnetometerReadingChangedEventArgs,
OrientationSensor: typeof Windows$Devices$Sensors$OrientationSensor,
OrientationSensorReading: typeof Windows$Devices$Sensors$OrientationSensorReading,
OrientationSensorReadingChangedEventArgs: typeof Windows$Devices$Sensors$OrientationSensorReadingChangedEventArgs,
Pedometer: typeof Windows$Devices$Sensors$Pedometer,
PedometerDataThreshold: typeof Windows$Devices$Sensors$PedometerDataThreshold,
PedometerReading: typeof Windows$Devices$Sensors$PedometerReading,
PedometerReadingChangedEventArgs: typeof Windows$Devices$Sensors$PedometerReadingChangedEventArgs,
ProximitySensor: typeof Windows$Devices$Sensors$ProximitySensor,
ProximitySensorDataThreshold: typeof Windows$Devices$Sensors$ProximitySensorDataThreshold,
ProximitySensorDisplayOnOffController: typeof Windows$Devices$Sensors$ProximitySensorDisplayOnOffController,
ProximitySensorReading: typeof Windows$Devices$Sensors$ProximitySensorReading,
ProximitySensorReadingChangedEventArgs: typeof Windows$Devices$Sensors$ProximitySensorReadingChangedEventArgs,
SensorDataThresholdTriggerDetails: typeof Windows$Devices$Sensors$SensorDataThresholdTriggerDetails,
SensorQuaternion: typeof Windows$Devices$Sensors$SensorQuaternion,
SensorRotationMatrix: typeof Windows$Devices$Sensors$SensorRotationMatrix,
SimpleOrientationSensor: typeof Windows$Devices$Sensors$SimpleOrientationSensor,
SimpleOrientationSensorOrientationChangedEventArgs: typeof Windows$Devices$Sensors$SimpleOrientationSensorOrientationChangedEventArgs,
        Custom: typeof npm$namespace$Windows$Devices$Sensors$Custom,
      }

/**
 * Represents an accelerometer sensor.
 */
declare class Windows$Devices$Sensors$Accelerometer  {

/**
 * Returns the default accelerometer.
 * @return The default accelerometer or null if no integrated accelerometers are found.
 */
static getDefault(): Windows$Devices$Sensors$Accelerometer;

/**
 * Gets the device identifier.
 */
deviceId: string;

/**
 * Gets the current accelerometer reading.
 * @return This method has no parameters.
 */
getCurrentReading(): Windows$Devices$Sensors$AccelerometerReading;

/**
 * Gets the maximum number of events that can be batched by the sensor.
 */
maxBatchSize: number;

/**
 * Gets the minimum report interval supported by the accelerometer.
 */
minimumReportInterval: number;

/**
 * Occurs each time the accelerometer reports a new sensor reading.
 */
onreadingchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Accelerometer, Windows$Devices$Sensors$AccelerometerReadingChangedEventArgs>;
addEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Accelerometer, Windows$Devices$Sensors$AccelerometerReadingChangedEventArgs>): void;
removeEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Accelerometer, Windows$Devices$Sensors$AccelerometerReadingChangedEventArgs>): void;

/**
 * Occurs when the accelerometer detects that the PC has been shaken.
 */
onshaken: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Accelerometer, Windows$Devices$Sensors$AccelerometerShakenEventArgs>;
addEventListener(
type: "shaken",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Accelerometer, Windows$Devices$Sensors$AccelerometerShakenEventArgs>): void;
removeEventListener(
type: "shaken",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Accelerometer, Windows$Devices$Sensors$AccelerometerShakenEventArgs>): void;

/**
 * Gets or sets the transformation that needs to be applied to sensor data. Transformations to be applied are tied to the display orientation with which to align the sensor data.
 */
readingTransform: $Values<typeof Windows$Graphics$Display$DisplayOrientations>;

/**
 * Gets or sets the current report interval for the accelerometer.
 */
reportInterval: number;

/**
 * Gets or sets the delay between batches of sensor information.
 */
reportLatency: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents an accelerometer reading.
 */
declare class Windows$Devices$Sensors$AccelerometerReading  {

/**
 * Gets the g-force acceleration along the x-axis.
 */
accelerationX: number;

/**
 * Gets the g-force acceleration along the y-axis.
 */
accelerationY: number;

/**
 * Gets the g-force acceleration along the z-axis.
 */
accelerationZ: number;

/**
 * Gets the time at which the sensor reported the reading.
 */
timestamp: Date
}


/**
 * Provides data for the accelerometer readingchanged event.
 */
declare class Windows$Devices$Sensors$AccelerometerReadingChangedEventArgs  {

/**
 * Gets the most recent accelerometer reading.
 */
reading: Windows$Devices$Sensors$AccelerometerReading
}


/**
 * Provides data for the accelerometer-shaken event.
 */
declare class Windows$Devices$Sensors$AccelerometerShakenEventArgs  {

/**
 * Gets the time at which the sensor reported the shaken event.
 */
timestamp: Date
}


/**
 * Represents an activity sensor that provides the activity and status of a sensor.
 */
declare class Windows$Devices$Sensors$ActivitySensor  {

/**
 * Asynchronously obtains the sensor from its identifier.
 * @param deviceId The sensor identifier.
 * @return Returns the ActivitySensor object from its identifier.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Sensors$ActivitySensor>;

/**
 * Asynchronously obtains the default sensor.
 * @return Asynchronously returns a ActivitySensor object that represents the default sensor.
 */
static getDefaultAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Sensors$ActivitySensor>;

/**
 * Gets the device selector.
 * @return Returns the device selector, if it exists; otherwise, null.
 */
static getDeviceSelector(): string;

/**
 * Asynchronously gets sensor readings from a specific time.
 * @param fromTime The time at which to get sensor readings.
 * @return Asynchronously returns a list of ActivitySensorReading objects that represent info about the sensor.
 */
static getSystemHistoryAsync(
fromTime: Date): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously gets sensor readings from a specific time and duration.
 * @param fromTime The time at which to get sensor readings.
 * @param duration The time span during which to get sensor readings.
 * @return Asynchronously returns a list of ActivitySensorReading objects that represent info about the sensor.
 */
static getSystemHistoryAsync(
fromTime: Date,
duration: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the device identifier.
 */
deviceId: string;

/**
 * Asynchronously gets the current sensor reading.
 * @return Asynchronously returns a ActivitySensorReading object that represents info about the sensor.
 */
getCurrentReadingAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Sensors$ActivitySensorReading>;

/**
 * Gets the minimum report interval supported by the sensor.
 */
minimumReportInterval: number;

/**
 * Occurs each time the sensor reports a new sensor reading.
 */
onreadingchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$ActivitySensor, Windows$Devices$Sensors$ActivitySensorReadingChangedEventArgs>;
addEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$ActivitySensor, Windows$Devices$Sensors$ActivitySensorReadingChangedEventArgs>): void;
removeEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$ActivitySensor, Windows$Devices$Sensors$ActivitySensorReadingChangedEventArgs>): void;

/**
 * Gets the power in milliwatts that the sensor consumes.
 */
powerInMilliwatts: number;

/**
 * Gets the list of activity types that the sensor pledges to perform.
 */
subscribedActivities: Windows$Foundation$Collections$IVector<$Values<typeof Windows$Devices$Sensors$ActivityType>>;

/**
 * Gets the list of activity types that the sensor supports.
 */
supportedActivities: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Devices$Sensors$ActivityType>>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the reading of an activity sensor that provides readings for the sensor.
 */
declare class Windows$Devices$Sensors$ActivitySensorReading  {

/**
 * Gets the activity type for the sensor.
 */
activity: $Values<typeof Windows$Devices$Sensors$ActivityType>;

/**
 * Gets the reading confidence for the sensor.
 */
confidence: $Values<typeof Windows$Devices$Sensors$ActivitySensorReadingConfidence>;

/**
 * Gets the time at which the sensor reported the reading.
 */
timestamp: Date
}


/**
 * Represents data for the sensor trigger.
 */
declare class Windows$Devices$Sensors$ActivitySensorReadingChangeReport  {

/**
 * Gets the reading of the sensor when it's triggered.
 */
reading: Windows$Devices$Sensors$ActivitySensorReading
}


/**
 * Represents data for the readingchanged event of the sensor.
 */
declare class Windows$Devices$Sensors$ActivitySensorReadingChangedEventArgs  {

/**
 * Gets the most recent sensor reading.
 */
reading: Windows$Devices$Sensors$ActivitySensorReading
}


/**
 * Specifies the confidence of a sensor reading.
 */

declare  var Windows$Devices$Sensors$ActivitySensorReadingConfidence: {|
  +high: 0,// 0
+low: 1,// 1

|};



/**
 * Represents details about the sensor triggering.
 */
declare class Windows$Devices$Sensors$ActivitySensorTriggerDetails  {

/**
 * Reads reports about the sensor triggering.
 * @return Returns a list of ActivitySensorReadingChangeReport objects that provides data for the sensor trigger.
 */
readReports(
): Windows$Foundation$Collections$IVectorView<Windows$Devices$Sensors$ActivitySensorReadingChangeReport>
}


/**
 * Specifies activity types of a sensor.
 */

declare  var Windows$Devices$Sensors$ActivityType: {|
  +unknown: 0,// 0
+idle: 1,// 1
+stationary: 2,// 2
+fidgeting: 3,// 3
+walking: 4,// 4
+running: 5,// 5
+inVehicle: 6,// 6
+biking: 7,// 7

|};



/**
 * Provides an interface for an altimetric sensor to measure the relative altitude.
 */
declare class Windows$Devices$Sensors$Altimeter  {

/**
 * Returns the default altimeter sensor.
 * @return The default altimeter.
 */
static getDefault(): Windows$Devices$Sensors$Altimeter;

/**
 * Gets the device identifier.
 */
deviceId: string;

/**
 * Gets the current reading for the altimeter.
 * @return The current alititude reading for this sensor.
 */
getCurrentReading(): Windows$Devices$Sensors$AltimeterReading;

/**
 * The smallest report interval that is supported by this altimeter sensor.
 */
minimumReportInterval: number;

/**
 * Occurs each time the altimeter sensor reports a new value.
 */
onreadingchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Altimeter, Windows$Devices$Sensors$AltimeterReadingChangedEventArgs>;
addEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Altimeter, Windows$Devices$Sensors$AltimeterReadingChangedEventArgs>): void;
removeEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Altimeter, Windows$Devices$Sensors$AltimeterReadingChangedEventArgs>): void;

/**
 * Gets or sets the current report interval for the altimeter.
 */
reportInterval: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents an altimeter reading.
 */
declare class Windows$Devices$Sensors$AltimeterReading  {

/**
 * Gets the current altitude determined by the altimeter sensor.
 */
altitudeChangeInMeters: number;

/**
 * Gets the time for the most recent altimeter reading.
 */
timestamp: Date
}


/**
 * Provides data for the altimeter readingchanged event.
 */
declare class Windows$Devices$Sensors$AltimeterReadingChangedEventArgs  {

/**
 * Gets the most recent barometer reading.
 */
reading: Windows$Devices$Sensors$AltimeterReading
}


/**
 * Provides an interface for a barometric sensor to measure atmospheric pressure.
 */
declare class Windows$Devices$Sensors$Barometer  {

/**
 * Returns the default barometer sensor.
 * @return The default barometer.
 */
static getDefault(): Windows$Devices$Sensors$Barometer;

/**
 * Gets the device identifier.
 */
deviceId: string;

/**
 * Gets the current reading for the barometer.
 * @return The current atmospheric pressure according to this sensor.
 */
getCurrentReading(): Windows$Devices$Sensors$BarometerReading;

/**
 * The smallest report interval that is supported by this barometer sensor.
 */
minimumReportInterval: number;

/**
 * Occurs each time the barometer sensor reports a new value.
 */
onreadingchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Barometer, Windows$Devices$Sensors$BarometerReadingChangedEventArgs>;
addEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Barometer, Windows$Devices$Sensors$BarometerReadingChangedEventArgs>): void;
removeEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Barometer, Windows$Devices$Sensors$BarometerReadingChangedEventArgs>): void;

/**
 * Gets or sets the current report interval for the barometer.
 */
reportInterval: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a barometer reading.
 */
declare class Windows$Devices$Sensors$BarometerReading  {

/**
 * Gets the barometric pressure determined by the barometer sensor.
 */
stationPressureInHectopascals: number;

/**
 * Gets the time for the most recent barometer reading.
 */
timestamp: Date
}


/**
 * Provides data for the barometer readingchanged event.
 */
declare class Windows$Devices$Sensors$BarometerReadingChangedEventArgs  {

/**
 * Gets the most recent barometer reading.
 */
reading: Windows$Devices$Sensors$BarometerReading
}


/**
 * Represents a compass sensor.
 */
declare class Windows$Devices$Sensors$Compass  {

/**
 * Returns the default compass.
 * @return The default compass or null if no integrated compasses are found.
 */
static getDefault(): Windows$Devices$Sensors$Compass;

/**
 * Gets the device identifier.
 */
deviceId: string;

/**
 * Gets the current compass reading.
 * @return The current compass reading.
 */
getCurrentReading(): Windows$Devices$Sensors$CompassReading;

/**
 * Gets the minimum report interval supported by the compass.
 */
minimumReportInterval: number;

/**
 * Occurs each time the compass reports a new sensor reading.
 */
onreadingchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Compass, Windows$Devices$Sensors$CompassReadingChangedEventArgs>;
addEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Compass, Windows$Devices$Sensors$CompassReadingChangedEventArgs>): void;
removeEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Compass, Windows$Devices$Sensors$CompassReadingChangedEventArgs>): void;

/**
 * Gets or sets the transformation that needs to be applied to sensor data. Transformations to be applied are tied to the display orientation with which to align the sensor data.
 */
readingTransform: $Values<typeof Windows$Graphics$Display$DisplayOrientations>;

/**
 * Gets or sets the current report interval for the compass.
 */
reportInterval: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a compass reading.
 */
declare class Windows$Devices$Sensors$CompassReading  {

/**
 * Gets the compass's heading accuracy.
 */
headingAccuracy: $Values<typeof Windows$Devices$Sensors$MagnetometerAccuracy>;

/**
 * Gets the heading in degrees relative to magnetic-north.
 */
headingMagneticNorth: number;

/**
 * Gets the heading in degrees relative to geographic true-north.
 */
headingTrueNorth: number;

/**
 * Gets the time at which the sensor reported the reading.
 */
timestamp: Date
}


/**
 * Provides data for the compass readingchanged event.
 */
declare class Windows$Devices$Sensors$CompassReadingChangedEventArgs  {

/**
 * Gets the current compass reading.
 */
reading: Windows$Devices$Sensors$CompassReading
}


      declare var npm$namespace$Windows$Devices$Sensors$Custom: {
        
        
        
        CustomSensor: typeof Windows$Devices$Sensors$Custom$CustomSensor,
CustomSensorReading: typeof Windows$Devices$Sensors$Custom$CustomSensorReading,
CustomSensorReadingChangedEventArgs: typeof Windows$Devices$Sensors$Custom$CustomSensorReadingChangedEventArgs,
        
      }

/**
 * Represents a custom sensor.
 */
declare class Windows$Devices$Sensors$Custom$CustomSensor  {

/**
 * Asynchronously obtains the sensor from its identifier.
 * @param sensorId The sensor identifier.
 * @return Returns the CustomSensor object from its identifier.
 */
static fromIdAsync(
sensorId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Sensors$Custom$CustomSensor>;

/**
 * Gets the device selector from the given interface identifier.
 * @param interfaceId The interface Guid that is associated with the custom sensor. This Guid is defined and registered by the sensor.
 * @return Returns the device selector, if it exists; otherwise, null.
 */
static getDeviceSelector(interfaceId: string): string;

/**
 * Gets the device identifier of the sensor.
 */
deviceId: string;

/**
 * Gets the current sensor reading.
 * @return The current sensor reading.
 */
getCurrentReading(): Windows$Devices$Sensors$Custom$CustomSensorReading;

/**
 * Gets the minimum report interval that is supported by the sensor.
 */
minimumReportInterval: number;

/**
 * Occurs each time the sensor reports a new sensor reading.
 */
onreadingchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Custom$CustomSensor, Windows$Devices$Sensors$Custom$CustomSensorReadingChangedEventArgs>;
addEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Custom$CustomSensor, Windows$Devices$Sensors$Custom$CustomSensorReadingChangedEventArgs>): void;
removeEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Custom$CustomSensor, Windows$Devices$Sensors$Custom$CustomSensorReadingChangedEventArgs>): void;

/**
 * Gets or sets the current report interval for the sensor.
 */
reportInterval: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a property set of key/value pairs that contain the custom data sent from the sensors driver to the app.
 */
declare class Windows$Devices$Sensors$Custom$CustomSensorReading  {

/**
 * Gets the property set for the sensor.
 */
properties: Windows$Foundation$Collections$IMapView<string, any>;

/**
 * Gets the time at which the sensor reported the reading.
 */
timestamp: Date
}


/**
 * Represents data for the readingchanged event of the custom sensor.
 */
declare class Windows$Devices$Sensors$Custom$CustomSensorReadingChangedEventArgs  {

/**
 * Gets the most recent sensor reading.
 */
reading: Windows$Devices$Sensors$Custom$CustomSensorReading
}


/**
 * Represents a gyrometer sensor.
 */
declare class Windows$Devices$Sensors$Gyrometer  {

/**
 * Returns the default gyrometer.
 * @return The default gyrometer or null if no integrated gyrometers are found.
 */
static getDefault(): Windows$Devices$Sensors$Gyrometer;

/**
 * Gets the device identifier.
 */
deviceId: string;

/**
 * Gets the current gyrometer reading.
 * @return This method has no parameters.
 */
getCurrentReading(): Windows$Devices$Sensors$GyrometerReading;

/**
 * Gets the minimum report interval supported by the gyrometer.
 */
minimumReportInterval: number;

/**
 * Occurs each time the gyrometer reports the current sensor reading.
 */
onreadingchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Gyrometer, Windows$Devices$Sensors$GyrometerReadingChangedEventArgs>;
addEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Gyrometer, Windows$Devices$Sensors$GyrometerReadingChangedEventArgs>): void;
removeEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Gyrometer, Windows$Devices$Sensors$GyrometerReadingChangedEventArgs>): void;

/**
 * Gets or sets the transformation that needs to be applied to sensor data. Transformations to be applied are tied to the display orientation with which to align the sensor data.
 */
readingTransform: $Values<typeof Windows$Graphics$Display$DisplayOrientations>;

/**
 * Gets or sets the current report interval for the gyrometer.
 */
reportInterval: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a gyrometer reading.
 */
declare class Windows$Devices$Sensors$GyrometerReading  {

/**
 * Gets the angular velocity, in degrees per second, about the x-axis.
 */
angularVelocityX: number;

/**
 * Gets the angular velocity, in degrees per second, about the y-axis.
 */
angularVelocityY: number;

/**
 * Gets the angular velocity, in degrees per second, about the z-axis.
 */
angularVelocityZ: number;

/**
 * Gets the time at which the sensor reported the reading.
 */
timestamp: Date
}


/**
 * Provides data for the gyrometer readingchanged event.
 */
declare class Windows$Devices$Sensors$GyrometerReadingChangedEventArgs  {

/**
 * Gets the current gyrometer reading.
 */
reading: Windows$Devices$Sensors$GyrometerReading
}


/**
 * Represents an inclinometer sensor.
 */
declare class Windows$Devices$Sensors$Inclinometer  {

/**
 * Returns the default inclinometer.
 * @return The default inclinometer or null if no inclinometers are found.
 */
static getDefault(): Windows$Devices$Sensors$Inclinometer;

/**
 * Returns the default inclinometer.
 * @return The default inclinometer or null if no inclinometers are found.
 */
static getDefaultForRelativeReadings(): Windows$Devices$Sensors$Inclinometer;

/**
 * Gets the device identifier.
 */
deviceId: string;

/**
 * Gets the current inclinometer reading.
 * @return The current inclinometer reading.
 */
getCurrentReading(): Windows$Devices$Sensors$InclinometerReading;

/**
 * Gets the minimum report interval supported by the inclinometer.
 */
minimumReportInterval: number;

/**
 * Occurs each time the inclinometer reports a new sensor reading.
 */
onreadingchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Inclinometer, Windows$Devices$Sensors$InclinometerReadingChangedEventArgs>;
addEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Inclinometer, Windows$Devices$Sensors$InclinometerReadingChangedEventArgs>): void;
removeEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Inclinometer, Windows$Devices$Sensors$InclinometerReadingChangedEventArgs>): void;

/**
 * Gets or sets the transformation that needs to be applied to sensor data. Transformations to be applied are tied to the display orientation with which to align the sensor data.
 */
readingTransform: $Values<typeof Windows$Graphics$Display$DisplayOrientations>;

/**
 * Gets the sensor reading type.
 */
readingType: $Values<typeof Windows$Devices$Sensors$SensorReadingType>;

/**
 * Gets or sets the current report interval for the inclinometer.
 */
reportInterval: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents an inclinometer reading.
 */
declare class Windows$Devices$Sensors$InclinometerReading  {

/**
 * Gets the rotation in degrees around the x-axis.
 */
pitchDegrees: number;

/**
 * Gets the rotation in degrees around the y-axis.
 */
rollDegrees: number;

/**
 * Gets the time at which the sensor reported the reading.
 */
timestamp: Date;

/**
 * Gets the inclinometer's z-axis accuracy.
 */
yawAccuracy: $Values<typeof Windows$Devices$Sensors$MagnetometerAccuracy>;

/**
 * Gets the rotation in degrees around the z-axis.
 */
yawDegrees: number
}


/**
 * Provides data for the inclinometer readingchanged event.
 */
declare class Windows$Devices$Sensors$InclinometerReadingChangedEventArgs  {

/**
 * Gets the current inclinometer reading.
 */
reading: Windows$Devices$Sensors$InclinometerReading
}


/**
 * Represents an ambient-light sensor.
 */
declare class Windows$Devices$Sensors$LightSensor  {

/**
 * Returns the default ambient-light sensor.
 * @return The default ambient-light sensor or null if no integrated light sensors are found.
 */
static getDefault(): Windows$Devices$Sensors$LightSensor;

/**
 * Gets the device identifier.
 */
deviceId: string;

/**
 * Gets the current ambient-light sensor reading.
 * @return The current ambient-light sensor reading.
 */
getCurrentReading(): Windows$Devices$Sensors$LightSensorReading;

/**
 * Gets the minimum report interval supported by the sensor.
 */
minimumReportInterval: number;

/**
 * Occurs each time the ambient-light sensor reports a new sensor reading.
 */
onreadingchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$LightSensor, Windows$Devices$Sensors$LightSensorReadingChangedEventArgs>;
addEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$LightSensor, Windows$Devices$Sensors$LightSensorReadingChangedEventArgs>): void;
removeEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$LightSensor, Windows$Devices$Sensors$LightSensorReadingChangedEventArgs>): void;

/**
 * Gets or sets the current report interval for the ambient light sensor.
 */
reportInterval: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents an ambient lightsensor reading.
 */
declare class Windows$Devices$Sensors$LightSensorReading  {

/**
 * Gets the illuminance level in lux.
 */
illuminanceInLux: number;

/**
 * Gets the time at which the sensor reported the reading.
 */
timestamp: Date
}


/**
 * Provides data for the ambient-light sensor reading-changed event.
 */
declare class Windows$Devices$Sensors$LightSensorReadingChangedEventArgs  {

/**
 * Gets the current ambient light-sensor reading.
 */
reading: Windows$Devices$Sensors$LightSensorReading
}


/**
 * Represents a magnetic sensor.
 */
declare class Windows$Devices$Sensors$Magnetometer  {

/**
 * Returns the default magnetometer.
 * @return The default magnetometer.
 */
static getDefault(): Windows$Devices$Sensors$Magnetometer;

/**
 * Gets the device identifier.
 */
deviceId: string;

/**
 * Gets the current magnetometer reading.
 * @return The current magnetometer reading.
 */
getCurrentReading(): Windows$Devices$Sensors$MagnetometerReading;

/**
 * Gets the minimum report interval supported by the magnetometer.
 */
minimumReportInterval: number;

/**
 * Occurs each time the compass reports a new sensor reading.
 */
onreadingchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Magnetometer, Windows$Devices$Sensors$MagnetometerReadingChangedEventArgs>;
addEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Magnetometer, Windows$Devices$Sensors$MagnetometerReadingChangedEventArgs>): void;
removeEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Magnetometer, Windows$Devices$Sensors$MagnetometerReadingChangedEventArgs>): void;

/**
 * Gets or sets the transformation that needs to be applied to sensor data. Transformations to be applied are tied to the display orientation with which to align the sensor data.
 */
readingTransform: $Values<typeof Windows$Graphics$Display$DisplayOrientations>;

/**
 * Gets or sets the current report interval for the magnetometer.
 */
reportInterval: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * The sensor's accuracy.
 */

declare  var Windows$Devices$Sensors$MagnetometerAccuracy: {|
  +unknown: 0,// 0
+unreliable: 1,// 1
+approximate: 2,// 2
+high: 3,// 3

|};



/**
 * Represents a magnetometer reading.
 */
declare class Windows$Devices$Sensors$MagnetometerReading  {

/**
 * Gets the magnetometer's directional accuracy.
 */
directionalAccuracy: $Values<typeof Windows$Devices$Sensors$MagnetometerAccuracy>;

/**
 * Gets the magnetic field strength in microteslas along the X axis.
 */
magneticFieldX: number;

/**
 * Gets the magnetic field strength in microteslas along the Y axis.
 */
magneticFieldY: number;

/**
 * Gets the magnetic field strength in microteslas along the Z axis.
 */
magneticFieldZ: number;

/**
 * Gets the time at which the sensor reported the reading.
 */
timestamp: Date
}


/**
 * Provides data for the magnetometer readingchanged event.
 */
declare class Windows$Devices$Sensors$MagnetometerReadingChangedEventArgs  {

/**
 * Gets the current magnetometer reading.
 */
reading: Windows$Devices$Sensors$MagnetometerReading
}


/**
 * Represents an orientation sensor.
 */
declare class Windows$Devices$Sensors$OrientationSensor  {

/**
 * Gets the default orientation sensor.
 * @return The default orientation sensor or null if no orientation sensors are found.
 */
static getDefault(): Windows$Devices$Sensors$OrientationSensor;

/**
 * Gets the default orientation sensor.
 * @return The default orientation sensor or null if no orientation sensors are found.
 */
static getDefaultForRelativeReadings(): Windows$Devices$Sensors$OrientationSensor;

/**
 * Gets the device identifier.
 */
deviceId: string;

/**
 * Gets the current sensor reading.
 * @return The current sensor reading.
 */
getCurrentReading(): Windows$Devices$Sensors$OrientationSensorReading;

/**
 * Gets the minimum report interval supported by the sensor.
 */
minimumReportInterval: number;

/**
 * Occurs each time the orientation sensor reports a new sensor reading.
 */
onreadingchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$OrientationSensor, Windows$Devices$Sensors$OrientationSensorReadingChangedEventArgs>;
addEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$OrientationSensor, Windows$Devices$Sensors$OrientationSensorReadingChangedEventArgs>): void;
removeEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$OrientationSensor, Windows$Devices$Sensors$OrientationSensorReadingChangedEventArgs>): void;

/**
 * Gets or sets the transformation that needs to be applied to sensor data. Transformations to be applied are tied to the display orientation with which to align the sensor data.
 */
readingTransform: $Values<typeof Windows$Graphics$Display$DisplayOrientations>;

/**
 * Gets the sensor reading type.
 */
readingType: $Values<typeof Windows$Devices$Sensors$SensorReadingType>;

/**
 * Gets or sets the report interval supported by the sensor.
 */
reportInterval: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents an orientation-sensor reading.
 */
declare class Windows$Devices$Sensors$OrientationSensorReading  {

/**
 * Gets the Quaternion for the current orientation-sensor reading.
 */
quaternion: Windows$Devices$Sensors$SensorQuaternion;

/**
 * Gets the rotation matrix for the current orientation-sensor reading.
 */
rotationMatrix: Windows$Devices$Sensors$SensorRotationMatrix;

/**
 * Gets the time at which the sensor reported the reading.
 */
timestamp: Date;

/**
 * Gets the orientation sensor's z-axis accuracy.
 */
yawAccuracy: $Values<typeof Windows$Devices$Sensors$MagnetometerAccuracy>
}


/**
 * Provides data for the orientation-sensor reading-changed event.
 */
declare class Windows$Devices$Sensors$OrientationSensorReadingChangedEventArgs  {

/**
 * Gets the current reading which includes a Quaternion, a RotationMatrix, and a timestamp.
 */
reading: Windows$Devices$Sensors$OrientationSensorReading
}


/**
 * Provides an interface for a pedometer to measure the number of steps taken.
 */
declare class Windows$Devices$Sensors$Pedometer  {

/**
 * Obtains the pedometer from its identifier.
 * @param deviceId The sensor identifier.
 * @return Returns the Pedometer object from its identifier.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Sensors$Pedometer>;

/**
 * Asynchronously obtains the default pedometer.
 * @return Asynchronously returns a Pedometer object that represents the default sensor.
 */
static getDefaultAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Sensors$Pedometer>;

/**
 * Gets the device selector.
 * @return Returns the device selector, if it exists; otherwise null.
 */
static getDeviceSelector(): string;
static getReadingsFromTriggerDetails: any;

/**
 * Asynchronously gets sensor readings from a specific time.
 * @param fromTime The time for which you want to retrieve the reading.
 * @return Asynchronously returns a list of PedometerReading objects that represent info about the sensor.
 */
static getSystemHistoryAsync(
fromTime: Date): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously gets pedometer readings from a specific time and duration.
 * @param fromTime The time for which you want to retrieve the reading.
 * @param duration The duration over which you want to retrieve data.
 * @return Asynchronously returns a list of PedometerReading objects that represent info about the sensor.
 */
static getSystemHistoryAsync(
fromTime: Date,
duration: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the device identifier.
 */
deviceId: string;
getCurrentReadings: any;

/**
 * The smallest report interval that is supported by this pedometer.
 */
minimumReportInterval: number;

/**
 * Occurs each time the pedometer reports a new value.
 */
onreadingchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Pedometer, Windows$Devices$Sensors$PedometerReadingChangedEventArgs>;
addEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Pedometer, Windows$Devices$Sensors$PedometerReadingChangedEventArgs>): void;
removeEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$Pedometer, Windows$Devices$Sensors$PedometerReadingChangedEventArgs>): void;

/**
 * Gets the power that the sensor consumes.
 */
powerInMilliwatts: number;

/**
 * Gets or sets the current report interval for the pedometer.
 */
reportInterval: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * A threshold for the Pedometer sensor. When the threshold conditions are met, the sensor trigger will activate.
 */
declare class Windows$Devices$Sensors$PedometerDataThreshold  {

/**
 * Creates a PedometerDataThreshold object.
 * @param sensor The pedometer sensor.
 * @param stepGoal The number of steps before the threshold is exceeded and the background task is activated.
 */
constructor(sensor: Windows$Devices$Sensors$Pedometer, stepGoal: number): this
}


/**
 * Represents a pedometer reading.
 */
declare class Windows$Devices$Sensors$PedometerReading  {

/**
 * Gets the total number of steps taken for this pedometer reading.
 */
cumulativeSteps: number;

/**
 * Gets the amount of time that has elapsed for this pedometer reading.
 */
cumulativeStepsDuration: number;

/**
 * Indicates the type of steps taken for this pedometer reading.
 */
stepKind: $Values<typeof Windows$Devices$Sensors$PedometerStepKind>;

/**
 * Gets the time for the most recent pedometer reading.
 */
timestamp: Date
}


/**
 * Provides data for the pedometer readingchanged event.
 */
declare class Windows$Devices$Sensors$PedometerReadingChangedEventArgs  {

/**
 * Gets the most recent pedometer reading.
 */
reading: Windows$Devices$Sensors$PedometerReading
}


/**
 * The type of step taken according to the pedometer.
 */

declare  var Windows$Devices$Sensors$PedometerStepKind: {|
  +unknown: 0,// 0
+walking: 1,// 1
+running: 2,// 2

|};



/**
 * Provides an interface for a proximity sensor to determine whether or not an object is detected.
 */
declare class Windows$Devices$Sensors$ProximitySensor  {

/**
 * Obtains the proximity sensor from its identifier.
 * @param sensorId The sensor identifier.
 * @return Returns the ProximitySensor object from its identifier.
 */
static fromId(sensorId: string): Windows$Devices$Sensors$ProximitySensor;

/**
 * Gets the device selector.
 * @return Returns the device selector. If no device selector is available, this method returns null.
 */
static getDeviceSelector(): string;

/**
 * Gets readings from the trigger details in background task.
 * @param triggerDetails The trigger details received from the background task.
 * @return The collection of proximity data retrieved from the trigger details.
 */
static getReadingsFromTriggerDetails(
triggerDetails: Windows$Devices$Sensors$SensorDataThresholdTriggerDetails): Windows$Foundation$Collections$IVectorView<Windows$Devices$Sensors$ProximitySensorReading>;

/**
 * Creates a controller responsible for turning the display on or off based on the ProximitySensorReading .
 * @return The controller for the phone display.
 */
createDisplayOnOffController(): Windows$Devices$Sensors$ProximitySensorDisplayOnOffController;

/**
 * Gets the device identifier.
 */
deviceId: string;

/**
 * Gets the current reading for the proximity sensor.
 * @return Indicates whether or not the proximity sensor detects an object, and if so, the distance to that object.
 */
getCurrentReading(): Windows$Devices$Sensors$ProximitySensorReading;

/**
 * The largest distance where the proximity sensor can detect an object.
 */
maxDistanceInMillimeters: number;

/**
 * The shortest distance where the proximity sensor can detect an object.
 */
minDistanceInMillimeters: number;

/**
 * Occurs each time the proximity sensor reports a new value.
 */
onreadingchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$ProximitySensor, Windows$Devices$Sensors$ProximitySensorReadingChangedEventArgs>;
addEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$ProximitySensor, Windows$Devices$Sensors$ProximitySensorReadingChangedEventArgs>): void;
removeEventListener(
type: "readingchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$ProximitySensor, Windows$Devices$Sensors$ProximitySensorReadingChangedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * A threshold for the ProximitySensor . When the threshold conditions are met, the sensor trigger will activate.
 */
declare class Windows$Devices$Sensors$ProximitySensorDataThreshold  {

/**
 * Creates a ProximitySensorDataThreshold object.
 * @param sensor The proximity sensor.
 */
constructor(sensor: Windows$Devices$Sensors$ProximitySensor): this
}


/**
 * Provides a controller responsible for turning on or off the phone display based on the readings from the ProximitySensor .
 */
declare class Windows$Devices$Sensors$ProximitySensorDisplayOnOffController  {

/**
 * Disconnects this ProximitySensorDisplayOnOffController instance from the service and frees all the allocated resources.
 */
close(): void
}


/**
 * Represents a reading from the proximity sensor.
 */
declare class Windows$Devices$Sensors$ProximitySensorReading  {

/**
 * Gets the distance from the proximity sensor to the detected object.
 */
distanceInMillimeters: number;

/**
 * Gets whether or not an object is detected by the proximity sensor.
 */
isDetected: boolean;

/**
 * Gets the time for the most recent proximity sensor reading.
 */
timestamp: Date
}


/**
 * Provides data for the readingchanged event of the proximity sensor.
 */
declare class Windows$Devices$Sensors$ProximitySensorReadingChangedEventArgs  {

/**
 * Gets or sets the most recent proximity sensor reading.
 */
reading: Windows$Devices$Sensors$ProximitySensorReading
}


/**
 * Provides data for what sensor triggered the data threshold monitoring task.
 */
declare class Windows$Devices$Sensors$SensorDataThresholdTriggerDetails  {

/**
 * Gets the device identifier for the device that activated the threshold trigger.
 */
deviceId: string;

/**
 * Gets the type of sensor associated with the threshold trigger.
 */
sensorType: $Values<typeof Windows$Devices$Sensors$SensorType>
}


/**
 * Represents a Quaternion.
 */
declare class Windows$Devices$Sensors$SensorQuaternion  {

/**
 * Gets the w-value of the Quaternion.
 */
w: number;

/**
 * Gets the x-value of the Quaternion.
 */
x: number;

/**
 * Gets the y-value of the Quaternion.
 */
y: number;

/**
 * Gets the z-value of the Quaternion.
 */
z: number
}


/**
 * Specifies the sensor reading type.
 */

declare  var Windows$Devices$Sensors$SensorReadingType: {|
  +absolute: 0,// 0
+relative: 1,// 1

|};



/**
 * Represents a 3x3 rotation matrix.
 */
declare class Windows$Devices$Sensors$SensorRotationMatrix  {

/**
 * Gets the value at row 1, column 1 of the given rotation matrix.
 */
m11: number;

/**
 * Gets the value at row 1, column 2 of the given rotation matrix.
 */
m12: number;

/**
 * Gets the value at row 1, column 3 of the given rotation matrix.
 */
m13: number;

/**
 * Gets the value at row 2, column 1 of the given rotation matrix.
 */
m21: number;

/**
 * Gets the value at row 2, column 2 of the given rotation matrix.
 */
m22: number;

/**
 * Gets the value at row 2, column 3 of the given rotation matrix.
 */
m23: number;

/**
 * Gets the value at row 3, column 1 of the given rotation matrix.
 */
m31: number;

/**
 * Gets the value at row 3, column 2 of the given rotation matrix.
 */
m32: number;

/**
 * Gets the value at row 3, column 3 of the given rotation matrix.
 */
m33: number
}


/**
 * Indicates the type of sensor.
 */

declare  var Windows$Devices$Sensors$SensorType: {|
  +accelerometer: 0,// 0
+activitySensor: 1,// 1
+barometer: 2,// 2
+compass: 3,// 3
+customSensor: 4,// 4
+gyroscope: 5,// 5
+proximitySensor: 6,// 6
+inclinometer: 7,// 7
+lightSensor: 8,// 8
+orientationSensor: 9,// 9
+pedometer: 10,// 10
+relativeInclinometer: 11,// 11
+relativeOrientationSensor: 12,// 12
+simpleOrientationSensor: 13,// 13

|};



/**
 * Indicates the orientation of the device.
 */

declare  var Windows$Devices$Sensors$SimpleOrientation: {|
  +notRotated: 0,// 0
+rotated90DegreesCounterclockwise: 1,// 1
+rotated180DegreesCounterclockwise: 2,// 2
+rotated270DegreesCounterclockwise: 3,// 3
+faceup: 4,// 4
+facedown: 5,// 5

|};



/**
 * Represents a simple orientation sensor.
 */
declare class Windows$Devices$Sensors$SimpleOrientationSensor  {

/**
 * Gets the default simple orientation sensor.
 * @return The default simple orientation sensor or null if no simple orientation sensors are found.
 */
static getDefault(): Windows$Devices$Sensors$SimpleOrientationSensor;

/**
 * Gets the device identifier.
 */
deviceId: string;

/**
 * Gets the default simple orientation sensor.
 * @return The default simple orientation sensor.
 */
getCurrentOrientation(): $Values<typeof Windows$Devices$Sensors$SimpleOrientation>;

/**
 * Occurs each time the simple orientation sensor reports a new sensor reading
 */
onorientationchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$SimpleOrientationSensor, Windows$Devices$Sensors$SimpleOrientationSensorOrientationChangedEventArgs>;
addEventListener(
type: "orientationchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$SimpleOrientationSensor, Windows$Devices$Sensors$SimpleOrientationSensorOrientationChangedEventArgs>): void;
removeEventListener(
type: "orientationchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sensors$SimpleOrientationSensor, Windows$Devices$Sensors$SimpleOrientationSensorOrientationChangedEventArgs>): void;

/**
 * Gets or sets the transformation that needs to be applied to sensor data. Transformations to be applied are tied to the display orientation with which to align the sensor data.
 */
readingTransform: $Values<typeof Windows$Graphics$Display$DisplayOrientations>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the sensor readingchanged event.
 */
declare class Windows$Devices$Sensors$SimpleOrientationSensorOrientationChangedEventArgs  {

/**
 * Gets the current sensor orientation.
 */
orientation: $Values<typeof Windows$Devices$Sensors$SimpleOrientation>;

/**
 * Gets the time of the current sensor reading.
 */
timestamp: Date
}


/**
 * Identifies a threshold for sensor data. When this threshold is crossed, the sensor trigger will activate.
 */
declare type Windows$Devices$Sensors$ISensorDataThreshold = {} & Windows$IInspectable



      declare var npm$namespace$Windows$Devices$SerialCommunication: {
        
        
        SerialError: typeof Windows$Devices$SerialCommunication$SerialError,
SerialHandshake: typeof Windows$Devices$SerialCommunication$SerialHandshake,
SerialParity: typeof Windows$Devices$SerialCommunication$SerialParity,
SerialPinChange: typeof Windows$Devices$SerialCommunication$SerialPinChange,
SerialStopBitCount: typeof Windows$Devices$SerialCommunication$SerialStopBitCount,
        ErrorReceivedEventArgs: typeof Windows$Devices$SerialCommunication$ErrorReceivedEventArgs,
PinChangedEventArgs: typeof Windows$Devices$SerialCommunication$PinChangedEventArgs,
SerialDevice: typeof Windows$Devices$SerialCommunication$SerialDevice,
        
      }

/**
 * Represents the object that is passed as a parameter to the event handler that is invoked when error occurs on the serial port.
 */
declare class Windows$Devices$SerialCommunication$ErrorReceivedEventArgs  {

/**
 * Gets the character type received that caused the event on the serial port.
 */
error: $Values<typeof Windows$Devices$SerialCommunication$SerialError>
}


/**
 * Represents the object that is passed as a parameter to the event handler that is invoked when the state of a signal line changes on the serial port.
 */
declare class Windows$Devices$SerialCommunication$PinChangedEventArgs  {

/**
 * Gets the type of signal change that caused the event on the serial port.
 */
pinChange: $Values<typeof Windows$Devices$SerialCommunication$SerialPinChange>
}


/**
 * Represents a serial port. The object provides methods and properties that an app can use to find the port (in the system).
 */
declare class Windows$Devices$SerialCommunication$SerialDevice  {

/**
 * Starts an asynchronous operation that creates a SerialDevice object.
 * @param deviceId The device instance path of the device. To obtain that value, get the DeviceInformation.Id property value.
 * @return Returns an IAsyncOperation(SerialDevice) object that returns the results of the operation.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$SerialCommunication$SerialDevice>;

/**
 * Gets an Advanced Query Syntax (AQS) string that the app can pass to DeviceInformation.FindAllAsync in order to find a serial device by specifying its port name.
 * @param portName The serial port name. For example, "COM1".
 * @return String formatted as an AQS query.
 */
static getDeviceSelector(portName: string): string;

/**
 * Gets an Advanced Query Syntax (AQS) string that the app can pass to DeviceInformation.FindAllAsync in order to find all serial devices on the system.
 * @return String formatted as an AQS query.
 */
static getDeviceSelector(): string;

/**
 * Gets an Advanced Query Syntax (AQS) string that the app can pass to DeviceInformation.FindAllAsync in order to find a specific Serial-to-USB device by specifying it's VID and PID.
 * @param vendorId Specifies the vendor identifier for the device as assigned by the USB specification committee. Possible values are 0 through 0xffff.
 * @param productId Specifies the product identifier. This value is assigned by the manufacturer and is device-specific. Possible values are 0 through 0xffff.
 * @return String formatted as an AQS query.
 */
static getDeviceSelectorFromUsbVidPid(vendorId: number, productId: number): string;

/**
 * Gets or sets the baud rate.
 */
baudRate: number;

/**
 * Gets or sets the break signal state.
 */
breakSignalState: boolean;

/**
 * Represents the number of bytes received by the last read operation of the input stream.
 */
bytesReceived: number;

/**
 * Gets the state of the Carrier Detect (CD) line.
 */
carrierDetectState: boolean;

/**
 * Gets the state of the Clear-to-Send (CTS) line.
 */
clearToSendState: boolean;

/**
 * Releases the reference to the SerialDevice object that was previously obtained by calling FromIdAsync .
 */
close(): void;

/**
 * The number of data bits in each character value that is transmitted or received, and does not include parity bits or stop bits.
 */
dataBits: number;

/**
 * Gets the state of the Data Set Ready (DSR) signal.
 */
dataSetReadyState: boolean;

/**
 * Gets or sets the handshaking protocol for flow control.
 */
handshake: $Values<typeof Windows$Devices$SerialCommunication$SerialHandshake>;

/**
 * Input stream that contains the data received on the serial port.
 */
inputStream: Windows$Storage$Streams$IInputStream;

/**
 * Gets or sets a value that enables the Data Terminal Ready (DTR) signal.
 */
isDataTerminalReadyEnabled: boolean;

/**
 * Gets or sets a value that enables the Request to Send (RTS) signal.
 */
isRequestToSendEnabled: boolean;

/**
 * Event handler that is invoked when error occurs on the serial port.
 */
onerrorreceived: Windows$Foundation$TypedEventHandler<Windows$Devices$SerialCommunication$SerialDevice, Windows$Devices$SerialCommunication$ErrorReceivedEventArgs>;
addEventListener(
type: "errorreceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$SerialCommunication$SerialDevice, Windows$Devices$SerialCommunication$ErrorReceivedEventArgs>): void;
removeEventListener(
type: "errorreceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$SerialCommunication$SerialDevice, Windows$Devices$SerialCommunication$ErrorReceivedEventArgs>): void;

/**
 * Event handler that is invoked when the state of a signal or line changes on the serial port.
 */
onpinchanged: Windows$Foundation$TypedEventHandler<Windows$Devices$SerialCommunication$SerialDevice, Windows$Devices$SerialCommunication$PinChangedEventArgs>;
addEventListener(
type: "pinchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$SerialCommunication$SerialDevice, Windows$Devices$SerialCommunication$PinChangedEventArgs>): void;
removeEventListener(
type: "pinchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$SerialCommunication$SerialDevice, Windows$Devices$SerialCommunication$PinChangedEventArgs>): void;

/**
 * Gets an output stream to which the app can write data to transmit through the serial port.
 */
outputStream: Windows$Storage$Streams$IOutputStream;

/**
 * Gets or sets the parity bit for error-checking.
 */
parity: $Values<typeof Windows$Devices$SerialCommunication$SerialParity>;

/**
 * Gets the port name for serial communications.
 */
portName: string;

/**
 * Gets or sets the time-out value for a read operation.
 */
readTimeout: number;

/**
 * Gets or sets the standard number of stop bits per byte.
 */
stopBits: $Values<typeof Windows$Devices$SerialCommunication$SerialStopBitCount>;

/**
 * Gets the idProduct field of the USB device descriptor. This value indicates the device-specific product identifier and is assigned by the manufacturer.
 */
usbProductId: number;

/**
 * Gets the idVendor field of the USB device descriptor. The value indicates the vendor identifier for the device as assigned by the USB specification committee.
 */
usbVendorId: number;

/**
 * Gets or sets the time-out value for a write operation.
 */
writeTimeout: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Defines values for error conditions that can occur on the serial port.
 */

declare  var Windows$Devices$SerialCommunication$SerialError: {|
  +frame: 0,// 0
+bufferOverrun: 1,// 1
+receiveFull: 2,// 2
+receiveParity: 3,// 3
+transmitFull: 4,// 4

|};



/**
 * Defines values for hardware and software flow control protocols used in serial communication. The values are used by Handshake property on the SerialDevice object.
 */

declare  var Windows$Devices$SerialCommunication$SerialHandshake: {|
  +none: 0,// 0
+requestToSend: 1,// 1
+xonXOff: 2,// 2
+requestToSendXOnXOff: 3,// 3

|};



/**
 * Defines values for the parity bit for the serial data transmission. The values are used by the Parity property on the SerialDevice object.
 */

declare  var Windows$Devices$SerialCommunication$SerialParity: {|
  +none: 0,// 0
+odd: 1,// 1
+even: 2,// 2
+mark: 3,// 3
+space: 4,// 4

|};



/**
 * Defines values for types of signal state changes on the serial port.
 */

declare  var Windows$Devices$SerialCommunication$SerialPinChange: {|
  +breakSignal: 0,// 0
+carrierDetect: 1,// 1
+clearToSend: 2,// 2
+dataSetReady: 3,// 3
+ringIndicator: 4,// 4

|};



/**
 * Defines values that indicate the number of stop bits used in a transmission. The values are used by the StopBits property on the SerialDevice object.
 */

declare  var Windows$Devices$SerialCommunication$SerialStopBitCount: {|
  +one: 0,// 0
+onePointFive: 1,// 1
+two: 2,// 2

|};



      declare var npm$namespace$Windows$Devices$SmartCards: {
        
        
        SmartCardPinCharacterPolicyOption: typeof Windows$Devices$SmartCards$SmartCardPinCharacterPolicyOption,
SmartCardReaderKind: typeof Windows$Devices$SmartCards$SmartCardReaderKind,
SmartCardReaderStatus: typeof Windows$Devices$SmartCards$SmartCardReaderStatus,
SmartCardStatus: typeof Windows$Devices$SmartCards$SmartCardStatus,
        CardAddedEventArgs: typeof Windows$Devices$SmartCards$CardAddedEventArgs,
CardRemovedEventArgs: typeof Windows$Devices$SmartCards$CardRemovedEventArgs,
SmartCard: typeof Windows$Devices$SmartCards$SmartCard,
SmartCardChallengeContext: typeof Windows$Devices$SmartCards$SmartCardChallengeContext,
SmartCardConnection: typeof Windows$Devices$SmartCards$SmartCardConnection,
SmartCardPinPolicy: typeof Windows$Devices$SmartCards$SmartCardPinPolicy,
SmartCardPinResetDeferral: typeof Windows$Devices$SmartCards$SmartCardPinResetDeferral,
SmartCardPinResetRequest: typeof Windows$Devices$SmartCards$SmartCardPinResetRequest,
SmartCardProvisioning: typeof Windows$Devices$SmartCards$SmartCardProvisioning,
SmartCardReader: typeof Windows$Devices$SmartCards$SmartCardReader,
        
      }

/**
 * Provides data for the CardAdded event.
 */
declare class Windows$Devices$SmartCards$CardAddedEventArgs  {

/**
 * Gets info about the smart card that was inserted into the smart card reader.
 */
smartCard: Windows$Devices$SmartCards$SmartCard
}


/**
 * Provides data for the CardRemoved event.
 */
declare class Windows$Devices$SmartCards$CardRemovedEventArgs  {

/**
 * Gets info about the smart card that was taken out of the smart card reader.
 */
smartCard: Windows$Devices$SmartCards$SmartCard
}


/**
 * Represents info about a smart card.
 */
declare class Windows$Devices$SmartCards$SmartCard  {

/**
 * Establishes a connection to the smart card and returns a SmartCardConnection object representing the connection.
 * @return Asynchronous operation that, when complete, returns the SmartCardConnection object representing the connection.
 */
connectAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$SmartCards$SmartCardConnection>;

/**
 * Returns the smart card's Answer to Reset (ATR), a standard series of bytes that contains info about the smart card's characteristics, behaviors, and state.
 * @return The smart card's ATR byte set.
 */
getAnswerToResetAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>;

/**
 * Returns the smart card's status.
 * @return One of the SmartCardStatus enumeration values, representing the smart card's status.
 */
getStatusAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Devices$SmartCards$SmartCardStatus>>;

/**
 * Gets info about the smart card reader into which the smart card is inserted.
 */
reader: Windows$Devices$SmartCards$SmartCardReader
}


/**
 * Represents a smart card authentication challenge/response operation.
 */
declare class Windows$Devices$SmartCards$SmartCardChallengeContext  {

/**
 * Gets the smart card's challenge value.
 */
challenge: Windows$Storage$Streams$IBuffer;

/**
 * Changes the smart card's admin key (also known as an administrator PIN or unblock PIN).
 * @param response The response to a smart card authentication challenge/response operation.
 * @param newAdministrativeKey The new smart card admin key.
 * @return An asynchronous action that completes after the admin key change attempt is done.
 */
changeAdministrativeKeyAsync(
response: Windows$Storage$Streams$IBuffer,
newAdministrativeKey: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Completes the smart card authentication challenge/response operation and frees associated system resources.
 */
close(): void;

/**
 * Reconfigures an existing, configured smart card with a new response. Optionally, formats the smart card.
 * @param response The new response to a smart card authentication challenge/response operation.
 * @param formatCard True to format the smart card; otherwise false.
 * @return An asynchronous action that completes after the smart card reconfiguration attempt is done.
 */
provisionAsync(
response: Windows$Storage$Streams$IBuffer,
formatCard: boolean): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Reconfigures an existing, configured smart card with a new response and ID. Optionally, formats the smart card.
 * @param response The new response to a smart card authentication challenge/response operation.
 * @param formatCard True to format the smart card; otherwise false.
 * @param newCardId The new smart card ID.
 * @return An asynchronous action that completes after the smart card reconfiguration attempt is done.
 */
provisionAsync(
response: Windows$Storage$Streams$IBuffer,
formatCard: boolean,
newCardId: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Verifies the response to the smart card challenge request.
 * @param response The response to the smart card challenge request.
 * @return After the verification attempt is done, true if the response was successfully verified; otherwise false.
 */
verifyResponseAsync(
response: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>
}


/**
 * Represents a connection to a smart card.
 */
declare class Windows$Devices$SmartCards$SmartCardConnection  {

/**
 * Completes the smart card authentication challenge/response operation and frees associated system resources.
 */
close(): void;

/**
 * Asynchronously transmits the supplied application protocol data unit (APDU) command and returns the response.
 * @param command The APDU command to transmit to the smart card.
 * @return An asynchronous operation that, when completed, returns the response to the command that was transmitted.
 */
transmitAsync(
command: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>
}


/**
 * Specifies the rules for characters in a smart card personal identification number (PIN).
 */

declare  var Windows$Devices$SmartCards$SmartCardPinCharacterPolicyOption: {|
  +allow: 0,// 0
+requireAtLeastOne: 1,// 1
+disallow: 2,// 2

|};



/**
 * Represents a set of personal identification number (PIN) rules on a Trusted Platform Module (TPM) virtual smart card.
 */
declare class Windows$Devices$SmartCards$SmartCardPinPolicy  {

/**
 * Creates and initializes a new instance of a set of personal identification number (PIN) rules on a Trusted Platform Module (TPM) virtual smart card.
 */
constructor(): this;

/**
 * Gets or sets whether number characters are allowed for a personal identification number (PIN) on a Trusted Platform Module (TPM) virtual smart card.
 */
digits: $Values<typeof Windows$Devices$SmartCards$SmartCardPinCharacterPolicyOption>;

/**
 * Gets or sets whether lowercase letter characters are allowed for a personal identification number (PIN) on a Trusted Platform Module (TPM) virtual smart card.
 */
lowercaseLetters: $Values<typeof Windows$Devices$SmartCards$SmartCardPinCharacterPolicyOption>;

/**
 * Gets or sets the maximum character length for a personal identification number (PIN) on a Trusted Platform Module (TPM) virtual smart card.
 */
maxLength: number;

/**
 * Gets or sets the minimum character length for a personal identification number (PIN) on a Trusted Platform Module (TPM) virtual smart card.
 */
minLength: number;

/**
 * Gets or sets whether special characters are allowed for a personal identification number (PIN) on a Trusted Platform Module (TPM) virtual smart card.
 */
specialCharacters: $Values<typeof Windows$Devices$SmartCards$SmartCardPinCharacterPolicyOption>;

/**
 * Gets or sets whether uppercase letter characters are allowed for a personal identification number (PIN) on a Trusted Platform Module (TPM) virtual smart card.
 */
uppercaseLetters: $Values<typeof Windows$Devices$SmartCards$SmartCardPinCharacterPolicyOption>
}


/**
 * Represents a wait time for a requested smart card personal identification number (PIN) reset.
 */
declare class Windows$Devices$SmartCards$SmartCardPinResetDeferral  {

/**
 * Returns a wait time completion for a smart card personal identification number (PIN) reset.
 */
complete(): void
}


/**
 * Represents a smart card personal identification number (PIN) reset request.
 */
declare class Windows$Devices$SmartCards$SmartCardPinResetRequest  {

/**
 * Gets the smart card's challenge value.
 */
challenge: Windows$Storage$Streams$IBuffer;

/**
 * Gets the length of time to wait before requesting the smart card personal identification number (PIN) reset.
 */
deadline: Date;

/**
 * Gets an instance of a wait time for a requested smart card personal identification number (PIN) reset.
 * @return An instance of a wait time for a requested smart card PIN reset.
 */
getDeferral(): Windows$Devices$SmartCards$SmartCardPinResetDeferral;

/**
 * Sets the response to a smart card authentication challenge/response operation.
 * @param response The response to a smart card authentication challenge/response operation.
 */
setResponse(response: Windows$Storage$Streams$IBuffer): void
}


/**
 * Represents info about, and operations for, configuring smart cards.
 */
declare class Windows$Devices$SmartCards$SmartCardProvisioning  {

/**
 * Returns a smart card to be configured.
 * @param card The specified smart card.
 * @return An instance of SmartCardProvisioning , representing the smart card to be configured.
 */
static fromSmartCardAsync(
card: Windows$Devices$SmartCards$SmartCard): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$SmartCards$SmartCardProvisioning>;
static requestAttestedVirtualSmartCardCreationAsync: any;

/**
 * Creates a Trusted Platform Module (TPM) virtual smart card with a given human-readable name, admin key, personal identification number (PIN) rules set, and ID.
 * @param friendlyName The smart card's human-readable name.
 * @param administrativeKey The smart card's admin key (also known as an administrator PIN or unblock PIN).
 * @param pinPolicy The smart card's PIN rules set.
 * @param cardId The smart card's ID.
 * @return After the operation completes, returns an instance of SmartCardProvisioning , representing the configured TPM virtual smart card.
 */
static requestVirtualSmartCardCreationAsync(
friendlyName: string,
administrativeKey: Windows$Storage$Streams$IBuffer,
pinPolicy: Windows$Devices$SmartCards$SmartCardPinPolicy,
cardId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$SmartCards$SmartCardProvisioning>;

/**
 * Creates a Trusted Platform Module (TPM) virtual smart card with a given human-readable name, admin key, and personal identification number (PIN) rules set.
 * @param friendlyName The smart card's human-readable name.
 * @param administrativeKey The smart card's admin key (also known as an administrator PIN or unblock PIN).
 * @param pinPolicy The smart card's PIN rules set.
 * @return After the operation completes, returns an instance of SmartCardProvisioning , representing the configured TPM virtual smart card.
 */
static requestVirtualSmartCardCreationAsync(
friendlyName: string,
administrativeKey: Windows$Storage$Streams$IBuffer,
pinPolicy: Windows$Devices$SmartCards$SmartCardPinPolicy): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$SmartCards$SmartCardProvisioning>;

/**
 * Deletes a Trusted Platform Module (TPM) virtual smart card.
 * @param card The TPM virtual smart card to delete.
 * @return After the deletion attempt completes, returns true if the TPM virtual smart card was successfully deleted; otherwise false.
 */
static requestVirtualSmartCardDeletionAsync(
card: Windows$Devices$SmartCards$SmartCard): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;
getAuthorityKeyContainerNameAsync: any;

/**
 * Returns a smart card's authentication challenge/response context.
 * @return After the asynchronous operation completes, returns an instance of SmartCardChalllengeContext , representing the smart card's authentication challenge/response context.
 */
getChallengeContextAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$SmartCards$SmartCardChallengeContext>;

/**
 * Returns the smart card's ID.
 * @return After the asynchronous operation completes, returns the smart card's ID.
 */
getIdAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Returns the smart card's minidriver name.
 * @return After the asynchronous operation completes, returns the smart card's name.
 */
getNameAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Changes a smart card's personal identification number (PIN).
 * @return After the smart card PIN change attempt completes, returns true if the smart card's PIN was successfully changed; otherwise false.
 */
requestPinChangeAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Resets a smart card's personal identification number (PIN).
 * @param handler The method that handles the smart card PIN reset.
 * @return After the smart card PIN reset attempt completes, returns true if the smart card's PIN was successfully reset; otherwise false.
 */
requestPinResetAsync(
handler: Windows$Devices$SmartCards$SmartCardPinResetHandler): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets the configured smart card.
 */
smartCard: Windows$Devices$SmartCards$SmartCard
}


/**
 * Represents info about a smart card reader.
 */
declare class Windows$Devices$SmartCards$SmartCardReader  {

/**
 * Returns a smart card reader that matches the specified device ID.
 * @param deviceId The smart card reader's device ID.
 * @return The matching smart card reader.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$SmartCards$SmartCardReader>;

/**
 * Returns an Advanced Query Syntax (AQS) string representing a set of a specific type of smart card readers connected to the device. This string is passed to the FindAllAsync method to enumerate the given set of smart card readers.
 * @param kind One of the enumeration values, representing a specific smart card reader type.
 * @return The Advanced Query Syntax (AQS) string representing a set of the specified type of smart card readers connected to the device.
 */
static getDeviceSelector(kind: $Values<typeof Windows$Devices$SmartCards$SmartCardReaderKind>): string;

/**
 * Returns an Advanced Query Syntax (AQS) string representing all smart card readers connected to the device. This string is passed to the FindAllAsync method to enumerate the given set of smart card readers.
 * @return The Advanced Query Syntax (AQS) string representing all smart card readers connected to the device.
 */
static getDeviceSelector(): string;

/**
 * Gets the smart card reader's device ID.
 */
deviceId: string;

/**
 * Returns a list of info about all smart cards that are connected to the smart card reader.
 * @return After the operation completes, returns the list of info about all smart cards that are connected to the smart card reader.
 */
findAllCardsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Returns the smart card reader's status.
 * @return After the status request completes, returns one of the SmartCardReaderStatus enumeration values, representing the smart card reader's status.
 */
getStatusAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Devices$SmartCards$SmartCardReaderStatus>>;

/**
 * Gets the smart card reader's type.
 */
kind: $Values<typeof Windows$Devices$SmartCards$SmartCardReaderKind>;

/**
 * Gets the smart card reader's device name.
 */
name: string;

/**
 * Occurs when a smart card is inserted into the smart card reader or tapped on an NFC reader.
 */
oncardadded: Windows$Foundation$TypedEventHandler<Windows$Devices$SmartCards$SmartCardReader, Windows$Devices$SmartCards$CardAddedEventArgs>;
addEventListener(
type: "cardadded",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$SmartCards$SmartCardReader, Windows$Devices$SmartCards$CardAddedEventArgs>): void;
removeEventListener(
type: "cardadded",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$SmartCards$SmartCardReader, Windows$Devices$SmartCards$CardAddedEventArgs>): void;

/**
 * Occurs when a smart card is taken out of the smart card reader.
 */
oncardremoved: Windows$Foundation$TypedEventHandler<Windows$Devices$SmartCards$SmartCardReader, Windows$Devices$SmartCards$CardRemovedEventArgs>;
addEventListener(
type: "cardremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$SmartCards$SmartCardReader, Windows$Devices$SmartCards$CardRemovedEventArgs>): void;
removeEventListener(
type: "cardremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$SmartCards$SmartCardReader, Windows$Devices$SmartCards$CardRemovedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the smart card reader's type.
 */

declare  var Windows$Devices$SmartCards$SmartCardReaderKind: {|
  +any: 0,// 0
+generic: 1,// 1
+tpm: 2,// 2
+nfc: 3,// 3
+uicc: 4,// 4

|};



/**
 * Specifies the smart card reader's status.
 */

declare  var Windows$Devices$SmartCards$SmartCardReaderStatus: {|
  +disconnected: 0,// 0
+ready: 1,// 1
+exclusive: 2,// 2

|};



/**
 * Specifies the smart card's status.
 */

declare  var Windows$Devices$SmartCards$SmartCardStatus: {|
  +disconnected: 0,// 0
+ready: 1,// 1
+shared: 2,// 2
+exclusive: 3,// 3
+unresponsive: 4,// 4

|};



/**
 * Represents a method that handles a smart card personal identification number (PIN) reset.
 */
declare type Windows$Devices$SmartCards$SmartCardPinResetHandler = (
sender: Windows$Devices$SmartCards$SmartCardProvisioning,
request: Windows$Devices$SmartCards$SmartCardPinResetRequest) => void;


      declare var npm$namespace$Windows$Devices$Sms: {
        
        
        CellularClass: typeof Windows$Devices$Sms$CellularClass,
SmsBroadcastType: typeof Windows$Devices$Sms$SmsBroadcastType,
SmsDataFormat: typeof Windows$Devices$Sms$SmsDataFormat,
SmsDeviceStatus: typeof Windows$Devices$Sms$SmsDeviceStatus,
SmsEncoding: typeof Windows$Devices$Sms$SmsEncoding,
SmsFilterActionType: typeof Windows$Devices$Sms$SmsFilterActionType,
SmsGeographicalScope: typeof Windows$Devices$Sms$SmsGeographicalScope,
SmsMessageClass: typeof Windows$Devices$Sms$SmsMessageClass,
SmsMessageFilter: typeof Windows$Devices$Sms$SmsMessageFilter,
SmsMessageType: typeof Windows$Devices$Sms$SmsMessageType,
SmsModemErrorCode: typeof Windows$Devices$Sms$SmsModemErrorCode,
        DeleteSmsMessageOperation: typeof Windows$Devices$Sms$DeleteSmsMessageOperation,
DeleteSmsMessagesOperation: typeof Windows$Devices$Sms$DeleteSmsMessagesOperation,
GetSmsDeviceOperation: typeof Windows$Devices$Sms$GetSmsDeviceOperation,
GetSmsMessageOperation: typeof Windows$Devices$Sms$GetSmsMessageOperation,
GetSmsMessagesOperation: typeof Windows$Devices$Sms$GetSmsMessagesOperation,
SendSmsMessageOperation: typeof Windows$Devices$Sms$SendSmsMessageOperation,
SmsAppMessage: typeof Windows$Devices$Sms$SmsAppMessage,
SmsBinaryMessage: typeof Windows$Devices$Sms$SmsBinaryMessage,
SmsBroadcastMessage: typeof Windows$Devices$Sms$SmsBroadcastMessage,
SmsDevice: typeof Windows$Devices$Sms$SmsDevice,
SmsDevice2: typeof Windows$Devices$Sms$SmsDevice2,
SmsDeviceMessageStore: typeof Windows$Devices$Sms$SmsDeviceMessageStore,
SmsFilterRule: typeof Windows$Devices$Sms$SmsFilterRule,
SmsFilterRules: typeof Windows$Devices$Sms$SmsFilterRules,
SmsMessageReceivedEventArgs: typeof Windows$Devices$Sms$SmsMessageReceivedEventArgs,
SmsMessageReceivedTriggerDetails: typeof Windows$Devices$Sms$SmsMessageReceivedTriggerDetails,
SmsMessageRegistration: typeof Windows$Devices$Sms$SmsMessageRegistration,
SmsReceivedEventDetails: typeof Windows$Devices$Sms$SmsReceivedEventDetails,
SmsSendMessageResult: typeof Windows$Devices$Sms$SmsSendMessageResult,
SmsStatusMessage: typeof Windows$Devices$Sms$SmsStatusMessage,
SmsTextMessage: typeof Windows$Devices$Sms$SmsTextMessage,
SmsTextMessage2: typeof Windows$Devices$Sms$SmsTextMessage2,
SmsVoicemailMessage: typeof Windows$Devices$Sms$SmsVoicemailMessage,
SmsWapMessage: typeof Windows$Devices$Sms$SmsWapMessage,
        
      }

/**
 * This enumerated type defines the type of radio standard in a device.
 */

declare  var Windows$Devices$Sms$CellularClass: {|
  +none: 0,// 0
+gsm: 1,// 1
+cdma: 2,// 2

|};



/**
 * Enables start, track, and end an asynchronous message delete operation for a single message.
 */
declare class Windows$Devices$Sms$DeleteSmsMessageOperation  {

/**
 * Cancels the asynchronous SMS message delete operation.
 */
cancel(): void;

/**
 * Closes the asynchronous SMS message delete operation.
 */
close(): void;

/**
 * Specifies whether the asynchronous SMS message delete operation has completed or not.
 */
completed: Windows$Foundation$AsyncActionCompletedHandler;

/**
 * Specifies the error code for the asynchronous SMS message delete operation.
 */
errorCode: Windows$WinRTError;

/**
 * Retrieves the result of the asynchronous SMS message delete operation.
 */
getResults(): void;

/**
 * Specifies the ID of the asynchronous SMS message delete operation.
 */
id: number;

/**
 * Specifies the status of the asynchronous SMS message delete operation.
 */
status: $Values<typeof Windows$Foundation$AsyncStatus>
}


/**
 * Enables start, track, and end asynchronous SMS message delete operations for multiple messages.
 */
declare class Windows$Devices$Sms$DeleteSmsMessagesOperation  {

/**
 * Cancels the asynchronous SMS message delete operations.
 */
cancel(): void;

/**
 * Closes the asynchronous SMS message delete operations.
 */
close(): void;

/**
 * Specifies whether the asynchronous SMS message delete operations have completed or not.
 */
completed: Windows$Foundation$AsyncActionCompletedHandler;

/**
 * Specifies the error code for the asynchronous SMS message delete operations.
 */
errorCode: Windows$WinRTError;

/**
 * Retrieves the result of the asynchronous message operations.
 */
getResults(): void;

/**
 * Specifies the ID of the asynchronous SMS message delete operations.
 */
id: number;

/**
 * Specifies the status of the asynchronous SMS message delete operations.
 */
status: $Values<typeof Windows$Foundation$AsyncStatus>
}


/**
 * Retrieves an SmsDevice object asynchronously.
 */
declare class Windows$Devices$Sms$GetSmsDeviceOperation  {

/**
 * Cancels the asynchronous SmsDevice object retrieval.
 */
cancel(): void;

/**
 * Closes the asynchronous SmsDevice object retrieval operation.
 */
close(): void;

/**
 * Specifies whether the asynchronous SmsDevice object retrieval operation has completed or not.
 */
completed: Windows$Foundation$AsyncOperationCompletedHandler<Windows$Devices$Sms$SmsDevice>;

/**
 * Specifies the error code for the asynchronous SmsDevice object retrieval operation
 */
errorCode: Windows$WinRTError;

/**
 * Gets the results of the asynchronous SmsDevice object retrieval operation.
 * @return A reference to an SmsDevice object.
 */
getResults(): Windows$Devices$Sms$SmsDevice;

/**
 * Specifies the ID of the asynchronous SmsDevice object retrieval operation.
 */
id: number;

/**
 * Specifies the status of the asynchronous SmsDevice object retrieval operation.
 */
status: $Values<typeof Windows$Foundation$AsyncStatus>
}


/**
 * Supports the retrieval of a message from the SMS message store.
 */
declare class Windows$Devices$Sms$GetSmsMessageOperation  {

/**
 * Cancels the asynchronous SMS message retrieval operation.
 */
cancel(): void;

/**
 * Closes the asynchronous SMS message retrieval operation.
 */
close(): void;

/**
 * A handler for the completed event of an asynchronous SMS message retrieval operation.
 */
completed: Windows$Foundation$AsyncOperationCompletedHandler<Windows$Devices$Sms$ISmsMessage>;

/**
 * Specifies the error code for the asynchronous SMS message retrieval operation.
 */
errorCode: Windows$WinRTError;

/**
 * Retrieves the result of the asynchronous SMS message retrieval operation.
 * @return An interface that accesses the retrieved message.
 */
getResults(): Windows$Devices$Sms$ISmsMessage;

/**
 * Specifies the ID of the asynchronous SMS message retrieval operation.
 */
id: number;

/**
 * Specifies the status of the asynchronous SMS message retrieval operation.
 */
status: $Values<typeof Windows$Foundation$AsyncStatus>
}


/**
 * Supports the retrieval of messages.
 */
declare class Windows$Devices$Sms$GetSmsMessagesOperation  {

/**
 * Cancels the asynchronous operations.
 */
cancel(): void;

/**
 * Closes the asynchronous operations.
 */
close(): void;

/**
 * Specifies whether the asynchronous message retrieval operation has completed or not.
 */
completed: Windows$Foundation$AsyncOperationWithProgressCompletedHandler<Windows$Foundation$Collections$IVectorView<any>, number>;

/**
 * Specifies the error code for the asynchronous message operation.
 */
errorCode: Windows$WinRTError;

/**
 * Retrieves the result of the asynchronous message retrieval operation.
 * @return A reference to the SMS messages retrieved.
 */
getResults(): Windows$Foundation$Collections$IVectorView<Windows$Devices$Sms$ISmsMessage>;

/**
 * Indicates the ID of the asynchronous message operation.
 */
id: number;

/**
 * Specifies the progress status of the asynchronous message operation.
 */
progress: Windows$Foundation$AsyncOperationProgressHandler<Windows$Foundation$Collections$IVectorView<any>, number>;

/**
 * Specifies the status of the asynchronous message operations.
 */
status: $Values<typeof Windows$Foundation$AsyncStatus>
}


/**
 * Enables the sending of a message.
 */
declare class Windows$Devices$Sms$SendSmsMessageOperation  {

/**
 * Cancels the asynchronous operation.
 */
cancel(): void;

/**
 * Closes the asynchronous operation.
 */
close(): void;

/**
 * A handler for the completed event of an asynchronous action.
 */
completed: Windows$Foundation$AsyncActionCompletedHandler;

/**
 * Specifies the error code for the asynchronous message operation.
 */
errorCode: Windows$WinRTError;

/**
 * Retrieves the result of the asynchronous operation.
 */
getResults(): void;

/**
 * Indicates the ID of the asynchronous message operation.
 */
id: number;

/**
 * Specifies the status of the asynchronous message operation.
 */
status: $Values<typeof Windows$Foundation$AsyncStatus>
}


/**
 * The interface for manipulating an SMS Application message. Application messages are those which cannot be characterized as any other message type.
 */
declare class Windows$Devices$Sms$SmsAppMessage  {

/**
 * Constructor. Used to create an SmsAppMessage prior to sending it.
 */
constructor(): this;

/**
 * Reads or writes the binary part of the Application message.
 */
binaryBody: Windows$Storage$Streams$IBuffer;

/**
 * The plain text body of the message.
 */
body: string;

/**
 * The number to be dialed in reply to a received SMS message.
 */
callbackNumber: string;

/**
 * The class of the cellular device that received the message.
 */
cellularClass: $Values<typeof Windows$Devices$Sms$CellularClass>;

/**
 * The device ID of the device that received the message.
 */
deviceId: string;

/**
 * The encoding used to send the message.
 */
encoding: $Values<typeof Windows$Devices$Sms$SmsEncoding>;

/**
 * The telephone number of the sender of the message.
 */
from: string;

/**
 * Indicates whether an SMS delivery status report was sent by the SMSC.
 */
isDeliveryNotificationEnabled: boolean;

/**
 * The message class of the message.
 */
messageClass: $Values<typeof Windows$Devices$Sms$SmsMessageClass>;

/**
 * The message type of the message.
 */
messageType: $Values<typeof Windows$Devices$Sms$SmsMessageType>;

/**
 * The port number of the message.
 */
portNumber: number;

/**
 * The Protocol identifier for the message.
 */
protocolId: number;

/**
 * The retry attempt count for the message.
 */
retryAttemptCount: number;

/**
 * Gets the ICCID (Integrated Circuit Card Identifier) of the SIM that received the message.
 */
simIccId: string;

/**
 * The Teleservice identifier for the message.
 */
teleserviceId: number;

/**
 * The timestamp of the message.
 */
timestamp: Date;

/**
 * The telephone number of the recipient of this message.
 */
to: string
}


/**
 * Represents an SMS message in raw PDU format. The data format differs depending on whether the message format (indicated by the value of the Format property) is GSM or CDMA.
 */
declare class Windows$Devices$Sms$SmsBinaryMessage  {

/**
 * Creates an instance of the SmsBinaryMessage class.
 */
constructor(): this;

/**
 * Retrieves the detected protocol description unit (PDU) format of this message.
 */
format: $Values<typeof Windows$Devices$Sms$SmsDataFormat>;

/**
 * Returns the raw buffer of the message in binary protocol description unit (PDU) format as a byte array.
 * @return A byte array representing message data. If there is no message data, the returned array is empty.
 */
getData(): number[];

/**
 * Indicates the ID of the asynchronous message operation.
 */
id: number;

/**
 * Returns the message class, as determined by the operator's message network. The two most common classes are None (normal message) or Class0 (special operator message, such as a roaming warning that must be shown immediately to the user). A typical client for end-user messages ignores Class0 messages.
 */
messageClass: $Values<typeof Windows$Devices$Sms$SmsMessageClass>;

/**
 * Specifies the raw binary payload of the SMS message. It should be formatted according to the protocol description unit (PDU) standard.
 * @param value A byte array representing message data. If there is no message data, the returned array is empty.
 */
setData(value: number[]): void
}


/**
 * Represents a broadcast SMS message.
 */
declare class Windows$Devices$Sms$SmsBroadcastMessage  {

/**
 * Gets the body of the broadcast SMS message.
 */
body: string;

/**
 * Gets the type of this broadcast SMS message.
 */
broadcastType: $Values<typeof Windows$Devices$Sms$SmsBroadcastType>;

/**
 * Gets the cellular class of this broadcast message.
 */
cellularClass: $Values<typeof Windows$Devices$Sms$CellularClass>;

/**
 * Gets the channel associated with the broadcast SMS message.
 */
channel: number;

/**
 * Gets the device ID of the device that received the broadcast SMS message.
 */
deviceId: string;

/**
 * Gets the geographical scope associated with this broadcast SMS message.
 */
geographicalScope: $Values<typeof Windows$Devices$Sms$SmsGeographicalScope>;

/**
 * True when the broadcast SMS message is an emergency alert.
 */
isEmergencyAlert: boolean;

/**
 * True when a user popup is requested by this broadcast SMS message.
 */
isUserPopupRequested: boolean;

/**
 * Gets the message class associated with this broadcast SMS message.
 */
messageClass: $Values<typeof Windows$Devices$Sms$SmsMessageClass>;

/**
 * Gets a code value associated with this broadcast SMS message.
 */
messageCode: number;

/**
 * Gets the message type of the broadcast SMS message.
 */
messageType: $Values<typeof Windows$Devices$Sms$SmsMessageType>;

/**
 * Gets the ICCID (Integrated Circuit Card Identifier) of the SIM that received the message.
 */
simIccId: string;

/**
 * Gets the timestamp of the broadcast SMS message.
 */
timestamp: Date;

/**
 * Gets the recipient phone number of the broadcast SMS message.
 */
to: string;

/**
 * Gets the update number associated with this broadcast SMS message.
 */
updateNumber: number
}


/**
 * Values that describe the type of a broadcast (emergency alert) message.
 */

declare  var Windows$Devices$Sms$SmsBroadcastType: {|
  +other: 0,// 0
+cmasPresidential: 1,// 1
+cmasExtreme: 2,// 2
+cmasSevere: 3,// 3
+cmasAmber: 4,// 4
+cmasTest: 5,// 5
+euAlert1: 6,// 6
+euAlert2: 7,// 7
+euAlert3: 8,// 8
+euAlertAmber: 9,// 9
+euAlertInfo: 10,// 10
+etwsEarthquake: 11,// 11
+etwsTsunami: 12,// 12
+etwsTsunamiAndEarthquake: 13,// 13
+latAlertLocal: 14,// 14

|};



/**
 * This enumerated type identifies the format of a given protocol description unit (PDU) buffer.
 */

declare  var Windows$Devices$Sms$SmsDataFormat: {|
  +unknown: 0,// 0
+cdmaSubmit: 1,// 1
+gsmSubmit: 2,// 2
+cdmaDeliver: 3,// 3
+gsmDeliver: 4,// 4

|};



/**
 * Supports the operation of a mobile broadband SMS device.
 */
declare class Windows$Devices$Sms$SmsDevice  {

/**
 * Creates an instance of SmsDevice for the device that received the SMS message.
 * @param deviceId A string representation of the DeviceInformation ID of the SMS device that received the SMS message.
 * @return The SMS device operation object.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Sms$SmsDevice>;

/**
 * Creates an instance of SmsDevice for the specified Mobile Broadband network account ID.
 * @param networkAccountId The Mobile Broadband network account ID to use to select the corresponding mobile broadband device to use for the SMS device
 * @return When this method completes, it returns the SmsDevice for the specified Mobile Broadband network account ID.
 */
static fromNetworkAccountIdAsync(
networkAccountId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Sms$SmsDevice>;

/**
 * Creates an instance of an SmsDevice object associated with the default SMS device. Because the device might be busy, the operation executes asynchronously. The asynchronous operation object returns immediately.
 * @return A reference to an IAsyncOperation(SmsDevice) object that supports asynchronous SmsDevice object retrieval.
 */
static getDefaultAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Sms$SmsDevice>;

/**
 * Retrieves the class selection string that can be used to enumerate SMS devices.
 * @return A reference to an Advanced Query Syntax (AQS) string that identifies an SMS device.
 */
static getDeviceSelector(): string;

/**
 * Returns the phone number associated with the SMS device. The phone number can be used to associate incoming messages with the account and possibly an external storage mechanism such as an account inbox.
 */
accountPhoneNumber: string;

/**
 * Estimates the transmitted message length of the specified text message. The estimate can be useful to clients who want to give an indication of how many messages will be sent on the network to carry the text of the full message.
 * @param message A reference to the SMS text message to measure.
 * @return A reference to an SmsEncodedLength structure that is populated with the length information.
 */
calculateLength(
message: Windows$Devices$Sms$SmsTextMessage): Windows$Devices$Sms$SmsEncodedLength;

/**
 * Returns the cellular class of the SMS device. The class can be used to determine which encodings are appropriate or which device limitations are in effect.
 */
cellularClass: $Values<typeof Windows$Devices$Sms$CellularClass>;

/**
 * Returns the SMS device's status, which indicates whether the device is ready, or not. It also indicates what type of problem exists if the device is not ready.
 */
deviceStatus: $Values<typeof Windows$Devices$Sms$SmsDeviceStatus>;

/**
 * Accesses the on-device message store. The store holds messages until a client can retrieve them. On some devices, for example, the store may correspond to the SIM storage for SMS messages.
 */
messageStore: Windows$Devices$Sms$SmsDeviceMessageStore;

/**
 * Sets an event handler to be called when the status of the SMS device changes.
 */
onsmsdevicestatuschanged: Windows$Devices$Sms$SmsDeviceStatusChangedEventHandler;
addEventListener(
type: "smsdevicestatuschanged",
listener: Windows$Devices$Sms$SmsDeviceStatusChangedEventHandler): void;
removeEventListener(
type: "smsdevicestatuschanged",
listener: Windows$Devices$Sms$SmsDeviceStatusChangedEventHandler): void;

/**
 * Sets an event handler to be called when the device receives a new text message.
 */
onsmsmessagereceived: Windows$Devices$Sms$SmsMessageReceivedEventHandler;
addEventListener(
type: "smsmessagereceived",
listener: Windows$Devices$Sms$SmsMessageReceivedEventHandler): void;
removeEventListener(
type: "smsmessagereceived",
listener: Windows$Devices$Sms$SmsMessageReceivedEventHandler): void;

/**
 * Asynchronously sends a message using the SMS device. The method is asynchronous because the send operation might not occur instantaneously. The message operation object is returned immediately.
 * @param message A reference to an ISmsMessage object. The message can be in text or binary format.
 * @return The message operation object.
 */
sendMessageAsync(
message: Windows$Devices$Sms$ISmsMessage): Windows$Foundation$IPromiseWithOperation<any, Windows$Devices$Sms$SendSmsMessageOperation>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Extends the SmsDevice class, and supports the operation of a mobile broadband SMS device.
 */
declare class Windows$Devices$Sms$SmsDevice2  {

/**
 * Creates an instance of SmsDevice2 for a device that received an SMS message.
 * @param deviceId A string representation of the device ID of the device that received an SMS message.
 * @return An instance of SmsDevice2 initialized for the device with the given ID.
 */
static fromId(deviceId: string): Windows$Devices$Sms$SmsDevice2;

/**
 * Creates an instance of SmsDevice2 for a device, given the device ID of the parent device.
 * @param parentDeviceId The device ID of the parent device.
 * @return An instance of SmsDevice2 initialized for the device with the given parent ID.
 */
static fromParentId(parentDeviceId: string): Windows$Devices$Sms$SmsDevice2;

/**
 * Creates an instance of SmsDevice2 associated with the default SMS device.
 * @return An instance of SmsDevice2 initialized for the default SMS device.
 */
static getDefault(): Windows$Devices$Sms$SmsDevice2;

/**
 * Retrieves the class selection string that can be used to enumerate SMS devices.
 * @return A reference to an Advanced Query Syntax (AQS) string that identifies an SMS device.
 */
static getDeviceSelector(): string;

/**
 * Gets the phone number associated with the SMS device. The phone number can be used to associate incoming messages with the account and possibly an external storage mechanism such as an account inbox.
 */
accountPhoneNumber: string;

/**
 * Estimates the transmitted message length of the specified text message. The estimate can be useful to clients that want to give an indication of how many messages will be sent on the network to carry the text of the full message.
 * @param message A reference to the SMS text message to measure.
 * @return A reference to an SmsEncodedLength structure that is populated with the length information.
 */
calculateLength(
message: Windows$Devices$Sms$ISmsMessageBase): Windows$Devices$Sms$SmsEncodedLength;

/**
 * Returns the cellular class of the SMS device. The class can be used to determine which encodings are appropriate or which device limitations are in effect.
 */
cellularClass: $Values<typeof Windows$Devices$Sms$CellularClass>;

/**
 * The device ID of the device represented by this instance.
 */
deviceId: string;

/**
 * Returns the SMS device's status, which indicates whether the device is ready, or not. It also indicates what type of problem exists if the device is not ready.
 */
deviceStatus: $Values<typeof Windows$Devices$Sms$SmsDeviceStatus>;

/**
 * Sets an event handler to be called when the status of the SMS device changes.
 */
ondevicestatuschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$Sms$SmsDevice2, any>;
addEventListener(
type: "devicestatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sms$SmsDevice2, any>): void;
removeEventListener(
type: "devicestatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sms$SmsDevice2, any>): void;

/**
 * The parent device ID of this device.
 */
parentDeviceId: string;

/**
 * Asynchronously sends a message using the SMS device. The method is asynchronous because the send operation might not occur instantaneously. The message operation object is returned immediately.
 * @param message A reference to an object that implements the ISmsMessageBase interface. The message can be in text or binary format.
 * @return The message operation object.
 */
sendMessageAndGetResultAsync(
message: Windows$Devices$Sms$ISmsMessageBase): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Sms$SmsSendMessageResult>;

/**
 * Gets or sets the SMSC address of this device.
 */
smscAddress: string;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides access to the messages stored on an SMS Device and information about the message store.
 */
declare class Windows$Devices$Sms$SmsDeviceMessageStore  {

/**
 * Deletes the message with the specified ID. Because the device might be busy, the operation executes asynchronously. The asynchronous operation object returns immediately.
 * @param messageId Integer ID of the message to delete, which was previously read from an SmsTextMessage object obtained from the device message store.
 * @return A new message operation object that is used to start and track the asynchronous operation.
 */
deleteMessageAsync(messageId: number): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Deletes the messages to which the filter applies. The filter can be used to delete all messages, or only messages that are read, unread, sent, or in a draft state. Because the operation might not be instantaneous, it executes asynchronously. The asynchronous operation object returns immediately.
 * @param messageFilter A search filter that specifies which messages to delete.
 * @return A new message operation object that is used to start and track the asynchronous operation.
 */
deleteMessagesAsync(
messageFilter: $Values<typeof Windows$Devices$Sms$SmsMessageFilter>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Retrieves the message with the specified ID. The device might be busy, so the method executes asynchronously. The asynchronous operation object returns immediately.
 * @param messageId ID of the message to retrieve.
 * @return Returns a new message operation object that is used to start and track the asynchronous operation.
 */
getMessageAsync(
messageId: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Sms$ISmsMessage>;

/**
 * Retrieves a list of messages that match the conditions specified in a filter. The messages can be filtered as read, unread, sent, or in the draft state.
 * @param messageFilter ID of the message to retrieve.
 * @return Returns a new message operation object that is used to start and track the asynchronous operation.
 */
getMessagesAsync(
messageFilter: $Values<typeof Windows$Devices$Sms$SmsMessageFilter>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Foundation$Collections$IVectorView<any>, number>;

/**
 * Indicates the maximum number of messages that can be stored in the device store. The client can use this value to determine how to maintain enough space in the device store to receive new messages from the network.
 */
maxMessages: number
}


/**
 * Contains values that indicate the readiness of an SMS device to engage in cellular network traffic operations.
 */

declare  var Windows$Devices$Sms$SmsDeviceStatus: {|
  +off: 0,// 0
+ready: 1,// 1
+simNotInserted: 2,// 2
+badSim: 3,// 3
+deviceFailure: 4,// 4
+subscriptionNotActivated: 5,// 5
+deviceLocked: 6,// 6
+deviceBlocked: 7,// 7

|};



/**
 * This enumerated type is used to determine the encoding algorithm to send or calculate the length of an SmsTextMessage object.
 */

declare  var Windows$Devices$Sms$SmsEncoding: {|
  +unknown: 0,// 0
+optimal: 1,// 1
+sevenBitAscii: 2,// 2
+unicode: 3,// 3
+gsmSevenBit: 4,// 4
+eightBit: 5,// 5
+latin: 6,// 6
+korean: 7,// 7
+ia5: 8,// 8
+shiftJis: 9,// 9
+latinHebrew: 10,// 10

|};



/**
 * Values that describe the action to be taken on a message filter.
 */

declare  var Windows$Devices$Sms$SmsFilterActionType: {|
  +acceptImmediately: 0,// 0
+drop: 1,// 1
+peek: 2,// 2
+accept: 3,// 3

|};



/**
 * Describes an SMS filtering rule.
 */
declare class Windows$Devices$Sms$SmsFilterRule  {

/**
 * Creates a new, empty SmsFilterRule .
 * @param messageType An enumeration value specifying the message type that will match this rule.
 */
constructor(messageType: $Values<typeof Windows$Devices$Sms$SmsMessageType>): this;

/**
 * A list of broadcast channels that match this rule.
 */
broadcastChannels: Windows$Foundation$Collections$IVector<number>;

/**
 * Gets a list of broadcast types for an SMS message that matches this rule.
 */
broadcastTypes: Windows$Foundation$Collections$IVector<$Values<typeof Windows$Devices$Sms$SmsBroadcastType>>;

/**
 * The cellular class identifier for SMS messages that match this rule.
 */
cellularClass: $Values<typeof Windows$Devices$Sms$CellularClass>;

/**
 * Gets a list of device identifiers for an SMS message that matches this rule.
 */
deviceIds: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets the IMSI prefixes for an SMS message that matches this rule.
 */
imsiPrefixes: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets the message type of an SMS message that matches this filter rule.
 */
messageType: $Values<typeof Windows$Devices$Sms$SmsMessageType>;

/**
 * Gets a list of port numbers associated with the SMS message that matches this rule.
 */
portNumbers: Windows$Foundation$Collections$IVector<number>;

/**
 * Gets a list of protocol identifiers associated with the SMS message that matches this rule..
 */
protocolIds: Windows$Foundation$Collections$IVector<number>;

/**
 * Gets the sender numbers associated with an SMS message that matches this rule.
 */
senderNumbers: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets the list of teleservice identifiers for an SMS message that matches this rule.
 */
teleserviceIds: Windows$Foundation$Collections$IVector<number>;

/**
 * Gets a list of the text message prefixes for an SMS message that matches this filter.
 */
textMessagePrefixes: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets a list of WAP application identifiers for the SMS message that matches this rule.
 */
wapApplicationIds: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets a list of WAP content types for the SMS message that matches this rule.
 */
wapContentTypes: Windows$Foundation$Collections$IVector<string>
}


/**
 * A collection of SmsFilterRule instances.
 */
declare class Windows$Devices$Sms$SmsFilterRules  {

/**
 * Creates an instance of SmsFilterRules .
 * @param actionType An enumeration value that specifies which action type is to be associated with the rules for this instance. Action type determines the order in which rules are evaluated, as well as the action to be taken when a rule is matched.
 */
constructor(actionType: $Values<typeof Windows$Devices$Sms$SmsFilterActionType>): this;

/**
 * The SmsFilterActionType for this set of filter rules.
 */
actionType: $Values<typeof Windows$Devices$Sms$SmsFilterActionType>;

/**
 * Gets the list of rules in this SmsFilterRules instance.
 */
rules: Windows$Foundation$Collections$IVector<Windows$Devices$Sms$SmsFilterRule>
}


/**
 * Values that describe the geographical scope of a cell broadcast message.
 */

declare  var Windows$Devices$Sms$SmsGeographicalScope: {|
  +none: 0,// 0
+cellWithImmediateDisplay: 1,// 1
+locationArea: 2,// 2
+plmn: 3,// 3
+cell: 4,// 4

|};



/**
 * This enumerated type specifies the message class of a message. The message class typically originates on the network, not the mobile device.
 */

declare  var Windows$Devices$Sms$SmsMessageClass: {|
  +none: 0,// 0
+class0: 1,// 1
+class1: 2,// 2
+class2: 3,// 3
+class3: 4,// 4

|};



/**
 * This enumerated type specifies which messages in the device message store an operation is performed on.
 */

declare  var Windows$Devices$Sms$SmsMessageFilter: {|
  +all: 0,// 0
+unread: 1,// 1
+read: 2,// 2
+sent: 3,// 3
+draft: 4,// 4

|};



/**
 * Provides data for ISmsBinaryMessage event handlers.
 */
declare class Windows$Devices$Sms$SmsMessageReceivedEventArgs  {

/**
 * Retrieves an object that holds the binary representation of the message. This is of interest only to clients who want to pass binary messages on directly or do their own interpretation of the binary message contents.
 */
binaryMessage: Windows$Devices$Sms$SmsBinaryMessage;

/**
 * Retrieves an object that holds the text representation of the message. If the message is not successfully decoded, an error is returned.
 */
textMessage: Windows$Devices$Sms$SmsTextMessage
}


/**
 * Contains event details for the event raised when an SMS message is received.
 */
declare class Windows$Devices$Sms$SmsMessageReceivedTriggerDetails  {

/**
 * Delivers the filtered message to the messaging app.
 */
accept(): void;

/**
 * When MessageType is App, the message details for the message.
 */
appMessage: Windows$Devices$Sms$SmsAppMessage;

/**
 * When MessageType is Broadcast, the message details for the message.
 */
broadcastMessage: Windows$Devices$Sms$SmsBroadcastMessage;

/**
 * Drops the filtered message, so that it is not passed on to the messaging app.
 */
drop(): void;

/**
 * The SmsMessageType of the received message.
 */
messageType: $Values<typeof Windows$Devices$Sms$SmsMessageType>;

/**
 * When MessageType is Status, the message details for the message.
 */
statusMessage: Windows$Devices$Sms$SmsStatusMessage;

/**
 * When MessageType is Text, the message details for the message.
 */
textMessage: Windows$Devices$Sms$SmsTextMessage2;

/**
 * When MessageType is Voicemail, the message details for the message.
 */
voicemailMessage: Windows$Devices$Sms$SmsVoicemailMessage;

/**
 * When MessageType is Wap, the message details for the message.
 */
wapMessage: Windows$Devices$Sms$SmsWapMessage
}


/**
 * Class used to represent registered message filters.
 */
declare class Windows$Devices$Sms$SmsMessageRegistration  {

/**
 * Static property that gets a list of currently registered message filters..
 */
static allRegistrations: Windows$Foundation$Collections$IVectorView<Windows$Devices$Sms$SmsMessageRegistration>;

/**
 * Registers a message filter.
 * @param id Identifier used to describe this message filter.
 * @param filterRules An object that represents the filter rules to be used for this registered message filter.
 * @return On successful completion, the SmsMessageRegistration object that represents this registered message filter.
 */
static register(
id: string,
filterRules: Windows$Devices$Sms$SmsFilterRules): Windows$Devices$Sms$SmsMessageRegistration;

/**
 * Gets an identifier for this registered message filter.
 */
id: string;

/**
 * Event signaled when a message has been received that meets the filter criteria set in a registered message filter.
 */
onmessagereceived: Windows$Foundation$TypedEventHandler<Windows$Devices$Sms$SmsMessageRegistration, Windows$Devices$Sms$SmsMessageReceivedTriggerDetails>;
addEventListener(
type: "messagereceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sms$SmsMessageRegistration, Windows$Devices$Sms$SmsMessageReceivedTriggerDetails>): void;
removeEventListener(
type: "messagereceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Sms$SmsMessageRegistration, Windows$Devices$Sms$SmsMessageReceivedTriggerDetails>): void;

/**
 * Unregisters a previously-registered message filter. The filter will no longer be applied to incoming messages.
 */
unregister(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * This enumerated type defines the format of the SMS message.
 */

declare  var Windows$Devices$Sms$SmsMessageType: {|
  +binary: 0,// 0
+text: 1,// 1
+wap: 2,// 2
+app: 3,// 3
+broadcast: 4,// 4
+voicemail: 5,// 5
+status: 6,// 6

|};



/**
 * Values that describe error codes from the SMS modem in an SmsSendMessageResult.
 */

declare  var Windows$Devices$Sms$SmsModemErrorCode: {|
  +other: 0,// 0
+messagingNetworkError: 1,// 1
+smsOperationNotSupportedByDevice: 2,// 2
+smsServiceNotSupportedByNetwork: 3,// 3
+deviceFailure: 4,// 4
+messageNotEncodedProperly: 5,// 5
+messageTooLarge: 6,// 6
+deviceNotReady: 7,// 7
+networkNotReady: 8,// 8
+invalidSmscAddress: 9,// 9
+networkFailure: 10,// 10
+fixedDialingNumberRestricted: 11,// 11

|};



/**
 * Presents the details of SMS message events to the background work item that handles messages while your app is suspended.
 */
declare class Windows$Devices$Sms$SmsReceivedEventDetails  {

/**
 * Gets the binary message object for the SMS message received by the background task.
 */
binaryMessage: Windows$Devices$Sms$SmsBinaryMessage;

/**
 * Returns the DeviceInformation ID of the network interface that received the SMS message. This ID can be passed to SmsDevice.FromIdAsync to activate the device and retrieve additional message details.
 */
deviceId: string;

/**
 * Gets the message class for the SMS message received by the background task.
 */
messageClass: $Values<typeof Windows$Devices$Sms$SmsMessageClass>;

/**
 * Returns the index of the new message that raised the event. You can pass this to SmsDevice.GetMessageAsync to retrieve the new message itself.
 */
messageIndex: number
}


/**
 * Encapsulates the results of calling SmsDevice2.SendMessageAndGetResultAsync .
 */
declare class Windows$Devices$Sms$SmsSendMessageResult  {

/**
 * Gets the cellular class used in the send operation.
 */
cellularClass: $Values<typeof Windows$Devices$Sms$CellularClass>;

/**
 * Gets a boolean value indicating whether the send operation has encountered a transient error.
 */
isErrorTransient: boolean;

/**
 * Gets a value indicating whether the send operation was successful.
 */
isSuccessful: boolean;

/**
 * Gets a list of message numbers sent.
 */
messageReferenceNumbers: Windows$Foundation$Collections$IVectorView<number>;

/**
 * Gets the error code for a modem error associated with the send operation.
 */
modemErrorCode: $Values<typeof Windows$Devices$Sms$SmsModemErrorCode>;

/**
 * Gets the error code for a network error associated with the send operation.
 */
networkCauseCode: number;

/**
 * Gets the error code for a transport failure associated with the send operation.
 */
transportFailureCause: number
}


/**
 * Encapsulates an SMS status message.
 */
declare class Windows$Devices$Sms$SmsStatusMessage  {

/**
 * Gets the body of the status message.
 */
body: string;

/**
 * Gets the cellular class of the message.
 */
cellularClass: $Values<typeof Windows$Devices$Sms$CellularClass>;

/**
 * Gets the device identifier associated with the status message.
 */
deviceId: string;

/**
 * The discharge time of the status message.
 */
dischargeTime: Date;

/**
 * Gets the phone number that sent the status message.
 */
from: string;

/**
 * Gets the message class of the status message.
 */
messageClass: $Values<typeof Windows$Devices$Sms$SmsMessageClass>;

/**
 * Gets the reference number of the status message.
 */
messageReferenceNumber: number;

/**
 * Gets the message type of the status message.
 */
messageType: $Values<typeof Windows$Devices$Sms$SmsMessageType>;

/**
 * Gets the service center timestamp of the status message.
 */
serviceCenterTimestamp: Date;

/**
 * Gets the ICCID (Integrated Circuit Card Identifier) of the SIM that received the message.
 */
simIccId: string;

/**
 * The status code associated with this message.
 */
status: number;

/**
 * Gets the phone number the status message was sent to.
 */
to: string
}


/**
 * Manages a decoded SMS text message, providing direct access to the plain text body of the message, as well as key header properties, such as time stamp.
 */
declare class Windows$Devices$Sms$SmsTextMessage  {

/**
 * Decodes a binary message and places the results in a new instance of a text message. This method represents the binary message as a reference to a buffer of bytes and a selection of how the buffer is encoded. Therefore, it can be used when the message did not originate directly from the device or as an instance of an SmsBinaryMessage class.
 * @param format An SmsDataFormat enumerated value that identifies the format of a particular protocol description unit (PDU) buffer.
 * @param value An array of bytes containing the binary data to decode.
 * @return A new SmsTextMessage object if the decoding was successful.
 */
static fromBinaryData(
format: $Values<typeof Windows$Devices$Sms$SmsDataFormat>,
value: number[]): Windows$Devices$Sms$SmsTextMessage;

/**
 * Reads a binary message and decodes it. The results are placed in a new instance of a text message.
 * @param binaryMessage An instance of a binary message to decode.
 * @return A new SmsTextMessage object.
 */
static fromBinaryMessage(
binaryMessage: Windows$Devices$Sms$SmsBinaryMessage): Windows$Devices$Sms$SmsTextMessage;

/**
 * Creates an instance of the SmsTextMessage class.
 */
constructor(): this;

/**
 * Specifies the plain text body of the message.
 */
body: string;

/**
 * Specifies the encoding type that has been set to use when sending this message.
 */
encoding: $Values<typeof Windows$Devices$Sms$SmsEncoding>;

/**
 * Specifies the phone number of the sender of the message.
 */
from: string;

/**
 * Indicates the ID of the SMS text message.
 */
id: number;

/**
 * Specifies the message class of a message. This message class typically originates on the network, not the mobile device.
 */
messageClass: $Values<typeof Windows$Devices$Sms$SmsMessageClass>;

/**
 * Indicates the total number of parts in the original message if the message is part of a multi-part message.
 */
partCount: number;

/**
 * Indicates the part number of a multi-part message if this message is part of a multi-part message. It can be used to reconstruct the original message by joining the parts together, in conjunction with the PartReferenceId and PartCount properties.
 */
partNumber: number;

/**
 * Indicates a reference value that can be used if the message is part of a multi-part message. If this message belongs to a multi-part message, the PartNumber value can be used to reconstruct the full original message, and each part of that message will have the same value for PartReferenceId.
 */
partReferenceId: number;

/**
 * Indicates the timestamp of the message. It is determined locally for a constructed message instance or from the service center timestamp of a received message.
 */
timestamp: Date;

/**
 * Indicates the recipient phone number of this message.
 */
to: string;

/**
 * Reads a message in the specified format and places the results in a new instance of a binary message.
 * @param format A value from the SmsDataFormat enumeration.
 * @return The new binary message that holds the result of this method call.
 */
toBinaryMessages(
format: $Values<typeof Windows$Devices$Sms$SmsDataFormat>): Windows$Foundation$Collections$IVectorView<Windows$Devices$Sms$ISmsBinaryMessage>
}


/**
 * Encapsulates a decoded SMS text message. Prefer this class to the older SmsTextMessage class.
 */
declare class Windows$Devices$Sms$SmsTextMessage2  {

/**
 * Constructs a new, default instance of this class.
 */
constructor(): this;

/**
 * Gets or sets the body of the text message.
 */
body: string;

/**
 * Gets or sets the callback number for the message.
 */
callbackNumber: string;

/**
 * Gets the cellular class of the message.
 */
cellularClass: $Values<typeof Windows$Devices$Sms$CellularClass>;

/**
 * Gets the device identifier for the device associated with the SMS text message.
 */
deviceId: string;

/**
 * Gets or sets the encoding scheme used for the message.
 */
encoding: $Values<typeof Windows$Devices$Sms$SmsEncoding>;

/**
 * gets the phone number of the sender of the message.
 */
from: string;

/**
 * Gets or sets whether text message delivery notification is enabled for this message.
 */
isDeliveryNotificationEnabled: boolean;

/**
 * Gets the message class of the message.
 */
messageClass: $Values<typeof Windows$Devices$Sms$SmsMessageClass>;

/**
 * Gets the message type of the message.
 */
messageType: $Values<typeof Windows$Devices$Sms$SmsMessageType>;

/**
 * Gets the protocol identifier for the message.
 */
protocolId: number;

/**
 * Gets or sets the number of retry attempts for the message.
 */
retryAttemptCount: number;

/**
 * Gets the ICCID (Integrated Circuit Card Identifier) of the SIM that received the message.
 */
simIccId: string;

/**
 * Gets the teleservice identifier associated with this message.
 */
teleserviceId: number;

/**
 * The timestamp of this message.
 */
timestamp: Date;

/**
 * Gets or sets the recipient phone number for the message.
 */
to: string
}


/**
 * Encapsulates an SMS voicemail message.
 */
declare class Windows$Devices$Sms$SmsVoicemailMessage  {

/**
 * Gets the body of the voicemail message.
 */
body: string;

/**
 * Gets the cellular class of the message.
 */
cellularClass: $Values<typeof Windows$Devices$Sms$CellularClass>;

/**
 * Gets the unique device identifier associated with the message.
 */
deviceId: string;

/**
 * Gets the message class of the message.
 */
messageClass: $Values<typeof Windows$Devices$Sms$SmsMessageClass>;

/**
 * Gets the number of available messages.
 */
messageCount: number;

/**
 * Gets the type of the message.
 */
messageType: $Values<typeof Windows$Devices$Sms$SmsMessageType>;

/**
 * Gets the ICCID (Integrated Circuit Card Identifier) of the SIM that received the message.
 */
simIccId: string;

/**
 * The timestamp of the message.
 */
timestamp: Date;

/**
 * The phone number the message was sent to.
 */
to: string
}


/**
 * Represents an SMS WAP push message.
 */
declare class Windows$Devices$Sms$SmsWapMessage  {

/**
 * Gets the value of the X-Wap-Application-Id header of the SmsWapMessage .
 */
applicationId: string;

/**
 * Gets the binary body of the blob in the SmsWapMessage .
 */
binaryBody: Windows$Storage$Streams$IBuffer;

/**
 * Gets the cellular class of the SMS device that received the message.
 */
cellularClass: $Values<typeof Windows$Devices$Sms$CellularClass>;

/**
 * Gets the value of the Content-Type header in the SmsWapMessage . Parameters are presents in the Headers property.
 */
contentType: string;

/**
 * Gets the device information ID of the SmsDevice that receives the SmsWapMessage .
 */
deviceId: string;

/**
 * Gets the phone number of the sender of the SmsWapMessage .
 */
from: string;

/**
 * Gets the header name-value pairs of the WAP push message.
 */
headers: Windows$Foundation$Collections$IMap<string, string>;

/**
 * Gets the message class of the SmsWapMessage .
 */
messageClass: $Values<typeof Windows$Devices$Sms$SmsMessageClass>;

/**
 * Gets the message type of the SmsWapMessage .
 */
messageType: $Values<typeof Windows$Devices$Sms$SmsMessageType>;

/**
 * Gets the ICCID (Integrated Circuit Card Identifier) of the SIM that received the message.
 */
simIccId: string;

/**
 * Gets the timestamp of the SmsWapMessage .
 */
timestamp: Date;

/**
 * Gets the recipient phone number of this SmsWapMessage .
 */
to: string
}


/**
 * This interface is implemented by all types of SMS messages that are supported.
 */
declare interface Windows$Devices$Sms$ISmsMessage {

/**
 * Retrieves an ID for the message, which can later be specified in calling message store methods in order to get or delete the message.
 */
id: number,

/**
 * Returns the message class, as determined by the operator's message network. The two most common classes are None (normal message) or Class0 (special operator message, such as a roaming warning that must be shown immediately to the user). A typical client for end-user messages ignores Class0 messages.
 */
messageClass: $Values<typeof Windows$Devices$Sms$SmsMessageClass>
} 


/**
 * This structure represents information about the length of an SmsTextMessage object when it is encoded as a PDU.
 */
declare interface Windows$Devices$Sms$SmsEncodedLength {

/**
 * The number of bytes in the last segment of the encoded message.
 */
byteCountLastSegment: number,

/**
 * The number of bytes in each segment of the message.
 */
bytesPerSegment: number,

/**
 * The number of characters in the last segment of the encoded message.
 */
characterCountLastSegment: number,

/**
 * The estimated number of characters that can fit in one segment of the message.
 */
charactersPerSegment: number,

/**
 * The number of segments needed to encode the message.
 */
segmentCount: number
} 


/**
 * This handler is called when the status on the SMS device changes. Callers should implement this when they want to be notified when a significant state change occurs on the device. For example, the caller might want to know when the device is ready to send and receive messages.
 */
declare type Windows$Devices$Sms$SmsDeviceStatusChangedEventHandler = (ev: Windows$WinRTEvent<Windows$Devices$Sms$SmsDevice>) => void;


/**
 * This event handler is called when a new binary message is received. Callers should implement this when they want to handle new binary messages from a given SMS device.
 */
declare type Windows$Devices$Sms$SmsMessageReceivedEventHandler = (
ev: Windows$Devices$Sms$SmsMessageReceivedEventArgs & Windows$WinRTEvent<Windows$Devices$Sms$SmsDevice>) => void;


/**
 * This interface specifies base functionality for all SMS message types.
 */
declare interface Windows$Devices$Sms$ISmsMessageBase {

/**
 * Gets the cellular class of the message.
 */
cellularClass: $Values<typeof Windows$Devices$Sms$CellularClass>,

/**
 * Gets the unique device identifier associated with this message.
 */
deviceId: string,

/**
 * Gets the message class of this message.
 */
messageClass: $Values<typeof Windows$Devices$Sms$SmsMessageClass>,

/**
 * Gets the message type of this message.
 */
messageType: $Values<typeof Windows$Devices$Sms$SmsMessageType>,

/**
 * Gets the ICCID (Integrated Circuit Card Identifier) of the SIM that received the message.
 */
simIccId: string
} 


/**
 * This interface provides access to the raw binary format of an SMS message. The message is stored in the industry standard protocol description unit (PDU) format (see the SMS specification GSM 03.40).
 */
declare type Windows$Devices$Sms$ISmsBinaryMessage = {

/**
 * Returns the raw buffer of the message in binary protocol description unit (PDU) format as a byte array.
 * @return A byte array representing message data. If there is no message data, the returned array is empty.
 */
getData(): Array<number>,

/**
 * Specifies the raw binary payload of the SMS message. It should be formatted according to the protocol description unit (PDU) standard.
 * @param value A byte array representing message data, formatted according to the protocol description unit (PDU) standard.
 */
setData(value: Array<number>): void,

/**
 * Retrieves the detected protocol description unit (PDU) format of this message.
 */
format: $Values<typeof Windows$Devices$Sms$SmsDataFormat>
} & Windows$Devices$Sms$ISmsMessage



      declare var npm$namespace$Windows$Devices$Spi: {
        
        
        SpiMode: typeof Windows$Devices$Spi$SpiMode,
SpiSharingMode: typeof Windows$Devices$Spi$SpiSharingMode,
        SpiBusInfo: typeof Windows$Devices$Spi$SpiBusInfo,
SpiConnectionSettings: typeof Windows$Devices$Spi$SpiConnectionSettings,
SpiController: typeof Windows$Devices$Spi$SpiController,
SpiDevice: typeof Windows$Devices$Spi$SpiDevice,
        Provider: typeof npm$namespace$Windows$Devices$Spi$Provider,
      }

      declare var npm$namespace$Windows$Devices$Spi$Provider: {
        
        
        
        ProviderSpiConnectionSettings: typeof Windows$Devices$Spi$Provider$ProviderSpiConnectionSettings,
        ProviderSpiMode: typeof npm$namespace$Windows$Devices$Spi$Provider$ProviderSpiMode,
ProviderSpiSharingMode: typeof npm$namespace$Windows$Devices$Spi$Provider$ProviderSpiSharingMode,
      }
declare class Windows$Devices$Spi$Provider$ProviderSpiConnectionSettings  {
chipSelectLine: any;
clockFrequency: any;
dataBitLength: any;
mode: any;
sharingMode: any
}


      declare var npm$namespace$Windows$Devices$Spi$Provider$ProviderSpiMode: {
        
        mode0: typeof Windows$Devices$Spi$Provider$ProviderSpiMode$mode0,
mode1: typeof Windows$Devices$Spi$Provider$ProviderSpiMode$mode1,
mode2: typeof Windows$Devices$Spi$Provider$ProviderSpiMode$mode2,
mode3: typeof Windows$Devices$Spi$Provider$ProviderSpiMode$mode3,
        
        
        
      }
declare var Windows$Devices$Spi$Provider$ProviderSpiMode$mode0: any;

declare var Windows$Devices$Spi$Provider$ProviderSpiMode$mode1: any;

declare var Windows$Devices$Spi$Provider$ProviderSpiMode$mode2: any;

declare var Windows$Devices$Spi$Provider$ProviderSpiMode$mode3: any;


      declare var npm$namespace$Windows$Devices$Spi$Provider$ProviderSpiSharingMode: {
        
        exclusive: typeof Windows$Devices$Spi$Provider$ProviderSpiSharingMode$exclusive,
shared: typeof Windows$Devices$Spi$Provider$ProviderSpiSharingMode$shared,
        
        
        
      }
declare var Windows$Devices$Spi$Provider$ProviderSpiSharingMode$exclusive: any;

declare var Windows$Devices$Spi$Provider$ProviderSpiSharingMode$shared: any;


/**
 * Represents actions common to SPI controller providers.
 */
declare interface Windows$Devices$Spi$Provider$ISpiProvider {
getControllersAsync: any
} 


/**
 * Represents the info about a SPI bus.
 */
declare class Windows$Devices$Spi$SpiBusInfo  {

/**
 * Gets the number of chip select lines available on the bus.
 */
chipSelectLineCount: number;

/**
 * Maximum clock cycle frequency of the bus.
 */
maxClockFrequency: number;

/**
 * Minimum clock cycle frequency of the bus.
 */
minClockFrequency: number;

/**
 * Gets the bit lengths that can be used on the bus for transmitting data.
 */
supportedDataBitLengths: Windows$Foundation$Collections$IVectorView<number>
}


/**
 * Represents the settings for the connection with a device.
 */
declare class Windows$Devices$Spi$SpiConnectionSettings  {

/**
 * Initializes new instance of SpiConnectionSettings .
 * @param chipSelectLine The chip select line on which the connection will be made.
 */
constructor(chipSelectLine: number): this;

/**
 * Gets or sets the chip select line for the connection to the SPI device.
 */
chipSelectLine: number;

/**
 * Gets or sets the clock frequency for the connection.
 */
clockFrequency: number;

/**
 * Gets or sets the bit length for data on this connection.
 */
dataBitLength: number;

/**
 * Gets or sets the SpiMode for this connection.
 */
mode: $Values<typeof Windows$Devices$Spi$SpiMode>;

/**
 * Gets or sets the sharing mode for the SPI connection.
 */
sharingMode: $Values<typeof Windows$Devices$Spi$SpiSharingMode>
}


/**
 * Represents the SPI controller on the system.
 */
declare class Windows$Devices$Spi$SpiController  {

/**
 * Gets all the SPI controllers that are on the system.
 * @param provider The SPI provider for the controllers on the system.
 * @return When the method completes successfully, it returns a list of values that represent the available SPI controllers on the system.
 */
static getControllersAsync(
provider: Windows$Devices$Spi$Provider$ISpiProvider): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the default SPI controller on the system.
 * @return The default SPI controller on the system, or null if the system has no SPI controller.
 */
static getDefaultAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Spi$SpiController>;

/**
 * Gets the SPI device with the specified settings.
 * @param settings The desired connection settings.
 * @return The SPI device.
 */
getDevice(
settings: Windows$Devices$Spi$SpiConnectionSettings): Windows$Devices$Spi$SpiDevice
}


/**
 * Represents a device connected through the SPI bus.
 */
declare class Windows$Devices$Spi$SpiDevice  {

/**
 * Opens a device with the connection settings provided.
 * @param busId The id of the bus.
 * @param settings The connection settings.
 * @return The SPI device requested.
 */
static fromIdAsync(
busId: string,
settings: Windows$Devices$Spi$SpiConnectionSettings): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Spi$SpiDevice>;

/**
 * Retrieves the info about a certain bus.
 * @param busId The id of the bus.
 * @return The bus info requested.
 */
static getBusInfo(busId: string): Windows$Devices$Spi$SpiBusInfo;

/**
 * Gets all the SPI buses found on the system that match the input parameter.
 * @param friendlyName Input parameter specifying an identifying name for the desired bus. This usually corresponds to a name on the schematic.
 * @return String containing all the buses that have the input in the name.
 */
static getDeviceSelector(friendlyName: string): string;

/**
 * Gets all the SPI buses found on the system.
 * @return String containing all the buses found on the system.
 */
static getDeviceSelector(): string;

/**
 * Closes the connection to the device.
 */
close(): void;

/**
 * Gets the connection settings for the device.
 */
connectionSettings: Windows$Devices$Spi$SpiConnectionSettings;

/**
 * Gets the unique ID associated with the device.
 */
deviceId: string;

/**
 * Reads from the connected device.
 * @return Array containing data read from the device.
 */
read(): number[];

/**
 * Transfer data using a full duplex communication system. Full duplex allows both the master and the slave to communicate simultaneously.
 * @param writeBuffer Array containing data to write to the device.
 * @return Array containing data read from the device.
 */
transferFullDuplex(writeBuffer: number[]): number[];

/**
 * Transfer data sequentially to the device.
 * @param writeBuffer Array containing data to write to the device.
 * @return Array containing data read from the device.
 */
transferSequential(writeBuffer: number[]): number[];

/**
 * Writes to the connected device.
 * @param buffer Array containing the data to write to the device.
 */
write(buffer: number[]): void
}


/**
 * Defines the SPI communication mode. The communication mode defines the clock edge on which the master out line toggles, the master in line samples, and the signal clock's signal steady level (named SCLK). Each mode is defined with a pair of parameters called clock polarity (CPOL) and clock phase (CPHA).
 */

declare  var Windows$Devices$Spi$SpiMode: {|
  +mode0: 0,// 0
+mode1: 1,// 1
+mode2: 2,// 2
+mode3: 3,// 3

|};



/**
 * Defines the sharing mode for the SPI bus.
 */

declare  var Windows$Devices$Spi$SpiSharingMode: {|
  +exclusive: 0,// 0
+shared: 1,// 1

|};



      declare var npm$namespace$Windows$Devices$Usb: {
        
        
        UsbControlRecipient: typeof Windows$Devices$Usb$UsbControlRecipient,
UsbControlTransferType: typeof Windows$Devices$Usb$UsbControlTransferType,
UsbEndpointType: typeof Windows$Devices$Usb$UsbEndpointType,
UsbReadOptions: typeof Windows$Devices$Usb$UsbReadOptions,
UsbTransferDirection: typeof Windows$Devices$Usb$UsbTransferDirection,
UsbWriteOptions: typeof Windows$Devices$Usb$UsbWriteOptions,
        UsbBulkInEndpointDescriptor: typeof Windows$Devices$Usb$UsbBulkInEndpointDescriptor,
UsbBulkInPipe: typeof Windows$Devices$Usb$UsbBulkInPipe,
UsbBulkOutEndpointDescriptor: typeof Windows$Devices$Usb$UsbBulkOutEndpointDescriptor,
UsbBulkOutPipe: typeof Windows$Devices$Usb$UsbBulkOutPipe,
UsbConfiguration: typeof Windows$Devices$Usb$UsbConfiguration,
UsbConfigurationDescriptor: typeof Windows$Devices$Usb$UsbConfigurationDescriptor,
UsbControlRequestType: typeof Windows$Devices$Usb$UsbControlRequestType,
UsbDescriptor: typeof Windows$Devices$Usb$UsbDescriptor,
UsbDevice: typeof Windows$Devices$Usb$UsbDevice,
UsbDeviceClass: typeof Windows$Devices$Usb$UsbDeviceClass,
UsbDeviceClasses: typeof Windows$Devices$Usb$UsbDeviceClasses,
UsbDeviceDescriptor: typeof Windows$Devices$Usb$UsbDeviceDescriptor,
UsbEndpointDescriptor: typeof Windows$Devices$Usb$UsbEndpointDescriptor,
UsbInterface: typeof Windows$Devices$Usb$UsbInterface,
UsbInterfaceDescriptor: typeof Windows$Devices$Usb$UsbInterfaceDescriptor,
UsbInterfaceSetting: typeof Windows$Devices$Usb$UsbInterfaceSetting,
UsbInterruptInEndpointDescriptor: typeof Windows$Devices$Usb$UsbInterruptInEndpointDescriptor,
UsbInterruptInEventArgs: typeof Windows$Devices$Usb$UsbInterruptInEventArgs,
UsbInterruptInPipe: typeof Windows$Devices$Usb$UsbInterruptInPipe,
UsbInterruptOutEndpointDescriptor: typeof Windows$Devices$Usb$UsbInterruptOutEndpointDescriptor,
UsbInterruptOutPipe: typeof Windows$Devices$Usb$UsbInterruptOutPipe,
UsbSetupPacket: typeof Windows$Devices$Usb$UsbSetupPacket,
        
      }

/**
 * The endpoint descriptor for a USB bulk IN endpoint. The descriptor specifies the endpoint type, direction, number and also the maximum number of bytes that can be read from the endpoint, in a single transfer.
 */
declare class Windows$Devices$Usb$UsbBulkInEndpointDescriptor  {

/**
 * Gets the USB endpoint number of the bulk IN endpoint.
 */
endpointNumber: number;

/**
 * Gets the maximum number of bytes that can be sent to or received from this endpoint, in a single packet.
 */
maxPacketSize: number;

/**
 * Gets the object that represents the pipe that the host opens to communicate with the bulk IN endpoint.
 */
pipe: Windows$Devices$Usb$UsbBulkInPipe
}


/**
 * Represents the pipe that the underlying USB driver opens to communicate with a USB bulk IN endpoint of the device. The app can get an input stream from the pipe and access data is being read from the endpoint.
 */
declare class Windows$Devices$Usb$UsbBulkInPipe  {

/**
 * Starts an asynchronous operation to clear a stall condition (endpoint halt) on the USB bulk IN endpoint that is associated with the pipe.
 * @return An IAsyncAction object that is used to control the asynchronous operation.
 */
clearStallAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the object that represents endpoint descriptor associated with the USB bulk IN endpoint.
 */
endpointDescriptor: Windows$Devices$Usb$UsbBulkInEndpointDescriptor;

/**
 * Discards any data that is cached in the bulk IN pipe.
 */
flushBuffer(): void;

/**
 * Input stream that stores the data that the bulk IN pipe received from the endpoint.
 */
inputStream: Windows$Storage$Streams$IInputStream;

/**
 * Gets the maximum number of bytes that can be read from the bulk IN pipe in a single transfer.
 */
maxTransferSizeBytes: number;

/**
 * Gets or sets configuration flags that controls the behavior of the pipe that reads data from a USB bulk IN endpoint.
 */
readOptions: $Values<typeof Windows$Devices$Usb$UsbReadOptions>
}


/**
 * The endpoint descriptor for a USB bulk OUT endpoint. The descriptor specifies the endpoint type, direction, number and also the maximum number of bytes that can be written to the endpoint, in a single transfer.
 */
declare class Windows$Devices$Usb$UsbBulkOutEndpointDescriptor  {

/**
 * Gets the USB endpoint number of the bulk OUT endpoint.
 */
endpointNumber: number;

/**
 * Gets the maximum number of bytes that can be sent to or received from this endpoint.
 */
maxPacketSize: number;

/**
 * Gets the object that represents the pipe that the host opens to communicate with the bulk IN endpoint.
 */
pipe: Windows$Devices$Usb$UsbBulkOutPipe
}


/**
 * Represents the pipe that the underlying USB driver opens to communicate with a USB bulk OUT endpoint of the device. The object provides access to an output stream to which the app can write data to send to the endpoint.
 */
declare class Windows$Devices$Usb$UsbBulkOutPipe  {

/**
 * Starts an asynchronous operation to clear a stall condition (endpoint halt) on the USB bulk OUT endpoint that is associated with the pipe.
 * @return An IAsyncAction object that is used to control the asynchronous operation.
 */
clearStallAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the object that represents the endpoint descriptor associated with the USB bulk OUT endpoint.
 */
endpointDescriptor: Windows$Devices$Usb$UsbBulkOutEndpointDescriptor;

/**
 * Gets an output stream to which the app can write data to send to the endpoint.
 */
outputStream: Windows$Storage$Streams$IOutputStream;

/**
 * Gets or sets configuration flags that controls the behavior of the pipe that writes data to a USB bulk IN endpoint.
 */
writeOptions: $Values<typeof Windows$Devices$Usb$UsbWriteOptions>
}


/**
 * Provides information about a USB configuration, its descriptors and the interfaces defined within that configuration. For an explanation of a USB configuration, see Section 9.6.3 in the Universal Serial Bus (USB) specification.
 */
declare class Windows$Devices$Usb$UsbConfiguration  {

/**
 * Gets the object that contains the first 9 bytes of the descriptor associated with the USB configuration.
 */
configurationDescriptor: Windows$Devices$Usb$UsbConfigurationDescriptor;

/**
 * Gets an array of objects that represent the full set of descriptors associated with a USB configuration.
 */
descriptors: Windows$Foundation$Collections$IVectorView<Windows$Devices$Usb$UsbDescriptor>;

/**
 * Gets an array of USB interfaces available in the USB configuration.
 */
usbInterfaces: Windows$Foundation$Collections$IVectorView<Windows$Devices$Usb$UsbInterface>
}


/**
 * Derives information from the first 9 bytes of a USB configuration descriptor. The information includes the power capabilities of the device when the configuration is active and the number of interfaces included in that configuration. For an explanation of a configuration descriptor, Section 9.6.3 Universal Serial Bus Specification. For information about descriptor fields, see:
 */
declare class Windows$Devices$Usb$UsbConfigurationDescriptor  {

/**
 * Parses the specified USB descriptor and returns fields of a USB configuration descriptor.
 * @param descriptor A UsbDescriptor object that contains first 9 bytes of the USB configuration descriptor.
 * @return A UsbConfigurationDescriptor object that contains fields of a USB configuration descriptor.
 */
static parse(
descriptor: Windows$Devices$Usb$UsbDescriptor): Windows$Devices$Usb$UsbConfigurationDescriptor;

/**
 * Retrieves the first 9 bytes of a USB configuration descriptor in a UsbConfigurationDescriptor object that is contained in a UsbDescriptor object.
 * @param descriptor The UsbDescriptor object to parse.
 */
static tryParse(
descriptor: Windows$Devices$Usb$UsbDescriptor): {
parsed: Windows$Devices$Usb$UsbConfigurationDescriptor,
returnValue: boolean
};

/**
 * Gets the bConfigurationValue field of a USB configuration descriptor. The value is the number that identifies the configuration.
 */
configurationValue: number;

/**
 * Gets the bMaxPower field of a USB configuration descriptor. The value indicates the maximum power (in milliamp units) that the device can draw from the bus, when the device is bus-powered.
 */
maxPowerMilliamps: number;

/**
 * Gets the D5 bit value of the bmAttributes field in the USB configuration descriptor. The value indicates whether the device can send a resume signal to wake up itself or the host system from a low power state.
 */
remoteWakeup: boolean;

/**
 * Gets the D6 bit of the bmAttributes field in the USB configuration. This value indicates whether the device is drawing power from a local source or the bus.
 */
selfPowered: boolean
}


/**
 * Defines constants that indicate the recipient of a USB control transfer. The recipient is defined in the setup packet of the control request. See Table 9.2 of section 9.3 of the Universal Serial Bus (USB) specification (www.usb.org).
 */

declare  var Windows$Devices$Usb$UsbControlRecipient: {|
  +device: 0,// 0
+specifiedInterface: 1,// 1
+endpoint: 2,// 2
+other: 3,// 3
+defaultInterface: 4,// 4

|};



/**
 * Provides information about the USB control transfer, the type of control request, whether the data is sent from or to the host, and the recipient of the request in the device.
 */
declare class Windows$Devices$Usb$UsbControlRequestType  {

/**
 * Creates a UsbControlRequestType object.
 */
constructor(): this;

/**
 * Gets or sets the bmRequestType value as a byte.
 */
asByte: number;

/**
 * Gets or sets the type of USB control transfer: standard, class, or vendor.
 */
controlTransferType: $Values<typeof Windows$Devices$Usb$UsbControlTransferType>;

/**
 * Gets or sets the direction of the USB control transfer.
 */
direction: $Values<typeof Windows$Devices$Usb$UsbTransferDirection>;

/**
 * Gets or sets the recipient of the USB control transfer.
 */
recipient: $Values<typeof Windows$Devices$Usb$UsbControlRecipient>
}


/**
 * Defines constants that indicate the type of USB control transfer: standard, class, or vendor.
 */

declare  var Windows$Devices$Usb$UsbControlTransferType: {|
  +standard: 0,// 0
+class: 1,// 1
+vendor: 2,// 2

|};



/**
 * Provides information about the type of descriptor, its size (in bytes), and gets the descriptor data.
 */
declare class Windows$Devices$Usb$UsbDescriptor  {

/**
 * Gets the type of descriptor.
 */
descriptorType: number;

/**
 * Gets the length of the descriptor.
 */
length: number;

/**
 * Reads descriptor data in the caller-supplied buffer.
 * @param buffer A caller-supplied buffer that receives descriptor data.
 */
readDescriptorBuffer(buffer: Windows$Storage$Streams$IBuffer): void
}


/**
 * Represents a USB device. The object provides methods and properties that an app can use to find the device (in the system) with which the app wants to communicate, and sends IN and OUT control transfers to the device.
 */
declare class Windows$Devices$Usb$UsbDevice  {

/**
 * Starts an asynchronous operation that creates a UsbDevice object.
 * @param deviceId The device instance path of the device. To obtain that value, get the DeviceInformation.Id property value.
 * @return Returns an IAsyncOperation(UsbDevice) object that returns the results of the operation.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Usb$UsbDevice>;

/**
 * Gets an Advanced Query Syntax (AQS) string that the app can pass to DeviceInformation.FindAllAsync in order to find a specific type of USB device.
 * @param usbClass A UsbDeviceClass object for the device class specified by the app.
 * @return String formatted as an AQS query.
 */
static getDeviceClassSelector(usbClass: Windows$Devices$Usb$UsbDeviceClass): string;

/**
 * Gets an Advanced Query Syntax (AQS) string, based on vendor and product identifiers, specified by the app. The app passes the string to DeviceInformation.FindAllAsync in order to find a specific type of USB device.
 * @param vendorId Specifies the vendor identifier for the device as assigned by the USB specification committee. Possible values are 0 through 0xffff.
 * @param productId Specifies the product identifier. This value is assigned by the manufacturer and is device-specific. Possible values are 0 through 0xffff.
 * @return String formatted as an AQS query.
 */
static getDeviceSelector(vendorId: number, productId: number): string;

/**
 * Gets an Advanced Query Syntax (AQS) string, based on the device interface GUID identifier, specified by the app. The app passes the string to DeviceInformation.FindAllAsync in order to find a specific type of USB device.
 * @param winUsbInterfaceClass The device interface GUID exposed by the Winusb.sys driver. See the remarks section.
 * @return String formatted as an AQS query.
 */
static getDeviceSelector(winUsbInterfaceClass: string): string;

/**
 * Gets an Advanced Query Syntax (AQS) string, based on vendor, product, and device interface GUID identifiers, specified by the app. The app passes the string to DeviceInformation.FindAllAsync in order to find a specific type of USB device.
 * @param vendorId Specifies the vendor identifier for the device as assigned by the USB specification committee. Possible values are 0 through 0xffff.
 * @param productId Specifies the product identifier. This value is assigned by the manufacturer and is device-specific. Possible values are 0 through 0xffff.
 * @param winUsbInterfaceClass The device interface GUID exposed by the Winusb.sys driver. See the remarks section.
 * @return String formatted as an AQS query.
 */
static getDeviceSelector(vendorId: number, productId: number, winUsbInterfaceClass: string): string;

/**
 * Releases the reference to the UsbDevice object that was previously obtained by calling FromIdAsync .
 */
close(): void;

/**
 * Gets an object that represents a USB configuration including all interfaces and their endpoints.
 */
configuration: Windows$Devices$Usb$UsbConfiguration;

/**
 * Gets the object that represents the default or the first interface in a USB configuration.
 */
defaultInterface: Windows$Devices$Usb$UsbInterface;

/**
 * Gets the object that represents the USB device descriptor.
 */
deviceDescriptor: Windows$Devices$Usb$UsbDeviceDescriptor;

/**
 * Starts a USB control transfer to receive data from the default control endpoint of the device.
 * @param setupPacket A UsbSetupPacket object that contains the setup packet for the control transfer.
 * @param buffer A caller-supplied buffer that contains transfer data.
 * @return Returns an IAsyncOperation(IBuffer) object that returns the results of the operation.
 */
sendControlInTransferAsync(
setupPacket: Windows$Devices$Usb$UsbSetupPacket,
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>;

/**
 * Starts a zero-length USB control transfer that reads from the default control endpoint of the device.
 * @param setupPacket A UsbSetupPacket object that contains the setup packet for the control transfer.
 * @return Returns an IAsyncOperation(IBuffer) object that returns the results of the operation.
 */
sendControlInTransferAsync(
setupPacket: Windows$Devices$Usb$UsbSetupPacket): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>;

/**
 * Starts a zero-length USB control transfer that writes to the default control endpoint of the device.
 * @param setupPacket A UsbSetupPacket object that contains the setup packet for the control transfer.
 * @return Returns an IAsyncOperation(UInt32) object that returns the results of the operation.
 */
sendControlOutTransferAsync(
setupPacket: Windows$Devices$Usb$UsbSetupPacket): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * Starts a USB control transfer to send data to the default control endpoint of the device.
 * @param setupPacket A UsbSetupPacket object that contains the setup packet for the control transfer.
 * @param buffer A caller-supplied buffer that contains the transfer data.
 * @return Returns an IAsyncOperation(UInt32) object that returns the results of the operation.
 */
sendControlOutTransferAsync(
setupPacket: Windows$Devices$Usb$UsbSetupPacket,
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<number>
}


/**
 * Provides a way for the app to get an Advanced Query Syntax (AQS) string by specifying the class code, subclass code, and the protocol code defined by the device. The properties in this class are passed in the call to GetDeviceClassSelector .
 */
declare class Windows$Devices$Usb$UsbDeviceClass  {

/**
 * Creates a UsbDeviceClass object.
 */
constructor(): this;

/**
 * Gets or sets the class code of the device.
 */
classCode: number;

/**
 * Gets or sets the protocol code of the device.
 */
protocolCode: number;

/**
 * Gets or sets the subclass code of the device.
 */
subclassCode: number
}


/**
 * Provides a way for the app to create a UsbDeviceClass object by specifying the USB device class of the device. The properties defined in this class represent the supported USB device classes and are passed in the constructor call to instantiate UsbDeviceClass. For information about USB device classes, see the official USB Website for Approved Class Specification Documents.
 */
declare class Windows$Devices$Usb$UsbDeviceClasses  {

/**
 * Gets the device class object for the device that conforms to the Active Sync device class.
 */
static activeSync: Windows$Devices$Usb$UsbDeviceClass;

/**
 * Gets the device class object for the device that conforms to the Communication Device Class (CDC).
 */
static cdcControl: Windows$Devices$Usb$UsbDeviceClass;

/**
 * Gets the device class object for the device that conforms to the Device Firmware Update device class.
 */
static deviceFirmwareUpdate: Windows$Devices$Usb$UsbDeviceClass;

/**
 * Gets the device class object for an infrared transceiver that conforms to the IrDA class defined as per the IrDA Bridge Device Definition 1.0 specification.
 */
static irda: Windows$Devices$Usb$UsbDeviceClass;

/**
 * Gets the device class object for a device that conforms to the USB test and measurement class (USBTMC).
 */
static measurement: Windows$Devices$Usb$UsbDeviceClass;

/**
 * Gets the device class object for the device that conforms to the Palm Sync device class.
 */
static palmSync: Windows$Devices$Usb$UsbDeviceClass;

/**
 * Gets the device class object for a device that conforms to the USB Personal Healthcare Device Class (PHDC).
 */
static personalHealthcare: Windows$Devices$Usb$UsbDeviceClass;

/**
 * Gets the device class object for a device that conforms to the Physical Interface Devices (PID) specification.
 */
static physical: Windows$Devices$Usb$UsbDeviceClass;

/**
 * Gets the device class object for a custom device that has 0xFF class code. This indicates that the device does not belong to a class approved by USB-IF.
 */
static vendorSpecific: Windows$Devices$Usb$UsbDeviceClass
}


/**
 * Derives information from the USB device descriptor of the device. For an explanation of the device descriptor, see Table 9.8 in the Universal Serial Bus Specification.
 */
declare class Windows$Devices$Usb$UsbDeviceDescriptor  {

/**
 * Gets the bcdDeviceRevision field of the USB device descriptor. The value indicates the revision number defined by the device and is a binary-coded decimal number.
 */
bcdDeviceRevision: number;

/**
 * Gets the bcdUSB field of the USB device descriptor. The value indicates the version of the USB specification to which the device conforms.
 */
bcdUsb: number;

/**
 * Gets the bMaxPacketSize0 field of the USB device descriptor. The value indicates the maximum packet size, in bytes, for endpoint zero of the device. This value can be 8, 16, 32, or 64.
 */
maxPacketSize0: number;

/**
 * Gets the bNumConfigurations field of the USB device descriptor. The value indicates the total count of USB configurations supported by the device.
 */
numberOfConfigurations: number;

/**
 * Gets the idProduct field of the USB device descriptor. This value indicates the device-specific product identifier and is assigned by the manufacturer.
 */
productId: number;

/**
 * Gets the idVendor field of the USB device descriptor. The value indicates the vendor identifier for the device as assigned by the USB specification committee.
 */
vendorId: number
}


/**
 * Derives information from the USB endpoint descriptor of the endpoint, such as type, direction, and endpoint number. This object also gets the specific endpoint descriptors based on the type of endpoint. For an explanation of an endpoint descriptor, see Section 9.6.5 in the Universal Serial Bus Specification:
 */
declare class Windows$Devices$Usb$UsbEndpointDescriptor  {

/**
 * Parses the specified USB descriptor and returns the USB endpoint descriptor in a UsbEndpointDescriptor object.
 * @param descriptor A UsbDescriptor object that contains the USB endpoint descriptor.
 * @return A UsbEndpointDescriptor object that contains the USB endpoint descriptor.
 */
static parse(
descriptor: Windows$Devices$Usb$UsbDescriptor): Windows$Devices$Usb$UsbEndpointDescriptor;

/**
 * Retrieves the USB endpoint descriptor in a UsbEndpointDescriptor object that is contained in a UsbDescriptor object.
 * @param descriptor The UsbDescriptor object to parse.
 */
static tryParse(
descriptor: Windows$Devices$Usb$UsbDescriptor): {
parsed: Windows$Devices$Usb$UsbEndpointDescriptor,
returnValue: boolean
};

/**
 * Gets an object that represents the endpoint descriptor for the USB bulk IN endpoint.
 */
asBulkInEndpointDescriptor: Windows$Devices$Usb$UsbBulkInEndpointDescriptor;

/**
 * Gets an object that represents the endpoint descriptor for the USB bulk OUT endpoint.
 */
asBulkOutEndpointDescriptor: Windows$Devices$Usb$UsbBulkOutEndpointDescriptor;

/**
 * Gets an object that represents the endpoint descriptor for the USB interrupt IN endpoint.
 */
asInterruptInEndpointDescriptor: Windows$Devices$Usb$UsbInterruptInEndpointDescriptor;

/**
 * Gets an object that represents the endpoint descriptor for the USB interrupt OUT endpoint.
 */
asInterruptOutEndpointDescriptor: Windows$Devices$Usb$UsbInterruptOutEndpointDescriptor;

/**
 * Gets the direction of the USB endpoint.
 */
direction: $Values<typeof Windows$Devices$Usb$UsbTransferDirection>;

/**
 * Gets the USB endpoint number.
 */
endpointNumber: number;

/**
 * Gets the type of USB endpoint.
 */
endpointType: $Values<typeof Windows$Devices$Usb$UsbEndpointType>
}


/**
 * Defines constants that indicate the type of USB endpoint: control, bulk, isochronous, or interrupt.
 */

declare  var Windows$Devices$Usb$UsbEndpointType: {|
  +control: 0,// 0
+isochronous: 1,// 1
+bulk: 2,// 2
+interrupt: 3,// 3

|};



/**
 * Provides information about the USB interface including its endpoints, the number of alternate settings the interface supports, and gets the entire descriptor set for those settings. It also obtains pipes associated with the endpoints that the interface supports.
 */
declare class Windows$Devices$Usb$UsbInterface  {

/**
 * Gets an array of objects that represent pipes that the host opened to communicate with bulk IN endpoints defined in the current setting of the USB interface setting.
 */
bulkInPipes: Windows$Foundation$Collections$IVectorView<Windows$Devices$Usb$UsbBulkInPipe>;

/**
 * Gets an array of objects that represent pipes that the host opened to communicate with bulk OUT endpoints defined in the current setting of the USB interface.
 */
bulkOutPipes: Windows$Foundation$Collections$IVectorView<Windows$Devices$Usb$UsbBulkOutPipe>;

/**
 * Gets an array of objects that represent descriptors for all alternate settings that are part of this USB interface.
 */
descriptors: Windows$Foundation$Collections$IVectorView<Windows$Devices$Usb$UsbDescriptor>;

/**
 * Gets the interface number that identifies the USB interface. This value is the bInterfaceNumber field of a standard USB interface descriptor.
 */
interfaceNumber: number;

/**
 * Gets an array of objects that represent alternate settings defined for the USB interface.
 */
interfaceSettings: Windows$Foundation$Collections$IVectorView<Windows$Devices$Usb$UsbInterfaceSetting>;

/**
 * Gets an array of objects that represent pipes that the host opened to communicate with interrupt IN endpoints defined in the current setting of the USB interface.
 */
interruptInPipes: Windows$Foundation$Collections$IVectorView<Windows$Devices$Usb$UsbInterruptInPipe>;

/**
 * Gets an array of objects that represent pipes that the host opened to communicate with interrupt OUT endpoints defined in the current setting of the USB interface.
 */
interruptOutPipes: Windows$Foundation$Collections$IVectorView<Windows$Devices$Usb$UsbInterruptOutPipe>
}


/**
 * Describes a USB alternate setting (of an interface) in an interface descriptor. For an explanation of an interface descriptor, see Section 9.6.5 in the Universal Serial Bus Specification:
 */
declare class Windows$Devices$Usb$UsbInterfaceDescriptor  {

/**
 * Parses the specified USB descriptor and returns alternate setting information in a UsbInterfaceDescriptor object.
 * @param descriptor A UsbDescriptor object that contains the USB interface descriptor.
 * @return A UsbInterfaceDescriptor object describes the alternate setting.
 */
static parse(
descriptor: Windows$Devices$Usb$UsbDescriptor): Windows$Devices$Usb$UsbInterfaceDescriptor;

/**
 * Retrieves information about the alternate setting in a UsbInterfaceDescriptor object that is contained in a UsbDescriptor object.
 * @param descriptor The UsbDescriptor object to parse.
 */
static tryParse(
descriptor: Windows$Devices$Usb$UsbDescriptor): {
parsed: Windows$Devices$Usb$UsbInterfaceDescriptor,
returnValue: boolean
};

/**
 * Gets the bAlternateSetting field of the USB interface descriptor. The value is a number that identifies the alternate setting defined by the interface.
 */
alternateSettingNumber: number;

/**
 * Gets the bInterfaceClass field of the USB interface descriptor. The value indicates the USB-defined class to which the interface conforms.
 */
classCode: number;

/**
 * Gets the bInterfaceNumber field of the USB interface descriptor. The value is the index that identifies the interface.
 */
interfaceNumber: number;

/**
 * Gets the bInterfaceProtocol field of the interface descriptor. The value is a USB-assigned identifier that specifies a USB-defined protocol to which the interface conforms.
 */
protocolCode: number;

/**
 * Gets the bInterfaceSubClass field of the USB interface descriptor. The value is a USB-assigned identifier that specifies a USB-defined subclass to which the interface.
 */
subclassCode: number
}


/**
 * Provides information about an alternate setting and select that setting. The app can get the USB interface descriptors for the setting and its endpoints, and determine whether this setting is currently selected.
 */
declare class Windows$Devices$Usb$UsbInterfaceSetting  {

/**
 * Gets an array of objects that represent descriptors associated with USB bulk IN endpoints that are defined in the alternate setting.
 */
bulkInEndpoints: Windows$Foundation$Collections$IVectorView<Windows$Devices$Usb$UsbBulkInEndpointDescriptor>;

/**
 * Gets an array of objects that represent descriptors associated with USB bulk OUT endpoints that are defined in the alternate setting.
 */
bulkOutEndpoints: Windows$Foundation$Collections$IVectorView<Windows$Devices$Usb$UsbBulkOutEndpointDescriptor>;

/**
 * Gets an array of objects that represent descriptors associated with the alternate setting.
 */
descriptors: Windows$Foundation$Collections$IVectorView<Windows$Devices$Usb$UsbDescriptor>;

/**
 * Gets an object that represents the descriptor that describes the alternate setting.
 */
interfaceDescriptor: Windows$Devices$Usb$UsbInterfaceDescriptor;

/**
 * Gets an array of objects that represent descriptors associated with USB interrupt IN endpoints that are defined in the alternate setting.
 */
interruptInEndpoints: Windows$Foundation$Collections$IVectorView<Windows$Devices$Usb$UsbInterruptInEndpointDescriptor>;

/**
 * Gets an array of objects that represent descriptors associated with USB interrupt OUT endpoints that are defined in the alternate setting.
 */
interruptOutEndpoints: Windows$Foundation$Collections$IVectorView<Windows$Devices$Usb$UsbInterruptOutEndpointDescriptor>;

/**
 * Selects the alternate setting as the current setting in the USB interface.
 * @return An IAsyncAction object that is used to control the asynchronous operation.
 */
selectSettingAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Determines whether the alternate setting is currently selected.
 */
selected: boolean
}


/**
 * The endpoint descriptor for a USB interrupt IN endpoint. The descriptor specifies the endpoint type, direction, number and also the maximum number of bytes that can be read from the endpoint, in a single transfer. The app can also get information about how often the host polls the endpoint for data.
 */
declare class Windows$Devices$Usb$UsbInterruptInEndpointDescriptor  {

/**
 * Gets the USB endpoint number of the interrupt IN endpoint.
 */
endpointNumber: number;

/**
 * Gets the poling interval of the USB interrupt endpoint.
 */
interval: number;

/**
 * Gets the maximum number of bytes that can be sent to or received (in a packet) from this endpoint.
 */
maxPacketSize: number;

/**
 * Gets the object that represents the pipe that the host opens to communicate with the interrupt IN endpoint.
 */
pipe: Windows$Devices$Usb$UsbInterruptInPipe
}


/**
 * Represents the object that is passed as a parameter to the event handler for the DataReceived event.
 */
declare class Windows$Devices$Usb$UsbInterruptInEventArgs  {

/**
 * Gets data from the interrupt IN endpoint.
 */
interruptData: Windows$Storage$Streams$IBuffer
}


/**
 * Represents the pipe that the underlying USB driver opens to communicate with a USB interrupt IN endpoint of the device. The object also enables the app to specify an event handler. That handler that gets invoked when data is read from the endpoint.
 */
declare class Windows$Devices$Usb$UsbInterruptInPipe  {

/**
 * Starts an asynchronous operation to clear a stall condition (endpoint halt) on the USB interrupt IN endpoint that is associated with the pipe.
 * @return An IAsyncAction object that is used to control the asynchronous operation.
 */
clearStallAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the object that represents the endpoint descriptor associated with the USB interrupt IN endpoint.
 */
endpointDescriptor: Windows$Devices$Usb$UsbInterruptInEndpointDescriptor;

/**
 * Raised when the interrupt pipe receives data from the interrupt IN endpoint.
 */
ondatareceived: Windows$Foundation$TypedEventHandler<Windows$Devices$Usb$UsbInterruptInPipe, Windows$Devices$Usb$UsbInterruptInEventArgs>;
addEventListener(
type: "datareceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Usb$UsbInterruptInPipe, Windows$Devices$Usb$UsbInterruptInEventArgs>): void;
removeEventListener(
type: "datareceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$Usb$UsbInterruptInPipe, Windows$Devices$Usb$UsbInterruptInEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * The endpoint descriptor for a USB interrupt OUT endpoint. The descriptor specifies the endpoint type, direction, number and also the maximum number of bytes that can be written to the endpoint, in a single transfer. The app can also get information about how often the host polls the endpoint to send data.
 */
declare class Windows$Devices$Usb$UsbInterruptOutEndpointDescriptor  {

/**
 * Gets the USB endpoint number of the interrupt OUT endpoint.
 */
endpointNumber: number;

/**
 * Gets the poling interval of the USB interrupt endpoint.
 */
interval: number;

/**
 * Gets the maximum number of bytes that can be sent to or received from this endpoint.
 */
maxPacketSize: number;

/**
 * Gets the object that represents the pipe that the host opens to communicate with the interrupt OUT endpoint.
 */
pipe: Windows$Devices$Usb$UsbInterruptOutPipe
}


/**
 * Represents the pipe that the underlying USB driver opens to communicate with a USB interrupt OUT endpoint of the device. The object provides access to an output stream to which the app can write data to send to the endpoint.
 */
declare class Windows$Devices$Usb$UsbInterruptOutPipe  {

/**
 * Starts an asynchronous operation to clear a stall condition (endpoint halt) on the USB interrupt OUT endpoint that is associated with the pipe.
 * @return An IAsyncAction object that is used to control the asynchronous operation.
 */
clearStallAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the object that represents the endpoint descriptor associated with the USB interrupt OUT endpoint.
 */
endpointDescriptor: Windows$Devices$Usb$UsbInterruptOutEndpointDescriptor;

/**
 * Gets an output stream to which the app can write data to send to the endpoint.
 */
outputStream: Windows$Storage$Streams$IOutputStream;

/**
 * Gets or sets configuration flags that controls the behavior of the pipe that writes data to a USB interrupt OUT endpoint.
 */
writeOptions: $Values<typeof Windows$Devices$Usb$UsbWriteOptions>
}


/**
 * Defines constants for configuration flags that can be set for a USB pipe that the host opens for a USB bulk IN endpoint.
 */

declare  var Windows$Devices$Usb$UsbReadOptions: {|
  +none: 0,// 0
+autoClearStall: 1,// 1
+overrideAutomaticBufferManagement: 2,// 2
+ignoreShortPacket: 3,// 3
+allowPartialReads: 4,// 4

|};



/**
 * Describes the setup packet for a USB control transfer. For an explanation of the setup packet, see Table 9.2 in the Universal Serial Bus (USB) specification.
 */
declare class Windows$Devices$Usb$UsbSetupPacket  {

/**
 * Creates a UsbSetupPacket object.
 */
constructor(): this;

/**
 * Creates a UsbSetupPacket object from a formatted buffer (eight bytes) that contains the setup packet.
 * @param eightByteBuffer A caller-supplied buffer that contains the setup packet formatted as per the standard USB specification. The length of the buffer must be eight bytes because that is the size of a setup packet on the bus.
 */
constructor(eightByteBuffer: Windows$Storage$Streams$IBuffer): this;

/**
 * Gets or sets the wIndex field in the setup packet of the USB control transfer.
 */
index: number;

/**
 * Gets the length, in bytes, of the setup packet.
 */
length: number;

/**
 * Gets or sets the bRequest field in the setup packet of the USB control transfer.
 */
request: number;

/**
 * Gets or sets the bmRequestType field in the setup packet of the USB control transfer. That field is represented by a UsbControlRequestType object.
 */
requestType: Windows$Devices$Usb$UsbControlRequestType;

/**
 * Gets or sets the wValue field in the setup packet of the USB control transfer.
 */
value: number
}


/**
 * Defines constants that indicate the direction of USB transfer: IN or OUT transfers.
 */

declare  var Windows$Devices$Usb$UsbTransferDirection: {|
  +out: 0,// 0
+in: 1,// 1

|};



/**
 * Defines constants for configuration flags that can be set for a USB pipe that the host opens for a USB OUT endpoint.
 */

declare  var Windows$Devices$Usb$UsbWriteOptions: {|
  +none: 0,// 0
+autoClearStall: 1,// 1
+shortPacketTerminate: 2,// 2

|};



      declare var npm$namespace$Windows$Devices$WiFi: {
        
        irect: typeof Windows$Devices$WiFi$irect,
        WiFiAccessStatus: typeof Windows$Devices$WiFi$WiFiAccessStatus,
WiFiConnectionStatus: typeof Windows$Devices$WiFi$WiFiConnectionStatus,
WiFiNetworkKind: typeof Windows$Devices$WiFi$WiFiNetworkKind,
WiFiPhyKind: typeof Windows$Devices$WiFi$WiFiPhyKind,
WiFiReconnectionKind: typeof Windows$Devices$WiFi$WiFiReconnectionKind,
        WiFiAdapter: typeof Windows$Devices$WiFi$WiFiAdapter,
WiFiAvailableNetwork: typeof Windows$Devices$WiFi$WiFiAvailableNetwork,
WiFiConnectionResult: typeof Windows$Devices$WiFi$WiFiConnectionResult,
WiFiNetworkReport: typeof Windows$Devices$WiFi$WiFiNetworkReport,
        
      }

/**
 * Used to report the results of an attempt to request access to a Wi-Fi adapter.
 */

declare  var Windows$Devices$WiFi$WiFiAccessStatus: {|
  +unspecified: 0,// 0
+allowed: 1,// 1
+deniedByUser: 2,// 2
+deniedBySystem: 3,// 3

|};



/**
 * Use this class to enumerate local Wi-Fi adapters, initiate Wi-Fi scans, enumerate scan results, and to connect or disconnect individual adapters.
 */
declare class Windows$Devices$WiFi$WiFiAdapter  {

/**
 * A static method that initiates an asynchronous operation to enumerate all Wi-Fi adapters in the system.
 * @return An asynchronous enumeration operation. On successful completion, returns a list of available Wi-Fi adapters.
 */
static findAllAdaptersAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * A static method that initiates an asynchronous operation to get a WiFiAdapter object.
 * @param deviceId The Device ID of the Wi-Fi adapter to be retrieved. Obtain a Device ID through the Windows.Devices.Enumeration namespace.
 * @return An asynchronous get operation. On successful completion, returns a WiFiAdapter object specific to the requested Device ID.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$WiFi$WiFiAdapter>;

/**
 * A static method that returns an Advanced Query Syntax (AQS) string to be used to enumerate Wi-Fi adapters using Windows.Devices.Enumeration.DeviceInformation.FindAllAsync and related methods.
 * @return An identifier to be used to enumerate Wi-Fi devices.
 */
static getDeviceSelector(): string;

/**
 * A static method for determining whether the current user can access any of the Wi-Fi adapters on this device.
 * @return An asynchronous access operation. On successful completion, returns a status enumeration value describing whether the current user can access any Wi-Fi adapter.
 */
static requestAccessAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Devices$WiFi$WiFiAccessStatus>>;

/**
 * Connect this Wi-Fi device to the specified network, with the specified reconnection policy.
 * @param availableNetwork Describes the Wi-Fi network to be connected.
 * @param reconnectionKind Specifies how to reconnect if the connection is lost.
 * @return An asynchronous connect operation. On successful conclusion of the operation, returns an object that describes the result of the connect operation.
 */
connectAsync(
availableNetwork: Windows$Devices$WiFi$WiFiAvailableNetwork,
reconnectionKind: $Values<typeof Windows$Devices$WiFi$WiFiReconnectionKind>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$WiFi$WiFiConnectionResult>;

/**
 * Connect this Wi-Fi device to the specified network, with the specified passphrase and reconnection policy.
 * @param availableNetwork Specifies the Wi-Fi network to connect to.
 * @param reconnectionKind Describes how to reconnect to the network if connection is lost.
 * @param passwordCredential The passphrase to be used to connect to the access point.
 * @return An asynchronous connect operation. On successful conclusion of the operation, returns an object that describes the result of the connect operation.
 */
connectAsync(
availableNetwork: Windows$Devices$WiFi$WiFiAvailableNetwork,
reconnectionKind: $Values<typeof Windows$Devices$WiFi$WiFiReconnectionKind>,
passwordCredential: Windows$Security$Credentials$PasswordCredential): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$WiFi$WiFiConnectionResult>;

/**
 * Connect this Wi-Fi device to a hidden network, with the given passphrase and reconnection policy.
 * @param availableNetwork Describes the Wi-Fi network to connect to.
 * @param reconnectionKind Describes how to reconnect to the network if connection is lost.
 * @param passwordCredential Password or other credential to use to connect to the network.
 * @param ssid When the network SSID is hidden, use this parameter to provide the SSID.
 * @return An asynchronous connect operation. On successful conclusion of the operation, returns an object that describes the result of the connect operation.
 */
connectAsync(
availableNetwork: Windows$Devices$WiFi$WiFiAvailableNetwork,
reconnectionKind: $Values<typeof Windows$Devices$WiFi$WiFiReconnectionKind>,
passwordCredential: Windows$Security$Credentials$PasswordCredential,
ssid: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$WiFi$WiFiConnectionResult>;

/**
 * Disconnects any active Wi-Fi connection through this adapter.
 */
disconnect(): void;

/**
 * Gets information about a Wi-Fi adapter.
 */
networkAdapter: Windows$Networking$Connectivity$NetworkAdapter;

/**
 * Gets a list of available networks populated by the last Wi-Fi scan on this WiFiNetworkAdapter.
 */
networkReport: Windows$Devices$WiFi$WiFiNetworkReport;

/**
 * Event raised when a scan completes on this Wi-Fi adapter. This even cannot be raised from a background task.
 */
onavailablenetworkschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFi$WiFiAdapter, any>;
addEventListener(
type: "availablenetworkschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFi$WiFiAdapter, any>): void;
removeEventListener(
type: "availablenetworkschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFi$WiFiAdapter, any>): void;

/**
 * Directs this adapter to initiate an asynchronous network scan.
 * @return An asynchronous scan operation. On successful completion, returns a list of networks scanned by this adapter.
 */
scanAsync(): Windows$Foundation$IPromiseWithIAsyncAction;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Describes an available Wi-Fi network.
 */
declare class Windows$Devices$WiFi$WiFiAvailableNetwork  {

/**
 * Gets the interval between 802.11 Beacon frames used by this network.
 */
beaconInterval: number;

/**
 * Gets the MAC address of the access point.
 */
bssid: string;

/**
 * Gets the channel center frequency of the band on which the 802.11 Beacon or Probe Response was received.
 */
channelCenterFrequencyInKilohertz: number;

/**
 * Gets a value indicating whether this network originates from a Wi-Fi Direct access point.
 */
isWiFiDirect: boolean;

/**
 * Gets a value describing the kind of network being described.
 */
networkKind: $Values<typeof Windows$Devices$WiFi$WiFiNetworkKind>;

/**
 * Gets the signal strength of the network.
 */
networkRssiInDecibelMilliwatts: number;

/**
 * Gets a value describing the kind of PHY used by this network.
 */
phyKind: $Values<typeof Windows$Devices$WiFi$WiFiPhyKind>;

/**
 * Gets the security configuration of the network.
 */
securitySettings: Windows$Networking$Connectivity$NetworkSecuritySettings;

/**
 * Gets the strength of the signal as a number of bars.
 */
signalBars: number;

/**
 * Gets the SSID (name) of the network.
 */
ssid: string;

/**
 * Gets the uptime value reported by the network.
 */
uptime: number
}


/**
 * Describes the results of an attempt to connect to a Wi-Fi network.
 */
declare class Windows$Devices$WiFi$WiFiConnectionResult  {

/**
 * Gets the connection result value.
 */
connectionStatus: $Values<typeof Windows$Devices$WiFi$WiFiConnectionStatus>
}


/**
 * Status of the connection attempt.
 */

declare  var Windows$Devices$WiFi$WiFiConnectionStatus: {|
  +unspecifiedFailure: 0,// 0
+success: 1,// 1
+accessRevoked: 2,// 2
+invalidCredential: 3,// 3
+networkNotAvailable: 4,// 4
+timeout: 5,// 5
+unsupportedAuthenticationProtocol: 6,// 6

|};



/**
 * Describes the kinds of Wi-Fi networks.
 */

declare  var Windows$Devices$WiFi$WiFiNetworkKind: {|
  +any: 0,// 0
+infrastructure: 1,// 1
+adhoc: 2,// 2

|};



/**
 * Contains the result of a network scan operation.
 */
declare class Windows$Devices$WiFi$WiFiNetworkReport  {

/**
 * A list of available networks.
 */
availableNetworks: Windows$Foundation$Collections$IVectorView<Windows$Devices$WiFi$WiFiAvailableNetwork>;

/**
 * Contains the result of a network scan operation.
 */
timestamp: Date
}


/**
 * Describes PHY types supported by standard 802.11.
 */

declare  var Windows$Devices$WiFi$WiFiPhyKind: {|
  +unknown: 0,// 0
+fhss: 1,// 1
+dsss: 2,// 2
+irBaseband: 3,// 3
+ofdm: 4,// 4
+hrdsss: 5,// 5
+erp: 6,// 6
+ht: 7,// 7
+vht: 8,// 8

|};



/**
 * Describes whether to automatically reconnect to this network.
 */

declare  var Windows$Devices$WiFi$WiFiReconnectionKind: {|
  +automatic: 0,// 0
+manual: 1,// 1

|};


declare var Windows$Devices$WiFi$irect: any;


      declare var npm$namespace$Windows$Devices$WiFiDirect: {
        
        
        WiFiDirectAdvertisementListenStateDiscoverability: typeof Windows$Devices$WiFiDirect$WiFiDirectAdvertisementListenStateDiscoverability,
WiFiDirectAdvertisementPublisherStatus: typeof Windows$Devices$WiFiDirect$WiFiDirectAdvertisementPublisherStatus,
WiFiDirectConfigurationMethod: typeof Windows$Devices$WiFiDirect$WiFiDirectConfigurationMethod,
WiFiDirectConnectionStatus: typeof Windows$Devices$WiFiDirect$WiFiDirectConnectionStatus,
WiFiDirectDeviceSelectorType: typeof Windows$Devices$WiFiDirect$WiFiDirectDeviceSelectorType,
WiFiDirectError: typeof Windows$Devices$WiFiDirect$WiFiDirectError,
WiFiDirectPairingProcedure: typeof Windows$Devices$WiFiDirect$WiFiDirectPairingProcedure,
        WiFiDirectAdvertisement: typeof Windows$Devices$WiFiDirect$WiFiDirectAdvertisement,
WiFiDirectAdvertisementPublisher: typeof Windows$Devices$WiFiDirect$WiFiDirectAdvertisementPublisher,
WiFiDirectAdvertisementPublisherStatusChangedEventArgs: typeof Windows$Devices$WiFiDirect$WiFiDirectAdvertisementPublisherStatusChangedEventArgs,
WiFiDirectConnectionListener: typeof Windows$Devices$WiFiDirect$WiFiDirectConnectionListener,
WiFiDirectConnectionParameters: typeof Windows$Devices$WiFiDirect$WiFiDirectConnectionParameters,
WiFiDirectConnectionRequest: typeof Windows$Devices$WiFiDirect$WiFiDirectConnectionRequest,
WiFiDirectConnectionRequestedEventArgs: typeof Windows$Devices$WiFiDirect$WiFiDirectConnectionRequestedEventArgs,
WiFiDirectDevice: typeof Windows$Devices$WiFiDirect$WiFiDirectDevice,
WiFiDirectInformationElement: typeof Windows$Devices$WiFiDirect$WiFiDirectInformationElement,
WiFiDirectLegacySettings: typeof Windows$Devices$WiFiDirect$WiFiDirectLegacySettings,
        Services: typeof npm$namespace$Windows$Devices$WiFiDirect$Services,
      }

      declare var npm$namespace$Windows$Devices$WiFiDirect$Services: {
        
        
        WiFiDirectServiceAdvertisementStatus: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAdvertisementStatus,
WiFiDirectServiceConfigurationMethod: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceConfigurationMethod,
WiFiDirectServiceError: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceError,
WiFiDirectServiceIPProtocol: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceIPProtocol,
WiFiDirectServiceSessionErrorStatus: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionErrorStatus,
WiFiDirectServiceSessionStatus: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionStatus,
WiFiDirectServiceStatus: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceStatus,
        WiFiDirectService: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectService,
WiFiDirectServiceAdvertiser: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAdvertiser,
WiFiDirectServiceAutoAcceptSessionConnectedEventArgs: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAutoAcceptSessionConnectedEventArgs,
WiFiDirectServiceProvisioningInfo: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceProvisioningInfo,
WiFiDirectServiceRemotePortAddedEventArgs: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceRemotePortAddedEventArgs,
WiFiDirectServiceSession: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSession,
WiFiDirectServiceSessionDeferredEventArgs: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionDeferredEventArgs,
WiFiDirectServiceSessionRequest: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionRequest,
WiFiDirectServiceSessionRequestedEventArgs: typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionRequestedEventArgs,
        
      }

/**
 * Represents a Wi-Fi Direct service. This class is used by code on a device that seeks to use a Wi-Fi Direct Service, to establish a Wi-Fi Direct Service session with the service provider.
 */
declare class Windows$Devices$WiFiDirect$Services$WiFiDirectService  {

/**
 * Static method that retrieves a WiFiDirectService instance for a Wi-Fi Direct Service offered by the device with a given device ID.
 * @param deviceId Device ID of the device that advertises the desired Wi-Fi Direct Service.
 * @return An asynchronous retrieval operation. On successful completion, returns an instance of WiFiDirectService specific to the desired service instance, advertised by the indicated device.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$WiFiDirect$Services$WiFiDirectService>;

/**
 * Gets an Advanced Query Syntax (AQS) string to be used to find Wi-Fi Direct Service advertisers for a particular service.
 * @param serviceName The service name to be found.
 * @return The AQS string for the requested advertiser query.
 */
static getSelector(serviceName: string): string;

/**
 * Gets an Advanced Query Syntax (AQS) string to be used to find Wi-Fi Direct Service advertisers for a particular service, where a given byte sequence appears in the advertiser's service information blob.
 * @param serviceName The service name to be found.
 * @param serviceInfoFilter A byte sequence that must be found in the advertiser's service information blob.
 * @return The AQS string for the requested advertiser query.
 */
static getSelector(
serviceName: string,
serviceInfoFilter: Windows$Storage$Streams$IBuffer): string;

/**
 * Initiates the establishment of a service session with the Wi-Fi Direct Service represented by this instance.
 * @return An asynchronous connection operation. When successfully completed, returns an object that represents the session that has been established.
 */
connectAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSession>;

/**
 * Initiates the establishment of a service session with the Wi-Fi Direct Service represented by this instance, using a PIN to configure the session.
 * @param pin The PIN to be used to configure the connection.
 * @return An asynchronous connection operation. When successfully completed, returns an object that represents the session that has been established.
 */
connectAsync(
pin: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSession>;

/**
 * Asynchronously retrieves Wi-Fi Direct Service session provisioning information.
 * @param selectedConfigurationMethod The preferred method of configuring the session.
 * @return An asynchronous retrieval operation. On successful completion, returns provisioning information.
 */
getProvisioningInfoAsync(
selectedConfigurationMethod: $Values<typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceConfigurationMethod>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceProvisioningInfo>;

/**
 * Event raised when a session request has been deferred. Note that this does not mean that the request has failed or been denied. It is a notification that the server is performing a long operation, such as waiting for a user to enter a PIN. The seeker that receives this message should begin a 120-second wait before it times out the session request, to give the server time to complete its operation. The event arguments include a buffer supplied by the server in the deferral notification with additional information.
 */
onsessiondeferred: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectService, Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionDeferredEventArgs>;
addEventListener(
type: "sessiondeferred",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectService, Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionDeferredEventArgs>): void;
removeEventListener(
type: "sessiondeferred",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectService, Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionDeferredEventArgs>): void;

/**
 * Gets or sets a value specifying whether the service instance should choose Wi-Fi Direct Point to Point (P2P) Group Owner (GO) mode.
 */
preferGroupOwnerMode: boolean;

/**
 * Gets the service information blob from this service instance.
 */
remoteServiceInfo: Windows$Storage$Streams$IBuffer;

/**
 * Error information about the latest attempt to connect to the service.
 */
serviceError: $Values<typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceError>;

/**
 * Gets or sets app-specific session information passed to the server when initiating a session.
 */
sessionInfo: Windows$Storage$Streams$IBuffer;

/**
 * Gets a list of supported configuration methods, ordered by preference. Your code uses IVector operations to modify the contents of the list.
 */
supportedConfigurationMethods: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceConfigurationMethod>>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Values used for WiFiDirectServiceAdvertiser.AdvertisementStatus .
 */

declare  var Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAdvertisementStatus: {|
  +created: 0,// 0
+started: 1,// 1
+stopped: 2,// 2
+aborted: 3,// 3

|};



/**
 * Represents a Service Advertiser. This class is used by code on a device that advertises Wi-Fi Direct Services, to advertise the service.
 */
declare class Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAdvertiser  {

/**
 * Creates an instance of the WiFiDirectServiceAdvertiser class. To start advertising a Wi-Fi Direct Service, create an instance of this class, set its properties appropriately for your service, and then call its Start method.
 * @param serviceName The name of the service to be advertised. Service names are UTF-8 strings no more than 255 characters long. It is recommended that names use reverse domain name notation, where the service owner's DNS name (such as "contoso.com") is reversed and used as the beginning of the service name (such as "com.contoso.serviceX"). This convention is intended to make it easy to choose unique service names. Service names that start with "org.wi-fi.wfds" are reserved for use by the Wi-Fi Alliance, and you may not use such names for your service.
 */
constructor(serviceName: string): this;

/**
 * Gets a value that describes the current status of the advertisement.
 */
advertisementStatus: $Values<typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAdvertisementStatus>;

/**
 * Gets or sets the Auto Accept property for this service advertisement.
 */
autoAcceptSession: boolean;

/**
 * Accepts a session request by connecting with the given PIN.
 * @param deviceInfo Describes the device to be connected. Pass in the WiFiDirectServiceSessionRequestedEventArgs.DeviceInformation property value.
 * @param pin The PIN to be used to configure the session.
 * @return An asynchronous connection operation. On successful completion, returns an object that describes the session that has been created.
 */
connectAsync(
deviceInfo: Windows$Devices$Enumeration$DeviceInformation,
pin: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSession>;

/**
 * Accepts a session request without requiring a PIN.
 * @param deviceInfo Describes the device to be connected. Pass in the WiFiDirectServiceSessionRequestedEventArgs.DeviceInformation property value.
 * @return An asynchronous connection operation. On successful completion, returns an object that describes the session that has been created.
 */
connectAsync(
deviceInfo: Windows$Devices$Enumeration$DeviceInformation): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSession>;

/**
 * Gets or sets a custom service status code. Only valid if the ServiceStatus property value is Custom.
 */
customServiceStatusCode: number;

/**
 * Gets or sets the service-specific information that is passed to a session requester when establishing a session will not be completed immediately, as when, for example, the service is waiting for user input to complete the request. A requester should implement a 120 second timeout when its request is deferred.
 */
deferredSessionInfo: Windows$Storage$Streams$IBuffer;

/**
 * Event raised when the AdvertisementStatus property value changes.
 */
onadvertisementstatuschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAdvertiser, any>;
addEventListener(
type: "advertisementstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAdvertiser, any>): void;
removeEventListener(
type: "advertisementstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAdvertiser, any>): void;

/**
 * Event raised when the service has automatically accepted a session request. Your event handler should establish socket connections for the endpoint pairs listed in the event arguments object.
 */
onautoacceptsessionconnected: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAdvertiser, Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAutoAcceptSessionConnectedEventArgs>;
addEventListener(
type: "autoacceptsessionconnected",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAdvertiser, Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAutoAcceptSessionConnectedEventArgs>): void;
removeEventListener(
type: "autoacceptsessionconnected",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAdvertiser, Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAutoAcceptSessionConnectedEventArgs>): void;

/**
 * Event raised when a Seeker has requested that a session be established with the service associated with this WiFiDirectServiceAdvertiser instance. To accept the request, call WiFiDirectServiceAdvertiser.ConnectAsync in your event handler.
 */
onsessionrequested: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAdvertiser, Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionRequestedEventArgs>;
addEventListener(
type: "sessionrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAdvertiser, Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionRequestedEventArgs>): void;
removeEventListener(
type: "sessionrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAdvertiser, Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionRequestedEventArgs>): void;

/**
 * Gets or sets a value indicating whether the service requires that it be the Wi-Fi Direct Peer to Peer (P2P) Group Owner.
 */
preferGroupOwnerMode: boolean;

/**
 * Gets a list (that implements the IVector interface) of preferred session configuration methods. Your code uses IVector operations on the list to add or remove elements from the list.
 */
preferredConfigurationMethods: Windows$Foundation$Collections$IVector<$Values<typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceConfigurationMethod>>;

/**
 * Gets a specific error code when AdvertisementStatus is Aborted.
 */
serviceError: $Values<typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceError>;

/**
 * Gets or sets the service information blob. The format and contents of the blob are determined by the individual service, and are intended to be used by Seekers during service discovery.
 */
serviceInfo: Windows$Storage$Streams$IBuffer;

/**
 * Gets the service name.
 */
serviceName: string;

/**
 * Gets a list of service name prefixes that should match this service when a seeker is using prefix searching. Your code uses IVector methods to add or remove elements from the list.
 */
serviceNamePrefixes: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets or sets the service status.
 */
serviceStatus: $Values<typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceStatus>;

/**
 * Starts advertising the service, using current property values to set the parameters of the advertisement.
 */
start(): void;

/**
 * Stops advertising the service. This does not affect existing sessions that are connected to the service.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Returned when a WiFiDirectServiceAdvertiser.AutoAcceptSessionConnected event is raised.
 */
declare class Windows$Devices$WiFiDirect$Services$WiFiDirectServiceAutoAcceptSessionConnectedEventArgs  {

/**
 * Gets the WiFiDirectServiceSession that was created when the connection was automatically accepted.
 */
session: Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSession;

/**
 * Gets the session information buffer that corresponds to this automatically accepted connection.
 */
sessionInfo: Windows$Storage$Streams$IBuffer
}


/**
 * Values describing how service configuration is performed when a session is being established. Typically, either no input is required, or one device in the session displays a PIN and the other device requires that the PIN be entered.
 */

declare  var Windows$Devices$WiFiDirect$Services$WiFiDirectServiceConfigurationMethod: {|
  +default: 0,// 0
+pinDisplay: 1,// 1
+pinEntry: 2,// 2

|};



/**
 * Values used for the WiFiDirectServiceAdvertiser.ServiceError property.
 */

declare  var Windows$Devices$WiFiDirect$Services$WiFiDirectServiceError: {|
  +success: 0,// 0
+radioNotAvailable: 1,// 1
+resourceInUse: 2,// 2
+unsupportedHardware: 3,// 3
+noHardware: 4,// 4

|};



/**
 * Values that specify the IP protocol of the new port when a WiFiDirectServiceSession.RemotePortAdded event is raised.
 */

declare  var Windows$Devices$WiFiDirect$Services$WiFiDirectServiceIPProtocol: {|
  +tcp: 0,// 0
+udp: 1,// 1

|};



/**
 * Contains provisioning information about a Wi-Fi Direct Service.
 */
declare class Windows$Devices$WiFiDirect$Services$WiFiDirectServiceProvisioningInfo  {

/**
 * Gets a value indicating whether Wi-Fi Direct Point to Point (P2P) group formation is needed.
 */
isGroupFormationNeeded: boolean;

/**
 * Gets a value describing the configuration method in use.
 */
selectedConfigurationMethod: $Values<typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceConfigurationMethod>
}


/**
 * Returned when a WiFiDirectServiceSession.RemotePortAdded event is raised. Your event handler should use this information to establish new socket connections to the new port.
 */
declare class Windows$Devices$WiFiDirect$Services$WiFiDirectServiceRemotePortAddedEventArgs  {

/**
 * Gets the endpoint pairs associated with the new remote port.
 */
endpointPairs: Windows$Foundation$Collections$IVectorView<Windows$Networking$EndpointPair>;

/**
 * Gets the protocol used to communicate with the new remote port.
 */
protocol: $Values<typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceIPProtocol>
}


/**
 * Represents a Wi-Fi Direct Services (WFDS) session.
 */
declare class Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSession  {

/**
 * Adds a DatagramSocket to the session. Your code creates the DatagramSocket before calling this method. Associating a socket to the session causes port information to be sent to the remote device(s) in the session. (In terms of this API, a RemotePortAdded event is raised on each remote device in the session, specifying the UDP protocol.) A remote device can use that information to open a socket and connect back to the local machine.
 * @param value The DatagramSocket instance to associate with this session.
 * @return An asynchronous association action. Returns on successful completion of the association.
 */
addDatagramSocketAsync(
value: Windows$Networking$Sockets$DatagramSocket): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Adds a StreamSocketListener to the session. Your code creates the StreamSocketListener before calling this method. Associating a socket to the session causes port information to be sent to the remote device(s) in the session. (In terms of this API, a RemotePortAdded event is raised on each remote device in the session, specifying the TCP protocol.) A remote device can use that information to open a socket and connect back to the local machine.
 * @param value The StreamSocketListener instance to be associated with the session.
 * @return An asynchronous association action. Returns on successful completion of the association.
 */
addStreamSocketListenerAsync(
value: Windows$Networking$Sockets$StreamSocketListener): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the advertisement ID for the session.
 */
advertisementId: number;

/**
 * Closes the session.
 */
close(): void;

/**
 * Gets the error status of the session.
 */
errorStatus: $Values<typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionErrorStatus>;

/**
 * Gets a list of connection endpoint pairs for the session. Your code uses IVectorView operations to enumerate the endpoint pairs in the list.
 * @return An immutable snapshot list of endpoint pairs involved in the session.
 */
getConnectionEndpointPairs(): Windows$Foundation$Collections$IVectorView<Windows$Networking$EndpointPair>;

/**
 * Event raised when a new remote port is added to the session. Your event handler should respond by establishing the appropriate socket connection to the new remote port.
 */
onremoteportadded: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSession, Windows$Devices$WiFiDirect$Services$WiFiDirectServiceRemotePortAddedEventArgs>;
addEventListener(
type: "remoteportadded",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSession, Windows$Devices$WiFiDirect$Services$WiFiDirectServiceRemotePortAddedEventArgs>): void;
removeEventListener(
type: "remoteportadded",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSession, Windows$Devices$WiFiDirect$Services$WiFiDirectServiceRemotePortAddedEventArgs>): void;

/**
 * Event raised when the session status changes.
 */
onsessionstatuschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSession, any>;
addEventListener(
type: "sessionstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSession, any>): void;
removeEventListener(
type: "sessionstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSession, any>): void;

/**
 * Gets the service address for this session.
 */
serviceAddress: string;

/**
 * Gets the service name of the advertiser service involved in the session.
 */
serviceName: string;

/**
 * Gets the session address for the session.
 */
sessionAddress: string;

/**
 * Gets the session ID.
 */
sessionId: number;

/**
 * Gets the session status.
 */
status: $Values<typeof Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionStatus>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Returned when a WiFiDirectService.SessionDeferred event is raised.
 */
declare class Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionDeferredEventArgs  {

/**
 * Gets the service-defined session information returned by the service when it sends a deferral in response to a connection request. Note that a deferral does not indicate that the connection is refused. Rather, it indicates that the server is performing a time-consuming operation such as requesting user input. A seeker should implement a 120-second timeout after getting a deferral before giving up on the request.
 */
deferredSessionInfo: Windows$Storage$Streams$IBuffer
}


/**
 * Values used in the WiFiDirectServiceSession.ErrorStatus property.
 */

declare  var Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionErrorStatus: {|
  +ok: 0,// 0
+disassociated: 1,// 1
+localClose: 2,// 2
+remoteClose: 3,// 3
+systemFailure: 4,// 4
+noResponseFromRemote: 5,// 5

|};



/**
 * Describes a Wi-Fi Direct Service session request.
 */
declare class Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionRequest  {

/**
 * Closes the session request. Your server code calls this method to reject a session request.
 */
close(): void;

/**
 * Gets device information for the requesting device.
 */
deviceInformation: Windows$Devices$Enumeration$DeviceInformation;

/**
 * Gets information about how provisioning should be performed if the session is established.
 */
provisioningInfo: Windows$Devices$WiFiDirect$Services$WiFiDirectServiceProvisioningInfo;

/**
 * Gets the session information blob associated with this request.
 */
sessionInfo: Windows$Storage$Streams$IBuffer
}


/**
 * Returned when a WiFiDirectServiceAdvertiser.SessionRequested event is raised.
 */
declare class Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionRequestedEventArgs  {

/**
 * Gets information about the session request that raised a WiFiDirectServiceAdvertiser.SessionRequested event.
 * @return Information about a new session request.
 */
getSessionRequest(): Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionRequest
}


/**
 * Values used to describe the status of a Wi-Fi Direct Service Session.
 */

declare  var Windows$Devices$WiFiDirect$Services$WiFiDirectServiceSessionStatus: {|
  +closed: 0,// 0
+initiated: 1,// 1
+requested: 2,// 2
+open: 3,// 3

|};



/**
 * Values used to describe the service status.
 */

declare  var Windows$Devices$WiFiDirect$Services$WiFiDirectServiceStatus: {|
  +available: 0,// 0
+busy: 1,// 1
+custom: 2,// 2

|};



/**
 * Represent a Wi-Fi Direct advertisement and allows the app to control the listen state and custom information elements in the advertisement.
 */
declare class Windows$Devices$WiFiDirect$WiFiDirectAdvertisement  {

/**
 * Information elements to advertise in the Wi-Fi Direct advertisement.
 */
informationElements: Windows$Foundation$Collections$IVector<Windows$Devices$WiFiDirect$WiFiDirectInformationElement>;

/**
 * Whether autonomous group owner will be enabled.
 */
isAutonomousGroupOwnerEnabled: boolean;

/**
 * Gets the settings object for "legacy" (non-Wi-Fi Direct) connections.
 */
legacySettings: Windows$Devices$WiFiDirect$WiFiDirectLegacySettings;

/**
 * Gets or sets the listen state and whether the Wi-Fi Direct device is discoverable.
 */
listenStateDiscoverability: $Values<typeof Windows$Devices$WiFiDirect$WiFiDirectAdvertisementListenStateDiscoverability>;

/**
 * Gets a device's supported configuration methods.
 */
supportedConfigurationMethods: Windows$Foundation$Collections$IVector<$Values<typeof Windows$Devices$WiFiDirect$WiFiDirectConfigurationMethod>>
}


/**
 * Specifies whether the Wi-Fi Direct device is listening and discoverable.
 */

declare  var Windows$Devices$WiFiDirect$WiFiDirectAdvertisementListenStateDiscoverability: {|
  +none: 0,// 0
+normal: 1,// 1
+intensive: 2,// 2

|};



/**
 * An object to publish Wi-Fi Direct advertisements.
 */
declare class Windows$Devices$WiFiDirect$WiFiDirectAdvertisementPublisher  {

/**
 * Creates a new WiFiDirectAdvertisementPublisher object.
 */
constructor(): this;

/**
 * Gets the Wi-Fi Direct advertisement to publish.
 */
advertisement: Windows$Devices$WiFiDirect$WiFiDirectAdvertisement;

/**
 * Notification that the status of the WiFiDirectAdvertisementPublisher has changed.
 */
onstatuschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$WiFiDirectAdvertisementPublisher, Windows$Devices$WiFiDirect$WiFiDirectAdvertisementPublisherStatusChangedEventArgs>;
addEventListener(
type: "statuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$WiFiDirectAdvertisementPublisher, Windows$Devices$WiFiDirect$WiFiDirectAdvertisementPublisherStatusChangedEventArgs>): void;
removeEventListener(
type: "statuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$WiFiDirectAdvertisementPublisher, Windows$Devices$WiFiDirect$WiFiDirectAdvertisementPublisherStatusChangedEventArgs>): void;

/**
 * Starts the Wi-Fi Direct advertisement.
 */
start(): void;

/**
 * Gets the current status of the WiFiDirectAdvertisementPublisher .
 */
status: $Values<typeof Windows$Devices$WiFiDirect$WiFiDirectAdvertisementPublisherStatus>;

/**
 * Stops the Wi-Fi Direct advertisement.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the possible states of the WiFiDirectAdvertisementPublisher .
 */

declare  var Windows$Devices$WiFiDirect$WiFiDirectAdvertisementPublisherStatus: {|
  +created: 0,// 0
+started: 1,// 1
+stopped: 2,// 2
+aborted: 3,// 3

|};



/**
 * Provides data for a StatusChanged event on a WiFiDirectAdvertisementPublisher .
 */
declare class Windows$Devices$WiFiDirect$WiFiDirectAdvertisementPublisherStatusChangedEventArgs  {

/**
 * Gets the error status for a StatusChanged event on a WiFiDirectAdvertisementPublisher .
 */
error: $Values<typeof Windows$Devices$WiFiDirect$WiFiDirectError>;

/**
 * Gets the new status of the WiFiDirectAdvertisementPublisher .
 */
status: $Values<typeof Windows$Devices$WiFiDirect$WiFiDirectAdvertisementPublisherStatus>
}


/**
 * Specifies a Wi-Fi Direct configuration method. Configuration is how a user tells one piece of Wi-Fi Direct equipment to connect to another piece of Wi-Fi Direct equipment.
 */

declare  var Windows$Devices$WiFiDirect$WiFiDirectConfigurationMethod: {|
  +providePin: 0,// 0
+displayPin: 1,// 1
+pushButton: 2,// 2

|};



/**
 * Class used to listen for incoming Wi-Fi Direct connection requests.
 */
declare class Windows$Devices$WiFiDirect$WiFiDirectConnectionListener  {

/**
 * Creates a new WiFiDirectConnectionListener object.
 */
constructor(): this;

/**
 * Notification on an incoming Wi-Fi Direct connection request.
 */
onconnectionrequested: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$WiFiDirectConnectionListener, Windows$Devices$WiFiDirect$WiFiDirectConnectionRequestedEventArgs>;
addEventListener(
type: "connectionrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$WiFiDirectConnectionListener, Windows$Devices$WiFiDirect$WiFiDirectConnectionRequestedEventArgs>): void;
removeEventListener(
type: "connectionrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$WiFiDirectConnectionListener, Windows$Devices$WiFiDirect$WiFiDirectConnectionRequestedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Used by an app to specify the connection parameters for a Wi-Fi Direct connect/pairing operation.
 */
declare class Windows$Devices$WiFiDirect$WiFiDirectConnectionParameters  {

/**
 * Gets a list of the DevicePairingKinds supporting the given configuration method.
 * @param configurationMethod A value specifying a configuration method.
 * @return A value specifying a pairing kind, for use with the pairing functionality in the Windows.Devices.Enumeration API.
 */
static getDevicePairingKinds(
configurationMethod: $Values<typeof Windows$Devices$WiFiDirect$WiFiDirectConfigurationMethod>): $Values<typeof Windows$Devices$Enumeration$DevicePairingKinds>;

/**
 * Creates a new WiFiDirectConnectionParameters object.
 */
constructor(): this;

/**
 * The group owner intent value used for group owner negotiation in a Wi-Fi Direct connect/pairing operation.
 */
groupOwnerIntent: number;

/**
 * Gets a list of supported configuration methods, in order of preference.
 */
preferenceOrderedConfigurationMethods: Windows$Foundation$Collections$IVector<$Values<typeof Windows$Devices$WiFiDirect$WiFiDirectConfigurationMethod>>;

/**
 * Gets or sets a value specifying a device's preferred pairing procedure.
 */
preferredPairingProcedure: $Values<typeof Windows$Devices$WiFiDirect$WiFiDirectPairingProcedure>
}


/**
 * A Wi-FI Direct connection request received by a WiFiDirectConnectionListener .
 */
declare class Windows$Devices$WiFiDirect$WiFiDirectConnectionRequest  {

/**
 * Closes the WiFiDirectConnectionRequest object.
 */
close(): void;

/**
 * Gets device information for the endpoint making the Wi-Fi Direct connection request.
 */
deviceInformation: Windows$Devices$Enumeration$DeviceInformation
}


/**
 * Provides data for a ConnectionRequested event on a WiFiDirectConnectionListener .
 */
declare class Windows$Devices$WiFiDirect$WiFiDirectConnectionRequestedEventArgs  {

/**
 * Retrieves the WiFiDirectConnectionRequest received on a ConnectionRequested event by a WiFiDirectConnectionListener .
 * @return The Wi-FI Direct connection request.
 */
getConnectionRequest(): Windows$Devices$WiFiDirect$WiFiDirectConnectionRequest
}


/**
 * Describes the connection status of a WiFiDirectDevice object.
 */

declare  var Windows$Devices$WiFiDirect$WiFiDirectConnectionStatus: {|
  +disconnected: 0,// 0
+connected: 1,// 1

|};



/**
 * Manages connections to associated Wi-Fi Direct devices.
 */
declare class Windows$Devices$WiFiDirect$WiFiDirectDevice  {

/**
 * Creates an instance of the WiFiDirectDevice class for the specified device interface id.
 * @param deviceId The DeviceInformation Id of a Wi-Fi Direct device.
 * @return An asynchronous operation to retrieve the WiFiDirectDevice that was created.
 */
static fromIdAsync(
deviceId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$WiFiDirect$WiFiDirectDevice>;

/**
 * Creates an instance of the WiFiDirectDevice class for the specified device interface id with specific connection parameters.
 * @param deviceId The DeviceInformation Id of a Wi-Fi Direct device.
 * @param connectionParameters Connection parameters for a Wi-Fi Direct connect/pairing operation.
 * @return An asynchronous operation to retrieve the WiFiDirectDevice that was created.
 */
static fromIdAsync(
deviceId: string,
connectionParameters: Windows$Devices$WiFiDirect$WiFiDirectConnectionParameters): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$WiFiDirect$WiFiDirectDevice>;

/**
 * Returns the class selection string that you can use to enumerate Wi-Fi Direct devices.
 * @return The class selection string that you can use to enumerate Wi-Fi Direct devices.
 */
static getDeviceSelector(): string;

/**
 * Returns the class selection string that you can use to enumerate Wi-Fi Direct devices for a specific Wi-Fi Direct device selector type.
 * @param type A specific Wi-Fi Direct device selector type.
 * @return The class selection string that you can use to enumerate Wi-Fi Direct devices.
 */
static getDeviceSelector(
type: $Values<typeof Windows$Devices$WiFiDirect$WiFiDirectDeviceSelectorType>): string;

/**
 * Close the active Wi-Fi Direct device connection.
 */
close(): void;

/**
 * Gets the connection status for the WiFi-Direct device.
 */
connectionStatus: $Values<typeof Windows$Devices$WiFiDirect$WiFiDirectConnectionStatus>;

/**
 * Gets the DeviceInformation Id for the Wi-Fi Direct device.
 */
deviceId: string;

/**
 * Gets a collection of network addresses for the Wi-Fi Direct device as endpoint pairs.
 * @return A collection of network addresses for the Wi-Fi Direct device as endpoint pairs.
 */
getConnectionEndpointPairs(): Windows$Foundation$Collections$IVectorView<Windows$Networking$EndpointPair>;

/**
 * Occurs when a Wi-Fi Direct device connection is connected or disconnected.
 */
onconnectionstatuschanged: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$WiFiDirectDevice, any>;
addEventListener(
type: "connectionstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$WiFiDirectDevice, any>): void;
removeEventListener(
type: "connectionstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Devices$WiFiDirect$WiFiDirectDevice, any>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies the device selector type for Wi-Fi Direct.
 */

declare  var Windows$Devices$WiFiDirect$WiFiDirectDeviceSelectorType: {|
  +deviceInterface: 0,// 0
+associationEndpoint: 1,// 1

|};



/**
 * Specifies some common Wi-Fi Direct error cases.
 */

declare  var Windows$Devices$WiFiDirect$WiFiDirectError: {|
  +success: 0,// 0
+radioNotAvailable: 1,// 1
+resourceInUse: 2,// 2

|};



/**
 * Represents information elements in a Wi-Fi Direct packet.
 */
declare class Windows$Devices$WiFiDirect$WiFiDirectInformationElement  {

/**
 * Create an array of information elements from a data buffer.
 * @param buffer The data buffer that contains a information element.
 * @return A array of information elements created from the buffer.
 */
static createFromBuffer(
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$Collections$IVector<Windows$Devices$WiFiDirect$WiFiDirectInformationElement>;

/**
 * Create an array of information elements from a DeviceInformation object.
 * @param deviceInformation The device information object that contains the information elements.
 * @return A array of information elements created from the device information object.
 */
static createFromDeviceInformation(
deviceInformation: Windows$Devices$Enumeration$DeviceInformation): Windows$Foundation$Collections$IVector<Windows$Devices$WiFiDirect$WiFiDirectInformationElement>;

/**
 * Creates a new WiFiDirectInformationElement object.
 */
constructor(): this;

/**
 * A three-byte organization identifier used to indicate the organization which defined a vendor extension information element (IE).
 */
oui: Windows$Storage$Streams$IBuffer;

/**
 * A one byte type value used in a vendor extension information element (IE) to distinguish between different IE formats defined by the same organization.
 */
ouiType: number;

/**
 * The value of the information element.
 */
value: Windows$Storage$Streams$IBuffer
}


/**
 * Settings governing "legacy" mode (non-Wi-Fi Direct connections to the access point being advertised.)
 */
declare class Windows$Devices$WiFiDirect$WiFiDirectLegacySettings  {

/**
 * Gets or sets a value specifying whether "legacy mode" is enabled. When enabled, this mode causes this device to act as a normal Wi-Fi access point, and is intended to support devices which do not support connection via Wi-Fi Direct.
 */
isEnabled: boolean;

/**
 * Gets or sets the pass phrase used by non-Wi-Fi Direct clients to connect to this access point in "legacy mode".
 */
passphrase: Windows$Security$Credentials$PasswordCredential;

/**
 * Gets or sets the Service Set Identifier (SSID, or "access point ID").
 */
ssid: string
}


/**
 * Specifies a direct pairing procedure.
 */

declare  var Windows$Devices$WiFiDirect$WiFiDirectPairingProcedure: {|
  +groupOwnerNegotiation: 0,// 0
+invitation: 1,// 1

|};



      declare var npm$namespace$Windows$Gaming: {
        
        
        
        
        Input: typeof npm$namespace$Windows$Gaming$Input,
Preview: typeof npm$namespace$Windows$Gaming$Preview,
UI: typeof npm$namespace$Windows$Gaming$UI,
XboxLive: typeof npm$namespace$Windows$Gaming$XboxLive,
      }

      declare var npm$namespace$Windows$Gaming$Input: {
        
        
        GamepadButtons: typeof Windows$Gaming$Input$GamepadButtons,
        Gamepad: typeof Windows$Gaming$Input$Gamepad,
Headset: typeof Windows$Gaming$Input$Headset,
        
      }

/**
 * Represents a game controller.
 */
declare class Windows$Gaming$Input$Gamepad  {

/**
 * The list of all connected gamepads.
 */
static gamepads: Windows$Foundation$Collections$IVectorView<Windows$Gaming$Input$Gamepad>;

/**
 * Signals when a new gamepad is connected.
 */
static ongamepadadded: Windows$Foundation$EventHandler<any>;
static addEventListener(type: "gamepadadded", listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: "gamepadadded", listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Signals when a gamepad is disconnected.
 */
static ongamepadremoved: Windows$Foundation$EventHandler<any>;
static addEventListener(type: "gamepadremoved", listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: "gamepadremoved", listener: Windows$Foundation$EventHandler<any>): void;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Gets a snapshot of the gamepad state.
 * @return Returns a GamepadReading containing the current state of the gamepad.
 */
getCurrentReading(): Windows$Gaming$Input$GamepadReading;

/**
 * The audio headset attached to the gamepad.
 */
headset: Windows$Gaming$Input$Headset;

/**
 * Gets a value that indicates the wireless state of the gamepad.
 */
isWireless: boolean;

/**
 * Signals when a headset is attached to the gamepad.
 */
onheadsetconnected: Windows$Foundation$TypedEventHandler<Windows$Gaming$Input$IGameController, Windows$Gaming$Input$Headset>;
addEventListener(
type: "headsetconnected",
listener: Windows$Foundation$TypedEventHandler<Windows$Gaming$Input$IGameController, Windows$Gaming$Input$Headset>): void;
removeEventListener(
type: "headsetconnected",
listener: Windows$Foundation$TypedEventHandler<Windows$Gaming$Input$IGameController, Windows$Gaming$Input$Headset>): void;

/**
 * Signals when a headset is disconnected from the gamepad.
 */
onheadsetdisconnected: Windows$Foundation$TypedEventHandler<Windows$Gaming$Input$IGameController, Windows$Gaming$Input$Headset>;
addEventListener(
type: "headsetdisconnected",
listener: Windows$Foundation$TypedEventHandler<Windows$Gaming$Input$IGameController, Windows$Gaming$Input$Headset>): void;
removeEventListener(
type: "headsetdisconnected",
listener: Windows$Foundation$TypedEventHandler<Windows$Gaming$Input$IGameController, Windows$Gaming$Input$Headset>): void;

/**
 * Signals when the user associated with the gamepad has changed.
 */
onuserchanged: Windows$Foundation$TypedEventHandler<Windows$Gaming$Input$IGameController, Windows$System$UserChangedEventArgs>;
addEventListener(
type: "userchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Gaming$Input$IGameController, Windows$System$UserChangedEventArgs>): void;
removeEventListener(
type: "userchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Gaming$Input$IGameController, Windows$System$UserChangedEventArgs>): void;

/**
 * The user associated with the gamepad.
 */
user: Windows$System$User;

/**
 * Describes the gamepad motor speed.
 */
vibration: Windows$Gaming$Input$GamepadVibration;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies the button type.
 */

declare  var Windows$Gaming$Input$GamepadButtons: {|
  +none: 0,// 0
+menu: 1,// 1
+view: 2,// 2
+a: 3,// 3
+b: 4,// 4
+x: 5,// 5
+y: 6,// 6
+dpadUp: 7,// 7
+dpadDown: 8,// 8
+dpadLeft: 9,// 9
+dpadRight: 10,// 10
+leftShoulder: 11,// 11
+rightShoulder: 12,// 12
+leftThumbstick: 13,// 13
+rightThumbstick: 14,// 14

|};



/**
 * Contains information about an audio headset attached to a gamepad.
 */
declare class Windows$Gaming$Input$Headset  {

/**
 * The XAudio endpoint ID for the headset's audio capture device.
 */
captureDeviceId: string;

/**
 * The XAudio enpoint ID for the headset's audio render device.
 */
renderDeviceId: string
}


/**
 * Represents the current state of the controller.
 */
declare interface Windows$Gaming$Input$GamepadReading {

/**
 * The state of the controller buttons.
 */
buttons: $Values<typeof Windows$Gaming$Input$GamepadButtons>,

/**
 * The position of the left thumbstick on the X-asxis. The value is between -1.0 and 1.0.
 */
leftThumbstickX: number,

/**
 * The position of the left thumbstick on the Y-axis.The value is between -1.0 and 1.0.
 */
leftThumbstickY: number,

/**
 * The position of the left trigger. The value is between 0.0 (not depressed) and 1.0 (fully depressed).
 */
leftTrigger: number,

/**
 * The position of the right thumbstick on the X-axis.The value is between -1.0 and 1.0.
 */
rightThumbstickX: number,

/**
 * The position of the right thumbstick on the Y-axis. The value is between -1.0 and 1.0.
 */
rightThumbstickY: number,

/**
 * The position of the right trigger. The value is between 0.0 (not depressed) and 1.0 (fully depressed).
 */
rightTrigger: number,

/**
 * Time when the state was retrieved from the controller.
 */
timestamp: number
} 


/**
 * The core interface required to be implemented by all controller devices, regardless of their actual type (i.e. gamepads, steering wheels, flight sticks, etc). This interface exists mainly to support extensibility for game controllers, which allows OEMs to publish WinRT classes that provide rich access to their device's features, while integrating into the underlying game controller device enumeration framework.
 */
declare interface Windows$Gaming$Input$IGameController {

/**
 * The audio headset attached to the controller.
 */
headset: Windows$Gaming$Input$Headset,

/**
 * Gets a value that indicates the wireless state of the gamepad.
 */
isWireless: boolean,

/**
 * The user associated with the controller.
 */
user: Windows$System$User
} 


/**
 * Describes the speed of the gamepad's four available vibration motors.
 */
declare interface Windows$Gaming$Input$GamepadVibration {

/**
 * The level of the left vibration motor. Valid values are between 0.0 and 1.0, where 0.0 signifies no motor use and 1.0 signifies max vibration.
 */
leftMotor: number,

/**
 * The left trigger vibration level. Valid values are between 0.0 and 1.0, where 0.0 signifies no motor use and 1.0 signifies max vibration.
 */
leftTrigger: number,

/**
 * The level of the right vibration motor. Valid values are between 0.0 and 1.0, where 0.0 signifies no motor use and 1.0 signifies max vibration.
 */
rightMotor: number,

/**
 * The right trigger vibration level, Valid values are between 0.0 and 1.0, where 0.0 signifies no motor use and 1.0 signifies max vibration.
 */
rightTrigger: number
} 


      declare var npm$namespace$Windows$Gaming$Preview: {
        
        
        
        
        GamesEnumeration: typeof npm$namespace$Windows$Gaming$Preview$GamesEnumeration,
      }

      declare var npm$namespace$Windows$Gaming$Preview$GamesEnumeration: {
        
        
        
        GameList: typeof Windows$Gaming$Preview$GamesEnumeration$GameList,
GameListEntry: typeof Windows$Gaming$Preview$GamesEnumeration$GameListEntry,
        GameListCategory: typeof npm$namespace$Windows$Gaming$Preview$GamesEnumeration$GameListCategory,
      }
declare class Windows$Gaming$Preview$GamesEnumeration$GameList  {
static addEventListener: any;
static findAllAsync: any;
static ongameadded: any;
static ongameremoved: any;
static ongameupdated: any;
static removeEventListener: any
}


      declare var npm$namespace$Windows$Gaming$Preview$GamesEnumeration$GameListCategory: {
        
        candidate: typeof Windows$Gaming$Preview$GamesEnumeration$GameListCategory$candidate,
confirmedBySystem: typeof Windows$Gaming$Preview$GamesEnumeration$GameListCategory$confirmedBySystem,
confirmedByUser: typeof Windows$Gaming$Preview$GamesEnumeration$GameListCategory$confirmedByUser,
        
        
        
      }
declare var Windows$Gaming$Preview$GamesEnumeration$GameListCategory$candidate: any;

declare var Windows$Gaming$Preview$GamesEnumeration$GameListCategory$confirmedBySystem: any;

declare var Windows$Gaming$Preview$GamesEnumeration$GameListCategory$confirmedByUser: any;

declare class Windows$Gaming$Preview$GamesEnumeration$GameListEntry  {
category: any;
displayInfo: any;
launchAsync: any;
properties: any;
setCategoryAsync: any
}


      declare var npm$namespace$Windows$Gaming$UI: {
        
        
        
        GameBar: typeof Windows$Gaming$UI$GameBar,
        
      }
declare class Windows$Gaming$UI$GameBar  {
static addEventListener: any;
static isInputRedirected: any;
static onisinputredirectedchanged: any;
static onvisibilitychanged: any;
static removeEventListener: any;
static visible: any
}


      declare var npm$namespace$Windows$Gaming$XboxLive: {
        
        
        
        
        Storage: typeof npm$namespace$Windows$Gaming$XboxLive$Storage,
      }

      declare var npm$namespace$Windows$Gaming$XboxLive$Storage: {
        
        
        GameSaveErrorStatus: typeof Windows$Gaming$XboxLive$Storage$GameSaveErrorStatus,
        GameSaveBlobGetResult: typeof Windows$Gaming$XboxLive$Storage$GameSaveBlobGetResult,
GameSaveBlobInfo: typeof Windows$Gaming$XboxLive$Storage$GameSaveBlobInfo,
GameSaveBlobInfoGetResult: typeof Windows$Gaming$XboxLive$Storage$GameSaveBlobInfoGetResult,
GameSaveBlobInfoQuery: typeof Windows$Gaming$XboxLive$Storage$GameSaveBlobInfoQuery,
GameSaveContainer: typeof Windows$Gaming$XboxLive$Storage$GameSaveContainer,
GameSaveContainerInfo: typeof Windows$Gaming$XboxLive$Storage$GameSaveContainerInfo,
GameSaveContainerInfoGetResult: typeof Windows$Gaming$XboxLive$Storage$GameSaveContainerInfoGetResult,
GameSaveContainerInfoQuery: typeof Windows$Gaming$XboxLive$Storage$GameSaveContainerInfoQuery,
GameSaveOperationResult: typeof Windows$Gaming$XboxLive$Storage$GameSaveOperationResult,
GameSaveProvider: typeof Windows$Gaming$XboxLive$Storage$GameSaveProvider,
GameSaveProviderGetResult: typeof Windows$Gaming$XboxLive$Storage$GameSaveProviderGetResult,
        
      }

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Gaming$XboxLive$Storage$GameSaveBlobGetResult  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
status: $Values<typeof Windows$Gaming$XboxLive$Storage$GameSaveErrorStatus>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
value: Windows$Foundation$Collections$IMapView<string, Windows$Storage$Streams$IBuffer>
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Gaming$XboxLive$Storage$GameSaveBlobInfo  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
name: string;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
size: number
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Gaming$XboxLive$Storage$GameSaveBlobInfoGetResult  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
status: $Values<typeof Windows$Gaming$XboxLive$Storage$GameSaveErrorStatus>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
value: Windows$Foundation$Collections$IVectorView<Windows$Gaming$XboxLive$Storage$GameSaveBlobInfo>
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Gaming$XboxLive$Storage$GameSaveBlobInfoQuery  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param startIndex This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param maxNumberOfItems This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getBlobInfoAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Gaming$XboxLive$Storage$GameSaveBlobInfoGetResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getBlobInfoAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Gaming$XboxLive$Storage$GameSaveBlobInfoGetResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getItemCountAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<number>
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Gaming$XboxLive$Storage$GameSaveContainer  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param blobNamePrefix This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
createBlobInfoQuery(blobNamePrefix: string): Windows$Gaming$XboxLive$Storage$GameSaveBlobInfoQuery;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param blobsToRead This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getAsync(
blobsToRead: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Gaming$XboxLive$Storage$GameSaveBlobGetResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
name: string;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
provider: Windows$Gaming$XboxLive$Storage$GameSaveProvider;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param blobsToRead This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
readAsync(
blobsToRead: Windows$Foundation$Collections$IMapView<string, Windows$Storage$Streams$IBuffer>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Gaming$XboxLive$Storage$GameSaveOperationResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param blobsToWrite This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param blobsToDelete This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param displayName This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
submitPropertySetUpdatesAsync(
blobsToWrite: Windows$Foundation$Collections$IPropertySet,
blobsToDelete: Windows$Foundation$Collections$IIterable<string>,
displayName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Gaming$XboxLive$Storage$GameSaveOperationResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param blobsToWrite This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param blobsToDelete This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param displayName This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
submitUpdatesAsync(
blobsToWrite: Windows$Foundation$Collections$IMapView<string, Windows$Storage$Streams$IBuffer>,
blobsToDelete: Windows$Foundation$Collections$IIterable<string>,
displayName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Gaming$XboxLive$Storage$GameSaveOperationResult>
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Gaming$XboxLive$Storage$GameSaveContainerInfo  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
displayName: string;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
lastModifiedTime: Date;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
name: string;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
needsSync: boolean;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
totalSize: number
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Gaming$XboxLive$Storage$GameSaveContainerInfoGetResult  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
status: $Values<typeof Windows$Gaming$XboxLive$Storage$GameSaveErrorStatus>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
value: Windows$Foundation$Collections$IVectorView<Windows$Gaming$XboxLive$Storage$GameSaveContainerInfo>
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Gaming$XboxLive$Storage$GameSaveContainerInfoQuery  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param startIndex This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param maxNumberOfItems This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getContainerInfoAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Gaming$XboxLive$Storage$GameSaveContainerInfoGetResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getContainerInfoAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Gaming$XboxLive$Storage$GameSaveContainerInfoGetResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getItemCountAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<number>
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */

declare  var Windows$Gaming$XboxLive$Storage$GameSaveErrorStatus: {|
  +ok: 0,// 0
+abort: 1,// 1
+invalidContainerName: 2,// 2
+noAccess: 3,// 3
+outOfLocalStorage: 4,// 4
+userCanceled: 5,// 5
+updateTooBig: 6,// 6
+quotaExceeded: 7,// 7
+providedBufferTooSmall: 8,// 8
+blobNotFound: 9,// 9
+noXboxLiveInfo: 10,// 10
+containerNotInSync: 11,// 11
+containerSyncFailed: 12,// 12
+userHasNoXboxLiveInfo: 13,// 13
+objectExpired: 14,// 14

|};



/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Gaming$XboxLive$Storage$GameSaveOperationResult  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
status: $Values<typeof Windows$Gaming$XboxLive$Storage$GameSaveErrorStatus>
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Gaming$XboxLive$Storage$GameSaveProvider  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param user This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param serviceConfigId This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static getForUserAsync(
user: Windows$System$User,
serviceConfigId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Gaming$XboxLive$Storage$GameSaveProviderGetResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param user This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param serviceConfigId This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
static getSyncOnDemandForUserAsync(
user: Windows$System$User,
serviceConfigId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Gaming$XboxLive$Storage$GameSaveProviderGetResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
containersChangedSinceLastSync: Windows$Foundation$Collections$IVectorView<string>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param name This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
createContainer(name: string): Windows$Gaming$XboxLive$Storage$GameSaveContainer;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param containerNamePrefix This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
createContainerInfoQuery(
containerNamePrefix: string): Windows$Gaming$XboxLive$Storage$GameSaveContainerInfoQuery;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
createContainerInfoQuery(): Windows$Gaming$XboxLive$Storage$GameSaveContainerInfoQuery;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param name This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
deleteContainerAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Gaming$XboxLive$Storage$GameSaveOperationResult>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
getRemainingBytesInQuotaAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
user: Windows$System$User
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
declare class Windows$Gaming$XboxLive$Storage$GameSaveProviderGetResult  {

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
status: $Values<typeof Windows$Gaming$XboxLive$Storage$GameSaveErrorStatus>;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
value: Windows$Gaming$XboxLive$Storage$GameSaveProvider
}


      declare var npm$namespace$Windows$Globalization: {
        
        
        DayOfWeek: typeof Windows$Globalization$DayOfWeek,
        ApplicationLanguages: typeof Windows$Globalization$ApplicationLanguages,
Calendar: typeof Windows$Globalization$Calendar,
CalendarIdentifiers: typeof Windows$Globalization$CalendarIdentifiers,
ClockIdentifiers: typeof Windows$Globalization$ClockIdentifiers,
CurrencyIdentifiers: typeof Windows$Globalization$CurrencyIdentifiers,
GeographicRegion: typeof Windows$Globalization$GeographicRegion,
JapanesePhoneme: typeof Windows$Globalization$JapanesePhoneme,
JapanesePhoneticAnalyzer: typeof Windows$Globalization$JapanesePhoneticAnalyzer,
Language: typeof Windows$Globalization$Language,
NumeralSystemIdentifiers: typeof Windows$Globalization$NumeralSystemIdentifiers,
        Collation: typeof npm$namespace$Windows$Globalization$Collation,
DateTimeFormatting: typeof npm$namespace$Windows$Globalization$DateTimeFormatting,
Fonts: typeof npm$namespace$Windows$Globalization$Fonts,
NumberFormatting: typeof npm$namespace$Windows$Globalization$NumberFormatting,
      }

/**
 * Specifies the language-related preferences that the app can use and maintain.
 */
declare class Windows$Globalization$ApplicationLanguages  {

/**
 * Gets the ranked list of current runtime language values preferred by the user.
 */
static languages: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the app's declared list of supported languages.
 */
static manifestLanguages: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets or sets an override for the app's preferred language, expressed as a BCP-47 language tag. This setting is persisted.
 */
static primaryLanguageOverride: string
}


/**
 * Manipulates the representation of a date and time within a given calendar and clock.
 */
declare class Windows$Globalization$Calendar  {

/**
 * Creates a Calendar object that is initialized with a language list, calendar, and clock.
 * @param languages The list of language identifiers, in priority order, representing the choice of languages. These are used for resolving patterns to strings. See Remarks.
 * @param calendar The calendar identifier to use.
 * @param clock The clock identifier to use.
 */
constructor(languages: Windows$Foundation$Collections$IIterable<string>, calendar: string, clock: string): this;

/**
 * Creates a Calendar object that is initialized with a language list.
 * @param languages The list of language identifiers, in priority order, that represents the choice of languages. These are used for resolving patterns to strings. See Remarks.
 */
constructor(languages: Windows$Foundation$Collections$IIterable<string>): this;

/**
 * Creates a Calendar object and initializes it to the current date and time.
 */
constructor(): this;

/**
 * Creates a Calendar object that is initialized with a language list, calendar, clock, and time zone.
 * @param languages The list of language identifiers, in priority order, representing the choice of languages. These are used for resolving patterns to strings. See Remarks.
 * @param calendar The calendar identifier to use.
 * @param clock The clock identifier to use.
 * @param timeZoneId An identifier from the IANA Time Zone Database which identifies the time zone that should be used (for example, "Americas/Los_Angeles" for Pacific Time).
 */
constructor(languages: Windows$Foundation$Collections$IIterable<string>, calendar: string, clock: string, timeZoneId: string): this;

/**
 * Increments or decrements the day.
 * @param days The number of days by which to increment the day (if the value is positive) or decrement the day (if the value is negative).
 */
addDays(days: number): void;

/**
 * Increments or decrements the era.
 * @param eras The number of eras by which to increment the era (if the value is positive) or decrement the era (if the value is negative).
 */
addEras(eras: number): void;

/**
 * Increments or decrements the hour.
 * @param hours The number of hours by which to increment the hour (if the value is positive) or decrement the hour (if the value is negative).
 */
addHours(hours: number): void;

/**
 * Increments or decrements the minute.
 * @param minutes The number of minutes by which to increment the minute (if the value is positive) or decrement the minute (if the value is negative).
 */
addMinutes(minutes: number): void;

/**
 * Increments or decrements the month.
 * @param months The number of months by which to increment the month (if the value is positive) or decrement the month (if the value is negative).
 */
addMonths(months: number): void;

/**
 * Increments or decrements the nanosecond.
 * @param nanoseconds The number of nanoseconds by which to increment the nanosecond (if the value is positive) or decrement the nanosecond (if the value is negative).
 */
addNanoseconds(nanoseconds: number): void;

/**
 * Increments or decrements the period.
 * @param periods The number of periods by which to increment the period (if the value is positive) or decrement the period (if the value is negative).
 */
addPeriods(periods: number): void;

/**
 * Increments or decrements the second.
 * @param seconds The number of seconds by which to increment the second (if the value is positive) or decrement the second (if the value is negative).
 */
addSeconds(seconds: number): void;

/**
 * Increments or decrements the day by the specified number of weeks.
 * @param weeks The number of weeks by which to increment the day (if the value is positive) or decrement the day (if the value is negative).
 */
addWeeks(weeks: number): void;

/**
 * Increments or decrements the year.
 * @param years The number of years by which to increment the year (if the value is positive) or decrement the year (if the value is negative).
 */
addYears(years: number): void;

/**
 * Sets a new calendar system to be used by this Calendar object.
 * @param value The calendar identifier to use.
 */
changeCalendarSystem(value: string): void;

/**
 * Sets a new clock to be used by this Calendar object.
 * @param value The clock identifier to use.
 */
changeClock(value: string): void;

/**
 * Sets a new time zone to be used by this Calendar object.
 * @param timeZoneId An identifier from the IANA Time Zone Database which identifies the time zone that should be used (for example, "Americas/Los_Angeles" for Pacific Time).
 */
changeTimeZone(timeZoneId: string): void;

/**
 * Creates a copy of the Calendar object.
 * @return A copy of the Calendar .
 */
clone(): Windows$Globalization$Calendar;

/**
 * Compares this calendar to another Calendar object and indicates whether the date and time of one is earlier, equal to, or later than that of the other.
 * @param other The Calendar object to compare to the current calendar.
 * @return One of the following values:
 */
compare(other: Windows$Globalization$Calendar): number;

/**
 * Compares this calendar to a DateTime object and indicates whether the date and time of one is earlier, equal to, or later than that of the other.
 * @param other The DateTime object to compare to the current calendar.
 * @return One of the following values:
 */
compareDateTime(other: Date): number;

/**
 * Copies the values from another Calendar object into this Calendar.
 * @param other The Calendar object to be copied.
 */
copyTo(other: Windows$Globalization$Calendar): void;

/**
 * Gets or sets the day.
 */
day: number;

/**
 * Returns a string representation of the day, optionally zero-padded.
 * @param minDigits The minimum number of integer digits to be displayed. If the day does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the day 3, a parameter of 1 returns 3, and a parameter of 2 returns 03.
 * @return A string representation of the day.
 */
dayAsPaddedString(minDigits: number): string;

/**
 * Returns a string that contains the numeric representation of the day.
 * @return A string representation of the day.
 */
dayAsString(): string;

/**
 * Gets the day of the week.
 */
dayOfWeek: $Values<typeof Windows$Globalization$DayOfWeek>;

/**
 * Returns a string representation of the day of the week suitable for stand-alone display.
 * @param idealLength A positive integer specifying the ideal length, in characters, for the returned string, or 0 specifying the most common abbreviation available.
 * @return A string representation of the day of the week.
 */
dayOfWeekAsSoloString(idealLength: number): string;

/**
 * Returns a string representation of the day of the week suitable for stand-alone display.
 * @return A string representation of the day of the week, using the most common abbreviation available.
 */
dayOfWeekAsSoloString(): string;

/**
 * Returns a string representation of the day of the week suitable for inclusion with other date components.
 * @param idealLength A positive integer specifying the ideal length, in characters, for the returned string, or 0 specifying the most common abbreviation available.
 * @return A string representation of the day of the week.
 */
dayOfWeekAsString(idealLength: number): string;

/**
 * Returns a string representation of the day of the week suitable for inclusion with other date components.
 * @return A string representation of the day of the week, using the most common abbreviation available.
 */
dayOfWeekAsString(): string;

/**
 * Gets or sets the era.
 */
era: number;

/**
 * Returns a string representation of the era. The string chosen is closest in length to the ideal length.
 * @param idealLength A positive integer specifying the ideal length, in characters, for the returned string, or 0 specifying the most common abbreviation available.
 * @return A string representation of the era.
 */
eraAsString(idealLength: number): string;

/**
 * Returns a string representation of the era.
 * @return A string representation of the era, using the most common abbreviation available.
 */
eraAsString(): string;

/**
 * Gets the first Day of the current Month .
 */
firstDayInThisMonth: number;

/**
 * Gets the first Era available in the calendar.
 */
firstEra: number;

/**
 * Gets the first Hour of the current Period .
 */
firstHourInThisPeriod: number;

/**
 * Gets the first Minute of the current Hour .
 */
firstMinuteInThisHour: number;

/**
 * Gets the first Month of the current Year .
 */
firstMonthInThisYear: number;

/**
 * Gets the first Period of the current Day .
 */
firstPeriodInThisDay: number;

/**
 * Gets the first Second of the current Minute .
 */
firstSecondInThisMinute: number;

/**
 * Gets the first Year of the current Era .
 */
firstYearInThisEra: number;

/**
 * Gets the calendar system that is used by this Calendar object.
 * @return The identifier of the calendar system.
 */
getCalendarSystem(): string;

/**
 * Gets the clock that is used by this Calendar object.
 * @return The identifier of the clock.
 */
getClock(): string;

/**
 * Builds a date and time, given the components of this Calendar object.
 * @return The DateTime representing the date and time of this Calendar .
 */
getDateTime(): Date;

/**
 * Gets the identifier that identifies the time zone that is used by this Calendar object.
 * @return The identifier from the IANA Time Zone Database that identifies the time zone that is used by this Calendar object. (An example is "Americas/Los_Angeles" for Pacific Time.)
 */
getTimeZone(): string;

/**
 * Gets or sets the hour.
 */
hour: number;

/**
 * Returns a string representation of the hour, optionally zero-padded.
 * @param minDigits The minimum number of integer digits to be displayed. If the hour does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the hour 3, a parameter of 1 returns 3, and a parameter of 2 returns 03.
 * @return A string representation of the hour.
 */
hourAsPaddedString(minDigits: number): string;

/**
 * Returns a string that contains the numeric representation of the hour.
 * @return A string representation of the hour.
 */
hourAsString(): string;

/**
 * Gets a Boolean indicating if Daylight Saving Time is in effect for the date of this Calendar object.
 */
isDaylightSavingTime: boolean;

/**
 * Gets the priority list of language identifiers that is used when formatting components as strings.
 */
languages: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the last Day of the current Month .
 */
lastDayInThisMonth: number;

/**
 * Gets the last Era available in the calendar.
 */
lastEra: number;

/**
 * Gets the last Hour of the current Period .
 */
lastHourInThisPeriod: number;

/**
 * Gets the last Minute of the current Hour .
 */
lastMinuteInThisHour: number;

/**
 * Gets the last Month of the current Year .
 */
lastMonthInThisYear: number;

/**
 * Gets the last Period of the current Day .
 */
lastPeriodInThisDay: number;

/**
 * Gets the last Second of the current Minute .
 */
lastSecondInThisMinute: number;

/**
 * Gets the last Year of the current Era .
 */
lastYearInThisEra: number;

/**
 * Gets or sets the minute.
 */
minute: number;

/**
 * Returns a string representation of the minute, optionally zero-padded.
 * @param minDigits The minimum number of integer digits to be displayed. If the minute does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the minute 3, a parameter of 1 returns 3, and a parameter of 2 returns 03.
 * @return A string representation of the minute.
 */
minuteAsPaddedString(minDigits: number): string;

/**
 * Returns a string that contains the numeric representation of the minute.
 * @return A string representation of the minute.
 */
minuteAsString(): string;

/**
 * Gets or sets the month.
 */
month: number;

/**
 * Returns a string that contains the numeric representation of the month.
 * @return A string representation of the month.
 */
monthAsNumericString(): string;

/**
 * Returns a string representation of the month, optionally zero-padded.
 * @param minDigits The minimum number of integer digits to be displayed. If the month does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the month 3, a parameter of 1 returns 3, and a parameter of 2 returns 03.
 * @return A string representation of the month.
 */
monthAsPaddedNumericString(minDigits: number): string;

/**
 * Returns a string representation of the month suitable for stand-alone display.
 * @param idealLength A positive integer specifying the ideal length, in characters, for the returned string, or 0 specifying the most common abbreviation available.
 * @return A string representation of the month.
 */
monthAsSoloString(idealLength: number): string;

/**
 * Returns a string representation of the month suitable for stand-alone display.
 * @return A string representation of the month, using the most common abbreviation available.
 */
monthAsSoloString(): string;

/**
 * Returns a string representation of the month suitable for inclusion with other date components.
 * @param idealLength A positive integer specifying the ideal length, in characters, for the returned string, or 0 specifying the most common abbreviation available.
 * @return A string representation of the month.
 */
monthAsString(idealLength: number): string;

/**
 * Returns a string representation of the month suitable for inclusion with other date components.
 * @return A string representation of the month, using the most common abbreviation available.
 */
monthAsString(): string;

/**
 * Gets or sets the nanosecond.
 */
nanosecond: number;

/**
 * Returns a string representation of the nanosecond, optionally zero-padded.
 * @param minDigits The minimum number of integer digits to be displayed. If the nanosecond does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the nanosecond 42, a parameter of 1 or 2 returns 42, and a parameter of 3 returns 042.
 * @return A string representation of the nanosecond.
 */
nanosecondAsPaddedString(minDigits: number): string;

/**
 * Returns a string that contains the numeric representation of the nanosecond.
 * @return A string representation of the nanosecond.
 */
nanosecondAsString(): string;

/**
 * Gets the number of days in the current month of this Calendar object.
 */
numberOfDaysInThisMonth: number;

/**
 * Gets the number of eras in this Calendar object.
 */
numberOfEras: number;

/**
 * Gets the number of hours in the current day period of this Calendar object.
 */
numberOfHoursInThisPeriod: number;

/**
 * Gets the number of Minute s in the current Hour .
 */
numberOfMinutesInThisHour: number;

/**
 * Gets the number of months in the current year of this Calendar object.
 */
numberOfMonthsInThisYear: number;

/**
 * Gets the number of periods in the current day of this Calendar object.
 */
numberOfPeriodsInThisDay: number;

/**
 * Gets the number of Second s in the current Minute .
 */
numberOfSecondsInThisMinute: number;

/**
 * Gets the number of years in the current era of this Calendar object.
 */
numberOfYearsInThisEra: number;

/**
 * Gets or sets the numbering system that is used when formatting components as strings.
 */
numeralSystem: string;

/**
 * Gets or sets the period of the current day.
 */
period: number;

/**
 * Returns a string representation of the day period, such as AM or PM, that uses the most common abbreviation available.
 * @return A string representation of the day period.
 */
periodAsString(): string;

/**
 * Returns a string representation of the day period, such as AM or PM.
 * @param idealLength A positive integer that specifies the ideal length, in characters, for the returned string; or a zero that specifies the most common abbreviation available.
 * @return A string representation for the day period.
 */
periodAsString(idealLength: number): string;

/**
 * Gets the language that was most recently used to perform calendar formatting or operations.
 */
resolvedLanguage: string;

/**
 * Gets or sets the second.
 */
second: number;

/**
 * Returns a string representation of the second, optionally zero-padded.
 * @param minDigits The minimum number of integer digits to be displayed. If the second does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the second 3, a parameter of 1 returns 3, and a parameter of 2 returns 03.
 * @return A string representation of the second.
 */
secondAsPaddedString(minDigits: number): string;

/**
 * Returns a string that contains the numeric representation of the second.
 * @return A string representation of the second.
 */
secondAsString(): string;

/**
 * Sets all the date and time fields to the date and time represented by the DateTime parameter.
 * @param value The DateTime that is used to set all of the date and time fields.
 */
setDateTime(value: Date): void;

/**
 * Sets the components of this Calendar object to the latest date and time that are supported.
 */
setToMax(): void;

/**
 * Sets the components of this Calendar object to the earliest date and time that are supported.
 */
setToMin(): void;

/**
 * Sets the components of this Calendar object to the current date and time.
 */
setToNow(): void;

/**
 * Returns the full time zone name applicable at the instant of time that this Calendar object represents.
 * @return The full time zone name. This usually differs depending on whether the time zone is observing Daylight Saving Time or not. It also may differ due to historical changes. (An example is "Americas/Los_Angeles" for Pacific Time.)
 */
timeZoneAsString(): string;

/**
 * Returns the abbreviated time zone name applicable at the instant of time that this Calendar object represents.
 * @param idealLength The desired length of the abbreviation to be returned. Use 0 to request the abbreviation in most common use.
 * @return The time zone abbreviation that is closest in length to idealLength. If there is a tie, the shorter abbreviation is returned. If idealLength is 0, the abbreviation in most common use is returned. (An example is "Americas/Los_Angeles" for Pacific Time.)
 */
timeZoneAsString(idealLength: number): string;

/**
 * Gets or sets the year.
 */
year: number;

/**
 * Returns a string representation of the year, optionally zero-padded.
 * @param minDigits The minimum number of integer digits to be displayed. If the year does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the year 42, a parameter of 1 or 2 returns 42, and a parameter of 3 returns 042.
 * @return A string representation of the year.
 */
yearAsPaddedString(minDigits: number): string;

/**
 * Returns a string representation of the year without any initial zero padding.
 * @return A string representation of the year.
 */
yearAsString(): string;

/**
 * Returns a string representation of the year, optionally truncated.
 * @param remainingDigits A positive integer that represents the number of least significant digits that should be included. For example, for the year 1234, a parameter of 2 returns 34, and a parameter of 4 or larger returns 1234.
 * @return A string representation of the year.
 */
yearAsTruncatedString(remainingDigits: number): string
}


/**
 * Contains the calendar identifiers for the supported calendars, as static properties.
 */
declare class Windows$Globalization$CalendarIdentifiers  {

/**
 * Gets the identifier for the Gregorian calendar.
 */
static gregorian: string;

/**
 * Gets the identifier for the Hebrew calendar.
 */
static hebrew: string;

/**
 * Gets the identifier for the Hijri calendar.
 */
static hijri: string;

/**
 * Gets the identifier for the Japanese calendar.
 */
static japanese: string;

/**
 * Gets the identifier for the Julian calendar.
 */
static julian: string;

/**
 * Gets the identifier for the Korean calendar.
 */
static korean: string;

/**
 * Gets the identifier for the Persian calendar.
 */
static persian: string;

/**
 * Gets the identifier for the Taiwan calendar.
 */
static taiwan: string;

/**
 * Gets the identifier for the Thai calendar.
 */
static thai: string;

/**
 * Gets the identifier for the Um Al-Qura calendar.
 */
static umAlQura: string
}


/**
 * Contains the clock identifiers for the supported clocks, as static properties.
 */
declare class Windows$Globalization$ClockIdentifiers  {

/**
 * Gets the identifier for a 12-hour clock.
 */
static twelveHour: string;

/**
 * Gets the identifier for a 24-hour clock.
 */
static twentyFourHour: string
}


      declare var npm$namespace$Windows$Globalization$Collation: {
        
        
        
        CharacterGrouping: typeof Windows$Globalization$Collation$CharacterGrouping,
CharacterGroupings: typeof Windows$Globalization$Collation$CharacterGroupings,
        
      }

/**
 * A container for character group information. Characters are grouped in an index that enables an application to determine where the grouping boundaries are.
 */
declare class Windows$Globalization$Collation$CharacterGrouping  {

/**
 * Gets the first item that appears in the grouping under this index.
 */
first: string;

/**
 * Gets the label that is associated with this index.
 */
label: string
}


/**
 * Contains the set of character groups and the functionality to get the label for any given string.
 */
declare class Windows$Globalization$Collation$CharacterGroupings mixins Array<Windows$Globalization$Collation$CharacterGrouping> {

/**
 * Create a CharacterGroupings object for the default collation.
 */
constructor(): this;

/**
 * Returns an iterator to enumerate the items in the set of character groups.
 * @return The iterator. The current position of the iterator is index 0, or the end of the set of character groups if the set is empty.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Globalization$Collation$CharacterGrouping>;

/**
 * Returns the CharacterGrouping at the specified index in the set of character groups.
 * @param index The zero-based index of the CharacterGrouping in the set to return.
 * @return The CharacterGrouping at the specified index.
 */
getAt(index: number): Windows$Globalization$Collation$CharacterGrouping;

/**
 * Returns the CharacterGrouping objects that start at the specified index in the set of character groups.
 * @param startIndex The zero-based index of the start of the CharacterGrouping objects in the set to return.
 */
getMany(
startIndex: number): {
items: Windows$Globalization$Collation$CharacterGrouping,
returnValue: number
};

/**
 * Returns the index of a specified CharacterGrouping object in the set of character groups.
 * @param value The CharacterGrouping object to find in the set.
 */
indexOf(
value: Windows$Globalization$Collation$CharacterGrouping): {
index: number,
returnValue: boolean
};

/**
 * Gets the label under which the provided text falls.
 * @param text The string for which to get the label.
 * @return The first character grouping label that applies to the given text.
 */
lookup(text: string): string;

/**
 * Gets the number of CharacterGrouping objects in the set of character groups.
 */
size: number;
indexOf(
value: Windows$Globalization$Collation$CharacterGrouping,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Globalization$Collation$CharacterGrouping,
fromIndex?: number): number
}


/**
 * Contains the currency identifiers for the supported currencies, as static properties.
 */
declare class Windows$Globalization$CurrencyIdentifiers  {

/**
 * Gets the currency identifier for the United Arab Emirates Dirham.
 */
static aed: string;

/**
 * Gets the currency identifier for the Afghan Afghani.
 */
static afn: string;

/**
 * Gets the currency identifier for the Albanian Lek.
 */
static all: string;

/**
 * Gets the currency identifier for the Armenian Dram.
 */
static amd: string;

/**
 * Gets the currency identifier for the Netherlands Antilles Guilder.
 */
static ang: string;

/**
 * Gets the currency identifier for the Angolan Kwanza.
 */
static aoa: string;

/**
 * Gets the currency identifier for the Argentine Peso.
 */
static ars: string;

/**
 * Gets the currency identifier for the Australian Dollar.
 */
static aud: string;

/**
 * Gets the currency identifier for the Aruban Florin.
 */
static awg: string;

/**
 * Gets the currency identifier for the Azerbaijani Manat.
 */
static azn: string;

/**
 * Gets the currency identifier for the Bosnia and Herzegovina Convertible Mark.
 */
static bam: string;

/**
 * Gets the currency identifier for the Barbados Dollar.
 */
static bbd: string;

/**
 * Gets the currency identifier for the Bangladeshi Taka.
 */
static bdt: string;

/**
 * Gets the currency identifier for the Bulgarian Lev.
 */
static bgn: string;

/**
 * Gets the currency identifier for the Bahraini Dinar.
 */
static bhd: string;

/**
 * Gets the currency identifier for the Burundian Franc.
 */
static bif: string;

/**
 * Gets the currency identifier for the Bermuda Dollar.
 */
static bmd: string;

/**
 * Gets the currency identifier for the Brunei Dollar.
 */
static bnd: string;

/**
 * Gets the currency identifier for the Bolivian Boliviano.
 */
static bob: string;

/**
 * Gets the currency identifier for the Brazilian Real.
 */
static brl: string;

/**
 * Gets the currency identifier for the Bahamian Dollar.
 */
static bsd: string;

/**
 * Gets the currency identifier for the Bhutanese Ngultrum.
 */
static btn: string;

/**
 * Gets the currency identifier for the Botswana Pula.
 */
static bwp: string;

/**
 * Gets the currency identifier for the Belarusian Ruble.
 */
static byr: string;

/**
 * Gets the currency identifier for the Belize Dollar.
 */
static bzd: string;

/**
 * Gets the currency identifier for the Canadian Dollar.
 */
static cad: string;

/**
 * Gets the currency identifier for the Congolese Franc.
 */
static cdf: string;

/**
 * Gets the currency identifier for the Swiss Franc.
 */
static chf: string;

/**
 * Gets the currency identifier for the Chilean Peso.
 */
static clp: string;

/**
 * Gets the currency identifier for the Chinese Yuan.
 */
static cny: string;

/**
 * Gets the currency identifier for the Colombian Peso.
 */
static cop: string;

/**
 * Gets the currency identifier for the Costa Rican Colon.
 */
static crc: string;

/**
 * Gets the currency identifier for the Cuban Peso.
 */
static cup: string;

/**
 * Gets the currency identifier for the Cabo Verde Escudo.
 */
static cve: string;

/**
 * Gets the currency identifier for the Czech Koruna.
 */
static czk: string;

/**
 * Gets the currency identifier for the Djiboutian Franc.
 */
static djf: string;

/**
 * Gets the currency identifier for the Danish Krone.
 */
static dkk: string;

/**
 * Gets the currency identifier for the Dominican Peso.
 */
static dop: string;

/**
 * Gets the currency identifier for the Algerian Dinar.
 */
static dzd: string;

/**
 * Gets the currency identifier for the Egyptian Pound.
 */
static egp: string;

/**
 * Gets the currency identifier for the Eritrean Nakfa.
 */
static ern: string;

/**
 * Gets the currency identifier for the Ethiopian Birr.
 */
static etb: string;

/**
 * Gets the currency identifier for the Euro.
 */
static eur: string;

/**
 * Gets the currency identifier for the Fiji Dollar.
 */
static fjd: string;

/**
 * Gets the currency identifier for the Falkland Islands Pound.
 */
static fkp: string;

/**
 * Gets the currency identifier for the Pound Sterling.
 */
static gbp: string;

/**
 * Gets the currency identifier for the Georgian Lari.
 */
static gel: string;

/**
 * Gets the currency identifier for the Ghanaian Cedi.
 */
static ghs: string;

/**
 * Gets the currency identifier for the Gibraltar Pound.
 */
static gip: string;

/**
 * Gets the currency identifier for the Gambian Dalasi.
 */
static gmd: string;

/**
 * Gets the currency identifier for the Guinean Franc.
 */
static gnf: string;

/**
 * Gets the currency identifier for the Guatemalan Quetzal.
 */
static gtq: string;

/**
 * Gets the currency identifier for the Guyanese Dollar.
 */
static gyd: string;

/**
 * Gets the currency identifier for the Hong Kong Dollar.
 */
static hkd: string;

/**
 * Gets the currency identifier for the Honduran Lempira.
 */
static hnl: string;

/**
 * Gets the currency identifier for the Croatian Kuna.
 */
static hrk: string;

/**
 * Gets the currency identifier for the Haitian Gourde.
 */
static htg: string;

/**
 * Gets the currency identifier for the Hungarian Forint.
 */
static huf: string;

/**
 * Gets the currency identifier for the Indonesian Rupiah.
 */
static idr: string;

/**
 * Gets the currency identifier for the Israeli New Shekel.
 */
static ils: string;

/**
 * Gets the currency identifier for the Indian Rupee.
 */
static inr: string;

/**
 * Gets the currency identifier for the Iraqi Dinar.
 */
static iqd: string;

/**
 * Gets the currency identifier for the Iranian Rial.
 */
static irr: string;

/**
 * Gets the currency identifier for the Icelandic Krona.
 */
static isk: string;

/**
 * Gets the currency identifier for the Jamaican Dollar.
 */
static jmd: string;

/**
 * Gets the currency identifier for the Jordanian Dinar.
 */
static jod: string;

/**
 * Gets the currency identifier for the Japanese Yen.
 */
static jpy: string;

/**
 * Gets the currency identifier for the Kenyan Shilling.
 */
static kes: string;

/**
 * Gets the currency identifier for the Kyrgyzstani Som.
 */
static kgs: string;

/**
 * Gets the currency identifier for the Cambodian Riel.
 */
static khr: string;

/**
 * Gets the currency identifier for the Comorian Franc.
 */
static kmf: string;

/**
 * Gets the currency identifier for the North Korean Won.
 */
static kpw: string;

/**
 * Gets the currency identifier for the Korean Won.
 */
static krw: string;

/**
 * Gets the currency identifier for the Kuwaiti Dinar.
 */
static kwd: string;

/**
 * Gets the currency identifier for the Cayman Islands Dollar.
 */
static kyd: string;

/**
 * Gets the currency identifier for the Kazakhstani Tenge.
 */
static kzt: string;

/**
 * Gets the currency identifier for the Lao Kip.
 */
static lak: string;

/**
 * Gets the currency identifier for the Lebanese Pound.
 */
static lbp: string;

/**
 * Gets the currency identifier for the Sri Lankan Rupee.
 */
static lkr: string;

/**
 * Gets the currency identifier for the Liberian Dollar.
 */
static lrd: string;

/**
 * Gets the currency identifier for the Lesotho Loti.
 */
static lsl: string;

/**
 * Gets the currency identifier for the Lithuanian Litas.
 */
static ltl: string;

/**
 * Gets the currency identifier for the Latvian Lats.
 */
static lvl: string;

/**
 * Gets the currency identifier for the Libyan Dinar.
 */
static lyd: string;

/**
 * Gets the currency identifier for the Moroccan Dirham.
 */
static mad: string;

/**
 * Gets the currency identifier for the Moldovan Leu.
 */
static mdl: string;

/**
 * Gets the currency identifier for the Malagasy Ariary.
 */
static mga: string;

/**
 * Gets the currency identifier for the Macedonia (FYROM) Denar.
 */
static mkd: string;

/**
 * Gets the currency identifier for the Myanmar Kyat.
 */
static mmk: string;

/**
 * Gets the currency identifier for the Mongolian Tugrik.
 */
static mnt: string;

/**
 * Gets the currency identifier for the Macao SAR Pataca.
 */
static mop: string;

/**
 * Gets the currency identifier for the Mauritania Ouguiya.
 */
static mro: string;

/**
 * Gets the currency identifier for the Mauritian Rupee.
 */
static mur: string;

/**
 * Gets the currency identifier for the Maldives Rufiyaa.
 */
static mvr: string;

/**
 * Gets the currency identifier for the Malawian Kwacha.
 */
static mwk: string;

/**
 * Gets the currency identifier for the Mexican Peso.
 */
static mxn: string;

/**
 * Gets the currency identifier for the Malaysian Ringgit.
 */
static myr: string;

/**
 * Gets the currency identifier for the New Mozambican Metical.
 */
static mzn: string;

/**
 * Gets the currency identifier for the Namibian Dollar.
 */
static nad: string;

/**
 * Gets the currency identifier for the Nigerian Naira.
 */
static ngn: string;

/**
 * Gets the currency identifier for the Nicaraguan Cordoba Oro.
 */
static nio: string;

/**
 * Gets the currency identifier for the Norwegian Krone.
 */
static nok: string;

/**
 * Gets the currency identifier for the Nepalese Rupee.
 */
static npr: string;

/**
 * Gets the currency identifier for the New Zealand Dollar.
 */
static nzd: string;

/**
 * Gets the currency identifier for the Omani Rial.
 */
static omr: string;

/**
 * Gets the currency identifier for the Panamanian Balboa.
 */
static pab: string;

/**
 * Gets the currency identifier for the Peruvian Nuevo Sol.
 */
static pen: string;

/**
 * Gets the currency identifier for the Papua New Guinea Kina.
 */
static pgk: string;

/**
 * Gets the currency identifier for the Philippine Peso.
 */
static php: string;

/**
 * Gets the currency identifier for the Pakistan Rupee.
 */
static pkr: string;

/**
 * Gets the currency identifier for the Polish Zloty.
 */
static pln: string;

/**
 * Gets the currency identifier for the Paraguay Guarani.
 */
static pyg: string;

/**
 * Gets the currency identifier for the Qatari Riyal.
 */
static qar: string;

/**
 * Gets the currency identifier for the Romanian Leu.
 */
static ron: string;

/**
 * Gets the currency identifier for the Serbian Dinar.
 */
static rsd: string;

/**
 * Gets the currency identifier for the Russian Ruble.
 */
static rub: string;

/**
 * Gets the currency identifier for the Rwandan Franc.
 */
static rwf: string;

/**
 * Gets the currency identifier for the Saudi Arabian Riyal.
 */
static sar: string;

/**
 * Gets the currency identifier for the Solomon Islands Dollar.
 */
static sbd: string;

/**
 * Gets the currency identifier for the Seychelles Rupee.
 */
static scr: string;

/**
 * Gets the currency identifier for the Sudanese Pound.
 */
static sdg: string;

/**
 * Gets the currency identifier for the Swedish Krona.
 */
static sek: string;

/**
 * Gets the currency identifier for the Singapore Dollar.
 */
static sgd: string;

/**
 * Gets the currency identifier for the Saint Helena Pound.
 */
static shp: string;

/**
 * Gets the currency identifier for the Sierra Leone Leone.
 */
static sll: string;

/**
 * Gets the currency identifier for the Somali Shilling.
 */
static sos: string;

/**
 * Gets the currency identifier for the Suriname Dollar.
 */
static srd: string;

/**
 * Gets the currency identifier for the Sao Tome Dobra.
 */
static std: string;

/**
 * Gets the currency identifier for the Syrian Pound.
 */
static syp: string;

/**
 * Gets the currency identifier for the Swazi Lilangeni.
 */
static szl: string;

/**
 * Gets the currency identifier for the Thai Baht.
 */
static thb: string;

/**
 * Gets the currency identifier for the Tajikistani Somoni.
 */
static tjs: string;

/**
 * Gets the currency identifier for the Turkmenistan Manat.
 */
static tmt: string;

/**
 * Gets the currency identifier for the Tunisian Dinar.
 */
static tnd: string;

/**
 * Gets the currency identifier for the Tongan Pa'Anga.
 */
static top: string;

/**
 * Gets the currency identifier for the Turkish Lira.
 */
static try: string;

/**
 * Gets the currency identifier for the Trinidad and Tobago Dollar.
 */
static ttd: string;

/**
 * Gets the currency identifier for the New Taiwan Dollar.
 */
static twd: string;

/**
 * Gets the currency identifier for the Tanzanian Shilling.
 */
static tzs: string;

/**
 * Gets the currency identifier for the Ukrainian Hryvnia.
 */
static uah: string;

/**
 * Gets the currency identifier for the Uganda Shilling.
 */
static ugx: string;

/**
 * Gets the currency identifier for the United States Dollar.
 */
static usd: string;

/**
 * Gets the currency identifier for the Uruguayan Peso.
 */
static uyu: string;

/**
 * Gets the currency identifier for the Uzbekistani Som.
 */
static uzs: string;

/**
 * Gets the currency identifier for the Venezuelan Bolivar Fuerte.
 */
static vef: string;

/**
 * Gets the currency identifier for the Viet Nam Dong.
 */
static vnd: string;

/**
 * Gets the currency identifier for the Vanuatu Vatu.
 */
static vuv: string;

/**
 * Gets the currency identifier for the Samoa Tala.
 */
static wst: string;

/**
 * Gets the currency identifier for the Central African CFA.
 */
static xaf: string;

/**
 * Gets the currency identifier for the East Caribbean Dollar.
 */
static xcd: string;

/**
 * Gets the currency identifier for the West African CFA.
 */
static xof: string;

/**
 * Gets the currency identifier for the French Pacific Franc.
 */
static xpf: string;

/**
 * Gets the currency identifier that represents no currency.
 */
static xxx: string;

/**
 * Gets the currency identifier for the Yemeni Rial.
 */
static yer: string;

/**
 * Gets the currency identifier for the South African Rand.
 */
static zar: string;

/**
 * Gets the currency identifier for the Zambian Kwacha.
 */
static zmw: string;

/**
 * Gets the currency identifier for the Zimbabwean Dollar.
 */
static zwl: string
}


      declare var npm$namespace$Windows$Globalization$DateTimeFormatting: {
        
        
        DayFormat: typeof Windows$Globalization$DateTimeFormatting$DayFormat,
DayOfWeekFormat: typeof Windows$Globalization$DateTimeFormatting$DayOfWeekFormat,
HourFormat: typeof Windows$Globalization$DateTimeFormatting$HourFormat,
MinuteFormat: typeof Windows$Globalization$DateTimeFormatting$MinuteFormat,
MonthFormat: typeof Windows$Globalization$DateTimeFormatting$MonthFormat,
SecondFormat: typeof Windows$Globalization$DateTimeFormatting$SecondFormat,
YearFormat: typeof Windows$Globalization$DateTimeFormatting$YearFormat,
        DateTimeFormatter: typeof Windows$Globalization$DateTimeFormatting$DateTimeFormatter,
        
      }

/**
 * Formats dates and times.
 */
declare class Windows$Globalization$DateTimeFormatting$DateTimeFormatter  {

/**
 * Gets the DateTimeFormatter object that formats dates according to the user's choice of long date pattern.
 */
static longDate: Windows$Globalization$DateTimeFormatting$DateTimeFormatter;

/**
 * Gets the DateTimeFormatter object that formats times according to the user's choice of long time pattern.
 */
static longTime: Windows$Globalization$DateTimeFormatting$DateTimeFormatter;

/**
 * Gets the DateTimeFormatter object that formats dates according to the user's choice of short date pattern.
 */
static shortDate: Windows$Globalization$DateTimeFormatting$DateTimeFormatter;

/**
 * Gets the DateTimeFormatter object that formats times according to the user's choice of short time pattern.
 */
static shortTime: Windows$Globalization$DateTimeFormatting$DateTimeFormatter;

/**
 * Creates a DateTimeFormatter object that is initialized with hour, minute, and second formats.
 * @param hourFormat The desired hour format to include in the template.
 * @param minuteFormat The desired minute format to include in the template.
 * @param secondFormat The desired second format to include in the template.
 */
constructor(hourFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$HourFormat>, minuteFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$MinuteFormat>, secondFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$SecondFormat>): this;

/**
 * Creates a DateTimeFormatter object that is initialized by a format template string.
 * @param formatTemplate A format template string that specifies the requested components. The order of the components is irrelevant. This can also be a format pattern. See the remarks for the DateTimeFormatter class for a list of valid format templates and format patterns.
 */
constructor(formatTemplate: string): this;

/**
 * Creates a DateTimeFormatter object with all formats and identifiers specified.
 * @param yearFormat The desired year format to include in the template.
 * @param monthFormat The desired month format to include in the template.
 * @param dayFormat The desired day format to include in the template.
 * @param dayOfWeekFormat The desired day of week format to include in the template.
 * @param hourFormat The desired hour format to include in the template.
 * @param minuteFormat The desired minute format to include in the template.
 * @param secondFormat The desired second format to include in the template.
 * @param languages The list of language identifiers, in priority order, that represent the choice of languages. These identifiers are used for resolving the template to a pattern, and for formatting. See Remarks.
 * @param geographicRegion The identifier for the geographic region. This identifier is used for resolving the template to a pattern.
 * @param calendar The calendar identifier to use.
 * @param clock The clock identifier to use.
 */
constructor(yearFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$YearFormat>, monthFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$MonthFormat>, dayFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$DayFormat>, dayOfWeekFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$DayOfWeekFormat>, hourFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$HourFormat>, minuteFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$MinuteFormat>, secondFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$SecondFormat>, languages: Windows$Foundation$Collections$IIterable<string>, geographicRegion: string, calendar: string, clock: string): this;

/**
 * Creates a DateTimeFormatter object that is initialized by a format template string, language list, geographic region, calendar, and clock.
 * @param formatTemplate A format template string that specifies the requested components. The order of the components is irrelevant. This can also be a format pattern. See the remarks for the DateTimeFormatter class for a list of valid format templates and format patterns.
 * @param languages The list of language identifiers, in priority order, that represent the choice of languages. These identifiers are used for resolving the template to a pattern, and for formatting. See Remarks.
 * @param geographicRegion The identifier for the geographic region. This identifier is used for resolving the template to a pattern.
 * @param calendar The calendar identifier to use.
 * @param clock The clock identifier to use.
 */
constructor(formatTemplate: string, languages: Windows$Foundation$Collections$IIterable<string>, geographicRegion: string, calendar: string, clock: string): this;

/**
 * Creates a DateTimeFormatter object that is initialized with year, month, day, and day of week formats.
 * @param yearFormat The desired year format to include in the template.
 * @param monthFormat The desired month format to include in the template.
 * @param dayFormat The desired day format to include in the template.
 * @param dayOfWeekFormat The desired day of week format to include in the template.
 */
constructor(yearFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$YearFormat>, monthFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$MonthFormat>, dayFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$DayFormat>, dayOfWeekFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$DayOfWeekFormat>): this;

/**
 * Creates a DateTimeFormatter object that is initialized with year, month, day, day of week, hour, minute, and second formats, and a language list.
 * @param yearFormat The year format to include in the template.
 * @param monthFormat The month format to include in the template.
 * @param dayFormat The day format to include in the template.
 * @param dayOfWeekFormat The day of week format to include in the template.
 * @param hourFormat The hour format to include in the template.
 * @param minuteFormat The minute format to include in the template.
 * @param secondFormat The second format to include in the template.
 * @param languages The list of language identifiers, in priority order, that represent the choice of languages. These identifiers are used for resolving the template to a pattern and for formatting. See Remarks.
 */
constructor(yearFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$YearFormat>, monthFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$MonthFormat>, dayFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$DayFormat>, dayOfWeekFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$DayOfWeekFormat>, hourFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$HourFormat>, minuteFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$MinuteFormat>, secondFormat: $Values<typeof Windows$Globalization$DateTimeFormatting$SecondFormat>, languages: Windows$Foundation$Collections$IIterable<string>): this;

/**
 * Creates a DateTimeFormatter object that is initialized by a format template string and language list.
 * @param formatTemplate A format template string that specifies the requested components. The order of the components is irrelevant. This can also be a format pattern. See the remarks for the DateTimeFormatter class for a list of valid format templates and format patterns.
 * @param languages The list of language identifiers, in priority order, that represent the choice of languages. These identifiers are used for resolving the template to a pattern and for formatting. See Remarks.
 */
constructor(formatTemplate: string, languages: Windows$Foundation$Collections$IIterable<string>): this;

/**
 * Gets the calendar that is used when formatting dates.
 */
calendar: string;

/**
 * Gets the clock that is used when formatting times.
 */
clock: string;

/**
 * Returns a string representation of the provided date and time.
 * @param value The date and time to be formatted.
 * @return A string that represents the date and time.
 */
format(value: Date): string;

/**
 * Returns a string that represents the given date and time in the given time zone, conforming to the template the formatter is currently using.
 * @param datetime The date and time to be formatted.
 * @param timeZoneId An identifier from the IANA Time Zone Database which identifies the time zone that should be used (for example, "Americas/Los_Angeles" for Pacific Time).
 * @return A string that represents the date, time, and time zone.
 */
format(datetime: Date, timeZoneId: string): string;

/**
 * Gets or sets the region that is used when formatting dates and times.
 */
geographicRegion: string;

/**
 * Gets the DayFormat in the template.
 */
includeDay: $Values<typeof Windows$Globalization$DateTimeFormatting$DayFormat>;

/**
 * Gets the DayOfWeekFormat in the template.
 */
includeDayOfWeek: $Values<typeof Windows$Globalization$DateTimeFormatting$DayOfWeekFormat>;

/**
 * Gets the HourFormat in the template.
 */
includeHour: $Values<typeof Windows$Globalization$DateTimeFormatting$HourFormat>;

/**
 * Gets the MinuteFormat in the template.
 */
includeMinute: $Values<typeof Windows$Globalization$DateTimeFormatting$MinuteFormat>;

/**
 * Gets the MonthFormat in the template.
 */
includeMonth: $Values<typeof Windows$Globalization$DateTimeFormatting$MonthFormat>;

/**
 * Gets the SecondFormat in the template.
 */
includeSecond: $Values<typeof Windows$Globalization$DateTimeFormatting$SecondFormat>;

/**
 * Gets the YearFormat in the template.
 */
includeYear: $Values<typeof Windows$Globalization$DateTimeFormatting$YearFormat>;

/**
 * Gets the priority list of language identifiers that is used when formatting dates and times.
 */
languages: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets or sets the numbering system that is used to format dates and times.
 */
numeralSystem: string;

/**
 * Gets the patterns corresponding to this template that are used when formatting dates and times.
 */
patterns: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the geographic region that was most recently used to format dates and times.
 */
resolvedGeographicRegion: string;

/**
 * Gets the language that was most recently used to format dates and times.
 */
resolvedLanguage: string;

/**
 * Gets a string representation of this format template.
 */
template: string
}


/**
 * Specifies the intended format for the day in a DateTimeFormatter object.
 */

declare  var Windows$Globalization$DateTimeFormatting$DayFormat: {|
  +none: 0,// 0
+default: 1,// 1

|};



/**
 * Specifies the intended format for the day of the week in a DateTimeFormatter object.
 */

declare  var Windows$Globalization$DateTimeFormatting$DayOfWeekFormat: {|
  +none: 0,// 0
+default: 1,// 1
+abbreviated: 2,// 2
+full: 3,// 3

|};



/**
 * Specifies the intended format for the hour in a DateTimeFormatter object.
 */

declare  var Windows$Globalization$DateTimeFormatting$HourFormat: {|
  +none: 0,// 0
+default: 1,// 1

|};



/**
 * Specifies the intended format for the minute in a DateTimeFormatter object.
 */

declare  var Windows$Globalization$DateTimeFormatting$MinuteFormat: {|
  +none: 0,// 0
+default: 1,// 1

|};



/**
 * Specifies the intended format for the month in a DateTimeFormatter object.
 */

declare  var Windows$Globalization$DateTimeFormatting$MonthFormat: {|
  +none: 0,// 0
+default: 1,// 1
+abbreviated: 2,// 2
+full: 3,// 3
+numeric: 4,// 4

|};



/**
 * Specifies the intended format for the second in a DateTimeFormatter object.
 */

declare  var Windows$Globalization$DateTimeFormatting$SecondFormat: {|
  +none: 0,// 0
+default: 1,// 1

|};



/**
 * Specifies the intended format for the year in a DateTimeFormatter object.
 */

declare  var Windows$Globalization$DateTimeFormatting$YearFormat: {|
  +none: 0,// 0
+default: 1,// 1
+abbreviated: 2,// 2
+full: 3,// 3

|};



/**
 * Identifies the day of the week.
 */

declare  var Windows$Globalization$DayOfWeek: {|
  +sunday: 0,// 0
+monday: 1,// 1
+tuesday: 2,// 2
+wednesday: 3,// 3
+thursday: 4,// 4
+friday: 5,// 5
+saturday: 6,// 6

|};



      declare var npm$namespace$Windows$Globalization$Fonts: {
        
        
        
        LanguageFont: typeof Windows$Globalization$Fonts$LanguageFont,
LanguageFontGroup: typeof Windows$Globalization$Fonts$LanguageFontGroup,
        
      }

/**
 * Provides data related to a particular font recommendation for a given language.
 */
declare class Windows$Globalization$Fonts$LanguageFont  {

/**
 * Gets the family name of the font.
 */
fontFamily: string;

/**
 * Gets the FontStretch property of the font.
 */
fontStretch: $Values<typeof Windows$UI$Text$FontStretch>;

/**
 * Gets the FontStyle property of the font.
 */
fontStyle: $Values<typeof Windows$UI$Text$FontStyle>;

/**
 * Gets the weight of the font ( FontWeight ).
 */
fontWeight: Windows$UI$Text$FontWeight;

/**
 * Gets a recommended font size scaling factor for the font.
 */
scaleFactor: number
}


/**
 * Supplies a set of font recommendations for a given language or script for various usage cases.
 */
declare class Windows$Globalization$Fonts$LanguageFontGroup  {

/**
 * Creates a LanguageFontGroup object for a given language or script.
 * @param languageTag A BCP-47 language tag, or an ISO 15924 script identifier.
 */
constructor(languageTag: string): this;

/**
 * Gets a font that is recommended as an additional option for use in documents beyond the recommendations provided by DocumentHeadingFont , ModernDocumentFont and TraditionalDocumentFont .
 */
documentAlternate1Font: Windows$Globalization$Fonts$LanguageFont;

/**
 * Gets a font that is recommended as an additional option for use in documents beyond the recommendations provided by DocumentHeadingFont , ModernDocumentFont and TraditionalDocumentFont .
 */
documentAlternate2Font: Windows$Globalization$Fonts$LanguageFont;

/**
 * Gets a font that is recommended for use in document headings.
 */
documentHeadingFont: Windows$Globalization$Fonts$LanguageFont;

/**
 * Gets a font that is recommended for displaying fixed-width characters.
 */
fixedWidthTextFont: Windows$Globalization$Fonts$LanguageFont;

/**
 * Gets a font that is recommended for typical document body text following modern style conventions.
 */
modernDocumentFont: Windows$Globalization$Fonts$LanguageFont;

/**
 * Gets a font that is recommended for typical document body text following traditional style conventions.
 */
traditionalDocumentFont: Windows$Globalization$Fonts$LanguageFont;

/**
 * Gets a font that is recommended for special UI elements, such as captions, that are displayed at sizes smaller than typical UI body text.
 */
uiCaptionFont: Windows$Globalization$Fonts$LanguageFont;

/**
 * Gets a font that is recommended for special UI elements, such as headings, that are displayed at sizes somewhat larger than typical UI body text.
 */
uiHeadingFont: Windows$Globalization$Fonts$LanguageFont;

/**
 * Gets a font that is recommended for special UI elements, such as headings in notifications or other app messages, that are displayed at UI body text size or only slightly larger yet need to be differentiated from UI body text.
 */
uiNotificationHeadingFont: Windows$Globalization$Fonts$LanguageFont;

/**
 * Gets a font that is recommended for typical UI body text.
 */
uiTextFont: Windows$Globalization$Fonts$LanguageFont;

/**
 * Gets a font that is recommended for special UI elements set at sizes much larger than typical UI body text.
 */
uiTitleFont: Windows$Globalization$Fonts$LanguageFont
}


/**
 * Describes a region. This is usually a country, but may be a macroregion.
 */
declare class Windows$Globalization$GeographicRegion  {

/**
 * Determines whether a geographic region identifier is supported.
 * @param geographicRegionCode One of the ISO 3166-1 two-letter or three-letter codes that identify the country, or one of the three-digit UN-M49 codes that identify the geographical region.
 * @return True if the ID is known; otherwise, false. If this method returns true, an app can safely construct a region by using this region identifier. If it returns false, attempting to construct a region for the given code will throw an exception.
 */
static isSupported(geographicRegionCode: string): boolean;

/**
 * Creates a GeographicRegion object that defaults to the user's home region.
 */
constructor(): this;

/**
 * Creates a GeographicRegion object.
 * @param geographicRegionCode One of the ISO 3166-1 two-letter or three-letter codes that identify the country, or one of the three-digit UN-M49 codes that identify the geographical region.
 */
constructor(geographicRegionCode: string): this;

/**
 * Gets the string that contains the best available identifier that represents the region.
 */
code: string;

/**
 * Gets the three-digit identifier for this region, as a string.
 */
codeThreeDigit: string;

/**
 * Gets the three-letter identifier for this region.
 */
codeThreeLetter: string;

/**
 * Gets the two-letter identifier for this region.
 */
codeTwoLetter: string;

/**
 * Gets the set of currencies in use in this region.
 */
currenciesInUse: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets a localized string that is suitable for display to the user for identifying the region.
 */
displayName: string;

/**
 * Gets the name of the region in the primary language spoken in this region.
 */
nativeName: string
}


/**
 * Represents a single Japanese word (a "reading") that has been extracted from a Japanese string by JapanesePhoneticAnalyzer .
 */
declare class Windows$Globalization$JapanesePhoneme  {

/**
 * Gets the text to display for this Japanese word.
 */
displayText: string;

/**
 * Gets a Boolean that indicates if this Japanese word is the start of a phrase.
 */
isPhraseStart: boolean;

/**
 * Gets the "reading" (the pronunciation of DisplayText ) for this Japanese word.
 */
yomiText: string
}


/**
 * Reads a Japanese string that is a combination of Kanji characters and Hiragana characters, and returns a collection of proper readings from the string with word breaks.
 */
declare class Windows$Globalization$JapanesePhoneticAnalyzer  {

/**
 * Reads a Japanese string that is a combination of Kanji characters and Hiragana characters, and returns a collection of proper readings from the string with word breaks. Optionally uses the "Mono Ruby" strategy in breaking multi-Kanji words into multiple Kanji words.
 * @param input A Japanese string that is a combination of Kanji characters and Hiragana characters.
 * @param monoRuby Specifies the use of the word-breaking strategy "Mono Ruby".
 * @return A collection of JapanesePhoneme objects that represent proper readings from the string with word breaks.
 */
static getWords(
input: string,
monoRuby: boolean): Windows$Foundation$Collections$IVectorView<Windows$Globalization$JapanesePhoneme>;

/**
 * Reads a Japanese string that is a combination of Kanji characters and Hiragana characters, and returns a collection of proper readings from the string with word breaks.
 * @param input A Japanese string that is a combination of Kanji characters and Hiragana characters.
 * @return A collection of JapanesePhoneme objects that represent proper readings from the string with word breaks.
 */
static getWords(
input: string): Windows$Foundation$Collections$IVectorView<Windows$Globalization$JapanesePhoneme>
}


/**
 * A class that provides information related to BCP-47 language tags such as the language name and the script.
 */
declare class Windows$Globalization$Language  {

/**
 * Gets the BCP-47 language tag for the currently enabled keyboard layout or Input Method Editor (IME).
 */
static currentInputMethodLanguageTag: string;

/**
 * Determines whether a BCP-47 language tag is well-formed.
 * @param languageTag A BCP-47 language tag.
 * @return True if the language tag is well-formed as defined by BCP-47, except when the language tag can never be valid according to BCP-47. Otherwise it returns false. If this method returns true, an application can safely construct a language by using this tag. If it returns false, attempting to construct a language for the given tag will throw an exception.
 */
static isWellFormed(languageTag: string): boolean;

/**
 * Tries to set the normalized BCP-47 language tag of this language.
 * @param languageTag The normalized BCP-47 language tag.
 * @return true if the value is successfully set, otherwise false.
 */
static trySetInputMethodLanguageTag(languageTag: string): boolean;

/**
 * Creates a Language object.
 * @param languageTag A BCP-47 language tag. See Remarks.
 */
constructor(languageTag: string): this;

/**
 * Gets a localized string that is suitable for display to the user for identifying the language.
 */
displayName: string;

/**
 * Retrieves a vector of extension subtags in the current language for the given extension identified by singleton.
 * @param singleton A single-character subtag for the LanguageTag of the current language. See BCP-47 language tags, Extensions and the Extensions Registry.
 * @return The list of extension subtags identified by singleton.
 */
getExtensionSubtags(singleton: string): Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the normalized BCP-47 language tag for this language.
 */
languageTag: string;

/**
 * Gets the name of the language in the language itself.
 */
nativeName: string;

/**
 * Gets the four-letter ISO 15924 script code of the language.
 */
script: string
}


      declare var npm$namespace$Windows$Globalization$NumberFormatting: {
        
        
        CurrencyFormatterMode: typeof Windows$Globalization$NumberFormatting$CurrencyFormatterMode,
RoundingAlgorithm: typeof Windows$Globalization$NumberFormatting$RoundingAlgorithm,
        CurrencyFormatter: typeof Windows$Globalization$NumberFormatting$CurrencyFormatter,
DecimalFormatter: typeof Windows$Globalization$NumberFormatting$DecimalFormatter,
IncrementNumberRounder: typeof Windows$Globalization$NumberFormatting$IncrementNumberRounder,
NumeralSystemTranslator: typeof Windows$Globalization$NumberFormatting$NumeralSystemTranslator,
PercentFormatter: typeof Windows$Globalization$NumberFormatting$PercentFormatter,
PermilleFormatter: typeof Windows$Globalization$NumberFormatting$PermilleFormatter,
SignificantDigitsNumberRounder: typeof Windows$Globalization$NumberFormatting$SignificantDigitsNumberRounder,
        
      }

/**
 * Formats and parses currencies.
 */
declare class Windows$Globalization$NumberFormatting$CurrencyFormatter  {

/**
 * Creates a CurrencyFormatter object initialized with a currency identifier, language list, and geographic region.
 * @param currencyCode The currency identifier to use when formatting and parsing currency values.
 * @param languages The list of language identifiers, in priority order, representing the choice of languages. See Remarks.
 * @param geographicRegion The identifier for the geographic region.
 */
constructor(currencyCode: string, languages: Windows$Foundation$Collections$IIterable<string>, geographicRegion: string): this;

/**
 * Creates a CurrencyFormatter object that is initialized with a currency identifier.
 * @param currencyCode The currency identifier to use when formatting and parsing currency values.
 */
constructor(currencyCode: string): this;

/**
 * Prepares the CurrencyFormatter object to format currency values with a specified rounding algorithm.
 * @param roundingAlgorithm The desired rounding algorithm for the currency. This must be one of the members of RoundingAlgorithm , excluding None.
 */
applyRoundingForCurrency(
roundingAlgorithm: $Values<typeof Windows$Globalization$NumberFormatting$RoundingAlgorithm>): void;

/**
 * Gets the identifier for the currency to be used for formatting and parsing currency values.
 */
currency: string;

/**
 * Returns a string representation of a UInt64 currency value.
 * @param value The UInt64 currency value to be formatted.
 * @return A string that represents the value.
 */
format(value: number): string;

/**
 * Returns a string representation of a Double currency value.
 * @param value The Double currency value to be formatted.
 * @return A string that represents the value.
 */
format(value: number): string;

/**
 * Returns a string representation of an Int64 currency value.
 * @param value The Int64 currency value to be formatted.
 * @return A string that represents the value.
 */
format(value: number): string;

/**
 * Returns a string representation of a Double currency value.
 * @param value The Double currency value to be formatted.
 * @return A string that represents the value.
 */
formatDouble(value: number): string;

/**
 * Returns a string representation of an Int64 currency value.
 * @param value The Int64 currency value to be formatted.
 * @return A string that represents the value.
 */
formatInt(value: number): string;

/**
 * Returns a string representation of a UInt64 currency value.
 * @param value The UInt64 currency value to be formatted.
 * @return The UInt64 currency value to be formatted.
 */
formatUInt(value: number): string;

/**
 * Gets or sets the minimum number of digits to display for the fraction part of the currency value.
 */
fractionDigits: number;

/**
 * Gets the region that is used when formatting and parsing currency values.
 */
geographicRegion: string;

/**
 * Gets or sets the minimum number of digits to display for the integer part of the currency value.
 */
integerDigits: number;

/**
 * Gets or sets whether the decimal point of the currency value should always be displayed.
 */
isDecimalPointAlwaysDisplayed: boolean;

/**
 * Gets or sets whether the integer part of the currency value should be grouped.
 */
isGrouped: boolean;

/**
 * Gets or sets whether -0 is formatted using the conventions for negative numbers or for positive numbers. (In the Latin numeral system, the choice is "-0" or "0".)
 */
isZeroSigned: boolean;

/**
 * Gets the priority list of language identifiers that is used when formatting and parsing currency values.
 */
languages: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets or sets whether the currency is formatted with the currency symbol or currency code.
 */
mode: $Values<typeof Windows$Globalization$NumberFormatting$CurrencyFormatterMode>;

/**
 * Gets or sets the current rounding strategy to be used when formatting currency amounts.
 */
numberRounder: Windows$Globalization$NumberFormatting$INumberRounder;

/**
 * Gets or sets the numbering system that is used to format and parse currency values.
 */
numeralSystem: string;

/**
 * Attempts to parse a string representation of a Double currency value.
 * @param text The text to be parsed.
 * @return If successful, a Double that corresponds to the string representation, and otherwise null.
 */
parseDouble(text: string): number;

/**
 * Attempts to parse a string representation of an integer currency value.
 * @param text The text to be parsed.
 * @return If successful, an Int64 that corresponds to the string representation, and otherwise null.
 */
parseInt(text: string): number;

/**
 * Attempts to parse a string representation of an unsigned integer currency value.
 * @param text The text to be parsed.
 * @return If successful, a UInt64 that corresponds to the string representation, and otherwise null.
 */
parseUInt(text: string): number;

/**
 * Gets the geographic region that was most recently used to format or parse currency values.
 */
resolvedGeographicRegion: string;

/**
 * Gets the language that was most recently used to format or parse currency values.
 */
resolvedLanguage: string;

/**
 * Gets or sets the current padding to significant digits when a currency amount is formatted.
 */
significantDigits: number
}


/**
 * Specifies the use of symbols or codes when currency is formatted.
 */

declare  var Windows$Globalization$NumberFormatting$CurrencyFormatterMode: {|
  +useSymbol: 0,// 0
+useCurrencyCode: 1,// 1

|};



/**
 * Formats and parses decimal numbers.
 */
declare class Windows$Globalization$NumberFormatting$DecimalFormatter  {

/**
 * Creates a DecimalFormatter object and initializes it to default values.
 */
constructor(): this;

/**
 * Creates a DecimalFormatter object initialized by a language list and a geographic region.
 * @param languages The list of language identifiers, in priority order, representing the choice of languages. See Remarks.
 * @param geographicRegion The identifier for the geographic region.
 */
constructor(languages: Windows$Foundation$Collections$IIterable<string>, geographicRegion: string): this;

/**
 * Returns a string representation of a Double number.
 * @param value The Double value to be formatted.
 * @return A string that represents the number.
 */
format(value: number): string;

/**
 * Returns a string representation of an Int64 number.
 * @param value The Int64 value to be formatted.
 * @return A string that represents the number.
 */
format(value: number): string;

/**
 * Returns a string representation of a UInt64 number.
 * @param value The UInt64 value to be formatted.
 * @return A string that represents the number.
 */
format(value: number): string;

/**
 * Returns a string representation of a Double number.
 * @param value The Double value to be formatted.
 * @return A string that represents the number.
 */
formatDouble(value: number): string;

/**
 * Returns a string representation of an Int64 number.
 * @param value The Int64 value to be formatted.
 * @return A string that represents the number.
 */
formatInt(value: number): string;

/**
 * Returns a string representation of a UInt64 number.
 * @param value The UInt64 value to be formatted.
 * @return A string that represents the number.
 */
formatUInt(value: number): string;

/**
 * Gets or sets the minimum number of digits to display for the fraction part of the number.
 */
fractionDigits: number;

/**
 * Gets the region that is used when formatting and parsing decimal numbers.
 */
geographicRegion: string;

/**
 * Gets or sets the minimum number of digits to display for the integer part of the number.
 */
integerDigits: number;

/**
 * Gets or sets whether the decimal point of the number should always be displayed.
 */
isDecimalPointAlwaysDisplayed: boolean;

/**
 * Gets or sets whether the integer part of the number should be grouped.
 */
isGrouped: boolean;

/**
 * Gets or sets whether -0 is formatted as "-0" or "0".
 */
isZeroSigned: boolean;

/**
 * Gets the priority list of language identifiers that is used when formatting and parsing decimal numbers.
 */
languages: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets or sets the current rounding strategy to be used when formatting numbers.
 */
numberRounder: Windows$Globalization$NumberFormatting$INumberRounder;

/**
 * Gets or sets the numbering system that is used to format and parse decimal numbers.
 */
numeralSystem: string;

/**
 * Attempts to parse a string representation of a Double number.
 * @param text The text to be parsed.
 * @return If successful, a Double that corresponds to the string representation, and otherwise null.
 */
parseDouble(text: string): number;

/**
 * Attempts to parse a string representation of an integer.
 * @param text The text to be parsed.
 * @return If successful, an Int64 that corresponds to the string representation, and otherwise null.
 */
parseInt(text: string): number;

/**
 * Attempts to parse a string representation of an unsigned integer.
 * @param text The text to be parsed.
 * @return If successful, a UInt64 that corresponds to the string representation, and otherwise null.
 */
parseUInt(text: string): number;

/**
 * Gets the geographic region that was most recently used to format or parse decimal values.
 */
resolvedGeographicRegion: string;

/**
 * Gets the language that was most recently used to format or parse decimal values.
 */
resolvedLanguage: string;

/**
 * Gets or sets the current padding to significant digits when a decimal number is formatted.
 */
significantDigits: number
}


/**
 * Rounds numbers to a specified increment.
 */
declare class Windows$Globalization$NumberFormatting$IncrementNumberRounder  {

/**
 * Creates an IncrementNumberRounder object.
 */
constructor(): this;

/**
 * Gets or sets the increment this IncrementNumberRounder object uses for rounding.
 */
increment: number;

/**
 * Rounds a Double number to the specified increment.
 * @param value The Double value to be rounded.
 * @return The rounded number. This result is a double precision floating point number, which is not necessarily an integer.
 */
roundDouble(value: number): number;

/**
 * Rounds an Int32 number to the specified increment.
 * @param value The Int32 value to be rounded.
 * @return The rounded 32 bit integer.
 */
roundInt32(value: number): number;

/**
 * Rounds an Int64 number to the specified increment.
 * @param value The Int64 value to be rounded.
 * @return The rounded 64 bit integer.
 */
roundInt64(value: number): number;

/**
 * Rounds a Single number to the specified increment.
 * @param value The Single value to be rounded.
 * @return The rounded number. This result is a single precision floating point number, which is not necessarily an integer.
 */
roundSingle(value: number): number;

/**
 * Rounds a UInt32 number to the specified increment.
 * @param value The UInt32 value to be rounded.
 * @return The rounded unsigned 32 bit integer.
 */
roundUInt32(value: number): number;

/**
 * Rounds a UInt64 number to the specified increment.
 * @param value The UInt64 value to be rounded.
 * @return The rounded unsigned 64 bit integer.
 */
roundUInt64(value: number): number;

/**
 * Gets or sets the rounding strategy value for this IncrementNumberRounder object.
 */
roundingAlgorithm: $Values<typeof Windows$Globalization$NumberFormatting$RoundingAlgorithm>
}


/**
 * Translates digits of the Latin numerical system into digits of another numerical system.
 */
declare class Windows$Globalization$NumberFormatting$NumeralSystemTranslator  {

/**
 * Creates a NumeralSystemTranslator object initialized by a language list.
 * @param languages A list of BCP-47 language tags, in priority order, representing the choice of languages. They must all be well-formed according to Windows.Globalization.Language.isWellFormed .
 */
constructor(languages: Windows$Foundation$Collections$IIterable<string>): this;

/**
 * Creates a NumeralSystemTranslator object initialized by the list of current runtime language values preferred by the user.
 */
constructor(): this;

/**
 * Gets the BCP-47 language tag(s) used to initialize this NumeralSystemTranslator object.
 */
languages: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets or sets the numeral system that Latin digits will be converted to on calls to TranslateNumerals .
 */
numeralSystem: string;

/**
 * Gets the language used to determine the numeral system when this object was initialized.
 */
resolvedLanguage: string;

/**
 * Converts a string of characters containing Latin digits to a string containing the corresponding digits of NumeralSystem .
 * @param value A string of characters containing Latin digits to be converted.
 * @return A string containing the converted digits. This string may be a different length than value.
 */
translateNumerals(value: string): string
}


/**
 * Formats and parses percentages.
 */
declare class Windows$Globalization$NumberFormatting$PercentFormatter  {

/**
 * Creates a PercentFormatter object and initializes it to default values.
 */
constructor(): this;

/**
 * Creates a PercentFormatter object initialized by a language list and a geographic region.
 * @param languages The list of language identifiers, in priority order, representing the choice of languages. See Remarks.
 * @param geographicRegion The identifier for the geographic region.
 */
constructor(languages: Windows$Foundation$Collections$IIterable<string>, geographicRegion: string): this;

/**
 * Returns a string representation of a UInt64 percentage.
 * @param value The UInt64 value to be formatted.
 * @return A string that represents the percentage.
 */
format(value: number): string;

/**
 * Returns a string representation of an Int64 percentage.
 * @param value The Int64 value to be formatted.
 * @return A string that represents the percentage.
 */
format(value: number): string;

/**
 * Returns a string representation of a Double percentage.
 * @param value The Double value to be formatted.
 * @return A string that represents the percentage.
 */
format(value: number): string;

/**
 * Returns a string representation of a Double percentage.
 * @param value The Double value to be formatted.
 * @return A string that represents the percentage.
 */
formatDouble(value: number): string;

/**
 * Returns a string representation of an Int64 percentage.
 * @param value The Int64 value to be formatted.
 * @return A string that represents the percentage.
 */
formatInt(value: number): string;

/**
 * Returns a string representation of a UInt64 percentage.
 * @param value The UInt64 value to be formatted.
 * @return A string that represents the percentage.
 */
formatUInt(value: number): string;

/**
 * Gets or sets the minimum number of digits to display for the fraction part of the percentage.
 */
fractionDigits: number;

/**
 * Gets the region that is used when formatting and parsing percentages.
 */
geographicRegion: string;

/**
 * Gets or sets the minimum number of digits to display for the integer part of the percentage.
 */
integerDigits: number;

/**
 * Gets or sets whether the decimal point of the percentage should always be displayed.
 */
isDecimalPointAlwaysDisplayed: boolean;

/**
 * Gets or sets whether the integer part of the percentage should be grouped.
 */
isGrouped: boolean;

/**
 * Gets or sets whether -0 is formatted as "-0" or "0".
 */
isZeroSigned: boolean;

/**
 * Gets the priority list of language identifiers that is used when formatting and parsing percentages.
 */
languages: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets or sets the current rounding strategy to be used when formatting percents.
 */
numberRounder: Windows$Globalization$NumberFormatting$INumberRounder;

/**
 * Gets or sets the numbering system that is used to format and parse percentages.
 */
numeralSystem: string;

/**
 * Attempts to parse a string representation of a Double percentage.
 * @param text The text to be parsed.
 * @return If successful, a Double that corresponds to the string representation, and otherwise null.
 */
parseDouble(text: string): number;

/**
 * Attempts to parse a string representation of an integer percentage.
 * @param text The text to be parsed.
 * @return If successful, an Int64 that corresponds to the string representation, and otherwise null.
 */
parseInt(text: string): number;

/**
 * Attempts to parse a string representation of an unsigned integer percentage.
 * @param text The text to be parsed.
 * @return If successful, a UInt64 that corresponds to the string representation, and otherwise null.
 */
parseUInt(text: string): number;

/**
 * Gets the geographic region that was most recently used to format or parse percent values.
 */
resolvedGeographicRegion: string;

/**
 * Gets the language that was most recently used to format or parse percent values.
 */
resolvedLanguage: string;

/**
 * Gets or sets the current padding to significant digits when a percent is formatted.
 */
significantDigits: number
}


/**
 * Formats and parses permillages.
 */
declare class Windows$Globalization$NumberFormatting$PermilleFormatter  {

/**
 * Creates a PermilleFormatter object and initializes it to default values.
 */
constructor(): this;

/**
 * Creates a PermilleFormatter object initialized by a language list and a geographic region.
 * @param languages The list of language identifiers, in priority order, representing the choice of languages. See Remarks.
 * @param geographicRegion The identifier for the geographic region.
 */
constructor(languages: Windows$Foundation$Collections$IIterable<string>, geographicRegion: string): this;

/**
 * Returns a string representation of a UInt64 permillage.
 * @param value The UInt64 value to be formatted.
 * @return A string that represents the permillage.
 */
format(value: number): string;

/**
 * Returns a string representation of an Int64 permillage.
 * @param value The Int64 value to be formatted.
 * @return A string that represents the permillage.
 */
format(value: number): string;

/**
 * Returns a string representation of a Double permillage.
 * @param value The Double value to be formatted.
 * @return A string that represents the permillage.
 */
format(value: number): string;

/**
 * Returns a string representation of a Double permillage.
 * @param value The Double value to be formatted.
 * @return A string that represents the permillage.
 */
formatDouble(value: number): string;

/**
 * Returns a string representation of an Int64 permillage.
 * @param value The Int64 value to be formatted.
 * @return A string that represents the permillage.
 */
formatInt(value: number): string;

/**
 * Returns a string representation of a UInt64 permillage.
 * @param value The UInt64 value to be formatted.
 * @return A string that represents the permillage.
 */
formatUInt(value: number): string;

/**
 * Gets or sets the minimum number of digits to display for the fraction part of the permillage.
 */
fractionDigits: number;

/**
 * Gets the region that is used when formatting and parsing permille values.
 */
geographicRegion: string;

/**
 * Gets or sets the minimum number of digits to display for the integer part of the permillage.
 */
integerDigits: number;

/**
 * Gets or sets whether the decimal point of the permillage should always be displayed.
 */
isDecimalPointAlwaysDisplayed: boolean;

/**
 * Gets or sets whether the integer part of the permillage should be grouped.
 */
isGrouped: boolean;

/**
 * Gets or sets whether -0 is formatted as "-0" or "0".
 */
isZeroSigned: boolean;

/**
 * Gets the priority list of language identifiers that is used when formatting and parsing permille values.
 */
languages: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets or sets the current rounding strategy to be used when formatting permilles.
 */
numberRounder: Windows$Globalization$NumberFormatting$INumberRounder;

/**
 * Gets or sets the numbering system that is used to format and parse permille values.
 */
numeralSystem: string;

/**
 * Attempts to parse a string representation of a Double permillage.
 * @param text The text to be parsed.
 * @return If successful, a Double that corresponds to the string representation, and otherwise null.
 */
parseDouble(text: string): number;

/**
 * Attempts to parse a string representation of an integer permillage.
 * @param text The text to be parsed.
 * @return If successful, an Int64 that corresponds to the string representation, and otherwise null.
 */
parseInt(text: string): number;

/**
 * Attempts to parse a string representation of an unsigned integer permillage.
 * @param text The text to be parsed.
 * @return If successful, a UInt64 that corresponds to the string representation, and otherwise null.
 */
parseUInt(text: string): number;

/**
 * Gets the geographic region that was most recently used to format or parse permille values.
 */
resolvedGeographicRegion: string;

/**
 * Gets the language that was most recently used to format or parse permille values.
 */
resolvedLanguage: string;

/**
 * Gets or sets the current padding to significant digits when a permille is formatted.
 */
significantDigits: number
}


/**
 * Specifies the algorithm used to round numbers.
 */

declare  var Windows$Globalization$NumberFormatting$RoundingAlgorithm: {|
  +none: 0,// 0
+roundDown: 1,// 1
+roundUp: 2,// 2
+roundTowardsZero: 3,// 3
+roundAwayFromZero: 4,// 4
+roundHalfDown: 5,// 5
+roundHalfUp: 6,// 6
+roundHalfTowardsZero: 7,// 7
+roundHalfAwayFromZero: 8,// 8
+roundHalfToEven: 9,// 9
+roundHalfToOdd: 10,// 10

|};



/**
 * Rounds numbers to a specified number of significant digits.
 */
declare class Windows$Globalization$NumberFormatting$SignificantDigitsNumberRounder  {

/**
 * Creates a SignificantDigitsNumberRounder object.
 */
constructor(): this;

/**
 * Rounds a Double number to the specified number of significant digits.
 * @param value The Double value to be rounded.
 * @return The rounded number. This result is a double precision floating point number, which is not necessarily an integer.
 */
roundDouble(value: number): number;

/**
 * Rounds an Int32 number to the specified number of significant digits.
 * @param value The Int32 value to be rounded.
 * @return The rounded 32 bit integer.
 */
roundInt32(value: number): number;

/**
 * Rounds an Int64 number to the specified number of significant digits.
 * @param value The Int64 value to be rounded.
 * @return The rounded 64 bit integer.
 */
roundInt64(value: number): number;

/**
 * Rounds a Single number to the specified number of significant digits.
 * @param value The Single value to be rounded.
 * @return The rounded number. This result is a single precision floating point number, which is not necessarily an integer.
 */
roundSingle(value: number): number;

/**
 * Rounds a UInt32 number to the specified number of significant digits.
 * @param value The UInt32 value to be rounded.
 * @return The rounded unsigned 32 bit integer.
 */
roundUInt32(value: number): number;

/**
 * Rounds a UInt64 number to the specified number of significant digits.
 * @param value The UInt64 value to be rounded.
 * @return The rounded unsigned 64 bit integer.
 */
roundUInt64(value: number): number;

/**
 * Gets or sets the rounding strategy value for this SignificantDigitsNumberRounder object.
 */
roundingAlgorithm: $Values<typeof Windows$Globalization$NumberFormatting$RoundingAlgorithm>;

/**
 * Gets or sets the number of significant digits this SignificantDigitsNumberRounder object uses for rounding.
 */
significantDigits: number
}


/**
 * An interface that returns rounded results for provided numbers of several data types.
 */
declare interface Windows$Globalization$NumberFormatting$INumberRounder {

/**
 * Rounds a Double number.
 * @param value The Double value to be rounded.
 * @return The rounded number. This result is a double precision floating point number, which is not necessarily an integer.
 */
roundDouble(value: number): number,

/**
 * Rounds an Int32 number.
 * @param value The Int32 value to be rounded.
 * @return The rounded 32 bit integer.
 */
roundInt32(value: number): number,

/**
 * Rounds an Int64 number.
 * @param value The Int64 value to be rounded.
 * @return The rounded 64 bit integer.
 */
roundInt64(value: number): number,

/**
 * Rounds a Single number.
 * @param value The Single value to be rounded.
 * @return The rounded number. This result is a single precision floating point number, which is not necessarily an integer.
 */
roundSingle(value: number): number,

/**
 * Rounds a UInt32 number.
 * @param value The UInt32 value to be rounded.
 * @return The rounded unsigned 32 bit integer.
 */
roundUInt32(value: number): number,

/**
 * Rounds a UInt64 number.
 * @param value The UInt64 value to be rounded.
 * @return The rounded unsigned 64 bit integer.
 */
roundUInt64(value: number): number
} 


/**
 * Contains the numeral system identifiers for the supported numeral systems, as static properties.
 */
declare class Windows$Globalization$NumeralSystemIdentifiers  {

/**
 * Gets the identifier for the Arabic-Indic decimal numeral system.
 */
static arab: string;

/**
 * Gets the identifier for the Extended Arabic-Indic decimal numeral system.
 */
static arabExt: string;

/**
 * Gets the identifier for the Balinese decimal numeral system.
 */
static bali: string;

/**
 * Gets the identifier for the Bangla decimal numeral system.
 */
static beng: string;

/**
 * Gets the identifier for the Brahmi decimal numeral system.
 */
static brah: string;

/**
 * Gets the identifier for the Cham decimal numeral system.
 */
static cham: string;

/**
 * Gets the identifier for the Devanagari decimal numeral system.
 */
static deva: string;

/**
 * Gets the identifier for the Latin decimal numeral system using full-width characters.
 */
static fullWide: string;

/**
 * Gets the identifier for the Gujarati decimal numeral system.
 */
static gujr: string;

/**
 * Gets the identifier for the Gurmukhi decimal numeral system.
 */
static guru: string;

/**
 * Gets the identifier for the Han decimal numeral system.
 */
static haniDec: string;

/**
 * Gets the identifier for the Javanese decimal numeral system.
 */
static java: string;

/**
 * Gets the identifier for the Kayah Li decimal numeral system.
 */
static kali: string;

/**
 * Gets the identifier for the Khmer decimal numeral system.
 */
static khmr: string;

/**
 * Gets the identifier for the Kannada decimal numeral system.
 */
static knda: string;

/**
 * Gets the identifier for the Tai Tham Hora decimal numeral system.
 */
static lana: string;

/**
 * Gets the identifier for the Tai Tham Tham decimal numeral system.
 */
static lanaTham: string;

/**
 * Gets the identifier for the Laoo decimal numeral system.
 */
static laoo: string;

/**
 * Gets the identifier for the Latin decimal numeral system.
 */
static latn: string;

/**
 * Gets the identifier for the Lepcha decimal numeral system.
 */
static lepc: string;

/**
 * Gets the identifier for the Limbu decimal numeral system.
 */
static limb: string;

/**
 * Gets the identifier for the decimal numeral system using MathBold characters.
 */
static mathBold: string;

/**
 * Gets the identifier for the decimal numeral system using MathDbl characters.
 */
static mathDbl: string;

/**
 * Gets the identifier for the decimal numeral system using MathMono characters.
 */
static mathMono: string;

/**
 * Gets the identifier for the decimal numeral system using MathSanb characters.
 */
static mathSanb: string;

/**
 * Gets the identifier for the decimal numeral system using MathSans characters.
 */
static mathSans: string;

/**
 * Gets the identifier for the Malayalam decimal numeral system.
 */
static mlym: string;

/**
 * Gets the identifier for the Mongolian decimal numeral system.
 */
static mong: string;

/**
 * Gets the identifier for the Meetei Mayek decimal numeral system.
 */
static mtei: string;

/**
 * Gets the identifier for the Myanmar decimal numeral system.
 */
static mymr: string;

/**
 * Gets the identifier for the Myanmar Shan decimal numeral system.
 */
static mymrShan: string;

/**
 * Gets the identifier for the Nko decimal numeral system.
 */
static nkoo: string;

/**
 * Gets the identifier for the Ol Chiki decimal numeral system.
 */
static olck: string;

/**
 * Gets the identifier for the Odia decimal numeral system.
 */
static orya: string;

/**
 * Gets the identifier for the Osmanya decimal numeral system.
 */
static osma: string;

/**
 * Gets the identifier for the Saurashtra decimal numeral system.
 */
static saur: string;

/**
 * Gets the identifier for the Sundanese decimal numeral system.
 */
static sund: string;

/**
 * Gets the identifier for the New Tai Lue decimal numeral system.
 */
static talu: string;

/**
 * Gets the identifier for the Tamil decimal numeral system.
 */
static tamlDec: string;

/**
 * Gets the identifier for the Telugu decimal numeral system.
 */
static telu: string;

/**
 * Gets the identifier for the Thai decimal numeral system.
 */
static thai: string;

/**
 * Gets the identifier for the Tibetan decimal numeral system.
 */
static tibt: string;

/**
 * Gets the identifier for the Vai decimal numeral system.
 */
static vaii: string;

/**
 * Gets the identifier for the decimal numeral system using ZmthBold (Mathematical notation) characters.
 */
static zmthBold: string;

/**
 * Gets the identifier for the decimal numeral system using ZmthDbl (Mathematical notation) characters.
 */
static zmthDbl: string;

/**
 * Gets the identifier for the decimal numeral system using ZmthMono (Mathematical notation) characters.
 */
static zmthMono: string;

/**
 * Gets the identifier for the decimal numeral system using ZmthSanb (Mathematical notation) characters.
 */
static zmthSanb: string;

/**
 * Gets the identifier for the decimal numeral system using ZmthSans (Mathematical notation) characters.
 */
static zmthSans: string
}


      declare var npm$namespace$Windows$Graphics: {
        
        
        
        
        DirectX: typeof npm$namespace$Windows$Graphics$DirectX,
Display: typeof npm$namespace$Windows$Graphics$Display,
Holographic: typeof npm$namespace$Windows$Graphics$Holographic,
Imaging: typeof npm$namespace$Windows$Graphics$Imaging,
Printing: typeof npm$namespace$Windows$Graphics$Printing,
Printing3D: typeof npm$namespace$Windows$Graphics$Printing3D,
      }

      declare var npm$namespace$Windows$Graphics$DirectX: {
        
        
        DirectXAlphaMode: typeof Windows$Graphics$DirectX$DirectXAlphaMode,
DirectXPixelFormat: typeof Windows$Graphics$DirectX$DirectXPixelFormat,
        
        Direct3D11: typeof npm$namespace$Windows$Graphics$DirectX$Direct3D11,
      }

      declare var npm$namespace$Windows$Graphics$DirectX$Direct3D11: {
        
        
        Direct3DBindings: typeof Windows$Graphics$DirectX$Direct3D11$Direct3DBindings,
Direct3DUsage: typeof Windows$Graphics$DirectX$Direct3D11$Direct3DUsage,
        
        
      }

/**
 * A Windows Runtime projection of the D3D11_BIND_FLAG enumeration. Identifies the ways in which a resource may be bound to the graphics pipeline.
 */

declare  var Windows$Graphics$DirectX$Direct3D11$Direct3DBindings: {|
  +vertexBuffer: 0,// 0
+indexBuffer: 1,// 1
+constantBuffer: 2,// 2
+shaderResource: 3,// 3
+streamOutput: 4,// 4
+renderTarget: 5,// 5
+depthStencil: 6,// 6
+unorderedAccess: 7,// 7
+decoder: 8,// 8
+videoEncoder: 9,// 9

|};



/**
 * A Windows Runtime projection of the D3D11_USAGE enumeration. Identifies expected resource use during rendering. The usage directly reflects whether a resource is accessible by the CPU and/or the graphics processing unit (GPU).
 */

declare  var Windows$Graphics$DirectX$Direct3D11$Direct3DUsage: {|
  +default: 0,// 0
+immutable: 1,// 1
+dynamic: 2,// 2
+staging: 3,// 3

|};



/**
 * This represents an IDXGISurface and can be used to interop between Windows Runtime components that need to exchange IDXGISurface references.
 */
declare type Windows$Graphics$DirectX$Direct3D11$IDirect3DSurface = {

/**
 * Gets a Direct3DSurfaceDescription describing the surface.
 */
description: Windows$Graphics$DirectX$Direct3D11$Direct3DSurfaceDescription
} & Windows$Foundation$IClosable



/**
 * A Windows Runtime projection of the DXGI_SURFACE_DESC structure. Describes a IDirect3DSurface .
 */
declare interface Windows$Graphics$DirectX$Direct3D11$Direct3DSurfaceDescription {

/**
 * Pixel format of the surface.
 */
format: $Values<typeof Windows$Graphics$DirectX$DirectXPixelFormat>,

/**
 * Height of the surface.
 */
height: number,

/**
 * Multi-sampling parameters for the surface.
 */
multisampleDescription: Windows$Graphics$DirectX$Direct3D11$Direct3DMultisampleDescription,

/**
 * Width of the surface.
 */
width: number
} 


/**
 * A Windows Runtime projection of the DXGI_SAMPLE_DESC structure. Describes multi-sampling parameters for a IDirect3DSurface .
 */
declare interface Windows$Graphics$DirectX$Direct3D11$Direct3DMultisampleDescription {

/**
 * The number of multisamples per pixel.
 */
count: number,

/**
 * The image quality level. The higher the quality, the lower the performance.
 */
quality: number
} 


/**
 * Identifies the alpha value, transparency behavior, of a surface. This is a managed version of the DXGI_APLAHA_MODE enumeration.
 */

declare  var Windows$Graphics$DirectX$DirectXAlphaMode: {|
  +unspecified: 0,// 0
+premultiplied: 1,// 1
+straight: 2,// 2
+ignore: 3,// 3

|};



/**
 * Specifies pixel formats, which includes fully-typed and type-less formats. This is a managed version of the DXGI_FORMAT enumeration.
 */

declare  var Windows$Graphics$DirectX$DirectXPixelFormat: {|
  +unknown: 0,// 0
+r32G32B32A32Typeless: 1,// 1
+r32G32B32A32Float: 2,// 2
+r32G32B32A32UInt: 3,// 3
+r32G32B32A32Int: 4,// 4
+r32G32B32Typeless: 5,// 5
+r32G32B32Float: 6,// 6
+r32G32B32UInt: 7,// 7
+r32G32B32Int: 8,// 8
+r16G16B16A16Typeless: 9,// 9
+r16G16B16A16Float: 10,// 10
+r16G16B16A16UIntNormalized: 11,// 11
+r16G16B16A16UInt: 12,// 12
+r16G16B16A16IntNormalized: 13,// 13
+r16G16B16A16Int: 14,// 14
+r32G32Typeless: 15,// 15
+r32G32Float: 16,// 16
+r32G32UInt: 17,// 17
+r32G32Int: 18,// 18
+r32G8X24Typeless: 19,// 19
+d32FloatS8X24UInt: 20,// 20
+r32FloatX8X24Typeless: 21,// 21
+x32TypelessG8X24UInt: 22,// 22
+r10G10B10A2Typeless: 23,// 23
+r10G10B10A2UIntNormalized: 24,// 24
+r10G10B10A2UInt: 25,// 25
+r11G11B10Float: 26,// 26
+r8G8B8A8Typeless: 27,// 27
+r8G8B8A8UIntNormalized: 28,// 28
+r8G8B8A8UIntNormalizedSrgb: 29,// 29
+r8G8B8A8UInt: 30,// 30
+r8G8B8A8IntNormalized: 31,// 31
+r8G8B8A8Int: 32,// 32
+r16G16Typeless: 33,// 33
+r16G16Float: 34,// 34
+r16G16UIntNormalized: 35,// 35
+r16G16UInt: 36,// 36
+r16G16IntNormalized: 37,// 37
+r16G16Int: 38,// 38
+r32Typeless: 39,// 39
+d32Float: 40,// 40
+r32Float: 41,// 41
+r32UInt: 42,// 42
+r32Int: 43,// 43
+r24G8Typeless: 44,// 44
+d24UIntNormalizedS8UInt: 45,// 45
+r24UIntNormalizedX8Typeless: 46,// 46
+x24TypelessG8UInt: 47,// 47
+r8G8Typeless: 48,// 48
+r8G8UIntNormalized: 49,// 49
+r8G8UInt: 50,// 50
+r8G8IntNormalized: 51,// 51
+r8G8Int: 52,// 52
+r16Typeless: 53,// 53
+r16Float: 54,// 54
+d16UIntNormalized: 55,// 55
+r16UIntNormalized: 56,// 56
+r16UInt: 57,// 57
+r16IntNormalized: 58,// 58
+r16Int: 59,// 59
+r8Typeless: 60,// 60
+r8UIntNormalized: 61,// 61
+r8UInt: 62,// 62
+r8IntNormalized: 63,// 63
+r8Int: 64,// 64
+a8UIntNormalized: 65,// 65
+r1UIntNormalized: 66,// 66
+r9G9B9E5SharedExponent: 67,// 67
+r8G8B8G8UIntNormalized: 68,// 68
+g8R8G8B8UIntNormalized: 69,// 69
+bc1Typeless: 70,// 70
+bc1UIntNormalized: 71,// 71
+bc1UIntNormalizedSrgb: 72,// 72
+bc2Typeless: 73,// 73
+bc2UIntNormalized: 74,// 74
+bc2UIntNormalizedSrgb: 75,// 75
+bc3Typeless: 76,// 76
+bc3UIntNormalized: 77,// 77
+bc3UIntNormalizedSrgb: 78,// 78
+bc4Typeless: 79,// 79
+bc4UIntNormalized: 80,// 80
+bc4IntNormalized: 81,// 81
+bc5Typeless: 82,// 82
+bc5UIntNormalized: 83,// 83
+bc5IntNormalized: 84,// 84
+b5G6R5UIntNormalized: 85,// 85
+b5G5R5A1UIntNormalized: 86,// 86
+b8G8R8A8UIntNormalized: 87,// 87
+b8G8R8X8UIntNormalized: 88,// 88
+r10G10B10XRBiasA2UIntNormalized: 89,// 89
+b8G8R8A8Typeless: 90,// 90
+b8G8R8A8UIntNormalizedSrgb: 91,// 91
+b8G8R8X8Typeless: 92,// 92
+b8G8R8X8UIntNormalizedSrgb: 93,// 93
+bc6HTypeless: 94,// 94
+bc6H16UnsignedFloat: 95,// 95
+bc6H16Float: 96,// 96
+bc7Typeless: 97,// 97
+bc7UIntNormalized: 98,// 98
+bc7UIntNormalizedSrgb: 99,// 99
+ayuv: 100,// 100
+y410: 101,// 101
+y416: 102,// 102
+nv12: 103,// 103
+p010: 104,// 104
+p016: 105,// 105
+opaque420: 106,// 106
+yuy2: 107,// 107
+y210: 108,// 108
+y216: 109,// 109
+nv11: 110,// 110
+ai44: 111,// 111
+ia44: 112,// 112
+p8: 113,// 113
+a8P8: 114,// 114
+b4G4R4A4UIntNormalized: 115,// 115
+p208: 116,// 116
+v208: 117,// 117
+v408: 118,// 118

|};



      declare var npm$namespace$Windows$Graphics$Display: {
        
        
        DisplayOrientations: typeof Windows$Graphics$Display$DisplayOrientations,
ResolutionScale: typeof Windows$Graphics$Display$ResolutionScale,
        DisplayInformation: typeof Windows$Graphics$Display$DisplayInformation,
DisplayProperties: typeof Windows$Graphics$Display$DisplayProperties,
        
      }

/**
 * Monitors and controls physical display information. The class provides events to allow clients to monitor for changes in the display.
 */
declare class Windows$Graphics$Display$DisplayInformation  {

/**
 * Gets and sets the preferred orientation of the app.
 */
static autoRotationPreferences: $Values<typeof Windows$Graphics$Display$DisplayOrientations>;

/**
 * Gets the current physical display information.
 * @return A DisplayInformation object that contains the current physical display information.
 */
static getForCurrentView(): Windows$Graphics$Display$DisplayInformation;

/**
 * Occurs when the display requires redrawing.
 */
static ondisplaycontentsinvalidated: Windows$Foundation$TypedEventHandler<Windows$Graphics$Display$DisplayInformation, any>;
static addEventListener(
type: "displaycontentsinvalidated",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Display$DisplayInformation, any>): void;
static removeEventListener(
type: "displaycontentsinvalidated",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Display$DisplayInformation, any>): void;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Gets the current orientation of a rectangular monitor.
 */
currentOrientation: $Values<typeof Windows$Graphics$Display$DisplayOrientations>;

/**
 * Diagonal size of the display in inches.
 */
diagonalSizeInInches: number;

/**
 * Asynchronously gets the default International Color Consortium (ICC) color profile that is associated with the physical display.
 * @return Object that manages the asynchronous retrieval of the color profile.
 */
getColorProfileAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStream>;

/**
 * Gets the pixels per logical inch of the current environment.
 */
logicalDpi: number;

/**
 * Gets the native orientation of the display monitor, which is typically the orientation where the buttons on the device match the orientation of the monitor.
 */
nativeOrientation: $Values<typeof Windows$Graphics$Display$DisplayOrientations>;

/**
 * Occurs when the physical display's color profile changes.
 */
oncolorprofilechanged: Windows$Foundation$TypedEventHandler<Windows$Graphics$Display$DisplayInformation, any>;
addEventListener(
type: "colorprofilechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Display$DisplayInformation, any>): void;
removeEventListener(
type: "colorprofilechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Display$DisplayInformation, any>): void;

/**
 * Occurs when the LogicalDpi property changes because the pixels per inch (PPI) of the display changes.
 */
ondpichanged: Windows$Foundation$TypedEventHandler<Windows$Graphics$Display$DisplayInformation, any>;
addEventListener(
type: "dpichanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Display$DisplayInformation, any>): void;
removeEventListener(
type: "dpichanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Display$DisplayInformation, any>): void;

/**
 * Occurs when either the CurrentOrientation or NativeOrientation property changes because of a mode change or a monitor change.
 */
onorientationchanged: Windows$Foundation$TypedEventHandler<Windows$Graphics$Display$DisplayInformation, any>;
addEventListener(
type: "orientationchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Display$DisplayInformation, any>): void;
removeEventListener(
type: "orientationchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Display$DisplayInformation, any>): void;

/**
 * Occurs when the StereoEnabled property changes because support for stereoscopic 3D changes.
 */
onstereoenabledchanged: Windows$Foundation$TypedEventHandler<Windows$Graphics$Display$DisplayInformation, any>;
addEventListener(
type: "stereoenabledchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Display$DisplayInformation, any>): void;
removeEventListener(
type: "stereoenabledchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Display$DisplayInformation, any>): void;

/**
 * Gets the raw dots per inch (DPI) along the x axis of the display monitor.
 */
rawDpiX: number;

/**
 * Gets the raw dots per inch (DPI) along the y axis of the display monitor.
 */
rawDpiY: number;

/**
 * Gets a value representing the number of raw (physical) pixels for each view (layout) pixel.
 */
rawPixelsPerViewPixel: number;

/**
 * Gets the scale factor of the immersive environment.
 */
resolutionScale: $Values<typeof Windows$Graphics$Display$ResolutionScale>;

/**
 * Gets a value that indicates whether the device supports stereoscopic 3D.
 */
stereoEnabled: boolean;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Describes the orientation of a rectangular monitor.
 */

declare  var Windows$Graphics$Display$DisplayOrientations: {|
  +none: 0,// 0
+landscape: 1,// 1
+portrait: 2,// 2
+landscapeFlipped: 3,// 3
+portraitFlipped: 4,// 4

|};



/**
 * Provides various properties that are related to the physical display.
 */
declare class Windows$Graphics$Display$DisplayProperties  {

/**
 * Gets and sets the preferred orientation of the app.
 */
static autoRotationPreferences: $Values<typeof Windows$Graphics$Display$DisplayOrientations>;

/**
 * Gets the current orientation of a rectangular monitor.
 */
static currentOrientation: $Values<typeof Windows$Graphics$Display$DisplayOrientations>;

/**
 * Asynchronously gets the default International Color Consortium (ICC) color profile that is associated with the physical display.
 * @return Object that manages the asynchronous retrieval of the color profile.
 */
static getColorProfileAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStream>;

/**
 * Gets the pixels per logical inch of the current environment.
 */
static logicalDpi: number;

/**
 * Gets the native orientation of the display monitor, which is typically the orientation where the buttons on the device match the orientation of the monitor.
 */
static nativeOrientation: $Values<typeof Windows$Graphics$Display$DisplayOrientations>;

/**
 * Occurs when the physical display's color profile changes.
 */
static oncolorprofilechanged: Windows$Graphics$Display$DisplayPropertiesEventHandler;
static addEventListener(
type: "colorprofilechanged",
listener: Windows$Graphics$Display$DisplayPropertiesEventHandler): void;
static removeEventListener(
type: "colorprofilechanged",
listener: Windows$Graphics$Display$DisplayPropertiesEventHandler): void;

/**
 * Occurs when the display requires redrawing.
 */
static ondisplaycontentsinvalidated: Windows$Graphics$Display$DisplayPropertiesEventHandler;
static addEventListener(
type: "displaycontentsinvalidated",
listener: Windows$Graphics$Display$DisplayPropertiesEventHandler): void;
static removeEventListener(
type: "displaycontentsinvalidated",
listener: Windows$Graphics$Display$DisplayPropertiesEventHandler): void;

/**
 * Occurs when the LogicalDpi property changes because the pixels per inch (PPI) of the display changes.
 */
static onlogicaldpichanged: Windows$Graphics$Display$DisplayPropertiesEventHandler;
static addEventListener(
type: "logicaldpichanged",
listener: Windows$Graphics$Display$DisplayPropertiesEventHandler): void;
static removeEventListener(
type: "logicaldpichanged",
listener: Windows$Graphics$Display$DisplayPropertiesEventHandler): void;

/**
 * Occurs when either the CurrentOrientation or NativeOrientation property changes because of a mode change or a monitor change.
 */
static onorientationchanged: Windows$Graphics$Display$DisplayPropertiesEventHandler;
static addEventListener(
type: "orientationchanged",
listener: Windows$Graphics$Display$DisplayPropertiesEventHandler): void;
static removeEventListener(
type: "orientationchanged",
listener: Windows$Graphics$Display$DisplayPropertiesEventHandler): void;

/**
 * Occurs when the StereoEnabled property changes because support for stereoscopic 3D changes.
 */
static onstereoenabledchanged: Windows$Graphics$Display$DisplayPropertiesEventHandler;
static addEventListener(
type: "stereoenabledchanged",
listener: Windows$Graphics$Display$DisplayPropertiesEventHandler): void;
static removeEventListener(
type: "stereoenabledchanged",
listener: Windows$Graphics$Display$DisplayPropertiesEventHandler): void;

/**
 * Gets the scale factor of the immersive environment.
 */
static resolutionScale: $Values<typeof Windows$Graphics$Display$ResolutionScale>;

/**
 * Gets a value that indicates whether the device supports stereoscopic 3D.
 */
static stereoEnabled: boolean;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Describes the scale factor of the immersive environment. The scale factor is determined by the operating system in response to high pixel density screens.
 */

declare  var Windows$Graphics$Display$ResolutionScale: {|
  +invalid: 0,// 0
+scale100Percent: 1,// 1
+scale120Percent: 2,// 2
+scale125Percent: 3,// 3
+scale140Percent: 4,// 4
+scale150Percent: 5,// 5
+scale160Percent: 6,// 6
+scale175Percent: 7,// 7
+scale180Percent: 8,// 8
+scale200Percent: 9,// 9
+scale225Percent: 10,// 10
+scale250Percent: 11,// 11
+scale300Percent: 12,// 12
+scale350Percent: 13,// 13
+scale400Percent: 14,// 14
+scale450Percent: 15,// 15
+scale500Percent: 16,// 16

|};



/**
 * Represents a method that handles display property events.
 */
declare type Windows$Graphics$Display$DisplayPropertiesEventHandler = (ev: Windows$WinRTEvent<any>) => void;




      declare var npm$namespace$Windows$Graphics$Holographic: {
        
        
        
        HolographicCamera: typeof Windows$Graphics$Holographic$HolographicCamera,
HolographicCameraPose: typeof Windows$Graphics$Holographic$HolographicCameraPose,
HolographicCameraRenderingParameters: typeof Windows$Graphics$Holographic$HolographicCameraRenderingParameters,
HolographicFrame: typeof Windows$Graphics$Holographic$HolographicFrame,
HolographicFramePrediction: typeof Windows$Graphics$Holographic$HolographicFramePrediction,
HolographicSpace: typeof Windows$Graphics$Holographic$HolographicSpace,
HolographicSpaceCameraAddedEventArgs: typeof Windows$Graphics$Holographic$HolographicSpaceCameraAddedEventArgs,
HolographicSpaceCameraRemovedEventArgs: typeof Windows$Graphics$Holographic$HolographicSpaceCameraRemovedEventArgs,
        HolographicFramePresentResult: typeof npm$namespace$Windows$Graphics$Holographic$HolographicFramePresentResult,
HolographicFramePresentWaitBehavior: typeof npm$namespace$Windows$Graphics$Holographic$HolographicFramePresentWaitBehavior,
      }
declare class Windows$Graphics$Holographic$HolographicCamera  {
id: any;
isStereo: any;
renderTargetSize: any;
setFarPlaneDistance: any;
setNearPlaneDistance: any;
viewportScaleFactor: any
}

declare class Windows$Graphics$Holographic$HolographicCameraPose  {
farPlaneDistance: any;
holographicCamera: any;
nearPlaneDistance: any;
projectionTransform: any;
tryGetCullingFrustum: any;
tryGetViewTransform: any;
tryGetVisibleFrustum: any;
viewport: any
}

declare class Windows$Graphics$Holographic$HolographicCameraRenderingParameters  {
direct3D11BackBuffer: any;
direct3D11Device: any;
setFocusPoint: any
}

declare class Windows$Graphics$Holographic$HolographicFrame  {
addedCameras: any;
currentPrediction: any;
duration: any;
getRenderingParameters: any;
presentUsingCurrentPrediction: any;
removedCameras: any;
updateCurrentPrediction: any;
waitForFrameToFinish: any
}

declare class Windows$Graphics$Holographic$HolographicFramePrediction  {
cameraPoses: any;
timestamp: any
}


      declare var npm$namespace$Windows$Graphics$Holographic$HolographicFramePresentResult: {
        
        success: typeof Windows$Graphics$Holographic$HolographicFramePresentResult$success,
deviceRemoved: typeof Windows$Graphics$Holographic$HolographicFramePresentResult$deviceRemoved,
        
        
        
      }
declare var Windows$Graphics$Holographic$HolographicFramePresentResult$success: any;

declare var Windows$Graphics$Holographic$HolographicFramePresentResult$deviceRemoved: any;


      declare var npm$namespace$Windows$Graphics$Holographic$HolographicFramePresentWaitBehavior: {
        
        waitForFrameToFinish: typeof Windows$Graphics$Holographic$HolographicFramePresentWaitBehavior$waitForFrameToFinish,
doNotWaitForFrameToFinish: typeof Windows$Graphics$Holographic$HolographicFramePresentWaitBehavior$doNotWaitForFrameToFinish,
        
        
        
      }
declare var Windows$Graphics$Holographic$HolographicFramePresentWaitBehavior$waitForFrameToFinish: any;

declare var Windows$Graphics$Holographic$HolographicFramePresentWaitBehavior$doNotWaitForFrameToFinish: any;

declare class Windows$Graphics$Holographic$HolographicSpace  {
static createForCoreWindow: any;
addEventListener: any;
createNextFrame: any;
oncameraadded: any;
oncameraremoved: any;
primaryAdapterId: any;
removeEventListener: any;
setDirect3D11Device: any
}

declare class Windows$Graphics$Holographic$HolographicSpaceCameraAddedEventArgs  {
camera: any;
getDeferral: any
}

declare class Windows$Graphics$Holographic$HolographicSpaceCameraRemovedEventArgs  {
camera: any
}


      declare var npm$namespace$Windows$Graphics$Imaging: {
        
        
        BitmapAlphaMode: typeof Windows$Graphics$Imaging$BitmapAlphaMode,
BitmapBufferAccessMode: typeof Windows$Graphics$Imaging$BitmapBufferAccessMode,
BitmapFlip: typeof Windows$Graphics$Imaging$BitmapFlip,
BitmapInterpolationMode: typeof Windows$Graphics$Imaging$BitmapInterpolationMode,
BitmapPixelFormat: typeof Windows$Graphics$Imaging$BitmapPixelFormat,
BitmapRotation: typeof Windows$Graphics$Imaging$BitmapRotation,
ColorManagementMode: typeof Windows$Graphics$Imaging$ColorManagementMode,
ExifOrientationMode: typeof Windows$Graphics$Imaging$ExifOrientationMode,
JpegSubsamplingMode: typeof Windows$Graphics$Imaging$JpegSubsamplingMode,
PngFilterMode: typeof Windows$Graphics$Imaging$PngFilterMode,
TiffCompressionMode: typeof Windows$Graphics$Imaging$TiffCompressionMode,
        BitmapBuffer: typeof Windows$Graphics$Imaging$BitmapBuffer,
BitmapCodecInformation: typeof Windows$Graphics$Imaging$BitmapCodecInformation,
BitmapDecoder: typeof Windows$Graphics$Imaging$BitmapDecoder,
BitmapEncoder: typeof Windows$Graphics$Imaging$BitmapEncoder,
BitmapFrame: typeof Windows$Graphics$Imaging$BitmapFrame,
BitmapProperties: typeof Windows$Graphics$Imaging$BitmapProperties,
BitmapPropertiesView: typeof Windows$Graphics$Imaging$BitmapPropertiesView,
BitmapPropertySet: typeof Windows$Graphics$Imaging$BitmapPropertySet,
BitmapTransform: typeof Windows$Graphics$Imaging$BitmapTransform,
BitmapTypedValue: typeof Windows$Graphics$Imaging$BitmapTypedValue,
ImageStream: typeof Windows$Graphics$Imaging$ImageStream,
PixelDataProvider: typeof Windows$Graphics$Imaging$PixelDataProvider,
SoftwareBitmap: typeof Windows$Graphics$Imaging$SoftwareBitmap,
        
      }

/**
 * Specifies the alpha mode of pixel data.
 */

declare  var Windows$Graphics$Imaging$BitmapAlphaMode: {|
  +premultiplied: 0,// 0
+straight: 1,// 1
+ignore: 2,// 2

|};



/**
 * Represents the pixel data buffer of a bitmap.
 */
declare class Windows$Graphics$Imaging$BitmapBuffer  {

/**
 * Disposes of the object and associated resources.
 */
close(): void;

/**
 * Creates a reference to the underlying memory buffer.
 * @return A reference to the underlying memory buffer.
 */
createReference(): Windows$Foundation$IMemoryBufferReference;

/**
 * Gets the number of bit planes in the bitmap buffer.
 * @return The number of bit planes in the bitmap buffer.
 */
getPlaneCount(): number;

/**
 * Gets a BitmapPlaneDescription object that describes the size, offset, and stride of the bitmap data in the bit plane with the specified index.
 * @param index The index of the bit plane for which the description is retrieved.
 * @return The bit plane description.
 */
getPlaneDescription(index: number): Windows$Graphics$Imaging$BitmapPlaneDescription
}


/**
 * Specifies the access mode of a BitmapBuffer .
 */

declare  var Windows$Graphics$Imaging$BitmapBufferAccessMode: {|
  +read: 0,// 0
+readWrite: 1,// 1
+write: 2,// 2

|};



/**
 * Provides access to information about a decoder or encoder.
 */
declare class Windows$Graphics$Imaging$BitmapCodecInformation  {

/**
 * The unique identifier of the decoder or encoder. Methods like BitmapDecoder::CreateAsync and BitmapEncoder::CreateAsync use the codec identifier to determine which codec to create.
 */
codecId: string;

/**
 * A collection of all the file extensions supported by the decoder or encoder.
 */
fileExtensions: Windows$Foundation$Collections$IVectorView<string>;

/**
 * The friendly name of the decoder or encoder.
 */
friendlyName: string;

/**
 * A collection of all the MIME/content types supported by the decoder or encoder. MIME type is synonymous with content type .
 */
mimeTypes: Windows$Foundation$Collections$IVectorView<string>
}


/**
 * Provides read access to bitmap container data as well as data from the first frame.
 */
declare class Windows$Graphics$Imaging$BitmapDecoder  {

/**
 * The unique identifier of the BMP decoder.
 */
static bmpDecoderId: string;

/**
 * Asynchronously creates a new BitmapDecoder and initializes it using a stream.
 * @param stream The stream containing the image file to be decoded.
 * @return An object that manages the asynchronous creation of a new BitmapDecoder .
 */
static createAsync(
stream: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$BitmapDecoder>;

/**
 * Asynchronously creates a new BitmapDecoder using a specific bitmap codec and initializes it using a stream.
 * @param decoderId The unique identifier of the specified bitmap codec.
 * @param stream The stream containing the image file to be decoded.
 * @return An object that manages the asynchronous creation of a new BitmapDecoder .
 */
static createAsync(
decoderId: string,
stream: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$BitmapDecoder>;

/**
 * The bitmap decoders installed on the system and information about them.
 * @return A list of BitmapCodecInformation objects containing information about each decoder.
 */
static getDecoderInformationEnumerator(
): Windows$Foundation$Collections$IVectorView<Windows$Graphics$Imaging$BitmapCodecInformation>;

/**
 * The unique identifier of the GIF decoder.
 */
static gifDecoderId: string;

/**
 * The unique identifier of the ICO decoder.
 */
static icoDecoderId: string;

/**
 * The unique identifier of the JPEG decoder.
 */
static jpegDecoderId: string;

/**
 * The unique identifier of the JPEG-XR decoder.
 */
static jpegXRDecoderId: string;

/**
 * The unique identifier of the PNG decoder.
 */
static pngDecoderId: string;

/**
 * The unique identifier of the TIFF decoder.
 */
static tiffDecoderId: string;

/**
 * The default alpha mode of the first frame.
 */
bitmapAlphaMode: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>;

/**
 * Provides access to the container bitmap properties.
 */
bitmapContainerProperties: Windows$Graphics$Imaging$BitmapPropertiesView;

/**
 * The pixel format that best fits the first frame.
 */
bitmapPixelFormat: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>;

/**
 * A read-only view of the metadata within the first frame.
 */
bitmapProperties: Windows$Graphics$Imaging$BitmapPropertiesView;

/**
 * Information about the bitmap decoder.
 */
decoderInformation: Windows$Graphics$Imaging$BitmapCodecInformation;

/**
 * The horizontal resolution of the first frame in dots per inch.
 */
dpiX: number;

/**
 * The vertical resolution of the first frame in dots per inch.
 */
dpiY: number;

/**
 * The number of frames within the image file.
 */
frameCount: number;

/**
 * Asynchronously retrieves a frame from the image file.
 * @param frameIndex The zero-based index of the frame to be retrieved.
 * @return Object that manages the asynchronous retrieval of the frame.
 */
getFrameAsync(
frameIndex: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$BitmapFrame>;

/**
 * Asynchronously requests the pixel data for the frame.
 * @return Object that manages the asynchronous retrieval of the pixel data.
 */
getPixelDataAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$PixelDataProvider>;

/**
 * Asynchronously requests the pixel data for the frame using the specified parameters.
 * @param pixelFormat The specified pixel format.
 * @param alphaMode The specified alpha mode.
 * @param transform The set of transformations to be applied to the frame.
 * @param exifOrientationMode Indicates whether the EXIF orientation flag should be ignored or respected.
 * @param colorManagementMode Indicates whether the pixel data should be color managed to the sRGB color space.
 * @return Object that manages the asynchronous retrieval of the pixel data.
 */
getPixelDataAsync(
pixelFormat: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>,
alphaMode: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>,
transform: Windows$Graphics$Imaging$BitmapTransform,
exifOrientationMode: $Values<typeof Windows$Graphics$Imaging$ExifOrientationMode>,
colorManagementMode: $Values<typeof Windows$Graphics$Imaging$ColorManagementMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$PixelDataProvider>;

/**
 * Asynchronously returns a stream containing the preview image.
 * @return Object that manages the asynchronous retrieval of the bitmap preview data.
 */
getPreviewAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$ImageStream>;

/**
 * Asynchronously gets a SoftwareBitmap representation of the decoded bitmap.
 * @return An asynchronous operation that returns a SoftwareBitmap on successful completion.
 */
getSoftwareBitmapAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$SoftwareBitmap>;

/**
 * Asynchronously gets a SoftwareBitmap representation of the decoded bitmap.
 * @param pixelFormat The pixel format of the software bitmap.
 * @param alphaMode The alpha mode of the software bitmap.
 * @param transform The transform of the software bitmap.
 * @param exifOrientationMode The EXIF orientation mode of the software bitmap.
 * @param colorManagementMode The color management mode of the software bitmap.
 * @return An asynchronous operation that returns a SoftwareBitmap on successful completion.
 */
getSoftwareBitmapAsync(
pixelFormat: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>,
alphaMode: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>,
transform: Windows$Graphics$Imaging$BitmapTransform,
exifOrientationMode: $Values<typeof Windows$Graphics$Imaging$ExifOrientationMode>,
colorManagementMode: $Values<typeof Windows$Graphics$Imaging$ColorManagementMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$SoftwareBitmap>;

/**
 * Asynchronously gets a SoftwareBitmap representation of the decoded bitmap.
 * @param pixelFormat The pixel format of the software bitmap.
 * @param alphaMode The alpha mode of the software bitmap.
 * @return An asynchronous operation that returns a SoftwareBitmap on successful completion.
 */
getSoftwareBitmapAsync(
pixelFormat: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>,
alphaMode: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$SoftwareBitmap>;

/**
 * Asynchronously returns a stream containing the thumbnail image.
 * @return Object that manages the asynchronous retrieval of the thumbnail stream.
 */
getThumbnailAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$ImageStream>;

/**
 * The height of the first frame in pixels, after any EXIF orientation has been applied to the bitmap.
 */
orientedPixelHeight: number;

/**
 * The width of the first frame in pixels, after any EXIF orientation has been applied to the bitmap.
 */
orientedPixelWidth: number;

/**
 * The height of the first frame in pixels.
 */
pixelHeight: number;

/**
 * The width of the first frame in pixels.
 */
pixelWidth: number
}


/**
 * Contains methods to create, edit and save images.
 */
declare class Windows$Graphics$Imaging$BitmapEncoder  {

/**
 * The unique identifier of the built-in BMP encoder.
 */
static bmpEncoderId: string;

/**
 * Asynchronously creates a new BitmapEncoder for the specified codec with the specified encoding options and initializes it on a stream.
 * @param encoderId The unique identifier of the specified encoder.
 * @param stream A stream representing where the image file is to be written.
 * @param encodingOptions A collection of key-value pairs containing one or more codec-specific encoding options and the desired values.
 * @return An object that manages the asynchronous creation of a new BitmapEncoder .
 */
static createAsync(
encoderId: string,
stream: Windows$Storage$Streams$IRandomAccessStream,
encodingOptions: Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$BitmapEncoder>;

/**
 * Asynchronously creates a new BitmapEncoder .
 * @param encoderId The unique identifier of the specified encoder.
 * @param stream The output stream.
 * @return An object that manages the asynchronous creation of a new BitmapEncoder .
 */
static createAsync(
encoderId: string,
stream: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$BitmapEncoder>;

/**
 * Asynchronously creates a new BitmapEncoder for in-place property and metadata editing. The new encoder can only edit bitmap properties in-place and will fail for any other uses.
 * @param bitmapDecoder A BitmapDecoder containing the image data to be edited. This parameter must be created on a stream with an access mode of ReadWrite .
 * @return An object that manages the asynchronous initialization of a new BitmapEncoder using data from an existing BitmapDecoder .
 */
static createForInPlacePropertyEncodingAsync(
bitmapDecoder: Windows$Graphics$Imaging$BitmapDecoder): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$BitmapEncoder>;

/**
 * Asynchronously creates a new BitmapEncoder and initializes it using data from an existing BitmapDecoder .
 * @param stream The output stream.
 * @param bitmapDecoder A BitmapDecoder containing the image data to be copied.
 * @return An object that manages the asynchronous creation of a new BitmapEncoder using data from an existing BitmapDecoder .
 */
static createForTranscodingAsync(
stream: Windows$Storage$Streams$IRandomAccessStream,
bitmapDecoder: Windows$Graphics$Imaging$BitmapDecoder): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$BitmapEncoder>;

/**
 * A list of the bitmap encoders installed on the system and information about them.
 * @return A list of BitmapCodecInformation objects containing information about each encoder.
 */
static getEncoderInformationEnumerator(
): Windows$Foundation$Collections$IVectorView<Windows$Graphics$Imaging$BitmapCodecInformation>;

/**
 * The unique identifier of the built-in GIF encoder.
 */
static gifEncoderId: string;

/**
 * The unique identifier of the built-in JPEG encoder.
 */
static jpegEncoderId: string;

/**
 * The unique identifier of the built-in JPEG-XR encoder.
 */
static jpegXREncoderId: string;

/**
 * The unique identifier of the built-in PNG encoder.
 */
static pngEncoderId: string;

/**
 * The unique identifier of the built-in TIFF encoder.
 */
static tiffEncoderId: string;

/**
 * The metadata for the container.
 */
bitmapContainerProperties: Windows$Graphics$Imaging$BitmapProperties;

/**
 * The metadata for the selected frame.
 */
bitmapProperties: Windows$Graphics$Imaging$BitmapProperties;

/**
 * A BitmapTransform object that is used to specify how the frame bitmap is to be transformed.
 */
bitmapTransform: Windows$Graphics$Imaging$BitmapTransform;

/**
 * Information about the bitmap encoder.
 */
encoderInformation: Windows$Graphics$Imaging$BitmapCodecInformation;

/**
 * Asynchronously commits and flushes all of the image data.
 * @return An object that manages the asynchronous flush operation.
 */
flushAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * The height, in pixels, of any generated thumbnail.
 */
generatedThumbnailHeight: number;

/**
 * The width, in pixels, of any generated thumbnail.
 */
generatedThumbnailWidth: number;

/**
 * Asynchronously commits the current frame data and appends a new empty frame, with the specified encoding options, to be edited.
 * @param encodingOptions The specified encoding options. A collection of key-value pairs containing one or more codec-specific encoding options and the desired values.
 * @return An object that manages the asynchronous operation of committing the current frame data and appending a new empty frame to be edited.
 */
goToNextFrameAsync(
encodingOptions: Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously commits the current frame data and appends a new empty frame to be edited.
 * @return An object that manages the asynchronous operation of committing the current frame data and appending a new empty frame to be edited.
 */
goToNextFrameAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Indicates whether or not a new thumbnail is automatically generated.
 */
isThumbnailGenerated: boolean;

/**
 * Sets pixel data on the frame.
 * @param pixelFormat The pixel format of the pixel data.
 * @param alphaMode The alpha mode of the pixel data.
 * @param width The width, in pixels, of the pixel data.
 * @param height The height, in pixels, of the pixel data.
 * @param dpiX The horizontal resolution, in dots per inch, of the pixel data.
 * @param dpiY The vertical resolution, in dots per inch, of the pixel data.
 * @param pixels The pixel data.
 */
setPixelData(
pixelFormat: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>,
alphaMode: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>,
width: number,
height: number,
dpiX: number,
dpiY: number,
pixels: number[]): void;

/**
 * Sets the image data of the current frame using the specified SoftwareBitmap .
 * @param bitmap The software bitmap containing the image data.
 */
setSoftwareBitmap(bitmap: Windows$Graphics$Imaging$SoftwareBitmap): void
}


/**
 * Specifies the flip operation to be performed on pixel data.
 */

declare  var Windows$Graphics$Imaging$BitmapFlip: {|
  +none: 0,// 0
+horizontal: 1,// 1
+vertical: 2,// 2

|};



/**
 * Provides read access to data within a single frame.
 */
declare class Windows$Graphics$Imaging$BitmapFrame  {

/**
 * The default alpha mode of the frame.
 */
bitmapAlphaMode: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>;

/**
 * The pixel format that best fits the frame.
 */
bitmapPixelFormat: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>;

/**
 * A read-only view of the metadata within the frame.
 */
bitmapProperties: Windows$Graphics$Imaging$BitmapPropertiesView;

/**
 * The horizontal resolution of the frame in dots per inch.
 */
dpiX: number;

/**
 * The vertical resolution of the frame in dots per inch.
 */
dpiY: number;

/**
 * Asynchronously requests the pixel data for the frame. The resulting pixel data array will use the bitmap pixel format and alpha mode specified in the BitmapPixelFormat and BitmapAlphaMode properties. It will also have color management and EXIF orientation applied (see the Remarks section for more information).
 * @return Object that manages the asynchronous retrieval of the pixel data.
 */
getPixelDataAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$PixelDataProvider>;

/**
 * Asynchronously requests the pixel data for the frame using the specified parameters.
 * @param pixelFormat The specified pixel format.
 * @param alphaMode The specified alpha mode.
 * @param transform The set of transformations to be applied to the frame.
 * @param exifOrientationMode Indicates whether the EXIF orientation flag should be ignored or respected.
 * @param colorManagementMode Indicates whether the pixel data should be color managed to the sRGB color space.
 * @return Object that manages the asynchronous retrieval of the pixel data.
 */
getPixelDataAsync(
pixelFormat: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>,
alphaMode: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>,
transform: Windows$Graphics$Imaging$BitmapTransform,
exifOrientationMode: $Values<typeof Windows$Graphics$Imaging$ExifOrientationMode>,
colorManagementMode: $Values<typeof Windows$Graphics$Imaging$ColorManagementMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$PixelDataProvider>;

/**
 * Asynchronously gets a SoftwareBitmap representation of the bitmap frame.
 * @return An asynchronous operation that returns a SoftwareBitmap on successful completion.
 */
getSoftwareBitmapAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$SoftwareBitmap>;

/**
 * Asynchronously gets a SoftwareBitmap representation of the bitmap frame.
 * @param pixelFormat The pixel format of the software bitmap.
 * @param alphaMode The alpha mode of the software bitmap.
 * @param transform The transform of the software bitmap.
 * @param exifOrientationMode The EXIF orientation mode of the software bitmap.
 * @param colorManagementMode The color management mode of the software bitmap.
 * @return An asynchronous operation that returns a SoftwareBitmap on successful completion.
 */
getSoftwareBitmapAsync(
pixelFormat: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>,
alphaMode: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>,
transform: Windows$Graphics$Imaging$BitmapTransform,
exifOrientationMode: $Values<typeof Windows$Graphics$Imaging$ExifOrientationMode>,
colorManagementMode: $Values<typeof Windows$Graphics$Imaging$ColorManagementMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$SoftwareBitmap>;

/**
 * Asynchronously gets a SoftwareBitmap representation of the bitmap frame.
 * @param pixelFormat The pixel format of the software bitmap.
 * @param alphaMode The alpha mode of the software bitmap.
 * @return An asynchronous operation that returns a SoftwareBitmap on successful completion.
 */
getSoftwareBitmapAsync(
pixelFormat: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>,
alphaMode: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$SoftwareBitmap>;

/**
 * Asynchronously returns a stream containing the thumbnail image.
 * @return Object that manages the asynchronous retrieval of the thumbnail data.
 */
getThumbnailAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$ImageStream>;

/**
 * The height of the frame in pixels, after any EXIF orientation has been applied to the bitmap.
 */
orientedPixelHeight: number;

/**
 * The width of the frame in pixels, after any EXIF orientation has been applied to the bitmap.
 */
orientedPixelWidth: number;

/**
 * The height of the frame in pixels.
 */
pixelHeight: number;

/**
 * The width of the frame in pixels.
 */
pixelWidth: number
}


/**
 * Specifies the interpolation mode used for scaling pixel data.
 */

declare  var Windows$Graphics$Imaging$BitmapInterpolationMode: {|
  +nearestNeighbor: 0,// 0
+linear: 1,// 1
+cubic: 2,// 2
+fant: 3,// 3

|};



/**
 * Specifies the pixel format of pixel data. Each enumeration value defines a channel ordering, bit depth, and data type.
 */

declare  var Windows$Graphics$Imaging$BitmapPixelFormat: {|
  +unknown: 0,// 0
+rgba16: 1,// 1
+rgba8: 2,// 2
+gray16: 3,// 3
+gray8: 4,// 4
+bgra8: 5,// 5
+nv12: 6,// 6
+yuy2: 7,// 7

|};



/**
 * Provides read and write access to image properties and metadata.
 */
declare class Windows$Graphics$Imaging$BitmapProperties  {

/**
 * Asynchronously retrieves one or more bitmap properties.
 * @param propertiesToRetrieve A collection of strings containing the specified property keys.
 * @return Object that manages the asynchronous retrieval of the bitmap properties.
 */
getPropertiesAsync(
propertiesToRetrieve: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$BitmapPropertySet>;

/**
 * Asynchronously sets one or more bitmap properties.
 * @param propertiesToSet A collection of key-value pairs representing the bitmap properties to be set. Each key is a string containing the Windows property or metadata query, and the corresponding value is a BitmapTypedValue with the data and the correct PropertyType .
 * @return Object that manages the setting of the bitmap properties asynchronously.
 */
setPropertiesAsync(
propertiesToSet: Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Provides read access to image properties and metadata. A particular instance of BitmapPropertiesView may represent the entire contents of the frame metadata, or any nested metadata block within the frame.
 */
declare class Windows$Graphics$Imaging$BitmapPropertiesView  {

/**
 * Asynchronously retrieves one or more bitmap properties.
 * @param propertiesToRetrieve A collection of strings representing the property keys or queries that are being requested. Valid strings include Windows properties and Windows Imaging Component metadata queries.
 * @return Object that manages the asynchronous retrieval of the bitmap properties.
 */
getPropertiesAsync(
propertiesToRetrieve: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$BitmapPropertySet>
}


/**
 * Represents a property set of BitmapTypedValue objects.
 */
declare class Windows$Graphics$Imaging$BitmapPropertySet  {

/**
 * Creates and initializes a new instance of the bitmap property set.
 */
constructor(): this;

/**
 * Removes all items from the property set.
 */
clear(): void;

/**
 * Returns an iterator to enumerate the items in the property set.
 * @return The iterator. The current position of the iterator is index 0, or the end of the property set if the property set is empty.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Gets an immutable view of the property set.
 * @return The immutable view.
 */
getView(
): Windows$Foundation$Collections$IMapView<string, Windows$Graphics$Imaging$BitmapTypedValue>;

/**
 * Indicates whether the property set has an item with the specified key.
 * @param key The key.
 * @return True if the property set has an item with the specified key; otherwise, false.
 */
hasKey(key: string): boolean;

/**
 * Adds an item to the property set.
 * @param key The key to insert.
 * @param value The value to insert.
 * @return True if the method replaces a value that already exists for the key; false if this is a new key.
 */
insert(key: string, value: Windows$Graphics$Imaging$BitmapTypedValue): boolean;

/**
 * Retrieves the value for the specified key.
 * @param key The key.
 * @return The value, if an item with the specified key exists; otherwise, null.
 */
lookup(key: string): Windows$Graphics$Imaging$BitmapTypedValue;

/**
 * Removes an item from the property set.
 * @param key The key.
 */
remove(key: string): void;

/**
 * Removes a specific item from the BitmapPropertySet .
 * @param key The key of the item to remove.
 * @return true if the item was removed, otherwise false.
 */
remove(key: string): boolean;

/**
 * Gets the number of items contained in the property set.
 */
size: number
}


/**
 * Specifies the rotation operation to be performed on pixel data.
 */

declare  var Windows$Graphics$Imaging$BitmapRotation: {|
  +none: 0,// 0
+clockwise90Degrees: 1,// 1
+clockwise180Degrees: 2,// 2
+clockwise270Degrees: 3,// 3

|};



/**
 * Contains transformations that can be applied to pixel data.
 */
declare class Windows$Graphics$Imaging$BitmapTransform  {

/**
 * Creates a new BitmapTransform object.
 */
constructor(): this;

/**
 * Specifies the bounding rectangle that is used to crop the bitmap. This rectangle is defined in the coordinate space after scale, rotation, and flip are applied.
 */
bounds: Windows$Graphics$Imaging$BitmapBounds;

/**
 * Specifies the flip operation that is used to transform the bitmap.
 */
flip: $Values<typeof Windows$Graphics$Imaging$BitmapFlip>;

/**
 * Specifies the interpolation mode that is used to scale the bitmap.
 */
interpolationMode: $Values<typeof Windows$Graphics$Imaging$BitmapInterpolationMode>;

/**
 * Specifies the rotation operation that is used to transform the bitmap.
 */
rotation: $Values<typeof Windows$Graphics$Imaging$BitmapRotation>;

/**
 * Specifies the height, in pixels, of the bitmap after it is scaled. This is defined in the coordinate space of the source image, before rotation and flip are applied.
 */
scaledHeight: number;

/**
 * Specifies the width, in pixels, of the bitmap after it is scaled. This is defined in the coordinate space of the source image, before rotation and flip are applied.
 */
scaledWidth: number
}


/**
 * A value along with an enumeration specifying its data type.
 */
declare class Windows$Graphics$Imaging$BitmapTypedValue  {

/**
 * Creates a new BitmapTypedValue object.
 * @param value The value to store.
 * @param type The type of the value parameter.
 */
constructor(value: any, type: $Values<typeof Windows$Foundation$PropertyType>): this;

/**
 * Gets the PropertyType of the stored value.
 */
type: $Values<typeof Windows$Foundation$PropertyType>;

/**
 * Gets the stored value.
 */
value: any
}


/**
 * Specifies the color management behavior when obtaining pixel data.
 */

declare  var Windows$Graphics$Imaging$ColorManagementMode: {|
  +doNotColorManage: 0,// 0
+colorManageToSRgb: 1,// 1

|};



/**
 * Specifies the EXIF orientation flag behavior when obtaining pixel data.
 */

declare  var Windows$Graphics$Imaging$ExifOrientationMode: {|
  +ignoreExifOrientation: 0,// 0
+respectExifOrientation: 1,// 1

|};



/**
 * An implementation of IRandomAccessStreamWithContent type used in the Imaging namespace.
 */
declare class Windows$Graphics$Imaging$ImageStream  {

/**
 * Indicates if you can read the stream.
 */
canRead: boolean;

/**
 * Indicates if you can write to the stream.
 */
canWrite: boolean;

/**
 * Returns the file stream for the ImageStream .
 * @return The file stream for the image.
 */
cloneStream(): Windows$Storage$Streams$IRandomAccessStream;

/**
 * Closes the ImageStream .
 */
close(): void;

/**
 * Returns the data format of the stream.
 */
contentType: string;

/**
 * Asynchronously commits the current frame data and flushes all of the data on the image stream.
 * @return An object that manages the asynchronous flush operation.
 */
flushAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Returns an input stream at a specified location in a stream.
 * @param position The location in the stream at which to begin.
 * @return The input stream.
 */
getInputStreamAt(position: number): Windows$Storage$Streams$IInputStream;

/**
 * Returns an output stream at a specified location in a stream.
 * @param position The location in the output stream at which to begin.
 * @return The output stream.
 */
getOutputStreamAt(position: number): Windows$Storage$Streams$IOutputStream;

/**
 * Gets the byte offset of the stream.
 */
position: number;

/**
 * Reads data asynchronously from a sequential stream.
 * @param buffer The buffer into which the asynchronous read operation stores the data.
 * @param count The size of the buffer.
 * @param options The options for the stream to be read.
 * @return The byte reader operation.
 */
readAsync(
buffer: Windows$Storage$Streams$IBuffer,
count: number,
options: $Values<typeof Windows$Storage$Streams$InputStreamOptions>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>;

/**
 * Sets the position of the stream to the specified value.
 * @param position The new position of the stream.
 */
seek(position: number): void;

/**
 * Gets or sets the size of the random access stream.
 */
size: number;

/**
 * Writes data asynchronously in a sequential stream.
 * @param buffer The buffer into which the asynchronous writer operation writes.
 * @return The byte writer operation.
 */
writeAsync(
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Specifies which chroma subsampling mode will be used for image compression in JPEG images.
 */

declare  var Windows$Graphics$Imaging$JpegSubsamplingMode: {|
  +default: 0,// 0
+y4Cb2Cr0: 1,// 1
+y4Cb2Cr2: 2,// 2
+y4Cb4Cr4: 3,// 3

|};



/**
 * Provides access to the pixel data from a bitmap frame.
 */
declare class Windows$Graphics$Imaging$PixelDataProvider  {

/**
 * Returns the internally-stored pixel data.
 * @return The pixel data.
 */
detachPixelData(): number[]
}


/**
 * Specifies the filter used to optimize the image prior to image compression in PNG images.
 */

declare  var Windows$Graphics$Imaging$PngFilterMode: {|
  +automatic: 0,// 0
+none: 1,// 1
+sub: 2,// 2
+up: 3,// 3
+average: 4,// 4
+paeth: 5,// 5
+adaptive: 6,// 6

|};



/**
 * Represents an uncompressed bitmap.
 */
declare class Windows$Graphics$Imaging$SoftwareBitmap  {

/**
 * Converts an existing SoftwareBitmap to a SoftwareBitmap with a different pixel format or alpha mode.
 * @param source The software bitmap to convert.
 * @param format The pixel format of the new software bitmap.
 * @param alpha The alpha mode of the new software bitmap.
 * @return The converted software bitmap.
 */
static convert(
source: Windows$Graphics$Imaging$SoftwareBitmap,
format: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>,
alpha: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>): Windows$Graphics$Imaging$SoftwareBitmap;

/**
 * Converts an existing SoftwareBitmap to a SoftwareBitmap with a different pixel format.
 * @param source The software bitmap to convert.
 * @param format The pixel format of the new software bitmap.
 * @return The converted software bitmap.
 */
static convert(
source: Windows$Graphics$Imaging$SoftwareBitmap,
format: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>): Windows$Graphics$Imaging$SoftwareBitmap;

/**
 * Creates a copy of the provided SoftwareBitmap object.
 * @param source The software bitmap to copy.
 * @return The newly created copy of the software bitmap.
 */
static copy(
source: Windows$Graphics$Imaging$SoftwareBitmap): Windows$Graphics$Imaging$SoftwareBitmap;

/**
 * Creates a new SoftwareBitmap by performing a deep copy of the provided buffer. Modifications to the data in the new SoftwareBitmap will not effect the buffer from which it was created.
 * @param source The source buffer from which the copy will be created.
 * @param format The pixel format of the software bitmap.
 * @param width The width of the software bitmap, in pixels.
 * @param height The height of the software bitmap, in pixels.
 * @return The new software bitmap.
 */
static createCopyFromBuffer(
source: Windows$Storage$Streams$IBuffer,
format: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>,
width: number,
height: number): Windows$Graphics$Imaging$SoftwareBitmap;

/**
 * Creates a new SoftwareBitmap by performing a deep copy of the provided buffer. Modifications to the data in the new SoftwareBitmap will not effect the buffer from which it was created.
 * @param source The source buffer from which the copy will be created.
 * @param format The pixel format of the software bitmap.
 * @param width The width of the software bitmap, in pixels.
 * @param height The height of the software bitmap, in pixels.
 * @param alpha The alpha mode of the software bitmap.
 * @return The new software bitmap.
 */
static createCopyFromBuffer(
source: Windows$Storage$Streams$IBuffer,
format: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>,
width: number,
height: number,
alpha: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>): Windows$Graphics$Imaging$SoftwareBitmap;

/**
 * Asynchronously creates a new SoftwareBitmap by performing a deep copy of the provided IDirect3DSurface . Modifications to the data in the new SoftwareBitmap will not effect the surface from which it was created.
 * @param surface The source surface from which the copy will be created.
 * @return An asynchronous operation that returns a SoftwareBitmap on successful completion.
 */
static createCopyFromSurfaceAsync(
surface: Windows$Graphics$DirectX$Direct3D11$IDirect3DSurface): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$SoftwareBitmap>;

/**
 * Asynchronously creates a new SoftwareBitmap by performing a deep copy of the provided IDirect3DSurface . Modifications to the data in the new SoftwareBitmap will not effect the surface from which it was created.
 * @param surface The source surface from which the copy will be created.
 * @param alpha The alpha mode of the software bitmap.
 * @return An asynchronous operation that returns a SoftwareBitmap on successful completion.
 */
static createCopyFromSurfaceAsync(
surface: Windows$Graphics$DirectX$Direct3D11$IDirect3DSurface,
alpha: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Imaging$SoftwareBitmap>;

/**
 * Initializes a new instance of the SoftwareBitmap class.
 * @param format The pixel format of the new software bitmap.
 * @param width The width of the new software bitmap, in pixels.
 * @param height The height of the new software bitmap, in pixels.
 * @param alpha The alpha mode of the new software bitmap.
 */
constructor(format: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>, width: number, height: number, alpha: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>): this;

/**
 * Initializes a new instance of the SoftwareBitmap class.
 * @param format The pixel format of the new software bitmap.
 * @param width The width of the new software bitmap, in pixels.
 * @param height The height of the new software bitmap, in pixels.
 */
constructor(format: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>, width: number, height: number): this;

/**
 * Gets the alpha mode of the software bitmap.
 */
bitmapAlphaMode: $Values<typeof Windows$Graphics$Imaging$BitmapAlphaMode>;

/**
 * Gets the pixel format of the software bitmap.
 */
bitmapPixelFormat: $Values<typeof Windows$Graphics$Imaging$BitmapPixelFormat>;

/**
 * Disposes of the object and associated resources.
 */
close(): void;

/**
 * Copies the pixel data from an IBuffer into the SoftwareBitmap .
 * @param buffer The buffer containing the pixel data to be copied.
 */
copyFromBuffer(buffer: Windows$Storage$Streams$IBuffer): void;

/**
 * Copies the current SoftwareBitmap into the provided SoftwareBitmap object.
 * @param bitmap The target software bitmap into which the data will be copied.
 */
copyTo(bitmap: Windows$Graphics$Imaging$SoftwareBitmap): void;

/**
 * Copies the software bitmap pixel data into the specified IBuffer .
 * @param buffer The target buffer to which the pixel data will be copied.
 */
copyToBuffer(buffer: Windows$Storage$Streams$IBuffer): void;

/**
 * Gets or sets the dots per inch of the software bitmap in the X direction.
 */
dpiX: number;

/**
 * Gets or sets the dots per inch of the software bitmap in the Y direction.
 */
dpiY: number;

/**
 * Gets a read-only representation of the SoftwareBitmap object.
 * @return A read-only representation of the SoftwareBitmap object.
 */
getReadOnlyView(): Windows$Graphics$Imaging$SoftwareBitmap;

/**
 * Gets a value indicating whether the software bitmap can be modified.
 */
isReadOnly: boolean;

/**
 * Gets a BitmapBuffer object that allows you to operate directly on the software bitmap's pixel data.
 * @param mode A value indicating the access mode of the returned buffer.
 * @return The buffer containing pixel data.
 */
lockBuffer(
mode: $Values<typeof Windows$Graphics$Imaging$BitmapBufferAccessMode>): Windows$Graphics$Imaging$BitmapBuffer;

/**
 * Gets the height of the software bitmap, in pixels.
 */
pixelHeight: number;

/**
 * Gets the width of the software bitmap, in pixels.
 */
pixelWidth: number
}


/**
 * Specifies the compression mode used for TIFF images.
 */

declare  var Windows$Graphics$Imaging$TiffCompressionMode: {|
  +automatic: 0,// 0
+none: 1,// 1
+ccitt3: 2,// 2
+ccitt4: 3,// 3
+lzw: 4,// 4
+rle: 5,// 5
+zip: 6,// 6
+lzwhDifferencing: 7,// 7

|};



/**
 * Defines the format of a bitmap plane.
 */
declare interface Windows$Graphics$Imaging$BitmapPlaneDescription {

/**
 * The height of the plane, in pixels.
 */
height: number,

/**
 * The start index of the pixel data within the plane.
 */
startIndex: number,

/**
 * The stride of the bitmap data.
 */
stride: number,

/**
 * The width of the plane, in pixels.
 */
width: number
} 


/**
 * Specifies a bounding rectangle.
 */
declare interface Windows$Graphics$Imaging$BitmapBounds {

/**
 * The Height, in pixels, of the bounding box
 */
height: number,

/**
 * The Width, in pixels, of the bounding box.
 */
width: number,

/**
 * The X coordinate, in pixels, of the top left corner of the bounding box.
 */
x: number,

/**
 * The Y coordinate, in pixels, of the top left corner of the bounding box.
 */
y: number
} 


/**
 * Represents the size of a bitmap, in pixels.
 */
declare interface Windows$Graphics$Imaging$BitmapSize {

/**
 * The height of a bitmap, in pixels.
 */
height: number,

/**
 * The width of a bitmap, in pixels.
 */
width: number
} 


      declare var npm$namespace$Windows$Graphics$Printing: {
        
        D: typeof Windows$Graphics$Printing$D,
        PrintBinding: typeof Windows$Graphics$Printing$PrintBinding,
PrintCollation: typeof Windows$Graphics$Printing$PrintCollation,
PrintColorMode: typeof Windows$Graphics$Printing$PrintColorMode,
PrintDuplex: typeof Windows$Graphics$Printing$PrintDuplex,
PrintHolePunch: typeof Windows$Graphics$Printing$PrintHolePunch,
PrintMediaSize: typeof Windows$Graphics$Printing$PrintMediaSize,
PrintMediaType: typeof Windows$Graphics$Printing$PrintMediaType,
PrintOrientation: typeof Windows$Graphics$Printing$PrintOrientation,
PrintQuality: typeof Windows$Graphics$Printing$PrintQuality,
PrintStaple: typeof Windows$Graphics$Printing$PrintStaple,
PrintTaskCompletion: typeof Windows$Graphics$Printing$PrintTaskCompletion,
        PrintManager: typeof Windows$Graphics$Printing$PrintManager,
PrintTask: typeof Windows$Graphics$Printing$PrintTask,
PrintTaskCompletedEventArgs: typeof Windows$Graphics$Printing$PrintTaskCompletedEventArgs,
PrintTaskOptions: typeof Windows$Graphics$Printing$PrintTaskOptions,
PrintTaskProgressingEventArgs: typeof Windows$Graphics$Printing$PrintTaskProgressingEventArgs,
PrintTaskRequest: typeof Windows$Graphics$Printing$PrintTaskRequest,
PrintTaskRequestedDeferral: typeof Windows$Graphics$Printing$PrintTaskRequestedDeferral,
PrintTaskRequestedEventArgs: typeof Windows$Graphics$Printing$PrintTaskRequestedEventArgs,
PrintTaskSourceRequestedArgs: typeof Windows$Graphics$Printing$PrintTaskSourceRequestedArgs,
PrintTaskSourceRequestedDeferral: typeof Windows$Graphics$Printing$PrintTaskSourceRequestedDeferral,
StandardPrintTaskOptions: typeof Windows$Graphics$Printing$StandardPrintTaskOptions,
        OptionDetails: typeof npm$namespace$Windows$Graphics$Printing$OptionDetails,
      }
declare var Windows$Graphics$Printing$D: void;


      declare var npm$namespace$Windows$Graphics$Printing$OptionDetails: {
        
        
        PrintOptionStates: typeof Windows$Graphics$Printing$OptionDetails$PrintOptionStates,
PrintOptionType: typeof Windows$Graphics$Printing$OptionDetails$PrintOptionType,
        PrintBindingOptionDetails: typeof Windows$Graphics$Printing$OptionDetails$PrintBindingOptionDetails,
PrintCollationOptionDetails: typeof Windows$Graphics$Printing$OptionDetails$PrintCollationOptionDetails,
PrintColorModeOptionDetails: typeof Windows$Graphics$Printing$OptionDetails$PrintColorModeOptionDetails,
PrintCopiesOptionDetails: typeof Windows$Graphics$Printing$OptionDetails$PrintCopiesOptionDetails,
PrintCustomItemDetails: typeof Windows$Graphics$Printing$OptionDetails$PrintCustomItemDetails,
PrintCustomItemListOptionDetails: typeof Windows$Graphics$Printing$OptionDetails$PrintCustomItemListOptionDetails,
PrintCustomTextOptionDetails: typeof Windows$Graphics$Printing$OptionDetails$PrintCustomTextOptionDetails,
PrintDuplexOptionDetails: typeof Windows$Graphics$Printing$OptionDetails$PrintDuplexOptionDetails,
PrintHolePunchOptionDetails: typeof Windows$Graphics$Printing$OptionDetails$PrintHolePunchOptionDetails,
PrintMediaSizeOptionDetails: typeof Windows$Graphics$Printing$OptionDetails$PrintMediaSizeOptionDetails,
PrintMediaTypeOptionDetails: typeof Windows$Graphics$Printing$OptionDetails$PrintMediaTypeOptionDetails,
PrintOrientationOptionDetails: typeof Windows$Graphics$Printing$OptionDetails$PrintOrientationOptionDetails,
PrintQualityOptionDetails: typeof Windows$Graphics$Printing$OptionDetails$PrintQualityOptionDetails,
PrintStapleOptionDetails: typeof Windows$Graphics$Printing$OptionDetails$PrintStapleOptionDetails,
PrintTaskOptionChangedEventArgs: typeof Windows$Graphics$Printing$OptionDetails$PrintTaskOptionChangedEventArgs,
PrintTaskOptionDetails: typeof Windows$Graphics$Printing$OptionDetails$PrintTaskOptionDetails,
        
      }

/**
 * Represents the list of print binding options.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintBindingOptionDetails  {

/**
 * Gets or sets the string for an error condition.
 */
errorText: string;

/**
 * Gets the list of items for the print binding options.
 */
items: Windows$Foundation$Collections$IVectorView<any>;

/**
 * Gets the ID of the print binding option.
 */
optionId: string;

/**
 * Gets the option type of the print binding option.
 */
optionType: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionType>;

/**
 * Gets or sets the state of the print binding option.
 */
state: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionStates>;

/**
 * Sets the value for the print binding option.
 * @param value Value for the print binding option.
 * @return Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
trySetValue(value: any): boolean;

/**
 * Gets or sets the enumerated value of the print binding option.
 */
value: any
}


/**
 * Represents the list of print collation options.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintCollationOptionDetails  {

/**
 * Gets or sets the string for an error condition.
 */
errorText: string;

/**
 * Gets the list of items for the print collation option.
 */
items: Windows$Foundation$Collections$IVectorView<any>;

/**
 * Gets the ID of the print collation option.
 */
optionId: string;

/**
 * Gets the option type for the print collation option.
 */
optionType: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionType>;

/**
 * Gets or sets the state of the print collation option.
 */
state: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionStates>;

/**
 * Sets the value for the print collation option.
 * @param value Value for the print collation option.
 * @return Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
trySetValue(value: any): boolean;

/**
 * Gets or sets the enumerated value of the print collation option.
 */
value: any
}


/**
 * Represents the list of print color mode options.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintColorModeOptionDetails  {

/**
 * Gets or sets the string for an error condition.
 */
errorText: string;

/**
 * Gets the list of items for the print color mode option.
 */
items: Windows$Foundation$Collections$IVectorView<any>;

/**
 * Gets the ID for the print color mode option.
 */
optionId: string;

/**
 * Gets the option type for the print color mode option.
 */
optionType: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionType>;

/**
 * Gets or sets the state of the print color mode option.
 */
state: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionStates>;

/**
 * Sets the value for the print color mode option.
 * @param value Value for the print color mode option.
 * @return Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
trySetValue(value: any): boolean;

/**
 * Gets or sets the enumerated value of the print color mode option.
 */
value: any
}


/**
 * Represents the option for the number of printed copies.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintCopiesOptionDetails  {

/**
 * Gets or sets the string for an error condition.
 */
errorText: string;

/**
 * Gets the value for the maximum number of printed copies allowed.
 */
maxValue: number;

/**
 * Gets the value for the minimum number of printed copies allowed.
 */
minValue: number;

/**
 * Gets the ID for the option for the number of printed copies.
 */
optionId: string;

/**
 * Gets the option type for the option for the number of printed copies.
 */
optionType: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionType>;

/**
 * Gets or sets the state of the option for the number of printed copies.
 */
state: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionStates>;

/**
 * Sets the value for the print copies option.
 * @param value Value for the print copies option.
 * @return Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
trySetValue(value: any): boolean;

/**
 * Gets or sets the number of copies for a print task.
 */
value: any
}


/**
 * Allows apps to add a collection of enumerable options to the app print experience.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintCustomItemDetails  {

/**
 * Gets or sets the display name of the custom print task option item.
 */
itemDisplayName: string;

/**
 * Gets the ID of the custom print task option item.
 */
itemId: string
}


/**
 * Represents a list of the custom print task option items.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintCustomItemListOptionDetails  {

/**
 * Sets the ID or display name of an item in the list of custom print task options.
 * @param itemId The ID of the option item.
 * @param displayName The display name of the option item.
 */
addItem(itemId: string, displayName: string): void;

/**
 * Gets or sets the display name of an item in the list of custom print task options.
 */
displayName: string;

/**
 * Gets or sets the string for an error condition.
 */
errorText: string;

/**
 * Gets an item from the list of custom print tasks.
 */
items: Windows$Foundation$Collections$IVectorView<any>;

/**
 * Gets the ID of a custom print task option.
 */
optionId: string;

/**
 * Gets the option type for a custom print task option.
 */
optionType: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionType>;

/**
 * Gets or sets the state of the list of custom print task option items.
 */
state: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionStates>;

/**
 * Sets the value for the item ID or the display name of the custom item.
 * @param value Value for the item ID or the display name of the custom item.
 * @return Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
trySetValue(value: any): boolean;

/**
 * Gets or sets the value of the list of custom print tasks.
 */
value: any
}


/**
 * Represents a custom print task option.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintCustomTextOptionDetails  {

/**
 * Gets or sets the display name of the custom print task option.
 */
displayName: string;

/**
 * Gets or sets the string for an error condition.
 */
errorText: string;

/**
 * Gets or sets the maximum number of characters for the display name of the custom print task option.
 */
maxCharacters: number;

/**
 * Gets the ID of the custom print task option.
 */
optionId: string;

/**
 * Gets the option type for the custom print task option.
 */
optionType: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionType>;

/**
 * Gets or sets the state of a custom print task option.
 */
state: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionStates>;

/**
 * Sets the value for the custom print task.
 * @param value Value for the custom print task.
 * @return Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
trySetValue(value: any): boolean;

/**
 * Gets or sets the value of a custom print task option.
 */
value: any
}


/**
 * Represents the list of print duplex options.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintDuplexOptionDetails  {

/**
 * Gets or sets the string for an error condition.
 */
errorText: string;

/**
 * Gets the list of print duplex options.
 */
items: Windows$Foundation$Collections$IVectorView<any>;

/**
 * Gets the ID of the print duplex option.
 */
optionId: string;

/**
 * Gets the option type of the print duplex option.
 */
optionType: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionType>;

/**
 * Gets or sets the state of the print duplex options.
 */
state: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionStates>;

/**
 * Sets the value for the duplex option.
 * @param value Value for the duplex option.
 * @return Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
trySetValue(value: any): boolean;

/**
 * Gets or sets the enumerated vlaue of the print duplex option.
 */
value: any
}


/**
 * Represents the list of punch hole options.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintHolePunchOptionDetails  {

/**
 * Gets or sets the string for an error condition.
 */
errorText: string;

/**
 * Gets the list of items for the hole punch option.
 */
items: Windows$Foundation$Collections$IVectorView<any>;

/**
 * Gets the ID for the hole punch option.
 */
optionId: string;

/**
 * Gets the option type for the hole punch option.
 */
optionType: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionType>;

/**
 * Gets or sets the state of the hole punch option.
 */
state: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionStates>;

/**
 * Sets the value for the hole punch option.
 * @param value Value for the hole punch option.
 * @return Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
trySetValue(value: any): boolean;

/**
 * Gets or sets the enumerated value of the hole punch option.
 */
value: any
}


/**
 * Represents the list of media size options.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintMediaSizeOptionDetails  {

/**
 * Gets or sets the string for an error condition.
 */
errorText: string;

/**
 * Gets the list of print media size option items.
 */
items: Windows$Foundation$Collections$IVectorView<any>;

/**
 * Gets the ID for the print media size option.
 */
optionId: string;

/**
 * Gets the option type for the option for the number of printed copies.
 */
optionType: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionType>;

/**
 * Gets or sets the state of the option for the number of printed copies.
 */
state: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionStates>;

/**
 * Sets the value for the media size option.
 * @param value Value for the media size option.
 * @return Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
trySetValue(value: any): boolean;

/**
 * Gets or sets the number of copies for a print task.
 */
value: any
}


/**
 * Represents the list of print media type options.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintMediaTypeOptionDetails  {

/**
 * Gets or sets the string for an error condition.
 */
errorText: string;

/**
 * Gets the list of items for the print media type options.
 */
items: Windows$Foundation$Collections$IVectorView<any>;

/**
 * Gets the ID for the print media type option.
 */
optionId: string;

/**
 * Gets the option type for the print media type option.
 */
optionType: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionType>;

/**
 * Gets or sets the state for the print media type option.
 */
state: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionStates>;

/**
 * Sets the value for the media type option.
 * @param value Value for the media type option.
 * @return Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
trySetValue(value: any): boolean;

/**
 * Gets or sets the enumerated value of the print media type option.
 */
value: any
}


/**
 * Specifies the print task option states.
 */

declare  var Windows$Graphics$Printing$OptionDetails$PrintOptionStates: {|
  +none: 0,// 0
+enabled: 1,// 1
+constrained: 2,// 2

|};



/**
 * Specifies the print task option types.
 */

declare  var Windows$Graphics$Printing$OptionDetails$PrintOptionType: {|
  +unknown: 0,// 0
+number: 1,// 1
+text: 2,// 2
+itemList: 3,// 3

|};



/**
 * Represents the list of print orientation options.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintOrientationOptionDetails  {

/**
 * Gets or sets the string for an error condition.
 */
errorText: string;

/**
 * Gets the list of items for the print media type options.
 */
items: Windows$Foundation$Collections$IVectorView<any>;

/**
 * Gets the ID for the print orientation option.
 */
optionId: string;

/**
 * Gets the option type for the print media type option.
 */
optionType: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionType>;

/**
 * Gets or sets the state for the print media type option.
 */
state: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionStates>;

/**
 * Sets the value for the print orientation option.
 * @param value Value for the print orientation option.
 * @return Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
trySetValue(value: any): boolean;

/**
 * Gets or sets the enumerated value of the print media type option.
 */
value: any
}


/**
 * Represents the list of print quality options.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintQualityOptionDetails  {

/**
 * Gets or sets the string for an error condition.
 */
errorText: string;

/**
 * Gets the list of items for the print quality options.
 */
items: Windows$Foundation$Collections$IVectorView<any>;

/**
 * Gets the ID for the print quality option.
 */
optionId: string;

/**
 * Gets the option type for the print quality option.
 */
optionType: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionType>;

/**
 * Gets or sets the state of the print quality option.
 */
state: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionStates>;

/**
 * Sets the value for the print quality option.
 * @param value Value for the print quality option.
 * @return Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
trySetValue(value: any): boolean;

/**
 * Gets or sets the enumerated value of the print quality option.
 */
value: any
}


/**
 * Represents a list of the stapling options.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintStapleOptionDetails  {

/**
 * Gets or sets the string for an error condition.
 */
errorText: string;

/**
 * Gets the list of items for the stapling options.
 */
items: Windows$Foundation$Collections$IVectorView<any>;

/**
 * Gets the ID for the stapling option.
 */
optionId: string;

/**
 * Gets the option type for the stapling option.
 */
optionType: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionType>;

/**
 * Gets or sets the state of the stapling option.
 */
state: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionStates>;

/**
 * Sets the value for the staple opiton.
 * @param value Value for the staple opiton.
 * @return Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
trySetValue(value: any): boolean;

/**
 * Gets or sets the enumerated value of the stapling option.
 */
value: any
}


/**
 * Called when a print task option has changed.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintTaskOptionChangedEventArgs  {

/**
 * Gets the ID of the print task option that changed.
 */
optionId: any
}


/**
 * A collection of events, methods and properties for advanced print tasks.
 */
declare class Windows$Graphics$Printing$OptionDetails$PrintTaskOptionDetails  {

/**
 * Used to retrieve the available options for a print task.
 * @param printTaskOptions Pointer to a PrintTaskOptions object.
 * @return Pointer to a PrintTaskOptionDetails object.
 */
static getFromPrintTaskOptions(
printTaskOptions: Windows$Graphics$Printing$PrintTaskOptions): Windows$Graphics$Printing$OptionDetails$PrintTaskOptionDetails;

/**
 * Creates a custom list of items that allow the user to choose the page format.
 * @param optionId The ID for the custom item.
 * @param displayName The display name for the custom item.
 * @return The list of custom items.
 */
createItemListOption(
optionId: string,
displayName: string): Windows$Graphics$Printing$OptionDetails$PrintCustomItemListOptionDetails;

/**
 * Creates a CustomPrintTaskOptionText object to handle the display name and other parameters of the advanced print task option item.
 * @param optionId The ID of the print task option.
 * @param displayName The display name of the print task option.
 * @return The CustomPrintTaskOptionText object.
 */
createTextOption(
optionId: string,
displayName: string): Windows$Graphics$Printing$OptionDetails$PrintCustomTextOptionDetails;

/**
 * Gets the list of print task options that are currently displayed.
 */
displayedOptions: Windows$Foundation$Collections$IVector<string>;

/**
 * Returns a PrintPageDescription object for the referenced page number.
 * @param jobPageNumber The page number.
 * @return The PrintPageDescription object.
 */
getPageDescription(jobPageNumber: number): Windows$Graphics$Printing$PrintPageDescription;

/**
 * Raised when the print system begins a validation pass on the current state of the print ticket.
 */
onbeginvalidation: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$OptionDetails$PrintTaskOptionDetails, any>;
addEventListener(
type: "beginvalidation",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$OptionDetails$PrintTaskOptionDetails, any>): void;
removeEventListener(
type: "beginvalidation",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$OptionDetails$PrintTaskOptionDetails, any>): void;

/**
 * Raised when any one of the advanced print task options is changed.
 */
onoptionchanged: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$OptionDetails$PrintTaskOptionDetails, Windows$Graphics$Printing$OptionDetails$PrintTaskOptionChangedEventArgs>;
addEventListener(
type: "optionchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$OptionDetails$PrintTaskOptionDetails, Windows$Graphics$Printing$OptionDetails$PrintTaskOptionChangedEventArgs>): void;
removeEventListener(
type: "optionchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$OptionDetails$PrintTaskOptionDetails, Windows$Graphics$Printing$OptionDetails$PrintTaskOptionChangedEventArgs>): void;

/**
 * Gets the list of options for the advanced print task.
 */
options: Windows$Foundation$Collections$IMapView<string, Windows$Graphics$Printing$OptionDetails$IPrintOptionDetails>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the base class for the PrintTaskOptionXxx objects.
 */
declare interface Windows$Graphics$Printing$OptionDetails$IPrintOptionDetails {

/**
 * Sets the value for the print task option.
 * @param value Value for the print task option.
 * @return Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
trySetValue(value: any): boolean,

/**
 * Gets or sets the string for an error condition.
 */
errorText: string,

/**
 * Gets the ID for a print task option.
 */
optionId: string,

/**
 * Gets the option type for a print task option.
 */
optionType: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionType>,

/**
 * Gets or sets the state of a print task option.
 */
state: $Values<typeof Windows$Graphics$Printing$OptionDetails$PrintOptionStates>,

/**
 * Gets the enumerated value of a print task option.
 */
value: any
} 


/**
 * Specifies the print binding option.
 */

declare  var Windows$Graphics$Printing$PrintBinding: {|
  +default: 0,// 0
+notAvailable: 1,// 1
+printerCustom: 2,// 2
+none: 3,// 3
+bale: 4,// 4
+bindBottom: 5,// 5
+bindLeft: 6,// 6
+bindRight: 7,// 7
+bindTop: 8,// 8
+booklet: 9,// 9
+edgeStitchBottom: 10,// 10
+edgeStitchLeft: 11,// 11
+edgeStitchRight: 12,// 12
+edgeStitchTop: 13,// 13
+fold: 14,// 14
+jogOffset: 15,// 15
+trim: 16,// 16

|};



/**
 * Specifies the collation option.
 */

declare  var Windows$Graphics$Printing$PrintCollation: {|
  +default: 0,// 0
+notAvailable: 1,// 1
+printerCustom: 2,// 2
+collated: 3,// 3
+uncollated: 4,// 4

|};



/**
 * Specifies the color mode option.
 */

declare  var Windows$Graphics$Printing$PrintColorMode: {|
  +default: 0,// 0
+notAvailable: 1,// 1
+printerCustom: 2,// 2
+color: 3,// 3
+grayscale: 4,// 4
+monochrome: 5,// 5

|};



/**
 * Specifies the duplex option.
 */

declare  var Windows$Graphics$Printing$PrintDuplex: {|
  +default: 0,// 0
+notAvailable: 1,// 1
+printerCustom: 2,// 2
+oneSided: 3,// 3
+twoSidedShortEdge: 4,// 4
+twoSidedLongEdge: 5,// 5

|};



/**
 * Specifies the hole punch option.
 */

declare  var Windows$Graphics$Printing$PrintHolePunch: {|
  +default: 0,// 0
+notAvailable: 1,// 1
+printerCustom: 2,// 2
+none: 3,// 3
+leftEdge: 4,// 4
+rightEdge: 5,// 5
+topEdge: 6,// 6
+bottomEdge: 7,// 7

|};



/**
 * Informs Windows that an application wishes to participate in printing. The PrintManager class is also used for programmatically initiating printing.
 */
declare class Windows$Graphics$Printing$PrintManager  {

/**
 * Retrieves the PrintManager object associated with the current window.
 * @return The PrintManager object.
 */
static getForCurrentView(): Windows$Graphics$Printing$PrintManager;

/**
 * Programmatically initiates the user interface for printing content.
 * @return A Boolean value to indicate a TRUE for success or a FALSE for a failure.
 */
static showPrintUIAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Raised when a request to print has occurred. This event may be triggered by user action or via programmatic invocation of printing via the ShowPrintUIAsync method.
 */
onprinttaskrequested: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$PrintManager, Windows$Graphics$Printing$PrintTaskRequestedEventArgs>;
addEventListener(
type: "printtaskrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$PrintManager, Windows$Graphics$Printing$PrintTaskRequestedEventArgs>): void;
removeEventListener(
type: "printtaskrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$PrintManager, Windows$Graphics$Printing$PrintTaskRequestedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies the media size option.
 */

declare  var Windows$Graphics$Printing$PrintMediaSize: {|
  +default: 0,// 0
+notAvailable: 1,// 1
+printerCustom: 2,// 2
+businessCard: 3,// 3
+creditCard: 4,// 4
+isoA0: 5,// 5
+isoA1: 6,// 6
+isoA10: 7,// 7
+isoA2: 8,// 8
+isoA3: 9,// 9
+isoA3Extra: 10,// 10
+isoA3Rotated: 11,// 11
+isoA4: 12,// 12
+isoA4Extra: 13,// 13
+isoA4Rotated: 14,// 14
+isoA5: 15,// 15
+isoA5Extra: 16,// 16
+isoA5Rotated: 17,// 17
+isoA6: 18,// 18
+isoA6Rotated: 19,// 19
+isoA7: 20,// 20
+isoA8: 21,// 21
+isoA9: 22,// 22
+isoB0: 23,// 23
+isoB1: 24,// 24
+isoB10: 25,// 25
+isoB2: 26,// 26
+isoB3: 27,// 27
+isoB4: 28,// 28
+isoB4Envelope: 29,// 29
+isoB5Envelope: 30,// 30
+isoB5Extra: 31,// 31
+isoB7: 32,// 32
+isoB8: 33,// 33
+isoB9: 34,// 34
+isoC0: 35,// 35
+isoC1: 36,// 36
+isoC10: 37,// 37
+isoC2: 38,// 38
+isoC3: 39,// 39
+isoC3Envelope: 40,// 40
+isoC4: 41,// 41
+isoC4Envelope: 42,// 42
+isoC5: 43,// 43
+isoC5Envelope: 44,// 44
+isoC6: 45,// 45
+isoC6C5Envelope: 46,// 46
+isoC6Envelope: 47,// 47
+isoC7: 48,// 48
+isoC8: 49,// 49
+isoC9: 50,// 50
+isoDLEnvelope: 51,// 51
+isoDLEnvelopeRotated: 52,// 52
+isoSRA3: 53,// 53
+japan2LPhoto: 54,// 54
+japanChou3Envelope: 55,// 55
+japanChou3EnvelopeRotated: 56,// 56
+japanChou4Envelope: 57,// 57
+japanChou4EnvelopeRotated: 58,// 58
+japanDoubleHagakiPostcard: 59,// 59
+japanDoubleHagakiPostcardRotated: 60,// 60
+japanHagakiPostcard: 61,// 61
+japanHagakiPostcardRotated: 62,// 62
+japanKaku2Envelope: 63,// 63
+japanKaku2EnvelopeRotated: 64,// 64
+japanKaku3Envelope: 65,// 65
+japanKaku3EnvelopeRotated: 66,// 66
+japanLPhoto: 67,// 67
+japanQuadrupleHagakiPostcard: 68,// 68
+japanYou1Envelope: 69,// 69
+japanYou2Envelope: 70,// 70
+japanYou3Envelope: 71,// 71
+japanYou4Envelope: 72,// 72
+japanYou4EnvelopeRotated: 73,// 73
+japanYou6Envelope: 74,// 74
+japanYou6EnvelopeRotated: 75,// 75
+jisB0: 76,// 76
+jisB1: 77,// 77
+jisB10: 78,// 78
+jisB2: 79,// 79
+jisB3: 80,// 80
+jisB4: 81,// 81
+jisB4Rotated: 82,// 82
+jisB5: 83,// 83
+jisB5Rotated: 84,// 84
+jisB6: 85,// 85
+jisB6Rotated: 86,// 86
+jisB7: 87,// 87
+jisB8: 88,// 88
+jisB9: 89,// 89
+northAmerica10x11: 90,// 90
+northAmerica10x12: 91,// 91
+northAmerica10x14: 92,// 92
+northAmerica11x17: 93,// 93
+northAmerica14x17: 94,// 94
+northAmerica4x6: 95,// 95
+northAmerica4x8: 96,// 96
+northAmerica5x7: 97,// 97
+northAmerica8x10: 98,// 98
+northAmerica9x11: 99,// 99
+northAmericaArchitectureASheet: 100,// 100
+northAmericaArchitectureBSheet: 101,// 101
+northAmericaArchitectureCSheet: 102,// 102
+northAmericaArchitectureDSheet: 103,// 103
+northAmericaArchitectureESheet: 104,// 104
+northAmericaCSheet: 105,// 105
+northAmericaDSheet: 106,// 106
+northAmericaESheet: 107,// 107
+northAmericaExecutive: 108,// 108
+northAmericaGermanLegalFanfold: 109,// 109
+northAmericaGermanStandardFanfold: 110,// 110
+northAmericaLegal: 111,// 111
+northAmericaLegalExtra: 112,// 112
+northAmericaLetter: 113,// 113
+northAmericaLetterExtra: 114,// 114
+northAmericaLetterPlus: 115,// 115
+northAmericaLetterRotated: 116,// 116
+northAmericaMonarchEnvelope: 117,// 117
+northAmericaNote: 118,// 118
+northAmericaNumber10Envelope: 119,// 119
+northAmericaNumber10EnvelopeRotated: 120,// 120
+northAmericaNumber11Envelope: 121,// 121
+northAmericaNumber12Envelope: 122,// 122
+northAmericaNumber14Envelope: 123,// 123
+northAmericaNumber9Envelope: 124,// 124
+northAmericaPersonalEnvelope: 125,// 125
+northAmericaQuarto: 126,// 126
+northAmericaStatement: 127,// 127
+northAmericaSuperA: 128,// 128
+northAmericaSuperB: 129,// 129
+northAmericaTabloid: 130,// 130
+northAmericaTabloidExtra: 131,// 131
+otherMetricA3Plus: 132,// 132
+otherMetricA4Plus: 133,// 133
+otherMetricFolio: 134,// 134
+otherMetricInviteEnvelope: 135,// 135
+otherMetricItalianEnvelope: 136,// 136
+prc10Envelope: 137,// 137
+prc10EnvelopeRotated: 138,// 138
+prc16K: 139,// 139
+prc16KRotated: 140,// 140
+prc1Envelope: 141,// 141
+prc1EnvelopeRotated: 142,// 142
+prc2Envelope: 143,// 143
+prc2EnvelopeRotated: 144,// 144
+prc32K: 145,// 145
+prc32KBig: 146,// 146
+prc32KRotated: 147,// 147
+prc3Envelope: 148,// 148
+prc3EnvelopeRotated: 149,// 149
+prc4Envelope: 150,// 150
+prc4EnvelopeRotated: 151,// 151
+prc5Envelope: 152,// 152
+prc5EnvelopeRotated: 153,// 153
+prc6Envelope: 154,// 154
+prc6EnvelopeRotated: 155,// 155
+prc7Envelope: 156,// 156
+prc7EnvelopeRotated: 157,// 157
+prc8Envelope: 158,// 158
+prc8EnvelopeRotated: 159,// 159
+prc9Envelope: 160,// 160
+prc9EnvelopeRotated: 161,// 161
+roll04Inch: 162,// 162
+roll06Inch: 163,// 163
+roll08Inch: 164,// 164
+roll12Inch: 165,// 165
+roll15Inch: 166,// 166
+roll18Inch: 167,// 167
+roll22Inch: 168,// 168
+roll24Inch: 169,// 169
+roll30Inch: 170,// 170
+roll36Inch: 171,// 171
+roll54Inch: 172,// 172

|};



/**
 * Specifies the media types for the printed output.
 */

declare  var Windows$Graphics$Printing$PrintMediaType: {|
  +default: 0,// 0
+notAvailable: 1,// 1
+printerCustom: 2,// 2
+autoSelect: 3,// 3
+archival: 4,// 4
+backPrintFilm: 5,// 5
+bond: 6,// 6
+cardStock: 7,// 7
+continuous: 8,// 8
+envelopePlain: 9,// 9
+envelopeWindow: 10,// 10
+fabric: 11,// 11
+highResolution: 12,// 12
+label: 13,// 13
+multiLayerForm: 14,// 14
+multiPartForm: 15,// 15
+photographic: 16,// 16
+photographicFilm: 17,// 17
+photographicGlossy: 18,// 18
+photographicHighGloss: 19,// 19
+photographicMatte: 20,// 20
+photographicSatin: 21,// 21
+photographicSemiGloss: 22,// 22
+plain: 23,// 23
+screen: 24,// 24
+screenPaged: 25,// 25
+stationery: 26,// 26
+tabStockFull: 27,// 27
+tabStockPreCut: 28,// 28
+transparency: 29,// 29
+tshirtTransfer: 30,// 30
+none: 31,// 31

|};



/**
 * Specifies the orientation options for the printed output.
 */

declare  var Windows$Graphics$Printing$PrintOrientation: {|
  +default: 0,// 0
+notAvailable: 1,// 1
+printerCustom: 2,// 2
+portrait: 3,// 3
+portraitFlipped: 4,// 4
+landscape: 5,// 5
+landscapeFlipped: 6,// 6

|};



/**
 * Specifies the print quality options for the printed output.
 */

declare  var Windows$Graphics$Printing$PrintQuality: {|
  +default: 0,// 0
+notAvailable: 1,// 1
+printerCustom: 2,// 2
+automatic: 3,// 3
+draft: 4,// 4
+fax: 5,// 5
+high: 6,// 6
+normal: 7,// 7
+photographic: 8,// 8
+text: 9,// 9

|};



/**
 * Specifies the staple options.
 */

declare  var Windows$Graphics$Printing$PrintStaple: {|
  +default: 0,// 0
+notAvailable: 1,// 1
+printerCustom: 2,// 2
+none: 3,// 3
+stapleTopLeft: 4,// 4
+stapleTopRight: 5,// 5
+stapleBottomLeft: 6,// 6
+stapleBottomRight: 7,// 7
+stapleDualLeft: 8,// 8
+stapleDualRight: 9,// 9
+stapleDualTop: 10,// 10
+stapleDualBottom: 11,// 11
+saddleStitch: 12,// 12

|};



/**
 * Represents a printing operation including the content to be printed, as well as providing access to information describing how the content is to be printed.
 */
declare class Windows$Graphics$Printing$PrintTask  {

/**
 * Gets or sets a value that indicates whether the PrintTask supports 3D manufacturing devices, like a 3D printer.
 */
is3DManufacturingTargetEnabled: boolean;

/**
 * Gets or sets a value indicating whether the PrintTask supports printer targets.
 */
isPrinterTargetEnabled: boolean;

/**
 * Raised when the print task is completed.
 */
oncompleted: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$PrintTask, Windows$Graphics$Printing$PrintTaskCompletedEventArgs>;
addEventListener(
type: "completed",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$PrintTask, Windows$Graphics$Printing$PrintTaskCompletedEventArgs>): void;
removeEventListener(
type: "completed",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$PrintTask, Windows$Graphics$Printing$PrintTaskCompletedEventArgs>): void;

/**
 * Raised when the print system initializes print preview mode.
 */
onpreviewing: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$PrintTask, any>;
addEventListener(
type: "previewing",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$PrintTask, any>): void;
removeEventListener(
type: "previewing",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$PrintTask, any>): void;

/**
 * Raised to provide progress information about how much of the printed content has been submitted to the print subsystem for printing.
 */
onprogressing: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$PrintTask, Windows$Graphics$Printing$PrintTaskProgressingEventArgs>;
addEventListener(
type: "progressing",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$PrintTask, Windows$Graphics$Printing$PrintTaskProgressingEventArgs>): void;
removeEventListener(
type: "progressing",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$PrintTask, Windows$Graphics$Printing$PrintTaskProgressingEventArgs>): void;

/**
 * Raised when a print task begins submitting content to the print subsystem to be printed.
 */
onsubmitting: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$PrintTask, any>;
addEventListener(
type: "submitting",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$PrintTask, any>): void;
removeEventListener(
type: "submitting",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing$PrintTask, any>): void;

/**
 * Retrieves the PrintTaskOptions for the print task that defines how the content is to be formatted for printing.
 */
options: Windows$Graphics$Printing$PrintTaskOptions;

/**
 * Retrieves a set of properties associated with the PrintTask .
 */
properties: Windows$ApplicationModel$DataTransfer$DataPackagePropertySet;

/**
 * Returns a pointer to the app-provided object that represents the content to be printed. This object must support the IPrintDocumentSource interface.
 */
source: Windows$Graphics$Printing$IPrintDocumentSource;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Reports the completion of the print task.
 */
declare class Windows$Graphics$Printing$PrintTaskCompletedEventArgs  {

/**
 * Gets the completion status of the print task.
 */
completion: $Values<typeof Windows$Graphics$Printing$PrintTaskCompletion>
}


/**
 * Specifies the completion status of a print task.
 */

declare  var Windows$Graphics$Printing$PrintTaskCompletion: {|
  +abandoned: 0,// 0
+canceled: 1,// 1
+failed: 2,// 2
+submitted: 3,// 3

|};



/**
 * Represents a collection of methods and properties for managing the options which define how the content is to be printed.
 */
declare class Windows$Graphics$Printing$PrintTaskOptions  {

/**
 * Gets or sets the binding option for the print task.
 */
binding: $Values<typeof Windows$Graphics$Printing$PrintBinding>;

/**
 * Gets or sets the collation option of the print tasks.
 */
collation: $Values<typeof Windows$Graphics$Printing$PrintCollation>;

/**
 * Gets or sets the color mode option of the print task.
 */
colorMode: $Values<typeof Windows$Graphics$Printing$PrintColorMode>;

/**
 * Gets the list of options displayed for the print experience.
 */
displayedOptions: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets or sets the duplex option of the print task.
 */
duplex: $Values<typeof Windows$Graphics$Printing$PrintDuplex>;

/**
 * Retrieves the physical dimensions of the printed page.
 * @param jobPageNumber The page number.
 * @return The page description data.
 */
getPageDescription(jobPageNumber: number): Windows$Graphics$Printing$PrintPageDescription;

/**
 * Gets or sets the hole punch option of the print task.
 */
holePunch: $Values<typeof Windows$Graphics$Printing$PrintHolePunch>;

/**
 * Gets the maximum number of copies supported for the print task.
 */
maxCopies: number;

/**
 * Gets or sets the media size option of the print task.
 */
mediaSize: $Values<typeof Windows$Graphics$Printing$PrintMediaSize>;

/**
 * Gets or sets the media type option for the print task.
 */
mediaType: $Values<typeof Windows$Graphics$Printing$PrintMediaType>;

/**
 * Gets the minimum number of copies allowed for the print task.
 */
minCopies: number;

/**
 * Gets or sets the value for the number of copies for the print task.
 */
numberOfCopies: number;

/**
 * Gets or sets the orientation option for the print task.
 */
orientation: $Values<typeof Windows$Graphics$Printing$PrintOrientation>;

/**
 * Gets or sets the print quality option for the print task.
 */
printQuality: $Values<typeof Windows$Graphics$Printing$PrintQuality>;

/**
 * Gets or sets the staple option for the print task.
 */
staple: $Values<typeof Windows$Graphics$Printing$PrintStaple>
}


/**
 * Contains the event arguments for the PrintTask.Progressing event. This event is raised during the submitting phase of the PrintTask .
 */
declare class Windows$Graphics$Printing$PrintTaskProgressingEventArgs  {

/**
 * Gets the page count for a print task.
 */
documentPageCount: number
}


/**
 * Contains the request from the system to create a print task. This object is available from the PrintTaskRequestedEventArgs object passed to the PrintTaskRequested event.
 */
declare class Windows$Graphics$Printing$PrintTaskRequest  {

/**
 * Creates a new PrintTask which indicates that the app has content to be printed.
 * @param title Title for the print task.
 * @param handler Pointer to a PrintTaskSourceRequestedHandler delegate for the print task.
 * @return Pointer to the print task that was created.
 */
createPrintTask(
title: string,
handler: Windows$Graphics$Printing$PrintTaskSourceRequestedHandler): Windows$Graphics$Printing$PrintTask;

/**
 * Gets a DateTime value that indicates how long an app has to respond to the PrintTaskRequested event. If the system has not received a response from the PrintTaskRequested event handler by the time the deadline is reached, then the print task is ignored.
 */
deadline: Date;

/**
 * Retrieves the deferral object associated with the PrintTaskRequest . The deferral object is used to handle asynchronous calls in the PrintTaskRequested event handler.
 * @return The PrintTaskRequestedDeferral for a print task.
 */
getDeferral(): Windows$Graphics$Printing$PrintTaskRequestedDeferral
}


/**
 * Used to defer the request for a print task.
 */
declare class Windows$Graphics$Printing$PrintTaskRequestedDeferral  {

/**
 * Indicates when the deferral for the print task request is over.
 */
complete(): void
}


/**
 * Event arguments associated with the PrintTaskRequest .
 */
declare class Windows$Graphics$Printing$PrintTaskRequestedEventArgs  {

/**
 * Gets the PrintTaskRequest object for a print task.
 */
request: Windows$Graphics$Printing$PrintTaskRequest
}


/**
 * Arguments associated with the PrintTaskSourceRequestedHandler delegate. Provides a method for handing the content to be printed to the Print Task.
 */
declare class Windows$Graphics$Printing$PrintTaskSourceRequestedArgs  {

/**
 * Gets the DateTime object that indicates the deadline for a print task source request.
 */
deadline: Date;

/**
 * Gets a PrintTaskSourceRequestedDeferral object that provides access to a Complete method. This method indicates then the deferral is over.
 * @return Provides access to a Complete method.
 */
getDeferral(): Windows$Graphics$Printing$PrintTaskSourceRequestedDeferral;

/**
 * Informs the print task of the content to be printed.
 * @param source A pointer to the IPrintDocumentSource interface.
 */
setSource(source: Windows$Graphics$Printing$IPrintDocumentSource): void
}


/**
 * Used to defer the request for a print task source.
 */
declare class Windows$Graphics$Printing$PrintTaskSourceRequestedDeferral  {

/**
 * Indicates when the deferral for a print task source request is over.
 */
complete(): void
}


/**
 * Provides access to the canonical names for the options represented by the PrintTaskOptions class. You can use the StandardPrintTaskOptions class to identify print options displayed in the user experience or to retrieve specific options using the PrintTaskOptionDetails class.
 */
declare class Windows$Graphics$Printing$StandardPrintTaskOptions  {

/**
 * Gets the canonical name for the binding option of the print task.
 */
static binding: string;

/**
 * Gets the canonical name for collation option of the print task.
 */
static collation: string;

/**
 * Gets the canonical name for color mode option of the print task.
 */
static colorMode: string;

/**
 * Gets the canonical name for the copies option of the print task.
 */
static copies: string;

/**
 * Gets the canonical name for the duplex option of the print task.
 */
static duplex: string;

/**
 * Gets the canonical name for the hole punch option of the print task.
 */
static holePunch: string;

/**
 * Gets the canonical name for the input bin option of the print task.
 */
static inputBin: string;

/**
 * Gets the canonical name for the media size option of the print task.
 */
static mediaSize: string;

/**
 * Gets the canonical name for the media type option of the print task.
 */
static mediaType: string;

/**
 * Gets the canonical name for the NUp option of the print task.
 */
static nup: string;

/**
 * Gets the canonical name for the orientation option of the print task.
 */
static orientation: string;

/**
 * Gets the canonical name for the print quality option of the print task.
 */
static printQuality: string;

/**
 * Gets the canonical name for the staple option of the print task.
 */
static staple: string
}


/**
 * Represents the data that describes a document page.
 */
declare interface Windows$Graphics$Printing$PrintPageDescription {

/**
 * The resolution in dots per inch (DPI) for the X dimension of the page.
 */
dpiX: number,

/**
 * The resolution in dots per inch (DPI) for the Y dimension of the page.
 */
dpiY: number,

/**
 * The Rect within the page size on which content may actually be printed. Content outside of the ImageableRect, whether less or greater than the page size, will be cropped by the print target. The ImageableRect is specified in device independent pixels (DIPs).
 */
imageableRect: Windows$Foundation$Rect,

/**
 * The page size in device independent pixels (DIPs).
 */
pageSize: Windows$Foundation$Size
} 


/**
 * Initialized when a print task is initialized for the print system.
 */
declare interface Windows$Graphics$Printing$IPrintDocumentSource {} 


/**
 * Occurs when a print task requests the document to print. The supplied print document must implement the IPrintDocumentSource interface.
 */
declare type Windows$Graphics$Printing$PrintTaskSourceRequestedHandler = (args: Windows$Graphics$Printing$PrintTaskSourceRequestedArgs) => void;


      declare var npm$namespace$Windows$Graphics$Printing3D: {
        
        
        Print3DTaskCompletion: typeof Windows$Graphics$Printing3D$Print3DTaskCompletion,
Print3DTaskDetail: typeof Windows$Graphics$Printing3D$Print3DTaskDetail,
Printing3DBufferFormat: typeof Windows$Graphics$Printing3D$Printing3DBufferFormat,
Printing3DMeshVerificationMode: typeof Windows$Graphics$Printing3D$Printing3DMeshVerificationMode,
Printing3DModelUnit: typeof Windows$Graphics$Printing3D$Printing3DModelUnit,
Printing3DObjectType: typeof Windows$Graphics$Printing3D$Printing3DObjectType,
Printing3DTextureEdgeBehavior: typeof Windows$Graphics$Printing3D$Printing3DTextureEdgeBehavior,
        Print3DManager: typeof Windows$Graphics$Printing3D$Print3DManager,
Print3DTask: typeof Windows$Graphics$Printing3D$Print3DTask,
Print3DTaskCompletedEventArgs: typeof Windows$Graphics$Printing3D$Print3DTaskCompletedEventArgs,
Print3DTaskRequest: typeof Windows$Graphics$Printing3D$Print3DTaskRequest,
Print3DTaskRequestedEventArgs: typeof Windows$Graphics$Printing3D$Print3DTaskRequestedEventArgs,
Print3DTaskSourceChangedEventArgs: typeof Windows$Graphics$Printing3D$Print3DTaskSourceChangedEventArgs,
Print3DTaskSourceRequestedArgs: typeof Windows$Graphics$Printing3D$Print3DTaskSourceRequestedArgs,
Printing3D3MFPackage: typeof Windows$Graphics$Printing3D$Printing3D3MFPackage,
Printing3DBaseMaterial: typeof Windows$Graphics$Printing3D$Printing3DBaseMaterial,
Printing3DBaseMaterialGroup: typeof Windows$Graphics$Printing3D$Printing3DBaseMaterialGroup,
Printing3DColorMaterial: typeof Windows$Graphics$Printing3D$Printing3DColorMaterial,
Printing3DColorMaterialGroup: typeof Windows$Graphics$Printing3D$Printing3DColorMaterialGroup,
Printing3DComponent: typeof Windows$Graphics$Printing3D$Printing3DComponent,
Printing3DComponentWithMatrix: typeof Windows$Graphics$Printing3D$Printing3DComponentWithMatrix,
Printing3DCompositeMaterial: typeof Windows$Graphics$Printing3D$Printing3DCompositeMaterial,
Printing3DCompositeMaterialGroup: typeof Windows$Graphics$Printing3D$Printing3DCompositeMaterialGroup,
Printing3DMaterial: typeof Windows$Graphics$Printing3D$Printing3DMaterial,
Printing3DMesh: typeof Windows$Graphics$Printing3D$Printing3DMesh,
Printing3DMeshVerificationResult: typeof Windows$Graphics$Printing3D$Printing3DMeshVerificationResult,
Printing3DModel: typeof Windows$Graphics$Printing3D$Printing3DModel,
Printing3DModelTexture: typeof Windows$Graphics$Printing3D$Printing3DModelTexture,
Printing3DMultiplePropertyMaterial: typeof Windows$Graphics$Printing3D$Printing3DMultiplePropertyMaterial,
Printing3DMultiplePropertyMaterialGroup: typeof Windows$Graphics$Printing3D$Printing3DMultiplePropertyMaterialGroup,
Printing3DTexture2CoordMaterial: typeof Windows$Graphics$Printing3D$Printing3DTexture2CoordMaterial,
Printing3DTexture2CoordMaterialGroup: typeof Windows$Graphics$Printing3D$Printing3DTexture2CoordMaterialGroup,
Printing3DTextureResource: typeof Windows$Graphics$Printing3D$Printing3DTextureResource,
        
      }

/**
 * Creates the 3D printing experience.
 */
declare class Windows$Graphics$Printing3D$Print3DManager  {

/**
 * Gets a 3D print manager.
 * @return The 3D print manager.
 */
static getForCurrentView(): Windows$Graphics$Printing3D$Print3DManager;

/**
 * Programmatically initiates the 3D printing user interface.
 * @return true if the operation completes successfully; otherwise, false.
 */
static showPrintUIAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Occurs when a new 3D print job has been created.
 */
ontaskrequested: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing3D$Print3DManager, Windows$Graphics$Printing3D$Print3DTaskRequestedEventArgs>;
addEventListener(
type: "taskrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing3D$Print3DManager, Windows$Graphics$Printing3D$Print3DTaskRequestedEventArgs>): void;
removeEventListener(
type: "taskrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing3D$Print3DManager, Windows$Graphics$Printing3D$Print3DTaskRequestedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a 3D print job.
 */
declare class Windows$Graphics$Printing3D$Print3DTask  {

/**
 * Occurs when the print request has been sent to the 3D printer and the 3D print job has been created.
 */
oncompleted: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing3D$Print3DTask, Windows$Graphics$Printing3D$Print3DTaskCompletedEventArgs>;
addEventListener(
type: "completed",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing3D$Print3DTask, Windows$Graphics$Printing3D$Print3DTaskCompletedEventArgs>): void;
removeEventListener(
type: "completed",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing3D$Print3DTask, Windows$Graphics$Printing3D$Print3DTaskCompletedEventArgs>): void;

/**
 * Occurs when the workflow modifies the 3D print package.
 */
onsourcechanged: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing3D$Print3DTask, Windows$Graphics$Printing3D$Print3DTaskSourceChangedEventArgs>;
addEventListener(
type: "sourcechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing3D$Print3DTask, Windows$Graphics$Printing3D$Print3DTaskSourceChangedEventArgs>): void;
removeEventListener(
type: "sourcechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing3D$Print3DTask, Windows$Graphics$Printing3D$Print3DTaskSourceChangedEventArgs>): void;

/**
 * Occurs when the 3D print package has been submitted to the 3D printer.
 */
onsubmitting: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing3D$Print3DTask, any>;
addEventListener(
type: "submitting",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing3D$Print3DTask, any>): void;
removeEventListener(
type: "submitting",
listener: Windows$Foundation$TypedEventHandler<Windows$Graphics$Printing3D$Print3DTask, any>): void;

/**
 * Gets the 3D print package to be printed.
 */
source: Windows$Graphics$Printing3D$Printing3D3MFPackage;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the Completed event of the 3D print request.
 */
declare class Windows$Graphics$Printing3D$Print3DTaskCompletedEventArgs  {

/**
 * Gets the status of the 3D print request.
 */
completion: $Values<typeof Windows$Graphics$Printing3D$Print3DTaskCompletion>;

/**
 * Gets the type of error encountered during the 3D print request.
 */
extendedStatus: $Values<typeof Windows$Graphics$Printing3D$Print3DTaskDetail>
}


/**
 * Specifies the completion status of a 3D print request.
 */

declare  var Windows$Graphics$Printing3D$Print3DTaskCompletion: {|
  +abandoned: 0,// 0
+canceled: 1,// 1
+failed: 2,// 2
+slicing: 3,// 3
+submitted: 4,// 4

|};



/**
 * Specifies the type of errors encountered during a 3D print request.
 */

declare  var Windows$Graphics$Printing3D$Print3DTaskDetail: {|
  +unknown: 0,// 0
+modelExceedsPrintBed: 1,// 1
+uploadFailed: 2,// 2
+invalidMaterialSelection: 3,// 3
+invalidModel: 4,// 4
+modelNotManifold: 5,// 5
+invalidPrintTicket: 6,// 6

|};



/**
 * Represents a 3D print job request.
 */
declare class Windows$Graphics$Printing3D$Print3DTaskRequest  {

/**
 * Creates a 3D print job.
 * @param title The name of the print job.
 * @param printerId The identifier of the 3D printer.
 * @param handler The callback for the source of the print job request.
 * @return The 3D print job.
 */
createTask(
title: string,
printerId: string,
handler: Windows$Graphics$Printing3D$Print3DTaskSourceRequestedHandler): Windows$Graphics$Printing3D$Print3DTask
}


/**
 * Provides data for the TaskRequested event.
 */
declare class Windows$Graphics$Printing3D$Print3DTaskRequestedEventArgs  {

/**
 * Gets the 3D print job request associated with the Print3DManager .
 */
request: Windows$Graphics$Printing3D$Print3DTaskRequest
}


/**
 * Provides data for the SourceChanged event.
 */
declare class Windows$Graphics$Printing3D$Print3DTaskSourceChangedEventArgs  {

/**
 * Gets the updated 3D print package from the workflow.
 */
source: Windows$Graphics$Printing3D$Printing3D3MFPackage
}


/**
 * Provides data for the Print3DTaskSourceRequestedHandler delegate.
 */
declare class Windows$Graphics$Printing3D$Print3DTaskSourceRequestedArgs  {

/**
 * Specifies the 3D Manufacturing Format (3MF) package to use in the print job.
 * @param source The 3D Manufacturing Format (3MF) package to use in the print job.
 */
setSource(source: Windows$Graphics$Printing3D$Printing3D3MFPackage): void
}


/**
 * Represents a 3D Manufacturing Format (3MF) package.
 */
declare class Windows$Graphics$Printing3D$Printing3D3MFPackage  {

/**
 * Creates a Printing3D3MFPackage object from a 3D Manufacturing Format (3MF) file stream.
 * @param value A 3MF file stream.
 * @return A Printing3D3MFPackage created from the specified 3MF package stream.
 */
static loadAsync(
value: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Printing3D$Printing3D3MFPackage>;

/**
 * Creates a Printing3D3MFPackage object.
 */
constructor(): this;

/**
 * Creates a Printing3DModel object from a 3D Manufacturing Format (3MF) file stream.
 * @param value A 3MF file stream.
 * @return A Printing3DModel object created from the specified 3MF object stream.
 */
loadModelFromPackageAsync(
value: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Printing3D$Printing3DModel>;

/**
 * Gets or sets an XML stream to the 3D model in the 3D Manufacturing Format (3MF) package.
 */
modelPart: Windows$Storage$Streams$IRandomAccessStream;

/**
 * Gets or sets a stream to the print ticket in the 3D Manufacturing Format (3MF) package.
 */
printTicket: Windows$Storage$Streams$IRandomAccessStream;

/**
 * Saves the Printing3D3MFPackage object to a 3D Manufacturing Format (3MF) file stream.
 * @return A stream to the 3MF file where the package is to be saved.
 */
saveAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStream>;

/**
 * Saves the specified 3D model to the 3D Manufacturing Format (3MF) package.
 * @param value The 3D model to be saved to the 3MF package.
 * @return The results of the operation.
 */
saveModelToPackageAsync(
value: Windows$Graphics$Printing3D$Printing3DModel): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets or sets the textures in the 3D Manufacturing Format (3MF) package.
 */
textures: Windows$Foundation$Collections$IVector<Windows$Graphics$Printing3D$Printing3DTextureResource>;

/**
 * Gets or sets a thumbnail image that represents the contents of the 3D Manufacturing Format (3MF) package.
 */
thumbnail: Windows$Graphics$Printing3D$Printing3DTextureResource
}


/**
 * Represents the base material used for manufacturing certain objects in the 3D model.
 */
declare class Windows$Graphics$Printing3D$Printing3DBaseMaterial  {

/**
 * Gets the name the acrylonitrile butadiene styrene (ABS) thermoplastic used in the base material.
 */
static abs: string;

/**
 * Gets the name the polylactic acid (PLA) thermoplastic used in the base material.
 */
static pla: string;

/**
 * Creates an instance of the Printing3DBaseMaterial class.
 */
constructor(): this;

/**
 * Gets or sets the color of the base material.
 */
color: Windows$Graphics$Printing3D$Printing3DColorMaterial;

/**
 * Gets or sets the name of the base material.
 */
name: string
}


/**
 * Represents a group of base materials used in the 3D model.
 */
declare class Windows$Graphics$Printing3D$Printing3DBaseMaterialGroup  {

/**
 * Creates an instance of the Printing3DBaseMaterialGroup class.
 * @param MaterialGroupId The identifier for the group of base materials used in the 3D model; a value greater than zero.
 */
constructor(MaterialGroupId: number): this;

/**
 * Gets a group of base materials used in the 3D model.
 */
bases: Windows$Foundation$Collections$IVector<Windows$Graphics$Printing3D$Printing3DBaseMaterial>;

/**
 * Gets the identifier (ID) of the base material group.
 */
materialGroupId: number
}


/**
 * Specifies the format used by the buffer.
 */

declare  var Windows$Graphics$Printing3D$Printing3DBufferFormat: {|
  +unknown: 0,// 0
+r32G32B32A32Float: 1,// 1
+r32G32B32A32UInt: 2,// 2
+r32G32B32Float: 3,// 3
+r32G32B32UInt: 4,// 4
+printing3DDouble: 5,// 5
+printing3DUInt: 6,// 6

|};



/**
 * Represents a color material used in the 3D model.
 */
declare class Windows$Graphics$Printing3D$Printing3DColorMaterial  {

/**
 * Creates an instance of the Printing3DColorMaterial class.
 */
constructor(): this;

/**
 * Gets or sets the color of the material.
 */
color: Windows$UI$Color;

/**
 * Gets or sets the color value of the material.
 */
value: number
}


/**
 * Represents a group of color materials used in the 3D model.
 */
declare class Windows$Graphics$Printing3D$Printing3DColorMaterialGroup  {

/**
 * Creates an instance of the Printing3DColorMaterialGroup class.
 * @param MaterialGroupId The identifier for the group of color materials used in the 3D model; a value greater than zero.
 */
constructor(MaterialGroupId: number): this;

/**
 * Gets a group of color materials used in the 3D model.
 */
colors: Windows$Foundation$Collections$IVector<Windows$Graphics$Printing3D$Printing3DColorMaterial>;

/**
 * Gets the identifier (ID) for the color material group.
 */
materialGroupId: number
}


/**
 * Represents a 3D Manufacturing Format (3MF) component. Acts as a container of other components.
 */
declare class Windows$Graphics$Printing3D$Printing3DComponent  {

/**
 * Creates an instance of the Printing3DComponent class.
 */
constructor(): this;

/**
 * Gets the other components contained within the component.
 */
components: Windows$Foundation$Collections$IVector<Windows$Graphics$Printing3D$Printing3DComponentWithMatrix>;

/**
 * Gets or sets the 3D mesh of the component.
 */
mesh: Windows$Graphics$Printing3D$Printing3DMesh;

/**
 * Gets or sets the name of the 3D Manufacturing Format (3MF) component.
 */
name: string;

/**
 * Gets or sets the part number of the 3D Manufacturing Format (3MF) component.
 */
partNumber: string;

/**
 * Gets or sets the thumbnail image of the 3D Manufacturing Format (3MF) component.
 */
thumbnail: Windows$Graphics$Printing3D$Printing3DTextureResource;

/**
 * Gets or sets the type of the 3D Manufacturing Format (3MF) component.
 */
type: $Values<typeof Windows$Graphics$Printing3D$Printing3DObjectType>
}


/**
 * Represents a 3D Manufacturing Format (3MF) component that's applied to the object definition with a matrix transform.
 */
declare class Windows$Graphics$Printing3D$Printing3DComponentWithMatrix  {

/**
 * Creates an instance of the Printing3DComponentWithMatrix class.
 */
constructor(): this;

/**
 * Gets or sets the 3D Manufacturing Format (3MF) primitive component that's applied to the object definition with a matrix transform.
 */
component: Windows$Graphics$Printing3D$Printing3DComponent;

/**
 * Gets or sets the matrix transform that's applied to the 3D Manufacturing Format (3MF) primitive component.
 */
matrix: Windows$Foundation$Numerics$Matrix4x4
}


/**
 * Represents a composite material that's defined by a mixture of base materials.
 */
declare class Windows$Graphics$Printing3D$Printing3DCompositeMaterial  {

/**
 * Creates an instance of the Printing3DCompositeMaterial class.
 */
constructor(): this;

/**
 * Gets the mixture of base materials used in the composite material. Each mixture is defined by listing the proportion of the overall mixture for each base material (values between 0 and 1).
 */
values: Windows$Foundation$Collections$IVector<number>
}


/**
 * Represents a group of composite materials.
 */
declare class Windows$Graphics$Printing3D$Printing3DCompositeMaterialGroup  {

/**
 * Creates an instance of the Printing3DCompositeMaterialGroup class.
 * @param MaterialGroupId The identifier (ID) of the composite material group; a value greater than zero.
 */
constructor(MaterialGroupId: number): this;

/**
 * Gets an list of mixtures that define individual composite materials. Each mixture is defined by listing the proportion of the overall mixture for each base material (values between 0 and 1), where the proportion values are specified in the same order as the base materials in MaterialIndices .
 */
composites: Windows$Foundation$Collections$IVector<Windows$Graphics$Printing3D$Printing3DCompositeMaterial>;

/**
 * Gets the identifier (ID) of the base material group that defines the materials used in the composite material group.
 */
materialGroupId: number;

/**
 * Gets an ordered list of base materials that are used to make the composite materials in the group. The order of base materials is maintained in the mixture values defined by Composites .
 */
materialIndices: Windows$Foundation$Collections$IVector<number>
}


/**
 * Represents all material resources in the 3D model.
 */
declare class Windows$Graphics$Printing3D$Printing3DMaterial  {

/**
 * Creates an instance of the Printing3DMaterial class.
 */
constructor(): this;

/**
 * Gets all base material groups used in the 3D model.
 */
baseGroups: Windows$Foundation$Collections$IVector<Windows$Graphics$Printing3D$Printing3DBaseMaterialGroup>;

/**
 * Gets all color material groups used in the 3D model.
 */
colorGroups: Windows$Foundation$Collections$IVector<Windows$Graphics$Printing3D$Printing3DColorMaterialGroup>;

/**
 * Gets all composite material groups used in the 3D model.
 */
compositeGroups: Windows$Foundation$Collections$IVector<Windows$Graphics$Printing3D$Printing3DCompositeMaterialGroup>;

/**
 * Gets all multi-property groups used in the 3D model.
 */
multiplePropertyGroups: Windows$Foundation$Collections$IVector<Windows$Graphics$Printing3D$Printing3DMultiplePropertyMaterialGroup>;

/**
 * Gets all 2D texture material groups used in the 3D model.
 */
texture2CoordGroups: Windows$Foundation$Collections$IVector<Windows$Graphics$Printing3D$Printing3DTexture2CoordMaterialGroup>
}


/**
 * Represents a mesh in the 3D model.
 */
declare class Windows$Graphics$Printing3D$Printing3DMesh  {

/**
 * Creates an instance of the Printing3DMesh class.
 */
constructor(): this;

/**
 * Gets a set of mesh buffer descriptions.
 */
bufferDescriptionSet: Windows$Foundation$Collections$IPropertySet;

/**
 * Gets a set of mesh buffers.
 */
bufferSet: Windows$Foundation$Collections$IPropertySet;

/**
 * Creates the buffer for triangle indices.
 * @param value The capacity of the buffer, the maximum number of bytes that the IBuffer can hold.
 */
createTriangleIndices(value: number): void;

/**
 * Creates the buffer for triangle material indices.
 * @param value The capacity of the buffer, the maximum number of bytes that the IBuffer can hold.
 */
createTriangleMaterialIndices(value: number): void;

/**
 * Creates the buffer for vertex normals.
 * @param value The capacity of the buffer, the maximum number of bytes that the IBuffer can hold.
 */
createVertexNormals(value: number): void;

/**
 * Creates the buffer for vertex positions.
 * @param value The capacity of the buffer, the maximum number of bytes that the IBuffer can hold.
 */
createVertexPositions(value: number): void;

/**
 * Gets the buffer for triangle indices.
 * @return The buffer for triangle indices.
 */
getTriangleIndices(): Windows$Storage$Streams$IBuffer;

/**
 * Gets the buffer for triangle material indices.
 * @return The buffer for triangle material indices.
 */
getTriangleMaterialIndices(): Windows$Storage$Streams$IBuffer;

/**
 * Gets the buffer for vertex normals.
 * @return The buffer for vertex normals.
 */
getVertexNormals(): Windows$Storage$Streams$IBuffer;

/**
 * Gets the buffer for vertex positions.
 * @return The buffer for vertex positions.
 */
getVertexPositions(): Windows$Storage$Streams$IBuffer;

/**
 * Gets or sets the number of triangle indices.
 */
indexCount: number;

/**
 * Gets or sets the buffer description for triangle indices.
 */
triangleIndicesDescription: Windows$Graphics$Printing3D$Printing3DBufferDescription;

/**
 * Gets or sets the buffer description for triangle material indices.
 */
triangleMaterialIndicesDescription: Windows$Graphics$Printing3D$Printing3DBufferDescription;

/**
 * Verifies the mesh has manifold edges and normal triangles.
 * @param value Specifies how the mesh is verified.
 * @return The results of the verification, of type Printing3DMeshVerificationResult .
 */
verifyAsync(
value: $Values<typeof Windows$Graphics$Printing3D$Printing3DMeshVerificationMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Graphics$Printing3D$Printing3DMeshVerificationResult>;

/**
 * Gets or sets the number of triangle vertices.
 */
vertexCount: number;

/**
 * Gets or sets the buffer description for vertex normals.
 */
vertexNormalsDescription: Windows$Graphics$Printing3D$Printing3DBufferDescription;

/**
 * Gets or sets the buffer description for vertex positions.
 */
vertexPositionsDescription: Windows$Graphics$Printing3D$Printing3DBufferDescription
}


/**
 * Specifies how the mesh is verified.
 */

declare  var Windows$Graphics$Printing3D$Printing3DMeshVerificationMode: {|
  +findFirstError: 0,// 0
+findAllErrors: 1,// 1

|};



/**
 * Provides data for the VerifyAsync method.
 */
declare class Windows$Graphics$Printing3D$Printing3DMeshVerificationResult  {

/**
 * Gets a value that indicates if the mesh is valid.
 */
isValid: boolean;

/**
 * Gets the triangles with non-manifold edges, if applicable.
 */
nonmanifoldTriangles: Windows$Foundation$Collections$IVectorView<number>;

/**
 * Gets the reverse normal triangles, if applicable.
 */
reversedNormalTriangles: Windows$Foundation$Collections$IVectorView<number>
}


/**
 * Represents the 3D model in a 3D Manufacturing Format (3MF) package.
 */
declare class Windows$Graphics$Printing3D$Printing3DModel  {

/**
 * Creates an instance of the Printing3DModel class.
 */
constructor(): this;

/**
 * Gets or sets the root 3D Manufacturing Format (3MF) component. It represents the build plate on a 3D printer and defines what will be printed.
 */
build: Windows$Graphics$Printing3D$Printing3DComponent;

/**
 * Gets a copy of the current 3D model.
 * @return A copy of the current 3D model.
 */
clone(): Windows$Graphics$Printing3D$Printing3DModel;

/**
 * Gets all 3D Manufacturing Format (3MF) components used in the 3D model.
 */
components: Windows$Foundation$Collections$IVector<Windows$Graphics$Printing3D$Printing3DComponent>;

/**
 * Gets or sets the root material container for the 3D model.
 */
material: Windows$Graphics$Printing3D$Printing3DMaterial;

/**
 * Gets all meshes used in the 3D model.
 */
meshes: Windows$Foundation$Collections$IVector<Windows$Graphics$Printing3D$Printing3DMesh>;

/**
 * Gets the metadata for the 3D Manufacturing Format (3MF) package.
 */
metadata: Windows$Foundation$Collections$IMap<string, string>;

/**
 * Repairs the 3D model.
 * @return Results of the operation.
 */
repairAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets a list of the extensions required by the 3D Manufacturing Format (3MF) package.
 */
requiredExtensions: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets all textures used in the 3D model.
 */
textures: Windows$Foundation$Collections$IVector<Windows$Graphics$Printing3D$Printing3DModelTexture>;

/**
 * Gets or sets the units of measure used in the 3D model.
 */
unit: $Values<typeof Windows$Graphics$Printing3D$Printing3DModelUnit>;

/**
 * Gets or sets the version of the 3D Manufacturing Format (3MF) package.
 */
version: string
}


/**
 * Represents a texture used in the 3D model.
 */
declare class Windows$Graphics$Printing3D$Printing3DModelTexture  {

/**
 * Creates an instance of the Printing3DModelTexture class.
 */
constructor(): this;

/**
 * Gets or sets the texture resource used by the texture.
 */
textureResource: Windows$Graphics$Printing3D$Printing3DTextureResource;

/**
 * Get or sets a value that indicates how tiling should occur in the U axis in order to fill the overall requested area.
 */
tileStyleU: $Values<typeof Windows$Graphics$Printing3D$Printing3DTextureEdgeBehavior>;

/**
 * Gets or sets a value that indicates how tiling should occur in the V axis in order to fill the overall requested area.
 */
tileStyleV: $Values<typeof Windows$Graphics$Printing3D$Printing3DTextureEdgeBehavior>
}


/**
 * Specifies the units of measure used in the 3D model.
 */

declare  var Windows$Graphics$Printing3D$Printing3DModelUnit: {|
  +meter: 0,// 0
+micron: 1,// 1
+millimeter: 2,// 2
+centimeter: 3,// 3
+inch: 4,// 4
+foot: 5,// 5

|};



/**
 * Represents a combination of properties and/or materials from the material groups specified in ( MaterialGroupIndices ).
 */
declare class Windows$Graphics$Printing3D$Printing3DMultiplePropertyMaterial  {

/**
 * Creates an instance of the Printing3DMultiplePropertyMaterial class.
 */
constructor(): this;

/**
 * Gets the indices of the properties and/or materials combined in the multi-property material. Each combination is defined by listing the index of an item from one material group with the index of an item from a secondary material group. The index values are specified in the same order as the material groups listed in MaterialGroupIndices .
 */
materialIndices: Windows$Foundation$Collections$IVector<number>
}


/**
 * Represents a multi-property material group.
 */
declare class Windows$Graphics$Printing3D$Printing3DMultiplePropertyMaterialGroup  {

/**
 * Creates a new instance of the Printing3DMultiplePropertyMaterialGroup class.
 * @param MaterialGroupId The identifier (ID) of the multi-property material group; a value greater than zero.
 */
constructor(MaterialGroupId: number): this;

/**
 * Gets the identifier (ID) of the multi-property material group.
 */
materialGroupId: number;

/**
 * Gets an ordered list of material groups ( MaterialGroupId values) that are used to define property-material combinations in the multi-property group. The order of material groups is maintained in the combinations defined by MultipleProperties .
 */
materialGroupIndices: Windows$Foundation$Collections$IVector<number>;

/**
 * Gets a list of property-material combinations. Each combination is defined by listing the index of an item from one material group with the index of an item from a secondary material group. The index values are specified in the same order as the material groups listed in MaterialGroupIndices .
 */
multipleProperties: Windows$Foundation$Collections$IVector<Windows$Graphics$Printing3D$Printing3DMultiplePropertyMaterial>
}


/**
 * Specifies the function of the object in the 3D model.
 */

declare  var Windows$Graphics$Printing3D$Printing3DObjectType: {|
  +model: 0,// 0
+support: 1,// 1
+others: 2,// 2

|};



/**
 * Represents a 2D texture material used in the 3D model.
 */
declare class Windows$Graphics$Printing3D$Printing3DTexture2CoordMaterial  {

/**
 * Creates an instance of the Printing3DTexture2CoordMaterial class.
 */
constructor(): this;

/**
 * Gets or sets the texture used in the 2D texture material.
 */
texture: Windows$Graphics$Printing3D$Printing3DModelTexture;

/**
 * Gets or sets the U-coordinate within the texture, horizontally right from the origin in the upper left of the texture.
 */
u: number;

/**
 * Gets or sets the V-coordinate within the texture, vertically down from the origin in the upper left of the texture.
 */
v: number
}


/**
 * Represents a group of 2D texture materials used in the 3D model.
 */
declare class Windows$Graphics$Printing3D$Printing3DTexture2CoordMaterialGroup  {

/**
 * Creates a instance of the Printing3DTexture2CoordMaterialGroup class.
 * @param MaterialGroupId The identifier for a group of 2D texture materials used in the 3D model; a value greater than zero.
 */
constructor(MaterialGroupId: number): this;

/**
 * Gets the identifier (ID) of the 2D texture material group.
 */
materialGroupId: number;

/**
 * Gets or sets the texture of the material group.
 */
texture: Windows$Graphics$Printing3D$Printing3DModelTexture;

/**
 * Gets a group of 2D texture materials used in the 3D model.
 */
texture2Coords: Windows$Foundation$Collections$IVector<Windows$Graphics$Printing3D$Printing3DTexture2CoordMaterial>
}


/**
 * Specifies how tiling should occur in the U and V axis in order to fill the overall requested area of a texture.
 */

declare  var Windows$Graphics$Printing3D$Printing3DTextureEdgeBehavior: {|
  +none: 0,// 0
+wrap: 1,// 1
+mirror: 2,// 2
+clamp: 3,// 3

|};



/**
 * Specifies the texture resource used in a 2D texture material.
 */
declare class Windows$Graphics$Printing3D$Printing3DTextureResource  {

/**
 * Creates an instance of the Printing3DTextureResource class.
 */
constructor(): this;

/**
 * Gets or sets the name of the texture resource.
 */
name: string;

/**
 * Gets or sets the image stream of the texture resource.
 */
textureData: Windows$Storage$Streams$IRandomAccessStreamWithContentType
}


/**
 * Represents the method that handles requests for 3D print packages.
 */
declare type Windows$Graphics$Printing3D$Print3DTaskSourceRequestedHandler = (args: Windows$Graphics$Printing3D$Print3DTaskSourceRequestedArgs) => void;


/**
 * Specifies how to parse data in the buffer.
 */
declare interface Windows$Graphics$Printing3D$Printing3DBufferDescription {

/**
 * Specifies the format used by the buffer.
 */
format: $Values<typeof Windows$Graphics$Printing3D$Printing3DBufferFormat>,

/**
 * Specifies how far to move the pointer forward to find the next unit of data.
 */
stride: number
} 


      declare var npm$namespace$Windows$Management: {
        
        
        
        
        Core: typeof npm$namespace$Windows$Management$Core,
Deployment: typeof npm$namespace$Windows$Management$Deployment,
Orchestration: typeof npm$namespace$Windows$Management$Orchestration,
Workplace: typeof npm$namespace$Windows$Management$Workplace,
      }

      declare var npm$namespace$Windows$Management$Core: {
        
        
        
        ApplicationDataManager: typeof Windows$Management$Core$ApplicationDataManager,
        
      }

/**
 * Enables you to access and manage the app data store for a package family.
 */
declare class Windows$Management$Core$ApplicationDataManager  {

/**
 * Provides access to the app data store for the specified package family.
 * @param packageFamilyName The package family name.
 * @return The app data store.
 */
static createForPackageFamily(packageFamilyName: string): Windows$Storage$ApplicationData
}


      declare var npm$namespace$Windows$Management$Deployment: {
        
        
        DeploymentOptions: typeof Windows$Management$Deployment$DeploymentOptions,
DeploymentProgressState: typeof Windows$Management$Deployment$DeploymentProgressState,
PackageInstallState: typeof Windows$Management$Deployment$PackageInstallState,
PackageState: typeof Windows$Management$Deployment$PackageState,
PackageStatus: typeof Windows$Management$Deployment$PackageStatus,
PackageTypes: typeof Windows$Management$Deployment$PackageTypes,
RemovalOptions: typeof Windows$Management$Deployment$RemovalOptions,
        DeploymentResult: typeof Windows$Management$Deployment$DeploymentResult,
PackageUserInformation: typeof Windows$Management$Deployment$PackageUserInformation,
PackageVolume: typeof Windows$Management$Deployment$PackageVolume,
        Preview: typeof npm$namespace$Windows$Management$Deployment$Preview,
      }

/**
 * Specifies the package deployment options.
 */

declare  var Windows$Management$Deployment$DeploymentOptions: {|
  +none: 0,// 0
+forceApplicationShutdown: 1,// 1
+developmentMode: 2,// 2
+installAllResources: 3,// 3
+forceTargetApplicationShutdown: 4,// 4

|};



/**
 * Represents the state of a deployment request.
 */

declare  var Windows$Management$Deployment$DeploymentProgressState: {|
  +queued: 0,// 0
+processing: 1,// 1

|};



/**
 * Provides the result of a deployment request.
 */
declare class Windows$Management$Deployment$DeploymentResult  {

/**
 * Gets the activity identifier used to look up an event in Windows Event Viewer. Gets the activity identifier used to look up an event. All events of a deployment operation are logged with the same activityId.
 */
activityId: string;

/**
 * Gets extended error text for the error if the deployment operation is not successful.
 */
errorText: string;

/**
 * The extended error code can be used to distinguish a specific error condition which needs to be handled differently from the general error indicated by the return code. The extended error code may provide a more specific reason for the failure that caused the general error. Also, it usually corresponds directly to the specific message in the ErrorText .
 */
extendedErrorCode: Windows$WinRTError
}


/**
 * Represents the install state of the package.
 */

declare  var Windows$Management$Deployment$PackageInstallState: {|
  +notInstalled: 0,// 0
+staged: 1,// 1
+installed: 2,// 2
+paused: 3,// 3

|};



/**
 * Represents the state of the package.
 */

declare  var Windows$Management$Deployment$PackageState: {|
  +normal: 0,// 0
+licenseInvalid: 1,// 1
+modified: 2,// 2
+tampered: 3,// 3

|};



/**
 * Provides info about the status of a package.
 */

declare  var Windows$Management$Deployment$PackageStatus: {|
  +ok: 0,// 0
+licenseIssue: 1,// 1
+modified: 2,// 2
+tampered: 3,// 3
+disabled: 4,// 4

|};



/**
 * Defines the types of packages to be included in the result set of a query.
 */

declare  var Windows$Management$Deployment$PackageTypes: {|
  +none: 0,// 0
+main: 1,// 1
+framework: 2,// 2
+resource: 3,// 3
+bundle: 4,// 4
+xap: 5,// 5

|};



/**
 * Provides information about the users of an installed package.
 */
declare class Windows$Management$Deployment$PackageUserInformation  {

/**
 * Gets the install state of the package for the user.
 */
installState: $Values<typeof Windows$Management$Deployment$PackageInstallState>;

/**
 * Gets the security identifier (SID) of the package user.
 */
userSecurityId: string
}


/**
 * Represents a package storage volume.
 */
declare class Windows$Management$Deployment$PackageVolume  {

/**
 * Initializes a new instance of the PackageVolume class.
 */
constructor(): this;

/**
 * Gets a collection of info about all installed instances of the specified package for all registered users.
 * @param packageFullName The full name of the package.
 * @return A collection of info about all installed instances of the specified package for all registered users.
 */
findPackage(
packageFullName: string): Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Package>;

/**
 * Gets a collection of info about the installed instances of the specified package for the specified user or users.
 * @param userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
 * @param packageFullName The full name of the package.
 * @return A collection of info about all installed instances of the specified package for the specified user or users.
 */
findPackageForUser(
userSecurityId: string,
packageFullName: string): Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Package>;

/**
 * Gets a collection of info about all installed instances of all packages for all registered users.
 * @return A collection of info about the specified packages.
 */
findPackages(): Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Package>;

/**
 * Gets a collection of info about all installed instances of the specified package from the specified publisher for all registered users.
 * @param packageName The full name of the package.
 * @param packagePublisher The publisher of the package.
 * @return A collection of info about the specified packages.
 */
findPackages(
packageName: string,
packagePublisher: string): Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Package>;

/**
 * Gets a collection of info about all installed instances of the specified package for all registered users.
 * @param packageFamilyName The package family name of the package.
 * @return A collection of info about the specified packages.
 */
findPackages(
packageFamilyName: string): Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Package>;

/**
 * Gets a collection of info about all installed instances of the specified package for the specified user or users.
 * @param userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
 * @param packageFamilyName The package family name.
 * @return A collection of info about the specified packages.
 */
findPackagesForUser(
userSecurityId: string,
packageFamilyName: string): Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Package>;

/**
 * Gets a collection of info about all installed instances of the specified package from the specified publisher for the specified user or users.
 * @param userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
 * @param packageName The full name of the package.
 * @param packagePublisher The publisher of the package.
 * @return A collection of info about the specified packages.
 */
findPackagesForUser(
userSecurityId: string,
packageName: string,
packagePublisher: string): Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Package>;

/**
 * Gets a collection of info about all installed instances of all packages for the specified user or users.
 * @param userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
 * @return A collection of info about the specified packages.
 */
findPackagesForUser(
userSecurityId: string): Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Package>;

/**
 * Gets a collection of info about all installed instances of all packages for the specified user or users and with the specified package types.
 * @param userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
 * @param packageTypes A bitwise combination of the enumeration values that specifies the types of packages to return.
 * @return A collection of info about the specified packages.
 */
findPackagesForUserWithPackageTypes(
userSecurityId: string,
packageTypes: $Values<typeof Windows$Management$Deployment$PackageTypes>): Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Package>;

/**
 * Gets a collection of info about all installed instances of the specified package for the specified user or users and with the specified package types.
 * @param userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
 * @param packageTypes A bitwise combination of the enumeration values that specifies the types of packages to return.
 * @param packageName The full name of the package.
 * @param packagePublisher The publisher of the package.
 * @return A collection of info about the specified packages.
 */
findPackagesForUserWithPackageTypes(
userSecurityId: string,
packageTypes: $Values<typeof Windows$Management$Deployment$PackageTypes>,
packageName: string,
packagePublisher: string): Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Package>;

/**
 * Gets a collection of info about all installed instances of the specified package for the specified user or users and with the specified package types.
 * @param userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
 * @param packageTypes A bitwise combination of the enumeration values that specifies the types of packages to return.
 * @param packageFamilyName The package family name.
 * @return A collection of info about the specified packages.
 */
findPackagesForUserWithPackageTypes(
userSecurityId: string,
packageTypes: $Values<typeof Windows$Management$Deployment$PackageTypes>,
packageFamilyName: string): Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Package>;

/**
 * Gets a collection of info about all installed instances of the specified package with the specified package types for all registered users.
 * @param packageTypes A bitwise combination of the enumeration values that specifies the types of packages to return.
 * @param packageFamilyName The package family name.
 * @return A collection of info about the specified packages.
 */
findPackagesWithPackageTypes(
packageTypes: $Values<typeof Windows$Management$Deployment$PackageTypes>,
packageFamilyName: string): Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Package>;

/**
 * Gets a collection of info about all installed instances of all packages with the specified package types for all registered users.
 * @param packageTypes A bitwise combination of the enumeration values that specifies the types of packages to return.
 * @return A collection of info about the specified packages.
 */
findPackagesWithPackageTypes(
packageTypes: $Values<typeof Windows$Management$Deployment$PackageTypes>): Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Package>;

/**
 * Gets a collection of info about all installed instances of the specified package from the specified publisher with the specified package types for all registered users.
 * @param packageTypes A bitwise combination of the enumeration values that specifies the types of packages to return.
 * @param packageName The full name of the package.
 * @param packagePublisher The publisher of the package.
 * @return A collection of info about the specified packages.
 */
findPackagesWithPackageTypes(
packageTypes: $Values<typeof Windows$Management$Deployment$PackageTypes>,
packageName: string,
packagePublisher: string): Windows$Foundation$Collections$IVector<Windows$ApplicationModel$Package>;

/**
 * Describes whether a volume is in an offline state.
 */
isOffline: boolean;

/**
 * Describes whether a volume is an internal system volume mapped to the %SYSTEMDRIVER% environment variable.
 */
isSystemVolume: boolean;

/**
 * Gets the path of the last known volume mount point.
 */
mountPoint: string;

/**
 * Gets the media ID of the volume.
 */
name: string;

/**
 * Gets the absolute path for the package store on the volume.
 */
packageStorePath: string;

/**
 * Gets a value that specifies whether the volume supports the creation of hard links in its file system.
 */
supportsHardLinks: boolean
}


      declare var npm$namespace$Windows$Management$Deployment$Preview: {
        
        
        
        ClassicAppManager: typeof Windows$Management$Deployment$Preview$ClassicAppManager,
InstalledClassicAppInfo: typeof Windows$Management$Deployment$Preview$InstalledClassicAppInfo,
        
      }
declare class Windows$Management$Deployment$Preview$ClassicAppManager  {
static findInstalledApp: any
}

declare class Windows$Management$Deployment$Preview$InstalledClassicAppInfo  {
displayName: any;
displayVersion: any
}


/**
 * Values that modify the removal of a package.
 */

declare  var Windows$Management$Deployment$RemovalOptions: {|
  +none: 0,// 0
+preserveApplicationData: 1,// 1

|};



      declare var npm$namespace$Windows$Management$Orchestration: {
        
        
        
        CurrentAppOrchestration: typeof Windows$Management$Orchestration$CurrentAppOrchestration,
SingleAppModeContext: typeof Windows$Management$Orchestration$SingleAppModeContext,
        
      }
declare class Windows$Management$Orchestration$CurrentAppOrchestration  {
static getForCurrentView: any;
startSingleAppMode: any
}

declare class Windows$Management$Orchestration$SingleAppModeContext  {
close: any
}


      declare var npm$namespace$Windows$Management$Workplace: {
        
        
        
        MdmPolicy: typeof Windows$Management$Workplace$MdmPolicy,
WorkplaceSettings: typeof Windows$Management$Workplace$WorkplaceSettings,
        
      }

/**
 * MDM (Mobile Device Management) policy.
 */
declare class Windows$Management$Workplace$MdmPolicy  {

/**
 * Returns true if a browser is allowed.
 * @return true if a browser is allowed.
 */
static isBrowserAllowed(): boolean;

/**
 * Returns true if a camera is allowed.
 * @return true if a camera is allowed.
 */
static isCameraAllowed(): boolean;

/**
 * Returns true if a Microsoft Account is allowed.
 * @return true if a Microsoft Account is allowed.
 */
static isMicrosoftAccountAllowed(): boolean;

/**
 * Returns true if a Store is allowed.
 * @return true if a Store is allowed.
 */
static isStoreAllowed(): boolean
}


/**
 * Enables Windows Store apps to access select enterprise settings that are managed through group policy or other management services.
 */
declare class Windows$Management$Workplace$WorkplaceSettings  {

/**
 * Gets a value that indicates whether an enterprise ID can be used instead of a Microsoft account.
 */
static isMicrosoftAccountOptional: boolean
}


      declare var npm$namespace$Windows$Perception: {
        
        
        
        PerceptionTimestamp: typeof Windows$Perception$PerceptionTimestamp,
PerceptionTimestampHelper: typeof Windows$Perception$PerceptionTimestampHelper,
        People: typeof npm$namespace$Windows$Perception$People,
Spatial: typeof npm$namespace$Windows$Perception$Spatial,
      }

      declare var npm$namespace$Windows$Perception$People: {
        
        
        
        HeadPose: typeof Windows$Perception$People$HeadPose,
        
      }
declare class Windows$Perception$People$HeadPose  {
forwardDirection: any;
position: any;
upDirection: any
}

declare class Windows$Perception$PerceptionTimestamp  {
predictionAmount: any;
targetTime: any
}

declare class Windows$Perception$PerceptionTimestampHelper  {
static fromHistoricalTargetTime: any
}


      declare var npm$namespace$Windows$Perception$Spatial: {
        
        
        
        SpatialAnchor: typeof Windows$Perception$Spatial$SpatialAnchor,
SpatialAnchorManager: typeof Windows$Perception$Spatial$SpatialAnchorManager,
SpatialAnchorRawCoordinateSystemAdjustedEventArgs: typeof Windows$Perception$Spatial$SpatialAnchorRawCoordinateSystemAdjustedEventArgs,
SpatialAnchorStore: typeof Windows$Perception$Spatial$SpatialAnchorStore,
SpatialAnchorTransferManager: typeof Windows$Perception$Spatial$SpatialAnchorTransferManager,
SpatialBoundingVolume: typeof Windows$Perception$Spatial$SpatialBoundingVolume,
SpatialCoordinateSystem: typeof Windows$Perception$Spatial$SpatialCoordinateSystem,
SpatialLocation: typeof Windows$Perception$Spatial$SpatialLocation,
SpatialLocator: typeof Windows$Perception$Spatial$SpatialLocator,
SpatialLocatorAttachedFrameOfReference: typeof Windows$Perception$Spatial$SpatialLocatorAttachedFrameOfReference,
SpatialLocatorPositionalTrackingDeactivatingEventArgs: typeof Windows$Perception$Spatial$SpatialLocatorPositionalTrackingDeactivatingEventArgs,
SpatialStationaryFrameOfReference: typeof Windows$Perception$Spatial$SpatialStationaryFrameOfReference,
        SpatialLocatability: typeof npm$namespace$Windows$Perception$Spatial$SpatialLocatability,
SpatialPerceptionAccessStatus: typeof npm$namespace$Windows$Perception$Spatial$SpatialPerceptionAccessStatus,
Surfaces: typeof npm$namespace$Windows$Perception$Spatial$Surfaces,
      }
declare class Windows$Perception$Spatial$SpatialAnchor  {
static tryCreateRelativeTo: any;
addEventListener: any;
coordinateSystem: any;
onrawcoordinatesystemadjusted: any;
rawCoordinateSystem: any;
removeEventListener: any
}

declare class Windows$Perception$Spatial$SpatialAnchorManager  {
static requestStoreAsync: any
}

declare class Windows$Perception$Spatial$SpatialAnchorRawCoordinateSystemAdjustedEventArgs  {
oldRawCoordinateSystemToNewRawCoordinateSystemTransform: any
}

declare class Windows$Perception$Spatial$SpatialAnchorStore  {
clear: any;
getAllSavedAnchors: any;
remove: any;
trySave: any
}

declare class Windows$Perception$Spatial$SpatialAnchorTransferManager  {
static requestAccessAsync: any;
static tryExportAnchorsAsync: any;
static tryImportAnchorsAsync: any
}

declare class Windows$Perception$Spatial$SpatialBoundingVolume  {
static fromBox: any;
static fromFrustum: any;
static fromOrientedBox: any;
static fromSphere: any
}

declare class Windows$Perception$Spatial$SpatialCoordinateSystem  {
tryGetTransformTo: any
}


      declare var npm$namespace$Windows$Perception$Spatial$SpatialLocatability: {
        
        unavailable: typeof Windows$Perception$Spatial$SpatialLocatability$unavailable,
orientationOnly: typeof Windows$Perception$Spatial$SpatialLocatability$orientationOnly,
positionalTrackingActivating: typeof Windows$Perception$Spatial$SpatialLocatability$positionalTrackingActivating,
positionalTrackingActive: typeof Windows$Perception$Spatial$SpatialLocatability$positionalTrackingActive,
positionalTrackingInhibited: typeof Windows$Perception$Spatial$SpatialLocatability$positionalTrackingInhibited,
        
        
        
      }
declare var Windows$Perception$Spatial$SpatialLocatability$unavailable: any;

declare var Windows$Perception$Spatial$SpatialLocatability$orientationOnly: any;

declare var Windows$Perception$Spatial$SpatialLocatability$positionalTrackingActivating: any;

declare var Windows$Perception$Spatial$SpatialLocatability$positionalTrackingActive: any;

declare var Windows$Perception$Spatial$SpatialLocatability$positionalTrackingInhibited: any;

declare class Windows$Perception$Spatial$SpatialLocation  {
absoluteAngularAcceleration: any;
absoluteAngularVelocity: any;
absoluteLinearAcceleration: any;
absoluteLinearVelocity: any;
orientation: any;
position: any
}

declare class Windows$Perception$Spatial$SpatialLocator  {
static getDefault: any;
addEventListener: any;
createAttachedFrameOfReferenceAtCurrentHeading: any;
createStationaryFrameOfReferenceAtCurrentLocation: any;
locatability: any;
onlocatabilitychanged: any;
onpositionaltrackingdeactivating: any;
removeEventListener: any;
tryLocateAtTimestamp: any
}

declare class Windows$Perception$Spatial$SpatialLocatorAttachedFrameOfReference  {
adjustHeading: any;
getStationaryCoordinateSystemAtTimestamp: any;
relativeOrientation: any;
relativePosition: any;
tryGetRelativeHeadingAtTimestamp: any
}

declare class Windows$Perception$Spatial$SpatialLocatorPositionalTrackingDeactivatingEventArgs  {
canceled: any
}


      declare var npm$namespace$Windows$Perception$Spatial$SpatialPerceptionAccessStatus: {
        
        unspecified: typeof Windows$Perception$Spatial$SpatialPerceptionAccessStatus$unspecified,
allowed: typeof Windows$Perception$Spatial$SpatialPerceptionAccessStatus$allowed,
deniedByUser: typeof Windows$Perception$Spatial$SpatialPerceptionAccessStatus$deniedByUser,
deniedBySystem: typeof Windows$Perception$Spatial$SpatialPerceptionAccessStatus$deniedBySystem,
        
        
        
      }
declare var Windows$Perception$Spatial$SpatialPerceptionAccessStatus$unspecified: any;

declare var Windows$Perception$Spatial$SpatialPerceptionAccessStatus$allowed: any;

declare var Windows$Perception$Spatial$SpatialPerceptionAccessStatus$deniedByUser: any;

declare var Windows$Perception$Spatial$SpatialPerceptionAccessStatus$deniedBySystem: any;

declare class Windows$Perception$Spatial$SpatialStationaryFrameOfReference  {
coordinateSystem: any
}


      declare var npm$namespace$Windows$Perception$Spatial$Surfaces: {
        
        
        
        SpatialSurfaceInfo: typeof Windows$Perception$Spatial$Surfaces$SpatialSurfaceInfo,
SpatialSurfaceMesh: typeof Windows$Perception$Spatial$Surfaces$SpatialSurfaceMesh,
SpatialSurfaceMeshBuffer: typeof Windows$Perception$Spatial$Surfaces$SpatialSurfaceMeshBuffer,
SpatialSurfaceMeshOptions: typeof Windows$Perception$Spatial$Surfaces$SpatialSurfaceMeshOptions,
SpatialSurfaceObserver: typeof Windows$Perception$Spatial$Surfaces$SpatialSurfaceObserver,
        
      }
declare class Windows$Perception$Spatial$Surfaces$SpatialSurfaceInfo  {
id: any;
tryComputeLatestMeshAsync: any;
tryGetBounds: any;
updateTime: any
}

declare class Windows$Perception$Spatial$Surfaces$SpatialSurfaceMesh  {
coordinateSystem: any;
surfaceInfo: any;
triangleIndices: any;
vertexNormals: any;
vertexPositionScale: any;
vertexPositions: any
}

declare class Windows$Perception$Spatial$Surfaces$SpatialSurfaceMeshBuffer  {
data: any;
elementCount: any;
format: any;
stride: any
}

declare class Windows$Perception$Spatial$Surfaces$SpatialSurfaceMeshOptions  {
static supportedTriangleIndexFormats: any;
static supportedVertexNormalFormats: any;
static supportedVertexPositionFormats: any;
includeVertexNormals: any;
triangleIndexFormat: any;
vertexNormalFormat: any;
vertexPositionFormat: any
}

declare class Windows$Perception$Spatial$Surfaces$SpatialSurfaceObserver  {
static requestAccessAsync: any;
addEventListener: any;
getObservedSurfaces: any;
onobservedsurfaceschanged: any;
removeEventListener: any;
setBoundingVolume: any;
setBoundingVolumes: any
}


      declare var npm$namespace$Windows$Security: {
        
        
        
        
        Authentication: typeof npm$namespace$Windows$Security$Authentication,
Credentials: typeof npm$namespace$Windows$Security$Credentials,
Cryptography: typeof npm$namespace$Windows$Security$Cryptography,
EnterpriseData: typeof npm$namespace$Windows$Security$EnterpriseData,
ExchangeActiveSyncProvisioning: typeof npm$namespace$Windows$Security$ExchangeActiveSyncProvisioning,
      }

      declare var npm$namespace$Windows$Security$Authentication: {
        
        
        
        
        OnlineId: typeof npm$namespace$Windows$Security$Authentication$OnlineId,
Web: typeof npm$namespace$Windows$Security$Authentication$Web,
      }

      declare var npm$namespace$Windows$Security$Authentication$OnlineId: {
        
        
        CredentialPromptType: typeof Windows$Security$Authentication$OnlineId$CredentialPromptType,
        OnlineIdAuthenticator: typeof Windows$Security$Authentication$OnlineId$OnlineIdAuthenticator,
OnlineIdServiceTicket: typeof Windows$Security$Authentication$OnlineId$OnlineIdServiceTicket,
OnlineIdServiceTicketRequest: typeof Windows$Security$Authentication$OnlineId$OnlineIdServiceTicketRequest,
SignOutUserOperation: typeof Windows$Security$Authentication$OnlineId$SignOutUserOperation,
UserAuthenticationOperation: typeof Windows$Security$Authentication$OnlineId$UserAuthenticationOperation,
UserIdentity: typeof Windows$Security$Authentication$OnlineId$UserIdentity,
        
      }

/**
 * Provides the ability to control when to show or hide the credential prompt user interface. This includes the user interface for the app to collect user consent to access data stored in Live. The user must see the user interface in order for the app to obtain any user data, if not app will see an error when they try to obtain user data.
 */

declare  var Windows$Security$Authentication$OnlineId$CredentialPromptType: {|
  +promptIfNeeded: 0,// 0
+retypeCredentials: 1,// 1
+doNotPrompt: 2,// 2

|};



/**
 * Provides an app with the ability to start the authentication request to get JavaScript Object Notation (JSON) tokens to use with your service or request tickets that can be used to get data that the user has consented to for your app using the Live Connect APIs.
 */
declare class Windows$Security$Authentication$OnlineId$OnlineIdAuthenticator  {

/**
 * Creates an instance of the OnlineIdAuthenticator .
 */
constructor(): this;

/**
 * Returns the ID of the application as a GUID.
 */
applicationId: string;

/**
 * Starts the async authentication request with one OnlineIdServiceTicketRequest . If a user is signed into a Windows 8 system with a Microsoft account, this user will be used for the authentication request.
 * @param request A request object that provides the ability for an app to specify the service and policy used to authenticate a Live user to obtain identity properties and tickets.
 * @return An object representing the authentication operation.
 */
authenticateUserAsync(
request: Windows$Security$Authentication$OnlineId$OnlineIdServiceTicketRequest): Windows$Foundation$IPromiseWithOperation<any, Windows$Security$Authentication$OnlineId$UserAuthenticationOperation>;

/**
 * Starts the async authentication request with multiple OnlineIdServiceTicketRequests and provides the ability to control the user experience by setting the CredentialPromptType to get the tickets. If a user is signed into a Windows 8 system with a Microsoft account, this user will be used for the authentication request.
 * @param requests A collection of requests.
 * @param credentialPromptType The type of credentials.
 * @return An object representing the authentication operation.
 */
authenticateUserAsync(
requests: Windows$Foundation$Collections$IIterable<Windows$Security$Authentication$OnlineId$OnlineIdServiceTicketRequest>,
credentialPromptType: $Values<typeof Windows$Security$Authentication$OnlineId$CredentialPromptType>): Windows$Foundation$IPromiseWithOperation<any, Windows$Security$Authentication$OnlineId$UserAuthenticationOperation>;

/**
 * Returns the ID of a user who has been successfully authenticated for your app.
 */
authenticatedSafeCustomerId: string;

/**
 * Indicates whether a user can sign out of the app, and whether to show the sign out link in the app.
 */
canSignOut: boolean;

/**
 * Allows users to sign out of your app.
 * @return An object that contains additional information about the why the user signed out.
 */
signOutUserAsync(
): Windows$Foundation$IPromiseWithOperation<any, Windows$Security$Authentication$OnlineId$SignOutUserOperation>
}


/**
 * Contains the ticket that is obtained after the user authenticates to this app or has provided consent to access user data stored in Live.
 */
declare class Windows$Security$Authentication$OnlineId$OnlineIdServiceTicket  {

/**
 * If there was an error in obtaining the ticket, then the error code is captured here.
 */
errorCode: number;

/**
 * Represents the OnlineIdServiceTicketRequest for which the ticket was obtained.
 */
request: Windows$Security$Authentication$OnlineId$OnlineIdServiceTicketRequest;

/**
 * The ticket.
 */
value: string
}


/**
 * Provides the ability for an app to specify the service and policy that is used to authenticate a Live user to obtain identity properties and tickets.
 */
declare class Windows$Security$Authentication$OnlineId$OnlineIdServiceTicketRequest  {

/**
 * Creates an instance of the OnlineIdServiceTicketRequest class.
 * @param service The service for the request.
 * @param policy The policy for the request.
 */
constructor(service: string, policy: string): this;

/**
 * Creates an instance of the OnlineIdServiceTicketRequest class.
 * @param service The service for the request.
 */
constructor(service: string): this;

/**
 * The policy used to authenticate users. Supported values are JWT, which returns data using the JSON format. For apps that are requesting user consent to access stored in Live, app developer must pass a policy of DELEGATION.
 */
policy: string;

/**
 * Identifies the service your app uses. The service name must match the DNS name you supplied when registering your app on http://go.microsoft.com/fwlink/p/?linkid=241860. Tickets are issued only for this service. For apps that are requesting user consent to access stored in Live, you must pass the offers to which your app needs access. The available list of offers can be found at our Scopes and Permissions page. The ticket can then be used with the Live Connect REST apis to access data that a user has consented to give to the app. Check out our REST APIs topic to learn more. Alternatively, the app can use the Live Connect SDK which will make these calls itself.
 */
service: string
}


/**
 * Allows users to sign out of your app.
 */
declare class Windows$Security$Authentication$OnlineId$SignOutUserOperation  {

/**
 * Requests the cancellation of the operation.
 */
cancel(): void;

/**
 * Requests that work associated with the operation should terminate.
 */
close(): void;

/**
 * Gets or sets a handler that is called when the operation completes.
 */
completed: Windows$Foundation$AsyncActionCompletedHandler;

/**
 * Gets the error code should the operation fail.
 */
errorCode: Windows$WinRTError;

/**
 * Returns the results of the operation. For this class, there are no results to return if the operation succeeds.
 */
getResults(): void;

/**
 * Gets a unique identifier that represents the operation.
 */
id: number;

/**
 * Gets the current status of the operation.
 */
status: $Values<typeof Windows$Foundation$AsyncStatus>
}


/**
 * Asynchronously gets the user's identity and corresponding tickets and properties.
 */
declare class Windows$Security$Authentication$OnlineId$UserAuthenticationOperation  {

/**
 * Requests the cancellation of the operation.
 */
cancel(): void;

/**
 * Requests that work associated with the operation should terminate.
 */
close(): void;

/**
 * Gets or sets a handler that's called when the operation completes.
 */
completed: Windows$Foundation$AsyncOperationCompletedHandler<Windows$Security$Authentication$OnlineId$UserIdentity>;

/**
 * Gets the error code should the operation fail.
 */
errorCode: Windows$WinRTError;

/**
 * Returns a UserIdentity object that contains information about the user.
 * @return An object containing information about the user's identity.
 */
getResults(): Windows$Security$Authentication$OnlineId$UserIdentity;

/**
 * Gets a unique identifier that represents the operation.
 */
id: number;

/**
 * Gets the current status of the operation.
 */
status: $Values<typeof Windows$Foundation$AsyncStatus>
}


/**
 * Contains the ID, tickets, and other information associated with a user.
 */
declare class Windows$Security$Authentication$OnlineId$UserIdentity  {

/**
 * Contains the first name of the user. This value is available only to Microsoft application partners.
 */
firstName: string;

/**
 * Gets the user's unique Microsoft account identifier. This value is available only to Microsoft application partners.
 */
id: string;

/**
 * Indicates if the user is part of a beta program. This value is available only to Microsoft application partners.
 */
isBetaAccount: boolean;

/**
 * Indicates if the user is on a PC that they have confirmed as their PC. This value is available only to Microsoft application partners.
 */
isConfirmedPC: boolean;

/**
 * Contains the user's last name. This value is available only to Microsoft application partners.
 */
lastName: string;

/**
 * Gets an obfuscated customer ID specific to the calling application. This ID allows your application to identify the user across sessions but cannot be used to share data between separate applications since each application will receive a distinct SafeCustomerId value for the same Microsoft account.
 */
safeCustomerId: string;

/**
 * The sign in name of the user. This value is available only to Microsoft application partners.
 */
signInName: string;

/**
 * Contains an array of tickets that identify the user. If your app uses the JWT policy, only one ticket is returned. This value is only available to Microsoft application partners.
 */
tickets: Windows$Foundation$Collections$IVectorView<Windows$Security$Authentication$OnlineId$OnlineIdServiceTicket>
}


      declare var npm$namespace$Windows$Security$Authentication$Web: {
        
        
        TokenBindingKeyType: typeof Windows$Security$Authentication$Web$TokenBindingKeyType,
WebAuthenticationOptions: typeof Windows$Security$Authentication$Web$WebAuthenticationOptions,
WebAuthenticationStatus: typeof Windows$Security$Authentication$Web$WebAuthenticationStatus,
        WebAuthenticationBroker: typeof Windows$Security$Authentication$Web$WebAuthenticationBroker,
WebAuthenticationResult: typeof Windows$Security$Authentication$Web$WebAuthenticationResult,
        Core: typeof npm$namespace$Windows$Security$Authentication$Web$Core,
Provider: typeof npm$namespace$Windows$Security$Authentication$Web$Provider,
      }

      declare var npm$namespace$Windows$Security$Authentication$Web$Core: {
        
        
        WebTokenRequestPromptType: typeof Windows$Security$Authentication$Web$Core$WebTokenRequestPromptType,
WebTokenRequestStatus: typeof Windows$Security$Authentication$Web$Core$WebTokenRequestStatus,
        WebAuthenticationCoreManager: typeof Windows$Security$Authentication$Web$Core$WebAuthenticationCoreManager,
WebProviderError: typeof Windows$Security$Authentication$Web$Core$WebProviderError,
WebTokenRequest: typeof Windows$Security$Authentication$Web$Core$WebTokenRequest,
WebTokenRequestResult: typeof Windows$Security$Authentication$Web$Core$WebTokenRequestResult,
WebTokenResponse: typeof Windows$Security$Authentication$Web$Core$WebTokenResponse,
        
      }

/**
 * Contains core methods for obtaining tokens from web account providers.
 */
declare class Windows$Security$Authentication$Web$Core$WebAuthenticationCoreManager  {

/**
 * Finds a web account asynchronously.
 * @param provider The web account provider for the web account.
 * @param webAccountId The Id of the web account.
 * @return When this method completes successfully, it returns the found web account.
 */
static findAccountAsync(
provider: Windows$Security$Credentials$WebAccountProvider,
webAccountId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Credentials$WebAccount>;

/**
 * Finds a web account provider asynchronously with one input.
 * @param webAccountProviderId The Id of the web account provider to find.
 * @return When this method completes successfully, it returns the found web account provider.
 */
static findAccountProviderAsync(
webAccountProviderId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Credentials$WebAccountProvider>;

/**
 * Finds a web account provider asynchronously with three inputs.
 * @param webAccountProviderId The Id of the web account provider to find.
 * @param authority The authority of the web account provider to find.
 * @param user The user associated with the web account provider to find.
 * @return When this method completes successfully, it returns the found web account provider.
 */
static findAccountProviderAsync(
webAccountProviderId: string,
authority: string,
user: Windows$System$User): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Credentials$WebAccountProvider>;

/**
 * Finds a web account provider asynchronously with two inputs.
 * @param webAccountProviderId The Id of the web account provider to find.
 * @param authority The authority of the web account provider to find.
 * @return When this method completes successfully, it returns the found web account provider.
 */
static findAccountProviderAsync(
webAccountProviderId: string,
authority: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Credentials$WebAccountProvider>;

/**
 * Attempts to get a token without showing any UI using one input. The user will never be prompted to enter their credentials.
 * @param request The web token request.
 * @return When this method completes successfully, it returns the result of the web token request.
 */
static getTokenSilentlyAsync(
request: Windows$Security$Authentication$Web$Core$WebTokenRequest): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Authentication$Web$Core$WebTokenRequestResult>;

/**
 * Attempts to get a token without showing any UI using two inputs. The user will never be prompted to enter their credentials.
 * @param request The web token request.
 * @param webAccount The web account.
 * @return When this method completes successfully, it returns the result of the web token request.
 */
static getTokenSilentlyAsync(
request: Windows$Security$Authentication$Web$Core$WebTokenRequest,
webAccount: Windows$Security$Credentials$WebAccount): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Authentication$Web$Core$WebTokenRequestResult>;

/**
 * Requests a token from a web account provider asynchronously. If needed, the user may be prompted to enter their credentials.
 * @param request The web token request.
 * @return When this method completes successfully, it returns the results of the web token request.
 */
static requestTokenAsync(
request: Windows$Security$Authentication$Web$Core$WebTokenRequest): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Authentication$Web$Core$WebTokenRequestResult>;

/**
 * Requests a token from a web account provider asynchronously. If needed, the user may be prompted to enter their credentials.
 * @param request The web token request.
 * @param webAccount The web account for the request.
 * @return When this method completes successfully, it returns the results of the web token request.
 */
static requestTokenAsync(
request: Windows$Security$Authentication$Web$Core$WebTokenRequest,
webAccount: Windows$Security$Credentials$WebAccount): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Authentication$Web$Core$WebTokenRequestResult>
}


/**
 * Represents an error from a web account provider.
 */
declare class Windows$Security$Authentication$Web$Core$WebProviderError  {

/**
 * Initializes a new instance of the WebProviderError class.
 * @param errorCode The error code.
 * @param errorMessage The error message.
 */
constructor(errorCode: number, errorMessage: string): this;

/**
 * Gets the error code.
 */
errorCode: number;

/**
 * Gets the error message.
 */
errorMessage: string;

/**
 * Gets the error properties.
 */
properties: Windows$Foundation$Collections$IMap<string, string>
}


/**
 * Represents a request to an online identity provider for an authentication token.
 */
declare class Windows$Security$Authentication$Web$Core$WebTokenRequest  {

/**
 * Initializes a new instance of the WebTokenRequest class with two inputs.
 * @param provider The web account provider the request is for.
 * @param scope The scope of the request.
 */
constructor(provider: Windows$Security$Credentials$WebAccountProvider, scope: string): this;

/**
 * Initializes a new instance of the WebTokenRequest class with four inputs.
 * @param provider The web account provider the request is for.
 * @param scope The scope of the request.
 * @param clientId The client Id.
 * @param promptType The request prompt type.
 */
constructor(provider: Windows$Security$Credentials$WebAccountProvider, scope: string, clientId: string, promptType: $Values<typeof Windows$Security$Authentication$Web$Core$WebTokenRequestPromptType>): this;

/**
 * Initializes a new instance of the WebTokenRequest class with one inputs.
 * @param provider The web account provider the request is for.
 */
constructor(provider: Windows$Security$Credentials$WebAccountProvider): this;

/**
 * Initializes a new instance of the WebTokenRequest class with three inputs.
 * @param provider The web account provider the request is for.
 * @param scope The scope of the request.
 * @param clientId The client Id.
 */
constructor(provider: Windows$Security$Credentials$WebAccountProvider, scope: string, clientId: string): this;
appProperties: any;

/**
 * Gets the Id of the client making the request.
 */
clientId: string;

/**
 * Gets the prompt type of the request.
 */
promptType: $Values<typeof Windows$Security$Authentication$Web$Core$WebTokenRequestPromptType>;

/**
 * Gets the properties of the request.
 */
properties: Windows$Foundation$Collections$IMap<string, string>;

/**
 * Gets the scope of the request.
 */
scope: string;

/**
 * Gets the web account provider for the request.
 */
webAccountProvider: Windows$Security$Credentials$WebAccountProvider
}


/**
 * Represents the prompt type of a web token request.
 */

declare  var Windows$Security$Authentication$Web$Core$WebTokenRequestPromptType: {|
  +default: 0,// 0
+forceAuthentication: 1,// 1

|};



/**
 * Represents the results of a web token request to an identity provider.
 */
declare class Windows$Security$Authentication$Web$Core$WebTokenRequestResult  {

/**
 * Invalidates the current cached WebTokenRequestResult . Use this method if an access denied error is returned when trying to use a token.
 * @return This method does not return an object or value.
 */
invalidateCacheAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the response data from the web token provider.
 */
responseData: Windows$Foundation$Collections$IVectorView<Windows$Security$Authentication$Web$Core$WebTokenResponse>;

/**
 * Gets the error returned by the web provider, if any.
 */
responseError: Windows$Security$Authentication$Web$Core$WebProviderError;

/**
 * Gets the status of the request.
 */
responseStatus: $Values<typeof Windows$Security$Authentication$Web$Core$WebTokenRequestStatus>
}


/**
 * Represents the status of a web token request.
 */

declare  var Windows$Security$Authentication$Web$Core$WebTokenRequestStatus: {|
  +success: 0,// 0
+userCancel: 1,// 1
+accountSwitch: 2,// 2
+userInteractionRequired: 3,// 3
+accountProviderNotAvailable: 4,// 4
+providerError: 5,// 5

|};



/**
 * Represents the response from a web account provider to a web token request.
 */
declare class Windows$Security$Authentication$Web$Core$WebTokenResponse  {

/**
 * Initializes a new instance of the WebTokenResponse class.
 */
constructor(): this;

/**
 * Initializes a new instance of the WebTokenResponse class with two inputs.
 * @param token The token.
 * @param webAccount The WebAccount .
 */
constructor(token: string, webAccount: Windows$Security$Credentials$WebAccount): this;

/**
 * Initializes a new instance of the WebTokenResponse class with three inputs.
 * @param token The token.
 * @param webAccount The WebAccount .
 * @param error The web provider error.
 */
constructor(token: string, webAccount: Windows$Security$Credentials$WebAccount, error: Windows$Security$Authentication$Web$Core$WebProviderError): this;

/**
 * Initializes a new instance of the WebTokenResponse class with one input.
 * @param token The token.
 */
constructor(token: string): this;

/**
 * Gets the properties of the response
 */
properties: Windows$Foundation$Collections$IMap<string, string>;

/**
 * Gets the error returned by the provider, if any.
 */
providerError: Windows$Security$Authentication$Web$Core$WebProviderError;

/**
 * Gets the authentication token.
 */
token: string;

/**
 * Gets the web account for the request.
 */
webAccount: Windows$Security$Credentials$WebAccount
}


      declare var npm$namespace$Windows$Security$Authentication$Web$Provider: {
        
        
        WebAccountClientViewType: typeof Windows$Security$Authentication$Web$Provider$WebAccountClientViewType,
WebAccountProviderOperationKind: typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderOperationKind,
WebAccountScope: typeof Windows$Security$Authentication$Web$Provider$WebAccountScope,
WebAccountSelectionOptions: typeof Windows$Security$Authentication$Web$Provider$WebAccountSelectionOptions,
        WebAccountClientView: typeof Windows$Security$Authentication$Web$Provider$WebAccountClientView,
WebAccountManager: typeof Windows$Security$Authentication$Web$Provider$WebAccountManager,
WebAccountProviderAddAccountOperation: typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderAddAccountOperation,
WebAccountProviderDeleteAccountOperation: typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderDeleteAccountOperation,
WebAccountProviderGetTokenSilentOperation: typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderGetTokenSilentOperation,
WebAccountProviderManageAccountOperation: typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderManageAccountOperation,
WebAccountProviderRequestTokenOperation: typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderRequestTokenOperation,
WebAccountProviderRetrieveCookiesOperation: typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderRetrieveCookiesOperation,
WebAccountProviderSignOutAccountOperation: typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderSignOutAccountOperation,
WebAccountProviderTriggerDetails: typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderTriggerDetails,
WebProviderTokenRequest: typeof Windows$Security$Authentication$Web$Provider$WebProviderTokenRequest,
WebProviderTokenResponse: typeof Windows$Security$Authentication$Web$Provider$WebProviderTokenResponse,
        
      }

/**
 * Represents the client view for a web account. Use this to control what information about an account from a provider is available to the client.
 */
declare class Windows$Security$Authentication$Web$Provider$WebAccountClientView  {

/**
 * Creates a new instance of the WebAccountClientView class.
 * @param viewType The client view type.
 * @param applicationCallbackUri The callback URI that indicates the completion of the operation.
 * @param accountPairwiseId The account pairwise Id.
 */
constructor(viewType: $Values<typeof Windows$Security$Authentication$Web$Provider$WebAccountClientViewType>, applicationCallbackUri: Windows$Foundation$Uri, accountPairwiseId: string): this;

/**
 * Creates a new instance of the WebAccountClientView class.
 * @param viewType The client view type.
 * @param applicationCallbackUri The callback URI that indicates the completion of the operation.
 */
constructor(viewType: $Values<typeof Windows$Security$Authentication$Web$Provider$WebAccountClientViewType>, applicationCallbackUri: Windows$Foundation$Uri): this;

/**
 * Gets the account pairwise Id.
 */
accountPairwiseId: string;

/**
 * Gets the app callback Uri.
 */
applicationCallbackUri: Windows$Foundation$Uri;

/**
 * Gets the type of web account client view.
 */
type: $Values<typeof Windows$Security$Authentication$Web$Provider$WebAccountClientViewType>
}


/**
 * Represents the levels of information about a web account shown to the client.
 */

declare  var Windows$Security$Authentication$Web$Provider$WebAccountClientViewType: {|
  +idOnly: 0,// 0
+idAndProperties: 1,// 1

|};



/**
 * Provides methods for managing web accounts.
 */
declare class Windows$Security$Authentication$Web$Provider$WebAccountManager  {

/**
 * Adds a new web account asynchronously with three inputs.
 * @param webAccountId The Id for the web account.
 * @param webAccountUserName The user name for the web account.
 * @param props Properties for the web account.
 * @return When this method completes, it returns the new web account.
 */
static addWebAccountAsync(
webAccountId: string,
webAccountUserName: string,
props: Windows$Foundation$Collections$IMapView<string, string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Credentials$WebAccount>;

/**
 * Adds a new web account asynchronously with four inputs.
 * @param webAccountId The Id for the web account.
 * @param webAccountUserName The user name for the web account.
 * @param props Properties for the web account.
 * @param scope The scope of the web account.
 * @return When this method completes, it returns the new web account.
 */
static addWebAccountAsync(
webAccountId: string,
webAccountUserName: string,
props: Windows$Foundation$Collections$IMapView<string, string>,
scope: $Values<typeof Windows$Security$Authentication$Web$Provider$WebAccountScope>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Credentials$WebAccount>;

/**
 * Clears the view for a web account.
 * @param webAccount The web account to clear the view for.
 * @param applicationCallbackUri The callback Uri that indicates the completion of the operation. The broker matches this Uri against every Uri that it is about to navigate to. The broker never navigates to this Uri, instead the broker returns the control back to the application when the user clicks a link or a web server redirection is made.
 * @return This method does not return a value.
 */
static clearViewAsync(
webAccount: Windows$Security$Credentials$WebAccount,
applicationCallbackUri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Clears a web account picture asynchronously.
 * @param webAccount The web account to clear the picture from.
 * @return This method does not return a value.
 */
static clearWebAccountPictureAsync(
webAccount: Windows$Security$Credentials$WebAccount): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Deletes a web account asynchronously.
 * @param webAccount The WebAccount to delete.
 * @return This method does not return a value.
 */
static deleteWebAccountAsync(
webAccount: Windows$Security$Credentials$WebAccount): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Finds all provider web accounts asynchronously.
 * @return When this method completes, it returns all provider web accounts.
 */
static findAllProviderWebAccountsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the scope of the web account.
 * @param webAccount The web account to get scope for.
 * @return The scope of the web account.
 */
static getScope(
webAccount: Windows$Security$Credentials$WebAccount): $Values<typeof Windows$Security$Authentication$Web$Provider$WebAccountScope>;

/**
 * Gets the views for a web account asynchronously.
 * @param webAccount The web account to get views for.
 * @return When this method completes, it returns the views for the web account.
 */
static getViewsAsync(
webAccount: Windows$Security$Credentials$WebAccount): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Pulls cookies asynchronously. Use this to enable single sign-on in an app after a user has entered their credentials into a web browser.
 * @param uriString The Uri to pull cookies from.
 * @param callerPFN The caller's package family name.
 * @return This method does not return a value.
 */
static pullCookiesAsync(
uriString: string,
callerPFN: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Pushes cookies asynchronously. Use this to enable single sign-on for a web account in a browser after the user has entered their credentials into the app.
 * @param uri The Uri to push the cookies to.
 * @param cookies The cookies to push.
 * @return This method does not return a value.
 */
static pushCookiesAsync(
uri: Windows$Foundation$Uri,
cookies: Windows$Foundation$Collections$IVectorView<Windows$Web$Http$HttpCookie>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Sets the scope of a web account asynchronously.
 * @param webAccount The web account to set scope for.
 * @param scope The scope to set.
 * @return This method does not return a value.
 */
static setScopeAsync(
webAccount: Windows$Security$Credentials$WebAccount,
scope: $Values<typeof Windows$Security$Authentication$Web$Provider$WebAccountScope>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Sets the view for a web account asynchronously.
 * @param webAccount The web account to set the view for.
 * @param view The view to set.
 * @return This method does not return a value.
 */
static setViewAsync(
webAccount: Windows$Security$Credentials$WebAccount,
view: Windows$Security$Authentication$Web$Provider$WebAccountClientView): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Sets the picture of a web account asynchronously.
 * @param webAccount The web account to set the picture for.
 * @param webAccountPicture The picture to set.
 * @return This method does not return a value.
 */
static setWebAccountPictureAsync(
webAccount: Windows$Security$Credentials$WebAccount,
webAccountPicture: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Updates the properties of a web account asynchronously.
 * @param webAccount The web account to update.
 * @param webAccountUserName The username to update.
 * @param additionalProperties The properties to update.
 * @return This method does not return a value.
 */
static updateWebAccountPropertiesAsync(
webAccount: Windows$Security$Credentials$WebAccount,
webAccountUserName: string,
additionalProperties: Windows$Foundation$Collections$IMapView<string, string>): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Represents an add account operation.
 */
declare class Windows$Security$Authentication$Web$Provider$WebAccountProviderAddAccountOperation  {

/**
 * Gets the kind of web account provider operation.
 */
kind: $Values<typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderOperationKind>;

/**
 * Informs the activating app that the operation completed successfully.
 */
reportCompleted(): void
}


/**
 * Represents a delete account operation.
 */
declare class Windows$Security$Authentication$Web$Provider$WebAccountProviderDeleteAccountOperation  {

/**
 * Gets the kind of web account provider operation.
 */
kind: $Values<typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderOperationKind>;

/**
 * Informs the activating app that the operation completed successfully.
 */
reportCompleted(): void;

/**
 * Informs the activating app that the operation encountered an error.
 * @param value The type of error encountered.
 */
reportError(value: Windows$Security$Authentication$Web$Core$WebProviderError): void;

/**
 * Gets the web account to delete.
 */
webAccount: Windows$Security$Credentials$WebAccount
}


/**
 * Represents a get token silently operation.
 */
declare class Windows$Security$Authentication$Web$Provider$WebAccountProviderGetTokenSilentOperation  {

/**
 * Gets or sets the cache expiration time.
 */
cacheExpirationTime: Date;

/**
 * Gets the kind of web account provider operation.
 */
kind: $Values<typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderOperationKind>;

/**
 * Gets the web provider token request.
 */
providerRequest: Windows$Security$Authentication$Web$Provider$WebProviderTokenRequest;

/**
 * Gets the web provider token responses.
 */
providerResponses: Windows$Foundation$Collections$IVector<Windows$Security$Authentication$Web$Provider$WebProviderTokenResponse>;

/**
 * Informs the activating app that the operation completed successfully.
 */
reportCompleted(): void;

/**
 * Informs the activating app that the operation encountered an error.
 * @param value The type of error encountered.
 */
reportError(value: Windows$Security$Authentication$Web$Core$WebProviderError): void;

/**
 * Informs the activating app that user interaction is required to continue the operation.
 */
reportUserInteractionRequired(): void;

/**
 * Informs the activating app that an error has occurred and user interaction is required to continue the operation.
 * @param value The error that has occurred.
 */
reportUserInteractionRequired(value: Windows$Security$Authentication$Web$Core$WebProviderError): void
}


/**
 * Represents a manage account operation.
 */
declare class Windows$Security$Authentication$Web$Provider$WebAccountProviderManageAccountOperation  {

/**
 * Gets the kind of web provider operation.
 */
kind: $Values<typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderOperationKind>;

/**
 * Informs the activating application that the operation completed successfully.
 */
reportCompleted(): void;

/**
 * Gets the web account to manage.
 */
webAccount: Windows$Security$Credentials$WebAccount
}


/**
 * Represents different operations a web account provider can perform. Use this to determine what operation to perform when the provider is activated.
 */

declare  var Windows$Security$Authentication$Web$Provider$WebAccountProviderOperationKind: {|
  +requestToken: 0,// 0
+getTokenSilently: 1,// 1
+addAccount: 2,// 2
+manageAccount: 3,// 3
+deleteAccount: 4,// 4
+retrieveCookies: 5,// 5
+signOutAccount: 6,// 6

|};



/**
 * Represents a request token operation.
 */
declare class Windows$Security$Authentication$Web$Provider$WebAccountProviderRequestTokenOperation  {

/**
 * Gets or sets the cache expiration time.
 */
cacheExpirationTime: Date;

/**
 * Gets the kind of web account provider operation.
 */
kind: $Values<typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderOperationKind>;

/**
 * Gets the web provider token request.
 */
providerRequest: Windows$Security$Authentication$Web$Provider$WebProviderTokenRequest;

/**
 * Gets the web provider token responses.
 */
providerResponses: Windows$Foundation$Collections$IVector<Windows$Security$Authentication$Web$Provider$WebProviderTokenResponse>;

/**
 * Informs the activating app that the operation completed successfully.
 */
reportCompleted(): void;

/**
 * Informs the activating app that the operation encountered an error.
 * @param value The type of error encountered.
 */
reportError(value: Windows$Security$Authentication$Web$Core$WebProviderError): void;

/**
 * Informs the activating app that the user cancelled the operation.
 */
reportUserCanceled(): void
}


/**
 * Represents a retrieve cookies operation made by a web account provider.
 */
declare class Windows$Security$Authentication$Web$Provider$WebAccountProviderRetrieveCookiesOperation  {

/**
 * Gets the app callback Uri.
 */
applicationCallbackUri: Windows$Foundation$Uri;

/**
 * Gets the context of the retrieve cookies operation.
 */
context: Windows$Foundation$Uri;

/**
 * Gets the cookies.
 */
cookies: Windows$Foundation$Collections$IVector<Windows$Web$Http$HttpCookie>;

/**
 * Gets the kind of web account provider operation.
 */
kind: $Values<typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderOperationKind>;

/**
 * Informs the activating app that the operation completed successfully.
 */
reportCompleted(): void;

/**
 * Informs the activating app that the operation encountered an error.
 * @param value The type of error encountered.
 */
reportError(value: Windows$Security$Authentication$Web$Core$WebProviderError): void;

/**
 * Gets or sets the Uri to retrieve cookies from.
 */
uri: Windows$Foundation$Uri
}


/**
 * Represents a sign out account operation made by a web account provider.
 */
declare class Windows$Security$Authentication$Web$Provider$WebAccountProviderSignOutAccountOperation  {

/**
 * Gets the app callback Uri.
 */
applicationCallbackUri: Windows$Foundation$Uri;

/**
 * Gets the client Id.
 */
clientId: string;

/**
 * Gets the kind of web account provider operation.
 */
kind: $Values<typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderOperationKind>;

/**
 * Informs the activating app that the operation completed successfully.
 */
reportCompleted(): void;

/**
 * Informs the activating app that the operation encountered an error.
 * @param value The type of error encountered.
 */
reportError(value: Windows$Security$Authentication$Web$Core$WebProviderError): void;

/**
 * Gets the web account to sign out.
 */
webAccount: Windows$Security$Credentials$WebAccount
}


/**
 * Provides information about a web account provider trigger.
 */
declare class Windows$Security$Authentication$Web$Provider$WebAccountProviderTriggerDetails  {

/**
 * Gets the web account provider operation.
 */
operation: Windows$Security$Authentication$Web$Provider$IWebAccountProviderOperation
}


/**
 * Represents the scope of a web account.
 */

declare  var Windows$Security$Authentication$Web$Provider$WebAccountScope: {|
  +perUser: 0,// 0
+perApplication: 1,// 1

|};



/**
 * Represents web account selection options. Use this to support the use of multiple web accounts in an app, where user might choose to log in with an existing account or add a new account.
 */

declare  var Windows$Security$Authentication$Web$Provider$WebAccountSelectionOptions: {|
  +default: 0,// 0
+new: 1,// 1

|};



/**
 * Represents a request for a token from a client to a provider.
 */
declare class Windows$Security$Authentication$Web$Provider$WebProviderTokenRequest  {

/**
 * Gets the app callback Uri.
 */
applicationCallbackUri: Windows$Foundation$Uri;

/**
 * Gets the web token request made by the client.
 */
clientRequest: Windows$Security$Authentication$Web$Core$WebTokenRequest;

/**
 * Gets a token binding key for the app asynchronously.
 * @param keyType The type of key to get.
 * @param target The target Uri.
 * @return When this method completes, it returns a cryptographic key.
 */
getApplicationTokenBindingKeyAsync(
keyType: $Values<typeof Windows$Security$Authentication$Web$TokenBindingKeyType>,
target: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Cryptography$Core$CryptographicKey>;

/**
 * Gets the web account selection options.
 */
webAccountSelectionOptions: $Values<typeof Windows$Security$Authentication$Web$Provider$WebAccountSelectionOptions>;

/**
 * Gets the web accounts for the request.
 */
webAccounts: Windows$Foundation$Collections$IVectorView<Windows$Security$Credentials$WebAccount>
}


/**
 * Represents a web provider token response.
 */
declare class Windows$Security$Authentication$Web$Provider$WebProviderTokenResponse  {

/**
 * Creates a new instance of the WebProviderTokenResponse class.
 * @param webTokenResponse The web token response from the client.
 */
constructor(webTokenResponse: Windows$Security$Authentication$Web$Core$WebTokenResponse): this;

/**
 * Gets the response from the provider to the client.
 */
clientResponse: Windows$Security$Authentication$Web$Core$WebTokenResponse
}


/**
 * Defines properties for web account provider operations.
 */
declare interface Windows$Security$Authentication$Web$Provider$IWebAccountProviderOperation {

/**
 * Gets the kind of web account provider operation.
 */
kind: $Values<typeof Windows$Security$Authentication$Web$Provider$WebAccountProviderOperationKind>
} 


/**
 * Gets the type of key used for token binding.
 */

declare  var Windows$Security$Authentication$Web$TokenBindingKeyType: {|
  +rsa2048: 0,// 0
+ecdsaP256: 1,// 1

|};



/**
 * Starts the authentication operation. You can call the methods of this class multiple times in a single application or across multiple applications at the same time.
 */
declare class Windows$Security$Authentication$Web$WebAuthenticationBroker  {

/**
 * Starts the authentication operation with two inputs.
 * @param requestUri The starting URI of the web service. This URI must be a secure address of https://.
 * @param callbackUri The callback URI that indicates the completion of the web authentication. The broker matches this URI against every URI that it is about to navigate to. The broker never navigates to this URI, instead the broker returns the control back to the application when the user clicks a link or a web server redirection is made.
 */
static authenticateAndContinue(requestUri: Windows$Foundation$Uri, callbackUri: Windows$Foundation$Uri): void;

/**
 * Starts the authentication operation with one input.
 * @param requestUri The starting URI of the web service. This URI must be a secure address of https://.
 */
static authenticateAndContinue(requestUri: Windows$Foundation$Uri): void;

/**
 * Starts the authentication operation with four inputs.
 * @param requestUri The starting URI of the web service. This URI must be a secure address of https://.
 * @param callbackUri The callback URI that indicates the completion of the web authentication. The broker matches this URI against every URI that it is about to navigate to. The broker never navigates to this URI, instead the broker returns the control back to the application when the user clicks a link or a web server redirection is made.
 * @param continuationData Continuation data to be passed as part of the authentication operation.
 * @param options The options for the authentication operation.
 */
static authenticateAndContinue(
requestUri: Windows$Foundation$Uri,
callbackUri: Windows$Foundation$Uri,
continuationData: Windows$Foundation$Collections$ValueSet,
options: $Values<typeof Windows$Security$Authentication$Web$WebAuthenticationOptions>): void;

/**
 * Starts the asynchronous authentication operation with three inputs. You can call this method multiple times in a single application or across multiple applications at the same time.
 * @param options The options for the authentication operation.
 * @param requestUri The starting URI of the web service. This URI must be a secure address of https://.
 * @param callbackUri The callback URI that indicates the completion of the web authentication. The broker matches this URI against every URI that it is about to navigate to. The broker never navigates to this URI, instead the broker returns the control back to the application when the user clicks a link or a web server redirection is made.
 * @return The way to query the status and get the results of the authentication operation. If you are getting an invalid parameter error, the most common cause is that you are not using HTTPS for the requestUri parameter.
 */
static authenticateAsync(
options: $Values<typeof Windows$Security$Authentication$Web$WebAuthenticationOptions>,
requestUri: Windows$Foundation$Uri,
callbackUri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Authentication$Web$WebAuthenticationResult>;

/**
 * Starts the asynchronous authentication operation with two inputs. You can call this method multiple times in a single application or across multiple applications at the same time.
 * @param options The options for the authentication operation.
 * @param requestUri The starting URI of the web service. This URI must be a secure address of https://.
 * @return The way to query the status and get the results of the authentication operation. If you are getting an invalid parameter error, the most common cause is that you are not using HTTPS for the requestUri parameter.
 */
static authenticateAsync(
options: $Values<typeof Windows$Security$Authentication$Web$WebAuthenticationOptions>,
requestUri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Authentication$Web$WebAuthenticationResult>;

/**
 * Starts the asynchronous authentication operation silently (no UI will be shown) with two inputs. You can call this method multiple times in a single application or across multiple applications at the same time.
 * @param requestUri The starting URI of the web service. This URI must be a secure address of https://.
 * @param options The options for the authentication operation.
 * @return The way to query the status and get the results of the authentication operation. If you are getting an invalid parameter error, the most common cause is that you are not using HTTPS for the requestUri parameter.
 */
static authenticateSilentlyAsync(
requestUri: Windows$Foundation$Uri,
options: $Values<typeof Windows$Security$Authentication$Web$WebAuthenticationOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Authentication$Web$WebAuthenticationResult>;

/**
 * Starts the asynchronous authentication operation silently (no UI will be shown) with one input. You can call this method multiple times in a single application or across multiple applications at the same time.
 * @param requestUri The starting URI of the web service. This URI must be a secure address of https://.
 * @return The way to query the status and get the results of the authentication operation. If you are getting an invalid parameter error, the most common cause is that you are not using HTTPS for the requestUri parameter.
 */
static authenticateSilentlyAsync(
requestUri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Authentication$Web$WebAuthenticationResult>;

/**
 * Gets the current application callback URI.
 * @return The URI of the current application.
 */
static getCurrentApplicationCallbackUri(): Windows$Foundation$Uri
}


/**
 * Contains the options available to the asynchronous operation.
 */

declare  var Windows$Security$Authentication$Web$WebAuthenticationOptions: {|
  +none: 0,// 0
+silentMode: 1,// 1
+useTitle: 2,// 2
+useHttpPost: 3,// 3
+useCorporateNetwork: 4,// 4

|};



/**
 * Indicates the result of the authentication operation.
 */
declare class Windows$Security$Authentication$Web$WebAuthenticationResult  {

/**
 * Contains the protocol data when the operation successfully completes.
 */
responseData: string;

/**
 * Returns the HTTP error code when ResponseStatus is equal to WebAuthenticationStatus.ErrorHttp . This is only available if there is an error.
 */
responseErrorDetail: number;

/**
 * Contains the status of the asynchronous operation when it completes.
 */
responseStatus: $Values<typeof Windows$Security$Authentication$Web$WebAuthenticationStatus>
}


/**
 * Contains the status of the authentication operation.
 */

declare  var Windows$Security$Authentication$Web$WebAuthenticationStatus: {|
  +success: 0,// 0
+userCancel: 1,// 1
+errorHttp: 2,// 2

|};



      declare var npm$namespace$Windows$Security$Credentials: {
        
        
        KeyCredentialAttestationStatus: typeof Windows$Security$Credentials$KeyCredentialAttestationStatus,
KeyCredentialCreationOption: typeof Windows$Security$Credentials$KeyCredentialCreationOption,
KeyCredentialStatus: typeof Windows$Security$Credentials$KeyCredentialStatus,
WebAccountPictureSize: typeof Windows$Security$Credentials$WebAccountPictureSize,
WebAccountState: typeof Windows$Security$Credentials$WebAccountState,
        KeyCredential: typeof Windows$Security$Credentials$KeyCredential,
KeyCredentialAttestationResult: typeof Windows$Security$Credentials$KeyCredentialAttestationResult,
KeyCredentialManager: typeof Windows$Security$Credentials$KeyCredentialManager,
KeyCredentialOperationResult: typeof Windows$Security$Credentials$KeyCredentialOperationResult,
KeyCredentialRetrievalResult: typeof Windows$Security$Credentials$KeyCredentialRetrievalResult,
PasswordCredential: typeof Windows$Security$Credentials$PasswordCredential,
PasswordCredentialPropertyStore: typeof Windows$Security$Credentials$PasswordCredentialPropertyStore,
PasswordVault: typeof Windows$Security$Credentials$PasswordVault,
WebAccount: typeof Windows$Security$Credentials$WebAccount,
WebAccountProvider: typeof Windows$Security$Credentials$WebAccountProvider,
        UI: typeof npm$namespace$Windows$Security$Credentials$UI,
      }

/**
 * Represents a key credential, an RSA, 2048-bit, asymmetric key that represents a user's identity for an application.
 */
declare class Windows$Security$Credentials$KeyCredential  {

/**
 * Gets an attestation for a key credential. Call this method after provisioning a key credential for the current user and application.
 * @return When this method completes, it returns a key credential attestation result.
 */
getAttestationAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Credentials$KeyCredentialAttestationResult>;

/**
 * Gets the name of the key credential.
 */
name: string;

/**
 * Prompts the user to cryptographcally sign data using their key credential.
 * @param data The data to cryptographically sign.
 * @return When this method completes, it returns a key credential operation result.
 */
requestSignAsync(
data: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Credentials$KeyCredentialOperationResult>;

/**
 * Gets the public portion of the asymmetric KeyCredential .
 * @return The public portion of the asymmetric key credential.
 */
retrievePublicKey(): Windows$Storage$Streams$IBuffer;

/**
 * Gets the public portion of the asymmetric KeyCredential .
 * @param blobType The blob type of the public key to retrieve.
 * @return The public portion of the asymmetric key credential.
 */
retrievePublicKey(
blobType: $Values<typeof Windows$Security$Cryptography$Core$CryptographicPublicKeyBlobType>): Windows$Storage$Streams$IBuffer
}


/**
 * Represents the results of the KeyCredential.GetAttestationAsync method.
 */
declare class Windows$Security$Credentials$KeyCredentialAttestationResult  {

/**
 * Gets the attestation information for the KeyCredential.
 */
attestationBuffer: Windows$Storage$Streams$IBuffer;

/**
 * Gets the chain of certificates used to verify the attestation.
 */
certificateChainBuffer: Windows$Storage$Streams$IBuffer;

/**
 * Gets the status of the key credential attestation.
 */
status: $Values<typeof Windows$Security$Credentials$KeyCredentialAttestationStatus>
}


/**
 * Represents key credential attestation statuses.
 */

declare  var Windows$Security$Credentials$KeyCredentialAttestationStatus: {|
  +success: 0,// 0
+unknownError: 1,// 1
+notSupported: 2,// 2
+temporaryFailure: 3,// 3

|};



/**
 * Represents the options for creating key credentials.
 */

declare  var Windows$Security$Credentials$KeyCredentialCreationOption: {|
  +replaceExisting: 0,// 0
+failIfExists: 1,// 1

|};



/**
 * Contains methods for basic management of key credentials.
 */
declare class Windows$Security$Credentials$KeyCredentialManager  {

/**
 * Deletes a previously provisioned user identity key for the current user and application.
 * @param name The name of the key to delete.
 * @return This method does not return a value.
 */
static deleteAsync(name: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Determines if the current device and user is capable of provisioning a key credential.
 * @return When this method completes, it returns true if the current device and user is capable of provisioning a key credential. Otherwise, it returns false.
 */
static isSupportedAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Retrieves a key credential for the current user and application.
 * @param name The name of the key credential to open.
 * @return When this method completes, it returns the results of the key credential retrieval.
 */
static openAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Credentials$KeyCredentialRetrievalResult>;

/**
 * Renews an attestation for a key credential.
 * @return This method does not return a value.
 */
static renewAttestationAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Creates a new key credential for the current user and application.
 * @param name The name of the key credential to create.
 * @param option Options for the creation operation.
 * @return When this method completes, it returns the results of the key credential creation.
 */
static requestCreateAsync(
name: string,
option: $Values<typeof Windows$Security$Credentials$KeyCredentialCreationOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Credentials$KeyCredentialRetrievalResult>
}


/**
 * Represents the result of a key credential operation.
 */
declare class Windows$Security$Credentials$KeyCredentialOperationResult  {

/**
 * Gets the result of the key credential operation.
 */
result: Windows$Storage$Streams$IBuffer;

/**
 * Gets the status of the key credential.
 */
status: $Values<typeof Windows$Security$Credentials$KeyCredentialStatus>
}


/**
 * Represents the result of a key credential retrieval.
 */
declare class Windows$Security$Credentials$KeyCredentialRetrievalResult  {

/**
 * Gets the key credential.
 */
credential: Windows$Security$Credentials$KeyCredential;

/**
 * Gets the status of the key credential.
 */
status: $Values<typeof Windows$Security$Credentials$KeyCredentialStatus>
}


/**
 * Represents the status of a key credential request.
 */

declare  var Windows$Security$Credentials$KeyCredentialStatus: {|
  +success: 0,// 0
+unknownError: 1,// 1
+notFound: 2,// 2
+userCanceled: 3,// 3
+userPrefersPassword: 4,// 4
+credentialAlreadyExists: 5,// 5
+securityDeviceLocked: 6,// 6

|};



/**
 * Represents the password credential store.
 */
declare class Windows$Security$Credentials$PasswordCredential  {

/**
 * Creates and initializes a new instance of the PasswordCredential object that contains the provided credential data.
 * @param resource The resource for which the credentials are used.
 * @param userName The user name that must be present in the credentials.
 * @param password The password for the created credentials.
 */
constructor(resource: string, userName: string, password: string): this;

/**
 * Creates and initializes a new, empty instance of the PasswordCredential object.
 */
constructor(): this;

/**
 * Gets or sets the password string of the credential.
 */
password: string;

/**
 * This API is intended for internal use only should not be used in your code.
 */
properties: Windows$Foundation$Collections$IPropertySet;

/**
 * Gets or sets the resource of the credential.
 */
resource: string;

/**
 * Populates the password for the credential. After the operation returns successfully, you can get the password from the Password property.
 */
retrievePassword(): void;

/**
 * Gets or sets the user name of the credential.
 */
userName: string
}


/**
 * Represents the password credential property store. This class and its members are reserved for internal use and are not intended to be used in your code.
 */
declare class Windows$Security$Credentials$PasswordCredentialPropertyStore  {

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 */
constructor(): this;

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 */
clear(): void;

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 */
first(): any;

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 */
getView(): any;

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 * @param key Reserved.
 */
hasKey(key: string): any;

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 * @param key Reserved.
 * @param value Reserved.
 */
insert(key: string, value: any): any;

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 * @param key Reserved.
 */
lookup(key: string): any;

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 */
onmapchanged: Windows$Foundation$Collections$MapChangedEventHandler<string, any>;
addEventListener(
type: "mapchanged",
listener: Windows$Foundation$Collections$MapChangedEventHandler<string, any>): void;
removeEventListener(
type: "mapchanged",
listener: Windows$Foundation$Collections$MapChangedEventHandler<string, any>): void;

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 * @param key Reserved.
 */
remove(key: string): void;

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 */
size: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a Credential Locker of credentials. The contents of the locker are specific to the app or service. Apps and services don't have access to credentials associated with other apps or services.
 */
declare class Windows$Security$Credentials$PasswordVault  {

/**
 * Creates and initializes a new instance of the PasswordVault object.
 */
constructor(): this;

/**
 * Adds a credential to the Credential Locker.
 * @param credential The credential to be added.
 */
add(credential: Windows$Security$Credentials$PasswordCredential): void;

/**
 * Searches the Credential Locker for credentials matching the resource specified.
 * @param resource The resource to be searched for.
 * @return When this method returns, contains an IVectorView of credential objects that match the search criteria.
 */
findAllByResource(
resource: string): Windows$Foundation$Collections$IVectorView<Windows$Security$Credentials$PasswordCredential>;

/**
 * Searches the Credential Locker for credentials that match the user name specified.
 * @param userName The user name to be searched for.
 * @return When this method returns, contains an IVectorView of credential objects that match the search criteria.
 */
findAllByUserName(
userName: string): Windows$Foundation$Collections$IVectorView<Windows$Security$Credentials$PasswordCredential>;

/**
 * Removes a credential from the Credential Locker.
 * @param credential The credential to be removed.
 */
remove(credential: Windows$Security$Credentials$PasswordCredential): void;

/**
 * Reads a credential from the Credential Locker.
 * @param resource The resource for which the credential is used.
 * @param userName The user name that must be present in the credential.
 * @return The returned credential that contains all the data.
 */
retrieve(
resource: string,
userName: string): Windows$Security$Credentials$PasswordCredential;

/**
 * Retrieves all of the credentials stored in the Credential Locker.
 * @return When this method returns, contains an IVectorView output of credential objects that match the search criteria. This output is a snapshot and not dynamic. If the results are used for updating or deleting credentials, those changes won't be reflected in the previous output.
 */
retrieveAll(
): Windows$Foundation$Collections$IVectorView<Windows$Security$Credentials$PasswordCredential>
}


      declare var npm$namespace$Windows$Security$Credentials$UI: {
        
        
        AuthenticationProtocol: typeof Windows$Security$Credentials$UI$AuthenticationProtocol,
CredentialSaveOption: typeof Windows$Security$Credentials$UI$CredentialSaveOption,
UserConsentVerificationResult: typeof Windows$Security$Credentials$UI$UserConsentVerificationResult,
UserConsentVerifierAvailability: typeof Windows$Security$Credentials$UI$UserConsentVerifierAvailability,
        CredentialPicker: typeof Windows$Security$Credentials$UI$CredentialPicker,
CredentialPickerOptions: typeof Windows$Security$Credentials$UI$CredentialPickerOptions,
CredentialPickerResults: typeof Windows$Security$Credentials$UI$CredentialPickerResults,
UserConsentVerifier: typeof Windows$Security$Credentials$UI$UserConsentVerifier,
        
      }

/**
 * Identifies which authentication protocol to use.
 */

declare  var Windows$Security$Credentials$UI$AuthenticationProtocol: {|
  +basic: 0,// 0
+digest: 1,// 1
+ntlm: 2,// 2
+kerberos: 3,// 3
+negotiate: 4,// 4
+credSsp: 5,// 5
+custom: 6,// 6

|};



/**
 * Creates an asynchronous object that displays a dialog box of credentials to the user and collects the user's response.
 */
declare class Windows$Security$Credentials$UI$CredentialPicker  {

/**
 * Constructor used to initiate asynchronous prompting operations using three inputs.
 * @param targetName The target name to display.
 * @param message The message to display in the dialog box.
 * @param caption The caption to display in the dialog box.
 * @return The credential and options from the user.
 */
static pickAsync(
targetName: string,
message: string,
caption: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Credentials$UI$CredentialPickerResults>;

/**
 * Constructor used to initiate asynchronous prompting operations using two inputs.
 * @param targetName The target name to display.
 * @param message The message to display in the dialog box.
 * @return The credential and options from the user.
 */
static pickAsync(
targetName: string,
message: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Credentials$UI$CredentialPickerResults>;

/**
 * Displays a dialog box to the user and collects credentials from the user.
 * @param options The options on displaying and collecting the credential box.
 * @return The credential and options from the user.
 */
static pickAsync(
options: Windows$Security$Credentials$UI$CredentialPickerOptions): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Credentials$UI$CredentialPickerResults>
}


/**
 * Controls the appearance and behavior of a credential prompt.
 */
declare class Windows$Security$Credentials$UI$CredentialPickerOptions  {

/**
 * Creates and initializes a new, empty instance of the CredentialPickerOptions object.
 */
constructor(): this;

/**
 * Gets or sets the option of whether the dialog box is displayed.
 */
alwaysDisplayDialog: boolean;

/**
 * Gets or sets the authentication protocol.
 */
authenticationProtocol: $Values<typeof Windows$Security$Credentials$UI$AuthenticationProtocol>;

/**
 * Gets or sets whether the caller wants to save the credentials.
 */
callerSavesCredential: boolean;

/**
 * Gets or sets the caption text that is displayed to the user.
 */
caption: string;

/**
 * Gets or sets the option on saving credentials.
 */
credentialSaveOption: $Values<typeof Windows$Security$Credentials$UI$CredentialSaveOption>;

/**
 * Gets or sets whether the authentication protocol is custom rather than a standard authentication protocol.
 */
customAuthenticationProtocol: string;

/**
 * Gets or sets the error code.
 */
errorCode: number;

/**
 * Gets or sets the body of text that displays to the user.
 */
message: string;

/**
 * Gets or sets whether to fill dialog box fields with previous credentials.
 */
previousCredential: Windows$Storage$Streams$IBuffer;

/**
 * Gets or sets the name of the target computer.
 */
targetName: string
}


/**
 * Describes the results of the dialog box operation.
 */
declare class Windows$Security$Credentials$UI$CredentialPickerResults  {

/**
 * Gets the opaque credential.
 */
credential: Windows$Storage$Streams$IBuffer;

/**
 * Gets the domain name portion of the unpacked credential.
 */
credentialDomainName: string;

/**
 * Gets the password portion of the unpacked credential.
 */
credentialPassword: string;

/**
 * Gets the state of the "Save Credentials" check box.
 */
credentialSaveOption: $Values<typeof Windows$Security$Credentials$UI$CredentialSaveOption>;

/**
 * Gets the status of the credential save operation.
 */
credentialSaved: boolean;

/**
 * Gets the user name of the unpacked credential.
 */
credentialUserName: string;

/**
 * Gets the value of the error code.
 */
errorCode: number
}


/**
 * Identifies the state of the dialog box option on whether to save credentials.
 */

declare  var Windows$Security$Credentials$UI$CredentialSaveOption: {|
  +unselected: 0,// 0
+selected: 1,// 1
+hidden: 2,// 2

|};



/**
 * Describes the result of a biometric (fingerprint) verification operation.
 */

declare  var Windows$Security$Credentials$UI$UserConsentVerificationResult: {|
  +verified: 0,// 0
+deviceNotPresent: 1,// 1
+notConfiguredForUser: 2,// 2
+disabledByPolicy: 3,// 3
+deviceBusy: 4,// 4
+retriesExhausted: 5,// 5
+canceled: 6,// 6

|};



/**
 * Checks for availability of a biometric (fingerprint) verifier device and performs a biometric verification.
 */
declare class Windows$Security$Credentials$UI$UserConsentVerifier  {

/**
 * Checks to see whether a biometric (fingerprint) verifier device is available.
 * @return A UserConsentVerifierAvailability value that describes the result of the availability check operation.
 */
static checkAvailabilityAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Security$Credentials$UI$UserConsentVerifierAvailability>>;

/**
 * Performs a fingerprint (biometric) verification.
 * @param message A message to display to the user for this biometric verification request.
 * @return A UserConsentVerificationResult value that describes the result of the biometric verification.
 */
static requestVerificationAsync(
message: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Security$Credentials$UI$UserConsentVerificationResult>>
}


/**
 * Describes the result of a check for a biometric (fingerprint) verifier device.
 */

declare  var Windows$Security$Credentials$UI$UserConsentVerifierAvailability: {|
  +available: 0,// 0
+deviceNotPresent: 1,// 1
+notConfiguredForUser: 2,// 2
+disabledByPolicy: 3,// 3
+deviceBusy: 4,// 4

|};



/**
 * Identifies an account from a web account provider.
 */
declare class Windows$Security$Credentials$WebAccount  {

/**
 * Creates an instance of the WebAccount class.
 * @param webAccountProvider The web account provider associated with the web account.
 * @param userName The user name of the web account.
 * @param state The state of the web account.
 */
constructor(webAccountProvider: Windows$Security$Credentials$WebAccountProvider, userName: string, state: $Values<typeof Windows$Security$Credentials$WebAccountState>): this;

/**
 * Gets the web account's picture asynchronously.
 * @param desizedSize The desired size of the web account picture.
 * @return When this method completes, it returns the web account's picture.
 */
getPictureAsync(
desizedSize: $Values<typeof Windows$Security$Credentials$WebAccountPictureSize>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStream>;

/**
 * Gets the Id of the web account.
 */
id: string;

/**
 * Gets the properties of the web account.
 */
properties: Windows$Foundation$Collections$IMapView<string, string>;

/**
 * Signs the web account out asynchronously. This clears all cached tokens associated with the account, and tells the provider to invalidate any tokens associated with the account for this app.
 * @param clientId The Id of the client.
 * @return This method does not return a value.
 */
signOutAsync(clientId: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Signs the web account out asynchronously. This clears all cached tokens associated with the account, and tells the provider to invalidate any tokens associated with the account for this app.
 * @return This method does not return a value.
 */
signOutAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the connected state of the web account.
 */
state: $Values<typeof Windows$Security$Credentials$WebAccountState>;

/**
 * Gets the username for the web account.
 */
userName: string;

/**
 * Gets the web authentication provider for the account.
 */
webAccountProvider: Windows$Security$Credentials$WebAccountProvider
}


/**
 * Represents the sizes of a web account picture.
 */

declare  var Windows$Security$Credentials$WebAccountPictureSize: {|
  +size64x64: 0,// 0
+size208x208: 1,// 1
+size424x424: 2,// 2
+size1080x1080: 3,// 3

|};



/**
 * Represents a web account authentication provider.
 */
declare class Windows$Security$Credentials$WebAccountProvider  {

/**
 * Creates an instance of the WebAccountProvider class.
 * @param id The web account provider id.
 * @param displayName The display name for the web account provider.
 * @param iconUri The Uri of the icon image to display for the web account provider.
 */
constructor(id: string, displayName: string, iconUri: Windows$Foundation$Uri): this;

/**
 * Gets the authority of the web account provider. Use authority to disambiguate between a single provider with multiple identities (such as a Microsoft account versus Azure Active Directory).
 */
authority: string;

/**
 * Gets the display name for the web account provider.
 */
displayName: string;

/**
 * Gets the display purpose of the web account provider.
 */
displayPurpose: string;

/**
 * Gets the Uri of the icon image to display for the web account provider.
 */
iconUri: Windows$Foundation$Uri;

/**
 * Gets the web account provider id.
 */
id: string;

/**
 * Gets the user associated with the provider.
 */
user: Windows$System$User
}


/**
 * Describes the state of a WebAccount object.
 */

declare  var Windows$Security$Credentials$WebAccountState: {|
  +none: 0,// 0
+connected: 1,// 1
+error: 2,// 2

|};



      declare var npm$namespace$Windows$Security$Cryptography: {
        
        
        BinaryStringEncoding: typeof Windows$Security$Cryptography$BinaryStringEncoding,
        CryptographicBuffer: typeof Windows$Security$Cryptography$CryptographicBuffer,
        Certificates: typeof npm$namespace$Windows$Security$Cryptography$Certificates,
Core: typeof npm$namespace$Windows$Security$Cryptography$Core,
DataProtection: typeof npm$namespace$Windows$Security$Cryptography$DataProtection,
      }

/**
 * Contains encoding formats that can be used in the ConvertStringToBinary and ConvertBinaryToString methods.
 */

declare  var Windows$Security$Cryptography$BinaryStringEncoding: {|
  +utf8: 0,// 0
+utf16LE: 1,// 1
+utf16BE: 2,// 2

|};



      declare var npm$namespace$Windows$Security$Cryptography$Certificates: {
        
        
        CertificateChainPolicy: typeof Windows$Security$Cryptography$Certificates$CertificateChainPolicy,
ChainValidationResult: typeof Windows$Security$Cryptography$Certificates$ChainValidationResult,
EnrollKeyUsages: typeof Windows$Security$Cryptography$Certificates$EnrollKeyUsages,
ExportOption: typeof Windows$Security$Cryptography$Certificates$ExportOption,
InstallOptions: typeof Windows$Security$Cryptography$Certificates$InstallOptions,
KeyProtectionLevel: typeof Windows$Security$Cryptography$Certificates$KeyProtectionLevel,
KeySize: typeof Windows$Security$Cryptography$Certificates$KeySize,
SignatureValidationResult: typeof Windows$Security$Cryptography$Certificates$SignatureValidationResult,
        Certificate: typeof Windows$Security$Cryptography$Certificates$Certificate,
CertificateChain: typeof Windows$Security$Cryptography$Certificates$CertificateChain,
CertificateEnrollmentManager: typeof Windows$Security$Cryptography$Certificates$CertificateEnrollmentManager,
CertificateKeyUsages: typeof Windows$Security$Cryptography$Certificates$CertificateKeyUsages,
CertificateQuery: typeof Windows$Security$Cryptography$Certificates$CertificateQuery,
CertificateRequestProperties: typeof Windows$Security$Cryptography$Certificates$CertificateRequestProperties,
CertificateStore: typeof Windows$Security$Cryptography$Certificates$CertificateStore,
CertificateStores: typeof Windows$Security$Cryptography$Certificates$CertificateStores,
ChainBuildingParameters: typeof Windows$Security$Cryptography$Certificates$ChainBuildingParameters,
ChainValidationParameters: typeof Windows$Security$Cryptography$Certificates$ChainValidationParameters,
CmsAttachedSignature: typeof Windows$Security$Cryptography$Certificates$CmsAttachedSignature,
CmsDetachedSignature: typeof Windows$Security$Cryptography$Certificates$CmsDetachedSignature,
CmsSignerInfo: typeof Windows$Security$Cryptography$Certificates$CmsSignerInfo,
CmsTimestampInfo: typeof Windows$Security$Cryptography$Certificates$CmsTimestampInfo,
KeyAlgorithmNames: typeof Windows$Security$Cryptography$Certificates$KeyAlgorithmNames,
KeyAttestationHelper: typeof Windows$Security$Cryptography$Certificates$KeyAttestationHelper,
KeyStorageProviderNames: typeof Windows$Security$Cryptography$Certificates$KeyStorageProviderNames,
PfxImportParameters: typeof Windows$Security$Cryptography$Certificates$PfxImportParameters,
SubjectAlternativeNameInfo: typeof Windows$Security$Cryptography$Certificates$SubjectAlternativeNameInfo,
UserCertificateEnrollmentManager: typeof Windows$Security$Cryptography$Certificates$UserCertificateEnrollmentManager,
        
      }

/**
 * Represents a cryptography certificate.
 */
declare class Windows$Security$Cryptography$Certificates$Certificate  {

/**
 * Create a new instance of the Certificate class using the specified certificate data.
 * @param certBlob The certificate data as an ASN.1 DER encoded certificate blob (.cer or .p7b).
 */
constructor(certBlob: Windows$Storage$Streams$IBuffer): this;

/**
 * Build a certificate chain for the specified certificates starting from the end entity certificate to the root using the specified chain building parameters.
 * @param certificates The intermediate certificates to use when building the certificate chain.
 * @param parameters The chain building paramaters to use when building the certificate chain.
 * @return An asynchronous operation to retrieve the CertificateChain object that contains the entire certificate chain.
 */
buildChainAsync(
certificates: Windows$Foundation$Collections$IIterable<Windows$Security$Cryptography$Certificates$Certificate>,
parameters: Windows$Security$Cryptography$Certificates$ChainBuildingParameters): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Cryptography$Certificates$CertificateChain>;

/**
 * Build a certificate chain for the specified certificates starting from the end entity certificate to the root.
 * @param certificates The intermediate certificates to use when building the certificate chain.
 * @return An asynchronous operation to retrieve the CertificateChain object that contains the entire certificate chain.
 */
buildChainAsync(
certificates: Windows$Foundation$Collections$IIterable<Windows$Security$Cryptography$Certificates$Certificate>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Cryptography$Certificates$CertificateChain>;

/**
 * Gets a collection of object identifiers (OIDs) for the enhanced key usage extension.
 */
enhancedKeyUsages: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets or sets the friendly name for the certificate.
 */
friendlyName: string;

/**
 * Gets the ASN.1 DER encoded certificate blob.
 * @return The ASN.1 DER encoded certificate blob.
 */
getCertificateBlob(): Windows$Storage$Streams$IBuffer;

/**
 * Gets the hash value for the certificate for a specified algorithm.
 * @param hashAlgorithmName The hash algorithm to use for the hash value of the certificate. Only values of "SHA1" or "SHA256" are supported.
 * @return The hash value of the certificate.
 */
getHashValue(hashAlgorithmName: string): number[];

/**
 * Gets the SHA1 hash value for the certificate.
 * @return The SHA1 hash value for the certificate.
 */
getHashValue(): number[];

/**
 * Gets a value indicating whether the certificate has a private key.
 */
hasPrivateKey: boolean;

/**
 * Gets whether the security device is bound.
 */
isSecurityDeviceBound: boolean;

/**
 * Gets a value that indicates whether the private key associated with the certificate is strongly protected.
 */
isStronglyProtected: boolean;

/**
 * Gets the name of the certificate issuer.
 */
issuer: string;

/**
 * Gets the name of the cryptographic algorithm used to create the key.
 */
keyAlgorithmName: string;

/**
 * Gets the key uses for the certificate.
 */
keyUsages: Windows$Security$Cryptography$Certificates$CertificateKeyUsages;

/**
 * Gets the serial number of the certificate.
 */
serialNumber: number;

/**
 * Gets the signature algorithm name.
 */
signatureAlgorithmName: string;

/**
 * Gets the signature hash algorithm name.
 */
signatureHashAlgorithmName: string;

/**
 * Gets the subject name of the certificate.
 */
subject: string;

/**
 * Gets info on the subject alternative name.
 */
subjectAlternativeName: Windows$Security$Cryptography$Certificates$SubjectAlternativeNameInfo;

/**
 * Gets the date and time after which the certificate is valid.
 */
validFrom: Date;

/**
 * Gets the date and time after which the certificate is no longer valid.
 */
validTo: Date
}


/**
 * Represents a certificate chain used for signature verification.
 */
declare class Windows$Security$Cryptography$Certificates$CertificateChain  {

/**
 * Gets the list of certificates from the certificate chain.
 * @param includeRoot True to include the root certificate in the results; otherwise false.
 * @return The list of certificates from the certificate chain.
 */
getCertificates(
includeRoot: boolean): Windows$Foundation$Collections$IVectorView<Windows$Security$Cryptography$Certificates$Certificate>;

/**
 * Verifies whether or not the certificate chain is valid.
 * @return The result of the certificate chain verification operation.
 */
validate(
): $Values<typeof Windows$Security$Cryptography$Certificates$ChainValidationResult>;

/**
 * Verifies whether or not the certificate chain is valid using the specified validation parameters.
 * @param parameter The validation parameters to use when verifying the certificate chain.
 * @return The result of the certificate chain verification operation.
 */
validate(
parameter: Windows$Security$Cryptography$Certificates$ChainValidationParameters): $Values<typeof Windows$Security$Cryptography$Certificates$ChainValidationResult>
}


/**
 * Describes the policy to use when performing a certificate chain validation.
 */

declare  var Windows$Security$Cryptography$Certificates$CertificateChainPolicy: {|
  +base: 0,// 0
+ssl: 1,// 1
+ntAuthentication: 2,// 2
+microsoftRoot: 3,// 3

|};



/**
 * Represents a certificate enrollment manager.
 */
declare class Windows$Security$Cryptography$Certificates$CertificateEnrollmentManager  {

/**
 * Asynchronously creates a PKCS #10 certificate request based on properties specified in a CertificateRequestProperties object.
 * @param request A CertificateRequestProperties object that contains the property values used to create the certificate request.
 * @return This method returns a string that contains the base64 encoded PKCS #10 certificate request.
 */
static createRequestAsync(
request: Windows$Security$Cryptography$Certificates$CertificateRequestProperties): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Asynchronously imports a certificate from a Personal Information Exchange (PFX) message.
 * @param pfxData Base64-encoded PFX message.
 * @param password The password used to decrypt and verify the PFX packet. The password must be exactly the same as the password that was used to encrypt the packet.
 * @param exportable A value of the ExportOption enumeration that specifies whether the key can be exported.
 * @param keyProtectionLevel A value of the KeyProtectionLevel enumeration that specifies the strength of the key protection. The default is NoConsent.
 * @param installOption An InstallOptions enumeration value that specifies the certificate installation option.
 * @param friendlyName The display name of the enrolled certificate. This value overwrites the FriendlyName property inside the PFX message.
 * @return This method does not return a value.
 */
static importPfxDataAsync(
pfxData: string,
password: string,
exportable: $Values<typeof Windows$Security$Cryptography$Certificates$ExportOption>,
keyProtectionLevel: $Values<typeof Windows$Security$Cryptography$Certificates$KeyProtectionLevel>,
installOption: $Values<typeof Windows$Security$Cryptography$Certificates$InstallOptions>,
friendlyName: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously imports a certificate from a Personal Information Exchange (PFX) message using the specified key storage provider.
 * @param pfxData Base64-encoded PFX message.
 * @param password The password used to decrypt and verify the PFX packet. The password must be exactly the same as the password that was used to encrypt the packet.
 * @param exportable A value of the ExportOption enumeration that specifies whether the key can be exported.
 * @param keyProtectionLevel A value of the KeyProtectionLevel enumeration that specifies the strength of the key protection. The default is NoConsent.
 * @param installOption An InstallOptions enumeration value that specifies the certificate installation option.
 * @param friendlyName The display name of the enrolled certificate. This value overwrites the FriendlyName property inside the PFX message.
 * @param keyStorageProvider The name of the key storage provider to use when importing the certificate.
 * @return This method does not return a value.
 */
static importPfxDataAsync(
pfxData: string,
password: string,
exportable: $Values<typeof Windows$Security$Cryptography$Certificates$ExportOption>,
keyProtectionLevel: $Values<typeof Windows$Security$Cryptography$Certificates$KeyProtectionLevel>,
installOption: $Values<typeof Windows$Security$Cryptography$Certificates$InstallOptions>,
friendlyName: string,
keyStorageProvider: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously imports a certificate from a Personal Information Exchange (PFX) message using import parameters.
 * @param pfxData Base64-encoded PFX message.
 * @param password The password used to decrypt and verify the PFX packet. The password must be exactly the same as the password that was used to encrypt the packet.
 * @param pfxImportParameters The PFX import parameters.
 * @return This method does not return a value.
 */
static importPfxDataAsync(
pfxData: string,
password: string,
pfxImportParameters: Windows$Security$Cryptography$Certificates$PfxImportParameters): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously Installs a certificate chain into the app container on the local computer.
 * @param certificate The encoded certificate. The certificate is encoded by using Distinguished Encoding Rules (DER) as defined by the Abstract Syntax Notation One (ASN.1) standard.
 * @param installOption An InstallOptions enumeration value that specifies the certificate installation option.
 * @return This method does not return a value.
 */
static installCertificateAsync(
certificate: string,
installOption: $Values<typeof Windows$Security$Cryptography$Certificates$InstallOptions>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the associated UserCertificateEnrollmentManager .
 */
static userCertificateEnrollmentManager: Windows$Security$Cryptography$Certificates$UserCertificateEnrollmentManager
}


/**
 * Represents the usages of a certificate key.
 */
declare class Windows$Security$Cryptography$Certificates$CertificateKeyUsages  {

/**
 * Creates a new instance of the CertificateKeyUsages class.
 */
constructor(): this;

/**
 * Gets or sets if the key is for cRLSign.
 */
crlSign: boolean;

/**
 * Gets or sets if the key is for data encipherment.
 */
dataEncipherment: boolean;

/**
 * Gets or sets if the key is for digital signature.
 */
digitalSignature: boolean;

/**
 * Gets or sets if the key is for encipher only.
 */
encipherOnly: boolean;

/**
 * Gets or sets if the key is for key agreement.
 */
keyAgreement: boolean;

/**
 * Gets or sets if the key is for key certificate sign.
 */
keyCertificateSign: boolean;

/**
 * Gets or sets if the key is for key encipherment.
 */
keyEncipherment: boolean;

/**
 * Gets or sets if the key is for non-repudiation.
 */
nonRepudiation: boolean
}


/**
 * Represents parameters for a query for certificates from the certificate store for an app.
 */
declare class Windows$Security$Cryptography$Certificates$CertificateQuery  {

/**
 * Creates a new instance of a certificate query.
 */
constructor(): this;

/**
 * Gets a collection of object identifiers (OIDs) for the enhanced key usage extension to search for.
 */
enhancedKeyUsages: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets or sets the certificate friendly name to search for.
 */
friendlyName: string;

/**
 * Gets or sets a value that indicates whether only hardware certificates (SC or TPM) are to be returned from the query.
 */
hardwareOnly: boolean;

/**
 * Gets or sets whether to include duplicates.
 */
includeDuplicates: boolean;

/**
 * Gets or sets whether to include expired certificates.
 */
includeExpiredCertificates: boolean;

/**
 * Gets or sets the name of the certificate issuer to search for.
 */
issuerName: string;

/**
 * Gets or sets the store name.
 */
storeName: string;

/**
 * Gets or sets a certificate thumbprint to search for.
 */
thumbprint: number
}


/**
 * Represents the properties of a certificate request.
 */
declare class Windows$Security$Cryptography$Certificates$CertificateRequestProperties  {

/**
 * Creates and initializes a new instance of the CertificateRequestProperties .
 */
constructor(): this;

/**
 * Gets or sets the CA exchange certificate that is used to encrypt a key attestation certificate request.
 */
attestationCredentialCertificate: Windows$Security$Cryptography$Certificates$Certificate;

/**
 * Gets or sets the container name.
 */
containerName: string;

/**
 * Gets or sets the prefix of the container name.
 */
containerNamePrefix: string;

/**
 * Gets or sets the name of the elliptic curve.
 */
curveName: string;

/**
 * Gets or sets the parameters of the elliptic curve.
 */
curveParameters: number;

/**
 * Gets or sets a value that specifies whether the private key created for the request can be exported.
 */
exportable: $Values<typeof Windows$Security$Cryptography$Certificates$ExportOption>;

/**
 * Gets or sets the display name of the enrolled certificate.
 */
friendlyName: string;

/**
 * Gets or sets the hash algorithm used when creating the certificate request signature.
 */
hashAlgorithmName: string;

/**
 * Gets or sets the public key algorithm.
 */
keyAlgorithmName: string;

/**
 * Gets or sets the level of strong key protection.
 */
keyProtectionLevel: $Values<typeof Windows$Security$Cryptography$Certificates$KeyProtectionLevel>;

/**
 * Gets or sets the size, in bits, of the private key to be generated.
 */
keySize: number;

/**
 * Gets or sets the name of the key storage provider (KSP) that will be used to generate the private key.
 */
keyStorageProviderName: string;

/**
 * Gets or sets the operation that can be performed by the private key created for this certificate request. The default value is Signing.
 */
keyUsages: $Values<typeof Windows$Security$Cryptography$Certificates$EnrollKeyUsages>;

/**
 * Gets or sets the certificate used to sign the certificate request.
 */
signingCertificate: Windows$Security$Cryptography$Certificates$Certificate;

/**
 * Gets or sets the name of the smart card reader used to create the certificate request.
 */
smartcardReaderName: string;

/**
 * Gets or sets the subject name.
 */
subject: string;

/**
 * Gets or sets whether to use the existing key.
 */
useExistingKey: boolean
}


/**
 * Represents a certificate store for an app.
 */
declare class Windows$Security$Cryptography$Certificates$CertificateStore  {

/**
 * Adds a certificate to the certificate store.
 * @param certificate The certificate to add to the certificate store.
 */
add(certificate: Windows$Security$Cryptography$Certificates$Certificate): void;

/**
 * Deletes a certificate from the certificate store.
 * @param certificate The certificate to delete from the certificate store.
 */
delete(certificate: Windows$Security$Cryptography$Certificates$Certificate): void;

/**
 * Gets the name of the certificate store.
 */
name: string
}


/**
 * Represents a collection of certificate stores.
 */
declare class Windows$Security$Cryptography$Certificates$CertificateStores  {

/**
 * Get all certificates from the certificate stores that match the specified query parameters.
 * @param query The certificate values to search for.
 * @return An asynchronous operation to retrieve the list of certificates.
 */
static findAllAsync(
query: Windows$Security$Cryptography$Certificates$CertificateQuery): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Get all certificates from the certificate stores.
 * @return An asynchronous operation to retrieve the list of certificates.
 */
static findAllAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets a certificate store from the collection of certificate stores by name.
 * @param storeName The name of the certificate store to return. The storeName parameter value cannot be "MY".
 * @return The requested certificate store.
 */
static getStoreByName(storeName: string): Windows$Security$Cryptography$Certificates$CertificateStore;

/**
 * Gets the certificate store of intermediate certification authorities for an app.
 */
static intermediateCertificationAuthorities: Windows$Security$Cryptography$Certificates$CertificateStore;

/**
 * Gets the certificate store of trusted root certificates for an app.
 */
static trustedRootCertificationAuthorities: Windows$Security$Cryptography$Certificates$CertificateStore
}


/**
 * Represents parameters to use when building a certificate chain.
 */
declare class Windows$Security$Cryptography$Certificates$ChainBuildingParameters  {

/**
 * Creates a new instance of the ChainBuildingParameters class.
 */
constructor(): this;

/**
 * Gets or sets a value that indicates whether Authority Information Access (AIA) is enabled.
 */
authorityInformationAccessEnabled: boolean;

/**
 * Gets or sets a value indicating that the current time is to be used for the validation timestamp.
 */
currentTimeValidationEnabled: boolean;

/**
 * Gets a collection of object identifiers (OIDs) for the enhanced key usage extension.
 */
enhancedKeyUsages: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets the list of root certificates that will be trusted.
 */
exclusiveTrustRoots: Windows$Foundation$Collections$IVector<Windows$Security$Cryptography$Certificates$Certificate>;

/**
 * Gets or sets a value indicating whether to request new URLs to use for chain building and revocation checking or to use cached URLs.
 */
networkRetrievalEnabled: boolean;

/**
 * Gets or sets a value indicating whether revocation checking is enabled.
 */
revocationCheckEnabled: boolean;

/**
 * Gets or sets the time stamp used to determine whether the certificate chain was time valid.
 */
validationTimestamp: Date
}


/**
 * Represents values to use when verifying a certificate chain.
 */
declare class Windows$Security$Cryptography$Certificates$ChainValidationParameters  {

/**
 * Creates a new instance of the ChainValidationParameters class.
 */
constructor(): this;

/**
 * Gets or sets the certificate chain policy to use when verifying the certificate chain.
 */
certificateChainPolicy: $Values<typeof Windows$Security$Cryptography$Certificates$CertificateChainPolicy>;

/**
 * Gets or sets the server DNS name to use for SSL policy.
 */
serverDnsName: Windows$Networking$HostName
}


/**
 * Describes the result of a certificate chain verification operation.
 */

declare  var Windows$Security$Cryptography$Certificates$ChainValidationResult: {|
  +success: 0,// 0
+untrusted: 1,// 1
+revoked: 2,// 2
+expired: 3,// 3
+incompleteChain: 4,// 4
+invalidSignature: 5,// 5
+wrongUsage: 6,// 6
+invalidName: 7,// 7
+invalidCertificateAuthorityPolicy: 8,// 8
+basicConstraintsError: 9,// 9
+unknownCriticalExtension: 10,// 10
+revocationInformationMissing: 11,// 11
+revocationFailure: 12,// 12
+otherErrors: 13,// 13

|};



/**
 * Represents a signature attached to a signed CMS message.
 */
declare class Windows$Security$Cryptography$Certificates$CmsAttachedSignature  {

/**
 * Signs the specified input data using the specified signer information and creates an attached signed CMS message.
 * @param data The input data to be signed.
 * @param signers The signer information used to compute the signature.
 * @param certificates The list of certificates to build the chain for the signer certificates.
 * @return An asynchronous operation to retrieve the attached signed CMS message.
 */
static generateSignatureAsync(
data: Windows$Storage$Streams$IBuffer,
signers: Windows$Foundation$Collections$IIterable<Windows$Security$Cryptography$Certificates$CmsSignerInfo>,
certificates: Windows$Foundation$Collections$IIterable<Windows$Security$Cryptography$Certificates$Certificate>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>;

/**
 * Creates a new instance of the CmsAttachedSignature class for the specified signed CMS message.
 * @param inputBlob A signed CMS message blob.
 */
constructor(inputBlob: Windows$Storage$Streams$IBuffer): this;

/**
 * Gets the list of certificates that are used for chain building for the signer certificate.
 */
certificates: Windows$Foundation$Collections$IVectorView<Windows$Security$Cryptography$Certificates$Certificate>;

/**
 * Gets the content of the signed CMS message.
 */
content: number;

/**
 * Gets the list of signers that are used for creating or verifying the signature.
 */
signers: Windows$Foundation$Collections$IVectorView<Windows$Security$Cryptography$Certificates$CmsSignerInfo>;

/**
 * Verifies the signature contained in the signed CMS message.
 * @return The result of the signature verification operation.
 */
verifySignature(
): $Values<typeof Windows$Security$Cryptography$Certificates$SignatureValidationResult>
}


/**
 * Represents a detached signature for a signed CMS message.
 */
declare class Windows$Security$Cryptography$Certificates$CmsDetachedSignature  {

/**
 * Signs the specified input data using the specified signer information and creates a detached signed CMS message.
 * @param data The input data to be signed.
 * @param signers The signer information used to compute the signature.
 * @param certificates The list of certificates to build the chain for the signer certificates.
 * @return An asynchronous operation to retrieve the detached signed CMS message.
 */
static generateSignatureAsync(
data: Windows$Storage$Streams$IInputStream,
signers: Windows$Foundation$Collections$IIterable<Windows$Security$Cryptography$Certificates$CmsSignerInfo>,
certificates: Windows$Foundation$Collections$IIterable<Windows$Security$Cryptography$Certificates$Certificate>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>;

/**
 * Creates a new instance of the CmsDetachedSignature class for the specified signed CMS message.
 * @param inputBlob A signed CMS message blob.
 */
constructor(inputBlob: Windows$Storage$Streams$IBuffer): this;

/**
 * Gets the list of certificates that are used for chain building for the signer certificate.
 */
certificates: Windows$Foundation$Collections$IVectorView<Windows$Security$Cryptography$Certificates$Certificate>;

/**
 * Gets the list of signers that are used for creating or verifying the signature.
 */
signers: Windows$Foundation$Collections$IVectorView<Windows$Security$Cryptography$Certificates$CmsSignerInfo>;

/**
 * Verifies a signed CMS message against the original streaming input.
 * @param data The original input stream for the signed CMS message.
 * @return An asynchronous operation to retrieve the result of the signature validation operation.
 */
verifySignatureAsync(
data: Windows$Storage$Streams$IInputStream): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Security$Cryptography$Certificates$SignatureValidationResult>>
}


/**
 * Represents signer information for a signed CMS message which contains a set of properties.
 */
declare class Windows$Security$Cryptography$Certificates$CmsSignerInfo  {

/**
 * Creates a new instance of the CmsSignerInfo class.
 */
constructor(): this;

/**
 * Gets or sets the signer certificate that is used to sign the message.
 */
certificate: Windows$Security$Cryptography$Certificates$Certificate;

/**
 * Gets or sets the hash algorithm that is used to sign the CMS message.
 */
hashAlgorithmName: string;

/**
 * Gets the RFC3161 unauthenticated timestamp information.
 */
timestampInfo: Windows$Security$Cryptography$Certificates$CmsTimestampInfo
}


/**
 * Represents an RFC3161 unauthenticated timestamp attribute in a signed CMS message.
 */
declare class Windows$Security$Cryptography$Certificates$CmsTimestampInfo  {

/**
 * Gets the list of certificates that is used for chain building for the signing certificate.
 */
certificates: Windows$Foundation$Collections$IVectorView<Windows$Security$Cryptography$Certificates$Certificate>;

/**
 * Gets the certificate that is used to sign the timestamp.
 */
signingCertificate: Windows$Security$Cryptography$Certificates$Certificate;

/**
 * Gets the date and time of the timestamp.
 */
timestamp: Date
}


/**
 * Specifies the cryptographic operations that can be performed by the private key. This enumeration type is used in the KeyUsages property of a CertificateRequestProperties object.
 */

declare  var Windows$Security$Cryptography$Certificates$EnrollKeyUsages: {|
  +none: 0,// 0
+decryption: 1,// 1
+signing: 2,// 2
+keyAgreement: 3,// 3
+all: 4,// 4

|};



/**
 * Specifies whether a private key can be exported. This enumeration type is used in the Exportable property of a CertificateRequestProperties object.
 */

declare  var Windows$Security$Cryptography$Certificates$ExportOption: {|
  +notExportable: 0,// 0
+exportable: 1,// 1

|};



/**
 * Specifies certificate installation options. This enumeration type is used by the InstallCertificateAsync and ImportPfxDataAsync methods.
 */

declare  var Windows$Security$Cryptography$Certificates$InstallOptions: {|
  +none: 0,// 0
+deleteExpired: 1,// 1

|};



/**
 * Defines several commonly used public key algorithm names. You can use this class in the KeyAlgorithmName property on the CertificateRequestProperties class.
 */
declare class Windows$Security$Cryptography$Certificates$KeyAlgorithmNames  {

/**
 * Returns "DSA" as the key algorithm name.
 */
static dsa: string;

/**
 * Returns "ECDH" as the key algorithm name.
 */
static ecdh: string;

/**
 * Returns "ECDH256" as the key algorithm name.
 */
static ecdh256: string;

/**
 * Returns "ECDH384" as the key algorithm name.
 */
static ecdh384: string;

/**
 * Returns "ECDH521" as the key algorithm name.
 */
static ecdh521: string;

/**
 * Returns "ECDSA" as the key algorithm name.
 */
static ecdsa: string;

/**
 * Returns "ECDSA256" as the key algorithm name.
 */
static ecdsa256: string;

/**
 * Returns "ECDSA384" as the key algorithm name.
 */
static ecdsa384: string;

/**
 * Returns "ECDSA521" as the key algorithm name.
 */
static ecdsa521: string;

/**
 * Returns "RSA" as the key algorithm name.
 */
static rsa: string
}


/**
 * Provides access to key attestation methods.
 */
declare class Windows$Security$Cryptography$Certificates$KeyAttestationHelper  {

/**
 * Decrypts a TPM key attestation credential.
 * @param credential The TPM key attestation credential to decrypt.
 * @return When this method completes, it returns the decrypted TPM key attestation credential.
 */
static decryptTpmAttestationCredentialAsync(credential: string): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Decrypts a TPM key attestation credential.
 * @param credential The TPM key attestation credential to decrypt.
 * @param containerName The container name of the credential.
 * @return When this method completes, it returns the decrypted TPM key attestation credential.
 */
static decryptTpmAttestationCredentialAsync(
credential: string,
containerName: string): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Gets the credential ID from a TPM key attestation credential.
 * @param credential The TPM key attestation credential to get the credential ID from.
 * @return The credential ID from the TPM key attestation credential.
 */
static getTpmAttestationCredentialId(credential: string): string
}


/**
 * Specifies the key protection level. This enumeration type is used in the KeyProtectionLevel property of a CertificateRequestProperties object.
 */

declare  var Windows$Security$Cryptography$Certificates$KeyProtectionLevel: {|
  +noConsent: 0,// 0
+consentOnly: 1,// 1
+consentWithPassword: 2,// 2
+consentWithFingerprint: 3,// 3

|};



/**
 * Specifies commonly used RSA algorithm key sizes. This enumeration type can be used in the KeySize property of a CertificateRequestProperties object.
 */

declare  var Windows$Security$Cryptography$Certificates$KeySize: {|
  +invalid: 0,// 0
+rsa2048: 1,// 1
+rsa4096: 2,// 2

|};



/**
 * Defines several commonly used key storage provider names. You can use this class in the KeyStorageProviderName property on the CertificateRequestProperties class.
 */
declare class Windows$Security$Cryptography$Certificates$KeyStorageProviderNames  {

/**
 * Returns "Microsoft Passport Key Storage Provider" as the provider name.
 */
static passportKeyStorageProvider: string;

/**
 * Returns "Microsoft Platform Crypyto Key Storage Provider" as the provider name.
 */
static platformKeyStorageProvider: string;

/**
 * Returns "Microsoft Smart Card Key Storage Provider" as the provider name.
 */
static smartcardKeyStorageProvider: string;

/**
 * Returns "Microsoft Software Key Storage Provider" as the provider name.
 */
static softwareKeyStorageProvider: string
}


/**
 * Represents PFX import parameters.
 */
declare class Windows$Security$Cryptography$Certificates$PfxImportParameters  {

/**
 * Creates a new instance of the PfxImportParameters class.
 */
constructor(): this;

/**
 * Gets or sets the container name prefix.
 */
containerNamePrefix: string;

/**
 * Gets or sets the export option.
 */
exportable: $Values<typeof Windows$Security$Cryptography$Certificates$ExportOption>;

/**
 * Gets or sets the friendly name.
 */
friendlyName: string;

/**
 * Gets or sets the install options.
 */
installOptions: $Values<typeof Windows$Security$Cryptography$Certificates$InstallOptions>;

/**
 * Gets or sets the key protection level.
 */
keyProtectionLevel: $Values<typeof Windows$Security$Cryptography$Certificates$KeyProtectionLevel>;

/**
 * Gets or sets the key storage provider name.
 */
keyStorageProviderName: string;

/**
 * Gets or sets the reader name.
 */
readerName: string
}


/**
 * Describes the result of a signature verification operation.
 */

declare  var Windows$Security$Cryptography$Certificates$SignatureValidationResult: {|
  +success: 0,// 0
+invalidParameter: 1,// 1
+badMessage: 2,// 2
+invalidSignature: 3,// 3
+otherErrors: 4,// 4

|};



/**
 * Provides info about a subject alternative name.
 */
declare class Windows$Security$Cryptography$Certificates$SubjectAlternativeNameInfo  {

/**
 * Creates a new instance of the SubjectAlternativeNameInfo class.
 */
constructor(): this;

/**
 * Gets the distinguished name.
 */
distinguishedName: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the DNS name.
 */
dnsName: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the email name.
 */
emailName: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the IP address.
 */
ipAddress: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the principal name.
 */
principalName: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the URL.
 */
url: Windows$Foundation$Collections$IVectorView<string>
}


/**
 * Provides access to certificate creation, import, and enrollment methods.
 */
declare class Windows$Security$Cryptography$Certificates$UserCertificateEnrollmentManager  {

/**
 * Asynchronously creates a PKCS #10 certificate request based on properties specified in a CertificateRequestProperties object.
 * @param request A CertificateRequestProperties object that contains the property values used to create the certificate request.
 * @return An asynchronous operation to retrieve the base64 encoded PKCS #10 certificate request.
 */
createRequestAsync(
request: Windows$Security$Cryptography$Certificates$CertificateRequestProperties): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Asynchronously imports a user certificate from a Personal Information Exchange (PFX) message.
 * @param pfxData Base64-encoded PFX message.
 * @param password The password used to decrypt and verify the PFX packet. The password must be exactly the same as the password that was used to encrypt the packet.
 * @param exportable A value of the ExportOption enumeration that specifies whether the key can be exported.
 * @param keyProtectionLevel A value of the KeyProtectionLevel enumeration that specifies the strength of the key protection. The default is NoConsent.
 * @param installOption An InstallOptions enumeration value that specifies the certificate installation option.
 * @param friendlyName The display name of the enrolled certificate. This value overwrites the FriendlyName property inside the PFX message.
 * @return This method does not return a value.
 */
importPfxDataAsync(
pfxData: string,
password: string,
exportable: $Values<typeof Windows$Security$Cryptography$Certificates$ExportOption>,
keyProtectionLevel: $Values<typeof Windows$Security$Cryptography$Certificates$KeyProtectionLevel>,
installOption: $Values<typeof Windows$Security$Cryptography$Certificates$InstallOptions>,
friendlyName: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously imports a certificate from a Personal Information Exchange (PFX) message using the specified key storage provider.
 * @param pfxData Base64-encoded PFX message.
 * @param password The password used to decrypt and verify the PFX packet. The password must be exactly the same as the password that was used to encrypt the packet.
 * @param exportable A value of the ExportOption enumeration that specifies whether the key can be exported.
 * @param keyProtectionLevel A value of the KeyProtectionLevel enumeration that specifies the strength of the key protection. The default is NoConsent.
 * @param installOption An InstallOptions enumeration value that specifies the certificate installation option.
 * @param friendlyName The display name of the enrolled certificate. This value overwrites the FriendlyName property inside the PFX message.
 * @param keyStorageProvider The name of the key storage provider to use when importing the certificate.
 * @return This method does not return a value.
 */
importPfxDataAsync(
pfxData: string,
password: string,
exportable: $Values<typeof Windows$Security$Cryptography$Certificates$ExportOption>,
keyProtectionLevel: $Values<typeof Windows$Security$Cryptography$Certificates$KeyProtectionLevel>,
installOption: $Values<typeof Windows$Security$Cryptography$Certificates$InstallOptions>,
friendlyName: string,
keyStorageProvider: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously imports a certificate from a Personal Information Exchange (PFX) message using the specified import parameters.
 * @param pfxData Base64-encoded PFX message.
 * @param password he password used to decrypt and verify the PFX packet. The password must be exactly the same as the password that was used to encrypt the packet.
 * @param pfxImportParameters The import parameters.
 * @return This method does not return a value.
 */
importPfxDataAsync(
pfxData: string,
password: string,
pfxImportParameters: Windows$Security$Cryptography$Certificates$PfxImportParameters): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously installs a certificate chain into the app container on the local computer.
 * @param certificate The encoded certificate. The certificate is encoded by using Distinguished Encoding Rules (DER) as defined by the Abstract Syntax Notation One (ASN.1) standard.
 * @param installOption An InstallOptions enumeration value that specifies the certificate installation option.
 * @return This method does not return a value.
 */
installCertificateAsync(
certificate: string,
installOption: $Values<typeof Windows$Security$Cryptography$Certificates$InstallOptions>): Windows$Foundation$IPromiseWithIAsyncAction
}


      declare var npm$namespace$Windows$Security$Cryptography$Core: {
        
        
        Capi1KdfTargetAlgorithm: typeof Windows$Security$Cryptography$Core$Capi1KdfTargetAlgorithm,
CryptographicPadding: typeof Windows$Security$Cryptography$Core$CryptographicPadding,
CryptographicPrivateKeyBlobType: typeof Windows$Security$Cryptography$Core$CryptographicPrivateKeyBlobType,
CryptographicPublicKeyBlobType: typeof Windows$Security$Cryptography$Core$CryptographicPublicKeyBlobType,
        AsymmetricAlgorithmNames: typeof Windows$Security$Cryptography$Core$AsymmetricAlgorithmNames,
AsymmetricKeyAlgorithmProvider: typeof Windows$Security$Cryptography$Core$AsymmetricKeyAlgorithmProvider,
CryptographicEngine: typeof Windows$Security$Cryptography$Core$CryptographicEngine,
CryptographicHash: typeof Windows$Security$Cryptography$Core$CryptographicHash,
CryptographicKey: typeof Windows$Security$Cryptography$Core$CryptographicKey,
EccCurveNames: typeof Windows$Security$Cryptography$Core$EccCurveNames,
EncryptedAndAuthenticatedData: typeof Windows$Security$Cryptography$Core$EncryptedAndAuthenticatedData,
HashAlgorithmNames: typeof Windows$Security$Cryptography$Core$HashAlgorithmNames,
HashAlgorithmProvider: typeof Windows$Security$Cryptography$Core$HashAlgorithmProvider,
KeyDerivationAlgorithmNames: typeof Windows$Security$Cryptography$Core$KeyDerivationAlgorithmNames,
KeyDerivationAlgorithmProvider: typeof Windows$Security$Cryptography$Core$KeyDerivationAlgorithmProvider,
KeyDerivationParameters: typeof Windows$Security$Cryptography$Core$KeyDerivationParameters,
MacAlgorithmNames: typeof Windows$Security$Cryptography$Core$MacAlgorithmNames,
MacAlgorithmProvider: typeof Windows$Security$Cryptography$Core$MacAlgorithmProvider,
PersistedKeyProvider: typeof Windows$Security$Cryptography$Core$PersistedKeyProvider,
SymmetricAlgorithmNames: typeof Windows$Security$Cryptography$Core$SymmetricAlgorithmNames,
SymmetricKeyAlgorithmProvider: typeof Windows$Security$Cryptography$Core$SymmetricKeyAlgorithmProvider,
        
      }

/**
 * Contains static properties that enable you to retrieve algorithm names that can be used in the OpenAlgorithm method of the AsymmetricKeyAlgorithmProvider class.
 */
declare class Windows$Security$Cryptography$Core$AsymmetricAlgorithmNames  {

/**
 * Retrieves a string that contains "DSA_SHA1".
 */
static dsaSha1: string;

/**
 * Retrieves a string that contains "DSA_SHA256".
 */
static dsaSha256: string;

/**
 * Retrieves a string that contains "ECDSA_P256_SHA256".
 */
static ecdsaP256Sha256: string;

/**
 * Retrieves a string that contains "ECDSA_P384_SHA384".
 */
static ecdsaP384Sha384: string;

/**
 * Retrieves a string that contains "ECDSA_P521_SHA512".
 */
static ecdsaP521Sha512: string;

/**
 * Retrieves a string that contains "ECDSA_SHA256".
 */
static ecdsaSha256: string;

/**
 * Retrieves a string that contains "ECDSA_SHA384".
 */
static ecdsaSha384: string;

/**
 * Retrieves a string that contains "ECDSA_SHA512".
 */
static ecdsaSha512: string;

/**
 * Retrieves a string that contains "RSA_OAEP_SHA1".
 */
static rsaOaepSha1: string;

/**
 * Retrieves a string that contains "RSA_OAEP_SHA256".
 */
static rsaOaepSha256: string;

/**
 * Retrieves a string that contains "RSA_OAEP_SHA384".
 */
static rsaOaepSha384: string;

/**
 * Retrieves a string that contains "RSA_OAEP_SHA512".
 */
static rsaOaepSha512: string;

/**
 * Retrieves a string that contains "RSA_PKCS1".
 */
static rsaPkcs1: string;

/**
 * Retrieves a string that contains "RSASIGN_PKCS1_SHA1".
 */
static rsaSignPkcs1Sha1: string;

/**
 * Retrieves a string that contains "RSASIGN_PKCS1_SHA256".
 */
static rsaSignPkcs1Sha256: string;

/**
 * Retrieves a string that contains "RSASIGN_PKCS1_SHA384".
 */
static rsaSignPkcs1Sha384: string;

/**
 * Retrieves a string that contains "RSASIGN_PSS_SHA512".
 */
static rsaSignPkcs1Sha512: string;

/**
 * Retrieves a string that contains "RSASIGN_PSS_SHA1".
 */
static rsaSignPssSha1: string;

/**
 * Retrieves a string that contains "RSASIGN_PSS_SHA256".
 */
static rsaSignPssSha256: string;

/**
 * Retrieves a string that contains "RSASIGN_PSS_SHA384".
 */
static rsaSignPssSha384: string;

/**
 * Retrieves a string that contains "RSASIGN_PSS_SHA512".
 */
static rsaSignPssSha512: string
}


/**
 * Represents a provider of asymmetric (public) key algorithms. For more information, see Cryptographic keys.
 */
declare class Windows$Security$Cryptography$Core$AsymmetricKeyAlgorithmProvider  {

/**
 * Creates an instance of the AsymmetricKeyAlgorithmProvider class and opens the specified algorithm for use.
 * @param algorithm Algorithm name.
 * @return Represents a public key algorithm provider.
 */
static openAlgorithm(
algorithm: string): Windows$Security$Cryptography$Core$AsymmetricKeyAlgorithmProvider;

/**
 * Gets the name of the open asymmetric algorithm.
 */
algorithmName: string;

/**
 * Creates a public/private key pair.
 * @param keySize Size, in bits, of the key. Typical key sizes are 512, 1024, 2048, or 4096 bits.
 * @return Represents the asymmetric key pair.
 */
createKeyPair(keySize: number): Windows$Security$Cryptography$Core$CryptographicKey;

/**
 * Creates a public/private key pair using a curve name.
 * @param curveName The name of the curve.
 * @return Represents the asymmetric key pair.
 */
createKeyPairWithCurveName(curveName: string): Windows$Security$Cryptography$Core$CryptographicKey;

/**
 * Creates a public/private key pair using curve parameters.
 * @param parameters The curve parameters.
 * @return Represents the asymmetric key pair.
 */
createKeyPairWithCurveParameters(parameters: number[]): Windows$Security$Cryptography$Core$CryptographicKey;

/**
 * Imports a public/private key pair from a buffer.
 * @param keyBlob Buffer that contains the key pair to import.
 * @return Represents the imported key pair.
 */
importKeyPair(
keyBlob: Windows$Storage$Streams$IBuffer): Windows$Security$Cryptography$Core$CryptographicKey;

/**
 * Imports a public/private key pair from a buffer in the specified format.
 * @param keyBlob Buffer that contains the key pair to import.
 * @param BlobType A CryptographicPrivateKeyBlobType enumeration value that specifies information about the private key contained in the keyBlob buffer. The default value is Pkcs8RawPrivateKeyInfo.
 * @return Represents the imported key pair.
 */
importKeyPair(
keyBlob: Windows$Storage$Streams$IBuffer,
BlobType: $Values<typeof Windows$Security$Cryptography$Core$CryptographicPrivateKeyBlobType>): Windows$Security$Cryptography$Core$CryptographicKey;

/**
 * Imports a public key into a buffer.
 * @param keyBlob Buffer that contains the key to import.
 * @return Represents the imported key.
 */
importPublicKey(
keyBlob: Windows$Storage$Streams$IBuffer): Windows$Security$Cryptography$Core$CryptographicKey;

/**
 * Imports a public key into a buffer for a specified format.
 * @param keyBlob Buffer that contains the key to import.
 * @param BlobType A CryptographicPublicKeyBlobType enumeration value that specifies the format of the public key contained in the keyBlob buffer. The default value is X509SubjectPublicKeyInfo.
 * @return Represents the imported key.
 */
importPublicKey(
keyBlob: Windows$Storage$Streams$IBuffer,
BlobType: $Values<typeof Windows$Security$Cryptography$Core$CryptographicPublicKeyBlobType>): Windows$Security$Cryptography$Core$CryptographicKey
}


/**
 * Represents information about a target algorithm.
 */

declare  var Windows$Security$Cryptography$Core$Capi1KdfTargetAlgorithm: {|
  +notAes: 0,// 0
+aes: 1,// 1

|};



/**
 * Encrypts, decrypts, and signs content, and verifies digital signatures.
 */
declare class Windows$Security$Cryptography$Core$CryptographicEngine  {

/**
 * Decrypts content that was previously encrypted by using a symmetric or asymmetric algorithm.
 * @param key Cryptographic key to use for decryption. This can be an asymmetric or a symmetric key. For more information, see AsymmetricKeyAlgorithmProvider and SymmetricKeyAlgorithmProvider .
 * @param data Buffer that contains the encrypted data.
 * @param iv Buffer that contains the initialization vector. If an initialization vector (IV) was used to encrypt the data, you must use the same IV to decrypt the data. For more information, see Encrypt .
 * @return Decrypted data.
 */
static decrypt(
key: Windows$Security$Cryptography$Core$CryptographicKey,
data: Windows$Storage$Streams$IBuffer,
iv: Windows$Storage$Streams$IBuffer): Windows$Storage$Streams$IBuffer;

/**
 * Decrypts and authenticates data. For more information and a complete code sample, see EncryptedAndAuthenticatedData .
 * @param key Symmetric key to use.
 * @param data Data to be decrypted and authenticated.
 * @param nonce Nonce to be used. This must be the same nonce used by the EncryptAndAuthenticate method.
 * @param authenticationTag Authentication tag.
 * @param authenticatedData Authenticated data. This can be Null.
 * @return A buffer that contains the decrypted data.
 */
static decryptAndAuthenticate(
key: Windows$Security$Cryptography$Core$CryptographicKey,
data: Windows$Storage$Streams$IBuffer,
nonce: Windows$Storage$Streams$IBuffer,
authenticationTag: Windows$Storage$Streams$IBuffer,
authenticatedData: Windows$Storage$Streams$IBuffer): Windows$Storage$Streams$IBuffer;

/**
 * Decrypts the encrypted input data using the supplied key.
 * @param key The key to use to decrypt the encrypted input data.
 * @param data The encrypted data to decrypt.
 * @param iv The initial vector for a symmetric key. For an asymmetric key, set this value to null.
 * @return The decrypted data.
 */
static decryptAsync(
key: Windows$Security$Cryptography$Core$CryptographicKey,
data: Windows$Storage$Streams$IBuffer,
iv: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>;

/**
 * Derives a key from another key by using a key derivation function. For more information, see the KeyDerivationAlgorithmProvider and KeyDerivationParameters classes.
 * @param key The symmetric or secret key used for derivation.
 * @param parameters Derivation parameters. The parameters vary depending on the type of KDF algorithm used.
 * @param desiredKeySize Requested size, in bytes, of the derived key.
 * @return Buffer that contains the derived key.
 */
static deriveKeyMaterial(
key: Windows$Security$Cryptography$Core$CryptographicKey,
parameters: Windows$Security$Cryptography$Core$KeyDerivationParameters,
desiredKeySize: number): Windows$Storage$Streams$IBuffer;

/**
 * Encrypts data by using a symmetric or asymmetric algorithm.
 * @param key Cryptographic key to use for encryption. This can be an asymmetric or a symmetric key. For more information, see AsymmetricKeyAlgorithmProvider and SymmetricKeyAlgorithmProvider .
 * @param data Data to encrypt.
 * @param iv Buffer that contains the initialization vector. This can be null for a symmetric algorithm and should always be null for an asymmetric algorithm. If an initialization vector (IV) was used to encrypt the data, you must use the same IV to decrypt the data. You can use the GenerateRandom method to create an IV that contains random data. Other IVs, such as nonce-generated vectors, require custom implementation. For more information, see Cryptographic keys.
 * @return Encrypted data.
 */
static encrypt(
key: Windows$Security$Cryptography$Core$CryptographicKey,
data: Windows$Storage$Streams$IBuffer,
iv: Windows$Storage$Streams$IBuffer): Windows$Storage$Streams$IBuffer;

/**
 * Performs authenticated encryption.
 * @param key Symmetric key to use for encryption.
 * @param data Data to be encrypted and authenticated.
 * @param nonce Nonce to be used. A nonce is a variable that has minimal chance of repeating. For example, you can use a random value that is newly generated for each use, a time stamp, a sequence number, or some combination of these. The Microsoft GCM implementation requires a 12-byte nonce. The CCM implementation requires a 7- to 13- byte nonce.
 * @param authenticatedData Authenticated data. This can be Null.
 * @return The encrypted and authenticated data.
 */
static encryptAndAuthenticate(
key: Windows$Security$Cryptography$Core$CryptographicKey,
data: Windows$Storage$Streams$IBuffer,
nonce: Windows$Storage$Streams$IBuffer,
authenticatedData: Windows$Storage$Streams$IBuffer): Windows$Security$Cryptography$Core$EncryptedAndAuthenticatedData;

/**
 * Signs digital content. For more information, see MACs, hashes, and signatures.
 * @param key Key used for signing.
 * @param data Data to be signed.
 * @return The data's signature.
 */
static sign(
key: Windows$Security$Cryptography$Core$CryptographicKey,
data: Windows$Storage$Streams$IBuffer): Windows$Storage$Streams$IBuffer;

/**
 * Computes a hash for the supplied input data, and then signs the computed hash using the specified key.
 * @param key The key to use to compute and sign the hash.
 * @param data The raw input data to sign. The data is not hashed.
 * @return An asynchronous operation to retrieve the hashed and signed data.
 */
static signAsync(
key: Windows$Security$Cryptography$Core$CryptographicKey,
data: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>;

/**
 * Signs the hashed input data using the specified key.
 * @param key The key to use to sign the hash. This key must be an asymmetric key obtained from a PersistedKeyProvider or AsymmetricKeyAlgorithmProvider .
 * @param data The input data to sign. The data is a hashed value which can be obtained through incremental hash.
 * @return The signed data.
 */
static signHashedData(
key: Windows$Security$Cryptography$Core$CryptographicKey,
data: Windows$Storage$Streams$IBuffer): Windows$Storage$Streams$IBuffer;

/**
 * Signs the hashed input data using the specified key.
 * @param key The key to use to sign the hash. This key must be an asymmetric key obtained from a PersistedKeyProvider or AsymmetricKeyAlgorithmProvider .
 * @param data The input data to sign. The data is a hashed value which can be obtained through incremental hash.
 * @return An asynchronous operation to retrieve the signed data.
 */
static signHashedDataAsync(
key: Windows$Security$Cryptography$Core$CryptographicKey,
data: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>;

/**
 * Verifies a message signature.
 * @param key Key used for verification. This must be the same key previously used to sign the message.
 * @param data Message to be verified.
 * @param signature Signature previously computed over the message to be verified.
 * @return true if the message is verified.
 */
static verifySignature(
key: Windows$Security$Cryptography$Core$CryptographicKey,
data: Windows$Storage$Streams$IBuffer,
signature: Windows$Storage$Streams$IBuffer): boolean;

/**
 * Verifies the signature of the specified input data against a known signature.
 * @param key The key to use to retrieve the signature from the input data. This key must be an asymmetric key obtained from a PersistedKeyProvider or AsymmetricKeyAlgorithmProvider .
 * @param data The data to be verified. The data is a hashed value of raw data.
 * @param signature The known signature to use to verify the signature of the input data.
 * @return True if the signature is verified; otherwise false.
 */
static verifySignatureWithHashInput(
key: Windows$Security$Cryptography$Core$CryptographicKey,
data: Windows$Storage$Streams$IBuffer,
signature: Windows$Storage$Streams$IBuffer): boolean
}


/**
 * Represents a reusable hashing object and contains the result of a hashing operation.
 */
declare class Windows$Security$Cryptography$Core$CryptographicHash  {

/**
 * Appends a binary encoded string to the data stored in the CryptographicHash object.
 * @param data Data to append.
 */
append(data: Windows$Storage$Streams$IBuffer): void;

/**
 * Gets hashed data from the CryptographicHash object and resets the object.
 * @return Hashed data.
 */
getValueAndReset(): Windows$Storage$Streams$IBuffer
}


/**
 * Represents a symmetric key or an asymmetric key pair.
 */
declare class Windows$Security$Cryptography$Core$CryptographicKey  {

/**
 * Exports the key pair to a buffer.
 * @return Buffer that contains the key pair.
 */
export(): Windows$Storage$Streams$IBuffer;

/**
 * Exports the key pair to a buffer given a specified format.
 * @param BlobType A CryptographicPrivateKeyBlobType enumeration value that specifies the format of the key in the buffer. The default value is Pkcs8RawPrivateKeyInfo.
 * @return Buffer that contains the key pair.
 */
export(
BlobType: $Values<typeof Windows$Security$Cryptography$Core$CryptographicPrivateKeyBlobType>): Windows$Storage$Streams$IBuffer;

/**
 * Exports a public key to a buffer.
 * @return Buffer that contains the public key.
 */
exportPublicKey(): Windows$Storage$Streams$IBuffer;

/**
 * Exports a public key to a buffer given a specified format.
 * @param BlobType A CryptographicPublicKeyBlobType enumeration value that specifies the format of the key in the buffer. The default value is X509SubjectPublicKeyInfo.
 * @return Buffer that contains the public key.
 */
exportPublicKey(
BlobType: $Values<typeof Windows$Security$Cryptography$Core$CryptographicPublicKeyBlobType>): Windows$Storage$Streams$IBuffer;

/**
 * Gets the size, in bits, of the key.
 */
keySize: number
}


/**
 * Specifies a padding mode for asymmetric algorithm signature or encryption operations.
 */

declare  var Windows$Security$Cryptography$Core$CryptographicPadding: {|
  +none: 0,// 0
+rsaOaep: 1,// 1
+rsaPkcs1V15: 2,// 2
+rsaPss: 3,// 3

|};



/**
 * Specifies the type of the private key contained in a buffer.
 */

declare  var Windows$Security$Cryptography$Core$CryptographicPrivateKeyBlobType: {|
  +pkcs8RawPrivateKeyInfo: 0,// 0
+pkcs1RsaPrivateKey: 1,// 1
+bcryptPrivateKey: 2,// 2
+capi1PrivateKey: 3,// 3
+bcryptEccFullPrivateKey: 4,// 4

|};



/**
 * Specifies the type of the public key contained in a buffer.
 */

declare  var Windows$Security$Cryptography$Core$CryptographicPublicKeyBlobType: {|
  +x509SubjectPublicKeyInfo: 0,// 0
+pkcs1RsaPublicKey: 1,// 1
+bcryptPublicKey: 2,// 2
+capi1PublicKey: 3,// 3
+bcryptEccFullPublicKey: 4,// 4

|};



/**
 * Contains static properties that enable you to retrieve supported elliptic curve cryptography (ECC) algorithm names.
 */
declare class Windows$Security$Cryptography$Core$EccCurveNames  {

/**
 * Gets an array of strings that represents all the curves registered on the local computer. This includes curves that were registered by the local administrator.
 */
static allEccCurveNames: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Retrieves a string that contains "BRAINPOOLP160R1".
 */
static brainpoolP160r1: string;

/**
 * Retrieves a string that contains "BRAINPOOLP160T1".
 */
static brainpoolP160t1: string;

/**
 * Retrieves a string that contains "BRAINPOOLP192R1".
 */
static brainpoolP192r1: string;

/**
 * Retrieves a string that contains "BRAINPOOLP192T1".
 */
static brainpoolP192t1: string;

/**
 * Retrieves a string that contains "BRAINPOOLP224R1".
 */
static brainpoolP224r1: string;

/**
 * Retrieves a string that contains "BRAINPOOLP224T1".
 */
static brainpoolP224t1: string;

/**
 * Retrieves a string that contains "BRAINPOOLP256R1".
 */
static brainpoolP256r1: string;

/**
 * Retrieves a string that contains "BRAINPOOLP256T1".
 */
static brainpoolP256t1: string;

/**
 * Retrieves a string that contains "BRAINPOOLP320R1".
 */
static brainpoolP320r1: string;

/**
 * Retrieves a string that contains "BRAINPOOLP320T1".
 */
static brainpoolP320t1: string;

/**
 * Retrieves a string that contains "BRAINPOOLP384R1".
 */
static brainpoolP384r1: string;

/**
 * Retrieves a string that contains "BRAINPOOLP384T1".
 */
static brainpoolP384t1: string;

/**
 * Retrieves a string that contains "BRAINPOOLP512R1".
 */
static brainpoolP512r1: string;

/**
 * Retrieves a string that contains "BRAINPOOLP512T1".
 */
static brainpoolP512t1: string;

/**
 * Retrieves a string that contains "CURVE25519".
 */
static curve25519: string;

/**
 * Retrieves a string that contains "EC192WAPI".
 */
static ec192wapi: string;

/**
 * Retrieves a string that contains "NISTP192".
 */
static nistP192: string;

/**
 * Retrieves a string that contains "NISTP224".
 */
static nistP224: string;

/**
 * Retrieves a string that contains "NISTP256".
 */
static nistP256: string;

/**
 * Retrieves a string that contains "NISTP384".
 */
static nistP384: string;

/**
 * Retrieves a string that contains "NISTP521".
 */
static nistP521: string;

/**
 * Retrieves a string that contains "NUMSP256T1".
 */
static numsP256t1: string;

/**
 * Retrieves a string that contains "NUMSP384T1".
 */
static numsP384t1: string;

/**
 * Retrieves a string that contains "NUMSP512T1".
 */
static numsP512t1: string;

/**
 * Retrieves a string that contains "SECP160K1".
 */
static secP160k1: string;

/**
 * Retrieves a string that contains "SECP160R1".
 */
static secP160r1: string;

/**
 * Retrieves a string that contains "SECP160R2".
 */
static secP160r2: string;

/**
 * Retrieves a string that contains "SECP192K1".
 */
static secP192k1: string;

/**
 * Retrieves a string that contains "SECP192R1".
 */
static secP192r1: string;

/**
 * Retrieves a string that contains "SECP224K1".
 */
static secP224k1: string;

/**
 * Retrieves a string that contains "SECP224R1".
 */
static secP224r1: string;

/**
 * Retrieves a string that contains "SecP256k1".
 */
static secP256k1: string;

/**
 * Retrieves a string that contains "SecP256r1".
 */
static secP256r1: string;

/**
 * Retrieves a string that contains "SecP384r1".
 */
static secP384r1: string;

/**
 * Retrieves a string that contains "SecP521r1".
 */
static secP521r1: string;

/**
 * Retrieves a string that contains "WTLS12".
 */
static wtls12: string;

/**
 * Retrieves a string that contains "WTLS7".
 */
static wtls7: string;

/**
 * Retrieves a string that contains "WTLS9".
 */
static wtls9: string;

/**
 * Retrieves a string that contains "X962P192v1".
 */
static x962P192v1: string;

/**
 * Retrieves a string that contains "X962P192v2".
 */
static x962P192v2: string;

/**
 * Retrieves a string that contains "X962P192v3".
 */
static x962P192v3: string;

/**
 * Retrieves a string that contains "X962P239v1".
 */
static x962P239v1: string;

/**
 * Retrieves a string that contains "X962P239v2".
 */
static x962P239v2: string;

/**
 * Retrieves a string that contains "X962P239v3".
 */
static x962P239v3: string;

/**
 * Retrieves a string that contains "X962P256v1".
 */
static x962P256v1: string
}


/**
 * Contains data that can be retrieved from encrypted and authenticated data. Authenticated encryption algorithms are opened by using the SymmetricKeyAlgorithmProvider class.
 */
declare class Windows$Security$Cryptography$Core$EncryptedAndAuthenticatedData  {

/**
 * Gets the authentication tag.
 */
authenticationTag: Windows$Storage$Streams$IBuffer;

/**
 * Gets the encrypted data.
 */
encryptedData: Windows$Storage$Streams$IBuffer
}


/**
 * Contains static properties that enable you to retrieve algorithm names that can be used in the OpenAlgorithm method of the HashAlgorithmProvider class.
 */
declare class Windows$Security$Cryptography$Core$HashAlgorithmNames  {

/**
 * Retrieves a string that contains "MD5".
 */
static md5: string;

/**
 * Retrieves a string that contains "SHA1".
 */
static sha1: string;

/**
 * Retrieves a string that contains "SHA256".
 */
static sha256: string;

/**
 * Retrieves a string that contains "SHA384".
 */
static sha384: string;

/**
 * Retrieves a string that contains "SHA512".
 */
static sha512: string
}


/**
 * Represents a cryptographic hash provider. For more information about hashes, see MACs, hashes, and signatures.
 */
declare class Windows$Security$Cryptography$Core$HashAlgorithmProvider  {

/**
 * Creates a HashAlgorithmProvider object and opens the specified algorithm for use.
 * @param algorithm Algorithm name.
 * @return Represents a provider that implements hash algorithms.
 */
static openAlgorithm(algorithm: string): Windows$Security$Cryptography$Core$HashAlgorithmProvider;

/**
 * Gets the name of the open hash algorithm.
 */
algorithmName: string;

/**
 * Creates a reusable CryptographicHash object.
 * @return Reusable hash object.
 */
createHash(): Windows$Security$Cryptography$Core$CryptographicHash;

/**
 * Hashes binary data.
 * @param data Data to be hashed.
 * @return Hashed data.
 */
hashData(data: Windows$Storage$Streams$IBuffer): Windows$Storage$Streams$IBuffer;

/**
 * Gets the length, in bytes, of the hash.
 */
hashLength: number
}


/**
 * Contains static properties that enable you to retrieve algorithm names that can be used in the OpenAlgorithm method of the KeyDerivationAlgorithmProvider class.
 */
declare class Windows$Security$Cryptography$Core$KeyDerivationAlgorithmNames  {

/**
 * Retrieves a string that contains "CAPI_KDF_MD5".
 */
static capiKdfMd5: string;

/**
 * Retrieves a string that contains "CAPI_KDF_SHA1".
 */
static capiKdfSha1: string;

/**
 * Retrieves a string that contains "CAPI_KDF_SHA256".
 */
static capiKdfSha256: string;

/**
 * Retrieves a string that contains "CAPI_KDF_SHA384".
 */
static capiKdfSha384: string;

/**
 * Retrieves a string that contains "CAPI_KDF_SHA512".
 */
static capiKdfSha512: string;

/**
 * Retrieves a string that contains "PBKDF2_MD5".
 */
static pbkdf2Md5: string;

/**
 * Retrieves a string that contains "PBKDF2_SHA1".
 */
static pbkdf2Sha1: string;

/**
 * Retrieves a string that contains "PBKDF2_SHA256".
 */
static pbkdf2Sha256: string;

/**
 * Retrieves a string that contains "PBKDF2_SHA384".
 */
static pbkdf2Sha384: string;

/**
 * Retrieves a string that contains "PBKDF2_SHA512".
 */
static pbkdf2Sha512: string;

/**
 * Retrieves a string that contains "SP800_108_CTR_HMAC_MD5".
 */
static sp800108CtrHmacMd5: string;

/**
 * Retrieves a string that contains "SP800_108_CTR_HMAC_SHA1".
 */
static sp800108CtrHmacSha1: string;

/**
 * Retrieves a string that contains "SP800_108_CTR_HMAC_SHA256".
 */
static sp800108CtrHmacSha256: string;

/**
 * Retrieves a string that contains "SP800_108_CTR_HMAC_SHA384".
 */
static sp800108CtrHmacSha384: string;

/**
 * Retrieves a string that contains "SP800_108_CTR_HMAC_SHA512".
 */
static sp800108CtrHmacSha512: string;

/**
 * Retrieves a string that contains "SP800_56A_CONCAT_MD5".
 */
static sp80056aConcatMd5: string;

/**
 * Retrieves a string that contains "SP800_56A_CONCAT_SHA1".
 */
static sp80056aConcatSha1: string;

/**
 * Retrieves a string that contains "SP800_108_CTR_HMAC_SHA256".
 */
static sp80056aConcatSha256: string;

/**
 * Retrieves a string that contains "SP800_108_CTR_HMAC_SHA384".
 */
static sp80056aConcatSha384: string;

/**
 * Retrieves a string that contains "SP800_56A_CONCAT_SHA512".
 */
static sp80056aConcatSha512: string
}


/**
 * Represents a key derivation algorithm provider.
 */
declare class Windows$Security$Cryptography$Core$KeyDerivationAlgorithmProvider  {

/**
 * Creates an instance of the KeyDerivationAlgorithmProvider class and opens the specified algorithm for use.
 * @param algorithm Represents a KDF algorithm provider.
 * @return The algorithm provider.
 */
static openAlgorithm(
algorithm: string): Windows$Security$Cryptography$Core$KeyDerivationAlgorithmProvider;

/**
 * Gets the name of the open key derivation function (KDF) algorithm.
 */
algorithmName: string;

/**
 * Creates a KDF key.
 * @param keyMaterial Data used to create the key.
 * @return Represents the KDF key.
 */
createKey(
keyMaterial: Windows$Storage$Streams$IBuffer): Windows$Security$Cryptography$Core$CryptographicKey
}


/**
 * Represents parameters used when deriving a key.
 */
declare class Windows$Security$Cryptography$Core$KeyDerivationParameters  {

/**
 * Creates a KeyDerivationParameters object for use in the target algorithm.
 * @param capi1KdfTargetAlgorithm The target algorithm.
 * @return Refers to the parameters used during key derivation.
 */
static buildForCapi1Kdf(
capi1KdfTargetAlgorithm: $Values<typeof Windows$Security$Cryptography$Core$Capi1KdfTargetAlgorithm>): Windows$Security$Cryptography$Core$KeyDerivationParameters;

/**
 * Creates a KeyDerivationParameters object for use in the password-based key derivation function 2 (PBKDF2).
 * @param pbkdf2Salt The salt, a random or pseudorandom value to be combined with the password in multiple iterations. A salt is used to increase entropy above what can be obtained from using a password alone.
 * @param iterationCount Number of iterations to be used to derive a key.
 * @return Refers to the parameters used during key derivation.
 */
static buildForPbkdf2(
pbkdf2Salt: Windows$Storage$Streams$IBuffer,
iterationCount: number): Windows$Security$Cryptography$Core$KeyDerivationParameters;

/**
 * Creates a KeyDerivationParameters object for use in a counter mode, hash-based message authentication code (HMAC) key derivation function.
 * @param label Buffer that specifies the purpose for the derived keying material.
 * @param context Buffer that specifies information related to the derived keying material. For example, the context can identify the parties who are deriving the keying material and, optionally, a nonce known by the parties.
 * @return Refers to the parameters used during key derivation.
 */
static buildForSP800108(
label: Windows$Storage$Streams$IBuffer,
context: Windows$Storage$Streams$IBuffer): Windows$Security$Cryptography$Core$KeyDerivationParameters;

/**
 * Creates a KeyDerivationParameters object for use in the SP800-56A key derivation function.
 * @param algorithmId Specifies the intended purpose of the derived key.
 * @param partyUInfo Contains public information contributed by the initiator.
 * @param partyVInfo Contains public information contributed by the responder.
 * @param suppPubInfo Contains public information known to both initiator and responder.
 * @param suppPrivInfo Contains private information known to both initiator and responder, such as a shared secret.
 * @return Refers to the parameters used during key derivation.
 */
static buildForSP80056a(
algorithmId: Windows$Storage$Streams$IBuffer,
partyUInfo: Windows$Storage$Streams$IBuffer,
partyVInfo: Windows$Storage$Streams$IBuffer,
suppPubInfo: Windows$Storage$Streams$IBuffer,
suppPrivInfo: Windows$Storage$Streams$IBuffer): Windows$Security$Cryptography$Core$KeyDerivationParameters;

/**
 * Gets or sets the Capi1KdfTargetAlgorithm .
 */
capi1KdfTargetAlgorithm: $Values<typeof Windows$Security$Cryptography$Core$Capi1KdfTargetAlgorithm>;

/**
 * Retrieves the number of iterations used to derive the key. For more information, see BuildForPbkdf2 .
 */
iterationCount: number;

/**
 * Gets or sets the parameters used by the key derivation algorithm.
 */
kdfGenericBinary: Windows$Storage$Streams$IBuffer
}


/**
 * Contains static properties that enable you to retrieve algorithm names that can be used in the OpenAlgorithm method of the MacAlgorithmProvider class.
 */
declare class Windows$Security$Cryptography$Core$MacAlgorithmNames  {

/**
 * Retrieves a string that contains "AES_CMAC".
 */
static aesCmac: string;

/**
 * Retrieves a string that contains "HMAC_MD5".
 */
static hmacMd5: string;

/**
 * Retrieves a string that contains "HMAC_SHA1".
 */
static hmacSha1: string;

/**
 * Retrieves a string that contains "HMAC_SHA256".
 */
static hmacSha256: string;

/**
 * Retrieves a string that contains "HMAC_SHA384".
 */
static hmacSha384: string;

/**
 * Retrieves a string that contains "HMAC_SHA512".
 */
static hmacSha512: string
}


/**
 * Represents a message authentication code (MAC). A MAC uses symmetric key cryptography to prevent message tampering. For more information, see MACs, hashes, and signatures.
 */
declare class Windows$Security$Cryptography$Core$MacAlgorithmProvider  {

/**
 * Creates a MacAlgorithmProvider object and opens the specified algorithm for use.
 * @param algorithm Algorithm name.
 * @return Represents a provider that implements MAC algorithms.
 */
static openAlgorithm(algorithm: string): Windows$Security$Cryptography$Core$MacAlgorithmProvider;

/**
 * Gets the name of the open MAC algorithm.
 */
algorithmName: string;

/**
 * Creates a CryptographicHash object that supports incremental hash operations.
 * @param keyMaterial Random data used to help generate the hash. You can call the GenerateRandom method to create the random data.
 * @return A CryptographicHash object that supports incremental hash operations.
 */
createHash(
keyMaterial: Windows$Storage$Streams$IBuffer): Windows$Security$Cryptography$Core$CryptographicHash;

/**
 * Creates a symmetric key that can be used to create the MAC value.
 * @param keyMaterial Random data used to help generate the key. You can call the GenerateRandom method to create the random data.
 * @return Symmetric key.
 */
createKey(
keyMaterial: Windows$Storage$Streams$IBuffer): Windows$Security$Cryptography$Core$CryptographicKey;

/**
 * Gets the length, in bytes, of the message authentication code.
 */
macLength: number
}


/**
 * Retrieves a persisted key from a Certificate object.
 */
declare class Windows$Security$Cryptography$Core$PersistedKeyProvider  {

/**
 * Opens the persisted private key from the specified Certificate object.
 * @param certificate The certificate that is associated with the private key.
 * @param hashAlgorithmName The hash algorithm for signature operations. For encryption, the hash algorithm is ignored.
 * @param padding The padding mode for asymmetric algorithm signature or encryption operations.
 * @return An asynchronous operation for retrieving a private key from the supplied Certificate object.
 */
static openKeyPairFromCertificateAsync(
certificate: Windows$Security$Cryptography$Certificates$Certificate,
hashAlgorithmName: string,
padding: $Values<typeof Windows$Security$Cryptography$Core$CryptographicPadding>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$Cryptography$Core$CryptographicKey>;

/**
 * Opens the persisted public key from the specified Certificate object.
 * @param certificate The certificate that contains the public key.
 * @param hashAlgorithmName The has algorithm for signature operations.
 * @param padding The padding mode for asymmetric algorithm signature or encryption operations.
 * @return The public key retrieved from the supplied Certificate object.
 */
static openPublicKeyFromCertificate(
certificate: Windows$Security$Cryptography$Certificates$Certificate,
hashAlgorithmName: string,
padding: $Values<typeof Windows$Security$Cryptography$Core$CryptographicPadding>): Windows$Security$Cryptography$Core$CryptographicKey
}


/**
 * Contains static properties that enable you to retrieve algorithm names that can be used in the OpenAlgorithm method of the SymmetricKeyAlgorithmProvider class.
 */
declare class Windows$Security$Cryptography$Core$SymmetricAlgorithmNames  {

/**
 * Retrieves a string that contains "AES_CBC".
 */
static aesCbc: string;

/**
 * Retrieves a string that contains "AES_CBC_PKCS7".
 */
static aesCbcPkcs7: string;

/**
 * Retrieves a string that contains "AES_CCM".
 */
static aesCcm: string;

/**
 * Retrieves a string that contains "AES_ECB".
 */
static aesEcb: string;

/**
 * Retrieves a string that contains "AES_ECB_PKCS7".
 */
static aesEcbPkcs7: string;

/**
 * Retrieves a string that contains "AES_CCM".
 */
static aesGcm: string;

/**
 * Retrieves a string that contains "DES_CBC".
 */
static desCbc: string;

/**
 * Retrieves a string that contains "DES_CBC_PKCS7".
 */
static desCbcPkcs7: string;

/**
 * Retrieves a string that contains "DES_ECB".
 */
static desEcb: string;

/**
 * Retrieves a string that contains "DES_ECB_PKCS7".
 */
static desEcbPkcs7: string;

/**
 * Retrieves a string that contains "RC2_CBC".
 */
static rc2Cbc: string;

/**
 * Retrieves a string that contains "RC2_CBC_PKCS7".
 */
static rc2CbcPkcs7: string;

/**
 * Retrieves a string that contains "RC2_ECB".
 */
static rc2Ecb: string;

/**
 * Retrieves a string that contains "RC2_ECB_PKCS7".
 */
static rc2EcbPkcs7: string;

/**
 * Retrieves a string that contains "RC4".
 */
static rc4: string;

/**
 * Retrieves a string that contains "3DES_CBC".
 */
static tripleDesCbc: string;

/**
 * Retrieves a string that contains "3DES_CBC_PKCS7".
 */
static tripleDesCbcPkcs7: string;

/**
 * Retrieves a string that contains "3DES_ECB".
 */
static tripleDesEcb: string;

/**
 * Retrieves a string that contains "3DES_ECB_PKCS7".
 */
static tripleDesEcbPkcs7: string
}


/**
 * Represents a provider of symmetric key algorithms. For more information, see Cryptographic keys.
 */
declare class Windows$Security$Cryptography$Core$SymmetricKeyAlgorithmProvider  {

/**
 * Creates an instance of the SymmetricKeyAlgorithmProvider class and opens the specified algorithm for use.
 * @param algorithm Algorithm name.
 * @return Represents a symmetric key algorithm provider.
 */
static openAlgorithm(
algorithm: string): Windows$Security$Cryptography$Core$SymmetricKeyAlgorithmProvider;

/**
 * Gets the name of the open symmetric algorithm.
 */
algorithmName: string;

/**
 * Gets the size, in bytes, of the cipher block for the open algorithm.
 */
blockLength: number;

/**
 * Creates a symmetric key.
 * @param keyMaterial Data used to generate the key. You can call the GenerateRandom method to create random key material.
 * @return Symmetric key.
 */
createSymmetricKey(
keyMaterial: Windows$Storage$Streams$IBuffer): Windows$Security$Cryptography$Core$CryptographicKey
}


/**
 * Contains static methods that implement data management functionality common to cryptographic operations.
 */
declare class Windows$Security$Cryptography$CryptographicBuffer  {

/**
 * Compares two IBuffer objects.
 * @param object1 Buffer to be used for comparison.
 * @param object2 Buffer to be used for comparison.
 * @return True specifies that the buffers are equal. Two buffers are equal if each code point in one matches the corresponding code point in the other.
 */
static compare(
object1: Windows$Storage$Streams$IBuffer,
object2: Windows$Storage$Streams$IBuffer): boolean;

/**
 * Converts a buffer to an encoded string.
 * @param encoding Encoding format.
 * @param buffer Data to be encoded.
 * @return A string that contains the encoded data.
 */
static convertBinaryToString(
encoding: $Values<typeof Windows$Security$Cryptography$BinaryStringEncoding>,
buffer: Windows$Storage$Streams$IBuffer): string;

/**
 * Converts a string to an encoded buffer.
 * @param value String to be encoded.
 * @param encoding Encoding format.
 * @return Encoded buffer.
 */
static convertStringToBinary(
value: string,
encoding: $Values<typeof Windows$Security$Cryptography$BinaryStringEncoding>): Windows$Storage$Streams$IBuffer;

/**
 * Copies a buffer to an array of bytes.
 * @param buffer Input buffer.
 * @return An array of bytes that contains the values copied from the input buffer. You must declare the array before calling this method and pass it by using the ref keyword. If the buffer for the input parameter is empty, then the value parameter will be returned as NULL.
 */
static copyToByteArray(buffer: Windows$Storage$Streams$IBuffer): number[];

/**
 * Creates a buffer from an input byte array.
 * @param value An array of bytes used to create the buffer.
 * @return Output buffer.
 */
static createFromByteArray(value: number[]): Windows$Storage$Streams$IBuffer;

/**
 * Decodes a string that has been base64 encoded.
 * @param value Base64 encoded input string.
 * @return Output buffer that contains the decoded string.
 */
static decodeFromBase64String(value: string): Windows$Storage$Streams$IBuffer;

/**
 * Decodes a string that has been hexadecimal encoded.
 * @param value Encoded input string.
 * @return Output buffer that contains the decoded string.
 */
static decodeFromHexString(value: string): Windows$Storage$Streams$IBuffer;

/**
 * Encodes a buffer to a base64 string.
 * @param buffer Input buffer.
 * @return Base64-encoded output string.
 */
static encodeToBase64String(buffer: Windows$Storage$Streams$IBuffer): string;

/**
 * Encodes a buffer to a hexadecimal string.
 * @param buffer Input buffer.
 * @return Hexadecimal encoded output string.
 */
static encodeToHexString(buffer: Windows$Storage$Streams$IBuffer): string;

/**
 * Creates a buffer that contains random data.
 * @param length Length, in bytes, of the buffer to create.
 * @return Output buffer that contains the random data.
 */
static generateRandom(length: number): Windows$Storage$Streams$IBuffer;

/**
 * Creates a random number.
 * @return Integer that contains the random data.
 */
static generateRandomNumber(): number
}


      declare var npm$namespace$Windows$Security$Cryptography$DataProtection: {
        
        
        
        DataProtectionProvider: typeof Windows$Security$Cryptography$DataProtection$DataProtectionProvider,
        
      }

/**
 * Represents a cryptographic provider that can be used to asynchronously encrypt and decrypt static data or a data stream.
 */
declare class Windows$Security$Cryptography$DataProtection$DataProtectionProvider  {

/**
 * Constructor used for encryption operations. Use this constructor before calling the ProtectAsync or ProtectStreamAsync methods.
 * @param protectionDescriptor Contains the protection descriptor that determines the entity to which the data will be encrypted. For more information, see Remarks.
 */
constructor(protectionDescriptor: string): this;

/**
 * Constructor used for decryption operations. Use this constructor before calling the UnprotectAsync or UnprotectStreamAsync methods.
 */
constructor(): this;

/**
 * Asynchronously protects static data.
 * @param data Data to protect.
 * @return Represents an asynchronous operation.
 */
protectAsync(
data: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>;

/**
 * Asynchronously protects a data stream.
 * @param src Stream to be protected.
 * @param dest Protected stream.
 * @return Represents an asynchronous action.
 */
protectStreamAsync(
src: Windows$Storage$Streams$IInputStream,
dest: Windows$Storage$Streams$IOutputStream): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously decrypts static data.
 * @param data Data to decrypt.
 * @return Represents an asynchronous operation.
 */
unprotectAsync(
data: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>;

/**
 * Asynchronously decrypts a data stream.
 * @param src Stream to decrypt.
 * @param dest Decrypted stream.
 * @return Represents an asynchronous action.
 */
unprotectStreamAsync(
src: Windows$Storage$Streams$IInputStream,
dest: Windows$Storage$Streams$IOutputStream): Windows$Foundation$IPromiseWithIAsyncAction
}


      declare var npm$namespace$Windows$Security$EnterpriseData: {
        
        
        DataProtectionStatus: typeof Windows$Security$EnterpriseData$DataProtectionStatus,
EnforcementLevel: typeof Windows$Security$EnterpriseData$EnforcementLevel,
FileProtectionStatus: typeof Windows$Security$EnterpriseData$FileProtectionStatus,
ProtectedImportExportStatus: typeof Windows$Security$EnterpriseData$ProtectedImportExportStatus,
ProtectionPolicyEvaluationResult: typeof Windows$Security$EnterpriseData$ProtectionPolicyEvaluationResult,
        BufferProtectUnprotectResult: typeof Windows$Security$EnterpriseData$BufferProtectUnprotectResult,
DataProtectionInfo: typeof Windows$Security$EnterpriseData$DataProtectionInfo,
DataProtectionManager: typeof Windows$Security$EnterpriseData$DataProtectionManager,
FileProtectionInfo: typeof Windows$Security$EnterpriseData$FileProtectionInfo,
FileProtectionManager: typeof Windows$Security$EnterpriseData$FileProtectionManager,
FileRevocationManager: typeof Windows$Security$EnterpriseData$FileRevocationManager,
ProtectedAccessResumedEventArgs: typeof Windows$Security$EnterpriseData$ProtectedAccessResumedEventArgs,
ProtectedAccessSuspendingEventArgs: typeof Windows$Security$EnterpriseData$ProtectedAccessSuspendingEventArgs,
ProtectedContainerExportResult: typeof Windows$Security$EnterpriseData$ProtectedContainerExportResult,
ProtectedContainerImportResult: typeof Windows$Security$EnterpriseData$ProtectedContainerImportResult,
ProtectedContentRevokedEventArgs: typeof Windows$Security$EnterpriseData$ProtectedContentRevokedEventArgs,
ProtectedFileCreateResult: typeof Windows$Security$EnterpriseData$ProtectedFileCreateResult,
ProtectionPolicyManager: typeof Windows$Security$EnterpriseData$ProtectionPolicyManager,
ThreadNetworkContext: typeof Windows$Security$EnterpriseData$ThreadNetworkContext,
        
      }

/**
 * Contains information about the result from protecting or unprotecting an enterprise protected buffer.
 */
declare class Windows$Security$EnterpriseData$BufferProtectUnprotectResult  {

/**
 * Gets the enterprise protected buffer that has been protected or unprotected.
 */
buffer: Windows$Storage$Streams$IBuffer;

/**
 * Gets the DataProtectionInfo object concerning the enterprise protected buffer that has been protected or unprotected.
 */
protectionInfo: Windows$Security$EnterpriseData$DataProtectionInfo
}


/**
 * Contains information about an enterprise protected buffer or stream.
 */
declare class Windows$Security$EnterpriseData$DataProtectionInfo  {

/**
 * The enterprise identity of the enterprise protected buffer or stream.
 */
identity: string;

/**
 * The protection status of the enterprise protected buffer or stream.
 */
status: $Values<typeof Windows$Security$EnterpriseData$DataProtectionStatus>
}


/**
 * Provides access to operations that manage buffers and streams that are protected to an enterprise identity.
 */
declare class Windows$Security$EnterpriseData$DataProtectionManager  {

/**
 * Get the status of an enterprise protected buffer.
 * @param protectedData The buffer for which protection status is being queried.
 * @return When the call to this method completes successfully, it returns a DataProtectionInfo object that contains the status of the buffer.
 */
static getProtectionInfoAsync(
protectedData: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$EnterpriseData$DataProtectionInfo>;

/**
 * Get the status of an enterprise protected stream.
 * @param protectedStream The stream for which protection status is being queried.
 * @return When the call to this method completes successfully, it returns a DataProtectionInfo object that contains the status of the stream.
 */
static getStreamProtectionInfoAsync(
protectedStream: Windows$Storage$Streams$IInputStream): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$EnterpriseData$DataProtectionInfo>;

/**
 * Protect the data in a buffer to an enterprise identity.
 * @param data The buffer to be protected.
 * @param identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @return When the call to this method completes successfully, it returns a BufferProtectUnprotectResult object that contains the status of the newly protected buffer.
 */
static protectAsync(
data: Windows$Storage$Streams$IBuffer,
identity: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$EnterpriseData$BufferProtectUnprotectResult>;

/**
 * Protect a stream of data to an enterprise identity.
 * @param unprotectedStream The input, unprotected stream.
 * @param identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @param protectedStream The output, protected stream.
 * @return When the call to this method completes successfully, it returns a DataProtectionInfo object that contains the status of the protected stream.
 */
static protectStreamAsync(
unprotectedStream: Windows$Storage$Streams$IInputStream,
identity: string,
protectedStream: Windows$Storage$Streams$IOutputStream): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$EnterpriseData$DataProtectionInfo>;

/**
 * Removes the protection to an enterprise identity from a buffer.
 * @param data The buffer to be unprotected.
 * @return When the call to this method completes successfully, it returns a BufferProtectUnprotectResult object that contains the status of the unprotected buffer.
 */
static unprotectAsync(
data: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$EnterpriseData$BufferProtectUnprotectResult>;

/**
 * Removes the protection to an enterprise identity from a stream of data.
 * @param protectedStream The input, protected stream.
 * @param unprotectedStream The output, unprotected stream.
 * @return When the call to this method completes successfully, it returns a DataProtectionInfo object that contains the status of the unprotected stream.
 */
static unprotectStreamAsync(
protectedStream: Windows$Storage$Streams$IInputStream,
unprotectedStream: Windows$Storage$Streams$IOutputStream): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$EnterpriseData$DataProtectionInfo>
}


/**
 * Describes the enterprise identity protection state of a buffer or stream.
 */

declare  var Windows$Security$EnterpriseData$DataProtectionStatus: {|
  +protectedToOtherIdentity: 0,// 0
+protected: 1,// 1
+revoked: 2,// 2
+unprotected: 3,// 3
+licenseExpired: 4,// 4
+accessSuspended: 5,// 5

|};



/**
 * A set of enumerated values together describing the possible enterprise data protection (EDP) enforcement levels. EDP enforcement level is one aspect of mobile device management (MDM) policy configuration.
 */

declare  var Windows$Security$EnterpriseData$EnforcementLevel: {|
  +noProtection: 0,// 0
+silent: 1,// 1
+override: 2,// 2
+block: 3,// 3

|};



/**
 * Contains information about an enterprise protected file.
 */
declare class Windows$Security$EnterpriseData$FileProtectionInfo  {

/**
 * The enterprise identity of the enterprise protected file.
 */
identity: string;

/**
 * Specifies if the protection of the enterprise protected file can be roamed to other devices.
 */
isRoamable: boolean;

/**
 * The protection status of the enterprise protected file.
 */
status: $Values<typeof Windows$Security$EnterpriseData$FileProtectionStatus>
}


/**
 * Provides access to operations that manage files that are protected to an enterprise identity.
 */
declare class Windows$Security$EnterpriseData$FileProtectionManager  {

/**
 * Replicate the file protection of one file onto another file.
 * @param source The source file, from which file protection is being copied.
 * @param target The target file, to which file protection is being copied.
 * @return When the call to this method completes successfully, it returns true if the file protection was copied, or false if there was an error.
 */
static copyProtectionAsync(
source: Windows$Storage$IStorageItem,
target: Windows$Storage$IStorageItem): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Create an enterprise-protected file.
 * @param parentFolder The folder into which to create the enterprise protected file.
 * @param desiredName The desired name of the new enterprise protected file.
 * @param identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @param collisionOption A CreationCollisionOption value that specifies what to do if desiredName already exists.
 * @return When the call to this method completes successfully, it returns a ProtectedFileCreateResult object representing the newly created protected file.
 */
static createProtectedAndOpenAsync(
parentFolder: Windows$Storage$IStorageFolder,
desiredName: string,
identity: string,
collisionOption: $Values<typeof Windows$Storage$CreationCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$EnterpriseData$ProtectedFileCreateResult>;

/**
 * Get the status of an enterprise-protected file.
 * @param source The file or folder for which protection status is being queried.
 * @return When the call to this method completes successfully, it returns a FileProtectionInfo object that contains the status of the file.
 */
static getProtectionInfoAsync(
source: Windows$Storage$IStorageItem): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$EnterpriseData$FileProtectionInfo>;
static isContainerAsync: any;

/**
 * Create an enterprise-protected file, and load it from a container file.
 * @param containerFile The enterprise protected file to be created and loaded.
 * @return When the call to this method completes successfully, it returns a ProtectedContainerImportResult object representing the newly created protected file.
 */
static loadFileFromContainerAsync(
containerFile: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$EnterpriseData$ProtectedContainerImportResult>;

/**
 * Create an enterprise-protected file in a specified storage item (such as a folder), and load it from a container file.
 * @param containerFile The enterprise protected file to be created and loaded.
 * @param target The storage item into which to create the enterprise protected file.
 * @return When the call to this method completes successfully, it returns a ProtectedContainerImportResult object representing the newly created protected file.
 */
static loadFileFromContainerAsync(
containerFile: Windows$Storage$IStorageFile,
target: Windows$Storage$IStorageItem): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$EnterpriseData$ProtectedContainerImportResult>;

/**
 * Create an enterprise-protected file in a specified storage item (such as a folder), and load it from a container file.
 * @param containerFile The enterprise protected file to be created and loaded.
 * @param target The storage item into which to create the enterprise protected file.
 * @param collisionOption The enum value that determines how Windows responds if the created file has the same name as an existing item in the container's location.
 * @return When the call to this method completes successfully, it returns a ProtectedContainerImportResult object representing the newly created protected file.
 */
static loadFileFromContainerAsync(
containerFile: Windows$Storage$IStorageFile,
target: Windows$Storage$IStorageItem,
collisionOption: $Values<typeof Windows$Storage$NameCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$EnterpriseData$ProtectedContainerImportResult>;

/**
 * Protect the data in a file to an enterprise identity. The app can then use standard APIs to read or write from the file.
 * @param target The file to be protected.
 * @param identity The enterprise identity. This is an email address or domain that is managed. Use ProtectionPolicyManager.IsIdentityManaged to confirm that an email address or domain is managed before using the identity to protect a file.
 * @return When the call to this method completes successfully, it returns a FileProtectionInfo object that contains the status of the newly protected file.
 */
static protectAsync(
target: Windows$Storage$IStorageItem,
identity: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$EnterpriseData$FileProtectionInfo>;

/**
 * Save an enterprise-protected file as a containerized version.
 * @param protectedFile The protected source file being copied.
 * @return When the call to this method completes successfully, it returns a ProtectedContainerExportResult object representing the newly created container file.
 */
static saveFileAsContainerAsync(
protectedFile: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$EnterpriseData$ProtectedContainerExportResult>;

/**
 * Save an enterprise-protected file as a containerized version, and share it with a specified list of user identities.
 * @param protectedFile The protected source file being copied.
 * @param sharedWithIdentities A collection of strings representing the user identities to share the containerized file with. For example, email recipients.
 * @return When the call to this method completes successfully, it returns a ProtectedContainerExportResult object representing the newly created container file.
 */
static saveFileAsContainerAsync(
protectedFile: Windows$Storage$IStorageFile,
sharedWithIdentities: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$EnterpriseData$ProtectedContainerExportResult>
}


/**
 * Describes the enterprise protection state of a file or folder.
 */

declare  var Windows$Security$EnterpriseData$FileProtectionStatus: {|
  +undetermined: 0,// 0
+unknown: 1,// 1
+unprotected: 2,// 2
+revoked: 3,// 3
+protected: 4,// 4
+protectedByOtherUser: 5,// 5
+protectedToOtherEnterprise: 6,// 6
+notProtectable: 7,// 7
+protectedToOtherIdentity: 8,// 8
+licenseExpired: 9,// 9
+accessSuspended: 10,// 10

|};



/**
 * Provides access to Selective Wipe operations.
 */
declare class Windows$Security$EnterpriseData$FileRevocationManager  {

/**
 * Copy the selective wipe protection state of a file or folder to a new file or folder.
 * @param sourceStorageItem The source item to copy the selective wipe protection status from.
 * @param targetStorageItem The target item to copy the selective wipe protection status to.
 * @return True if the copy operation was successful; otherwise false.
 */
static copyProtectionAsync(
sourceStorageItem: Windows$Storage$IStorageItem,
targetStorageItem: Windows$Storage$IStorageItem): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets the selective wipe protection status for a file or folder.
 * @param storageItem The file or folder to get the selective wipe protection status for.
 * @return An aysnchronous operation that retrieves the selective wipe protection status for the storageItem.
 */
static getStatusAsync(
storageItem: Windows$Storage$IStorageItem): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Security$EnterpriseData$FileProtectionStatus>>;

/**
 * Protects a file or folder for selective wipe.
 * @param storageItem The file or folder to protect for selective wipe.
 * @param enterpriseIdentity The enterprise id that the file or folder is protected for. The enterpriseIdentity value must be formatted as an Internationalized Domain Name (IDN) and cannot contain spaces. For example, contoso.com.
 * @return An asynchronous operation that retrieves the selective wipe protection status for the storageItem.
 */
static protectAsync(
storageItem: Windows$Storage$IStorageItem,
enterpriseIdentity: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Security$EnterpriseData$FileProtectionStatus>>;

/**
 * Revokes all files and folders protected for selective wipe for a specified enterprise id.
 * @param enterpriseIdentity Revoke all files and folders protected by selective wipe for this enterprise id. The enterpriseIdentity value must be formatted as an Internationalized Domain Name (IDN) and cannot contain spaces. For example, contoso.com.
 */
static revoke(enterpriseIdentity: string): void
}


/**
 * Provides data when content protection is resumed.
 */
declare class Windows$Security$EnterpriseData$ProtectedAccessResumedEventArgs  {

/**
 * Contains the enterprise identities for which content protection is being resumed.
 */
identities: Windows$Foundation$Collections$IVectorView<string>
}


/**
 * Provides data when content protection is being suspended.
 */
declare class Windows$Security$EnterpriseData$ProtectedAccessSuspendingEventArgs  {

/**
 * DateTime at which content protection will be suspended. The app can subtract DateTime.Now from this value to determine how much time there is to perform any processing before the suspension occurs.
 */
deadline: Date;

/**
 * Gets the Deferral object that manages the protection suspension. The app must call Deferral.Complete before it returns from the event handler.
 * @return The Deferral object.
 */
getDeferral(): Windows$Foundation$Deferral;

/**
 * Contains the enterprise identities for which content protection is being suspended.
 */
identities: Windows$Foundation$Collections$IVectorView<string>
}


/**
 * Represents the result of an enterprise protected file that has been exported to a container file.
 */
declare class Windows$Security$EnterpriseData$ProtectedContainerExportResult  {

/**
 * The container file that has been exported from an enterprise protected file.
 */
file: Windows$Storage$StorageFile;

/**
 * The protection status after an enterprise protected file has been exported to a container file.
 */
status: $Values<typeof Windows$Security$EnterpriseData$ProtectedImportExportStatus>
}


/**
 * Represents the result of an enterprise protected file that has been imported from a container file.
 */
declare class Windows$Security$EnterpriseData$ProtectedContainerImportResult  {

/**
 * The enterprise protected file that has been loaded from a container file.
 */
file: Windows$Storage$StorageFile;

/**
 * The protection status after an enterprise protected file has been imported from a container file.
 */
status: $Values<typeof Windows$Security$EnterpriseData$ProtectedImportExportStatus>
}


/**
 * Provides data when content protection has been revoked.
 */
declare class Windows$Security$EnterpriseData$ProtectedContentRevokedEventArgs  {

/**
 * Contains the enterprise identities for which content protection has been revoked.
 */
identities: Windows$Foundation$Collections$IVectorView<string>
}


/**
 * Contains information about a newly created enterprise protected file.
 */
declare class Windows$Security$EnterpriseData$ProtectedFileCreateResult  {

/**
 * The newly created enterprise protected file.
 */
file: Windows$Storage$StorageFile;

/**
 * Information about the enterprise protected file.
 */
protectionInfo: Windows$Security$EnterpriseData$FileProtectionInfo;

/**
 * The stream random access to the newly created enterprise protected file.
 */
stream: Windows$Storage$Streams$IRandomAccessStream
}


/**
 * Possible status values for an enterprise protected file that has been imported from or exported to a container file.
 */

declare  var Windows$Security$EnterpriseData$ProtectedImportExportStatus: {|
  +ok: 0,// 0
+undetermined: 1,// 1
+unprotected: 2,// 2
+revoked: 3,// 3
+notRoamable: 4,// 4
+protectedToOtherIdentity: 5,// 5
+licenseExpired: 6,// 6
+accessSuspended: 7,// 7

|};



/**
 * Possible results when access to protected content is requested or queried.
 */

declare  var Windows$Security$EnterpriseData$ProtectionPolicyEvaluationResult: {|
  +allowed: 0,// 0
+blocked: 1,// 1
+consentRequired: 2,// 2

|};



/**
 * Manages enterprise-protection policy on protected content.
 */
declare class Windows$Security$EnterpriseData$ProtectionPolicyManager  {

/**
 * Request if access to enterprise-protected content is available to an identity.
 * @param sourceIdentity The source enterprise identity of the app. This is an email address or domain that is managed. Your app should use IsIdentityManaged to check if an email address or domain is managed.
 * @param targetIdentity The enterprise identity you want to check has access to the protected content.
 * @return A value of the ProtectionPolicyEvaluationResult enumeration that is the result of the query.
 */
static checkAccess(
sourceIdentity: string,
targetIdentity: string): $Values<typeof Windows$Security$EnterpriseData$ProtectionPolicyEvaluationResult>;

/**
 * Perform enterprise-protection policy evaluation for a data transfer between your app and a specific target app.
 * @param sourceIdentity The source enterprise identity of the app. This is an email address or domain that is managed. Your app should use IsIdentityManaged to check if an email address or domain is managed.
 * @param appPackageFamilyName The package family name of the app you want to check has access to the protected content.
 * @return A value of the ProtectionPolicyEvaluationResult enumeration that is the result of the query.
 */
static checkAccessForApp(
sourceIdentity: string,
appPackageFamilyName: string): $Values<typeof Windows$Security$EnterpriseData$ProtectionPolicyEvaluationResult>;

/**
 * Clear UI policy enforcement for an enterprise identity. The app calls this method before it displays non-enterprise-protected content.
 */
static clearProcessUIPolicy(): void;

/**
 * Creates a ThreadNetworkContext protected to an enterprise identity. The creation of the context tags all network connections made thereafter on the current thread with the identity, and allows access to enterprise resources that are access controlled by the enterprise's policy.
 * @param identity The enterprise identity. This is an email address or domain that is managed. This may be returned from GetPrimaryManagedIdentityForNetworkEndpoint ; otherwise your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @return The protected network context. The app must call ThreadNetworkContext.Close after access to the resource is completed.
 */
static createCurrentThreadNetworkContext(identity: string): Windows$Security$EnterpriseData$ThreadNetworkContext;

/**
 * You can use this method to determine the current enterprise data protection (EDP) enforcement level. EDP enforcement level is one aspect of mobile device management (MDM) policy configuration.
 * @param identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @return A value of the EnforcementLevel enumeration.
 */
static getEnforcementLevel(
identity: string): $Values<typeof Windows$Security$EnterpriseData$EnforcementLevel>;

/**
 * Returns the ProtectionPolicyManager object associated with the current app window.
 * @return The ProtectionPolicyManager object associated with the current app window.
 */
static getForCurrentView(): Windows$Security$EnterpriseData$ProtectionPolicyManager;

/**
 * Returns the enterprise identity of a network resource if the resource is on an enterprise-policy-managed endpoint.
 * @param endpointHost The host name or IP address of the network resource.
 * @return The enterprise identity.
 */
static getPrimaryManagedIdentityForNetworkEndpointAsync(
endpointHost: Windows$Networking$HostName): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Use this method to check whether access to protected data has been revoked since a specified date and time, or is still accessible.
 * @param identity The enterprise identity protecting the data. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @param since The date and time from which point forward you want to include in the check.
 * @return true if access has been revoked since the specified date and time, otherwise false.
 */
static hasContentBeenRevokedSince(identity: string, since: Date): boolean;

/**
 * Determines if an enterprise entity is managed by an enterprise policy.
 * @param identity The enterprise identity. This is an email address or domain.
 * @return true if the enterprise identity is managed, or false if it is not.
 */
static isIdentityManaged(identity: string): boolean;

/**
 * Use this property to determine whether enterprise data protection (EDP) is enabled on the device.
 */
static isProtectionEnabled: boolean;

/**
 * Use this property to determine the value of the ProtectionUnderLockConfigRequired enterprise data protection (EDP) policy.
 * @param identity The enterprise identity you want to check has ProtectionUnderLockConfigRequired policy set.
 * @return true if ProtectionUnderLockConfigRequired policy is set for the identity, otherwise false.
 */
static isProtectionUnderLockRequired(identity: string): boolean;

/**
 * Use this property to determine whether decryption of files protected by enterprise data protection (EDP) is allowed.
 * @param identity The enterprise identity you want to check has access to the protected content.
 * @return true if decryption of files protected by EDP is allowed, otherwise false.
 */
static isUserDecryptionAllowed(identity: string): boolean;

/**
 * An event that is raised in response to changes in enterprise data protection (EDP) policy managed by the Policy CSP.
 */
static onpolicychanged: Windows$Foundation$EventHandler<any>;
static addEventListener(type: "policychanged", listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: "policychanged", listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Event with which the app registers to receive notification that protection has been resumed.
 */
static onprotectedaccessresumed: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "protectedaccessresumed",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "protectedaccessresumed",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Event with which the app registers to receive notification that protection is to be suspended.
 */
static onprotectedaccesssuspending: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "protectedaccesssuspending",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "protectedaccesssuspending",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Event with which the app registers to receive notification that protection is to be revoked. When the app receives this event, it should determine from ProtectedContentRevokedEventArgs.Identities which enterprise entities have had protection revoked, and call RevokeContent as well as delete any metadata associated with the identity.
 */
static onprotectedcontentrevoked: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "protectedcontentrevoked",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "protectedcontentrevoked",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Request access to enterprise protected content for an identity.
 * @param sourceIdentity The source enterprise identity of the app. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @param targetIdentity The target enterprise identity to which the content is protected.
 * @return A value of the ProtectionPolicyEvaluationResult enumeration that is the result of the request.
 */
static requestAccessAsync(
sourceIdentity: string,
targetIdentity: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Security$EnterpriseData$ProtectionPolicyEvaluationResult>>;

/**
 * Request access to enterprise-protected content for a specific target app.
 * @param sourceIdentity The source enterprise identity of the app. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @param appPackageFamilyName The package family name of the app you want to check has access to the protected content.
 * @return A value of the ProtectionPolicyEvaluationResult enumeration that is the result of the query.
 */
static requestAccessForAppAsync(
sourceIdentity: string,
appPackageFamilyName: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Security$EnterpriseData$ProtectionPolicyEvaluationResult>>;

/**
 * Revoke the keys required to access all content protected to the specified enterprise identity.
 * @param identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 */
static revokeContent(identity: string): void;

/**
 * Enables UI policy enforcement for an enterprise identity. When an app is about to display a protected file (such as a PDF) or resource (buffer or stream) on its UI, it must enable UI policy enforcement based on the identity the file is protected to. A call to TryApplyProcessUIPolicy ensures that the OS knows about the current context of the app.
 * @param identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @return true if the identity is being managed by an enterprise policy, or false if it is not.
 */
static tryApplyProcessUIPolicy(identity: string): boolean;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Gets or sets the enterprise identity.
 */
identity: string
}


/**
 * A protected network context for an enterprise identity. The creation of the context tags all network connections made thereafter on the current thread with the identity, and allows access to enterprise resources that are access controlled by the enterprise's policy.
 */
declare class Windows$Security$EnterpriseData$ThreadNetworkContext  {

/**
 * Closes the protected network context. The app must call Close after access to the protected resource is completed.
 */
close(): void
}


      declare var npm$namespace$Windows$Security$ExchangeActiveSyncProvisioning: {
        
        
        EasDisallowConvenienceLogonResult: typeof Windows$Security$ExchangeActiveSyncProvisioning$EasDisallowConvenienceLogonResult,
EasEncryptionProviderType: typeof Windows$Security$ExchangeActiveSyncProvisioning$EasEncryptionProviderType,
EasMaxInactivityTimeLockResult: typeof Windows$Security$ExchangeActiveSyncProvisioning$EasMaxInactivityTimeLockResult,
EasMaxPasswordFailedAttemptsResult: typeof Windows$Security$ExchangeActiveSyncProvisioning$EasMaxPasswordFailedAttemptsResult,
EasMinPasswordComplexCharactersResult: typeof Windows$Security$ExchangeActiveSyncProvisioning$EasMinPasswordComplexCharactersResult,
EasMinPasswordLengthResult: typeof Windows$Security$ExchangeActiveSyncProvisioning$EasMinPasswordLengthResult,
EasPasswordExpirationResult: typeof Windows$Security$ExchangeActiveSyncProvisioning$EasPasswordExpirationResult,
EasPasswordHistoryResult: typeof Windows$Security$ExchangeActiveSyncProvisioning$EasPasswordHistoryResult,
EasRequireEncryptionResult: typeof Windows$Security$ExchangeActiveSyncProvisioning$EasRequireEncryptionResult,
        EasClientDeviceInformation: typeof Windows$Security$ExchangeActiveSyncProvisioning$EasClientDeviceInformation,
EasClientSecurityPolicy: typeof Windows$Security$ExchangeActiveSyncProvisioning$EasClientSecurityPolicy,
EasComplianceResults: typeof Windows$Security$ExchangeActiveSyncProvisioning$EasComplianceResults,
        
      }

/**
 * Provides the app the ability to retrieve device information from the local device.
 */
declare class Windows$Security$ExchangeActiveSyncProvisioning$EasClientDeviceInformation  {

/**
 * Creates an instance of an object that allows the caller app to retrieve device information from the local device.
 */
constructor(): this;

/**
 * Returns the friendly name of the local device.
 */
friendlyName: string;

/**
 * Returns the identifier of the local device.
 */
id: string;

/**
 * Returns the operating system of the local device.
 */
operatingSystem: string;

/**
 * Returns the system firmware version of the local device.
 */
systemFirmwareVersion: string;

/**
 * Returns the system hardware version of the local device.
 */
systemHardwareVersion: string;

/**
 * Returns the system manufacturer of the local device. Use this only if the SystemSku is empty.
 */
systemManufacturer: string;

/**
 * Returns the system product name of the local device.
 */
systemProductName: string;

/**
 * Returns the system SKU of the local device.
 */
systemSku: string
}


/**
 * Modern mail apps evaluate and apply the EAS security policies. An EasClientSecurityPolicy object is constructed by the caller app to set policies received from the Exchange server or application.
 */
declare class Windows$Security$ExchangeActiveSyncProvisioning$EasClientSecurityPolicy  {

/**
 * Creates an instance of an object that allows the caller app to set policies received from the Exchange server for evaluation or application.
 */
constructor(): this;

/**
 * Applies the EAS policies in asynchronous mode once the user consents. ApplyAsync is called by a Windows Store app for mail any time the app wants to make the local computer compliant.
 * @return Returns the evaluation of the callback results, in asynchronous mode, back to the calling app.
 */
applyAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Security$ExchangeActiveSyncProvisioning$EasComplianceResults>;

/**
 * Evaluates the EAS policies. CheckCompliance is called by a Windows Store app for mail any time the app wants to evaluate whether the local computer is compliant to the given EAS policies. Because this call doesn't involve any UI interactions, it is a synchronous call.
 * @return Returns the results of the compliance check, in synchronous mode.
 */
checkCompliance(): Windows$Security$ExchangeActiveSyncProvisioning$EasComplianceResults;

/**
 * Gets or sets the ability to prevent convenience logons. DisallowConvenienceLogon is not defined in MS-ASPROV. It is mapped from MS-ASPROV AllowSimplePassword with respect to the Windows password policies.
 */
disallowConvenienceLogon: boolean;

/**
 * Gets or sets the maximum length of time the computer can remain inactive before it is locked. The MS-ASPROV name is MaxInactivityTimeDeviceLock.
 */
maxInactivityTimeLock: number;

/**
 * Gets or sets the maximum number of failed password attempts for logging on. The MS-ASPROV name is MaxDevicePasswordFailedAttempts.
 */
maxPasswordFailedAttempts: number;

/**
 * Gets or sets the minimum number of complex characters that are required for a password. The MS-ASPROV name is MinDevicePasswordComplexCharacters.
 */
minPasswordComplexCharacters: number;

/**
 * Gets or set the minimum length of password allowed. The MS-ASPROV name is MinPasswordLength.
 */
minPasswordLength: number;

/**
 * Gets or set the length of time that a password is valid. The MS-ASPROV name is DevicePasswordExpiration.
 */
passwordExpiration: number;

/**
 * Gets or set the password information previously used. The MS-ASPROV name is DevicePasswordHistory.
 */
passwordHistory: number;

/**
 * Gets or sets whether encryption is required. The MS-ASPROV name is RequireDeviceEncryption.
 */
requireEncryption: boolean
}


/**
 * Provides the mail app with the results of the evaluation of the EAS security policies. Every policy being evaluated returns an enumerated value indicating the evaluation results against the policy. The evaluations results are encapsulated in the EasComplianceResults object for the caller app to retrieve.
 */
declare class Windows$Security$ExchangeActiveSyncProvisioning$EasComplianceResults  {

/**
 * Returns the result of whether the computer is compliant with the EAS policies.
 */
compliant: boolean;

/**
 * Returns the result of whether convenience logons are disallowed.
 */
disallowConvenienceLogonResult: $Values<typeof Windows$Security$ExchangeActiveSyncProvisioning$EasDisallowConvenienceLogonResult>;

/**
 * Gets the type of the Exchange ActiveSync encryption provider.
 */
encryptionProviderType: $Values<typeof Windows$Security$ExchangeActiveSyncProvisioning$EasEncryptionProviderType>;

/**
 * Returns the result of the maximum time of inactivity allowed before the computer is locked.
 */
maxInactivityTimeLockResult: $Values<typeof Windows$Security$ExchangeActiveSyncProvisioning$EasMaxInactivityTimeLockResult>;

/**
 * Returns the result of the maximum number of failed password attempts allowed.
 */
maxPasswordFailedAttemptsResult: $Values<typeof Windows$Security$ExchangeActiveSyncProvisioning$EasMaxPasswordFailedAttemptsResult>;

/**
 * Returns the result of the minimum number of complex password characters required.
 */
minPasswordComplexCharactersResult: $Values<typeof Windows$Security$ExchangeActiveSyncProvisioning$EasMinPasswordComplexCharactersResult>;

/**
 * Returns the result of the minimum length of the password required.
 */
minPasswordLengthResult: $Values<typeof Windows$Security$ExchangeActiveSyncProvisioning$EasMinPasswordLengthResult>;

/**
 * Returns the result of whether the password is expired.
 */
passwordExpirationResult: $Values<typeof Windows$Security$ExchangeActiveSyncProvisioning$EasPasswordExpirationResult>;

/**
 * Returns the result of the history of passwords.
 */
passwordHistoryResult: $Values<typeof Windows$Security$ExchangeActiveSyncProvisioning$EasPasswordHistoryResult>;

/**
 * Returns the result of whether encryption is required.
 */
requireEncryptionResult: $Values<typeof Windows$Security$ExchangeActiveSyncProvisioning$EasRequireEncryptionResult>
}


/**
 * Results of whether the logon can occur. These values are mapped against the HRESULT codes returned from the EAS policy engine.
 */

declare  var Windows$Security$ExchangeActiveSyncProvisioning$EasDisallowConvenienceLogonResult: {|
  +notEvaluated: 0,// 0
+compliant: 1,// 1
+canBeCompliant: 2,// 2
+requestedPolicyIsStricter: 3,// 3

|};



/**
 * Describes the type of Exchange ActiveSync encryption provider.
 */

declare  var Windows$Security$ExchangeActiveSyncProvisioning$EasEncryptionProviderType: {|
  +notEvaluated: 0,// 0
+windowsEncryption: 1,// 1
+otherEncryption: 2,// 2

|};



/**
 * Represents the maximum length of time result before locking the computer. These values are mapped against the HRESULT codes returned from the EAS policy engine.
 */

declare  var Windows$Security$ExchangeActiveSyncProvisioning$EasMaxInactivityTimeLockResult: {|
  +notEvaluated: 0,// 0
+compliant: 1,// 1
+canBeCompliant: 2,// 2
+requestedPolicyIsStricter: 3,// 3
+invalidParameter: 4,// 4

|};



/**
 * Represents the maximum number of password attempts results. These values are mapped against the HRESULT codes returned from the EAS policy engine.
 */

declare  var Windows$Security$ExchangeActiveSyncProvisioning$EasMaxPasswordFailedAttemptsResult: {|
  +notEvaluated: 0,// 0
+compliant: 1,// 1
+canBeCompliant: 2,// 2
+requestedPolicyIsStricter: 3,// 3
+invalidParameter: 4,// 4

|};



/**
 * Represents the minimum complexity result for passwords. These values are mapped against the HRESULT codes returned from the EAS policy engine.
 */

declare  var Windows$Security$ExchangeActiveSyncProvisioning$EasMinPasswordComplexCharactersResult: {|
  +notEvaluated: 0,// 0
+compliant: 1,// 1
+canBeCompliant: 2,// 2
+requestedPolicyIsStricter: 3,// 3
+requestedPolicyNotEnforceable: 4,// 4
+invalidParameter: 5,// 5
+currentUserHasBlankPassword: 6,// 6
+adminsHaveBlankPassword: 7,// 7
+userCannotChangePassword: 8,// 8
+adminsCannotChangePassword: 9,// 9
+localControlledUsersCannotChangePassword: 10,// 10
+connectedAdminsProviderPolicyIsWeak: 11,// 11
+connectedUserProviderPolicyIsWeak: 12,// 12
+changeConnectedAdminsPassword: 13,// 13
+changeConnectedUserPassword: 14,// 14

|};



/**
 * Represents the minimum length result for passwords. These values are mapped against the HRESULT codes returned from the EAS policy engine.
 */

declare  var Windows$Security$ExchangeActiveSyncProvisioning$EasMinPasswordLengthResult: {|
  +notEvaluated: 0,// 0
+compliant: 1,// 1
+canBeCompliant: 2,// 2
+requestedPolicyIsStricter: 3,// 3
+requestedPolicyNotEnforceable: 4,// 4
+invalidParameter: 5,// 5
+currentUserHasBlankPassword: 6,// 6
+adminsHaveBlankPassword: 7,// 7
+userCannotChangePassword: 8,// 8
+adminsCannotChangePassword: 9,// 9
+localControlledUsersCannotChangePassword: 10,// 10
+connectedAdminsProviderPolicyIsWeak: 11,// 11
+connectedUserProviderPolicyIsWeak: 12,// 12
+changeConnectedAdminsPassword: 13,// 13
+changeConnectedUserPassword: 14,// 14

|};



/**
 * Results of querying on the password expiration information. These values are mapped against the HRESULT codes returned from the EAS policy engine.
 */

declare  var Windows$Security$ExchangeActiveSyncProvisioning$EasPasswordExpirationResult: {|
  +notEvaluated: 0,// 0
+compliant: 1,// 1
+canBeCompliant: 2,// 2
+requestedPolicyIsStricter: 3,// 3
+requestedExpirationIncompatible: 4,// 4
+invalidParameter: 5,// 5
+userCannotChangePassword: 6,// 6
+adminsCannotChangePassword: 7,// 7
+localControlledUsersCannotChangePassword: 8,// 8

|};



/**
 * Represents the password history. These values are mapped against the HRESULT codes returned from the EAS policy engine.
 */

declare  var Windows$Security$ExchangeActiveSyncProvisioning$EasPasswordHistoryResult: {|
  +notEvaluated: 0,// 0
+compliant: 1,// 1
+canBeCompliant: 2,// 2
+requestedPolicyIsStricter: 3,// 3
+invalidParameter: 4,// 4

|};



/**
 * Represents the type of encryption required. These values are mapped against the HRESULT codes returned from the EAS policy engine.
 */

declare  var Windows$Security$ExchangeActiveSyncProvisioning$EasRequireEncryptionResult: {|
  +notEvaluated: 0,// 0
+compliant: 1,// 1
+canBeCompliant: 2,// 2
+notProvisionedOnAllVolumes: 3,// 3
+deFixedDataNotSupported: 4,// 4
+fixedDataNotSupported: 5,// 5
+deHardwareNotCompliant: 6,// 6
+hardwareNotCompliant: 7,// 7
+deWinReNotConfigured: 8,// 8
+lockNotConfigured: 9,// 9
+deProtectionSuspended: 10,// 10
+protectionSuspended: 11,// 11
+deOsVolumeNotProtected: 12,// 12
+osVolumeNotProtected: 13,// 13
+deProtectionNotYetEnabled: 14,// 14
+protectionNotYetEnabled: 15,// 15
+noFeatureLicense: 16,// 16
+osNotProtected: 17,// 17
+unexpectedFailure: 18,// 18

|};



      declare var npm$namespace$Windows$Services: {
        
        
        
        
        Maps: typeof npm$namespace$Windows$Services$Maps,
Store: typeof npm$namespace$Windows$Services$Store,
      }

      declare var npm$namespace$Windows$Services$Maps: {
        
        
        
        
        Guidance: typeof npm$namespace$Windows$Services$Maps$Guidance,
      }

      declare var npm$namespace$Windows$Services$Maps$Guidance: {
        
        
        GuidanceLaneMarkers: typeof Windows$Services$Maps$Guidance$GuidanceLaneMarkers,
        
        
      }

/**
 * Specifies the path of the lane.
 */

declare  var Windows$Services$Maps$Guidance$GuidanceLaneMarkers: {|
  +none: 0,// 0
+lightRight: 1,// 1
+right: 2,// 2
+hardRight: 3,// 3
+straight: 4,// 4
+uturnLeft: 5,// 5
+hardLeft: 6,// 6
+left: 7,// 7
+lightLeft: 8,// 8
+uturnRight: 9,// 9
+unknown: 10,// 10

|};





      declare var npm$namespace$Windows$Services$Store: {
        
        
        StoreConsumableStatus: typeof Windows$Services$Store$StoreConsumableStatus,
StorePackageUpdateState: typeof Windows$Services$Store$StorePackageUpdateState,
StoreDurationUnit: typeof Windows$Services$Store$StoreDurationUnit,
StorePurchaseStatus: typeof Windows$Services$Store$StorePurchaseStatus,
        StoreAcquireLicenseResult: typeof Windows$Services$Store$StoreAcquireLicenseResult,
StoreAppLicense: typeof Windows$Services$Store$StoreAppLicense,
StoreAvailability: typeof Windows$Services$Store$StoreAvailability,
StoreCollectionData: typeof Windows$Services$Store$StoreCollectionData,
StoreConsumableResult: typeof Windows$Services$Store$StoreConsumableResult,
StoreContext: typeof Windows$Services$Store$StoreContext,
StoreImage: typeof Windows$Services$Store$StoreImage,
StoreLicense: typeof Windows$Services$Store$StoreLicense,
StorePackageLicense: typeof Windows$Services$Store$StorePackageLicense,
StorePackageUpdate: typeof Windows$Services$Store$StorePackageUpdate,
StorePackageUpdateResult: typeof Windows$Services$Store$StorePackageUpdateResult,
StorePrice: typeof Windows$Services$Store$StorePrice,
StoreProduct: typeof Windows$Services$Store$StoreProduct,
StoreProductPagedQueryResult: typeof Windows$Services$Store$StoreProductPagedQueryResult,
StoreProductQueryResult: typeof Windows$Services$Store$StoreProductQueryResult,
StoreProductResult: typeof Windows$Services$Store$StoreProductResult,
StorePurchaseProperties: typeof Windows$Services$Store$StorePurchaseProperties,
StorePurchaseResult: typeof Windows$Services$Store$StorePurchaseResult,
StoreRequestHelper: typeof Windows$Services$Store$StoreRequestHelper,
StoreSendRequestResult: typeof Windows$Services$Store$StoreSendRequestResult,
StoreSku: typeof Windows$Services$Store$StoreSku,
StoreSubscriptionInfo: typeof Windows$Services$Store$StoreSubscriptionInfo,
StoreVideo: typeof Windows$Services$Store$StoreVideo,
        
      }

/**
 * Defines values that represent the status of an request that is related to a consumable add-on.
 */

declare  var Windows$Services$Store$StoreConsumableStatus: {|
  +insufficentQuantity: 1,// 1
+networkError: 2,// 2
+serverError: 3,// 3
+succeeded: 0,// 0

|};



/**
 * Defines values that represent the state of a package download or installation request.
 */

declare  var Windows$Services$Store$StorePackageUpdateState: {|
  +canceled: 4,// 4
+completed: 3,// 3
+deploying: 2,// 2
+downloading: 1,// 1
+errorLowBattery: 6,// 6
+errorWiFiRecommended: 7,// 7
+errorWiFiRequired: 8,// 8
+otherError: 5,// 5
+pending: 0,// 0

|};



/**
 * Defines values that represent the units of a trial period or billing period for a subscription.
 */

declare  var Windows$Services$Store$StoreDurationUnit: {|
  +day: 2,// 2
+hour: 1,// 1
+minute: 0,// 0
+month: 4,// 4
+week: 3,// 3
+year: 5,// 5

|};



/**
 * Defines values that represent the status of a request to purchase an app or add-on.
 */

declare  var Windows$Services$Store$StorePurchaseStatus: {|
  +alreadyPurchased: 1,// 1
+networkError: 3,// 3
+notPurchased: 2,// 2
+serverError: 4,// 4
+succeeded: 0,// 0

|};



/**
 * Provides status info for a package that is associated with a download or installation request.
 */
declare interface Windows$Services$Store$StorePackageUpdateStatus {

/**
 * The number of bytes that have been downloaded.
 */
packageBytesDownloaded: number,

/**
 * The download (or download and install) progress of the current package, represented by a value from 0.0 to 1.0. When you use RequestDownloadStorePackageUpdatesAsync to download packages, this value increases from 0.0 to 1.0 during the download of each package. When you use RequestDownloadAndInstallStorePackageUpdatesAsync to download and install packages in a single operation, this value increases from 0.0 to 0.8 during the download of each package, and then it increases from 0.8 to 1.0 during the install phase.
 */
packageDownloadProgress: number,

/**
 * The size of the package that is being downloaded, in bytes. This is an estimate, and it might change during the download process.
 */
packageDownloadSizeInBytes: number,

/**
 * The family name of the package that is being downloaded or installed.
 */
packageFamilyName: string,

/**
 * A StorePackageUpdateState value that indicates the state of the package that is being downloaded or installed.
 */
packageUpdateState: $Values<typeof Windows$Services$Store$StorePackageUpdateState>,

/**
 * The current progress of all package downloads in the request, represented by a value from 0.0 to 1.0.
 */
totalDownloadProgress: number
} 


/**
 * Provides response data for a request to acquire a downloadable content (DLC) package license.
 */
declare class Windows$Services$Store$StoreAcquireLicenseResult  {

/**
 * Gets the error code for the request, if the operation encountered an error.
 */
extendedError: Windows$WinRTError;

/**
 * Gets an object that represents the downloadable content (DLC) package license.
 */
storePackageLicense: Windows$Services$Store$StorePackageLicense
}


/**
 * Provides license info for the current app, including licenses for products that are offered by the app.
 */
declare class Windows$Services$Store$StoreAppLicense  {

/**
 * Gets the collection of licenses for add-ons that can be used offline (typically durable add-ons), for which the user has entitlements to use. This property does not include licenses for consumable add-ons.
 */
addOnLicenses: Windows$Foundation$Collections$IMapView<string, Windows$Services$Store$StoreLicense>;

/**
 * Gets the expiration date and time for the app license.
 */
expirationDate: Date;

/**
 * Gets complete license data in JSON format.
 */
extendedJsonData: string;

/**
 * Gets a value that indicates whether the license is active.
 */
isActive: boolean;

/**
 * Gets a value that indicates whether the license is a trial license.
 */
isTrial: boolean;

/**
 * Gets a value that indicates whether the current user has an entitlement for the usage-limited trial that is associated with this app license.
 */
isTrialOwnedByThisUser: boolean;

/**
 * Gets the Store ID of the licensed app SKU from the Windows Store catalog.
 */
skuStoreId: string;

/**
 * Gets the remaining time for the usage-limited trial that is associated with this app license.
 */
trialTimeRemaining: number;

/**
 * Gets a unique ID that identifies the combination of the current user and the usage-limited trial that is associated with this app license.
 */
trialUniqueId: string
}


/**
 * Represents a specific instance of a product SKU that can be purchased.
 */
declare class Windows$Services$Store$StoreAvailability  {

/**
 * Gets the end date for the current SKU availability.
 */
endDate: Date;

/**
 * Gets complete data for the current SKU availability from the Store in JSON format.
 */
extendedJsonData: string;

/**
 * Gets price info for the current SKU availability, including the base price, current price, and sale info.
 */
price: Windows$Services$Store$StorePrice;

/**
 * Requests the purchase of the current SKU availability and displays the UI that is used to complete the transaction via the Windows Store.
 * @return An asynchronous operation that, on successful completion, returns a StorePurchaseResult object that provides status and error info about the purchase.
 */
requestPurchaseAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StorePurchaseResult>;

/**
 * Requests the purchase of the current SKU availability and displays the UI that is used to complete the transaction via the Windows Store. This method provides the option to specify additional details for a specific offer within a large catalog of products that are represented by a single listing in the Windows Store, including the product name to display to the user during the purchase.
 * @param {Windows$Services$Store$StorePurchaseProperties} storePurchaseProperties An object that specifies additional info for the purchase request, including the product name to display to the user during the purchase.
 * @return An asynchronous operation that, on successful completion, returns a StorePurchaseResult object that provides status and error info about the purchase.
 */
requestPurchaseAsync(
storePurchaseProperties: Windows$Services$Store$StorePurchaseProperties): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StorePurchaseResult>;

/**
 * Gets the Store ID of the current SKU availability from the Windows Store catalog.
 */
storeId: string
}


/**
 * Provides additional data for a product SKU that the user has an entitlement to use.
 */
declare class Windows$Services$Store$StoreCollectionData  {

/**
 * Gets the date on which the product SKU was acquired.
 */
acquiredDate: Date;

/**
 * Gets the promotion campaign ID that is associated with the product SKU.
 */
campaignId: string;

/**
 * Gets the developer offer ID that is associated with the product SKU.
 */
developerOfferId: string;

/**
 * Gets the end date of the trial for the product SKU, if the SKU is a trial version or a durable add-on that expires after a set duration.
 */
endDate: Date;

/**
 * Gets complete collection data for the product SKU in JSON format.
 */
extendedJsonData: string;

/**
 * Gets a value that indicates whether the product SKU is a trial version.
 */
isTrial: boolean;

/**
 * Gets the start date of the trial for the product SKU, if the SKU is a trial version or a durable add-on that expires after a set duration.
 */
startDate: Date;

/**
 * Gets the remaining trial time for the product SKU.
 */
trialTimeRemaining: number
}


/**
 * Provides response data for a request that involves a consumable add-on for the current app.
 */
declare class Windows$Services$Store$StoreConsumableResult  {

/**
 * Gets the remaining balance for the consumable add-on.
 */
balanceRemaining: number;

/**
 * Gets the error code for the request, if the operation encountered an error.
 */
extendedError: Windows$WinRTError;

/**
 * Gets the status of the request.
 */
status: $Values<typeof Windows$Services$Store$StoreConsumableStatus>;

/**
 * Gets the tracking ID that was submitted with the ReportConsumableFulfillmentAsync request.
 */
trackingId: string
}


/**
 * Provides members you can use to access and manage Windows Store-related data for the current app. For example, you can use members of this class to get Windows Store listing and license info for the current app, purchase the current app or products that are offered by the app, or download and install package updates for the app.
 */
declare class Windows$Services$Store$StoreContext  {

/**
 * Acquires a license for the specified downloadable content (DLC) package for the current app.
 * @param optionalPackage The DLC package for which to acquire a license.
 * @return An asynchronous operation that, on successful completion, returns a StoreAcquireLicenseResult object that contains the license.
 */
acquireStoreLicenseForOptionalPackageAsync(
optionalPackage: Windows$ApplicationModel$Package): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StoreAcquireLicenseResult>;

/**
 * Gets Store product details for the app or add-on that is associated with the specified package.
 * @param productKinds An array of strings that specify the types of Store products that might be associated with the package. For a list of the supported string values, see the ProductKind property.
 * @param package A Package that represents the package for which you want to get the corresponding Store product details.
 * @return An asynchronous operation that, on successful completion, returns a StoreProductResult object. Use the Product property of this object to access a StoreProduct that contains Store product details for the specified package.
 */
findStoreProductForPackageAsync(
productKinds: Windows$Foundation$Collections$IIterable<string>,
package: Windows$ApplicationModel$Package): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StoreProductResult>;

/**
 * Gets the collection of packages for the current app that have updates available for download from the Windows Store, including optional packages for the app (also called downloadable content or DLC).
 * @return An asynchronous operation that, on successful completion, returns a collection of StorePackageUpdate objects that represent the packages that have updates available.
 */
getAppAndOptionalStorePackageUpdatesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StorePackageUpdate>;

/**
 * Gets license info for the current app, including licenses for add-ons for the current app.
 * @return An asynchronous operation that, on successful completion, returns a StoreAppLicense object that contains license info for the current app, including add-on licenses.
 */
getAppLicenseAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StoreAppLicense>;

/**
 * Gets the list of products that can be purchased from within the current app.
 * @param productKinds An array of strings that specify the types of products you want to get. For a list of the supported string values, see the ProductKind property.
 * @return An asynchronous operation that, on successful completion, returns a StoreProductQueryResult that provides access to the associated products and relevant error info.
 */
getAssociatedStoreProductsAsync(
productKinds: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StoreProductQueryResult>;

/**
 * Gets the list of products that can be purchased from within the current app. This method supports paging to return the results.
 * @param productKinds An array of strings that specify the types of products you want to get. For a list of the supported string values, see the ProductKind property.
 * @param maxItemsToRetrievePerPage The maximum number of products to return in each page of results.
 * @return An asynchronous operation that, on successful completion, returns a StoreProductPagedQueryResult that provides access to the associated products, relevant error info, and the next page of results.
 */
getAssociatedStoreProductsWithPagingAsync(
productKinds: Windows$Foundation$Collections$IIterable<string>,
maxItemsToRetrievePerPage: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StoreProductPagedQueryResult>;

/**
 * Gets the remaining balance for the specified consumable add-on for the current app.
 * @param productStoreId The Store ID for the add-on (as provided by the StoreId property of the StoreProduct that represents the add-on).
 * @return An asynchronous operation that, on successful completion, returns a StoreConsumableResult that provides the remaining balance and other info.
 */
getConsumableBalanceRemainingAsync(
productStoreId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StoreConsumableResult>;

/**
 * Retrieves a Windows Store collections ID key that can be used to query for product entitlements or to consume product entitlements that are owned by the current user.
 * @param serviceTicket An Azure Active Directory access token that identifies the publisher of the current app. For more information about generating this token, see Manage product entitlements from a service.
 * @param publisherUserId An anonymous ID that identifies the current user in the context of services that are managed by the publisher of the current app. If the publisher maintains anonymous user IDs for use in their services, they can use this parameter to correlate these user IDs with the calls they make to Windows Store services. This parameter is optional.
 * @return An asynchronous operation that, on successful completion, returns the collections ID key for the current user. This key is valid for 90 days.
 */
getCustomerCollectionsIdAsync(
serviceTicket: string,
publisherUserId?: string): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Retrieves a Windows Store purchase ID key that can be used to grant entitlements for free products on behalf of the current user.
 * @param serviceTicket An Azure Active Directory access token that identifies the publisher of the current app. For more information about generating this token, see Manage product entitlements from a service.
 * @param publisherUserId An anonymous ID that identifies the current user in the context of services that are managed by the publisher of the current app. If the publisher maintains anonymous user IDs for use in their services, they can use this parameter to correlate these user IDs with the calls they make to Windows Store services. This parameter is optional.
 * @return An asynchronous operation that, on successful completion, returns the purchase ID key for the current user. This key is valid for 90 days.
 */
getCustomerPurchaseIdAsync(
serviceTicket: string,
publisherUserId?: string): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Gets a StoreContext object that can be used to access and manage Windows Store-related data for the current user in the context of the current app.
 * @return An object that you can use to access and manage Windows Store-related data for the current user.
 */
static getDefault(): Windows$Services$Store$StoreContext;

/**
 * Gets a StoreContext object that can be used to access and manage Windows Store-related data for the specified user in the context of the current app.
 * @param user An object that identifies the user whose Windows Store-related data you want to access and manage.
 * @return An object that you can use to access and manage Windows Store-related data for the specified user.
 */
static getForUser(user: Windows$System$User): Windows$Services$Store$StoreContext;

/**
 * Gets Windows Store listing info for the current app and provides access to a method that you can use to purchase the app for the current user.
 * @return An asynchronous operation that, on successful completion, returns a StoreProductResult object that contains Windows Store listing info for the current app and any relevant error info.
 */
getStoreProductForCurrentAppAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StoreProductResult>;

/**
 * Gets Windows Store listing info for the specified products that can be purchased from within the current app.
 * @param productKinds An array of strings that specify the types of products for which you want to retrieve listing info. For a list of the supported string values, see the ProductKind property.
 * @param storeIds An array of the Store ID strings for the products for which you want to retrieve listing info.
 * @return An asynchronous operation that, on successful completion, returns a StoreProductQueryResult object that contains Windows Store listing info for the specified products and any relevant error info.
 */
getStoreProductsAsync(
productKinds: Windows$Foundation$Collections$IIterable<string>,
storeIds: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StoreProductQueryResult>;

/**
 * Gets Windows Store info for the add-ons of the current app for which the user has entitlements to use.
 * @param productKinds An array of strings that specify the types of add-ons for which you want to retrieve listing info. For a list of the supported string values, see the ProductKind property.
 * @return An asynchronous operation that, on successful completion, returns a StoreProductQueryResult object that contains Windows Store listing info for the add-ons of the current app for which the user has entitlements to use.
 */
getUserCollectionAsync(
productKinds: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StoreProductQueryResult>;

/**
 * Gets Windows Store info for the add-ons of the current app for which the user has entitlements to use. This method supports paging to return the results.
 * @param productKinds An array of strings that specify the types of add-ons for which you want to retrieve listing info. For a list of the supported string values, see the ProductKind property.
 * @param maxItemsToRetrievePerPage The maximum number of add-ons to return in each page of results.
 * @return An asynchronous operation that, on successful completion, returns a StoreProductPagedQueryResult object that provides access to the Windows Store listing info for the add-ons of the current app for which the user has entitlements to use, as well as the next page of results.
 */
getUserCollectionWithPagingAsync(
productKinds: Windows$Foundation$Collections$IIterable<string>,
maxItemsToRetrievePerPage: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StoreProductPagedQueryResult>;

/**
 * Raised when the status of the app's license changes (for example, the trial period has expired or the user has purchased the full version of the app).
 */
onofflinelicenseschanged: Windows$Foundation$TypedEventHandler<Windows$Services$Store$StoreContext, {[key: string]: any}>;

/**
 * Reports a consumable add-on for the current app as fulfilled in the Windows Store.
 * @param productStoreId The Store ID of the consumable add-on that you want to report as fulfilled.
 * @param quantity The number of units of the consumable add-on that you want to report as fulfilled. For a Store-managed consumable (that is, a consumable where Microsoft keeps track of the balance), specify the number of units that have been consumed. For a developer-managed consumable (that is, a consumable where the developer keeps track of the balance), specify 1.
 * @param trackingId A developer-supplied GUID that identifies the specific transaction that the fulfillment operation is associated with for tracking purposes. For more information, see the remarks.
 * @return An asynchronous operation that, on successful completion, returns a StoreConsumableResult object that contains info about the fulfillment operation, such as the remaining balance of add-on units.
 */
reportConsumableFulfillmentAsync(
productStoreId: string,
quantity: number,
trackingId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StoreConsumableResult>;

/**
 * Downloads and installs the specified downloadable content (DLC) packages for the current app from the Windows Store.
 * @param storeIds The product IDs of the add-on packages to install.
 * @return An object that the caller can observe to track progress and completion for the operation. On successful completion, the result is a StorePackageUpdateResult object that provides info about the package updates.
 */
requestDownloadAndInstallStorePackagesAsync(
storeIds: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Services$Store$StorePackageUpdateResult, Windows$Services$Store$StorePackageUpdateStatus>;

/**
 * Downloads and installs the specified package updates for the current app from the Windows Store.
 * @param storePackageUpdates The set of StorePackageUpdate objects that represent the updated packages to download and install.
 * @return An object that the caller can observe to track progress and completion for the operation. On successful completion, the result is a StorePackageUpdateResult object that provides info about the package updates.
 */
requestDownloadAndInstallStorePackageUpdatesAsync(
storePackageUpdates: Windows$Foundation$Collections$IIterable<Windows$Services$Store$StorePackageUpdate>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Services$Store$StorePackageUpdateResult, Windows$Services$Store$StorePackageUpdateStatus>;

/**
 * Downloads the specified package updates for the current app from the Windows Store.
 * @param storePackageUpdates The set of StorePackageUpdate objects that represent the updated packages to download.
 * @return An object that the caller can observe to track progress and completion for the operation. On successful completion, the result is a StorePackageUpdateResult object that provides info about the package updates.
 */
requestDownloadStorePackageUpdatesAsync(
storePackageUpdates: Windows$Foundation$Collections$IIterable<Windows$Services$Store$StorePackageUpdate>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Services$Store$StorePackageUpdateResult, Windows$Services$Store$StorePackageUpdateStatus>;

/**
 * Requests the purchase for the specified app or add-on and displays the UI that is used to complete the transaction via the Windows Store.
 * @param storeId The Store ID of the app or the add-on that you want to purchase for the current user.
 * @return An asynchronous operation that, on successful completion, returns a StorePurchaseResult object that provides status and error info about the purchase.
 */
requestPurchaseAsync(
storeId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StorePurchaseResult>;

/**
 * Requests the purchase for the specified app or add-on and displays the UI that is used to complete the transaction via the Windows Store. This method provides the option to specify additional details for a specific offer within a large catalog of products that are represented by a single listing in the Windows Store, including the product name to display to the user during the purchase.
 * @param storeId The Store ID of the app or the add-on that you want to purchase for the current user.
 * @param storePurchaseProperties An object that specifies additional info for the purchase request, including the product name to display to the user during the purchase.
 * @return An asynchronous operation that, on successful completion, returns a StorePurchaseResult object that provides status and error info about the purchase.
 */
requestPurchaseAsync(
storeId: string,
storePurchaseProperties: Windows$Services$Store$StorePurchaseProperties): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StorePurchaseResult>;

/**
 * Gets an object that provides info about the current user.
 */
user: Windows$System$User
}


/**
 * Represents an image that is associated with a product listing in the Windows Store.
 */
declare class Windows$Services$Store$StoreImage  {

/**
 * Gets the caption for the image.
 */
caption: string;

/**
 * Gets the height of the image, in pixels.
 */
height: number;

/**
 * Gets the tag for the image.
 */
imagePurposeTag: string;

/**
 * Gets the URI of the image.
 */
uri: Windows$Foundation$Uri;

/**
 * Gets the width of the image, in pixels.
 */
width: number
}


/**
 * Provides license info for an add-on that is associated with the current app.
 */
declare class Windows$Services$Store$StoreLicense  {

/**
 * Gets the expiration date and time for the add-on license.
 */
expirationDate: Date;

/**
 * Gets complete license data in JSON format.
 */
extendedJsonData: string;

/**
 * Gets in the product ID for the add-on.
 */
inAppOfferToken: string;

/**
 * Gets a value that indicates whether the add-on license is active.
 */
isActive: boolean;

/**
 * Gets the Store ID of the licensed add-on SKU from the Windows Store catalog.
 */
skuStoreId: string
}


/**
 * Provides license info for a downloadable content (DLC) package for the current app.
 */
declare class Windows$Services$Store$StorePackageLicense  {

/**
 * Closes and releases any resources used by this StorePackageLicense.
 */
close(): void;

/**
 * Gets a value that indicates whether the license is valid.
 */
isValid: boolean;

/**
 * Raised when user no longer has rights to the license on the current device (for example, the user has acquired the license on a different device).
 */
onlicenselost: Windows$Foundation$TypedEventHandler<Windows$Services$Store$StorePackageLicense, {[key: string]: any}>;

/**
 * Gets the downloadable content (DLC) package that is associated with the license.
 */
package: Windows$ApplicationModel$Package;

/**
 * Releases the license for the downloadable content (DLC) package.
 */
releaseLicense(): void
}


/**
 * Provides info about a package for the current app that has an update available for download from the Windows Store.
 */
declare class Windows$Services$Store$StorePackageUpdate  {

/**
 * Gets a value that indicates whether the package that has an update available for download from the Windows Store is a mandatory package, as specified by the developer in the Windows Dev Center dashboard.
 */
mandatory: boolean;

/**
 * Gets the package that has an update available for download from the Windows Store.
 */
package: Windows$ApplicationModel$Package
}


/**
 * Provides info about a completed package update request for the current app.
 */
declare class Windows$Services$Store$StorePackageUpdateResult  {

/**
 * Gets the state of the completed package update request.
 */
overallState: $Values<typeof Windows$Services$Store$StorePackageUpdateState>;

/**
 * Gets info about the status of each of the package updates that are associated with the completed request.
 */
storePackageUpdateStatuses: Windows$Foundation$Collections$IVectorView<Windows$Services$Store$StorePackageUpdateStatus>
}


/**
 * Contains pricing info for a product listing in the Windows Store.
 */
declare class Windows$Services$Store$StorePrice  {

/**
 * Gets the ISO 4217 currency code for the market of the current user.
 */
currencyCode: string;

/**
 * Gets the base price for the product with the appropriate formatting for the market of the current user.
 */
formattedBasePrice: string;

/**
 * Gets the purchase price for the product with the appropriate formatting for the market of the current user.
 */
formattedPrice: string;

/**
 * Gets the recurring price for the product with the appropriate formatting for the market of the current user, if recurring billing is enabled for this product.
 */
formattedRecurrencePrice: string;

/**
 * Gets a value that indicates whether the product is on sale.
 */
isOnSale: boolean;

/**
 * Gets the end date for the sale period for the product, if the product is on sale.
 */
saleEndDate: Date
}


/**
 * Represents a product that is available in the Windows Store.
 */
declare class Windows$Services$Store$StoreProduct  {

/**
 * Gets the product description from the Windows Store listing.
 */
description: string;

/**
 * Gets complete data for the product from the Store in JSON format.
 */
extendedJsonData: string;

/**
 * Indicates whether any SKU of this product is installed on the current device. This method is intended to be used for products that have downloadable content (DLC).
 * @return An asynchronous operation that, on successful completion, returns true if a SKU of this product is installed on the current device; otherwise, false.
 */
getIsAnySkuInstalledAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets a value that indicates whether the product has optional downloadable content (DLC).
 */
hasDigitalDownload: boolean;

/**
 * Gets the images from the Windows Store listing for the product.
 */
images: Windows$Foundation$Collections$IVectorView<Windows$Services$Store$StoreImage>;

/**
 * Gets the product ID for this product, if the current StoreProduct represents an add-on.
 */
inAppOfferToken: string;

/**
 * Gets a value that indicates whether the current user has an entitlement to use the default SKU of the product.
 */
isInUserCollection: boolean;

/**
 * Gets the keywords that are associated with the product in the Windows Dev Center dashboard. This property only applies to StoreProduct objects that represent add-ons. These strings correspond to the value of the Keywords field in the properties page for the add-on in the Windows Dev Center dashboard.
 */
keywords: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the language for the data in the Windows Store listing for the product.
 */
language: string;

/**
 * Gets the URI to the Windows Store listing for the product.
 */
linkUri: Windows$Foundation$Uri;

/**
 * Gets the price for the default SKU and availability for the product.
 */
price: Windows$Services$Store$StorePrice;

/**
 * Gets the type of the product. These values are currently supported: Application, Game, Consumable, UnmanagedConsumable, and Durable.
 */
productKind: string;

/**
 * Requests the purchase of the default SKU and availability for the product and displays the UI that is used to complete the transaction via the Windows Store.
 * @return An asynchronous operation that, on successful completion, returns a StorePurchaseResult object that provides status and error info about the purchase.
 */
requestPurchaseAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StorePurchaseResult>;

/**
 * Requests the purchase of the default SKU and availability for the product and displays the UI that is used to complete the transaction via the Windows Store. This method provides the option to specify additional details for a specific offer within a large catalog of products that are represented by a single listing in the Windows Store, including the product name to display to the user during the purchase.
 * @param storePurchaseProperties An object that specifies additional info for the purchase request, including the product name to display to the user during the purchase.
 * @return An asynchronous operation that, on successful completion, returns a StorePurchaseResult object that provides status and error info about the purchase.
 */
requestPurchaseAsync(
storePurchaseProperties: Windows$Services$Store$StorePurchaseProperties): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StorePurchaseResult>;

/**
 * Gets the list of available SKUs for the product.
 */
skus: Windows$Foundation$Collections$IVectorView<Windows$Services$Store$StoreSku>;

/**
 * Gets the Store ID for this product.
 */
storeId: string;

/**
 * Gets the product title from the Windows Store listing.
 */
title: string;

/**
 * Gets the videos from the Windows Store listing for the product.
 */
videos: Windows$Foundation$Collections$IVectorView<Windows$Services$Store$StoreVideo>
}


/**
 * Provides response data for a paged request to retrieve details about products that can be purchased from within the current app.
 */
declare class Windows$Services$Store$StoreProductPagedQueryResult  {

/**
 * Gets the error code for the request, if the operation encountered an error.
 */
extendedError: Windows$WinRTError;

/**
 * Returns the next page of results. To determine if there are more pages of results, use the HasMoreResults property.
 * @return An asynchronous operation that, on successful completion, returns a StoreProductPagedQueryResult object that provides the next page of results.
 */
getNextAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StoreProductPagedQueryResult>;

/**
 * Gets a value that indicates whether there are additional pages of results. To get the next page of results, use the GetNextAsync method.
 */
hasMoreResults: boolean;

/**
 * Gets the collection of products returned by the request.
 */
products: Windows$Foundation$Collections$IMapView<string, Windows$Services$Store$StoreProduct>
}


/**
 * Provides response data for a request to retrieve details about products that can be purchased from within the current app.
 */
declare class Windows$Services$Store$StoreProductQueryResult  {

/**
 * Gets the error code for the request, if the operation encountered an error.
 */
extendedError: Windows$WinRTError;

/**
 * Gets the collection of products returned by the request.
 */
products: Windows$Foundation$Collections$IMapView<string, Windows$Services$Store$StoreProduct>
}


/**
 * Provides response data for a request to retrieve details about the current app.
 */
declare class Windows$Services$Store$StoreProductResult  {

/**
 * Gets the error code for the request, if the operation encountered an error.
 */
extendedError: Windows$WinRTError;

/**
 * Gets info about the current app.
 */
product: Windows$Services$Store$StoreProduct
}


/**
 * Contains additional details that you can pass to a purchase request for a product, including the product name to display to the user during the purchase.
 */
declare class Windows$Services$Store$StorePurchaseProperties  {

/**
 * Initializes a new instance of the StorePurchaseProperties class.
 */
constructor(): this;

/**
 * Initializes a new instance of the StorePurchaseProperties class. This overload provides the option to specify the product name that is displayed to the user during the purchase.
 * @param name The product name that is displayed to the user during the purchase.
 */
constructor(name: string): this;

/**
 * Gets or sets a JSON-formatted string that contains extended data to pass with the purchase request to the Windows Store.
 */
extendedJsonData: string;

/**
 * Gets or sets the product name that is displayed to the user during the purchase. The specified name appears in the title bar of the purchase UI.
 */
name: string
}


/**
 * Provides response data for a request to purchase an app or product that is offered by the app.
 */
declare class Windows$Services$Store$StorePurchaseResult  {

/**
 * Gets the error code for the purchase request, if the operation encountered an error.
 */
extendedError: Windows$WinRTError;

/**
 * Gets the status of the purchase request.
 */
status: $Values<typeof Windows$Services$Store$StorePurchaseStatus>
}


/**
 * Provides a helper method that can be used to send requests to the Windows Store for operations that do not yet have a corresponding API available in the Windows SDK.
 */
declare class Windows$Services$Store$StoreRequestHelper  {

/**
 * Sends the specified request to the Windows Store with the provided context and parameters.
 * @param context An object that specifies the user for which to perform the operation. If your app is a single-user app (that is, it runs only in the context of the user that launched the app), use the StoreContext.GetDefault method to get a StoreContext object that you can use to send a request that operates in the context of the user. If your app is a multi-user app, use the StoreContext.GetForUser method to get a StoreContext object that you can use to send a request that operates in the context of a specific user.
 * @param requestKind A value that identifies the request that you want to send to the Windows Store.
 * @param parametersAsJson A JSON-formatted string that contains the arguments to pass to the request.
 * @return An asynchronous operation that, on successful completion, returns a StoreSendRequestResult object that provides status and error info about the request.
 */
static sendRequestAsync(
context: Windows$Services$Store$StoreContext,
requestKind: number,
parametersAsJson: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StoreSendRequestResult>
}


/**
 * Provides response data for a request that is sent to the Windows Store.
 */
declare class Windows$Services$Store$StoreSendRequestResult  {

/**
 * Gets the error code for the request, if the operation encountered an error.
 */
extendedError: Windows$WinRTError;

/**
 * Gets the HTTP status code for the request.
 */
httpStatusCode: $Values<typeof Windows$Web$Http$HttpStatusCode>;

/**
 * Gets the response data for the request.
 */
response: string
}


/**
 * Provides info for a SKU of a product in the Windows Store.
 */
declare class Windows$Services$Store$StoreSku  {

/**
 * Gets the availabilities for the current product SKU. Each product SKU can have one or more availabilities that have different prices.
 */
availabilities: Windows$Foundation$Collections$IVectorView<Windows$Services$Store$StoreAvailability>;

/**
 * Gets the list of Store IDs for the apps or add-ons that are bundled with this product SKU.
 */
bundledSkus: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets additional data for the current product SKU, if the user has an entitlement to use the SKU.
 */
collectionData: Windows$Services$Store$StoreCollectionData;

/**
 * Gets the custom developer data string (also called a tag) that contains custom information about the add-on that this product SKU represents. This string corresponds to the value of the Custom developer data field in the properties page for the add-on in the Windows Dev Center dashboard.
 */
customDeveloperData: string;

/**
 * Gets the product SKU description from the Windows Store listing.
 */
description: string;

/**
 * Gets complete data for the current product SKU from the Store in JSON format.
 */
extendedJsonData: string;

/**
 * Indicates whether this product SKU is installed on the current device.
 * @return An asynchronous operation that, on successful completion, returns true if this product SKU is installed on the current device; otherwise, false.
 */
getIsInstalledAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets the images from the Windows Store listing for the product SKU.
 */
images: Windows$Foundation$Collections$IVectorView<Windows$Services$Store$StoreImage>;

/**
 * Gets a value that indicates whether the current user has an entitlement to use the current product SKU.
 */
isInUserCollection: boolean;

/**
 * Gets a value that indicates whether the current product SKU is a subscription with recurring billing. For more information about the subscription, see the SubscriptionInfo property.
 */
isSubscription: boolean;

/**
 * Gets a value that indicates whether the current product SKU is a trial SKU.
 */
isTrial: boolean;

/**
 * Gets the language for the data in the Windows Store listing for the product SKU.
 */
language: string;

/**
 * Gets the price of the default availability for this product SKU.
 */
price: Windows$Services$Store$StorePrice;

/**
 * Requests the purchase of the product SKU and displays the UI that is used to complete the transaction via the Windows Store.
 * @return An asynchronous operation that, on successful completion, returns a StorePurchaseResult object that provides status and error info about the purchase.
 */
requestPurchaseAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StorePurchaseResult>;

/**
 * Requests the purchase of the product SKU and displays the UI that is used to complete the transaction via the Windows Store. This method provides the option to specify additional details for a specific offer within a large catalog of products that are represented by a single listing in the Windows Store, including the product name to display to the user during the purchase.
 * @param storePurchaseProperties An object that specifies additional info for the purchase request, including the product name to display to the user during the purchase.
 * @return An asynchronous operation that, on successful completion, returns a StorePurchaseResult object that provides status and error info about the purchase.
 */
requestPurchaseAsync(
storePurchaseProperties: Windows$Services$Store$StorePurchaseProperties): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Services$Store$StorePurchaseResult>;

/**
 * Gets the Store ID of this product SKU.
 */
storeId: string;

/**
 * Gets subscription information for this product SKU, if this product SKU is a subscription with recurring billing. To determine whether this product SKU is a subscription, use the IsSubscription property.
 */
subscriptionInfo: Windows$Services$Store$StoreSubscriptionInfo;

/**
 * Gets the product SKU title from the Windows Store listing.
 */
title: string;

/**
 * Gets the videos from the Windows Store listing for the product SKU.
 */
videos: Windows$Foundation$Collections$IVectorView<Windows$Services$Store$StoreVideo>
}


/**
 * Provides subscription info for a product SKU that represents a subscription with recurring billing.
 */
declare class Windows$Services$Store$StoreSubscriptionInfo  {

/**
 * Gets the duration of the billing period for a subscription, in the units specified by the BillingPeriodUnit property.
 */
billingPeriod: number;

/**
 * Gets the units of the billing period for a subscription.
 */
billingPeriodUnit: $Values<typeof Windows$Services$Store$StoreDurationUnit>;

/**
 * Gets a value that indicates whether the subscription contains a trial period.
 */
hasTrialPeriod: boolean;

/**
 * Gets the duration of the trial period for the subscription, in the units specified by the TrialPeriodUnit property. To determine whether the subscription has a trial period, use the HasTrialPeriod property.
 */
trialPeriod: number;

/**
 * Gets the units of the trial period for the subscription.
 */
trialPeriodUnit: $Values<typeof Windows$Services$Store$StoreDurationUnit>
}


/**
 * Represents a video that is associated with a product listing in the Windows Store.
 */
declare class Windows$Services$Store$StoreVideo  {

/**
 * Gets the caption for the video.
 */
caption: string;

/**
 * Gets the height of the video, in pixels.
 */
height: number;

/**
 * Gets the preview image that is displayed for the video.
 */
previewImage: Windows$Services$Store$StoreImage;

/**
 * Gets the URI of the video.
 */
uri: Windows$Foundation$Uri;

/**
 * Gets the tag for the video.
 */
videoPurposeTag: string;

/**
 * Gets the width of the video, in pixels.
 */
width: number
}


      declare var npm$namespace$Windows$Storage: {
        
        
        ApplicationDataCreateDisposition: typeof Windows$Storage$ApplicationDataCreateDisposition,
ApplicationDataLocality: typeof Windows$Storage$ApplicationDataLocality,
CreationCollisionOption: typeof Windows$Storage$CreationCollisionOption,
FileAccessMode: typeof Windows$Storage$FileAccessMode,
FileAttributes: typeof Windows$Storage$FileAttributes,
KnownFolderId: typeof Windows$Storage$KnownFolderId,
KnownLibraryId: typeof Windows$Storage$KnownLibraryId,
NameCollisionOption: typeof Windows$Storage$NameCollisionOption,
StorageDeleteOption: typeof Windows$Storage$StorageDeleteOption,
StorageItemTypes: typeof Windows$Storage$StorageItemTypes,
StorageOpenOptions: typeof Windows$Storage$StorageOpenOptions,
StreamedFileFailureMode: typeof Windows$Storage$StreamedFileFailureMode,
        ApplicationData: typeof Windows$Storage$ApplicationData,
ApplicationDataCompositeValue: typeof Windows$Storage$ApplicationDataCompositeValue,
ApplicationDataContainer: typeof Windows$Storage$ApplicationDataContainer,
ApplicationDataContainerSettings: typeof Windows$Storage$ApplicationDataContainerSettings,
CachedFileManager: typeof Windows$Storage$CachedFileManager,
DownloadsFolder: typeof Windows$Storage$DownloadsFolder,
FileIO: typeof Windows$Storage$FileIO,
KnownFolders: typeof Windows$Storage$KnownFolders,
PathIO: typeof Windows$Storage$PathIO,
SetVersionDeferral: typeof Windows$Storage$SetVersionDeferral,
SetVersionRequest: typeof Windows$Storage$SetVersionRequest,
StorageFile: typeof Windows$Storage$StorageFile,
StorageFolder: typeof Windows$Storage$StorageFolder,
StorageLibrary: typeof Windows$Storage$StorageLibrary,
StorageProvider: typeof Windows$Storage$StorageProvider,
StorageStreamTransaction: typeof Windows$Storage$StorageStreamTransaction,
StreamedFileDataRequest: typeof Windows$Storage$StreamedFileDataRequest,
SystemAudioProperties: typeof Windows$Storage$SystemAudioProperties,
SystemGPSProperties: typeof Windows$Storage$SystemGPSProperties,
SystemImageProperties: typeof Windows$Storage$SystemImageProperties,
SystemMediaProperties: typeof Windows$Storage$SystemMediaProperties,
SystemMusicProperties: typeof Windows$Storage$SystemMusicProperties,
SystemPhotoProperties: typeof Windows$Storage$SystemPhotoProperties,
SystemProperties: typeof Windows$Storage$SystemProperties,
SystemVideoProperties: typeof Windows$Storage$SystemVideoProperties,
        AccessCache: typeof npm$namespace$Windows$Storage$AccessCache,
BulkAccess: typeof npm$namespace$Windows$Storage$BulkAccess,
Compression: typeof npm$namespace$Windows$Storage$Compression,
FileProperties: typeof npm$namespace$Windows$Storage$FileProperties,
Pickers: typeof npm$namespace$Windows$Storage$Pickers,
Provider: typeof npm$namespace$Windows$Storage$Provider,
Search: typeof npm$namespace$Windows$Storage$Search,
Streams: typeof npm$namespace$Windows$Storage$Streams,
      }

      declare var npm$namespace$Windows$Storage$AccessCache: {
        
        
        AccessCacheOptions: typeof Windows$Storage$AccessCache$AccessCacheOptions,
RecentStorageItemVisibility: typeof Windows$Storage$AccessCache$RecentStorageItemVisibility,
        AccessListEntryView: typeof Windows$Storage$AccessCache$AccessListEntryView,
ItemRemovedEventArgs: typeof Windows$Storage$AccessCache$ItemRemovedEventArgs,
StorageApplicationPermissions: typeof Windows$Storage$AccessCache$StorageApplicationPermissions,
StorageItemAccessList: typeof Windows$Storage$AccessCache$StorageItemAccessList,
StorageItemMostRecentlyUsedList: typeof Windows$Storage$AccessCache$StorageItemMostRecentlyUsedList,
        
      }

/**
 * Describes the behavior to use when the app accesses an item in a list.
 */

declare  var Windows$Storage$AccessCache$AccessCacheOptions: {|
  +none: 0,// 0
+disallowUserInput: 1,// 1
+fastLocationsOnly: 2,// 2
+useReadOnlyCachedCopy: 3,// 3
+suppressAccessTimeUpdate: 4,// 4

|};



/**
 * A list of the entries that are in your app's most recently used list (MRU) (obtained from the static StorageApplicationPermissions.MostRecentlyUsedList property) and in your app's future-access list (obtained from the static StorageApplicationPermissions.FutureAccessList property).
 */
declare class Windows$Storage$AccessCache$AccessListEntryView mixins Array<Windows$Storage$AccessCache$AccessListEntry> {

/**
 * Retrieves the first storage item from the access list or most recently used (MRU) list.
 * @return The first item.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Storage$AccessCache$AccessListEntry>;

/**
 * Retrieves the storage item at the specified index in the access list or most recently used (MRU) list.
 * @param index The zero-based index of the storage item to retrieve.
 * @return The storage item.
 */
getAt(index: number): Windows$Storage$AccessCache$AccessListEntry;

/**
 * Retrieves the storage items that start at the specified index in the access list or most recently used (MRU) list.
 * @param startIndex The zero-based index of the start of the items in the collection to retrieve.
 */
getMany(
startIndex: number): {
items: Windows$Storage$AccessCache$AccessListEntry,
returnValue: number
};

/**
 * Retrieves the index of the specified storage item in the access list or most recently used (MRU) list.
 * @param value The storage item.
 */
indexOf(
value: Windows$Storage$AccessCache$AccessListEntry): {
index: number,
returnValue: boolean
};

/**
 * Gets the number of storage items in the access list or most recently used (MRU) list.
 */
size: number;
indexOf(
value: Windows$Storage$AccessCache$AccessListEntry,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Storage$AccessCache$AccessListEntry,
fromIndex?: number): number
}


/**
 * Provides data about an ItemRemoved event.
 */
declare class Windows$Storage$AccessCache$ItemRemovedEventArgs  {

/**
 * Gets information about the StorageFile or StorageFolder that was removed from the StorageItemMostRecentlyUsedList .
 */
removedEntry: Windows$Storage$AccessCache$AccessListEntry
}


/**
 * Describes the extent of the visibility of a storage item added to the most recently used (MRU) list.
 */

declare  var Windows$Storage$AccessCache$RecentStorageItemVisibility: {|
  +appOnly: 0,// 0
+appAndSystem: 1,// 1

|};



/**
 * Provides static properties for you to get your app's most recently used list (MRU) (use StorageApplicationPermissions.MostRecentlyUsedList ) and future-access list (use StorageApplicationPermissions.FutureAccessList .
 */
declare class Windows$Storage$AccessCache$StorageApplicationPermissions  {

/**
 * Gets an object that represents a list that an app maintains so that the app can store files and/or locations (like folders) and easily access these items in the future.
 */
static futureAccessList: Windows$Storage$AccessCache$StorageItemAccessList;

/**
 * Gets an object that represents a list that an app can use to track the files and/or locations (like folders) that the app has accessed most recently.
 */
static mostRecentlyUsedList: Windows$Storage$AccessCache$StorageItemMostRecentlyUsedList
}


/**
 * Represents your app's future-access list (obtained from the static StorageApplicationPermissions.FutureAccessList property). By picking files and folders, your user grants your app permission to access items that might not be accessible otherwise. If you add these items to your future-access list then you'll retain that permission when your app wants to access those items again later. Items are stored in the future-access list as StorageFile and StorageFolder objects.
 */
declare class Windows$Storage$AccessCache$StorageItemAccessList  {

/**
 * Adds a new storage item and accompanying metadata to the access list.
 * @param file The storage item to add.
 * @param metadata Optional metadata to associate with the storage item.
 * @return A token that the app can use later to retrieve the storage item.
 */
add(file: Windows$Storage$IStorageItem, metadata: string): string;

/**
 * Adds a new storage item to the access list.
 * @param file The storage item to add.
 * @return A token that the app can use later to retrieve the storage item.
 */
add(file: Windows$Storage$IStorageItem): string;

/**
 * Adds a new storage item and accompanying metadata to the access list, or replaces the specified item if it already exists in the list.
 * @param token A token that the app can use later to retrieve this storage item.
 * @param file The storage item to add or replace.
 * @param metadata Optional metadata to associate with the storage item.
 */
addOrReplace(token: string, file: Windows$Storage$IStorageItem, metadata: string): void;

/**
 * Adds a new storage item to the access list, or replaces the specified item if it already exists in the list.
 * @param token The token associated with the new storage item. If the access list already contains a storage item that has this token, the new item replaces the existing one.
 * @param file The storage item to add or replace.
 */
addOrReplace(token: string, file: Windows$Storage$IStorageItem): void;

/**
 * Determines whether the app has access to the specified storage item in the access list.
 * @param file The storage item to check for access.
 * @return True if the app can access the storage item; otherwise false.
 */
checkAccess(file: Windows$Storage$IStorageItem): boolean;

/**
 * Removes all storage items from the access list.
 */
clear(): void;

/**
 * Determines whether the access list contains the specified storage item.
 * @param token The token of the storage item to look for.
 * @return True if the access list contains the specified storage item; false otherwise.
 */
containsItem(token: string): boolean;

/**
 * Gets an object for retrieving storage items from the access list.
 */
entries: Windows$Storage$AccessCache$AccessListEntryView;

/**
 * Retrieves the specified StorageFile from the list.
 * @param token The token of the StorageFile to retrieve.
 * @return When this method completes successfully, it returns the StorageFile that is associated with the specified token.
 */
getFileAsync(
token: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Retrieves the StorageFile from the list using the specified options.
 * @param token The token of the StorageFile to retrieve.
 * @param options The enum value that describes the behavior to use when the app accesses the item.
 * @return When this method completes successfully, it returns the StorageFile that is associated with the specified token.
 */
getFileAsync(
token: string,
options: $Values<typeof Windows$Storage$AccessCache$AccessCacheOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Retrieves the specified StorageFolder from the list using the specified options.
 * @param token The token of the StorageFolder to retrieve.
 * @param options The enum value that describes the behavior to use when the app accesses the item.
 * @return When this method completes successfully, it returns the StorageFolder that is associated with the specified token.
 */
getFolderAsync(
token: string,
options: $Values<typeof Windows$Storage$AccessCache$AccessCacheOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Retrieves the specified StorageFolder from the list.
 * @param token The token of the StorageFolder to retrieve.
 * @return When this method completes successfully, it returns the StorageFolder that is associated with the specified token.
 */
getFolderAsync(
token: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Retrieves the specified item (like a file or folder) from the most recently used (MRU) list.
 * @param token The token of the item to retrieve.
 * @return When this method completes successfully, it returns the item (type IStorageItem ) that is associated with the specified token.
 */
getItemAsync(
token: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$IStorageItem>;

/**
 * Retrieves the specified item (like a file or folder) from the list using the specified options.
 * @param token The token of the item to retrieve.
 * @param options The enum value that describes the behavior to use when the app accesses the item.
 * @return When this method completes successfully, it returns the item (type IStorageItem ) that is associated with the specified token.
 */
getItemAsync(
token: string,
options: $Values<typeof Windows$Storage$AccessCache$AccessCacheOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$IStorageItem>;

/**
 * Gets the maximum number of storage items that the access list can contain.
 */
maximumItemsAllowed: number;

/**
 * Removes the specified storage item from the access list.
 * @param token The token of the storage item to remove.
 */
remove(token: string): void
}


/**
 * Represents your app's most recently used list (MRU) (obtained from the static StorageApplicationPermissions.MostRecentlyUsedList property). You use your MRU to track items (files and/or folders) that the user has accessed most recently. Items are stored in the MRU as StorageFile and StorageFolder objects.
 */
declare class Windows$Storage$AccessCache$StorageItemMostRecentlyUsedList  {

/**
 * Adds a new storage item and accompanying metadata to the most recently used (MRU) list.
 * @param file The storage item to add.
 * @param metadata Optional metadata to associate with the storage item.
 * @return A token that the app can use later to retrieve the storage item.
 */
add(file: Windows$Storage$IStorageItem, metadata: string): string;

/**
 * Adds a new storage item to the most recently used (MRU) list.
 * @param file The storage item to add.
 * @return A token that the app can use later to retrieve the storage item.
 */
add(file: Windows$Storage$IStorageItem): string;

/**
 * Adds a new storage item and accompanying metadata to the most recently used (MRU) list, specifying the extent of its visibility in the list.
 * @param file The storage item to add.
 * @param metadata Optional metadata to associate with the storage item.
 * @param visibility The extent of the visibility of the storage item in the list.
 * @return A token that the app can use later to retrieve the storage item.
 */
add(
file: Windows$Storage$IStorageItem,
metadata: string,
visibility: $Values<typeof Windows$Storage$AccessCache$RecentStorageItemVisibility>): string;

/**
 * Adds a new storage item to the most recently used (MRU) list, or replaces the specified item if it already exists in the list.
 * @param token The token associated with the new storage item. If the access list already contains a storage item that has this token, the new item replaces the existing one.
 * @param file The storage item to add or replace.
 */
addOrReplace(token: string, file: Windows$Storage$IStorageItem): void;

/**
 * Adds a new storage item and accompanying metadata to the most recently used (MRU) list, or replaces the specified item if it already exists in the list.
 * @param token The token associated with the new storage item. If the access list already contains a storage item that has this token, the new item replaces the existing one.
 * @param file The storage item to add or replace.
 * @param metadata Optional metadata to associate with the storage item.
 */
addOrReplace(token: string, file: Windows$Storage$IStorageItem, metadata: string): void;

/**
 * Adds a new storage item and accompanying metadata to the most recently used (MRU) list, or replaces the specified item if it already exists in the list. Also specifies the extent of its visibility in the list.
 * @param token The token associated with the new storage item. If the access list already contains a storage item that has this token, the new item replaces the existing one.
 * @param file The storage item to add or replace.
 * @param metadata Optional metadata to associate with the storage item.
 * @param visibility The extent of the visibility of the storage item in the list.
 */
addOrReplace(
token: string,
file: Windows$Storage$IStorageItem,
metadata: string,
visibility: $Values<typeof Windows$Storage$AccessCache$RecentStorageItemVisibility>): void;

/**
 * Determines whether the app has access to the specified storage item in the most recently used (MRU) list.
 * @param file The storage item to check for access.
 * @return True if the app can access the storage item; otherwise false.
 */
checkAccess(file: Windows$Storage$IStorageItem): boolean;

/**
 * Removes all storage items from the most recently used (MRU) list.
 */
clear(): void;

/**
 * Determines whether the most recently used (MRU) list contains the specified storage item.
 * @param token The token of the storage item to look for.
 * @return True if the MRU list contains the specified storage item; false otherwise.
 */
containsItem(token: string): boolean;

/**
 * Gets an object for retrieving storage items from the most recently used (MRU) list.
 */
entries: Windows$Storage$AccessCache$AccessListEntryView;

/**
 * Retrieves the specified storageFile from the most recently used (MRU) list using the specified options.
 * @param token The token of the storageFile to retrieve.
 * @param options The enum value that describes the behavior to use when the app accesses the item.
 * @return When this method completes successfully, it returns the storageFile that is associated with the specified token.
 */
getFileAsync(
token: string,
options: $Values<typeof Windows$Storage$AccessCache$AccessCacheOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Retrieves the specified storageFile from the most recently used (MRU) list.
 * @param token The token of the storageFile to retrieve.
 * @return When this method completes successfully, it returns the storageFile that is associated with the specified token.
 */
getFileAsync(
token: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Retrieves the specified StorageFolder from the most recently used (MRU) list.
 * @param token The token of the StorageFolder to retrieve.
 * @return When this method completes successfully, it returns the StorageFolder that is associated with the specified token.
 */
getFolderAsync(
token: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Retrieves the specified StorageFolder from the most recently used (MRU) list using the specified options.
 * @param token The token of the StorageFolder to retrieve.
 * @param options The enum value that describes the behavior to use when the app accesses the item.
 * @return When this method completes successfully, it returns the StorageFolder that is associated with the specified token.
 */
getFolderAsync(
token: string,
options: $Values<typeof Windows$Storage$AccessCache$AccessCacheOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Retrieves the specified item (like a file or folder) from the most recently used (MRU) list using the specified options.
 * @param token The token of the item to retrieve.
 * @param options The enum value that describes the behavior to use when the app accesses the item.
 * @return When this method completes successfully, it returns the item (type IStorageItem ) that is associated with the specified token.
 */
getItemAsync(
token: string,
options: $Values<typeof Windows$Storage$AccessCache$AccessCacheOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$IStorageItem>;

/**
 * Retrieves the specified item (like a file or folder) from the most recently used (MRU) list.
 * @param token The token of the item to retrieve.
 * @return When this method completes successfully, it returns the item (type IStorageItem ) that is associated with the specified token.
 */
getItemAsync(
token: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$IStorageItem>;

/**
 * Gets the maximum number of storage items that the most recently used (MRU) list can contain.
 */
maximumItemsAllowed: number;

/**
 * Fires when a storage item is removed from the most recently used (MRU) list.
 */
onitemremoved: Windows$Foundation$TypedEventHandler<Windows$Storage$AccessCache$StorageItemMostRecentlyUsedList, Windows$Storage$AccessCache$ItemRemovedEventArgs>;
addEventListener(
type: "itemremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$AccessCache$StorageItemMostRecentlyUsedList, Windows$Storage$AccessCache$ItemRemovedEventArgs>): void;
removeEventListener(
type: "itemremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$AccessCache$StorageItemMostRecentlyUsedList, Windows$Storage$AccessCache$ItemRemovedEventArgs>): void;

/**
 * Removes the specified storage item from the most recently used (MRU) list.
 * @param token The token of the storage item to remove.
 */
remove(token: string): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a list entry that contains the identifier and metadata for a StorageFile or StorageFolder object in a list.
 */
declare interface Windows$Storage$AccessCache$AccessListEntry {

/**
 * Optional app-specified metadata associated with the StorageFile or StorageFolder in the list.
 */
metadata: string,

/**
 * The identifier of the StorageFile or StorageFolder in the list.
 */
token: string
} 


/**
 * Provides access to the application data store. Application data consists of files and settings that are either local, roaming, or temporary.
 */
declare class Windows$Storage$ApplicationData  {

/**
 * Provides access to the app data store associated with the app's app package.
 */
static current: Windows$Storage$ApplicationData;

/**
 * Static method that returns the ApplicationData for a User .
 * @param user The User for which the ApplicationData is returned.
 * @return When this method completes, it returns the requested ApplicationData object.
 */
static getForUserAsync(
user: Windows$System$User): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$ApplicationData>;

/**
 * Removes all application data from the local, roaming, and temporary app data stores.
 * @return An object that is used to manage the asynchronous clear operation.
 */
clearAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Removes all application data from the specified app data store.
 * @param locality One of the enumeration values.
 * @return An object that is used to manage the asynchronous clear operation.
 */
clearAsync(
locality: $Values<typeof Windows$Storage$ApplicationDataLocality>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Clears the files and subfolders from the specified subfolder of the shared storage folder for the publisher of the current app.
 * @param folderName The subfolder of the shared storage folder for the publisher of the current app from which to clear the files and subfolders.
 * @return Represents an asynchronous action that does not return a result and does not have progress notifications. You can use this value to get the results of the operation, or to specify a method to run when the operation completes - for example, to repopulate the shared storage folder with new data.
 */
clearPublisherCacheFolderAsync(folderName: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the specified subfolder of the shared storage folder for the publisher of the current app.
 * @param folderName The subfolder to get from the shared storage folder for the publisher of the current app.
 * @return The specified subfolder.
 */
getPublisherCacheFolder(folderName: string): Windows$Storage$StorageFolder;

/**
 * Gets the folder in the local app data store where you can save files that are not included in backup and restore.
 */
localCacheFolder: Windows$Storage$StorageFolder;

/**
 * Gets the root folder in the local app data store.
 */
localFolder: Windows$Storage$StorageFolder;

/**
 * Gets the application settings container in the local app data store.
 */
localSettings: Windows$Storage$ApplicationDataContainer;

/**
 * Occurs when roaming application data is synchronized.
 */
ondatachanged: Windows$Foundation$TypedEventHandler<Windows$Storage$ApplicationData, any>;
addEventListener(
type: "datachanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$ApplicationData, any>): void;
removeEventListener(
type: "datachanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$ApplicationData, any>): void;

/**
 * Gets the root folder in the roaming app data store.
 */
roamingFolder: Windows$Storage$StorageFolder;

/**
 * Gets the application settings container in the roaming app data store.
 */
roamingSettings: Windows$Storage$ApplicationDataContainer;

/**
 * Gets the maximum size of the data that can be synchronized to the cloud from the roaming app data store.
 */
roamingStorageQuota: number;

/**
 * Sets the version number of the application data in the app data store.
 * @param desiredVersion The new version number.
 * @param handler The set version event handler.
 * @return An object that is used to manage the asynchronous set version operation.
 */
setVersionAsync(
desiredVersion: number,
handler: Windows$Storage$ApplicationDataSetVersionHandler): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the root folder in the shared app data store.
 */
sharedLocalFolder: Windows$Storage$StorageFolder;

/**
 * Sends a DataChanged | datachanged event to all registered event handlers.
 */
signalDataChanged(): void;

/**
 * Gets the root folder in the temporary app data store.
 */
temporaryFolder: Windows$Storage$StorageFolder;

/**
 * Gets the version number of the application data in the app data store.
 */
version: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents related app settings that must be serialized and deserialized atomically.
 */
declare class Windows$Storage$ApplicationDataCompositeValue  {

/**
 * Creates and initializes a new, initially empty, instance of the object.
 */
constructor(): this;

/**
 * Removes all application settings previously inserted into the composite value object, returning the object to its empty state.
 */
clear(): void;

/**
 * Retrieves an iterator to enumerate the settings in the composite value.
 * @return The iterator.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Returns a read-only snapshot of the contents of the composite value.
 * @return The view of the composite value.
 */
getView(): Windows$Foundation$Collections$IMapView<string, any>;

/**
 * Determines whether there is an application setting with the specified key.
 * @param key The key.
 * @return True if the key is found; otherwise false.
 */
hasKey(key: string): boolean;

/**
 * Creates or replaces an application setting.
 * @param key The key of the setting to insert or replace.
 * @param value The setting value.
 * @return True if an item with the specified key is an existing item and was replaced; otherwise, false.
 */
insert(key: string, value: any): boolean;

/**
 * Retrieves the specified application setting.
 * @param key The key of the setting.
 * @return The application setting.
 */
lookup(key: string): any;

/**
 * Occurs when the map changes.
 */
onmapchanged: Windows$Foundation$Collections$MapChangedEventHandler<string, any>;
addEventListener(
type: "mapchanged",
listener: Windows$Foundation$Collections$MapChangedEventHandler<string, any>): void;
removeEventListener(
type: "mapchanged",
listener: Windows$Foundation$Collections$MapChangedEventHandler<string, any>): void;

/**
 * Removes the value with the specified key.
 * @param key The key of the value to remove.
 */
remove(key: string): void;

/**
 * Removes a specific item from the ApplicationDataCompositeValue .
 * @param key The key of the item to remove.
 * @return true if the item was removed, otherwise false.
 */
remove(key: string): boolean;

/**
 * Gets the number of related application settings.
 */
size: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents a container for app settings. The methods and properties of this class support creating, deleting, enumerating, and traversing the container hierarchy.
 */
declare class Windows$Storage$ApplicationDataContainer  {

/**
 * Gets the child application settings containers of this application settings container.
 */
containers: Windows$Foundation$Collections$IMapView<string, Windows$Storage$ApplicationDataContainer>;

/**
 * Creates or opens the specified settings container in the current settings container.
 * @param name The name of the container.
 * @param disposition One of the enumeration values.
 * @return The settings container.
 */
createContainer(
name: string,
disposition: $Values<typeof Windows$Storage$ApplicationDataCreateDisposition>): Windows$Storage$ApplicationDataContainer;

/**
 * Deletes the specified settings container, its subcontainers, and all application settings in the hierarchy.
 * @param name The name of the settings container.
 */
deleteContainer(name: string): void;

/**
 * Gets the type (local or roaming) of the app data store that is associated with the current settings container.
 */
locality: $Values<typeof Windows$Storage$ApplicationDataLocality>;

/**
 * Gets the name of the current settings container.
 */
name: string;

/**
 * Gets an object that represents the settings in this settings container.
 */
values: Windows$Foundation$Collections$IPropertySet
}


/**
 * Provides access to the settings in a settings container. The ApplicationDataContainer.Values property returns an object that can be cast to this type.
 */
declare class Windows$Storage$ApplicationDataContainerSettings  {

/**
 * Removes all related application settings.
 */
clear(): void;

/**
 * Retrieves an iterator to enumerate the settings in the settings container.
 * @return The iterator.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Returns a read-only snapshot of the contents of the settings container.
 * @return The view of the settings container.
 */
getView(): Windows$Foundation$Collections$IMapView<string, any>;

/**
 * Determines whether there is an application setting with the specified key.
 * @param key The key.
 * @return True if the key is found; otherwise false.
 */
hasKey(key: string): boolean;

/**
 * Inserts or replaces an application setting.
 * @param key The key of the setting to insert or replace.
 * @param value The setting value.
 * @return True if an item with the specified key is an existing item and was replaced; otherwise, false.
 */
insert(key: string, value: any): boolean;

/**
 * Retrieves the specified application setting.
 * @param key The key of the setting.
 * @return The application setting.
 */
lookup(key: string): any;

/**
 * Occurs when the map changes.
 */
onmapchanged: Windows$Foundation$Collections$MapChangedEventHandler<string, any>;
addEventListener(
type: "mapchanged",
listener: Windows$Foundation$Collections$MapChangedEventHandler<string, any>): void;
removeEventListener(
type: "mapchanged",
listener: Windows$Foundation$Collections$MapChangedEventHandler<string, any>): void;

/**
 * Removes the specified application setting.
 * @param key The key of the setting.
 */
remove(key: string): void;

/**
 * Removes a specific item from the ApplicationDataContainerSettings .
 * @param key The key of the item to remove.
 * @return true if the item was removed, otherwise false.
 */
remove(key: string): boolean;

/**
 * Gets the number of related application settings.
 */
size: number;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies options for creating application data containers or returning existing containers. This enumeration is used by the ApplicationDataContainer.CreateContainer method.
 */

declare  var Windows$Storage$ApplicationDataCreateDisposition: {|
  +always: 0,// 0
+existing: 1,// 1

|};



/**
 * Specifies the type of an application data store.
 */

declare  var Windows$Storage$ApplicationDataLocality: {|
  +local: 0,// 0
+roaming: 1,// 1
+temporary: 2,// 2
+localCache: 3,// 3

|};



      declare var npm$namespace$Windows$Storage$BulkAccess: {
        
        
        
        FileInformation: typeof Windows$Storage$BulkAccess$FileInformation,
FileInformationFactory: typeof Windows$Storage$BulkAccess$FileInformationFactory,
FolderInformation: typeof Windows$Storage$BulkAccess$FolderInformation,
        
      }

/**
 * Provides synchronous access to the properties exposed off StorageFile and lets an app perform asynchronous file operations such as copy, delete, move, and rename.
 */
declare class Windows$Storage$BulkAccess$FileInformation  {

/**
 * Gets the attributes of a file.
 */
attributes: $Values<typeof Windows$Storage$FileAttributes>;

/**
 * Gets an object that contains the basic properties information of the file.
 */
basicProperties: Windows$Storage$FileProperties$BasicProperties;

/**
 * Gets a string that describes the contents of the file.
 */
contentType: string;

/**
 * Replaces the specified StorageFile with a copy of the current file.
 * @param fileToReplace The StorageFile to be replaced.
 * @return No object or value is returned when this method completes.
 */
copyAndReplaceAsync(
fileToReplace: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Creates a copy of the StorageFile , gives it the specified file name, and stores it in the specified StorageFolder .
 * @param destinationFolder The folder in which to store the copied file.
 * @param desiredNewName The name of the new copy.
 * @return When this method completes successfully, it returns the copy as a StorageFile object.
 */
copyAsync(
destinationFolder: Windows$Storage$IStorageFolder,
desiredNewName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Creates a copy of the StorageFile , gives it the specified file name, and stores it in the specified StorageFolder . The method also specifies what to do if a file with the same name already exists in the specified folder.
 * @param destinationFolder The folder in which to store the copied file.
 * @param desiredNewName The name of the new copy.
 * @param option A value that indicates what to do if the file name already exists in the destination folder.
 * @return When this method completes successfully, it returns the copy as a StorageFile object.
 */
copyAsync(
destinationFolder: Windows$Storage$IStorageFolder,
desiredNewName: string,
option: $Values<typeof Windows$Storage$NameCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Creates a copy of the StorageFile and stores it in the specified StorageFolder .
 * @param destinationFolder The folder in which to store the copied file.
 * @return When this method completes successfully, it returns the copy as a StorageFile object.
 */
copyAsync(
destinationFolder: Windows$Storage$IStorageFolder): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Gets the date that the file was created.
 */
dateCreated: Date;

/**
 * Deletes a file.
 * @return No object or value is returned when this method completes.
 */
deleteAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Deletes a file, optionally moving the deleted file to the recycle bin.
 * @param option A value that specifies whether the deleted file is moved to the recycle bin.
 * @return No object or value is returned when this method completes.
 */
deleteAsync(
option: $Values<typeof Windows$Storage$StorageDeleteOption>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the user-friendly name of the StorageFile .
 */
displayName: string;

/**
 * Gets the display type of the StorageFile .
 */
displayType: string;

/**
 * Gets an object that provides access to the document properties of the StorageFile , such as the title, author name, and so on.
 */
documentProperties: Windows$Storage$FileProperties$DocumentProperties;

/**
 * Gets the file type.
 */
fileType: string;

/**
 * Gets the identifier that uniquely identifies the StorageFile relative to other items in the same folder.
 */
folderRelativeId: string;

/**
 * Retrieves the basic properties of the StorageFile .
 * @return When this method completes successfully, it returns a BasicProperties object.
 */
getBasicPropertiesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$BasicProperties>;

/**
 * Gets the parent folder of the current file.
 * @return When this method completes, it returns the parent folder as a StorageFolder .
 */
getParentAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Retrieves the thumbnail that is associated with the StorageFile .
 * @param mode The thumbnail mode to retrieve.
 * @return When this method completes successfully, it returns the thumbnail image as a StorageItemThumbnail object.
 */
getThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Retrieves the thumbnail that is associated with the StorageFile , scaling it to the specified size.
 * @param mode The thumbnail mode to retrieve.
 * @param requestedSize The requested size in pixels of thumbnail to retrieve.
 * @return When this method completes successfully, it returns the thumbnail image as a StorageItemThumbnail object.
 */
getThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>,
requestedSize: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Retrieves the thumbnail that is associated with the StorageFile , based on the specified options.
 * @param mode The thumbnail mode to retrieve.
 * @param requestedSize The requested size in pixels of thumbnail to retrieve.
 * @param options The thumbnail retrieval options.
 * @return When this method completes successfully, it returns the thumbnail image as a StorageItemThumbnail object.
 */
getThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>,
requestedSize: number,
options: $Values<typeof Windows$Storage$FileProperties$ThumbnailOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Gets the image properties of the StorageFile , such as the title, rating, date that the image was taken, and so on.
 */
imageProperties: Windows$Storage$FileProperties$ImageProperties;

/**
 * Indicates if the current file has been downloaded or can be downloaded.
 */
isAvailable: boolean;

/**
 * Indicates whether the current file is the same as the specified storage item.
 * @param item The IStorageItem object that represents a storage item to compare against.
 * @return Returns true if the current storage item is the same as the specified storage item; otherwise false.
 */
isEqual(item: Windows$Storage$IStorageItem): boolean;

/**
 * Determines whether the loaded StorageFile is the specified type.
 * @param type The type of item to check against.
 * @return True if the loaded StorageFile is the specified type; otherwise false.
 */
isOfType(type: $Values<typeof Windows$Storage$StorageItemTypes>): boolean;

/**
 * Moves the current StorageFile from its location and uses it to replace the specified StorageFile.
 * @param fileToReplace The StorageFile to be replaced.
 * @return An object for managing the asynchronous move and replace operation.
 */
moveAndReplaceAsync(
fileToReplace: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Moves the StorageFile to the specified StorageFolder .
 * @param destinationFolder The destination folder.
 * @return No object or value is returned when this method completes.
 */
moveAsync(
destinationFolder: Windows$Storage$IStorageFolder): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Moves the StorageFile to the specified folder and gives it the specified file name. The method also specifies what to do if a file with the same name already exists in the specified folder.
 * @param destinationFolder The destination folder.
 * @param desiredNewName The new file name.
 * @param option A value that indicates what to do if the file name already exists in the destination folder.
 * @return No object or value is returned when this method completes.
 */
moveAsync(
destinationFolder: Windows$Storage$IStorageFolder,
desiredNewName: string,
option: $Values<typeof Windows$Storage$NameCollisionOption>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Moves the StorageFile to the specified folder, and gives the file the specified file name.
 * @param destinationFolder The destination folder.
 * @param desiredNewName The new file name.
 * @return No object or value is returned when this method completes.
 */
moveAsync(
destinationFolder: Windows$Storage$IStorageFolder,
desiredNewName: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the music properties associated with the StorageFile , such as the album name, artist name, bit rate, and so on.
 */
musicProperties: Windows$Storage$FileProperties$MusicProperties;

/**
 * Gets the name of the StorageFile .
 */
name: string;

/**
 * Occurs when one or more of the StorageFile 's properties is updated.
 */
onpropertiesupdated: Windows$Foundation$TypedEventHandler<Windows$Storage$BulkAccess$IStorageItemInformation, any>;
addEventListener(
type: "propertiesupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$BulkAccess$IStorageItemInformation, any>): void;
removeEventListener(
type: "propertiesupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$BulkAccess$IStorageItemInformation, any>): void;

/**
 * Fires when the StorageFile 's thumbnail is updated or a better quality thumbnail is available.
 */
onthumbnailupdated: Windows$Foundation$TypedEventHandler<Windows$Storage$BulkAccess$IStorageItemInformation, any>;
addEventListener(
type: "thumbnailupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$BulkAccess$IStorageItemInformation, any>): void;
removeEventListener(
type: "thumbnailupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$BulkAccess$IStorageItemInformation, any>): void;

/**
 * Opens a random-access stream with the specified options over the specified file.
 * @param accessMode One of the enumeration values that specifies the type of access to allow.
 * @return When this method completes, it returns an IRandomAccessStream that contains the requested random-access stream.
 */
openAsync(
accessMode: $Values<typeof Windows$Storage$FileAccessMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStream>;

/**
 * Opens a random-access stream with the specified options over the specified file.
 * @param accessMode One of the enumeration values that specifies the type of access to allow.
 * @param options A bitwise combination of the enumeration values that specify options for opening the stream.
 * @return When this method completes, it returns an IRandomAccessStream that contains the requested random-access stream.
 */
openAsync(
accessMode: $Values<typeof Windows$Storage$FileAccessMode>,
options: $Values<typeof Windows$Storage$StorageOpenOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStream>;

/**
 * Opens a read-only, random-access stream over the StorageFile .
 * @return When this method completes successfully, it returns a read-only, random-access stream (type IRandomAccessStreamWithContentType ).
 */
openReadAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStreamWithContentType>;

/**
 * Opens a read-only, sequential-access stream over the StorageFile .
 * @return When this method completes successfully, it returns a read-only, sequential-access stream (type IInputStream ).
 */
openSequentialReadAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IInputStream>;

/**
 * Opens a random-access stream to the file that can be used for transacted-write operations.
 * @return When this method completes, it returns a StorageStreamTransaction that contains the random-access stream and methods that can be used to complete transactions.
 */
openTransactedWriteAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageStreamTransaction>;

/**
 * Opens a random-access stream to the file that can be used for transacted-write operations with the specified options.
 * @param options A bitwise combination of the enumeration values that specify options for opening the stream.
 * @return When this method completes, it returns a StorageStreamTransaction that contains the random-access stream and methods that can be used to complete transactions.
 */
openTransactedWriteAsync(
options: $Values<typeof Windows$Storage$StorageOpenOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageStreamTransaction>;

/**
 * Gets the path of the StorageFile .
 */
path: string;

/**
 * Gets an object for retrieving the properties of the StorageFile .
 */
properties: Windows$Storage$FileProperties$StorageItemContentProperties;

/**
 * Gets the StorageProvider object that contains info about the service that stores the current file.
 */
provider: Windows$Storage$StorageProvider;

/**
 * Renames the StorageFile .
 * @param desiredName The new name.
 * @return No object or value is returned when this method completes.
 */
renameAsync(desiredName: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Renames the StorageFile , and specifies what to do if a file with the same name already exists in the current folder.
 * @param desiredName The new name.
 * @param option A value that indicates what to do if the file name already exists in the current folder.
 * @return No object or value is returned when this method completes.
 */
renameAsync(
desiredName: string,
option: $Values<typeof Windows$Storage$NameCollisionOption>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the thumbnail associated with the StorageFile .
 */
thumbnail: Windows$Storage$FileProperties$StorageItemThumbnail;

/**
 * Gets an object that provides access to the video properties of the StorageFile , such as the duration, rating, date released, and so on.
 */
videoProperties: Windows$Storage$FileProperties$VideoProperties;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Used to load information about files and folders from the results of a query and to bind these file system items to JavaScript ListView or XAML ListView and GridView controls. After information is loaded, an app can then access that information quickly using synchronous operations.
 */
declare class Windows$Storage$BulkAccess$FileInformationFactory  {

/**
 * Creates a new FileInformationFactory object that retrieves information about the StorageFile and StorageFolder objects in the specified query result, specifies the requested size and options for thumbnails that are retrieved for the objects, and indicates whether to delay loading information.
 * @param queryResult The result of a query of files and folders on the system.
 * @param mode A value that indicates the type of thumbnail view to retrieve for the StorageFile and StorageFolder .
 * @param requestedThumbnailSize The requested minimum size, in pixels, of the StorageFile and StorageFolder thumbnails.
 * @param thumbnailOptions The thumbnail retrieval options.
 * @param delayLoad True to delay loading information; otherwise false. By default, this option is false and delay loading is not used.
 */
constructor(queryResult: Windows$Storage$Search$IStorageQueryResultBase, mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>, requestedThumbnailSize: number, thumbnailOptions: $Values<typeof Windows$Storage$FileProperties$ThumbnailOptions>, delayLoad: boolean): this;

/**
 * Creates a new FileInformationFactory object that retrieves information about the StorageFile and StorageFolder objects in the specified query result, and that specifies the requested size and options for thumbnails that are retrieved for the objects.
 * @param queryResult The result of a query of files and folders on the system.
 * @param mode A value that indicates the type of thumbnail view to retrieve for the StorageFile and StorageFolder .
 * @param requestedThumbnailSize The requested minimum size, in pixels, of the StorageFile and StorageFolder thumbnails.
 * @param thumbnailOptions The thumbnail retrieval options.
 */
constructor(queryResult: Windows$Storage$Search$IStorageQueryResultBase, mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>, requestedThumbnailSize: number, thumbnailOptions: $Values<typeof Windows$Storage$FileProperties$ThumbnailOptions>): this;

/**
 * Creates a new FileInformationFactory object that retrieves information about the StorageFile and StorageFolder objects in the specified query result and that specifies the requested size for thumbnails that are retrieved for the objects.
 * @param queryResult The result of a query of files and folders on the system.
 * @param mode A value that indicates the type of thumbnail view to retrieve for the StorageFile and StorageFolder .
 * @param requestedThumbnailSize The requested minimum size, in pixels, of the StorageFile and StorageFolder thumbnails.
 */
constructor(queryResult: Windows$Storage$Search$IStorageQueryResultBase, mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>, requestedThumbnailSize: number): this;

/**
 * Creates a new FileInformationFactory object that retrieves information about the StorageFile and StorageFolder objects in the specified query result.
 * @param queryResult The result of a query of files and folders on the system.
 * @param mode A value that indicates the type of thumbnail view to retrieve for the StorageFile and StorageFolder .
 */
constructor(queryResult: Windows$Storage$Search$IStorageQueryResultBase, mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>): this;

/**
 * Retrieves a collection of FileInformation objects that contain information about a range of StorageFile objects in a collection.
 * @param startIndex The zero-based index of the first StorageFile in the range.
 * @param maxItemsToRetrieve The maximum number of StorageFile objects to retrieve information for.
 * @return When this method completes successfully, it returns the list (type IVectorView ) of FileInformation objects.
 */
getFilesAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a collection of FileInformation objects that contain information about all StorageFile objects in a collection.
 * @return When this method completes successfully, it returns the list (type IVectorView ) of FileInformation objects.
 */
getFilesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a collection of FolderInformation objects that contain information about a range of StorageFolder objects in a collection.
 * @param startIndex The zero-based index of the first StorageFolder in the range.
 * @param maxItemsToRetrieve The maximum number of StorageFolder objects to retrieve information for.
 * @return When this method completes successfully, it returns the list (type IVectorView ) of FolderInformation objects.
 */
getFoldersAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a collection of FolderInformation objects that contain information about all StorageFolder objects in a collection.
 * @return When this method completes successfully, it returns the list (type IVectorView ) of FolderInformation objects.
 */
getFoldersAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a collection of IStorageItemInformation objects that contain information about all the items in the collection.
 * @return When this method completes successfully, it returns the list (type IVectorView ) of FileInformation and FolderInformation objects.
 */
getItemsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a collection of IStorageItemInformation objects that contain information about a range of items in a collection.
 * @param startIndex The zero-based index of the first item in the range.
 * @param maxItemsToRetrieve The maximum number of items to retrieve information for.
 * @return When this method completes successfully, it returns the list (type IVectorView ) of FileInformation and FolderInformation objects.
 */
getItemsAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets a virtualized vector of IStorageItemInformation objects that can be bound to ListView or GridView controls in C#, C++, and VB.
 * @return The virtualized vector of IStorageItemInformation objects.
 */
getVirtualizedFilesVector(): any;

/**
 * Gets a virtualized vector of IStorageItemInformation objects that can be bound to ListView or GridView controls in C#, C++, and VB.
 * @return The virtualized vector of IStorageItemInformation objects.
 */
getVirtualizedFoldersVector(): any;

/**
 * Gets a virtualized vector of IStorageItemInformation objects that can be bound to ListView or GridView controls in C#, C++, and VB.
 * @return The virtualized vector of IStorageItemInformation objects.
 */
getVirtualizedItemsVector(): any
}


/**
 * Provides synchronous access to the properties exposed off StorageFolder and lets an app perform asynchronous management operations such as copy, delete, move, and rename.
 */
declare class Windows$Storage$BulkAccess$FolderInformation  {

/**
 * Retrieves a value that indicates whether the folder supports the specified search query options.
 * @param queryOptions The search query options to test.
 * @return True if the folder supports the specified search query options; otherwise false.
 */
areQueryOptionsSupported(queryOptions: Windows$Storage$Search$QueryOptions): boolean;

/**
 * Gets the attributes of a loaded folder.
 */
attributes: $Values<typeof Windows$Storage$FileAttributes>;

/**
 * Gets an object that contains the basic properties information of the folder.
 */
basicProperties: Windows$Storage$FileProperties$BasicProperties;

/**
 * Creates a new file in the current folder.
 * @param desiredName The name of the new file.
 * @return When this method completes successfully, it returns a StorageFile that represents the new file.
 */
createFileAsync(
desiredName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Creates a new file in the current folder, and specifies what to do if a file with the same name already exists in the current folder.
 * @param desiredName The name of the new file.
 * @param options A value that indicates what to do if the file name already exists in the current folder.
 * @return When this method completes successfully, it returns a StorageFile that represents the new file.
 */
createFileAsync(
desiredName: string,
options: $Values<typeof Windows$Storage$CreationCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Creates an object for performing filtered search queries for StorageFile in the current folder.
 * @return An object for managing the search queries and accessing the results.
 */
createFileQuery(): Windows$Storage$Search$StorageFileQueryResult;

/**
 * Creates an object for performing filtered search queries for StorageFile objects in the current folder. Search results are grouped based on the specified file attribute.
 * @param query A value that specifies the folder attribute to use to group the search results.
 * @return An object for managing the search queries and accessing the results.
 */
createFileQuery(
query: $Values<typeof Windows$Storage$Search$CommonFileQuery>): Windows$Storage$Search$StorageFileQueryResult;

/**
 * Creates an object used to perform filtered search queries for StorageFile objects in the folder. The object is initialized with the specified query options.
 * @param queryOptions The initial query options.
 * @return An object for managing the search queries and accessing the results.
 */
createFileQueryWithOptions(
queryOptions: Windows$Storage$Search$QueryOptions): Windows$Storage$Search$StorageFileQueryResult;

/**
 * Creates a new child folder of the current folder, and specifies what to do if a folder with the same name already exists in the current folder.
 * @param desiredName The name of the new folder.
 * @param options A value that indicates what to do if the child folder already exists in the current folder.
 * @return When this method completes successfully, it returns a StorageFolder that represents the new file.
 */
createFolderAsync(
desiredName: string,
options: $Values<typeof Windows$Storage$CreationCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Creates a new child folder of the current folder.
 * @param desiredName The name of the new folder.
 * @return When this method completes successfully, it returns a StorageFolder that represents the new file.
 */
createFolderAsync(
desiredName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Creates an object for performing filtered search queries for child StorageFolder objects of the current folder.
 * @return An object for managing the search queries and accessing the results.
 */
createFolderQuery(): Windows$Storage$Search$StorageFolderQueryResult;

/**
 * Creates an object for performing filtered search queries for child StorageFolder objects of the current folder. Search results are grouped based on the specified folder attribute.
 * @param query A value that specifies the folder attribute to use to group the search results.
 * @return An object for managing the search queries and accessing the results.
 */
createFolderQuery(
query: $Values<typeof Windows$Storage$Search$CommonFolderQuery>): Windows$Storage$Search$StorageFolderQueryResult;

/**
 * Creates an object used to perform filtered search queries for child StorageFolder objects of the current folder. The object is initialized with the specified query options.
 * @param queryOptions The initial query options.
 * @return An object for managing the search queries and accessing the results.
 */
createFolderQueryWithOptions(
queryOptions: Windows$Storage$Search$QueryOptions): Windows$Storage$Search$StorageFolderQueryResult;

/**
 * Creates an object used to perform filtered search queries for items in the folder.
 * @return An object for managing the search queries and accessing the results.
 */
createItemQuery(): Windows$Storage$Search$StorageItemQueryResult;

/**
 * Creates an object used to perform filtered search queries for items in the folder. The object is initialized with the specified query options.
 * @param queryOptions The initial query options.
 * @return An object for managing the search queries and accessing the results.
 */
createItemQueryWithOptions(
queryOptions: Windows$Storage$Search$QueryOptions): Windows$Storage$Search$StorageItemQueryResult;

/**
 * Gets the date that the folder was created.
 */
dateCreated: Date;

/**
 * Deletes the current folder.
 * @return No object or value is returned when this method completes.
 */
deleteAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Deletes the current folder, optionally moving the deleted folder to the recycle bin.
 * @param option A value that specifies whether to move the deleted folder to the recycle bin.
 * @return No object or value is returned when this method completes.
 */
deleteAsync(
option: $Values<typeof Windows$Storage$StorageDeleteOption>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the user-friendly name of the StorageFolder .
 */
displayName: string;

/**
 * Gets the display type of the StorageFolder .
 */
displayType: string;

/**
 * Gets the document properties of the StorageFolder .
 */
documentProperties: Windows$Storage$FileProperties$DocumentProperties;

/**
 * Gets the identifier that uniquely identifies the StorageFolder relative to other items in the same folder.
 */
folderRelativeId: string;

/**
 * Retrieves the basic properties of the StorageFolder object.
 * @return When this method completes successfully, it returns a BasicProperties object.
 */
getBasicPropertiesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$BasicProperties>;

/**
 * Retrieves a file from the current folder.
 * @param name The name of the file to retrieve.
 * @return When this method completes successfully, it returns a StorageFile .
 */
getFileAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Retrieves all files from the current folder.
 * @return When this method completes successfully, it returns the list (type IVectorView ) of StorageFile objects in the folder.
 */
getFilesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves files from the current folder based on a common folder query.
 * @param query The common file query.
 * @return When this method completes successfully, it returns the list (type IVectorView ) of StorageFile objects in the folder.
 */
getFilesAsync(
query: $Values<typeof Windows$Storage$Search$CommonFileQuery>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a range of files from the current folder based on a common file query.
 * @param query The common file query.
 * @param startIndex The zero-based index of the first file in the range.
 * @param maxItemsToRetrieve The maximum number of files to retrieve.
 * @return When this method completes successfully, it returns the list (type IVectorView ) of StorageFile objects in the folder.
 */
getFilesAsync(
query: $Values<typeof Windows$Storage$Search$CommonFileQuery>,
startIndex: number,
maxItemsToRetrieve: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves the specified child folder from the current folder.
 * @param name The name of the child folder to retrieve.
 * @return When this method completes successfully, it returns a StorageFolder that represents the specified child folder.
 */
getFolderAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Retrieves all child folders from the current folder.
 * @return When this method completes successfully, it returns the list (type IVectorView ) of child folders. Each child folder in this list is represented by a StorageFolder object.
 */
getFoldersAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a range of child folders from the current folder based on a common folder query.
 * @param query The common folder query.
 * @param startIndex The zero-based index of the first child folder in the range.
 * @param maxItemsToRetrieve The maximum number of child folders to retrieve.
 * @return When this method completes successfully, it returns the list (type IVectorView ) of child folders. Each child folder in this list is represented by a StorageFolder object.
 */
getFoldersAsync(
query: $Values<typeof Windows$Storage$Search$CommonFolderQuery>,
startIndex: number,
maxItemsToRetrieve: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves child folders from the current folder based on a common folder query.
 * @param query The common folder query.
 * @return When this method completes successfully, it returns the list (type IVectorView ) of child folders. Each child folder in this list is represented by a StorageFolder object.
 */
getFoldersAsync(
query: $Values<typeof Windows$Storage$Search$CommonFolderQuery>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves the indexed state of the folder.
 * @return When this method completes successfully, it returns an IndexedState enumeration value.
 */
getIndexedStateAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Storage$Search$IndexedState>>;

/**
 * Retrieves an item from the folder.
 * @param name The name of the item to retrieve.
 * @return When this method completes successfully, it returns the item (type IStorageItem ).
 */
getItemAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$IStorageItem>;

/**
 * Retrieves all items from the current folder.
 * @return When this method completes successfully, it returns the list (type IVectorView ) of items.
 */
getItemsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a range of items from the current folder.
 * @param startIndex The zero-based index of the first item in the range.
 * @param maxItemsToRetrieve The maximum number of items to retrieve.
 * @return When this method completes successfully, it returns the list (type IVectorView ) of items.
 */
getItemsAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the parent folder of the current folder.
 * @return When this method completes, it returns the parent folder as a StorageFolder .
 */
getParentAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Retrieves the thumbnail that is associated with the StorageFolder , scaling it to the specified size.
 * @param mode The thumbnail mode to retrieve.
 * @param requestedSize The requested size in pixels of thumbnail to retrieve.
 * @return When this method completes successfully, it returns the thumbnail image as a StorageItemThumbnail object.
 */
getThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>,
requestedSize: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Retrieves the thumbnail that is associated with the StorageFolder .
 * @param mode The thumbnail mode to retrieve.
 * @return When this method completes successfully, it returns the thumbnail image as a StorageItemThumbnail object.
 */
getThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Retrieves the thumbnail that is associated with the StorageFolder , based on the specified options.
 * @param mode The thumbnail mode to retrieve.
 * @param requestedSize The requested size in pixels of thumbnail to retrieve.
 * @param options The thumbnail retrieval options.
 * @return When this method completes successfully, it returns the thumbnail image as a StorageItemThumbnail object.
 */
getThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>,
requestedSize: number,
options: $Values<typeof Windows$Storage$FileProperties$ThumbnailOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Gets the image properties of the StorageFolder .
 */
imageProperties: Windows$Storage$FileProperties$ImageProperties;

/**
 * Retrieves a value that indicates whether the current folder supports the specified common file query.
 * @param query The common file query to test.
 * @return True if the folder supports the specified common file query; otherwise false.
 */
isCommonFileQuerySupported(query: $Values<typeof Windows$Storage$Search$CommonFileQuery>): boolean;

/**
 * Retrieves a value that indicates whether the current folder supports the specified common folder query.
 * @param query The common folder query to test.
 * @return True if the folder supports the specified common folder query; otherwise false.
 */
isCommonFolderQuerySupported(query: $Values<typeof Windows$Storage$Search$CommonFolderQuery>): boolean;

/**
 * Indicates whether the current folder is equal to the specified folder.
 * @param item The IStorageItem object that represents the folder to compare against.
 * @return Returns true if the current folder is equal to the specified folder; otherwise false.
 */
isEqual(item: Windows$Storage$IStorageItem): boolean;

/**
 * Determines whether the loaded StorageFolder is the specified type.
 * @param type The type of item to check against.
 * @return True if the loaded StorageFolder is the specified type; otherwise false.
 */
isOfType(type: $Values<typeof Windows$Storage$StorageItemTypes>): boolean;

/**
 * Gets the music properties associated with the StorageFolder .
 */
musicProperties: Windows$Storage$FileProperties$MusicProperties;

/**
 * Gets the name of the StorageFolder .
 */
name: string;

/**
 * Occurs when one or more of the StorageFolder 's properties is updated.
 */
onpropertiesupdated: Windows$Foundation$TypedEventHandler<Windows$Storage$BulkAccess$IStorageItemInformation, any>;
addEventListener(
type: "propertiesupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$BulkAccess$IStorageItemInformation, any>): void;
removeEventListener(
type: "propertiesupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$BulkAccess$IStorageItemInformation, any>): void;

/**
 * Fires when the StorageFolder 's thumbnail is updated or a better quality thumbnail is available.
 */
onthumbnailupdated: Windows$Foundation$TypedEventHandler<Windows$Storage$BulkAccess$IStorageItemInformation, any>;
addEventListener(
type: "thumbnailupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$BulkAccess$IStorageItemInformation, any>): void;
removeEventListener(
type: "thumbnailupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$BulkAccess$IStorageItemInformation, any>): void;

/**
 * Gets the path of the StorageFolder .
 */
path: string;

/**
 * Gets an object for retrieving the properties of the StorageFolder .
 */
properties: Windows$Storage$FileProperties$StorageItemContentProperties;

/**
 * Gets the StorageProvider object that contains info about the service that stores the current folder.
 */
provider: Windows$Storage$StorageProvider;

/**
 * Renames the StorageFolder .
 * @param desiredName The new name.
 * @return No object or value is returned when this method completes.
 */
renameAsync(desiredName: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Renames the StorageFolder , and specifies what to do if a folder with the same name already exists.
 * @param desiredName The new name.
 * @param option A value that indicates what to do if a folder with desiredName already exists.
 * @return No object or value is returned when this method completes.
 */
renameAsync(
desiredName: string,
option: $Values<typeof Windows$Storage$NameCollisionOption>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the thumbnail for the StorageFile .
 */
thumbnail: Windows$Storage$FileProperties$StorageItemThumbnail;

/**
 * Try to get a specific file or sub-folder from the current folder using the name of the file or folder to get.
 * @param name The name (or path relative to the current folder) of the file or sub-folder to try to retrieve.
 * @return When this method completes successfully, it returns the file or folder (type IStorageItem ).
 */
tryGetItemAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$IStorageItem>;

/**
 * Gets the video properties that are associated with the StorageFolder .
 */
videoProperties: Windows$Storage$FileProperties$VideoProperties;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides synchronous access to the properties of a file or folder in the file system.
 */
declare interface Windows$Storage$BulkAccess$IStorageItemInformation {

/**
 * Gets an object that contains the basic properties information of the item.
 */
basicProperties: Windows$Storage$FileProperties$BasicProperties,

/**
 * Gets an object that provides access to the document properties of the item, such as the title, author name, and so on.
 */
documentProperties: Windows$Storage$FileProperties$DocumentProperties,

/**
 * Gets an object that provides access to the image properties of the item, such as the title, rating, date that the image was taken, and so on.
 */
imageProperties: Windows$Storage$FileProperties$ImageProperties,

/**
 * Gets an object that provides access to the music properties of the item, such as the album name, artist name, bit rate, and so on.
 */
musicProperties: Windows$Storage$FileProperties$MusicProperties,

/**
 * Gets the thumbnail associated with the item.
 */
thumbnail: Windows$Storage$FileProperties$StorageItemThumbnail,

/**
 * Gets an object that provides access to the video properties of the item, such as the duration, rating, date released, and so on.
 */
videoProperties: Windows$Storage$FileProperties$VideoProperties
} 


/**
 * Lets apps manage real-time updates to files.
 */
declare class Windows$Storage$CachedFileManager  {

/**
 * Initiates updates for the specified file. This method contacts the app that provided the file to perform the updates.
 * @param file The file to update.
 * @return When this method completes, it returns a FileUpdateStatus enum value that describes the status of the updates to the file.
 */
static completeUpdatesAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Storage$Provider$FileUpdateStatus>>;

/**
 * Lets apps defer real-time updates for a specified file.
 * @param file The file to defer updates for.
 */
static deferUpdates(file: Windows$Storage$IStorageFile): void
}


      declare var npm$namespace$Windows$Storage$Compression: {
        
        
        CompressAlgorithm: typeof Windows$Storage$Compression$CompressAlgorithm,
        Compressor: typeof Windows$Storage$Compression$Compressor,
Decompressor: typeof Windows$Storage$Compression$Decompressor,
        
      }

/**
 * Identifies a compression algorithm to use when creating an instance of a compressor.
 */

declare  var Windows$Storage$Compression$CompressAlgorithm: {|
  +invalidAlgorithm: 0,// 0
+nullAlgorithm: 1,// 1
+mszip: 2,// 2
+xpress: 3,// 3
+xpressHuff: 4,// 4
+lzms: 5,// 5

|};



/**
 * A compressor takes information written to a stream and compresses it using a compression algorithm.
 */
declare class Windows$Storage$Compression$Compressor  {

/**
 * Creates an instance of a compressor.
 * @param underlyingStream The stream of compressed information to be written by the compressor.
 */
constructor(underlyingStream: Windows$Storage$Streams$IOutputStream): this;

/**
 * Creates an instance of a compressor.
 * @param underlyingStream The stream of compressed information to be written by the compressor.
 * @param algorithm The compression algorithm used by the compressor to write underlyingStream.
 * @param blockSize Size in bytes of the intermediate buffer used by the compression algorithm. A value of 0 specifies that the compression algorithm will use its default block size. Valid non-zero values for this parameter are 32Kb to 64Mb.
 */
constructor(underlyingStream: Windows$Storage$Streams$IOutputStream, algorithm: $Values<typeof Windows$Storage$Compression$CompressAlgorithm>, blockSize: number): this;

/**
 * Closes a Compressor object and synchronously discards any information in buffers. This will close the underlying stream as well unless the Compressor.Detach method has been used to detach the stream from the object. Subsequent calls on a closed object, except for Compressor.Close, will fail.
 */
close(): void;

/**
 * Detaches the underlying stream from the Compressor object so that the object can be closed using the Compressor.Close method without also closing the underlying stream.
 * @return The stream of information.
 */
detachStream(): Windows$Storage$Streams$IOutputStream;

/**
 * Finishes writing the compression stream.
 * @return The asynchronous operation.
 */
finishAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Flushes the compression stream asynchronously.
 * @return The asynchronous operation.
 */
flushAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Writes information to the compression stream asynchronously.
 * @param buffer The buffer that contains the information to be written to the stream.
 * @return The asynchronous operation.
 */
writeAsync(
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * A decompressor takes a stream compressed by a compressor and decompresses it.
 */
declare class Windows$Storage$Compression$Decompressor  {

/**
 * This method creates an instance of a decompressor.
 * @param underlyingStream The stream of compressed information to be read and decompressed by the decompressor.
 */
constructor(underlyingStream: Windows$Storage$Streams$IInputStream): this;

/**
 * Closes a Decompressor object and synchronously discards any information in buffers. This will close the underlying stream as well unless the Decompressor.Detach method has been used to detach the stream from the object. Subsequent calls on a closed object, except Decompressor.Close, will fail.
 */
close(): void;

/**
 * Detaches the underlying stream from the Decompressor object so that the object can be closed using the Decompressor.Close method without also closing the underlying stream.
 * @return The stream of information.
 */
detachStream(): Windows$Storage$Streams$IInputStream;

/**
 * Reads from the compression stream asynchronously.
 * @param buffer The buffer that contains the information to be read from the stream.
 * @param count The number of bytes to read.
 * @param options Read options
 * @return The asynchronous operation.
 */
readAsync(
buffer: Windows$Storage$Streams$IBuffer,
count: number,
options: $Values<typeof Windows$Storage$Streams$InputStreamOptions>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>
}


/**
 * Specifies what to do if a file or folder with the specified name already exists in the current folder when you create a new file or folder.
 */

declare  var Windows$Storage$CreationCollisionOption: {|
  +generateUniqueName: 0,// 0
+replaceExisting: 1,// 1
+failIfExists: 2,// 2
+openIfExists: 3,// 3

|};



/**
 * Creates files and folders inside the Downloads folder.
 */
declare class Windows$Storage$DownloadsFolder  {

/**
 * Creates a new file inside the Downloads folder.
 * @param desiredName The desired name of the file to create.
 * @return When this method completes, it returns the new file as a StorageFile object.
 */
static createFileAsync(
desiredName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Creates a new file in the Downloads folder, and specifies what to do if a file with the same name already exists in the Downloads folder.
 * @param desiredName The desired name of the file to create.
 * @param option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing file in the current folder.
 * @return When this method completes, it returns the new file as a StorageFile object.
 */
static createFileAsync(
desiredName: string,
option: $Values<typeof Windows$Storage$CreationCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Creates a new file inside the Downloads folder of a specific User .
 * @param user The User for which the file is created.
 * @param desiredName The desired name of the file to create.
 * @return When this method completes, it returns the new file as a StorageFile object.
 */
static createFileForUserAsync(
user: Windows$System$User,
desiredName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Creates a new file in the Downloads folder of a specific User , and specifies what to do if a file with the same name already exists in the Downloads folder.
 * @param user The User for which the file is created.
 * @param desiredName The desired name of the file to create.
 * @param option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing file in the current folder.
 * @return When this method completes, it returns the new file as a StorageFile object.
 */
static createFileForUserAsync(
user: Windows$System$User,
desiredName: string,
option: $Values<typeof Windows$Storage$CreationCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Creates a new subfolder in the Downloads folder.
 * @param desiredName The desired name of the subfolder to create.
 * @return When this method completes, it returns the new subfolder as a StorageFolder .
 */
static createFolderAsync(
desiredName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Creates a new subfolder in the Downloads folder, and specifies what to do if a subfolder with the same name already exists in the Downloads folder.
 * @param desiredName The desired name of the subfolder to create.
 * @param option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing subfolder in the Downloads folder.
 * @return When this method completes, it returns the new subfolder as a StorageFolder .
 */
static createFolderAsync(
desiredName: string,
option: $Values<typeof Windows$Storage$CreationCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Creates a new subfolder inside the Downloads folder of a specific User .
 * @param user The User for which the folder is created.
 * @param desiredName The desired name of the subfolder to create.
 * @return When this method completes, it returns the new subfolder as a StorageFolder .
 */
static createFolderForUserAsync(
user: Windows$System$User,
desiredName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Creates a new subfolder in the Downloads folder of a specific User , and specifies what to do if a subfolder with the same name already exists in the Downloads folder.
 * @param user The User for which the folder is created.
 * @param desiredName The desired name of the subfolder to create.
 * @param option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing subfolder in the Downloads folder.
 * @return When this method completes, it returns the new subfolder as a StorageFolder .
 */
static createFolderForUserAsync(
user: Windows$System$User,
desiredName: string,
option: $Values<typeof Windows$Storage$CreationCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>
}


/**
 * Specifies whether to access a file in read-only mode or in read/write mode.
 */

declare  var Windows$Storage$FileAccessMode: {|
  +read: 0,// 0
+readWrite: 1,// 1

|};



/**
 * Describes the attributes of a file or folder.
 */

declare  var Windows$Storage$FileAttributes: {|
  +normal: 0,// 0
+readOnly: 1,// 1
+directory: 2,// 2
+archive: 3,// 3
+temporary: 4,// 4
+locallyIncomplete: 5,// 5

|};



/**
 * Provides helper methods for reading and writing files that are represented by objects of type IStorageFile .
 */
declare class Windows$Storage$FileIO  {

/**
 * Appends lines of text to the specified file.
 * @param file The file that the lines are appended to.
 * @param lines The list of text strings to append as lines.
 * @return No object or value is returned when this method completes.
 */
static appendLinesAsync(
file: Windows$Storage$IStorageFile,
lines: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Appends lines of text to the specified file using the specified character encoding.
 * @param file The file that the lines are appended to.
 * @param lines The list of text strings to append as lines.
 * @param encoding The character encoding of the file.
 * @return No object or value is returned when this method completes.
 */
static appendLinesAsync(
file: Windows$Storage$IStorageFile,
lines: Windows$Foundation$Collections$IIterable<string>,
encoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Appends text to the specified file.
 * @param file The file that the text is appended to.
 * @param contents The text to append.
 * @return No object or value is returned when this method completes.
 */
static appendTextAsync(
file: Windows$Storage$IStorageFile,
contents: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Appends text to the specified file using the specified character encoding.
 * @param file The file that the text is appended to.
 * @param contents The text to append.
 * @param encoding The character encoding of the file.
 * @return No object or value is returned when this method completes.
 */
static appendTextAsync(
file: Windows$Storage$IStorageFile,
contents: string,
encoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Reads the contents of the specified file and returns a buffer.
 * @param file The file to read.
 * @return When this method completes, it returns an object (type IBuffer ) that represents the contents of the file.
 */
static readBufferAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>;

/**
 * Reads the contents of the specified file and returns lines of text.
 * @param file The file to read.
 * @return When this method completes successfully, it returns the contents of the file as a list (type IVector ) of lines of text. Each line of text in the list is represented by a String object.
 */
static readLinesAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVector<any>>;

/**
 * Reads the contents of the specified file using the specified character encoding and returns lines of text.
 * @param file The file to read.
 * @param encoding The character encoding to use.
 * @return When this method completes successfully, it returns the contents of the file as a list (type IVector ) of lines of text. Each line of text in the list is represented by a String object.
 */
static readLinesAsync(
file: Windows$Storage$IStorageFile,
encoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVector<any>>;

/**
 * Reads the contents of the specified file and returns text.
 * @param file The file to read.
 * @return When this method completes successfully, it returns the contents of the file as a text string.
 */
static readTextAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Reads the contents of the specified file using the specified character encoding and returns text.
 * @param file The file to read.
 * @param encoding The character encoding to use.
 * @return When this method completes successfully, it returns the contents of the file as a text string.
 */
static readTextAsync(
file: Windows$Storage$IStorageFile,
encoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Writes data from a buffer to the specified file.
 * @param file The file that the buffer of data is written to.
 * @param buffer The buffer that contains the data to write.
 * @return No object or value is returned when this method completes.
 */
static writeBufferAsync(
file: Windows$Storage$IStorageFile,
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Writes an array of bytes of data to the specified file.
 * @param file The file that the byte is written to.
 * @param buffer The array of bytes to write.
 * @return No object or value is returned when this method completes.
 */
static writeBytesAsync(
file: Windows$Storage$IStorageFile,
buffer: number[]): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Writes lines of text to the specified file.
 * @param file The file that the lines are written to.
 * @param lines The list of text strings to write as lines.
 * @return No object or value is returned when this method completes.
 */
static writeLinesAsync(
file: Windows$Storage$IStorageFile,
lines: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Writes lines of text to the specified file using the specified character encoding.
 * @param file The file that the lines are written to.
 * @param lines The list of text strings to write as lines.
 * @param encoding The character encoding of the file.
 * @return No object or value is returned when this method completes.
 */
static writeLinesAsync(
file: Windows$Storage$IStorageFile,
lines: Windows$Foundation$Collections$IIterable<string>,
encoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Writes text to the specified file.
 * @param file The file that the text is written to.
 * @param contents The text to write.
 * @return No object or value is returned when this method completes.
 */
static writeTextAsync(
file: Windows$Storage$IStorageFile,
contents: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Writes text to the specified file using the specified character encoding.
 * @param file The file that the text is written to.
 * @param contents The text to write.
 * @param encoding The character encoding of the file.
 * @return No object or value is returned when this method completes.
 */
static writeTextAsync(
file: Windows$Storage$IStorageFile,
contents: string,
encoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>): Windows$Foundation$IPromiseWithIAsyncAction
}


      declare var npm$namespace$Windows$Storage$FileProperties: {
        
        
        PhotoOrientation: typeof Windows$Storage$FileProperties$PhotoOrientation,
PropertyPrefetchOptions: typeof Windows$Storage$FileProperties$PropertyPrefetchOptions,
ThumbnailMode: typeof Windows$Storage$FileProperties$ThumbnailMode,
ThumbnailOptions: typeof Windows$Storage$FileProperties$ThumbnailOptions,
ThumbnailType: typeof Windows$Storage$FileProperties$ThumbnailType,
VideoOrientation: typeof Windows$Storage$FileProperties$VideoOrientation,
        BasicProperties: typeof Windows$Storage$FileProperties$BasicProperties,
DocumentProperties: typeof Windows$Storage$FileProperties$DocumentProperties,
GeotagHelper: typeof Windows$Storage$FileProperties$GeotagHelper,
ImageProperties: typeof Windows$Storage$FileProperties$ImageProperties,
MusicProperties: typeof Windows$Storage$FileProperties$MusicProperties,
StorageItemContentProperties: typeof Windows$Storage$FileProperties$StorageItemContentProperties,
StorageItemThumbnail: typeof Windows$Storage$FileProperties$StorageItemThumbnail,
VideoProperties: typeof Windows$Storage$FileProperties$VideoProperties,
        
      }

/**
 * Provides access to the basic properties, like the size of the item or the date the item was last modified, of the item (like a file or folder).
 */
declare class Windows$Storage$FileProperties$BasicProperties  {

/**
 * Gets the timestamp of the last time the file was modified.
 */
dateModified: Date;

/**
 * Gets the most relevant date for the item.
 */
itemDate: Date;

/**
 * Retrieves the specified properties associated with the item.
 * @param propertiesToRetrieve A collection that contains the names of the properties to retrieve.
 * @return When this method completes successfully, it returns a collection (type IMap ) that contains the specified properties and values as key-value pairs.
 */
retrievePropertiesAsync(
propertiesToRetrieve: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IMap<any, any>>;

/**
 * Saves the specified properties and values associated with the item.
 * @param propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
 * @return No object or value is returned when this method completes.
 */
savePropertiesAsync(
propertiesToSave: Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Saves all properties associated with the item.
 * @return No object or value is returned when this method completes.
 */
savePropertiesAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the size of the file.
 */
size: number
}


/**
 * Provides access to the document-related properties of an item (like a file or folder).
 */
declare class Windows$Storage$FileProperties$DocumentProperties  {

/**
 * Gets the collection of the document's authors.
 */
author: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets or sets the comments associated with the document.
 */
comment: string;

/**
 * Gets the collection of keywords associated with the document.
 */
keywords: Windows$Foundation$Collections$IVector<string>;

/**
 * Retrieves the specified properties associated with the item.
 * @param propertiesToRetrieve A collection that contains the names of the properties to retrieve.
 * @return An object for managing the asynchronous property retrieval operation.
 */
retrievePropertiesAsync(
propertiesToRetrieve: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IMap<any, any>>;

/**
 * Saves the specified properties and values associated with the item.
 * @param propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
 * @return No object or value is returned when this method completes.
 */
savePropertiesAsync(
propertiesToSave: Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Saves all properties associated with the item.
 * @return No object or value is returned when this method completes.
 */
savePropertiesAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets or sets the title of the document.
 */
title: string
}


/**
 * Provides methods for setting and retrieving geographic metadata for a file.
 */
declare class Windows$Storage$FileProperties$GeotagHelper  {

/**
 * Asynchronously retrieves a Geopoint representing the geographic metadata of a file, if present.
 * @param file The file from which the geographic metadata is retrieved.
 * @return An asynchronous operation that returns a Geopoint on successful completion.
 */
static getGeotagAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Devices$Geolocation$Geopoint>;

/**
 * Asynchronously sets the geographic metadata of a file from the provided Geopoint .
 * @param file The file into which the geographic metadata is set.
 * @param geopoint The Geopoint representing the geographic metadata to be set.
 * @return An asynchronous action.
 */
static setGeotagAsync(
file: Windows$Storage$IStorageFile,
geopoint: Windows$Devices$Geolocation$Geopoint): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously sets the geographic metadata of a file to the device's current location using the provided Geolocator object.
 * @param file The file into which the geographic metadata is set.
 * @param geolocator The Geolocator object that will be used to determine the device's current location.
 * @return An asychronous action.
 */
static setGeotagFromGeolocatorAsync(
file: Windows$Storage$IStorageFile,
geolocator: Windows$Devices$Geolocation$Geolocator): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Provides access to the image-related properties of an item (like a file or folder).
 */
declare class Windows$Storage$FileProperties$ImageProperties  {

/**
 * Gets or sets the manufacturer of the camera that took the photo.
 */
cameraManufacturer: string;

/**
 * Gets or sets the model of the camera that took the photo.
 */
cameraModel: string;

/**
 * Gets or sets the date when the image was taken.
 */
dateTaken: Date;

/**
 * Gets the height of the image.
 */
height: number;

/**
 * Gets the collection of keywords associated with the image.
 */
keywords: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets the latitude coordinate where the photo was taken.
 */
latitude: number;

/**
 * Gets the longitude coordinate where the photo was taken.
 */
longitude: number;

/**
 * Gets the Exchangeable Image File (EXIF) orientation flag of the photo.
 */
orientation: $Values<typeof Windows$Storage$FileProperties$PhotoOrientation>;

/**
 * Gets the names of people who are tagged in the photo.
 */
peopleNames: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets or sets the rating associated with an image file.
 */
rating: number;

/**
 * Retrieves the specified properties associated with the item.
 * @param propertiesToRetrieve A collection that contains the names of the properties to retrieve.
 * @return When this method completes successfully, it returns a collection (type IMap ) that contains the specified properties and values as key-value pairs.
 */
retrievePropertiesAsync(
propertiesToRetrieve: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IMap<any, any>>;

/**
 * Saves the specified properties and values associated with the item.
 * @param propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
 * @return No object or value is returned when this method completes.
 */
savePropertiesAsync(
propertiesToSave: Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Saves all properties associated with the item.
 * @return No object or value is returned when this method completes.
 */
savePropertiesAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets or sets the title of the image.
 */
title: string;

/**
 * Gets the width of the image.
 */
width: number
}


/**
 * Provides access to the music-related properties of an item (like a file or folder).
 */
declare class Windows$Storage$FileProperties$MusicProperties  {

/**
 * Gets or sets the name of the album that contains the song.
 */
album: string;

/**
 * Gets or sets the name of the album artist of the song.
 */
albumArtist: string;

/**
 * Gets the artists that contributed to the song.
 */
artist: string;

/**
 * Gets the bit rate of the song file.
 */
bitrate: number;

/**
 * Gets the composers of the song.
 */
composers: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets the conductors of the song.
 */
conductors: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets the duration of the song in milliseconds.
 */
duration: number;

/**
 * Gets the names of music genres that the song belongs to.
 */
genre: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets the producers of the song.
 */
producers: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets or sets the publisher of the song.
 */
publisher: string;

/**
 * Gets or sets the rating associated with a music file.
 */
rating: number;

/**
 * Retrieves the specified properties associated with the item.
 * @param propertiesToRetrieve A collection that contains the names of the properties to retrieve.
 * @return When this method completes successfully, it returns a collection (type IMap ) that contains the specified properties and values as key-value pairs.
 */
retrievePropertiesAsync(
propertiesToRetrieve: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IMap<any, any>>;

/**
 * Saves the specified properties and values associated with the item.
 * @param propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
 * @return No object or value is returned when this method completes.
 */
savePropertiesAsync(
propertiesToSave: Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Saves all properties associated with the item.
 * @return No object or value is returned when this method completes.
 */
savePropertiesAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets or sets the subtitle of the song.
 */
subtitle: string;

/**
 * Gets or sets the title of the song
 */
title: string;

/**
 * Gets or sets the track number of the song on the song's album.
 */
trackNumber: number;

/**
 * Gets the songwriters.
 */
writers: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets or sets the year that the song was released.
 */
year: number
}


/**
 * Indicates the Exchangeable Image File (EXIF) orientation flag of the photo. This flag describes how to rotate the photo to display it correctly.
 */

declare  var Windows$Storage$FileProperties$PhotoOrientation: {|
  +unspecified: 0,// 0
+normal: 1,// 1
+flipHorizontal: 2,// 2
+rotate180: 3,// 3
+flipVertical: 4,// 4
+transpose: 5,// 5
+rotate270: 6,// 6
+transverse: 7,// 7
+rotate90: 8,// 8

|};



/**
 * Indicates a system-defined group of file properties.
 */

declare  var Windows$Storage$FileProperties$PropertyPrefetchOptions: {|
  +none: 0,// 0
+musicProperties: 1,// 1
+videoProperties: 2,// 2
+imageProperties: 3,// 3
+documentProperties: 4,// 4
+basicProperties: 5,// 5

|};



/**
 * Provides access to the content-related properties of an item (like a file or folder).
 */
declare class Windows$Storage$FileProperties$StorageItemContentProperties  {

/**
 * Retrieves the document properties of the item (like a file of folder).
 * @return When this method completes successfully, it returns a documentProperties object.
 */
getDocumentPropertiesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$DocumentProperties>;

/**
 * Retrieves the image properties of the item (like a file of folder).
 * @return When this method completes successfully, it returns an imageProperties object.
 */
getImagePropertiesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$ImageProperties>;

/**
 * Retrieves the music properties of the item (like a file of folder).
 * @return When this method completes successfully, it returns a musicProperties object.
 */
getMusicPropertiesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$MusicProperties>;

/**
 * Retrieves the video properties of the item (like a file of folder).
 * @return When this method completes successfully, it returns a videoProperties object.
 */
getVideoPropertiesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$VideoProperties>;

/**
 * Retrieves the specified properties associated with the item.
 * @param propertiesToRetrieve A collection that contains the names of the properties to retrieve.
 * @return When this method completes successfully, it returns a collection (type IMap ) that contains the specified properties and values as key-value pairs. The return value of properties can be null.
 */
retrievePropertiesAsync(
propertiesToRetrieve: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IMap<any, any>>;

/**
 * Saves all properties associated with the item.
 * @return No object or value is returned when this method completes.
 */
savePropertiesAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Saves the specified properties and values associated with the item.
 * @param propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
 * @return No object or value is returned when this method completes.
 */
savePropertiesAsync(
propertiesToSave: Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Represents the thumbnail image associated with a system resource (like a file or folder).
 */
declare class Windows$Storage$FileProperties$StorageItemThumbnail  {

/**
 * Gets a value that indicates whether the thumbnail stream can be read from.
 */
canRead: boolean;

/**
 * Gets a value that indicates whether the thumbnail stream can be written to.
 */
canWrite: boolean;

/**
 * Creates a new stream over the thumbnail that is represented by the current storageItemThumbnail object.
 * @return The new thumbnail stream. The initial, internal position of the stream is 0.
 */
cloneStream(): Windows$Storage$Streams$IRandomAccessStream;

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 */
close(): void;

/**
 * Gets the MIME content type of the thumbnail image.
 */
contentType: string;

/**
 * Flushes data asynchronously in a sequential stream.
 * @return The stream flush operation.
 */
flushAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Retrieves the thumbnail image data as an undecoded stream.
 * @param position The position in the storage item to start reading thumbnail image data.
 * @return An object for reading the thumbnail image data.
 */
getInputStreamAt(position: number): Windows$Storage$Streams$IInputStream;

/**
 * Retrieves an output stream object for writing thumbnail image data to a storage item.
 * @param position The position in the storage item to start writing thumbnail image data.
 * @return The output stream.
 */
getOutputStreamAt(position: number): Windows$Storage$Streams$IOutputStream;

/**
 * Gets the original (not scaled) height of the thumbnail image.
 */
originalHeight: number;

/**
 * Gets the original (not scaled) width of the thumbnail image.
 */
originalWidth: number;

/**
 * Gets the byte offset of the thumbnail stream.
 */
position: number;

/**
 * Returns an asynchronous byte reader object.
 * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param count The number of bytes to read that is less than or equal to the Capacity value.
 * @param options Specifies the type of the asynchronous read operation.
 * @return The asynchronous operation.
 */
readAsync(
buffer: Windows$Storage$Streams$IBuffer,
count: number,
options: $Values<typeof Windows$Storage$Streams$InputStreamOptions>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>;

/**
 * Gets a value that indicates whether the thumbnail image returned was a cached version with a smaller size.
 */
returnedSmallerCachedSize: boolean;

/**
 * Sets the offset of the thumbnail stream to the specified value.
 * @param position The number of bytes from the start of the thumbnail stream where the position of the thumbnail stream is set.
 */
seek(position: number): void;

/**
 * Gets or sets the size of the thumbnail image.
 */
size: number;

/**
 * Gets a value that indicates if the thumbnail is an icon or an image.
 */
type: $Values<typeof Windows$Storage$FileProperties$ThumbnailType>;

/**
 * Writes data asynchronously in a sequential stream.
 * @param buffer The buffer into which the asynchronous writer operation writes.
 * @return The byte writer operation.
 */
writeAsync(
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Describes the purpose of the thumbnail to determine how to adjust the thumbnail image to retrieve.
 */

declare  var Windows$Storage$FileProperties$ThumbnailMode: {|
  +picturesView: 0,// 0
+videosView: 1,// 1
+musicView: 2,// 2
+documentsView: 3,// 3
+listView: 4,// 4
+singleItem: 5,// 5

|};



/**
 * Describes the behavior used to retrieve and adjust thumbnails, including the size and quality of the image and how quickly the thumbnail image is retrieved.
 */

declare  var Windows$Storage$FileProperties$ThumbnailOptions: {|
  +none: 0,// 0
+returnOnlyIfCached: 1,// 1
+resizeThumbnail: 2,// 2
+useCurrentScale: 3,// 3

|};



/**
 * Indicates whether the thumbnail is an icon or an image.
 */

declare  var Windows$Storage$FileProperties$ThumbnailType: {|
  +image: 0,// 0
+icon: 1,// 1

|};



/**
 * Indicates how to rotate the video to display it correctly.
 */

declare  var Windows$Storage$FileProperties$VideoOrientation: {|
  +normal: 0,// 0
+rotate90: 1,// 1
+rotate180: 2,// 2
+rotate270: 3,// 3

|};



/**
 * Provides access to the video-related properties of an item (like a file or folder).
 */
declare class Windows$Storage$FileProperties$VideoProperties  {

/**
 * Gets the sum audio and video bitrate of the video.
 */
bitrate: number;

/**
 * Gets the directors of the video.
 */
directors: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets the duration of the video.
 */
duration: number;

/**
 * Gets the height of the video.
 */
height: number;

/**
 * Gets the collection of keywords associated with the video.
 */
keywords: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets the latitude coordinate where the video was shot.
 */
latitude: number;

/**
 * Gets the longitude coordinate where the video was shot.
 */
longitude: number;

/**
 * Gets a VideoOrientation value that indicates how the video should be rotated to display it correctly.
 */
orientation: $Values<typeof Windows$Storage$FileProperties$VideoOrientation>;

/**
 * Gets the producers of the video.
 */
producers: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets or sets the publisher of the video.
 */
publisher: string;

/**
 * Gets or sets the rating associated with a video file.
 */
rating: number;

/**
 * Retrieves the specified properties associated with the item.
 * @param propertiesToRetrieve A collection that contains the names of the properties to retrieve.
 * @return When this method completes successfully, it returns a collection (type IMap ) that contains the specified properties and values as key-value pairs.
 */
retrievePropertiesAsync(
propertiesToRetrieve: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IMap<any, any>>;

/**
 * Saves the specified properties and values associated with the item.
 * @param propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
 * @return No object or value is returned when this method completes.
 */
savePropertiesAsync(
propertiesToSave: Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Saves all properties associated with the item.
 * @return No object or value is returned when this method completes.
 */
savePropertiesAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets or sets the subtitle of the video.
 */
subtitle: string;

/**
 * Gets or sets the title of the video.
 */
title: string;

/**
 * Gets the width of the video.
 */
width: number;

/**
 * Gets the script writers for the video.
 */
writers: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets or sets the year that the video was shot or released.
 */
year: number
}


/**
 * Provides values that identify storage folders.
 */

declare  var Windows$Storage$KnownFolderId: {|
  +appCaptures: 0,// 0
+cameraRoll: 1,// 1
+documentsLibrary: 2,// 2
+homeGroup: 3,// 3
+mediaServerDevices: 4,// 4
+musicLibrary: 5,// 5
+objects3D: 6,// 6
+picturesLibrary: 7,// 7
+playlists: 8,// 8
+recordedCalls: 9,// 9
+removableDevices: 10,// 10
+savedPictures: 11,// 11
+screenshots: 12,// 12
+videosLibrary: 13,// 13

|};



/**
 * Provides access to common locations that contain user content. This includes content from a user's local libraries (such as Documents, Pictures, Music, and Videos), HomeGroup, removable devices, and media server devices.
 */
declare class Windows$Storage$KnownFolders  {

/**
 * Gets the App Captures folder.
 */
static appCaptures: Windows$Storage$StorageFolder;

/**
 * Gets the Camera Roll folder.
 */
static cameraRoll: Windows$Storage$StorageFolder;

/**
 * Gets the Documents library. The Documents library is not intended for general use.
 */
static documentsLibrary: Windows$Storage$StorageFolder;

/**
 * Static method that returns a specified known folder for a User .
 * @param user The User for which the folder is returned.
 * @param folderId The ID of the folder to be returned.
 * @return When this method completes, it returns the requested StorageFolder object.
 */
static getFolderForUserAsync(
user: Windows$System$User,
folderId: $Values<typeof Windows$Storage$KnownFolderId>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Gets the HomeGroup folder.
 */
static homeGroup: Windows$Storage$StorageFolder;

/**
 * Gets the folder of media server (DLNA) devices.
 */
static mediaServerDevices: Windows$Storage$StorageFolder;

/**
 * Gets the Music library.
 */
static musicLibrary: Windows$Storage$StorageFolder;

/**
 * Gets the Objects 3D folder.
 */
static objects3D: Windows$Storage$StorageFolder;

/**
 * Gets the Pictures library.
 */
static picturesLibrary: Windows$Storage$StorageFolder;

/**
 * Gets the play lists folder.
 */
static playlists: Windows$Storage$StorageFolder;

/**
 * Gets the recorded calls folder.
 */
static recordedCalls: Windows$Storage$StorageFolder;

/**
 * Gets the removable devices folder.
 */
static removableDevices: Windows$Storage$StorageFolder;

/**
 * Gets the Saved Pictures folder.
 */
static savedPictures: Windows$Storage$StorageFolder;

/**
 * Gets the Videos library.
 */
static videosLibrary: Windows$Storage$StorageFolder
}


/**
 * Provides values that identify storage libraries.
 */

declare  var Windows$Storage$KnownLibraryId: {|
  +music: 0,// 0
+pictures: 1,// 1
+videos: 2,// 2
+documents: 3,// 3

|};



/**
 * Specifies what to do if a file or folder with the specified name already exists in the current folder when you copy, move, or rename a file or folder.
 */

declare  var Windows$Storage$NameCollisionOption: {|
  +generateUniqueName: 0,// 0
+replaceExisting: 1,// 1
+failIfExists: 2,// 2

|};



/**
 * Provides helper methods for reading and writing a file using the absolute path or URI of the file.
 */
declare class Windows$Storage$PathIO  {

/**
 * Appends lines of text to the file at the specified path or URI using the specified character encoding.
 * @param absolutePath The path of the file that the lines are appended to.
 * @param lines The list of text strings to append as lines.
 * @param encoding The character encoding of the file.
 * @return No object or value is returned when this method completes.
 */
static appendLinesAsync(
absolutePath: string,
lines: Windows$Foundation$Collections$IIterable<string>,
encoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Appends lines of text to the file at the specified path or URI.
 * @param absolutePath The path or URI of the file that the lines are appended to.
 * @param lines The list of text strings to append as lines.
 * @return No object or value is returned when this method completes.
 */
static appendLinesAsync(
absolutePath: string,
lines: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Appends text to the file at the specified path or URI using the specified character encoding.
 * @param absolutePath The path of the file that the text is appended to.
 * @param contents The text to append.
 * @param encoding The character encoding of the file.
 * @return No object or value is returned when this method completes.
 */
static appendTextAsync(
absolutePath: string,
contents: string,
encoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Appends text to the file at the specified path or URI.
 * @param absolutePath The path of the file that the text is appended to.
 * @param contents The text to append.
 * @return No object or value is returned when this method completes.
 */
static appendTextAsync(
absolutePath: string,
contents: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Reads the contents of the file at the specified path or URI and returns a buffer.
 * @param absolutePath The path of the file to read.
 * @return When this method completes, it returns an object (type IBuffer ) that represents the contents of the file.
 */
static readBufferAsync(
absolutePath: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IBuffer>;

/**
 * Reads the contents of the file at the specified path or URI and returns lines of text.
 * @param absolutePath The path of the file to read.
 * @return When this method completes successfully, it returns the contents of the file as a list (type IVector ) of lines of text. Each line of text in the list is represented by a String object.
 */
static readLinesAsync(
absolutePath: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVector<any>>;

/**
 * Reads the contents of the file at the specified path or URI using the specified character encoding and returns lines of text.
 * @param absolutePath The path of the file to read.
 * @param encoding The character encoding of the file.
 * @return When this method completes successfully, it returns the contents of the file as a list (type IVector ) of lines of text. Each line of text in the list is represented by a String object.
 */
static readLinesAsync(
absolutePath: string,
encoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVector<any>>;

/**
 * Reads the contents of the file at the specified path or URI and returns text.
 * @param absolutePath The path of the file to read.
 * @return When this method completes successfully, it returns the contents of the file as a text string.
 */
static readTextAsync(absolutePath: string): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Reads the contents of the file at the specified path or URI using the specified character encoding and returns text.
 * @param absolutePath The path of the file to read.
 * @param encoding The character encoding of the file.
 * @return When this method completes successfully, it returns the contents of the file as a text string.
 */
static readTextAsync(
absolutePath: string,
encoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Writes data from a buffer to the file at the specified path or URI.
 * @param absolutePath The path of the file that the data is written to.
 * @param buffer The buffer that contains the data to write.
 * @return No object or value is returned when this method completes.
 */
static writeBufferAsync(
absolutePath: string,
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Writes a single byte of data to the file at the specified path or URI.
 * @param absolutePath The path of the file that the byte is written to.
 * @param buffer An array of bytes to write.
 * @return No object or value is returned when this method completes.
 */
static writeBytesAsync(
absolutePath: string,
buffer: number[]): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Writes lines of text to the file at the specified path or URI using the specified character encoding.
 * @param absolutePath The path of the file that the lines are appended to.
 * @param lines The list of text strings to append as lines.
 * @param encoding The character encoding of the file.
 * @return No object or value is returned when this method completes.
 */
static writeLinesAsync(
absolutePath: string,
lines: Windows$Foundation$Collections$IIterable<string>,
encoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Writes lines of text to the file at the specified path or URI.
 * @param absolutePath The path of the file that the lines are written to.
 * @param lines The list of text strings to append as lines.
 * @return No object or value is returned when this method completes.
 */
static writeLinesAsync(
absolutePath: string,
lines: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Writes text to the file at the specified path or URI.
 * @param absolutePath The path of the file that the text is written to.
 * @param contents The text to write.
 * @return No object or value is returned when this method completes.
 */
static writeTextAsync(
absolutePath: string,
contents: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Writes text to the file at the specified path or URI using the specified character encoding.
 * @param absolutePath The path of the file that the text is written to.
 * @param contents The text to write.
 * @param encoding The character encoding of the file.
 * @return No object or value is returned when this method completes.
 */
static writeTextAsync(
absolutePath: string,
contents: string,
encoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>): Windows$Foundation$IPromiseWithIAsyncAction
}


      declare var npm$namespace$Windows$Storage$Pickers: {
        
        
        PickerLocationId: typeof Windows$Storage$Pickers$PickerLocationId,
PickerViewMode: typeof Windows$Storage$Pickers$PickerViewMode,
        FileExtensionVector: typeof Windows$Storage$Pickers$FileExtensionVector,
FileOpenPicker: typeof Windows$Storage$Pickers$FileOpenPicker,
FilePickerFileTypesOrderedMap: typeof Windows$Storage$Pickers$FilePickerFileTypesOrderedMap,
FilePickerSelectedFilesArray: typeof Windows$Storage$Pickers$FilePickerSelectedFilesArray,
FileSavePicker: typeof Windows$Storage$Pickers$FileSavePicker,
FolderPicker: typeof Windows$Storage$Pickers$FolderPicker,
        Provider: typeof npm$namespace$Windows$Storage$Pickers$Provider,
      }

/**
 * Represents a random-access collection of file name extensions.
 */
declare class Windows$Storage$Pickers$FileExtensionVector mixins Array<string> {

/**
 * Appends a file name extension to the end of the collection.
 * @param value The file name extension to append.
 */
append(value: string): void;

/**
 * Removes all file name extensions from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator that iterates through the file name extensions in the collection.
 * @return The iterator.
 */
first(): Windows$Foundation$Collections$IIterator<string>;

/**
 * Retrieves the file name extension at the specified index in the collection.
 * @param index The zero-based index of the file name extension to retrieve.
 * @return The file name extension at the specified index.
 */
getAt(index: number): string;

/**
 * Retrieves the file name extensions that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the file name extensions in the collection to retrieve.
 */
getMany(startIndex: number): {
items: string[],
returnValue: number
};

/**
 * Retrieves an immutable view of the collection of file name extensions.
 * @return The view of the collection.
 */
getView(): Windows$Foundation$Collections$IVectorView<string>;

/**
 * Retrieves the index of a specified file name extension in the collection.
 * @param value The file name extension to find in the collection.
 */
indexOf(value: string): {
index: number,
returnValue: boolean
};

/**
 * Inserts a file name extension into a collection at a specified index.
 * @param index Zero-based index of the location at which to insert the file name extension.
 * @param value The file name extension to insert.
 */
insertAt(index: number, value: string): void;

/**
 * Removes the file name extension at the specified index in the collection.
 * @param index The zero-based index of the file name extension to remove.
 */
removeAt(index: number): void;

/**
 * Removes the last file name extension from the collection.
 */
removeAtEnd(): void;

/**
 * Replaces all file name extensions in the collection with the specified file name extensions.
 * @param items The collection of file name extensions to put in the vector.
 */
replaceAll(items: string[]): void;

/**
 * Sets the file name extension at the specified index of the collection.
 * @param index The zero-based index of the location at which to set the file name extension.
 * @param value The file name extension.
 */
setAt(index: number, value: string): void;

/**
 * Gets the number of file name extensions in the collection.
 */
size: number;
indexOf(value: string, ...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(searchElement: string, fromIndex?: number): number
}


/**
 * Represents a UI element that lets the user choose and open files.
 */
declare class Windows$Storage$Pickers$FileOpenPicker  {
static resumePickSingleFileAsync: any;

/**
 * Creates a new instance of a FileOpenPicker .
 */
constructor(): this;

/**
 * Gets or sets the label text of the file open picker's commit button.
 */
commitButtonText: string;

/**
 * Gets a set of values to be populated by the app before PickSingleFileAndContinue or PickMultipleFilesAndContinue operation that deactivates the app in order to provide context when the app is activated. (Windows Phone Store apps)
 */
continuationData: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the collection of file types that the file open picker displays.
 */
fileTypeFilter: Windows$Foundation$Collections$IVector<string>;

/**
 * Shows the file picker so that the user can pick multiple files, deactivating and the app and reactivating it when the operation is complete. (Windows Phone Store apps)
 */
pickMultipleFilesAndContinue(): void;

/**
 * Shows the file picker so that the user can pick multiple files. (Windows Store apps)
 * @return When the call to this method completes successfully, it returns a filePickerSelectedFilesArray object that contains all the files that were picked by the user. Picked files in this array are represented by storageFile objects.
 */
pickMultipleFilesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Shows the file picker so that the user can pick one file, potentially deactivating the app and reactivating it when the operation is complete. (Windows Phone Store apps)
 */
pickSingleFileAndContinue(): void;

/**
 * Shows the file picker so that the user can pick one file.
 * @return When the call to this method completes successfully, it returns a StorageFile object that represents the file that the user picked.
 */
pickSingleFileAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Shows the file picker so that the user can pick one file.
 * @param pickerOperationId This argument is ignored and has no effect.
 * @return When the call to this method completes successfully, it returns a StorageFile object that represents the file that the user picked.
 */
pickSingleFileAsync(
pickerOperationId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Gets or sets the settings identifier associated with the state of the file open picker.
 */
settingsIdentifier: string;

/**
 * Gets or sets the initial location where the file open picker looks for files to present to the user.
 */
suggestedStartLocation: $Values<typeof Windows$Storage$Pickers$PickerLocationId>;

/**
 * Gets or sets the view mode that the file open picker uses to display items.
 */
viewMode: $Values<typeof Windows$Storage$Pickers$PickerViewMode>
}


/**
 * Represents a collection of display names mapped to the associated file types (extensions). Each element in this collection maps a display name to a corresponding collection of file name extensions. The key is a single string, the value is a list/vector of strings representing one or more extension choices.
 */
declare class Windows$Storage$Pickers$FilePickerFileTypesOrderedMap  {

/**
 * Removes all display names and associated file name extensions from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator that iterates through the display names and associated file types in the collection.
 * @return The iterator.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Returns an immutable view of the collection of display names and associated file types.
 * @return The view of the collection.
 */
getView(
): Windows$Foundation$Collections$IMapView<string, Windows$Foundation$Collections$IVector<string>>;

/**
 * Determines whether the mapped collection of display names and associated file types contains the specified key.
 * @param key The key.
 * @return True if the key is found; otherwise, false.
 */
hasKey(key: string): boolean;

/**
 * Inserts or replaces an item in the mapped collection of display names and associated file types.
 * @param key The key associated with the item to insert.
 * @param value The item to insert.
 * @return true if an item with the specified key is an existing item and was replaced; otherwise false.
 */
insert(key: string, value: Windows$Foundation$Collections$IVector<string>): boolean;

/**
 * Returns the item at the specified key in the mapped collection of display names and associated file types.
 * @param key The key to use to locate the item.
 * @return The item associated with the specified key.
 */
lookup(key: string): Windows$Foundation$Collections$IVector<string>;

/**
 * Removes an item from the mapped collection of display names and associated file types.
 * @param key The key associated with the item to remove.
 */
remove(key: string): void;

/**
 * Gets the number of items in the mapped collection of display names and associated file types.
 */
size: number
}


/**
 * Represents a collection of storage files that the user has selected by using a file picker.
 */
declare class Windows$Storage$Pickers$FilePickerSelectedFilesArray mixins Array<Windows$Storage$StorageFile> {

/**
 * Retrieves an iterator that iterates through the collection of StorageFile objects that represent selected files.
 * @return The iterator.
 */
first(): Windows$Foundation$Collections$IIterator<Windows$Storage$StorageFile>;

/**
 * Returns the StorageFile object at the specified index in the collection.
 * @param index The zero-based index of the object to retrieve.
 * @return The object at the specified index.
 */
getAt(index: number): Windows$Storage$StorageFile;

/**
 * Retrieves the StorageFile objects that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the objects in the collection to return.
 */
getMany(
startIndex: number): {
items: Windows$Storage$StorageFile,
returnValue: number
};

/**
 * Retrieves the index of a specified StorageFile object in the collection.
 * @param value The object to find in the collection.
 */
indexOf(value: Windows$Storage$StorageFile): {
index: number,
returnValue: boolean
};

/**
 * Gets the number of StorageFile objects in the collection.
 */
size: number;
indexOf(
value: Windows$Storage$StorageFile,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(searchElement: Windows$Storage$StorageFile, fromIndex?: number): number
}


/**
 * Represents a file picker that lets the user choose the file name, extension, and storage location for a file.
 */
declare class Windows$Storage$Pickers$FileSavePicker  {

/**
 * Creates a new instance of a FileSavePicker .
 */
constructor(): this;

/**
 * Gets or sets the label text of the commit button in the file picker UI.
 */
commitButtonText: string;

/**
 * Gets a set of values to be populated by the app before a PickSaveFileAndContinue operation that deactivates the app in order to provide context when the app is activated. (Windows Phone Store apps)
 */
continuationData: Windows$Foundation$Collections$ValueSet;

/**
 * Gets or sets the default file name extension that the fileSavePicker gives to files to be saved.
 */
defaultFileExtension: string;

/**
 * Gets or sets an ID that specifies the enterprise that owns the file.
 */
enterpriseId: string;

/**
 * Gets the collection of valid file types that the user can choose to assign to a file.
 */
fileTypeChoices: Windows$Foundation$Collections$IMap<string, Windows$Foundation$Collections$IVector<string>>;

/**
 * Shows the file picker so that the user can save a file, deactivating and the app and reactivating it when the operation is complete. (Windows Phone Store apps)
 */
pickSaveFileAndContinue(): void;

/**
 * Shows the file picker so that the user can save a file and set the file name, extension, and location of the file to be saved. (Windows Store apps)
 * @return When the call to this method completes successfully, it returns a storageFile object that was created to represent the saved file. The file name, extension, and location of this storageFile match those specified by the user, but the file has no content.
 */
pickSaveFileAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Gets or sets the settings identifier associated with the current FileSavePicker instance.
 */
settingsIdentifier: string;

/**
 * Gets or sets the file name that the file save picker suggests to the user.
 */
suggestedFileName: string;

/**
 * Gets or sets the storageFile that the file picker suggests to the user for saving a file.
 */
suggestedSaveFile: Windows$Storage$StorageFile;

/**
 * Gets or sets the location that the file save picker suggests to the user as the location to save a file.
 */
suggestedStartLocation: $Values<typeof Windows$Storage$Pickers$PickerLocationId>
}


/**
 * Represents a UI element that lets the user choose folders.
 */
declare class Windows$Storage$Pickers$FolderPicker  {

/**
 * Creates a new instance of a FolderPicker .
 */
constructor(): this;

/**
 * Gets or sets the label text of the folder picker's commit button.
 */
commitButtonText: string;

/**
 * Gets a set of values to be populated by the app before a PickFolderAndContinue operation that deactivates the app in order to provide context when the app is activated. (Windows Phone Store apps)
 */
continuationData: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the collection of file types that the folder picker displays.
 */
fileTypeFilter: Windows$Foundation$Collections$IVector<string>;

/**
 * Shows the file picker so that the user can pick a folder, deactivating and the app and reactivating it when the operation is complete. (Windows Phone Store apps)
 */
pickFolderAndContinue(): void;

/**
 * Shows the folderPicker object so that the user can pick a folder. (Windows Store apps)
 * @return When the call to this method completes successfully, it returns a storageFolder object that represents the folder that the user picked.
 */
pickSingleFolderAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Gets or sets the settings identifier associated with the with the current FolderPicker instance.
 */
settingsIdentifier: string;

/**
 * Gets or sets the initial location where the folder picker looks for folders to present to the user.
 */
suggestedStartLocation: $Values<typeof Windows$Storage$Pickers$PickerLocationId>;

/**
 * Gets or sets the view mode that the folder picker uses to display items.
 */
viewMode: $Values<typeof Windows$Storage$Pickers$PickerViewMode>
}


/**
 * Identifies the storage location that the file picker presents to the user.
 */

declare  var Windows$Storage$Pickers$PickerLocationId: {|
  +documentsLibrary: 0,// 0
+computerFolder: 1,// 1
+desktop: 2,// 2
+downloads: 3,// 3
+homeGroup: 4,// 4
+musicLibrary: 5,// 5
+picturesLibrary: 6,// 6
+videosLibrary: 7,// 7
+objects3D: 8,// 8
+unspecified: 9,// 9

|};



/**
 * Indicates the view mode that the file picker is using to present items.
 */

declare  var Windows$Storage$Pickers$PickerViewMode: {|
  +list: 0,// 0
+thumbnail: 1,// 1

|};



      declare var npm$namespace$Windows$Storage$Pickers$Provider: {
        
        
        AddFileResult: typeof Windows$Storage$Pickers$Provider$AddFileResult,
FileSelectionMode: typeof Windows$Storage$Pickers$Provider$FileSelectionMode,
SetFileNameResult: typeof Windows$Storage$Pickers$Provider$SetFileNameResult,
        FileOpenPickerUI: typeof Windows$Storage$Pickers$Provider$FileOpenPickerUI,
FileRemovedEventArgs: typeof Windows$Storage$Pickers$Provider$FileRemovedEventArgs,
FileSavePickerUI: typeof Windows$Storage$Pickers$Provider$FileSavePickerUI,
PickerClosingDeferral: typeof Windows$Storage$Pickers$Provider$PickerClosingDeferral,
PickerClosingEventArgs: typeof Windows$Storage$Pickers$Provider$PickerClosingEventArgs,
PickerClosingOperation: typeof Windows$Storage$Pickers$Provider$PickerClosingOperation,
TargetFileRequest: typeof Windows$Storage$Pickers$Provider$TargetFileRequest,
TargetFileRequestDeferral: typeof Windows$Storage$Pickers$Provider$TargetFileRequestDeferral,
TargetFileRequestedEventArgs: typeof Windows$Storage$Pickers$Provider$TargetFileRequestedEventArgs,
        
      }

/**
 * Indicates the result of a call to the fileOpenPickerUI.addFile method.
 */

declare  var Windows$Storage$Pickers$Provider$AddFileResult: {|
  +added: 0,// 0
+alreadyAdded: 1,// 1
+notAllowed: 2,// 2
+unavailable: 3,// 3

|};



/**
 * Used to interact with the file picker if your app provides files with the File Open Picker contract.
 */
declare class Windows$Storage$Pickers$Provider$FileOpenPickerUI  {

/**
 * Adds the specified file to the list of files that the user has chosen.
 * @param id A unique identifier of the file to add.
 * @param file The file to add to the list of files that the user has chosen.
 * @return The enumeration value that indicates the result of this addFile method.
 */
addFile(
id: string,
file: Windows$Storage$IStorageFile): $Values<typeof Windows$Storage$Pickers$Provider$AddFileResult>;

/**
 * Gets a list of file types (extensions) that the user can choose.
 */
allowedFileTypes: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Indicates whether the specified file can be added to the list of files the user has chosen.
 * @param file The file to test.
 * @return True if the file can be added to the file picker UI; otherwise false.
 */
canAddFile(file: Windows$Storage$IStorageFile): boolean;

/**
 * Determines whether the specified file is in the list of files that the user has chosen.
 * @param id The identifier of the file.
 * @return True if the file is in the basket; otherwise false.
 */
containsFile(id: string): boolean;

/**
 * Fires when the user closes the file picker.
 */
onclosing: Windows$Foundation$TypedEventHandler<Windows$Storage$Pickers$Provider$FileOpenPickerUI, Windows$Storage$Pickers$Provider$PickerClosingEventArgs>;
addEventListener(
type: "closing",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Pickers$Provider$FileOpenPickerUI, Windows$Storage$Pickers$Provider$PickerClosingEventArgs>): void;
removeEventListener(
type: "closing",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Pickers$Provider$FileOpenPickerUI, Windows$Storage$Pickers$Provider$PickerClosingEventArgs>): void;

/**
 * Fires when the user removes a file from the list of files that the user has chosen if that file was added by the app that is providing files.
 */
onfileremoved: Windows$Foundation$TypedEventHandler<Windows$Storage$Pickers$Provider$FileOpenPickerUI, Windows$Storage$Pickers$Provider$FileRemovedEventArgs>;
addEventListener(
type: "fileremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Pickers$Provider$FileOpenPickerUI, Windows$Storage$Pickers$Provider$FileRemovedEventArgs>): void;
removeEventListener(
type: "fileremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Pickers$Provider$FileOpenPickerUI, Windows$Storage$Pickers$Provider$FileRemovedEventArgs>): void;

/**
 * Removes the specified file from the list of files the user has chosen.
 * @param id The identifier of the file to remove.
 */
removeFile(id: string): void;

/**
 * Gets an enumeration value that indicates whether the file picker currently limits selection to single files, or if multiple files can be selected.
 */
selectionMode: $Values<typeof Windows$Storage$Pickers$Provider$FileSelectionMode>;

/**
 * Gets an identifier for the current context of the file picker.
 */
settingsIdentifier: string;

/**
 * Gets or sets a title to display in the file picker UI that identifies the location that the file picker is displaying to the user.
 */
title: string;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides information about a fileremoved event.
 */
declare class Windows$Storage$Pickers$Provider$FileRemovedEventArgs  {

/**
 * Gets the identifier of the file that the user removed from the list of chosen files in the file picker. This identifier was set by the providing app when it added the files to the list of chosen files.
 */
id: string
}


/**
 * Used to interact with the file picker when your app provides a save location with the File Save Picker contract.
 */
declare class Windows$Storage$Pickers$Provider$FileSavePickerUI  {

/**
 * Gets a list of file types (extensions) that can be saved to the app that is providing the save location.
 */
allowedFileTypes: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the full file name of the file to save, including the file type extension. The file name and extension are specified by the user.
 */
fileName: string;

/**
 * Fired when the user changes the file name in the file name text box or changes the extension in the file type drop-down menu.
 */
onfilenamechanged: Windows$Foundation$TypedEventHandler<Windows$Storage$Pickers$Provider$FileSavePickerUI, any>;
addEventListener(
type: "filenamechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Pickers$Provider$FileSavePickerUI, any>): void;
removeEventListener(
type: "filenamechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Pickers$Provider$FileSavePickerUI, any>): void;

/**
 * Fires when the user commits a file to be saved in the file picker.
 */
ontargetfilerequested: Windows$Foundation$TypedEventHandler<Windows$Storage$Pickers$Provider$FileSavePickerUI, Windows$Storage$Pickers$Provider$TargetFileRequestedEventArgs>;
addEventListener(
type: "targetfilerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Pickers$Provider$FileSavePickerUI, Windows$Storage$Pickers$Provider$TargetFileRequestedEventArgs>): void;
removeEventListener(
type: "targetfilerequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Pickers$Provider$FileSavePickerUI, Windows$Storage$Pickers$Provider$TargetFileRequestedEventArgs>): void;

/**
 * Gets an identifier for the current context of the file picker.
 */
settingsIdentifier: string;

/**
 * Gets or sets a title to display in the file picker UI that identifies the location that the file picker is displaying to the user.
 */
title: string;

/**
 * Tries to set the file name and extension in the file picker UI.
 * @param value The file name and extension that are used to update the file name text box and file type drop-down menu in the file picker UI.
 * @return The enumeration value that indicates whether the file name and extension were updated in the file picker UI.
 */
trySetFileName(
value: string): $Values<typeof Windows$Storage$Pickers$Provider$SetFileNameResult>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Indicates whether the file picker currently limits selection to single files, or if multiple files can be selected.
 */

declare  var Windows$Storage$Pickers$Provider$FileSelectionMode: {|
  +single: 0,// 0
+multiple: 1,// 1

|};



/**
 * Use by an app that provides files to indicate asynchronously that the app is finished responding to a closing event.
 */
declare class Windows$Storage$Pickers$Provider$PickerClosingDeferral  {

/**
 * Signals that the app providing files has finished responding to a closing event.
 */
complete(): void
}


/**
 * Provides information about a closing event.
 */
declare class Windows$Storage$Pickers$Provider$PickerClosingEventArgs  {

/**
 * Gets a pickerClosingOperation object that is used to respond to a closing event.
 */
closingOperation: Windows$Storage$Pickers$Provider$PickerClosingOperation;

/**
 * Gets a value that indicates whether the file picker is closing because the user cancelled it.
 */
isCanceled: boolean
}


/**
 * Lets an app that provides files get the deadline for responding to a closing event and get a deferral so the app can respond to the event asynchronously.
 */
declare class Windows$Storage$Pickers$Provider$PickerClosingOperation  {

/**
 * Gets a dateTime object that indicates when the system will shut down the app that is providing files through the file picker without further notice.
 */
deadline: Date;

/**
 * Gets a pickerClosingDeferral that the app providing files through the file picker can use to respond asynchronously to a closing event.
 * @return The pickerClosingDeferral that the app providing files through the file picker can use to respond asynchronously to a closing event.
 */
getDeferral(): Windows$Storage$Pickers$Provider$PickerClosingDeferral
}


/**
 * Indicates the result of a call to the fileSavePickerUI.trySetFileName method.
 */

declare  var Windows$Storage$Pickers$Provider$SetFileNameResult: {|
  +succeeded: 0,// 0
+notAllowed: 1,// 1
+unavailable: 2,// 2

|};



/**
 * Lets an app that provides a save location specify the storageFile that represents the file to save and get a deferral so the app can respond asynchronously to a targetFileRequested event.
 */
declare class Windows$Storage$Pickers$Provider$TargetFileRequest  {

/**
 * Gets a targetFileRequestDeferral that the app providing the save location can use to respond asynchronously to a targetfilerequested event.
 * @return The targetFileRequestDeferral that the providing app can use asynchronously to indicate that it is finished responding to a targetfilerequested event.
 */
getDeferral(): Windows$Storage$Pickers$Provider$TargetFileRequestDeferral;

/**
 * Gets or sets the IStorageFile object that is provided to represent the file to save by the app that is providing the save location.
 */
targetFile: Windows$Storage$IStorageFile
}


/**
 * Used by an app that provides a save location to indicate asynchronously that the app is finished responding to a targetfilerequested event.
 */
declare class Windows$Storage$Pickers$Provider$TargetFileRequestDeferral  {

/**
 * Signals that the app providing the save location finished responding to a targetfilerequested event.
 */
complete(): void
}


/**
 * Provides information about a targetfilerequested event.
 */
declare class Windows$Storage$Pickers$Provider$TargetFileRequestedEventArgs  {

/**
 * Gets a targetFileRequest object that is used to respond to a targetfilerequested event.
 */
request: Windows$Storage$Pickers$Provider$TargetFileRequest
}


      declare var npm$namespace$Windows$Storage$Provider: {
        
        
        CachedFileOptions: typeof Windows$Storage$Provider$CachedFileOptions,
CachedFileTarget: typeof Windows$Storage$Provider$CachedFileTarget,
FileUpdateStatus: typeof Windows$Storage$Provider$FileUpdateStatus,
ReadActivationMode: typeof Windows$Storage$Provider$ReadActivationMode,
UIStatus: typeof Windows$Storage$Provider$UIStatus,
WriteActivationMode: typeof Windows$Storage$Provider$WriteActivationMode,
        CachedFileUpdater: typeof Windows$Storage$Provider$CachedFileUpdater,
CachedFileUpdaterUI: typeof Windows$Storage$Provider$CachedFileUpdaterUI,
FileUpdateRequest: typeof Windows$Storage$Provider$FileUpdateRequest,
FileUpdateRequestDeferral: typeof Windows$Storage$Provider$FileUpdateRequestDeferral,
FileUpdateRequestedEventArgs: typeof Windows$Storage$Provider$FileUpdateRequestedEventArgs,
        
      }

/**
 * Describes when Windows will request an update to a file.
 */

declare  var Windows$Storage$Provider$CachedFileOptions: {|
  +none: 0,// 0
+requireUpdateOnAccess: 1,// 1
+useCachedFileWhenOffline: 2,// 2
+denyAccessWhenOffline: 3,// 3

|};



/**
 * Indicates whether updates should be applied to the locally cached copy or the remote version of the file.
 */

declare  var Windows$Storage$Provider$CachedFileTarget: {|
  +local: 0,// 0
+remote: 1,// 1

|};



/**
 * Manages files so that they can be updated in real-time by an app that participates in the Cached File Updater contract.
 */
declare class Windows$Storage$Provider$CachedFileUpdater  {

/**
 * Configures update policies for a local file.
 * @param file The local file.
 * @param contentId A unique identifier for the local file.
 * @param readMode A value that specifies whether Windows will request updates before the local file is read by other apps.
 * @param writeMode A value that specifies whether other apps can write to the local file and, if so, whether Windows will request updates after the local file is written.
 * @param options A value that specifies additional circumstances and behaviors for when Windows requests updates.
 */
static setUpdateInformation(
file: Windows$Storage$IStorageFile,
contentId: string,
readMode: $Values<typeof Windows$Storage$Provider$ReadActivationMode>,
writeMode: $Values<typeof Windows$Storage$Provider$WriteActivationMode>,
options: $Values<typeof Windows$Storage$Provider$CachedFileOptions>): void
}


/**
 * Used to interact with the file picker if your app provides file updates through the Cached File Updater contract.
 */
declare class Windows$Storage$Provider$CachedFileUpdaterUI  {

/**
 * Gets an object used to complete a file update request asynchronously.
 * @return The object that the app uses to indicate, asynchronously, that it has finished responding to a FileUpdateRequested event and that the Request is complete.
 */
getDeferral(): Windows$Storage$Provider$FileUpdateRequestDeferral;

/**
 * Fires when the Windows requests a file update. This event fires once for each requested update.
 */
onfileupdaterequested: Windows$Foundation$TypedEventHandler<Windows$Storage$Provider$CachedFileUpdaterUI, Windows$Storage$Provider$FileUpdateRequestedEventArgs>;
addEventListener(
type: "fileupdaterequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Provider$CachedFileUpdaterUI, Windows$Storage$Provider$FileUpdateRequestedEventArgs>): void;
removeEventListener(
type: "fileupdaterequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Provider$CachedFileUpdaterUI, Windows$Storage$Provider$FileUpdateRequestedEventArgs>): void;

/**
 * Fires when the calling app needs to display the file picker letterbox UI that is represented by the CachedFileUpdaterUI object.
 */
onuirequested: Windows$Foundation$TypedEventHandler<Windows$Storage$Provider$CachedFileUpdaterUI, any>;
addEventListener(
type: "uirequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Provider$CachedFileUpdaterUI, any>): void;
removeEventListener(
type: "uirequested",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Provider$CachedFileUpdaterUI, any>): void;

/**
 * Gets or sets the title to display in the top-left the file picker UI. The title identifies the location or context of the app's page (which is hosted in the file picker UI) for the user.
 */
title: string;

/**
 * Gets an enum value that indicates the status of the file picker UI.
 */
uiStatus: $Values<typeof Windows$Storage$Provider$UIStatus>;

/**
 * Gets the file update request currently being processed by the cached file updater.
 */
updateRequest: Windows$Storage$Provider$FileUpdateRequest;

/**
 * Gets a value that indicates which version of the file needs to be updated: the local version or the version in the app's repository.
 */
updateTarget: $Values<typeof Windows$Storage$Provider$CachedFileTarget>;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides information about a requested file update so that the app can complete the request.
 */
declare class Windows$Storage$Provider$FileUpdateRequest  {

/**
 * Gets the unique identifier used to associate the local version of a file with the corresponding remote version.
 */
contentId: string;

/**
 * Gets a StorageFile object that represents the locally cached copy of the file to update.
 */
file: Windows$Storage$StorageFile;

/**
 * Gets an object used to complete an update asynchronously.
 * @return The object that the app uses to indicate, asynchronously, that it has finished responding to a FileUpdateRequested event and that the Request is complete.
 */
getDeferral(): Windows$Storage$Provider$FileUpdateRequestDeferral;

/**
 * Gets or sets the status of the update. This property is set in response to a FileUpdateRequested event.
 */
status: $Values<typeof Windows$Storage$Provider$FileUpdateStatus>;

/**
 * Provide a new version of the local file to represent the remote file.
 * @param value The new version of the local file that will represent remote file.
 */
updateLocalFile(value: Windows$Storage$IStorageFile): void;

/**
 * Gets or sets a message to the user indicating that user input is needed to complete the FileUpdateRequest .
 */
userInputNeededMessage: string
}


/**
 * Use to complete an update asynchronously.
 */
declare class Windows$Storage$Provider$FileUpdateRequestDeferral  {

/**
 * Signals that the response to a FileUpdateRequested event is finished.
 */
complete(): void
}


/**
 * Provides information about a FileUpdateRequested event.
 */
declare class Windows$Storage$Provider$FileUpdateRequestedEventArgs  {

/**
 * Gets the details of the requested file update.
 */
request: Windows$Storage$Provider$FileUpdateRequest
}


/**
 * Describes the status of a file update request.
 */

declare  var Windows$Storage$Provider$FileUpdateStatus: {|
  +incomplete: 0,// 0
+complete: 1,// 1
+userInputNeeded: 2,// 2
+currentlyUnavailable: 3,// 3
+failed: 4,// 4
+completeAndRenamed: 5,// 5

|};



/**
 * Indicates when Windows will request a file update if another app reads the locally cached version of the file.
 */

declare  var Windows$Storage$Provider$ReadActivationMode: {|
  +notNeeded: 0,// 0
+beforeAccess: 1,// 1

|};



/**
 * Indicates the status of the file picker UI.
 */

declare  var Windows$Storage$Provider$UIStatus: {|
  +unavailable: 0,// 0
+hidden: 1,// 1
+visible: 2,// 2
+complete: 3,// 3

|};



/**
 * Indicates whether other apps can write to the locally cached version of the file and when Windows will request an update if another app writes to that local file.
 */

declare  var Windows$Storage$Provider$WriteActivationMode: {|
  +readOnly: 0,// 0
+notNeeded: 1,// 1
+afterWrite: 2,// 2

|};



      declare var npm$namespace$Windows$Storage$Search: {
        
        
        CommonFileQuery: typeof Windows$Storage$Search$CommonFileQuery,
CommonFolderQuery: typeof Windows$Storage$Search$CommonFolderQuery,
DateStackOption: typeof Windows$Storage$Search$DateStackOption,
FolderDepth: typeof Windows$Storage$Search$FolderDepth,
IndexedState: typeof Windows$Storage$Search$IndexedState,
IndexerOption: typeof Windows$Storage$Search$IndexerOption,
        ContentIndexer: typeof Windows$Storage$Search$ContentIndexer,
ContentIndexerQuery: typeof Windows$Storage$Search$ContentIndexerQuery,
IndexableContent: typeof Windows$Storage$Search$IndexableContent,
QueryOptions: typeof Windows$Storage$Search$QueryOptions,
SortEntryVector: typeof Windows$Storage$Search$SortEntryVector,
StorageFileQueryResult: typeof Windows$Storage$Search$StorageFileQueryResult,
StorageFolderQueryResult: typeof Windows$Storage$Search$StorageFolderQueryResult,
StorageItemQueryResult: typeof Windows$Storage$Search$StorageItemQueryResult,
StorageLibraryContentChangedTriggerDetails: typeof Windows$Storage$Search$StorageLibraryContentChangedTriggerDetails,
ValueAndLanguage: typeof Windows$Storage$Search$ValueAndLanguage,
        
      }

/**
 * Specifies how to sort the files in the query results and determines whether the query is shallow or deep. Query results for deep queries include all files in all of the subfolders of the current folder, sorted according to the specified option.
 */

declare  var Windows$Storage$Search$CommonFileQuery: {|
  +defaultQuery: 0,// 0
+orderByName: 1,// 1
+orderByTitle: 2,// 2
+orderByMusicProperties: 3,// 3
+orderBySearchRank: 4,// 4
+orderByDate: 5,// 5

|};



/**
 * Specifies how to group files into folders in the query results and determines whether the query is shallow or deep. Query results for deep queries include all files in all of the subfolders of the current folder, grouped into folders according to the specified option.
 */

declare  var Windows$Storage$Search$CommonFolderQuery: {|
  +defaultQuery: 0,// 0
+groupByYear: 1,// 1
+groupByMonth: 2,// 2
+groupByArtist: 3,// 3
+groupByAlbum: 4,// 4
+groupByAlbumArtist: 5,// 5
+groupByComposer: 6,// 6
+groupByGenre: 7,// 7
+groupByPublishedYear: 8,// 8
+groupByRating: 9,// 9
+groupByTag: 10,// 10
+groupByAuthor: 11,// 11
+groupByType: 12,// 12

|};



/**
 * Enables Windows Store apps to place content properties in the system index.
 */
declare class Windows$Storage$Search$ContentIndexer  {

/**
 * Gets the per-app index with the specified name or creates a new one, if necessary.
 * @param indexName The index name.
 * @return The index.
 */
static getIndexer(indexName: string): Windows$Storage$Search$ContentIndexer;

/**
 * Gets an existing per-app index or creates a new one, if necessary.
 * @return The index.
 */
static getIndexer(): Windows$Storage$Search$ContentIndexer;

/**
 * Adds app-defined items with properties and content to the system index.
 * @param indexableContent The content properties to index.
 */
addAsync(indexableContent: Windows$Storage$Search$IIndexableContent): any;

/**
 * Builds a query with the specified search filter, sort order, and identifies which properties to retrieve.
 * @param searchFilter The AQS filter.
 * @param propertiesToRetrieve The properties to retrieve, specified by their Windows canonical property names.
 * @param sortOrder The sort order for the filtered results.
 * @return The query.
 */
createQuery(
searchFilter: string,
propertiesToRetrieve: Windows$Foundation$Collections$IIterable<string>,
sortOrder: Windows$Foundation$Collections$IIterable<Windows$Storage$Search$SortEntry>): Windows$Storage$Search$ContentIndexerQuery;

/**
 * Builds a query with the specified search filter, sort order, filter language, and identifies which properties to retrieve.
 * @param searchFilter The AQS filter to apply.
 * @param propertiesToRetrieve The properties to retrieve, specified by their Windows canonical property names.
 * @param sortOrder The sort order for the filtered results.
 * @param searchFilterLanguage The language that's used to parse AQS, specified as a BCP-47 language tag.
 * @return The query.
 */
createQuery(
searchFilter: string,
propertiesToRetrieve: Windows$Foundation$Collections$IIterable<string>,
sortOrder: Windows$Foundation$Collections$IIterable<Windows$Storage$Search$SortEntry>,
searchFilterLanguage: string): Windows$Storage$Search$ContentIndexerQuery;

/**
 * Builds a query with the specified search filter and identifies which properties to retrieve.
 * @param searchFilter The AQS filter to apply.
 * @param propertiesToRetrieve The properties to retrieve, specified by their Windows canonical property names.
 * @return The query.
 */
createQuery(
searchFilter: string,
propertiesToRetrieve: Windows$Foundation$Collections$IIterable<string>): Windows$Storage$Search$ContentIndexerQuery;

/**
 * Removes all app-defined items from the ContentIndexer .
 */
deleteAllAsync(): any;

/**
 * Removes the specified app-defined item from the ContentIndexer .
 * @param contentId The identifier of the item to remove.
 */
deleteAsync(contentId: string): any;

/**
 * Removes the specified app-defined items from the ContentIndexer .
 * @param contentIds The identifier of the item to remove.
 */
deleteMultipleAsync(contentIds: Windows$Foundation$Collections$IIterable<string>): any;

/**
 * Gets content properties based on the given content identifier.
 * @param contentId The identifier for the content properties.
 * @param propertiesToRetrieve The retrieved properties, based on contentId.
 * @return When this method completes, it returns the retrieved properties as a map of key-value pairs.
 */
retrievePropertiesAsync(
contentId: string,
propertiesToRetrieve: Windows$Foundation$Collections$IIterable<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IMapView<any, any>>;

/**
 * Gets the version of the ContentIndexer .
 */
revision: number;

/**
 * Updates app content and properties in the ContentIndexer .
 * @param indexableContent The content properties to update.
 */
updateAsync(indexableContent: Windows$Storage$Search$IIndexableContent): any
}


/**
 * Represents a query for content properties in the ContentIndexer .
 */
declare class Windows$Storage$Search$ContentIndexerQuery  {

/**
 * Runs the query on the app's indexed content properties and returns the specified number of items from the specified start index in the results collection.
 * @param startIndex The index of the first item to get from the results collection.
 * @param maxItems The maximum number of items to get.
 * @return When this method completes, it returns the query results, represented as a collection of IndexableContent instances.
 */
getAsync(
startIndex: number,
maxItems: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Runs the query on the app's indexed content properties.
 * @return When this method completes, it returns the query results, represented as a collection of IIndexableContent instances.
 */
getAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the number of items in the search results.
 * @return When this method completes, it returns the number of items in the search results.
 */
getCountAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * Retrieves a collection of property sets for an app, where the property sets are key-value pairs.
 * @return When this method completes, it returns the query results as a collection of PropertyValue instances.
 */
getPropertiesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Runs the query on the app's indexed content properties and returns the specified number of properties from the specified start index in the results collection.
 * @param startIndex The index of the first item to get from the results collection.
 * @param maxItems The maximum number of items to get.
 * @return When this method completes, it returns the query results as a collection of PropertyValue instances.
 */
getPropertiesAsync(
startIndex: number,
maxItems: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the StorageFolder representation of the app-provided items in the ContentIndexer query.
 */
queryFolder: Windows$Storage$StorageFolder
}


/**
 * Indicates the unit of time used to group files into folders if a CommonFolderQuery based on date is used to create a QueryOptions object.
 */

declare  var Windows$Storage$Search$DateStackOption: {|
  +none: 0,// 0
+year: 1,// 1
+month: 2,// 2

|};



/**
 * Indicates whether all files and subfolders of the folder being queried will be enumerated or if only the top-level files and subfolders will be enumerated.
 */

declare  var Windows$Storage$Search$FolderDepth: {|
  +shallow: 0,// 0
+deep: 1,// 1

|};



/**
 * Represents app content and properties that can be added to the ContentIndexer .
 */
declare class Windows$Storage$Search$IndexableContent  {

/**
 * Initializes a new instance of the IndexableContent class.
 */
constructor(): this;

/**
 * Gets or sets the identifier for the content properties in the IndexableContent object. Changes to the actual representation of the item in the index can be made using the ContentIndexer class.
 */
id: string;

/**
 * Gets the content properties.
 */
properties: Windows$Foundation$Collections$IMap<string, any>;

/**
 * Gets or sets a Stream that provides full-text content. Changes to the actual representation of the item in the index can be made using the ContentIndexer class.
 */
stream: Windows$Storage$Streams$IRandomAccessStream;

/**
 * Specifies the type of content in the Stream .
 */
streamContentType: string
}


/**
 * Indicates whether a StorageFolder is included in the system index.
 */

declare  var Windows$Storage$Search$IndexedState: {|
  +unknown: 0,// 0
+notIndexed: 1,// 1
+partiallyIndexed: 2,// 2
+fullyIndexed: 3,// 3

|};



/**
 * Specifies whether the query should use the system index of the file system when enumerating content in the folder being queried. The indexer can retrieve results faster but is not available in all file locations.
 */

declare  var Windows$Storage$Search$IndexerOption: {|
  +useIndexerWhenAvailable: 0,// 0
+onlyUseIndexer: 1,// 1
+doNotUseIndexer: 2,// 2

|};



/**
 * Specifies the parameters of a search query for enumerating the contents of storage folders.
 */
declare class Windows$Storage$Search$QueryOptions  {

/**
 * Creates an instance of the QueryOptions class for enumerating files and initializes it with values provided by the specified CommonFileQuery and an optional file type filter that determines which files to include in query results.
 * @param query An enumeration value that specifies the search parameters to use to query files.
 * @param fileTypeFilter An array of file types to be included in the query results. To include all file types, supply null or an array containing a single entry of "*".
 */
constructor(query: $Values<typeof Windows$Storage$Search$CommonFileQuery>, fileTypeFilter: Windows$Foundation$Collections$IIterable<string>): this;

/**
 * Creates an instance of the QueryOptions class for enumerating subfolders and initializes it with values based on the specified CommonFolderQuery .
 * @param query An enumeration value that specifies how to group the contents of the folder where the query is created into subfolders to enumerate. The subfolders that are retrieved using a CommonFolderQuery can be actual file system folders or virtual folders that represent groups of files (which are determined by the CommonFolderQuery value). For example, the CommonFolderQuery.GroupByArtist uses the Artist of the files in the folder (and its subfolders) to group files, creating one virtual folder (or file group) for each artist.
 */
constructor(query: $Values<typeof Windows$Storage$Search$CommonFolderQuery>): this;

/**
 * Creates an instance of the QueryOptions class for enumerating storage items, and initializes it with the following default settings: QueryOptions.FolderDepth gets FolderDepth.Shallow and QueryOptions.IndexerOption gets IndexerOption.DoNotUseIndexer .
 */
constructor(): this;

/**
 * Gets or sets an application-defined Advanced Query Syntax (AQS) string for filtering files by keywords or properties. This property is combined with the UserSearchFilter to create the query's search filter.
 */
applicationSearchFilter: string;

/**
 * Gets the unit of time used to group files into folders if the QueryOptions object was created with a CommonFolderQuery based on date. For example, if CommonFolderQuery.GroupByYear is used to create a QueryOptions object, the value of this property is DateStackOption.Year .
 */
dateStackOption: $Values<typeof Windows$Storage$Search$DateStackOption>;

/**
 * Gets a list of file name extensions used to filter the search results. If the list is empty, the results include all file types.
 */
fileTypeFilter: Windows$Foundation$Collections$IVector<string>;

/**
 * Indicates whether the search query should produce a shallow view of the folder contents or a deep recursive view of all files and subfolder.
 */
folderDepth: $Values<typeof Windows$Storage$Search$FolderDepth>;

/**
 * Gets the name of the property used to group query results if the QueryOptions object was created using a CommonFolderQuery . For example, if CommonFolderQuery.GroupByYear is used to create a QueryOptions object, the value of this property is System.ItemDate .
 */
groupPropertyName: string;

/**
 * Gets or sets a value that specifies whether the system index or the file system is used to retrieve query results. The indexer can retrieve results faster but is not available in all file locations.
 */
indexerOption: $Values<typeof Windows$Storage$Search$IndexerOption>;

/**
 * Gets or sets the Internet Engineering Task Force (IETF) language tag (BCP47 standard) that identifies the language associated with the query. This determines the language-specific algorithm used by the system to break the query into individual search tokens.
 */
language: string;

/**
 * Initializes the current instance of the QueryOptions class with search parameters specified by a string that was created by the SaveToString method.
 * @param value A string retrieved by a previous call to SaveToString .
 */
loadFromString(value: string): void;

/**
 * Converts the values of a QueryOptions object to a string that can be used to initialize the values of a QueryOptions object by calling LoadFromString .
 * @return A string representing the serialized settings of a QueryOptions instance.
 */
saveToString(): string;

/**
 * Specifies properties that the system should load in advance for all items in the query result set while the query is being executed (instead of retrieving them on a case-by-case basis). If many properties are specified, the query might take longer to execute, but subsequent property retrieval on query results will be faster.
 * @param options A value that specifies the set of properties to retrieve in advance.
 * @param propertiesToRetrieve A custom list of properties to retrieve in advance as an array of property names. Use the system property names to specify properties, for example "System.Copyright" and "System.Image.ColorSpace".
 */
setPropertyPrefetch(
options: $Values<typeof Windows$Storage$FileProperties$PropertyPrefetchOptions>,
propertiesToRetrieve: Windows$Foundation$Collections$IIterable<string>): void;

/**
 * Specifies the type and size of thumbnails that the system should start loading immediately when items are accessed (instead of retrieving them on a case-by-case basis). This uses more resources but makes thumbnail retrieval on query results faster.
 * @param mode The enumeration value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to return a thumbnail image that can be scaled to the requested size without reducing the quality of the image.
 * @param options The enum value that describes the desired behavior to use to retrieve the thumbnail image. The specified behavior might affect the size and/or quality of the image and how quickly the thumbnail image is retrieved.
 */
setThumbnailPrefetch(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>,
requestedSize: number,
options: $Values<typeof Windows$Storage$FileProperties$ThumbnailOptions>): void;

/**
 * Gets the list of SortEntry structures that specify how to sort content (like files and subfolders) in query results. Use this list to customize how query results are sorted.
 */
sortOrder: Windows$Foundation$Collections$IVector<Windows$Storage$Search$SortEntry>;

/**
 * Gets the filter for storage provider identifiers.
 */
storageProviderIdFilter: Windows$Foundation$Collections$IVector<string>;

/**
 * Gets or sets a user-defined Advanced Query Syntax (AQS) string for filtering files by keywords or properties. This property is combined with the ApplicationSearchFilter to create the query's search filter.
 */
userSearchFilter: string
}


/**
 * Provides access to the sorting criteria of the query results as a collection of SortEntry objects.
 */
declare class Windows$Storage$Search$SortEntryVector mixins Array<Windows$Storage$Search$SortEntry> {

/**
 * Appends a sort entry to the end of the collection.
 * @param value The sort entry to append to the collection.
 */
append(value: Windows$Storage$Search$SortEntry): void;

/**
 * Removes all sort entries from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator that iterates through the sort entries in the collection.
 * @return The iterator.
 */
first(): Windows$Foundation$Collections$IIterator<Windows$Storage$Search$SortEntry>;

/**
 * Retrieves the sort entry at the specified index in the collection.
 * @param index The zero-based index of the sort entry to retrieve.
 * @return The sort entry at the specified index.
 */
getAt(index: number): Windows$Storage$Search$SortEntry;

/**
 * Retrieves the sort entries that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the sort entries in the collection to retrieve.
 */
getMany(
startIndex: number): {
items: Windows$Storage$Search$SortEntry,
returnValue: number
};

/**
 * Retrieves an immutable view of the collection of sort entries.
 * @return The view of the collection.
 */
getView(): Windows$Foundation$Collections$IVectorView<Windows$Storage$Search$SortEntry>;

/**
 * Retrieves the index of a specified sort entry in the collection.
 * @param value The sort entry to find in the collection.
 */
indexOf(
value: Windows$Storage$Search$SortEntry): {
index: number,
returnValue: boolean
};

/**
 * Inserts a sort entry into the collection at a specified index.
 * @param index The zero-based index of the location to insert the sort entry.
 * @param value The sort entry to insert.
 */
insertAt(index: number, value: Windows$Storage$Search$SortEntry): void;

/**
 * Removes the sort entry at the specified index in the collection.
 * @param index The zero-based index of the sort entry to remove.
 */
removeAt(index: number): void;

/**
 * Removes the last sort entry from the collection.
 */
removeAtEnd(): void;

/**
 * Replaces all sort entries in the collection with the specified sort entries.
 * @param items The collection of sort entries to put in the vector.
 */
replaceAll(items: Windows$Storage$Search$SortEntry): void;

/**
 * Sets the sort entry at the specified index of the collection.
 * @param index The zero-based index of the location at which to set the sort entry.
 * @param value The sort entry.
 */
setAt(index: number, value: Windows$Storage$Search$SortEntry): void;

/**
 * Gets the number of sort entries in the collection.
 */
size: number;
indexOf(
value: Windows$Storage$Search$SortEntry,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(searchElement: Windows$Storage$Search$SortEntry, fromIndex?: number): number
}


/**
 * Provides access to the results of a query of the files in the location that is represented by a storageFolder object. You can use storageFileQueryResult to enumerate the files in that storageFolder location.
 */
declare class Windows$Storage$Search$StorageFileQueryResult  {

/**
 * Modifies query results based on new QueryOptions .
 * @param newQueryOptions The new query options.
 */
applyNewQueryOptions(newQueryOptions: Windows$Storage$Search$QueryOptions): void;

/**
 * Retrieves the index of the file from the query results that most closely matches the specified property value (or file, if used with FileActivatedEventArgs.NeighboringFilesQuery ). The property that is matched is determined by the first SortEntry of the QueryOptions.SortOrder list.
 * @param value The property value to match when searching the query results. The property to that is used to match this value is the property in the first SortEntry of the QueryOptions.SortOrder list.
 * @return When this method completes successfully, it returns the index of the matched file in the query results or the index of the file in the FileActivatedEventArgs.NeighboringFilesQuery . In the latter case, the file is expected to be sourced from FileActivatedEventArgs.Files .
 */
findStartIndexAsync(value: any): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * Gets the folder that was queried to create the StorageFileQueryResult object. This folder represents the scope of the query.
 */
folder: Windows$Storage$StorageFolder;

/**
 * Retrieves the query options used to determine query results.
 * @return The query options.
 */
getCurrentQueryOptions(): Windows$Storage$Search$QueryOptions;

/**
 * Retrieves a list of all the files in the query result set.
 * @return When this method completes successfully, it returns a list (type IVectorView ) of files that are represented by storageFile objects.
 */
getFilesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a list of files in a specified range.
 * @param startIndex The zero-based index of the first file to retrieve. This parameter is 0 by default.
 * @param maxNumberOfItems The maximum number of files to retrieve. Use -1 to retrieve all files. If the range contains fewer files than the max number, all files in the range are returned.
 * @return When this method completes successfully, it returns a list (type IVectorView ) of files that are represented by storageFile objects.
 */
getFilesAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves the number of files in the set of query results.
 * @return When this method completes successfully, it returns the number of files in the location that match the query.
 */
getItemCountAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * Gets matching file properties with corresponding text ranges.
 * @param file The file to query for properties.
 * @return The matched properties and corresponding text ranges.
 */
getMatchingPropertiesWithRanges(
file: Windows$Storage$StorageFile): Windows$Foundation$Collections$IMap<string, Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Fires when a file is added to, deleted from, or modified in the folder being queried. This event only fires after GetFilesAsync has been called at least once.
 */
oncontentschanged: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>;
addEventListener(
type: "contentschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>): void;
removeEventListener(
type: "contentschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>): void;

/**
 * Fires when the query options change.
 */
onoptionschanged: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>;
addEventListener(
type: "optionschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>): void;
removeEventListener(
type: "optionschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides access to the results of a query that lists the folder (or file groups) in the folder being queried (which is represented by a storageFolder ). You can use a storageFolderQueryResult to enumerate folders or file groups in that folder.
 */
declare class Windows$Storage$Search$StorageFolderQueryResult  {

/**
 * Modifies query results based on new QueryOptions .
 * @param newQueryOptions The new query options.
 */
applyNewQueryOptions(newQueryOptions: Windows$Storage$Search$QueryOptions): void;

/**
 * Retrieves the index of the folder from the query results that most closely matches the specified property value. The property that is matched is determined by the first SortEntry of the QueryOptions.SortOrder list.
 * @param value The property value to match when searching the query results. The property to that is used to match this value is the property in the first SortEntry of the QueryOptions.SortOrder list.
 * @return When this method completes successfully it returns the index of the matched folder in the query results.
 */
findStartIndexAsync(value: any): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * Gets the folder originally used to create the StorageFolderQueryResult object. This folder represents the scope of the query.
 */
folder: Windows$Storage$StorageFolder;

/**
 * Retrieves the query options used to determine query results.
 * @return The query options.
 */
getCurrentQueryOptions(): Windows$Storage$Search$QueryOptions;

/**
 * Retrieves folders (or file groups) in a specified range.
 * @param startIndex The zero-based index of the first folder to retrieve. This parameter defaults to 0.
 * @param maxNumberOfItems The maximum number of folders or file groups to retrieve. Use -1 to retrieve all folders. If the range contains fewer folders than the max number, all folders in the range are returned.
 * @return When this method completes successfully, it returns a list (type IVectorView ) of folders or file groups that are represented by storageFolder objects.
 */
getFoldersAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a list of all the folders (or file groups) in the result set.
 * @return When this method completes successfully, it returns a list (type IVectorView ) of folders or file groups that are represented by storageFolder objects. Each of these folder or file group can also be enumerated to retrieve its contents.
 */
getFoldersAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves the number of folders (or file groups) in the set of query results.
 * @return When this method completes successfully, it returns the number of folders or file groups in the location that match the query.
 */
getItemCountAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * Fires when a file is added to, deleted from, or modified in the folder being queried. This event only fires after GetFilesAsync has been called at least once.
 */
oncontentschanged: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>;
addEventListener(
type: "contentschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>): void;
removeEventListener(
type: "contentschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>): void;

/**
 * Fires when the query options change.
 */
onoptionschanged: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>;
addEventListener(
type: "optionschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>): void;
removeEventListener(
type: "optionschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides access to the results of a query that lists all items including files and folders (or file groups) in the folder being queried (which is represented by a storageFolder ). You can use storageItemQueryResult to enumerate the files and folders in that storageFolder .
 */
declare class Windows$Storage$Search$StorageItemQueryResult  {

/**
 * Modifies query results based on new QueryOptions .
 * @param newQueryOptions The new query options.
 */
applyNewQueryOptions(newQueryOptions: Windows$Storage$Search$QueryOptions): void;

/**
 * Retrieves the index of the item from the query results that most closely matches the specified property value. The property that is matched is determined by the first SortEntry of the QueryOptions.SortOrder list.
 * @param value The property value to match when searching the query results. The property to that is used to match this value is the property in the first SortEntry of the QueryOptions.SortOrder list.
 * @return When this method completes successfully it returns the index of the matched item in the query results.
 */
findStartIndexAsync(value: any): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * Gets the folder originally used to create the StorageItemQueryResult object. This folder represents the scope of the query.
 */
folder: Windows$Storage$StorageFolder;

/**
 * Retrieves the query options used to determine query results.
 * @return The query options.
 */
getCurrentQueryOptions(): Windows$Storage$Search$QueryOptions;

/**
 * Retrieves the number of items in the set of query results.
 * @return When this method completes successfully, it returns the number of items in the location that match the query.
 */
getItemCountAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<number>;

/**
 * Retrieves a list of all the items (files and folders) in the query results set.
 * @return When this method completes successfully, it returns a list (type IVectorView ) of items. Each item is the IStorageItem type and represents a file, folder, or file group.
 */
getItemsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a list of items (files and folders) in a specified range.
 * @param startIndex The zero-based index of the first item to retrieve. This parameter defaults to 0.
 * @param maxNumberOfItems The maximum number of items to retrieve. Use -1 to retrieve all items. If the range contains fewer items than the max number, all items in the range are returned.
 * @return When this method completes successfully, it returns a list (type IVectorView ) of items. Each item is the IStorageItem type and represents a file, folder, or file group.
 */
getItemsAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Fires when an item is added to, deleted from, or modified in the folder being queried. This event only fires after GetItemsAsync has been called at least once.
 */
oncontentschanged: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>;
addEventListener(
type: "contentschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>): void;
removeEventListener(
type: "contentschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>): void;

/**
 * Fires when the query options change.
 */
onoptionschanged: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>;
addEventListener(
type: "optionschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>): void;
removeEventListener(
type: "optionschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$Search$IStorageQueryResultBase, any>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Details about a change to storage library content.
 */
declare class Windows$Storage$Search$StorageLibraryContentChangedTriggerDetails  {

/**
 * Query for the creation/modified changes since a previous such query.
 * @param lastQueryTime The time the previous query was made.
 * @return The query result.
 */
createModifiedSinceQuery(lastQueryTime: Date): Windows$Storage$Search$StorageItemQueryResult;

/**
 * Gets the StorageFolder that has been changed.
 */
folder: Windows$Storage$StorageFolder
}


/**
 * Specifies the language of a property, as a BCP-47 language code.
 */
declare class Windows$Storage$Search$ValueAndLanguage  {

/**
 * Initializes a new instance of the ValueAndLanguage class.
 */
constructor(): this;

/**
 * Gets or sets the language of the property value, specified as a BCP-47 language code.
 */
language: string;

/**
 * Gets or sets the property value for the current ValueAndLanguage .
 */
value: any
}


/**
 * Provides methods to access to and manage query results.
 */
declare interface Windows$Storage$Search$IStorageQueryResultBase {

/**
 * Applies new query options to the results retrieved by the StorageFileQueryResult , StorageFolderQueryResult , or StorageItemQueryResult object.
 * @param newQueryOptions The new query options.
 */
applyNewQueryOptions(newQueryOptions: Windows$Storage$Search$QueryOptions): void,

/**
 * Retrieves the index of the file from the query results that most closely matches the specified property value. The property that is matched is determined by the first SortEntry of the QueryOptions.SortOrder list.
 * @param value The property value to match when searching the query results.
 * @return When this method completes successfully it returns the index of the matched item in the query results.
 */
findStartIndexAsync(value: any): Windows$Foundation$IPromiseWithIAsyncOperation<number>,

/**
 * Retrieves the query options used to create a StorageFileQueryResult , StorageFolderQueryResult , or StorageItemQueryResult object.
 * @return The query options.
 */
getCurrentQueryOptions(): Windows$Storage$Search$QueryOptions,

/**
 * Retrieves the number of items that match the query that created a StorageFileQueryResult , StorageFolderQueryResult , or StorageItemQueryResult object.
 * @return When this method completes successfully, it returns the number of items that match the query.
 */
getItemCountAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<number>,

/**
 * Gets the folder originally used to create a StorageFileQueryResult , StorageFolderQueryResult , or StorageItemQueryResult object. This folder represents the scope of the query.
 */
folder: Windows$Storage$StorageFolder
} 


/**
 * Represents app content and properties that can be added to the ContentIndexer .
 */
declare interface Windows$Storage$Search$IIndexableContent {

/**
 * Gets or sets the identifier for the content properties in the IIndexableContent object. Changes to the actual representation of the item in the index can be made using the ContentIndexer class.
 */
id: string,

/**
 * Gets the content properties.
 */
properties: Windows$Foundation$Collections$IMap<string, any>,

/**
 * Gets or sets a stream that provides full-text content. Changes to the actual representation of the item in the index can be made using the ContentIndexer class.
 */
stream: Windows$Storage$Streams$IRandomAccessStream,

/**
 * Specifies the type of content in the Stream .
 */
streamContentType: string
} 


/**
 * An entry in the SortOrder list the specifies a property and ordering that is used to sort query results.
 */
declare interface Windows$Storage$Search$SortEntry {

/**
 * True to sort content in the query results in ascending order based on the property name, or false to sort content in descending order.
 */
ascendingOrder: boolean,

/**
 * The name of the property to use for sorting, like System.Author. The property must be registered on the system.
 */
propertyName: string
} 


/**
 * Manages a delayed set version operation.
 */
declare class Windows$Storage$SetVersionDeferral  {

/**
 * Notifies the system that the app has set the version of the application data in its app data store.
 */
complete(): void
}


/**
 * Provides data when an app sets the version of the application data in its app data store.
 */
declare class Windows$Storage$SetVersionRequest  {

/**
 * Gets the current version.
 */
currentVersion: number;

/**
 * Gets the requested version.
 */
desiredVersion: number;

/**
 * Requests that the set version request be delayed.
 * @return The set version deferral.
 */
getDeferral(): Windows$Storage$SetVersionDeferral
}


/**
 * Specifies whether a deleted item is moved to the Recycle Bin or permanently deleted.
 */

declare  var Windows$Storage$StorageDeleteOption: {|
  +default: 0,// 0
+permanentDelete: 1,// 1

|};



/**
 * Represents a file. Provides information about the file and its content, and ways to manipulate them.
 */
declare class Windows$Storage$StorageFile  {

/**
 * Creates a StorageFile to represent the specified stream of data. This method lets the app produce the data on-demand by specifying a function to be invoked when the StorageFile that represents the stream is first accessed.
 * @param displayNameWithExtension The user-friendly name of the StorageFile to create, including a file type extension.
 * @param dataRequested The function that should be invoked when the StorageFile that is returned is first accessed. This function should produce the data stream represented by the returned StorageFile and lets the app produce data on-demand instead of writing the contents of the file at creation time.
 * @param thumbnail The thumbnail image for the StorageFile to create.
 * @return When this method completes, it returns a StorageFile object that represents the new stream of data.
 */
static createStreamedFileAsync(
displayNameWithExtension: string,
dataRequested: Windows$Storage$StreamedFileDataRequestedHandler,
thumbnail: Windows$Storage$Streams$IRandomAccessStreamReference): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Creates a StorageFile to represent a stream of data from the specified URI resource. This method lets the app download the data on-demand when the StorageFile that represents the stream is first accessed.
 * @param displayNameWithExtension The user-friendly name of the StorageFile to create, including a file type extension.
 * @param uri The URI of the resource used to create the StorageFile .
 * @param thumbnail The thumbnail image for the StorageFile to create.
 * @return When this method completes, it returns a StorageFile object that represents the URI resource.
 */
static createStreamedFileFromUriAsync(
displayNameWithExtension: string,
uri: Windows$Foundation$Uri,
thumbnail: Windows$Storage$Streams$IRandomAccessStreamReference): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Gets a StorageFile object to represent the specified URI app resource. For examples of sample URIs see How to load file resources.
 * @param uri The URI of the app resource to get a StorageFile to represent.
 * @return When this method completes, it returns a StorageFile object that represents the URI resource.
 */
static getFileFromApplicationUriAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Gets a StorageFile object to represent the file at the specified path.
 * @param path The path of the file to get a StorageFile to represent.
 * @return When this method completes, it returns the file as a StorageFile .
 */
static getFileFromPathAsync(
path: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Replaces the contents of the file referred to by the specified IStorageFile object with a new data stream. This method lets the app produce the data on-demand by specifying a function to be invoked when the StorageFile that represents the stream is first accessed.
 * @param fileToReplace The file (type IStorageFile ) that the new data stream should be written to.
 * @param dataRequested The function that should be invoked when the StorageFile that is returned is first accessed. This function should produce the data stream represented by the returned StorageFile and lets the app produce data on-demand instead of writing the contents of the file at creation time.
 * @param thumbnail The thumbnail image for the StorageFile to create.
 * @return When this method completes, it returns a StorageFile object that represents the new data stream. Subsequently, this StorageFile object should be used to access file content instead of the file (type IStorageFile ) that was specified to be replace.
 */
static replaceWithStreamedFileAsync(
fileToReplace: Windows$Storage$IStorageFile,
dataRequested: Windows$Storage$StreamedFileDataRequestedHandler,
thumbnail: Windows$Storage$Streams$IRandomAccessStreamReference): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Replaces the contents of the file referred to by the specified IStorageFile object with a new data stream of the specified URI. This method lets the app download the data on-demand when the StorageFile that represents the stream is first accessed.
 * @param fileToReplace The file that the created StorageFile will provide a stream of.
 * @param uri The URI of the resource used to create the StorageFile .
 * @param thumbnail The thumbnail image for the StorageFile to create.
 * @return When this method completes, it returns a StorageFile object that represents the streamed file. Subsequently, this StorageFile object should be used to access file content instead of the file (type IStorageFile ) that was specified to be replace.
 */
static replaceWithStreamedFileFromUriAsync(
fileToReplace: Windows$Storage$IStorageFile,
uri: Windows$Foundation$Uri,
thumbnail: Windows$Storage$Streams$IRandomAccessStreamReference): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Gets the attributes of a file.
 */
attributes: $Values<typeof Windows$Storage$FileAttributes>;

/**
 * Gets the MIME type of the contents of the file.
 */
contentType: string;

/**
 * Replaces the specified file with a copy of the current file.
 * @param fileToReplace The file to replace.
 * @return No object or value is returned when this method completes.
 */
copyAndReplaceAsync(
fileToReplace: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Creates a copy of the file in the specified folder and renames the copy. This method also specifies what to do if a file with the same name already exists in the destination folder.
 * @param destinationFolder The destination folder where the copy of the file is created.
 * @param desiredNewName The new name for the copy of the file created in the destinationFolder.
 * @param option One of the enumeration values that determines how to handle the collision if a file with the specified desiredNewName already exists in the destination folder.
 * @return When this method completes, it returns a StorageFile that represents the copy of the file created in the destinationFolder.
 */
copyAsync(
destinationFolder: Windows$Storage$IStorageFolder,
desiredNewName: string,
option: $Values<typeof Windows$Storage$NameCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Creates a copy of the file in the specified folder and renames the copy.
 * @param destinationFolder The destination folder where the copy of the file is created.
 * @param desiredNewName The new name for the copy of the file created in the destinationFolder.
 * @return When this method completes, it returns a StorageFile that represents the copy of the file created in the destinationFolder.
 */
copyAsync(
destinationFolder: Windows$Storage$IStorageFolder,
desiredNewName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Creates a copy of the file in the specified folder.
 * @param destinationFolder The destination folder where the copy of the file is created.
 * @return When this method completes, it returns a StorageFile that represents the copy of the file created in the destinationFolder.
 */
copyAsync(
destinationFolder: Windows$Storage$IStorageFolder): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Gets the date and time when the current file was created.
 */
dateCreated: Date;

/**
 * Deletes the current file, optionally deleting the item permanently.
 * @param option A value that indicates whether to delete the item permanently.
 * @return No object or value is returned by this method when it completes.
 */
deleteAsync(
option: $Values<typeof Windows$Storage$StorageDeleteOption>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Deletes the current file.
 * @return No object or value is returned by this method when it completes.
 */
deleteAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets a user-friendly name for the file.
 */
displayName: string;

/**
 * Gets a user-friendly description of the type of the file.
 */
displayType: string;

/**
 * Gets the type (file name extension) of the file.
 */
fileType: string;

/**
 * Gets an identifier for the file. This ID is unique for the query result or StorageFolder that contains the file and can be used to distinguish between items that have the same name.
 */
folderRelativeId: string;

/**
 * Gets the basic properties of the current file.
 * @return When this method completes successfully, it returns the basic properties of the current file as a BasicProperties object.
 */
getBasicPropertiesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$BasicProperties>;

/**
 * Gets the parent folder of the current file.
 * @return When this method completes, it returns the parent folder as a StorageFolder .
 */
getParentAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail, the requested size, and the specified options
 * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
 * @param options The enum value that describes the desired behavior to use to retrieve the thumbnail image. The specified behavior might affect the size and/or quality of the image and how quickly the thumbnail image is retrieved.
 * @return When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the item.
 */
getScaledImageAsThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>,
requestedSize: number,
options: $Values<typeof Windows$Storage$FileProperties$ThumbnailOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail and the requested size.
 * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
 * @return When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the item.
 */
getScaledImageAsThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>,
requestedSize: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail.
 * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @return When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the item.
 */
getScaledImageAsThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Retrieves an adjusted thumbnail image for the file, determined by the purpose of the thumbnail.
 * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @return When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the file.
 */
getThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Retrieves an adjusted thumbnail image for the file, determined by the purpose of the thumbnail and the requested size.
 * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
 * @return When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the file.
 */
getThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>,
requestedSize: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Retrieves an adjusted thumbnail image for the file, determined by the purpose of the thumbnail, the requested size, and the specified options.
 * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
 * @param options The enum value that describes the desired behavior to use to retrieve the thumbnail image. The specified behavior might affect the size and/or quality of the image and how quickly the thumbnail image is retrieved.
 * @return When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the file.
 */
getThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>,
requestedSize: number,
options: $Values<typeof Windows$Storage$FileProperties$ThumbnailOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Indicates if the file is local, is cached locally, or can be downloaded.
 */
isAvailable: boolean;

/**
 * Indicates whether the current file is equal to the specified file.
 * @param item The IStorageItem object that represents a file to compare against.
 * @return Returns true if the current file is equal to the specified file; otherwise false.
 */
isEqual(item: Windows$Storage$IStorageItem): boolean;

/**
 * Determines whether the current StorageFile matches the specified StorageItemTypes value.
 * @param type The value to match against.
 * @return True if the StorageFile matches the specified value; otherwise false.
 */
isOfType(type: $Values<typeof Windows$Storage$StorageItemTypes>): boolean;

/**
 * Moves the current file to the location of the specified file and replaces the specified file in that location.
 * @param fileToReplace The file to replace.
 * @return No object or value is returned by this method.
 */
moveAndReplaceAsync(
fileToReplace: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Moves the current file to the specified folder.
 * @param destinationFolder The destination folder where the file is moved.
 * @return No object or value is returned by this method.
 */
moveAsync(
destinationFolder: Windows$Storage$IStorageFolder): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Moves the current file to the specified folder and renames the file according to the desired name.
 * @param destinationFolder The destination folder where the file is moved.
 * @param desiredNewName The desired name of the file after it is moved.
 * @return No object or value is returned by this method.
 */
moveAsync(
destinationFolder: Windows$Storage$IStorageFolder,
desiredNewName: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Moves the current file to the specified folder and renames the file according to the desired name. This method also specifies what to do if a file with the same name already exists in the specified folder.
 * @param destinationFolder The destination folder where the file is moved.
 * @param desiredNewName The desired name of the file after it is moved.
 * @param option An enum value that determines how Windows responds if the desiredNewName is the same as the name of an existing file in the destination folder.
 * @return No object or value is returned by this method.
 */
moveAsync(
destinationFolder: Windows$Storage$IStorageFolder,
desiredNewName: string,
option: $Values<typeof Windows$Storage$NameCollisionOption>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the name of the file including the file name extension.
 */
name: string;

/**
 * Opens a random-access stream with the specified options over the specified file.
 * @param accessMode One of the enumeration values that specifies the type of access to allow.
 * @return When this method completes, it returns an IRandomAccessStream that contains the requested random-access stream.
 */
openAsync(
accessMode: $Values<typeof Windows$Storage$FileAccessMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStream>;

/**
 * Opens a random-access stream with the specified options over the specified file.
 * @param accessMode One of the enumeration values that specifies the type of access to allow.
 * @param options A bitwise combination of the enumeration values that specify options for opening the stream.
 * @return When this method completes, it returns an IRandomAccessStream that contains the requested random-access stream.
 */
openAsync(
accessMode: $Values<typeof Windows$Storage$FileAccessMode>,
options: $Values<typeof Windows$Storage$StorageOpenOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStream>;

/**
 * Opens a random-access stream over the current file for reading file contents.
 * @return When this method completes, it returns the random-access stream (type IRandomAccessStreamWithContentType ).
 */
openReadAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStreamWithContentType>;

/**
 * Opens a sequential-access stream over the current file for reading file contents.
 * @return When this method completes, it returns the sequential-access stream (type IInputStream ).
 */
openSequentialReadAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IInputStream>;

/**
 * Opens a random-access stream to the file that can be used for transacted-write operations.
 * @return When this method completes, it returns a StorageStreamTransaction that contains the random-access stream and methods that can be used to complete transactions.
 */
openTransactedWriteAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageStreamTransaction>;

/**
 * Opens a random-access stream to the file that can be used for transacted-write operations with the specified options.
 * @param options A bitwise combination of the enumeration values that specify options for opening the stream.
 * @return When this method completes, it returns a StorageStreamTransaction that contains the random-access stream and methods that can be used to complete transactions.
 */
openTransactedWriteAsync(
options: $Values<typeof Windows$Storage$StorageOpenOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageStreamTransaction>;

/**
 * Gets the full file-system path of the current file, if the file has a path.
 */
path: string;

/**
 * Gets an object that provides access to the content-related properties of the file.
 */
properties: Windows$Storage$FileProperties$StorageItemContentProperties;

/**
 * Gets the StorageProvider object that contains info about the service that stores the current file.
 */
provider: Windows$Storage$StorageProvider;

/**
 * Renames the current file.
 * @param desiredName The desired, new name of the current item.
 * @return No object or value is returned by this method when it completes.
 */
renameAsync(desiredName: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Renames the current file. This method also specifies what to do if an existing item in the current file's location has the same name.
 * @param desiredName The desired, new name of the current file.
 * @param option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing item in the current file's location.
 * @return No object or value is returned by this method when it completes.
 */
renameAsync(
desiredName: string,
option: $Values<typeof Windows$Storage$NameCollisionOption>): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Manages folders and their contents and provides information about them.
 */
declare class Windows$Storage$StorageFolder  {

/**
 * Gets the folder that has the specified absolute path in the file system.
 * @param path The absolute path in the file system (not the Uri) of the folder to get.
 * @return When this method completes successfully, it returns a StorageFolder that represents the specified folder.
 */
static getFolderFromPathAsync(
path: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Indicates whether the current folder supports the specified QueryOptions .
 * @param queryOptions The QueryOptions to check.
 * @return True if the folder or file group supports the specified QueryOptions ; otherwise false.
 */
areQueryOptionsSupported(queryOptions: Windows$Storage$Search$QueryOptions): boolean;

/**
 * Gets the attributes of the current folder.
 */
attributes: $Values<typeof Windows$Storage$FileAttributes>;

/**
 * Creates a new file in the current folder. This method also specifies what to do if a file with the same name already exists in the current folder.
 * @param desiredName The name of the new file to create in the current folder.
 * @param options One of the enumeration values that determines how to handle the collision if a file with the specified desiredName already exists in the current folder.
 * @return When this method completes, it returns a StorageFile that represents the new file.
 */
createFileAsync(
desiredName: string,
options: $Values<typeof Windows$Storage$CreationCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Creates a new file with the specified name in the current folder.
 * @param desiredName The name of the new file to create in the current folder.
 * @return When this method completes, it returns a StorageFile that represents the new file.
 */
createFileAsync(
desiredName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Gets a query result object that contains the files in the current folder.
 * @return A query result object. Call the GetFilesAsync method of the query result to get the flat list of files. This method returns a list of type IReadOnlyList< StorageFile >. Each file is represented by an item of type StorageFile.
 */
createFileQuery(): Windows$Storage$Search$StorageFileQueryResult;

/**
 * Gets a query result object that contains the files in the current folder. Also gets the files from the subfolders of the current folder when the value of the query argument is something other than CommonFileQuery.DefaultQuery . Files are sorted based on the specified CommonFileQuery.
 * @param query One of the enumeration values that specifies how to sort the files and determines whether the query is shallow or deep.
 * @return A query result object. Call the GetFilesAsync method of the query result to get the flat list of files, sorted as specified by query. This method returns a list of type IReadOnlyList< StorageFile >. Each file is represented by an item of type StorageFile.
 */
createFileQuery(
query: $Values<typeof Windows$Storage$Search$CommonFileQuery>): Windows$Storage$Search$StorageFileQueryResult;

/**
 * Gets a query result object that contains the files in the current folder and, optionally, in the subfolders of the current folder. The results are based on the specified QueryOptions .
 * @param queryOptions The criteria that are applied to the query.
 * @return A query result object that contains the files in the current folder and, optionally, in the subfolders of the current folder, filtered and sorted based on the specified QueryOptions . Call the GetFilesAsync method of the query result to get the flat list of files, sorted as specified by queryOptions. This method returns a list of type IReadOnlyList< StorageFile >. Each file is represented by an item of type StorageFile.
 */
createFileQueryWithOptions(
queryOptions: Windows$Storage$Search$QueryOptions): Windows$Storage$Search$StorageFileQueryResult;

/**
 * Creates a new subfolder with the specified name in the current folder.
 * @param desiredName The name of the new subfolder to create in the current folder.
 * @return When this method completes, it returns a StorageFolder that represents the new subfolder.
 */
createFolderAsync(
desiredName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Creates a new subfolder with the specified name in the current folder. This method also specifies what to do if a subfolder with the same name already exists in the current folder.
 * @param desiredName The name of the new subfolder to create in the current folder.
 * @param options One of the enumeration values that determines how to handle the collision if a subfolder with the specified desiredName already exists in the current folder.
 * @return When this method completes, it returns a StorageFolder that represents the new subfolder.
 */
createFolderAsync(
desiredName: string,
options: $Values<typeof Windows$Storage$CreationCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Gets a query result object that contains the subfolders in the current folder.
 * @return A query result object. Call the GetFoldersAsync method of the query result to get the subfolders in the current folder. This method returns a list of type IReadOnlyList< StorageFolder >. Each file or folder is represented by an item of type StorageFolder.
 */
createFolderQuery(): Windows$Storage$Search$StorageFolderQueryResult;

/**
 * Gets a query result object that contains the subfolders in the current folder. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , gets a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. Files are grouped into folders based on the specified value from the CommonFolderQuery enumeration.
 * @param query One of the enumeration values that specifies how to group the files into folders and determines whether the query is shallow or deep.
 * @return A query result object. Call the GetFoldersAsync method of the query result to get the subfolders in the current folder. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , the query result object contains a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. (Files from the current folder are not included.) The files are grouped as specified by query. The list is of type IReadOnlyList< StorageFolder >. Each folder in the list is represented by a StorageFolder object.
 */
createFolderQuery(
query: $Values<typeof Windows$Storage$Search$CommonFolderQuery>): Windows$Storage$Search$StorageFolderQueryResult;

/**
 * Gets a query result object that contains the subfolders in the current folder and, optionally, nested subfolders. The results are based on the specified QueryOptions .
 * @param queryOptions The criteria that are applied to the query.
 * @return A query result object. Call the GetFoldersAsync method of the query result to get the subfolders in the current folder. If you provided a CommonFolderQuery value other than CommonFolderQuery.DefaultQuery when you instantiated the QueryOptions , the query result object contains a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. (Files from the current folder are not included.) The files are grouped as specified by queryOptions. The list is of type IReadOnlyList< StorageFolder >. Each folder in the list is represented by a StorageFolder object.
 */
createFolderQueryWithOptions(
queryOptions: Windows$Storage$Search$QueryOptions): Windows$Storage$Search$StorageFolderQueryResult;

/**
 * Gets a query result object that contains the files and subfolders in the current folder.
 * @return A query result object. Call the GetItemsAsync method of the query result to get the files and subfolders in the current folder. This method returns a list of type IReadOnlyList< IStorageItem >. Each file or folder is represented by an item of type IStorageItem.
 */
createItemQuery(): Windows$Storage$Search$StorageItemQueryResult;

/**
 * Gets a query result object that contains the files and subfolders in the current folder and, optionally, in the subfolders of the current folder. The results are based on the specified QueryOptions .
 * @param queryOptions The criteria that are applied to the query.
 * @return A query result object. Call the GetItemsAsync method of the query result to get the files and subfolders in the current folder and, optionally, in the subfolders of the current folder, filtered and sorted based on the specified QueryOptions . This method returns a list of type IReadOnlyList< IStorageItem >. Each file or folder is represented by an item of type IStorageItem.
 */
createItemQueryWithOptions(
queryOptions: Windows$Storage$Search$QueryOptions): Windows$Storage$Search$StorageItemQueryResult;

/**
 * Gets the date and time that the current folder was created.
 */
dateCreated: Date;

/**
 * Deletes the current folder. This method also specifies whether to delete the folder permanently.
 * @param option One of the enumeration values that specifies whether to delete the folder permanently.
 * @return No object or value is returned by this method when it completes.
 */
deleteAsync(
option: $Values<typeof Windows$Storage$StorageDeleteOption>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Deletes the current folder.
 * @return No object or value is returned by this method when it completes.
 */
deleteAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the user-friendly name of the current folder.
 */
displayName: string;

/**
 * Gets the user-friendly description of the type of the folder; for example, JPEG image.
 */
displayType: string;

/**
 * Gets an identifier for the current folder. This ID is unique for the query result or StorageFolder that contains the current folder or file group, and can be used to distinguish between items that have the same name.
 */
folderRelativeId: string;

/**
 * Gets the basic properties of the current folder or file group.
 * @return When this method completes successfully, it returns the basic properties of the current folder or file group as a BasicProperties object.
 */
getBasicPropertiesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$BasicProperties>;

/**
 * Gets the file with the specified name from the current folder.
 * @param name The name (or path relative to the current folder) of the file to get.
 * @return When this method completes successfully, it returns a StorageFile that represents the specified file.
 */
getFileAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>;

/**
 * Gets the files in the current folder. Also gets the files from the subfolders of the current folder when the value of the query argument is something other than CommonFileQuery.DefaultQuery . Files are sorted based on the specified value from the CommonFileQuery enumeration.
 * @param query One of the enumeration values that specifies how to sort the files and determines whether the query is shallow or deep.
 * @return When this method completes successfully, it returns a flat list of files, sorted as specified by query. The list is of type IReadOnlyList< StorageFile >. Each file in the list is represented by a StorageFile object.
 */
getFilesAsync(
query: $Values<typeof Windows$Storage$Search$CommonFileQuery>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the files in the current folder.
 * @return When this method completes successfully, it returns a list of the files in the current folder. The list is of type IReadOnlyList< StorageFile >. Each file in the list is represented by a StorageFile object.
 */
getFilesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets an index-based range of files from the list of all files in the current folder. Also gets the files from the subfolders of the current folder when the value of the query argument is something other than CommonFileQuery.DefaultQuery . Files are sorted based on the specified value from the CommonFileQuery enumeration.
 * @param query One of the enumeration values that specifies how to sort the files and determines whether the query is shallow or deep.
 * @param startIndex The zero-based index of the first file in the range to retrieve.
 * @param maxItemsToRetrieve The maximum number of files to retrieve.
 * @return When this method completes successfully, it returns a flat list of files sorted as specified by query. The list is of type IReadOnlyList< StorageFile >. Each file in the list is represented by a StorageFile object.
 */
getFilesAsync(
query: $Values<typeof Windows$Storage$Search$CommonFileQuery>,
startIndex: number,
maxItemsToRetrieve: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the subfolder with the specified name from the current folder.
 * @param name The name (or path relative to the current folder) of the subfolder to get.
 * @return When this method completes successfully, it returns a StorageFolder that represents the specified subfolder.
 */
getFolderAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Gets the subfolders in the current folder.
 * @return When this method completes successfully, it returns a list of the subfolders in the current folder. The list is of type IReadOnlyList< StorageFolder >. Each folder in the list is represented by a StorageFolder object.
 */
getFoldersAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the subfolders in the current folder. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , gets a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. Files are grouped into folders based on the specified value from the CommonFolderQuery enumeration.
 * @param query One of the enumeration values that specifies how to group the files into folders and determines whether the query is shallow or deep.
 * @return When this method completes successfully, it returns a list of subfolders. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , this method returns a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. (Files from the current folder are not included.) The files are grouped as specified by query. The list is of type IReadOnlyList< StorageFolder >. Each folder in the list is represented by a StorageFolder object.
 */
getFoldersAsync(
query: $Values<typeof Windows$Storage$Search$CommonFolderQuery>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets an index-based range of folders from the list of all subfolders in the current folder. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , gets a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. Files are grouped into folders based on the specified value from the CommonFolderQuery enumeration.
 * @param query One of the enumeration values that specifies how to group the files into folders and determines whether the query is shallow or deep.
 * @param startIndex The zero-based index of the first folder in the range to retrieve.
 * @param maxItemsToRetrieve The maximum number of folders to retrieve.
 * @return When this method completes successfully, it returns a list of subfolders. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , this method returns a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. (Files from the current folder are not included.) The files are grouped as specified by query. The list is of type IReadOnlyList< StorageFolder >. Each folder in the list is represented by a StorageFolder object.
 */
getFoldersAsync(
query: $Values<typeof Windows$Storage$Search$CommonFolderQuery>,
startIndex: number,
maxItemsToRetrieve: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the indexed state of the current folder.
 * @return When this method completes successfully, it returns an IndexedState enum value that describes the state of the folder.
 */
getIndexedStateAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$Storage$Search$IndexedState>>;

/**
 * Gets the file or folder with the specified name from the current folder.
 * @param name The name (or path relative to the current folder) of the file or folder to get.
 * @return When this method completes successfully, it returns an IStorageItem that represents the specified file or folder.
 */
getItemAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$IStorageItem>;

/**
 * Gets the files and subfolders in the current folder.
 * @return When this method completes successfully, it returns a list of the files and folders in the current folder. The list is of type IReadOnlyList< IStorageItem >. Each item in the list is represented by an IStorageItem object.
 */
getItemsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets an index-based range of files and folders from the list of all files and subfolders in the current folder.
 * @param startIndex The zero-based index of the first item in the range to get.
 * @param maxItemsToRetrieve The maximum number of items to get.
 * @return When this method completes successfully, it returns a list of the files and subfolders in the current folder. The list is of type IReadOnlyList< IStorageItem >. Each item in the list is represented by an IStorageItem object.
 */
getItemsAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets the parent folder of the current folder.
 * @return When this method completes, it returns the parent folder as a StorageFolder .
 */
getParentAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail, the requested size, and the specified options
 * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
 * @param options The enum value that describes the desired behavior to use to retrieve the thumbnail image. The specified behavior might affect the size and/or quality of the image and how quickly the thumbnail image is retrieved.
 * @return When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the item.
 */
getScaledImageAsThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>,
requestedSize: number,
options: $Values<typeof Windows$Storage$FileProperties$ThumbnailOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail and the requested size.
 * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
 * @return When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the item.
 */
getScaledImageAsThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>,
requestedSize: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail.
 * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @return When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the item.
 */
getScaledImageAsThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Gets a thumbnail image for the current folder, sized for the specified purpose of the thumbnail and adjusted to the requested size with the specified options.
 * @param mode A value from the enumeration that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. This method uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
 * @param options A value from the enumeration that specifies how to retrieve and size the image. The default value, UseCurrentScale, is suitable for most apps.
 * @return When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image, or null if there is no thumbnail image associated with the folder.
 */
getThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>,
requestedSize: number,
options: $Values<typeof Windows$Storage$FileProperties$ThumbnailOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Gets a thumbnail image for the current folder, sized for the specified purpose of the thumbnail and adjusted to the requested size.
 * @param mode A value from the enumeration that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. This method uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
 * @return When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image, or null if there is no thumbnail image associated with the folder.
 */
getThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>,
requestedSize: number): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Gets a thumbnail image for the current folder, sized for the specified purpose of the thumbnail.
 * @param mode A value from the enumeration that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @return When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image, or null if there is no thumbnail image associated with the folder.
 */
getThumbnailAsync(
mode: $Values<typeof Windows$Storage$FileProperties$ThumbnailMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$StorageItemThumbnail>;

/**
 * Indicates whether the current folder supports the specified CommonFileQuery .
 * @param query The value to test.
 * @return True if the folder supports the specified CommonFileQuery ; otherwise, false.
 */
isCommonFileQuerySupported(query: $Values<typeof Windows$Storage$Search$CommonFileQuery>): boolean;

/**
 * Indicates whether the current folder supports the specified CommonFolderQuery .
 * @param query The value to test.
 * @return True if the folder supports the specified CommonFolderQuery ; otherwise, false.
 */
isCommonFolderQuerySupported(query: $Values<typeof Windows$Storage$Search$CommonFolderQuery>): boolean;

/**
 * Indicates whether the current folder is equal to the specified folder.
 * @param item The IStorageItem object that represents the folder to compare against.
 * @return Returns true if the current folder is equal to the specified folder; otherwise false.
 */
isEqual(item: Windows$Storage$IStorageItem): boolean;

/**
 * Indicates whether the current StorageFolder matches the specified StorageItemTypes value.
 * @param type The enum value that determines the object type to match against.
 * @return True if the StorageFolder matches the specified StorageItemTypes value; otherwise false.
 */
isOfType(type: $Values<typeof Windows$Storage$StorageItemTypes>): boolean;

/**
 * Gets the name of the current folder.
 */
name: string;

/**
 * Gets the full path of the current folder in the file system, if the path is available.
 */
path: string;

/**
 * Gets an object that provides access to the content-related properties of the current folder.
 */
properties: Windows$Storage$FileProperties$StorageItemContentProperties;

/**
 * Gets the StorageProvider object that contains info about the service that stores the current folder.
 */
provider: Windows$Storage$StorageProvider;

/**
 * Renames the current folder.
 * @param desiredName The desired, new name for the current folder.
 * @return No object or value is returned by this method when it completes.
 */
renameAsync(desiredName: string): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Renames the current folder and specifies what to do if a folder with the same name already exists.
 * @param desiredName The desired, new name for the current folder.
 * @param option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing item in the current folder's location.
 * @return No object or value is returned by this method when it completes.
 */
renameAsync(
desiredName: string,
option: $Values<typeof Windows$Storage$NameCollisionOption>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Tries to get the file or folder with the specified name from the current folder. Returns null instead of raising an exception if the specified file or folder is not found.
 * @param name The name (or path relative to the current folder) of the file or folder to get.
 * @return When this method completes successfully, it returns an IStorageItem that represents the specified file or folder. If the specified file or folder is not found, this method returns null instead of raising an exception.
 */
tryGetItemAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$IStorageItem>
}


/**
 * Describes whether an item that implements the IStorageItem interface is a file or a folder.
 */

declare  var Windows$Storage$StorageItemTypes: {|
  +none: 0,// 0
+file: 1,// 1
+folder: 2,// 2

|};



/**
 * Lets you add and remove folders from a library like Music or Videos and lets you get a list of folders included in the library.
 */
declare class Windows$Storage$StorageLibrary  {

/**
 * Gets the specified library.
 * @param libraryId A KnownLibraryId value that identifies the library to retrieve, like Music or Videos.
 * @return When this method completes successfully, it returns the library (type StorageLibrary ).
 */
static getLibraryAsync(
libraryId: $Values<typeof Windows$Storage$KnownLibraryId>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageLibrary>;

/**
 * Gets the specified library for a User .
 * @param user The User for which the library is retrieved.
 * @param libraryId A KnownLibraryId value that identifies the library to retrieve, like Music or Videos.
 * @return When this method completes successfully, it returns the library (type StorageLibrary ).
 */
static getLibraryForUserAsync(
user: Windows$System$User,
libraryId: $Values<typeof Windows$Storage$KnownLibraryId>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageLibrary>;

/**
 * Gets the folders in the current library.
 */
folders: Windows$Foundation$Collections$IObservableVector<Windows$Storage$StorageFolder>;

/**
 * Occurs when the list of folders in the current library changes.
 */
ondefinitionchanged: Windows$Foundation$TypedEventHandler<Windows$Storage$StorageLibrary, any>;
addEventListener(
type: "definitionchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$StorageLibrary, any>): void;
removeEventListener(
type: "definitionchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$Storage$StorageLibrary, any>): void;

/**
 * Prompts the user to select a folder, and then adds the folder to the library.
 * @return When this method completes, it returns the folder that the user picked and added as a StorageFolder . If the user cancels the operation and doesn't pick a folder, the method returns null.
 */
requestAddFolderAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>;

/**
 * Prompts the user to confirm removal of the specified folder from the current library, and then removes the folder.
 * @param folder The folder to remove.
 * @return Returns true if the folder was removed; otherwise false.
 */
requestRemoveFolderAsync(
folder: Windows$Storage$StorageFolder): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Get the default save folder for the current library.
 */
saveFolder: Windows$Storage$StorageFolder;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides options to use when opening a file.
 */

declare  var Windows$Storage$StorageOpenOptions: {|
  +none: 0,// 0
+allowOnlyReaders: 1,// 1

|};



/**
 * Contains info about the service that stores files and folders. Files and folders may be stored either by the local file system or by a remote service like Microsoft OneDrive.
 */
declare class Windows$Storage$StorageProvider  {

/**
 * Gets a user-friendly name for the current provider of files and folders.
 */
displayName: string;

/**
 * Gets an identifier for the current provider of files and folders.
 */
id: string
}


/**
 * Represents a write transaction for a random-access stream.
 */
declare class Windows$Storage$StorageStreamTransaction  {

/**
 * Releases system resources that are exposed by the stream, indicating that the data request is complete.
 */
close(): void;

/**
 * Save the stream to the underlying file.
 * @return No object or value is returned by this method.
 */
commitAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets the random-access stream used in the transaction.
 */
stream: Windows$Storage$Streams$IRandomAccessStream
}


/**
 * Represents a sequential-access output stream that indicates a request for the data stream of a StorageFile that was created by calling CreateStreamedFileAsync or ReplaceWithStreamedFileAsync .
 */
declare class Windows$Storage$StreamedFileDataRequest  {

/**
 * Releases system resources that are exposed by the current stream indicating that the data request is complete.
 */
close(): void;

/**
 * Indicates that the data can't be streamed and releases system resources that are exposed by the current stream indicating that the data request is complete.
 * @param failureMode The enum value that indicates why the data stream can't be accessed.
 */
failAndClose(failureMode: $Values<typeof Windows$Storage$StreamedFileFailureMode>): void;

/**
 * Flushes the data in the current stream.
 * @return When this method completes, it returns true if the data was flushed successfully or false if the flush operation failed.
 */
flushAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Writes data from a buffer to the current stream.
 * @param buffer The buffer that contains the data to write.
 * @return When this method completes, it returns the number of bytes (type UInt32 ) that were written to the stream. If the app specifies a function to monitor progress, that function receives the number of bytes (type UInt32) written so far.
 */
writeAsync(
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Indicates the reason that data could not be streamed.
 */

declare  var Windows$Storage$StreamedFileFailureMode: {|
  +failed: 0,// 0
+currentlyUnavailable: 1,// 1
+incomplete: 2,// 2

|};



      declare var npm$namespace$Windows$Storage$Streams: {
        
        
        ByteOrder: typeof Windows$Storage$Streams$ByteOrder,
InputStreamOptions: typeof Windows$Storage$Streams$InputStreamOptions,
UnicodeEncoding: typeof Windows$Storage$Streams$UnicodeEncoding,
        Buffer: typeof Windows$Storage$Streams$Buffer,
DataReader: typeof Windows$Storage$Streams$DataReader,
DataReaderLoadOperation: typeof Windows$Storage$Streams$DataReaderLoadOperation,
DataWriter: typeof Windows$Storage$Streams$DataWriter,
DataWriterStoreOperation: typeof Windows$Storage$Streams$DataWriterStoreOperation,
FileInputStream: typeof Windows$Storage$Streams$FileInputStream,
FileOutputStream: typeof Windows$Storage$Streams$FileOutputStream,
FileRandomAccessStream: typeof Windows$Storage$Streams$FileRandomAccessStream,
InMemoryRandomAccessStream: typeof Windows$Storage$Streams$InMemoryRandomAccessStream,
InputStreamOverStream: typeof Windows$Storage$Streams$InputStreamOverStream,
OutputStreamOverStream: typeof Windows$Storage$Streams$OutputStreamOverStream,
RandomAccessStream: typeof Windows$Storage$Streams$RandomAccessStream,
RandomAccessStreamOverStream: typeof Windows$Storage$Streams$RandomAccessStreamOverStream,
RandomAccessStreamReference: typeof Windows$Storage$Streams$RandomAccessStreamReference,
        
      }

/**
 * Provides a default implementation of the IBuffer interface and its related interfaces.
 */
declare class Windows$Storage$Streams$Buffer  {

/**
 * Creates a new buffer containing a copy of a specified buffer.
 * @param input The buffer to be copied.
 * @return The newly created copy.
 */
static createCopyFromMemoryBuffer(input: Windows$Foundation$IMemoryBuffer): Windows$Storage$Streams$Buffer;

/**
 * Creates a MemoryBuffer from an existing IBuffer .
 * @param input The input IBuffer .
 * @return The newly created MemoryBuffer .
 */
static createMemoryBufferOverIBuffer(input: Windows$Storage$Streams$IBuffer): Windows$Foundation$MemoryBuffer;

/**
 * Initializes a new instance of the Buffer class with the specified capacity.
 * @param capacity The maximum number of bytes that the buffer can hold.
 */
constructor(capacity: number): this;
byteLength: any;

/**
 * Gets the maximum number of bytes that the buffer can hold.
 */
capacity: number;

/**
 * Gets the number of bytes currently in use in the buffer.
 */
length: number
}


/**
 * Specifies the byte order of a stream.
 */

declare  var Windows$Storage$Streams$ByteOrder: {|
  +littleEndian: 0,// 0
+bigEndian: 1,// 1

|};



/**
 * Reads data from an input stream.
 */
declare class Windows$Storage$Streams$DataReader  {

/**
 * Creates a new instance of the data reader with data from the specified buffer.
 * @param buffer The buffer.
 * @return The data reader.
 */
static fromBuffer(buffer: Windows$Storage$Streams$IBuffer): Windows$Storage$Streams$DataReader;

/**
 * Creates and initializes a new instance of the data reader.
 * @param inputStream The input stream.
 */
constructor(inputStream: Windows$Storage$Streams$IInputStream): this;

/**
 * Gets or sets the byte order of the data in the input stream.
 */
byteOrder: $Values<typeof Windows$Storage$Streams$ByteOrder>;

/**
 * Closes the current stream and releases system resources.
 */
close(): void;

/**
 * Detaches the buffer that is associated with the data reader.
 * @return The detached buffer.
 */
detachBuffer(): Windows$Storage$Streams$IBuffer;

/**
 * Detaches the stream that is associated with the data reader.
 * @return The detached stream.
 */
detachStream(): Windows$Storage$Streams$IInputStream;

/**
 * Gets or sets the read options for the input stream.
 */
inputStreamOptions: $Values<typeof Windows$Storage$Streams$InputStreamOptions>;

/**
 * Loads data from the input stream.
 * @param count The count of bytes to load into the intermediate buffer.
 * @return The asynchronous load data request.
 */
loadAsync(
count: number): Windows$Foundation$IPromiseWithOperation<any, Windows$Storage$Streams$DataReaderLoadOperation>;

/**
 * Reads a Boolean value from the input stream.
 * @return The value.
 */
readBoolean(): boolean;

/**
 * Reads a buffer from the input stream.
 * @param length The length of the buffer, in bytes.
 * @return The buffer.
 */
readBuffer(length: number): Windows$Storage$Streams$IBuffer;

/**
 * Reads a byte value from the input stream.
 * @return The value.
 */
readByte(): number;

/**
 * Reads an array of byte values from the input stream.
 * @return The array that receives the byte values.
 */
readBytes(): number[];

/**
 * Reads a date and time value from the input stream.
 * @return The value.
 */
readDateTime(): Date;

/**
 * Reads a floating-point value from the input stream.
 * @return The value.
 */
readDouble(): number;

/**
 * Reads a GUID value from the input stream.
 * @return The value.
 */
readGuid(): string;

/**
 * Reads a 16-bit integer value from the input stream.
 * @return The value.
 */
readInt16(): number;

/**
 * Reads a 32-bit integer value from the input stream.
 * @return The value.
 */
readInt32(): number;

/**
 * Reads a 64-bit integer value from the input stream.
 * @return The value.
 */
readInt64(): number;

/**
 * Reads a floating-point value from the input stream.
 * @return The value.
 */
readSingle(): number;

/**
 * Reads a string value from the input stream.
 * @param codeUnitCount The length of the string.
 * @return The value.
 */
readString(codeUnitCount: number): string;

/**
 * Reads a time-interval value from the input stream.
 * @return The value.
 */
readTimeSpan(): number;

/**
 * Reads a 16-bit unsigned integer from the input stream.
 * @return The value.
 */
readUInt16(): number;

/**
 * Reads a 32-bit unsigned integer from the input stream.
 * @return The value.
 */
readUInt32(): number;

/**
 * Reads a 64-bit unsigned integer from the input stream.
 * @return The value.
 */
readUInt64(): number;

/**
 * Gets the size of the buffer that has not been read.
 */
unconsumedBufferLength: number;

/**
 * Gets or sets the Unicode character encoding for the input stream.
 */
unicodeEncoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>
}


/**
 * Loads data from an input stream.
 */
declare class Windows$Storage$Streams$DataReaderLoadOperation  {

/**
 * Requests the cancellation of the data load operation.
 */
cancel(): void;

/**
 * Requests that work associated with the data load operation should stop.
 */
close(): void;

/**
 * Gets or sets the handler to call when the data load operation is complete.
 */
completed: Windows$Foundation$AsyncOperationCompletedHandler<number>;

/**
 * Gets the error code for the data load operation if it fails.
 */
errorCode: Windows$WinRTError;

/**
 * Returns the result of the data load operation.
 * @return The result of the operation.
 */
getResults(): number;

/**
 * Gets a unique identifier that represents the data load operation.
 */
id: number;

/**
 * Gets the current status of the data load operation.
 */
status: $Values<typeof Windows$Foundation$AsyncStatus>
}


/**
 * Writes data to an output stream.
 */
declare class Windows$Storage$Streams$DataWriter  {

/**
 * Creates and initializes a new instance of the data writer.
 */
constructor(): this;

/**
 * Creates and initializes a new instance of the data writer to an output stream.
 * @param outputStream The new output stream instance.
 */
constructor(outputStream: Windows$Storage$Streams$IOutputStream): this;

/**
 * Gets or sets the byte order of the data in the output stream.
 */
byteOrder: $Values<typeof Windows$Storage$Streams$ByteOrder>;

/**
 * Closes the current stream and releases system resources.
 */
close(): void;

/**
 * Detaches the buffer that is associated with the data writer.
 * @return The detached buffer.
 */
detachBuffer(): Windows$Storage$Streams$IBuffer;

/**
 * Detaches the stream that is associated with the data writer.
 * @return The detached stream.
 */
detachStream(): Windows$Storage$Streams$IOutputStream;

/**
 * Flushes data asynchronously.
 * @return The stream flush operation.
 */
flushAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets the size of a string.
 * @param value The string.
 * @return The size of the string, in bytes.
 */
measureString(value: string): number;

/**
 * Commits data in the buffer to a backing store.
 * @return The asynchronous store data operation.
 */
storeAsync(
): Windows$Foundation$IPromiseWithOperation<any, Windows$Storage$Streams$DataWriterStoreOperation>;

/**
 * Gets or sets the Unicode character encoding for the output stream.
 */
unicodeEncoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>;

/**
 * Gets the size of the buffer that has not been used.
 */
unstoredBufferLength: number;

/**
 * Writes a Boolean value to the output stream.
 * @param value The value.
 */
writeBoolean(value: boolean): void;

/**
 * Writes the specified bytes from a buffer to the output stream.
 * @param buffer The buffer.
 * @param start The starting byte.
 * @param count The number of bytes to write.
 */
writeBuffer(buffer: Windows$Storage$Streams$IBuffer, start: number, count: number): void;

/**
 * Writes the contents of the specified buffer to the output stream.
 * @param buffer The buffer.
 */
writeBuffer(buffer: Windows$Storage$Streams$IBuffer): void;

/**
 * Writes a byte value to the output stream.
 * @param value The value.
 */
writeByte(value: number): void;

/**
 * Writes an array of byte values to the output stream.
 * @param value The array of values.
 */
writeBytes(value: number[]): void;

/**
 * Writes a date and time value to the output stream.
 * @param value The value.
 */
writeDateTime(value: Date): void;

/**
 * Writes a floating-point value to the output stream.
 * @param value The value.
 */
writeDouble(value: number): void;

/**
 * Writes a GUID value to the output stream.
 * @param value The value.
 */
writeGuid(value: string): void;

/**
 * Writes a 16-bit integer value to the output stream.
 * @param value The value.
 */
writeInt16(value: number): void;

/**
 * Writes a 32-bit integer value to the output stream.
 * @param value The value.
 */
writeInt32(value: number): void;

/**
 * Writes a 64-bit integer value to the output stream.
 * @param value The value.
 */
writeInt64(value: number): void;

/**
 * Writes a floating-point value to the output stream.
 * @param value The value.
 */
writeSingle(value: number): void;

/**
 * Writes a string value to the output stream.
 * @param value The value.
 * @return The length of the string, in bytes.
 */
writeString(value: string): number;

/**
 * Writes a time-interval value to the output stream.
 * @param value The value.
 */
writeTimeSpan(value: number): void;

/**
 * Writes a 16-bit unsigned integer value to the output stream.
 * @param value The value.
 */
writeUInt16(value: number): void;

/**
 * Writes a 32-bit unsigned integer value to the output stream.
 * @param value The value.
 */
writeUInt32(value: number): void;

/**
 * Writes a 64-bit unsigned integer value to the output stream.
 * @param value The value.
 */
writeUInt64(value: number): void
}


/**
 * Commits data in a buffer to a backing store.
 */
declare class Windows$Storage$Streams$DataWriterStoreOperation  {

/**
 * Requests the cancellation of the data store operation.
 */
cancel(): void;

/**
 * Requests that work associated with the data store operation should stop.
 */
close(): void;

/**
 * Gets or sets the handler to call when the data store operation is complete.
 */
completed: Windows$Foundation$AsyncOperationCompletedHandler<number>;

/**
 * Gets the error code for the data store operation if it fails.
 */
errorCode: Windows$WinRTError;

/**
 * Returns the result of the data store operation.
 * @return The result of the operation.
 */
getResults(): number;

/**
 * Gets a unique identifier that represents the data store operation.
 */
id: number;

/**
 * Gets the current status of the data store operation.
 */
status: $Values<typeof Windows$Foundation$AsyncStatus>
}


/**
 * Reads data from a file.
 */
declare class Windows$Storage$Streams$FileInputStream  {

/**
 * Closes the current stream and releases system resources.
 */
close(): void;

/**
 * Returns an asynchronous byte reader object.
 * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param count The number of bytes to read that is less than or equal to the Capacity value.
 * @param options Specifies the type of the asynchronous read operation.
 * @return The asynchronous operation.
 */
readAsync(
buffer: Windows$Storage$Streams$IBuffer,
count: number,
options: $Values<typeof Windows$Storage$Streams$InputStreamOptions>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>
}


/**
 * Writes data to a file.
 */
declare class Windows$Storage$Streams$FileOutputStream  {

/**
 * Closes the current stream and releases system resources.
 */
close(): void;

/**
 * Flushes data asynchronously in a sequential stream.
 * @return The stream flush operation.
 */
flushAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Writes data asynchronously to a file.
 * @param buffer The buffer into which the asynchronous writer operation writes.
 * @return The byte writer operation.
 */
writeAsync(
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Supports reading and writing to a file at a specified position.
 */
declare class Windows$Storage$Streams$FileRandomAccessStream  {

/**
 * Gets a value that indicates whether the stream can be read from.
 */
canRead: boolean;

/**
 * Gets a value that indicates whether the file can be written to.
 */
canWrite: boolean;

/**
 * Creates a new instance of a IRandomAccessStream over the same resource as the current stream.
 * @return The new stream. The initial, internal position of the stream is 0.
 */
cloneStream(): Windows$Storage$Streams$IRandomAccessStream;

/**
 * Closes the current stream and releases system resources.
 */
close(): void;

/**
 * Flushes data asynchronously in a sequential stream.
 * @return The stream flush operation.
 */
flushAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Returns an input stream at a specified location in a stream.
 * @param position The location in the stream at which to begin.
 * @return The input stream.
 */
getInputStreamAt(position: number): Windows$Storage$Streams$IInputStream;

/**
 * Returns an output stream at a specified location in a stream.
 * @param position The location in the output stream at which to begin.
 * @return The output stream.
 */
getOutputStreamAt(position: number): Windows$Storage$Streams$IOutputStream;

/**
 * Gets the byte offset of the stream.
 */
position: number;

/**
 * Returns an asynchronous byte reader object.
 * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param count The number of bytes to read that is less than or equal to the Capacity value.
 * @param options Specifies the type of the asynchronous read operation.
 * @return The asynchronous operation.
 */
readAsync(
buffer: Windows$Storage$Streams$IBuffer,
count: number,
options: $Values<typeof Windows$Storage$Streams$InputStreamOptions>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>;

/**
 * Sets the position of the stream to the specified value.
 * @param position The new position of the stream.
 */
seek(position: number): void;

/**
 * Gets or sets the size of the random access stream.
 */
size: number;

/**
 * Writes data asynchronously to a file.
 * @param buffer The buffer into which the asynchronous writer operation writes.
 * @return The byte writer operation.
 */
writeAsync(
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Provides random access of data in input and output streams that are stored in memory instead of on disk.
 */
declare class Windows$Storage$Streams$InMemoryRandomAccessStream  {

/**
 * Creates a new instance of the InMemoryRandomAccessStream class.
 */
constructor(): this;

/**
 * Gets a value that indicates whether the stream can be read from.
 */
canRead: boolean;

/**
 * Gets a value that indicates whether the stream can be written to.
 */
canWrite: boolean;

/**
 * Creates a new instance of a IRandomAccessStream over the same resource as the current stream.
 * @return The new stream. The initial, internal position of the stream is 0.
 */
cloneStream(): Windows$Storage$Streams$IRandomAccessStream;

/**
 * Closes the current stream and releases system resources.
 */
close(): void;

/**
 * Flushes data asynchronously in a sequential stream.
 * @return The stream flush operation.
 */
flushAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Returns an input stream at a specified location in a stream.
 * @param position The location in the stream at which to begin.
 * @return The input stream.
 */
getInputStreamAt(position: number): Windows$Storage$Streams$IInputStream;

/**
 * Returns an output stream at a specified location in a stream.
 * @param position The location in the output stream at which to begin.
 * @return The output stream.
 */
getOutputStreamAt(position: number): Windows$Storage$Streams$IOutputStream;

/**
 * Gets the byte offset of the stream.
 */
position: number;

/**
 * Returns an asynchronous byte reader object.
 * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param count The number of bytes to read that is less than or equal to the Capacity value.
 * @param options Specifies the type of the asynchronous read operation.
 * @return The asynchronous operation.
 */
readAsync(
buffer: Windows$Storage$Streams$IBuffer,
count: number,
options: $Values<typeof Windows$Storage$Streams$InputStreamOptions>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>;

/**
 * Sets the position of the stream to the specified value.
 * @param position The new position of the stream.
 */
seek(position: number): void;

/**
 * Gets or sets the size of the random access stream.
 */
size: number;

/**
 * Writes data asynchronously in a sequential stream.
 * @param buffer The buffer into which the asynchronous writer operation writes.
 * @return The byte writer operation.
 */
writeAsync(
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Specifies the read options for an input stream.
 */

declare  var Windows$Storage$Streams$InputStreamOptions: {|
  +none: 0,// 0
+partial: 1,// 1
+readAhead: 2,// 2

|};



/**
 * Provides a Windows Runtime input stream for an IStream base implementation.
 */
declare class Windows$Storage$Streams$InputStreamOverStream  {

/**
 * Closes the current stream and releases system resources.
 */
close(): void;

/**
 * Returns an asynchronous byte reader object.
 * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param count The number of bytes to read that is less than or equal to the Capacity value.
 * @param options Specifies the type of the asynchronous read operation.
 * @return The asynchronous operation.
 */
readAsync(
buffer: Windows$Storage$Streams$IBuffer,
count: number,
options: $Values<typeof Windows$Storage$Streams$InputStreamOptions>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>
}


/**
 * Provides a Windows Runtime output stream for an IStream base implementation.
 */
declare class Windows$Storage$Streams$OutputStreamOverStream  {

/**
 * Closes the current stream and releases system resources.
 */
close(): void;

/**
 * Flushes data asynchronously in a sequential stream.
 * @return The stream flush operation.
 */
flushAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Writes data asynchronously in a sequential stream.
 * @param buffer The buffer into which the asynchronous writer operation writes.
 * @return The byte writer operation.
 */
writeAsync(
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Provides random access of data in input and output streams.
 */
declare class Windows$Storage$Streams$RandomAccessStream  {

/**
 * Copies a source stream to a destination stream and waits for the copy operation to complete.
 * @param source The stream to copy data from.
 * @param destination The stream to copy data to.
 * @return The asynchronous operation.
 */
static copyAndCloseAsync(
source: Windows$Storage$Streams$IInputStream,
destination: Windows$Storage$Streams$IOutputStream): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>;

/**
 * Copies the specified number of bytes from a source stream to a destination stream.
 * @param source The stream to copy data from.
 * @param destination The stream to copy data to.
 * @param bytesToCopy The number of bytes to copy.
 * @return The asynchronous operation.
 */
static copyAsync(
source: Windows$Storage$Streams$IInputStream,
destination: Windows$Storage$Streams$IOutputStream,
bytesToCopy: number): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>;

/**
 * Copies a source stream to a destination stream.
 * @param source The stream to copy data from.
 * @param destination The stream to copy data to.
 * @return The asynchronous operation.
 */
static copyAsync(
source: Windows$Storage$Streams$IInputStream,
destination: Windows$Storage$Streams$IOutputStream): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Provides a Windows Runtime random access stream for an IStream base implementation.
 */
declare class Windows$Storage$Streams$RandomAccessStreamOverStream  {

/**
 * Gets a value that indicates whether the stream can be read from.
 */
canRead: boolean;

/**
 * Gets a value that indicates whether the stream can be written to.
 */
canWrite: boolean;

/**
 * Creates a new instance of a IRandomAccessStream over the same resource as the current stream.
 * @return The new stream. The initial, internal position of the stream is 0.
 */
cloneStream(): Windows$Storage$Streams$IRandomAccessStream;

/**
 * Closes the current stream and releases system resources.
 */
close(): void;

/**
 * Flushes data asynchronously in a sequential stream.
 * @return The stream flush operation.
 */
flushAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Returns an input stream at a specified location in a stream.
 * @param position The location in the stream at which to begin.
 * @return The input stream.
 */
getInputStreamAt(position: number): Windows$Storage$Streams$IInputStream;

/**
 * Returns an output stream at a specified location in a stream.
 * @param position The location in the output stream at which to begin.
 * @return The output stream.
 */
getOutputStreamAt(position: number): Windows$Storage$Streams$IOutputStream;

/**
 * Gets the byte offset of the stream.
 */
position: number;

/**
 * Returns an asynchronous byte reader object.
 * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param count The number of bytes to read that is less than or equal to the Capacity value.
 * @param options Specifies the type of the asynchronous read operation.
 * @return The asynchronous operation.
 */
readAsync(
buffer: Windows$Storage$Streams$IBuffer,
count: number,
options: $Values<typeof Windows$Storage$Streams$InputStreamOptions>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>;

/**
 * Sets the position of the stream to the specified value.
 * @param position The new position of the stream.
 */
seek(position: number): void;

/**
 * Gets or sets the size of the random access stream.
 */
size: number;

/**
 * Writes data asynchronously in a sequential stream.
 * @param buffer The buffer into which the asynchronous writer operation writes.
 * @return The byte writer operation.
 */
writeAsync(
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Provides random access of data in input and output streams for a file.
 */
declare class Windows$Storage$Streams$RandomAccessStreamReference  {

/**
 * Creates a random access stream around a file.
 * @param file The file to create a stream around.
 * @return The stream that encapsulates file.
 */
static createFromFile(
file: Windows$Storage$IStorageFile): Windows$Storage$Streams$RandomAccessStreamReference;

/**
 * Creates a random access stream around the specified stream.
 * @param stream The source stream.
 * @return The random access stream that encapsulates stream.
 */
static createFromStream(
stream: Windows$Storage$Streams$IRandomAccessStream): Windows$Storage$Streams$RandomAccessStreamReference;

/**
 * Creates a random access stream around the specified URI.
 * @param uri The URI to create the stream around. The valid URI schemes are http, https, ms-appx, and ms-appdata.
 * @return The random access stream that encapsulates uri.
 */
static createFromUri(
uri: Windows$Foundation$Uri): Windows$Storage$Streams$RandomAccessStreamReference;

/**
 * Opens a stream for random access.
 * @return The asynchronous operation.
 */
openReadAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStreamWithContentType>
}


/**
 * Specifies the type of character encoding for a stream.
 */

declare  var Windows$Storage$Streams$UnicodeEncoding: {|
  +utf8: 0,// 0
+utf16LE: 1,// 1
+utf16BE: 2,// 2

|};



/**
 * Enables a Windows Runtime component to provide access to an encapsulated stream.
 */
declare interface Windows$Storage$Streams$IRandomAccessStreamReference {

/**
 * Opens a stream for random access.
 * @return The asynchronous operation.
 */
openReadAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStreamWithContentType>
} 


/**
 * Supports random access of data in input and output streams for a specified data format.
 */
declare type Windows$Storage$Streams$IRandomAccessStreamWithContentType = {} & Windows$Storage$Streams$IRandomAccessStream & Windows$Foundation$IClosable & Windows$Storage$Streams$IInputStream & Windows$Storage$Streams$IOutputStream & Windows$Storage$Streams$IContentTypeProvider



/**
 * Supports random access of data in input and output streams.
 */
declare type Windows$Storage$Streams$IRandomAccessStream = {

/**
 * Creates a new instance of a IRandomAccessStream over the same resource as the current stream.
 * @return The new stream. The initial, internal position of the stream is 0.
 */
cloneStream(): Windows$Storage$Streams$IRandomAccessStream,

/**
 * Returns an input stream at a specified location in a stream.
 * @param position The location in the stream at which to begin.
 * @return The input stream.
 */
getInputStreamAt(position: number): Windows$Storage$Streams$IInputStream,

/**
 * Returns an output stream at a specified location in a stream.
 * @param position The location in the output stream at which to begin.
 * @return The output stream.
 */
getOutputStreamAt(position: number): Windows$Storage$Streams$IOutputStream,

/**
 * Sets the position of the stream to the specified value.
 * @param position The new position of the stream.
 */
seek(position: number): void,

/**
 * Gets a value that indicates whether the stream can be read from.
 */
canRead: boolean,

/**
 * Gets a value that indicates whether the stream can be written to.
 */
canWrite: boolean,

/**
 * Gets the byte offset of the stream.
 */
position: number,

/**
 * Gets or sets the size of the random access stream.
 */
size: number
} & Windows$Foundation$IClosable & Windows$Storage$Streams$IInputStream & Windows$Storage$Streams$IOutputStream



/**
 * Represents a referenced array of bytes used by byte stream read and write interfaces. Buffer is the class implementation of this interface.
 */
declare interface Windows$Storage$Streams$IBuffer {

/**
 * Gets the maximum number of bytes that the buffer can hold.
 */
capacity: number,

/**
 * Gets the number of bytes currently in use in the buffer.
 */
length: number
} 


/**
 * Represents a sequential stream of bytes to be read.
 */
declare type Windows$Storage$Streams$IInputStream = {

/**
 * Reads data from the stream asynchronously.
 * @param buffer A buffer that may be used to return the bytes that are read. The return value contains the buffer that holds the results.
 * @param count The number of bytes to read that is less than or equal to the Capacity value.
 * @param options Specifies the type of the asynchronous read operation.
 * @return The asynchronous operation.
 */
readAsync(
buffer: Windows$Storage$Streams$IBuffer,
count: number,
options: $Values<typeof Windows$Storage$Streams$InputStreamOptions>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>
} & Windows$Foundation$IClosable



/**
 * Represents a sequential stream of bytes to be written.
 */
declare type Windows$Storage$Streams$IOutputStream = {

/**
 * Flushes data asynchronously in a sequential stream.
 * @return The stream flush operation.
 */
flushAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>,

/**
 * Writes data asynchronously in a sequential stream.
 * @param buffer A buffer that contains the data to be written.
 * @return The byte writer operation.
 */
writeAsync(
buffer: Windows$Storage$Streams$IBuffer): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
} & Windows$Foundation$IClosable



/**
 * Characterizes the format of the data.
 */
declare interface Windows$Storage$Streams$IContentTypeProvider {

/**
 * Gets the format of the data.
 */
contentType: string
} 


/**
 * Enables a Windows Runtime component to provide sequential read access to an encapsulated stream.
 */
declare interface Windows$Storage$Streams$IInputStreamReference {

/**
 * Opens a stream for sequential read access.
 * @return The asynchronous operation.
 */
openSequentialReadAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IInputStream>
} 


/**
 * A helper object that provides indexing names for Windows audio file properties.
 */
declare class Windows$Storage$SystemAudioProperties  {

/**
 * Gets the name of the System.Audio.EncodingBitrate property (one of the Windows audio file properties).
 */
encodingBitrate: string
}


/**
 * A helper object that provides indexing names for GPS file properties.
 */
declare class Windows$Storage$SystemGPSProperties  {

/**
 * Gets the name of the System.GPS.LatitudeDecimal property (one of the GPS file properties).
 */
latitudeDecimal: string;

/**
 * Gets the name of the System.GPS.LongitudeDecimal property (one of the GPS file properties).
 */
longitudeDecimal: string
}


/**
 * A helper object that provides indexing names for Windows image file properties.
 */
declare class Windows$Storage$SystemImageProperties  {

/**
 * Gets the name of the System.Image.HorizontalSize property (one of the Windows image file properties).
 */
horizontalSize: string;

/**
 * Gets the name of the System.Image.VerticalSize property (one of the Windows image file properties).
 */
verticalSize: string
}


/**
 * A helper object that provides indexing names for Windows media file properties.
 */
declare class Windows$Storage$SystemMediaProperties  {

/**
 * Gets the name of the System.Media.Duration property (one of the Windows media file properties).
 */
duration: string;

/**
 * Gets the name of the System.Media.Producer property (one of the Windows media file properties).
 */
producer: string;

/**
 * Gets the name of the System.Media.Publisher property (one of the Windows media file properties).
 */
publisher: string;

/**
 * Gets the name of the System.Media.SubTitle property (one of the Windows media file properties).
 */
subTitle: string;

/**
 * Gets the name of the System.Media.Writer property (one of the Windows media file properties).
 */
writer: string;

/**
 * Gets the name of the System.Media.Year property (one of the Windows media file properties).
 */
year: string
}


/**
 * A helper object that provides indexing names for Windows music file properties.
 */
declare class Windows$Storage$SystemMusicProperties  {

/**
 * Gets the name of the System.Music.AlbumArtist property (one of the Windows music file properties).
 */
albumArtist: string;

/**
 * Gets the name of the System.Music.AlbumTitle property (one of the Windows music file properties).
 */
albumTitle: string;

/**
 * Gets the name of the System.Music.Artist property (one of the Windows music file properties).
 */
artist: string;

/**
 * Gets the name of the System.Music.Composer property (one of the Windows music file properties).
 */
composer: string;

/**
 * Gets the name of the System.Music.Conductor property (one of the Windows music file properties).
 */
conductor: string;

/**
 * Gets the name of the System.Music.DisplayArtist property (one of the Windows music file properties).
 */
displayArtist: string;

/**
 * Gets the name of the System.Music.Genre property (one of the Windows music file properties).
 */
genre: string;

/**
 * Gets the name of the System.Music.TrackNumber property (one of the Windows music file properties).
 */
trackNumber: string
}


/**
 * A helper object that provides indexing names for Windows photo file properties.
 */
declare class Windows$Storage$SystemPhotoProperties  {

/**
 * Gets the name of the System.Photo.CameraManufacturer property (one of the Windows photo file properties).
 */
cameraManufacturer: string;

/**
 * Gets the name of the System.Photo.CameraModel property (one of the Windows photo file properties).
 */
cameraModel: string;

/**
 * Gets the name of the System.Photo.DateTaken property (one of the Windows photo file properties).
 */
dateTaken: string;

/**
 * Gets the name of the System.Photo.Orientation property (one of the Windows photo file properties).
 */
orientation: string;

/**
 * Gets the name of the System.Photo.PeopleNames property (one of the Windows photo file properties).
 */
peopleNames: string
}


/**
 * Provides string values for indexing names of common Windows file properties such as System.Title , and also references helper objects that provide indexing names for properties of specific file types (for example video files).
 */
declare class Windows$Storage$SystemProperties  {

/**
 * Gets an object that provides the indexing names of Windows file properties for System.Audio.
 */
static audio: Windows$Storage$SystemAudioProperties;

/**
 * Gets the name of the System.Author property (one of the Windows file properties).
 */
static author: string;

/**
 * Gets the name of the System.Comment property (one of the Windows file properties).
 */
static comment: string;

/**
 * Gets an object that provides the indexing names of Windows system file properties for System.GPS.
 */
static gps: Windows$Storage$SystemGPSProperties;

/**
 * Gets an object that provides the indexing names of Windows file properties for System.Image.
 */
static image: Windows$Storage$SystemImageProperties;

/**
 * Gets the name of the System.ItemNameDisplay property (one of the Windows file properties).
 */
static itemNameDisplay: string;

/**
 * Gets the name of the System.Keywords property (one of the Windows file properties).
 */
static keywords: string;

/**
 * Gets an object that provides the indexing names of system media file properties such as System.Duration .
 */
static media: Windows$Storage$SystemMediaProperties;

/**
 * Gets an object that provides the indexing names of Windows file properties for System.Music.
 */
static music: Windows$Storage$SystemMusicProperties;

/**
 * Gets an object that provides the indexing names of Windows file properties for System.Photo.
 */
static photo: Windows$Storage$SystemPhotoProperties;

/**
 * Gets the name of the System.Rating property (one of the Windows file properties).
 */
static rating: string;

/**
 * Gets the name of the System.Title property (one of the Windows file properties).
 */
static title: string;

/**
 * Gets an object that provides the indexing names of Windows file properties for System.Video.
 */
static video: Windows$Storage$SystemVideoProperties
}


/**
 * A helper object that provides indexing names for video file properties.
 */
declare class Windows$Storage$SystemVideoProperties  {

/**
 * Gets the name of the System.Video.Director property (one of the Windows video file properties).
 */
director: string;

/**
 * Gets the name of the System.Video.FrameHeight property (one of the Windows video file properties).
 */
frameHeight: string;

/**
 * Gets the name of the System.Video.FrameWidth property (one of the Windows video file properties).
 */
frameWidth: string;

/**
 * Gets the name of the System.Video.Orientation property (one of the Windows video file properties).
 */
orientation: string;

/**
 * Gets the name of the System.Video.TotalBitrate property (one of the Windows video file properties).
 */
totalBitrate: string
}


/**
 * Manipulates storage items (files and folders) and their contents, and provides information about them.
 */
declare interface Windows$Storage$IStorageItem {

/**
 * Deletes the current item, optionally deleting it permanently.
 * @param option A value that indicates whether to delete the item permanently.
 * @return No object or value is returned by this method when it completes.
 */
deleteAsync(
option: $Values<typeof Windows$Storage$StorageDeleteOption>): Windows$Foundation$IPromiseWithIAsyncAction,

/**
 * Deletes the current item.
 * @return No object or value is returned by this method when it completes.
 */
deleteAsync(): Windows$Foundation$IPromiseWithIAsyncAction,

/**
 * Gets the basic properties of the current item (like a file or folder).
 * @return When this method completes successfully, it returns the basic properties of the current item as a BasicProperties object.
 */
getBasicPropertiesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$FileProperties$BasicProperties>,

/**
 * Determines whether the current IStorageItem matches the specified StorageItemTypes value.
 * @param type The value to match against.
 * @return True if the IStorageItem matches the specified value; otherwise false.
 */
isOfType(type: $Values<typeof Windows$Storage$StorageItemTypes>): boolean,

/**
 * Renames the current item. This method also specifies what to do if an existing item in the current item's location has the same name.
 * @param desiredName The desired, new name of the current item.
 * @param option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing item in the current item's location.
 * @return No object or value is returned by this method when it completes.
 */
renameAsync(
desiredName: string,
option: $Values<typeof Windows$Storage$NameCollisionOption>): Windows$Foundation$IPromiseWithIAsyncAction,

/**
 * Renames the current item.
 * @param desiredName The desired, new name of the item.
 * @return No object or value is returned by this method when it completes.
 */
renameAsync(desiredName: string): Windows$Foundation$IPromiseWithIAsyncAction,

/**
 * Gets the attributes of a storage item.
 */
attributes: $Values<typeof Windows$Storage$FileAttributes>,

/**
 * Gets the date and time when the current item was created.
 */
dateCreated: Date,

/**
 * Gets the name of the item including the file name extension if there is one.
 */
name: string,

/**
 * Gets the full file-system path of the item, if the item has a path.
 */
path: string,

/**
 * Gets the parent folder of the current storage item.
 * @return When this method completes, it returns the parent folder as a StorageFolder .
 */
getParentAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>,

/**
 * Indicates whether the current item is the same as the specified item.
 * @param item The IStorageItem object that represents a storage item to compare against.
 * @return Returns true if the current storage item is the same as the specified storage item; otherwise false.
 */
isEqual(item: Windows$Storage$IStorageItem): boolean
} 


/**
 * Represents a file. Provides information about the file and its contents, and ways to manipulate them.
 */
declare type Windows$Storage$IStorageFile = {

/**
 * Replaces the specified file with a copy of the current file.
 * @param fileToReplace The file to replace.
 * @return No object or value is returned when this method completes.
 */
copyAndReplaceAsync(
fileToReplace: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncAction,

/**
 * Creates a copy of the file in the specified folder, using the desired name. This method also specifies what to do if an existing file in the specified folder has the same name.
 * @param destinationFolder The destination folder where the copy is created.
 * @param desiredNewName The desired name of the copy.
 * @param option An enum value that determines how Windows responds if the desiredNewName is the same as the name of an existing file in the destination folder.
 * @return When this method completes, it returns a StorageFile that represents the copy.
 */
copyAsync(
destinationFolder: Windows$Storage$IStorageFolder,
desiredNewName: string,
option: $Values<typeof Windows$Storage$NameCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>,

/**
 * Creates a copy of the file in the specified folder, using the desired name.
 * @param destinationFolder The destination folder where the copy is created.
 * @param desiredNewName The desired name of the copy.
 * @return When this method completes, it returns a StorageFile that represents the copy.
 */
copyAsync(
destinationFolder: Windows$Storage$IStorageFolder,
desiredNewName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>,

/**
 * Creates a copy of the file in the specified folder.
 * @param destinationFolder The destination folder where the copy is created.
 * @return When this method completes, it returns a StorageFile that represents the copy.
 */
copyAsync(
destinationFolder: Windows$Storage$IStorageFolder): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>,

/**
 * Moves the current file to the location of the specified file and replaces the specified file in that location.
 * @param fileToReplace The file to replace.
 * @return No object or value is returned by this method.
 */
moveAndReplaceAsync(
fileToReplace: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncAction,

/**
 * Moves the current file to the specified folder.
 * @param destinationFolder The destination folder where the file is moved.
 * @return No object or value is returned by this method.
 */
moveAsync(
destinationFolder: Windows$Storage$IStorageFolder): Windows$Foundation$IPromiseWithIAsyncAction,

/**
 * Moves the current file to the specified folder and renames the file according to the desired name. This method also specifies what to do if a file with the same name already exists in the specified folder.
 * @param destinationFolder The destination folder where the file is moved.
 * @param desiredNewName The desired name of the file after it is moved.
 * @param option An enum value that determines how Windows responds if the desiredNewName is the same as the name of an existing file in the destination folder.
 * @return No object or value is returned by this method.
 */
moveAsync(
destinationFolder: Windows$Storage$IStorageFolder,
desiredNewName: string,
option: $Values<typeof Windows$Storage$NameCollisionOption>): Windows$Foundation$IPromiseWithIAsyncAction,

/**
 * Moves the current file to the specified folder and renames the file according to the desired name.
 * @param destinationFolder The destination folder where the file is moved.
 * @param desiredNewName The desired name of the file after it is moved.
 * @return No object or value is returned by this method.
 */
moveAsync(
destinationFolder: Windows$Storage$IStorageFolder,
desiredNewName: string): Windows$Foundation$IPromiseWithIAsyncAction,

/**
 * Opens a random-access stream over the file.
 * @param accessMode The type of access to allow.
 * @return When this method completes, it returns the random-access stream (type IRandomAccessStream ).
 */
openAsync(
accessMode: $Values<typeof Windows$Storage$FileAccessMode>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStream>,

/**
 * Opens a random-access stream over the file.
 * @param accessMode One of the enumeration values that specifies the type of access to allow.
 * @param options A bitwise combination of the enumeration values that specify options for opening the stream.
 * @return When this method completes, it returns an IRandomAccessStream that contains the requested random-access stream.
 */
openAsync(
accessMode: $Values<typeof Windows$Storage$FileAccessMode>,
options: $Values<typeof Windows$Storage$StorageOpenOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStream>,

/**
 * Opens a transacted, random-access stream for writing to the file.
 * @return When this method completes, it returns a StorageStreamTransaction that contains the random-access stream and methods that can be used to complete transactions.
 */
openTransactedWriteAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageStreamTransaction>,

/**
 * Opens a random-access stream to the file that can be used for transacted-write operations with the specified options.
 * @param options A bitwise combination of the enumeration values that specify options for opening the stream.
 * @return When this method completes, it returns a StorageStreamTransaction that contains the random-access stream and methods that can be used to complete transactions.
 */
openTransactedWriteAsync(
options: $Values<typeof Windows$Storage$StorageOpenOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageStreamTransaction>,

/**
 * Gets the MIME type of the contents of the file.
 */
contentType: string,

/**
 * Gets the type (file name extension) of the file.
 */
fileType: string
} & Windows$Storage$IStorageItem & Windows$Storage$Streams$IRandomAccessStreamReference & Windows$Storage$Streams$IInputStreamReference



/**
 * Manipulates folders and their contents, and provides information about them.
 */
declare type Windows$Storage$IStorageFolder = {

/**
 * Creates a new file in the current folder, and specifies what to do if a file with the same name already exists in the current folder.
 * @param desiredName The desired name of the file to create.
 * @param options The enum value that determines how Windows responds if the desiredName is the same as the name of an existing file in the current folder.
 * @return When this method completes, it returns the new file as a StorageFile .
 */
createFileAsync(
desiredName: string,
options: $Values<typeof Windows$Storage$CreationCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>,

/**
 * Creates a new file in the current folder.
 * @param desiredName The desired name of the file to create.
 * @return When this method completes, it returns the new file as a StorageFile .
 */
createFileAsync(
desiredName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>,

/**
 * Creates a new folder in the current folder.
 * @param desiredName The desired name of the folder to create.
 * @return When this method completes, it returns the new folder as a StorageFolder .
 */
createFolderAsync(
desiredName: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>,

/**
 * Creates a new folder in the current folder, and specifies what to do if a folder with the same name already exists in the current folder.
 * @param desiredName The desired name of the folder to create.
 * @param options The enum value that determines how Windows responds if the desiredName is the same as the name of an existing folder in the current folder.
 * @return When this method completes, it returns the new folder as a StorageFolder .
 */
createFolderAsync(
desiredName: string,
options: $Values<typeof Windows$Storage$CreationCollisionOption>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>,

/**
 * Gets the specified file from the current folder.
 * @param name The name (or path relative to the current folder) of the file to retrieve.
 * @return When this method completes successfully, it returns a StorageFile that represents the file.
 */
getFileAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFile>,

/**
 * Gets the files from the current folder.
 * @return When this method completes successfully, it returns a list of the files (type IVectorView ) in the folder. Each file in the list is represented by a StorageFile object.
 */
getFilesAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>,

/**
 * Gets the specified folder from the current folder.
 * @param name The name of the child folder to retrieve.
 * @return When this method completes successfully, it returns a StorageFolder that represents the child folder.
 */
getFolderAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$StorageFolder>,

/**
 * Gets the folders in the current folder.
 * @return When this method completes successfully, it returns a list of the files (type IVectorView ). Each folder in the list is represented by a StorageFolder .
 */
getFoldersAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>,

/**
 * Gets the specified item from the IStorageFolder .
 * @param name The name of the item to retrieve.
 * @return When this method completes successfully, it returns the file or folder (type IStorageItem ).
 */
getItemAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$IStorageItem>,

/**
 * Gets the items from the current folder.
 * @return When this method completes successfully, it returns a list of the files and folders (type IVectorView ). The files and folders in the list are represented by objects of type IStorageItem .
 */
getItemsAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>,

/**
 * Try to get a single file or sub-folder from the current folder by using the name of the item.
 * @param name The name (or path relative to the current folder) of the file or sub-folder to try to retrieve.
 * @return When this method completes successfully, it returns the file or folder (type IStorageItem ).
 */
tryGetItemAsync(
name: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$IStorageItem>
} & Windows$Storage$IStorageItem



/**
 * Represents a method that handles the request to set the version of the application data in the application data store.
 */
declare type Windows$Storage$ApplicationDataSetVersionHandler = (setVersionRequest: Windows$Storage$SetVersionRequest) => void;


/**
 * Represents the method that will stream data into a StorageFile when that file is first accessed.
 */
declare type Windows$Storage$StreamedFileDataRequestedHandler = (stream: Windows$Storage$StreamedFileDataRequest) => void;


      declare var npm$namespace$Windows$System: {
        
        
        AppMemoryUsageLevel: typeof Windows$System$AppMemoryUsageLevel,
LaunchQuerySupportStatus: typeof Windows$System$LaunchQuerySupportStatus,
LaunchQuerySupportType: typeof Windows$System$LaunchQuerySupportType,
LaunchUriStatus: typeof Windows$System$LaunchUriStatus,
ProcessorArchitecture: typeof Windows$System$ProcessorArchitecture,
UserAuthenticationStatus: typeof Windows$System$UserAuthenticationStatus,
UserPictureSize: typeof Windows$System$UserPictureSize,
UserType: typeof Windows$System$UserType,
UserWatcherStatus: typeof Windows$System$UserWatcherStatus,
VirtualKey: typeof Windows$System$VirtualKey,
VirtualKeyModifiers: typeof Windows$System$VirtualKeyModifiers,
        AppMemoryReport: typeof Windows$System$AppMemoryReport,
AppMemoryUsageLimitChangingEventArgs: typeof Windows$System$AppMemoryUsageLimitChangingEventArgs,
FolderLauncherOptions: typeof Windows$System$FolderLauncherOptions,
KnownUserProperties: typeof Windows$System$KnownUserProperties,
LaunchUriResult: typeof Windows$System$LaunchUriResult,
Launcher: typeof Windows$System$Launcher,
LauncherOptions: typeof Windows$System$LauncherOptions,
LauncherUIOptions: typeof Windows$System$LauncherUIOptions,
MemoryManager: typeof Windows$System$MemoryManager,
ProcessLauncher: typeof Windows$System$ProcessLauncher,
ProcessLauncherOptions: typeof Windows$System$ProcessLauncherOptions,
ProcessLauncherResult: typeof Windows$System$ProcessLauncherResult,
ProcessMemoryReport: typeof Windows$System$ProcessMemoryReport,
ProtocolForResultsOperation: typeof Windows$System$ProtocolForResultsOperation,
ShutdownManager: typeof Windows$System$ShutdownManager,
TimeZoneSettings: typeof Windows$System$TimeZoneSettings,
User: typeof Windows$System$User,
UserAuthenticationStatusChangeDeferral: typeof Windows$System$UserAuthenticationStatusChangeDeferral,
UserAuthenticationStatusChangingEventArgs: typeof Windows$System$UserAuthenticationStatusChangingEventArgs,
UserChangedEventArgs: typeof Windows$System$UserChangedEventArgs,
UserWatcher: typeof Windows$System$UserWatcher,
        Diagnostics: typeof npm$namespace$Windows$System$Diagnostics,
Display: typeof npm$namespace$Windows$System$Display,
Power: typeof npm$namespace$Windows$System$Power,
Profile: typeof npm$namespace$Windows$System$Profile,
RemoteDesktop: typeof npm$namespace$Windows$System$RemoteDesktop,
ShutdownKind: typeof npm$namespace$Windows$System$ShutdownKind,
Threading: typeof npm$namespace$Windows$System$Threading,
UserProfile: typeof npm$namespace$Windows$System$UserProfile,
      }

/**
 * Represents app memory usage at a single point in time.
 */
declare class Windows$System$AppMemoryReport  {

/**
 * Gets the app's peak usage of private commit.
 */
peakPrivateCommitUsage: number;

/**
 * Gets the app's usage of private commit.
 */
privateCommitUsage: number;

/**
 * Gets the app's total cap for private plus shared commit.
 */
totalCommitLimit: number;

/**
 * Gets the app's total usage of private plus shared commit.
 */
totalCommitUsage: number
}


/**
 * An enumeration containing 3 levels of app memory usage: low, medium, and high.
 */

declare  var Windows$System$AppMemoryUsageLevel: {|
  +low: 0,// 0
+medium: 1,// 1
+high: 2,// 2

|};



/**
 * Provides data for the AppMemoryUsageLimitChanging event.
 */
declare class Windows$System$AppMemoryUsageLimitChangingEventArgs  {

/**
 * Gets the new limit for how much total memory the app can use, in bytes.
 */
newLimit: number;

/**
 * Gets the old limit for how much total memory the app can use, in bytes.
 */
oldLimit: number
}


      declare var npm$namespace$Windows$System$Diagnostics: {
        
        
        
        ProcessCpuUsage: typeof Windows$System$Diagnostics$ProcessCpuUsage,
ProcessCpuUsageReport: typeof Windows$System$Diagnostics$ProcessCpuUsageReport,
ProcessDiagnosticInfo: typeof Windows$System$Diagnostics$ProcessDiagnosticInfo,
ProcessDiskUsage: typeof Windows$System$Diagnostics$ProcessDiskUsage,
ProcessDiskUsageReport: typeof Windows$System$Diagnostics$ProcessDiskUsageReport,
ProcessMemoryUsage: typeof Windows$System$Diagnostics$ProcessMemoryUsage,
ProcessMemoryUsageReport: typeof Windows$System$Diagnostics$ProcessMemoryUsageReport,
        
      }

/**
 * Provides access to data about the CPU usage of a process.
 */
declare class Windows$System$Diagnostics$ProcessCpuUsage  {

/**
 * Gets the ProcessCpuUsageReport for the process.
 * @return The CPU usage report for the process.
 */
getReport(): Windows$System$Diagnostics$ProcessCpuUsageReport
}


/**
 * Provides data about the CPU usage of the process.
 */
declare class Windows$System$Diagnostics$ProcessCpuUsageReport  {

/**
 * Gets the amount of CPU kernel time consumed by the process.
 */
kernelTime: number;

/**
 * Gets the amount of CPU user time consumed by the process.
 */
userTime: number
}


/**
 * Provides diagnostic information about a process, such as CPU usage, disk usage, memory usage and so on.
 */
declare class Windows$System$Diagnostics$ProcessDiagnosticInfo  {

/**
 * Gets the ProcessDiagnosticInfo for the currently running process.
 * @return The ProcessDiagnosticInfo for the currently running process.
 */
static getForCurrentProcess(): Windows$System$Diagnostics$ProcessDiagnosticInfo;

/**
 * Gets a list of ProcessDiagnosticInfo objects for all running processes.
 * @return A list of ProcessDiagnosticInfo objects for all running processes.
 */
static getForProcesses(
): Windows$Foundation$Collections$IVectorView<Windows$System$Diagnostics$ProcessDiagnosticInfo>;

/**
 * Gets the CPU time used by the process.
 */
cpuUsage: Windows$System$Diagnostics$ProcessCpuUsage;

/**
 * Gets the disk I/O usage of the process.
 */
diskUsage: Windows$System$Diagnostics$ProcessDiskUsage;

/**
 * Gets the name of the executable file for the process.
 */
executableFileName: string;

/**
 * Get memory usage data for the process.
 */
memoryUsage: Windows$System$Diagnostics$ProcessMemoryUsage;

/**
 * Gets the ProcessDiagnosticInfo for the parent process.
 */
parent: Windows$System$Diagnostics$ProcessDiagnosticInfo;

/**
 * Gets the unique process ID.
 */
processId: number;

/**
 * Gets the time the process was started.
 */
processStartTime: Date
}


/**
 * Provides access to data about the disk usage of a process.
 */
declare class Windows$System$Diagnostics$ProcessDiskUsage  {

/**
 * Gets the ProcessDiskUsageReport for the process.
 * @return The ProcessDiskUsageReport for the process.
 */
getReport(): Windows$System$Diagnostics$ProcessDiskUsageReport
}


/**
 * Provides data about the disk usage of the process.
 */
declare class Windows$System$Diagnostics$ProcessDiskUsageReport  {

/**
 * Gets the number of bytes the process has read from disk.
 */
bytesReadCount: number;

/**
 * Gets the number of bytes the process has written to disk.
 */
bytesWrittenCount: number;

/**
 * Gets the number of bytes used by the process in disk operations that were not read or write operations.
 */
otherBytesCount: number;

/**
 * Gets the number of disk operations performed by the process that were not read or write operations.
 */
otherOperationCount: number;

/**
 * Gets the number of disk read operations performed by the process.
 */
readOperationCount: number;

/**
 * Gets the number of disk write operations performed by the process.
 */
writeOperationCount: number
}


/**
 * Provides access to data about the memory usage of a process.
 */
declare class Windows$System$Diagnostics$ProcessMemoryUsage  {

/**
 * Gets the ProcessMemoryUsageReport for the process.
 * @return The ProcessMemoryUsageReport for the process.
 */
getReport(): Windows$System$Diagnostics$ProcessMemoryUsageReport
}


/**
 * Provides data about the memory usage of the process.
 */
declare class Windows$System$Diagnostics$ProcessMemoryUsageReport  {

/**
 * Gets the amount of non-paged memory available to the process, in bytes.
 */
nonPagedPoolSizeInBytes: number;

/**
 * Gets the number of memory page faults.
 */
pageFaultCount: number;

/**
 * Gets the size of the memory page file in bytes.
 */
pageFileSizeInBytes: number;

/**
 * Gets the amount of paged memory available to the process, in bytes.
 */
pagedPoolSizeInBytes: number;

/**
 * Gets the maximum amount of non-paged memory used by the process, in bytes.
 */
peakNonPagedPoolSizeInBytes: number;

/**
 * Gets the maximum size of the memory page file used by the process, in bytes.
 */
peakPageFileSizeInBytes: number;

/**
 * Gets the maximum amount of paged memory used by the process, in bytes.
 */
peakPagedPoolSizeInBytes: number;

/**
 * Gets the maximum amount of virtual memory used by the associated process.
 */
peakVirtualMemorySizeInBytes: number;

/**
 * Gets the maximum amount of physical memory used by the associated process.
 */
peakWorkingSetSizeInBytes: number;

/**
 * Gets the number of private memory pages allocated for the associated process.
 */
privatePageCount: number;

/**
 * Gets the amount of the virtual memory allocated for the associated process.
 */
virtualMemorySizeInBytes: number;

/**
 * Gets the amount of physical memory allocated for the associated process.
 */
workingSetSizeInBytes: number
}


      declare var npm$namespace$Windows$System$Display: {
        
        
        
        DisplayRequest: typeof Windows$System$Display$DisplayRequest,
        
      }

/**
 * Represents a display request.
 */
declare class Windows$System$Display$DisplayRequest  {

/**
 * Creates an instance of the DisplayRequest class.
 */
constructor(): this;

/**
 * Activates a display request.
 */
requestActive(): void;

/**
 * Deactivates a display request.
 */
requestRelease(): void
}


/**
 * Specifies the options to use when launching File Explorer to display the contents of a specific folder by calling the LaunchFolderAsync(IStorageFolder, FolderLauncherOptions) method.
 */
declare class Windows$System$FolderLauncherOptions  {

/**
 * Initializes a new instance of the FolderLauncherOptions class.
 */
constructor(): this;

/**
 * Specifies how much space on the screen to leave for the calling app when launching File Explorer. The calling app can take up more or less space than File Explorer, or File Explorer can fill the entire screen.
 */
desiredRemainingView: $Values<typeof Windows$UI$ViewManagement$ViewSizePreference>;

/**
 * Provides the list of items to select when File Explorer displays the contents of the specified folder.
 */
itemsToSelect: Windows$Foundation$Collections$IVector<Windows$Storage$IStorageItem>
}


/**
 * Contains basic information about a user.
 */
declare class Windows$System$KnownUserProperties  {

/**
 * Gets the user's account name.
 */
static accountName: string;

/**
 * Gets the user's display name.
 */
static displayName: string;

/**
 * Gets the user's domain name.
 */
static domainName: string;

/**
 * Gets the user's first name.
 */
static firstName: string;

/**
 * Gets the user's guest host.
 */
static guestHost: string;

/**
 * Gets the user's last name.
 */
static lastName: string;

/**
 * Gets the user's principal name.
 */
static principalName: string;

/**
 * Gets the user's provider name.
 */
static providerName: string;

/**
 * Gets the user's session initiation protocol Uri.
 */
static sessionInitiationProtocolUri: string
}


/**
 * Specifies whether an app is available that supports activation.
 */

declare  var Windows$System$LaunchQuerySupportStatus: {|
  +available: 0,// 0
+appNotInstalled: 1,// 1
+appUnavailable: 2,// 2
+notSupported: 3,// 3
+unknown: 4,// 4

|};



/**
 * Specifies the type of activation to query for.
 */

declare  var Windows$System$LaunchQuerySupportType: {|
  +uri: 0,// 0
+uriForResults: 1,// 1

|};



/**
 * Represents the results of a Uri launch.
 */
declare class Windows$System$LaunchUriResult  {

/**
 * Gets the result of the Uri launch.
 */
result: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the status of the Uri launch.
 */
status: $Values<typeof Windows$System$LaunchUriStatus>
}


/**
 * Specifies the result of activating an application.
 */

declare  var Windows$System$LaunchUriStatus: {|
  +success: 0,// 0
+appUnavailable: 1,// 1
+protocolUnavailable: 2,// 2
+unknown: 3,// 3

|};



/**
 * Starts the default app associated with the specified file or URI.
 */
declare class Windows$System$Launcher  {

/**
 * Enumerate the file handlers on the device.
 * @param extension The file extension that you want to find handlers for. For example, ".bat". Include the leading period '.'.
 * @return A list of AppInfo s for each application that handles the specified file extension.
 */
static findFileHandlersAsync(
extension: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$AppInfo>>;

/**
 * Enumerates the
 * @param scheme The scheme name that you find to find handlers for. For example, "ms-lens".
 * @return A list of AppInfo s for each application that handles the specified scheme.
 */
static findUriSchemeHandlersAsync(
scheme: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$AppInfo>>;

/**
 * Enumerate the scheme handlers on the device.
 * @param scheme The scheme name that you find to find handlers for. For example, "ms-lens".
 * @param launchQuerySupportType Filter the list of handlers by whether they can be launched for results or not.
 * @return A list of AppInfo s for each application that handles the specified scheme.
 */
static findUriSchemeHandlersAsync(
scheme: string,
launchQuerySupportType: $Values<typeof Windows$System$LaunchQuerySupportType>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<Windows$ApplicationModel$AppInfo>>;

/**
 * Starts the default app associated with the specified file.
 * @param file The file.
 * @return The launch operation.
 */
static launchFileAsync(
file: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Starts the default app associated with the specified file, using the specified options.
 * @param file The file.
 * @param options The launch options for the app.
 * @return The launch operation.
 */
static launchFileAsync(
file: Windows$Storage$IStorageFile,
options: Windows$System$LauncherOptions): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Launches File Explorer with the specified options and displays the contents of the specified folder.
 * @param folder The folder to display in File Explorer.
 * @param options Options that specify the amount of screen space that File Explorer fills, and the list of items to select in the specified folder.
 * @return The result of the operation.
 */
static launchFolderAsync(
folder: Windows$Storage$IStorageFolder,
options: Windows$System$FolderLauncherOptions): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Launches File Explorer and displays the contents of the specified folder.
 * @param folder The folder to display in File Explorer.
 * @return The result of the operation.
 */
static launchFolderAsync(
folder: Windows$Storage$IStorageFolder): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Starts the default app associated with the URI scheme name for the specified URI.
 * @param uri The URI.
 * @return The launch operation.
 */
static launchUriAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Starts the default app associated with the URI scheme name or the one specified by the ContentType for the specified URI, using the specified options.
 * @param uri The URI.
 * @param options The launch options for the app.
 * @return The launch operation.
 */
static launchUriAsync(
uri: Windows$Foundation$Uri,
options: Windows$System$LauncherOptions): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Starts the default app associated with the URI scheme name for the specified URI, using the specified options and input data.
 * @param uri The URI.
 * @param options The launch options for the app.
 * @param inputData The input data for the app.
 * @return The launch operation.
 */
static launchUriAsync(
uri: Windows$Foundation$Uri,
options: Windows$System$LauncherOptions,
inputData: Windows$Foundation$Collections$ValueSet): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously starts the default app associated with the URI scheme name for the specified URI, using the specified options and input data.
 * @param uri The Uri to launch.
 * @param options The launch options.
 * @param inputData The data to send to the launched app.
 * @return When this method completes, it returns the results of the launch.
 */
static launchUriForResultsAsync(
uri: Windows$Foundation$Uri,
options: Windows$System$LauncherOptions,
inputData: Windows$Foundation$Collections$ValueSet): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$System$LaunchUriResult>;

/**
 * Asynchronously starts the default app associated with the URI scheme name for the specified URI, using the specified options.
 * @param uri The Uri to launch.
 * @param options The launch options.
 * @return When this method completes, it returns the results of the launch.
 */
static launchUriForResultsAsync(
uri: Windows$Foundation$Uri,
options: Windows$System$LauncherOptions): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$System$LaunchUriResult>;

/**
 * Asynchronously query whether an app can be activated for the specified file.
 * @param file The file for which to query support.
 * @return A value that indicates whether an application can be activated for the file.
 */
static queryFileSupportAsync(
file: Windows$Storage$StorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$System$LaunchQuerySupportStatus>>;

/**
 * Asynchronously query whether an app with the specified package name can be activated for the specified file.
 * @param file The file for which to query support.
 * @param packageFamilyName The package for which to query support.
 * @return A value that indicates whether an application can be activated for the file.
 */
static queryFileSupportAsync(
file: Windows$Storage$StorageFile,
packageFamilyName: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$System$LaunchQuerySupportStatus>>;

/**
 * Asynchronously query whether an app can be activated for the specified URI, launch type, and package name.
 * @param uri The URI for which to query support.
 * @param launchQuerySupportType The type of launch for which to query support.
 * @param packageFamilyName Specifies a specific package that will be used to launch this URI.
 * @return A value that indicates whether the application is available to launch the URI.
 */
static queryUriSupportAsync(
uri: Windows$Foundation$Uri,
launchQuerySupportType: $Values<typeof Windows$System$LaunchQuerySupportType>,
packageFamilyName: string): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$System$LaunchQuerySupportStatus>>;

/**
 * Asynchronously query whether an app can be activated for the specified URI and launch type.
 * @param uri The URI for which to query support.
 * @param launchQuerySupportType The type of launch for which to query support.
 * @return A value that indicates whether an application is available to launch the URI.
 */
static queryUriSupportAsync(
uri: Windows$Foundation$Uri,
launchQuerySupportType: $Values<typeof Windows$System$LaunchQuerySupportType>): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$System$LaunchQuerySupportStatus>>
}


/**
 * Specifies the options used to launch the default app for a file or URI.
 */
declare class Windows$System$LauncherOptions  {

/**
 * Creates and initializes a new instance of the launcher options object.
 */
constructor(): this;

/**
 * Gets or sets the content type that is associated with a URI that represents a file on the network.
 */
contentType: string;

/**
 * Launch a target app and have the currently running source app remain on the screen by sharing the space equally with the target app or by taking up more or less space than the target app.
 */
desiredRemainingView: $Values<typeof Windows$UI$ViewManagement$ViewSizePreference>;

/**
 * Gets or sets a value that indicates whether to display the Open With dialog whenever the association launching API is called.
 */
displayApplicationPicker: boolean;

/**
 * Gets or sets a value that represents a URI that the user should be taken to in the browser if no app exists to handle the file type or URI.
 */
fallbackUri: Windows$Foundation$Uri;

/**
 * Enables an app to access files that are related to the file used to activate the app.
 */
neighboringFilesQuery: Windows$Storage$Search$StorageFileQueryResult;

/**
 * Gets or sets a value that represents the display name of the app in the store that the user should install if no app exists to handle the file type or URI.
 */
preferredApplicationDisplayName: string;

/**
 * Gets or sets a value that represents the package family name of the app in the Store that the user should install if no app exists to handle the file type or URI.
 */
preferredApplicationPackageFamilyName: string;

/**
 * The package family name of the target package that should be used to launch a file or URI. This property is optional.
 */
targetApplicationPackageFamilyName: string;

/**
 * Gets or sets a value that indicates whether the system should display a warning that the file or URI is potentially unsafe when starting the app associated with a file or URI.
 */
treatAsUntrusted: boolean;

/**
 * Gets the user interface (UI) options when starting a default app.
 */
ui: Windows$System$LauncherUIOptions
}


/**
 * Specifies options for user interface elements such as the application picker that can be invoked by this API.
 */
declare class Windows$System$LauncherUIOptions  {

/**
 * Gets or sets the point on the screen where the user opened a file or URI.
 */
invocationPoint: Windows$Foundation$Point;

/**
 * Gets or sets the preferred placement of the Open With and Warning dialog boxes when starting a default app.
 */
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>;

/**
 * Gets or sets the selection rectangle on the screen where the user opened a file or URI.
 */
selectionRect: Windows$Foundation$Rect
}


/**
 * Provides access to information on an app's memory usage.
 */
declare class Windows$System$MemoryManager  {

/**
 * Gets the app's current memory usage.
 */
static appMemoryUsage: number;

/**
 * Gets the app's memory usage level.
 */
static appMemoryUsageLevel: $Values<typeof Windows$System$AppMemoryUsageLevel>;

/**
 * Gets the app's memory usage limit.
 */
static appMemoryUsageLimit: number;

/**
 * Gets an AppMemoryReport for the app, which provides information about its memory usage.
 * @return Information about the process' memory usage.
 */
static getAppMemoryReport(): Windows$System$AppMemoryReport;

/**
 * Gets a ProcessMemoryReport for a process, which provides information about its memory usage.
 * @return Information about the process' memory usage.
 */
static getProcessMemoryReport(): Windows$System$ProcessMemoryReport;

/**
 * Raised when the app's memory consumption has decreased to a lower value in the AppMemoryUsageLevel enumeration.
 */
static onappmemoryusagedecreased: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "appmemoryusagedecreased",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "appmemoryusagedecreased",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Raised when the app's memory consumption has increased to a higher value in the AppMemoryUsageLevel enumeration.
 */
static onappmemoryusageincreased: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "appmemoryusageincreased",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "appmemoryusageincreased",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Raised just before the limit of how much total memory the app can use is changed.
 */
static onappmemoryusagelimitchanging: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "appmemoryusagelimitchanging",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "appmemoryusagelimitchanging",
listener: Windows$Foundation$EventHandler<any>): void;
static trySetAppMemoryUsageLimit: any;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


      declare var npm$namespace$Windows$System$Power: {
        
        
        BatteryStatus: typeof Windows$System$Power$BatteryStatus,
EnergySaverStatus: typeof Windows$System$Power$EnergySaverStatus,
PowerSupplyStatus: typeof Windows$System$Power$PowerSupplyStatus,
        BackgroundEnergyManager: typeof Windows$System$Power$BackgroundEnergyManager,
ForegroundEnergyManager: typeof Windows$System$Power$ForegroundEnergyManager,
PowerManager: typeof Windows$System$Power$PowerManager,
        Diagnostics: typeof npm$namespace$Windows$System$Power$Diagnostics,
      }

/**
 * Provides information about your app's background energy usage.
 */
declare class Windows$System$Power$BackgroundEnergyManager  {

/**
 * Gets the excessive usage level, expressed as a percentage of normal energy usage.
 */
static excessiveUsageLevel: number;

/**
 * Gets the low usage level, expressed as a percentage of normal energy consumption.
 */
static lowUsageLevel: number;

/**
 * Gets the maximum acceptable usage level, expressed as a percentage of normal energy consumption.
 */
static maxAcceptableUsageLevel: number;

/**
 * Gets the near-maximum acceptable usage level, expressed as a percentage of normal energy usage.
 */
static nearMaxAcceptableUsageLevel: number;

/**
 * Gets the near-termination usage level, expressed as a percentage of normal energy usage.
 */
static nearTerminationUsageLevel: number;

/**
 * Occurs when the background task's energy usage has increased significantly.
 */
static onrecentenergyusageincreased: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "recentenergyusageincreased",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "recentenergyusageincreased",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Occurs when the background task's energy usage has decreased to a low usage level.
 */
static onrecentenergyusagereturnedtolow: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "recentenergyusagereturnedtolow",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "recentenergyusagereturnedtolow",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Gets the energy usage of the app's background task for the current 30 minute period, expressed as a percentage of normal.
 */
static recentEnergyUsage: number;

/**
 * Gets the nearest predefined energy level of the app's background task for the current 30 minute period, equal to LowUsageLevel , NearMaxAcceptableUsageLevel , MaxAcceptableUsageLevel , ExcessiveUsageLevel , NearTerminationUsageLevel , or TerminationUsageLevel .
 */
static recentEnergyUsageLevel: number;

/**
 * Gets the termination usage level, expressed as a percentage of normal energy usage.
 */
static terminationUsageLevel: number;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Indicates the status of the battery.
 */

declare  var Windows$System$Power$BatteryStatus: {|
  +notPresent: 0,// 0
+discharging: 1,// 1
+idle: 2,// 2
+charging: 3,// 3

|};



      declare var npm$namespace$Windows$System$Power$Diagnostics: {
        
        
        
        BackgroundEnergyDiagnostics: typeof Windows$System$Power$Diagnostics$BackgroundEnergyDiagnostics,
ForegroundEnergyDiagnostics: typeof Windows$System$Power$Diagnostics$ForegroundEnergyDiagnostics,
        
      }

/**
 * Provides debugging APIs for calculating your app's background energy usage in real time. We recommend using these APIs only for debugging.
 */
declare class Windows$System$Power$Diagnostics$BackgroundEnergyDiagnostics  {

/**
 * Computes the total cumulative energy usage of the background task since the last reset, expressed as a percentage of normal.
 * @return The total cumulative energy usage of the background task since the last reset, expressed as a percentage of normal.
 */
static computeTotalEnergyUsage(): number;

/**
 * Gets the device-specific conversion factor used to convert energy usage (mW) to a normalized percentage.
 */
static deviceSpecificConversionFactor: number;

/**
 * Clears the value that represents the total cumulative energy usage of the background task since the last reset.
 */
static resetTotalEnergyUsage(): void
}


/**
 * Provides debugging APIs for calculating your app's foreground energy usage in real time. We recommend using these APIs only for debugging.
 */
declare class Windows$System$Power$Diagnostics$ForegroundEnergyDiagnostics  {

/**
 * Computes the total cumulative energy usage of the foreground app since the last reset, expressed as a percentage of normal.
 * @return The total cumulative energy usage of the foreground app since the last reset, expressed as a percentage of normal.
 */
static computeTotalEnergyUsage(): number;

/**
 * Gets the device-specific conversion factor used to convert energy usage (mW) to a normalized percentage.
 */
static deviceSpecificConversionFactor: number;

/**
 * Clears the value that represents the total cumulative energy usage of the foreground app since the last reset.
 */
static resetTotalEnergyUsage(): void
}


/**
 * Specifies the status of battery saver.
 */

declare  var Windows$System$Power$EnergySaverStatus: {|
  +disabled: 0,// 0
+off: 1,// 1
+on: 2,// 2

|};



/**
 * Provides information about your app's foreground energy usage.
 */
declare class Windows$System$Power$ForegroundEnergyManager  {

/**
 * Gets the excessive usage level, expressed as a percentage of normal energy usage.
 */
static excessiveUsageLevel: number;

/**
 * Gets the low usage level, expressed as a percentage of normal energy consumption.
 */
static lowUsageLevel: number;

/**
 * Gets the maximum acceptable usage level, expressed as a percentage of normal energy consumption.
 */
static maxAcceptableUsageLevel: number;

/**
 * Gets the near-maximum acceptable usage level, expressed as a percentage of normal energy usage.
 */
static nearMaxAcceptableUsageLevel: number;

/**
 * Occurs when the app's foreground energy usage has increased significantly.
 */
static onrecentenergyusageincreased: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "recentenergyusageincreased",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "recentenergyusageincreased",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Occurs when the app's energy usage has decreased to a low usage level.
 */
static onrecentenergyusagereturnedtolow: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "recentenergyusagereturnedtolow",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "recentenergyusagereturnedtolow",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Gets the nearest predefined energy level of the foreground app for the current 30 minute period, equal to LowUsageLevel , NearMaxAcceptableUsageLevel , MaxAcceptableUsageLevel , or ExcessiveUsageLevel .
 */
static recentEnergyUsage: number;

/**
 * Gets the nearest predefined energy level of the foreground app for the current 30 minute period, equal to LowUsageLevel , NearMaxAcceptableUsageLevel , MaxAcceptableUsageLevel , or ExcessiveUsageLevel .
 */
static recentEnergyUsageLevel: number;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides access to information about a device's battery and power supply status.
 */
declare class Windows$System$Power$PowerManager  {

/**
 * Gets the device's battery status.
 */
static batteryStatus: $Values<typeof Windows$System$Power$BatteryStatus>;

/**
 * Gets battery saver status, indicating when to save energy.
 */
static energySaverStatus: $Values<typeof Windows$System$Power$EnergySaverStatus>;

/**
 * Occurs when BatteryStatus changes.
 */
static onbatterystatuschanged: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "batterystatuschanged",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "batterystatuschanged",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Occurs when EnergySaverStatus changes.
 */
static onenergysaverstatuschanged: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "energysaverstatuschanged",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "energysaverstatuschanged",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Occurs when the PowerSupplyStatus changes.
 */
static onpowersupplystatuschanged: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "powersupplystatuschanged",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "powersupplystatuschanged",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Occurs when RemainingChargePercent changes.
 */
static onremainingchargepercentchanged: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "remainingchargepercentchanged",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "remainingchargepercentchanged",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Occurs when RemainingDischargeTime changes.
 */
static onremainingdischargetimechanged: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "remainingdischargetimechanged",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "remainingdischargetimechanged",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Gets the device's power supply status.
 */
static powerSupplyStatus: $Values<typeof Windows$System$Power$PowerSupplyStatus>;

/**
 * Gets the total percentage of charge remaining from all batteries connected to the device.
 */
static remainingChargePercent: number;

/**
 * Gets the total runtime remaining from all batteries connected to the device.
 */
static remainingDischargeTime: number;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the device's power supply status.
 */

declare  var Windows$System$Power$PowerSupplyStatus: {|
  +notPresent: 0,// 0
+inadequate: 1,// 1
+adequate: 2,// 2

|};


declare class Windows$System$ProcessLauncher  {
static runToCompletionAsync: any
}

declare class Windows$System$ProcessLauncherOptions  {
standardError: any;
standardInput: any;
standardOutput: any;
workingDirectory: any
}

declare class Windows$System$ProcessLauncherResult  {
exitCode: any
}


/**
 * Represents process memory usage at a single point in time.
 */
declare class Windows$System$ProcessMemoryReport  {

/**
 * Gets the process' private working set usage.
 */
privateWorkingSetUsage: number;

/**
 * Gets the process' total working set usage.
 */
totalWorkingSetUsage: number
}


/**
 * Specifies the processor architecture supported by an app.
 */

declare  var Windows$System$ProcessorArchitecture: {|
  +x86: 0,// 0
+arm: 1,// 1
+x64: 2,// 2
+neutral: 3,// 3
+unknown: 4,// 4

|};



      declare var npm$namespace$Windows$System$Profile: {
        
        
        
        AnalyticsInfo: typeof Windows$System$Profile$AnalyticsInfo,
AnalyticsVersionInfo: typeof Windows$System$Profile$AnalyticsVersionInfo,
HardwareIdentification: typeof Windows$System$Profile$HardwareIdentification,
HardwareToken: typeof Windows$System$Profile$HardwareToken,
KnownRetailInfoProperties: typeof Windows$System$Profile$KnownRetailInfoProperties,
PlatformDiagnosticsAndUsageDataSettings: typeof Windows$System$Profile$PlatformDiagnosticsAndUsageDataSettings,
RetailInfo: typeof Windows$System$Profile$RetailInfo,
        PlatformDataCollectionLevel: typeof npm$namespace$Windows$System$Profile$PlatformDataCollectionLevel,
SystemManufacturers: typeof npm$namespace$Windows$System$Profile$SystemManufacturers,
      }

/**
 * Provides information about the device for profiling purposes.
 */
declare class Windows$System$Profile$AnalyticsInfo  {

/**
 * Gets the device form.
 */
static deviceForm: string;

/**
 * Gets version info about the device family.
 */
static versionInfo: Windows$System$Profile$AnalyticsVersionInfo
}


/**
 * Provides version information about the device family.
 */
declare class Windows$System$Profile$AnalyticsVersionInfo  {

/**
 * Gets the device family.
 */
deviceFamily: string;

/**
 * Gets the version within the device family.
 */
deviceFamilyVersion: string
}


/**
 * Provides the ability to obtain a hardware identifier that represents the current hardware.
 */
declare class Windows$System$Profile$HardwareIdentification  {

/**
 * Gets a hardware identifier ( ASHWID) that represents the current hardware. The returned ASHWID will be different for each application package. In other words, this API will return different identifiers when called by two apps from different packages. It will return the same identifier when called by two apps that are part of the same package.
 * @param nonce The cryptographic nonce is optional. The nonce is recommended when ASHWID needs to be verified on the cloud against replay attacks. In the scenarios where nonce is desired, the remote server should generate a random nonce and pass it to the client app, and then verify that the signature has the expected nonce once the ASHWID is received from the client system.
 * @return The hardware Id information.
 */
static getPackageSpecificToken(nonce: Windows$Storage$Streams$IBuffer): Windows$System$Profile$HardwareToken
}


/**
 * Represents a token that contains a hardware based identification that is sufficiently unique.
 */
declare class Windows$System$Profile$HardwareToken  {

/**
 * Gets the certificate that is used to sign the Id and is used to help verify the authenticity of the Id.
 */
certificate: Windows$Storage$Streams$IBuffer;

/**
 * Gets the hardware identifier that identifies the device.
 */
id: Windows$Storage$Streams$IBuffer;

/**
 * Gets the digital signature of hardware Id that helps verify the authenticity of returned Id.
 */
signature: Windows$Storage$Streams$IBuffer
}


/**
 * Identifies the string keys that might exist within the RetailInfo.Properties map of retail-demo relevant property values.
 */
declare class Windows$System$Profile$KnownRetailInfoProperties  {

/**
 * Gets the string that identifies the KnownRetailInfoProperties retail demo property.
 */
static batteryLifeDescription: string;

/**
 * Gets the string that identifies the DisplayDescription retail demo property.
 */
static displayDescription: string;

/**
 * Gets the string that identifies the DisplayModelName retail demo property.
 */
static displayModelName: string;

/**
 * Gets the string that identifies the FormFactor retail demo property.
 */
static formFactor: string;

/**
 * Gets the string that identifies the FrontCameraDescription retail demo property.
 */
static frontCameraDescription: string;

/**
 * Gets the string that identifies the GraphicsDescription retail demo property.
 */
static graphicsDescription: string;

/**
 * Gets the string that identifies the HasNfc retail demo property.
 */
static hasNfc: string;

/**
 * Gets the string that identifies the HasOpticalDrive retail demo property.
 */
static hasOpticalDrive: string;

/**
 * Gets the string that identifies the HasSdSlot retail demo property.
 */
static hasSdSlot: string;

/**
 * Gets the string that identifies the IsFeatured retail demo property.
 */
static isFeatured: string;

/**
 * Gets the string that identifies the IsOfficeInstalled retail demo property.
 */
static isOfficeInstalled: string;

/**
 * Gets the string that identifies the ManufacturerName retail demo property.
 */
static manufacturerName: string;

/**
 * Gets the string that identifies the Memory retail demo property.
 */
static memory: string;

/**
 * Gets the string that identifies the ModelName retail demo property.
 */
static modelName: string;

/**
 * Gets the string that identifies the Price retail demo property.
 */
static price: string;

/**
 * Gets the string that identifies the ProcessorDescription retail demo property.
 */
static processorDescription: string;

/**
 * Gets the string that identifies the RearCameraDescription retail demo property.
 */
static rearCameraDescription: string;

/**
 * Gets the string that identifies the RetailAccessCode retail demo property.
 */
static retailAccessCode: string;

/**
 * Gets the string that identifies the ScreenSize retail demo property.
 */
static screenSize: string;

/**
 * Gets the string that identifies the StorageDescription retail demo property.
 */
static storageDescription: string;

/**
 * Gets the string that identifies the Weight retail demo property.
 */
static weight: string;

/**
 * Gets the string that identifies the WindowsEdition retail demo property.
 */
static windowsEdition: string
}


      declare var npm$namespace$Windows$System$Profile$PlatformDataCollectionLevel: {
        
        security: typeof Windows$System$Profile$PlatformDataCollectionLevel$security,
basic: typeof Windows$System$Profile$PlatformDataCollectionLevel$basic,
enhanced: typeof Windows$System$Profile$PlatformDataCollectionLevel$enhanced,
full: typeof Windows$System$Profile$PlatformDataCollectionLevel$full,
        
        
        
      }
declare var Windows$System$Profile$PlatformDataCollectionLevel$security: any;

declare var Windows$System$Profile$PlatformDataCollectionLevel$basic: any;

declare var Windows$System$Profile$PlatformDataCollectionLevel$enhanced: any;

declare var Windows$System$Profile$PlatformDataCollectionLevel$full: any;

declare class Windows$System$Profile$PlatformDiagnosticsAndUsageDataSettings  {
static addEventListener: any;
static canCollectDiagnostics: any;
static collectionLevel: any;
static oncollectionlevelchanged: any;
static removeEventListener: any
}


/**
 * A utility class that supports one method, IsDemoModeEnabled , and one property, Properties . Call IsDemoModeEnabled to determine whether the device where the app is running has specifically enabled its retail demo mode.
 */
declare class Windows$System$Profile$RetailInfo  {

/**
 * Determines whether the device where the app is running has specifically enabled its retail demo mode.
 */
static isDemoModeEnabled: boolean;

/**
 * Gets an object that represents the set of available retail demo properties and their values.
 */
static properties: Windows$Foundation$Collections$IMapView<string, any>
}


      declare var npm$namespace$Windows$System$Profile$SystemManufacturers: {
        
        
        
        SmbiosInformation: typeof Windows$System$Profile$SystemManufacturers$SmbiosInformation,
        
      }

/**
 * Enables access to properties from the SMBIOS for the system.
 */
declare class Windows$System$Profile$SystemManufacturers$SmbiosInformation  {

/**
 * Gets the serial number from the SMBIOS for the system.
 */
static serialNumber: string
}


/**
 * Represents the result to the application that launched the current application for results.
 */
declare class Windows$System$ProtocolForResultsOperation  {

/**
 * Indicates that the application activated for results is ready to return to the application that launched it for results.
 * @param data The data to return to the application that activated this app.
 */
reportCompleted(data: Windows$Foundation$Collections$ValueSet): void
}


      declare var npm$namespace$Windows$System$RemoteDesktop: {
        
        
        
        InteractiveSession: typeof Windows$System$RemoteDesktop$InteractiveSession,
        
      }

/**
 * Provides Remote Desktop information about the current session.
 */
declare class Windows$System$RemoteDesktop$InteractiveSession  {

/**
 * Indicates whether the calling process is running in a Remote Desktop session.
 */
static isRemote: boolean
}


      declare var npm$namespace$Windows$System$ShutdownKind: {
        
        shutdown: typeof Windows$System$ShutdownKind$shutdown,
restart: typeof Windows$System$ShutdownKind$restart,
        
        
        
      }
declare var Windows$System$ShutdownKind$shutdown: any;

declare var Windows$System$ShutdownKind$restart: any;

declare class Windows$System$ShutdownManager  {
static beginShutdown: any;
static cancelShutdown: any
}



declare class Windows$System$TimeZoneSettings  {
static canChangeTimeZone: any;
static changeTimeZoneByDisplayName: any;
static currentTimeZoneDisplayName: any;
static supportedTimeZoneDisplayNames: any
}


/**
 * Represents a user.
 */
declare class Windows$System$User  {

/**
 * Creates a UserWatcher which enumerates users and raises events when the collection of users changes or when a users authentication state changes.
 * @return A UserWatcher which enumerates users and raises events when the collection of users changes.
 */
static createWatcher(): Windows$System$UserWatcher;

/**
 * Finds all users of a given type and authentication status asynchronously.
 * @param type The type of users to find.
 * @param status The authentication status of users to find.
 * @return When this method completes successfully, it returns a list (type IVectorView ) of Users .
 */
static findAllAsync(
type: $Values<typeof Windows$System$UserType>,
status: $Values<typeof Windows$System$UserAuthenticationStatus>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Finds all users asynchronously.
 * @return When this method completes successfully, it returns a list (type IVectorView ) of Users .
 */
static findAllAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Finds all users of a given type asynchronously.
 * @param type The type of users to find.
 * @return When this method completes successfully, it returns a list (type IVectorView ) of Users .
 */
static findAllAsync(
type: $Values<typeof Windows$System$UserType>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Gets a user with a given Id.
 * @param nonRoamableId The Id of the user to get.
 * @return The user with the given Id.
 */
static getFromId(nonRoamableId: string): Windows$System$User;

/**
 * Gets the authentication status of the user.
 */
authenticationStatus: $Values<typeof Windows$System$UserAuthenticationStatus>;

/**
 * Gets a user's picture asynchronously.
 * @param desiredSize The desired size of the user's picture to return.
 * @return When this method completes, it returns the user's picture.
 */
getPictureAsync(
desiredSize: $Values<typeof Windows$System$UserPictureSize>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Storage$Streams$IRandomAccessStreamReference>;

/**
 * Gets properties for the user.
 * @param values The properties to get. Use the KnownUserProperties class to obtain property names.
 * @return When this method completes, it returns the requested properties. If a property is missing or unavailable, it is reported as an empty string.
 */
getPropertiesAsync(
values: Windows$Foundation$Collections$IVectorView<string>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IPropertySet>;

/**
 * Gets a property for the user. Use the KnownUserProperties class to obtain property names.
 * @param value The property to get.
 * @return When this method completes, it returns the requested property. If the property is missing or unavailable, an empty string is returned.
 */
getPropertyAsync(value: string): Windows$Foundation$IPromiseWithIAsyncOperation<any>;

/**
 * Gets the user's non-roamable id.
 */
nonRoamableId: string;

/**
 * Gets the user type.
 */
type: $Values<typeof Windows$System$UserType>
}


/**
 * Represents the authentication status of a user.
 */

declare  var Windows$System$UserAuthenticationStatus: {|
  +unauthenticated: 0,// 0
+locallyAuthenticated: 1,// 1
+remotelyAuthenticated: 2,// 2

|};



/**
 * Represents a user authentication status change deferral returned by the UserAuthenticationStatusChangingEventArgs.GetDeferral method.
 */
declare class Windows$System$UserAuthenticationStatusChangeDeferral  {

/**
 * Reports that the application has completed its user authentication status change deferral.
 */
complete(): void
}


/**
 * Provides data for a user authentication status changing event.
 */
declare class Windows$System$UserAuthenticationStatusChangingEventArgs  {

/**
 * Gets the user's current authentication status.
 */
currentStatus: $Values<typeof Windows$System$UserAuthenticationStatus>;

/**
 * Requests a delay before the user's authentication status changes.
 * @return The user authentication status change deferral.
 */
getDeferral(): Windows$System$UserAuthenticationStatusChangeDeferral;

/**
 * Gets the user's new authentication status.
 */
newStatus: $Values<typeof Windows$System$UserAuthenticationStatus>;

/**
 * Gets the user.
 */
user: Windows$System$User
}


/**
 * Provides data for a user changed event.
 */
declare class Windows$System$UserChangedEventArgs  {

/**
 * Gets the user.
 */
user: Windows$System$User
}


/**
 * Represents user picture sizes.
 */

declare  var Windows$System$UserPictureSize: {|
  +size64x64: 0,// 0
+size208x208: 1,// 1
+size424x424: 2,// 2
+size1080x1080: 3,// 3

|};



      declare var npm$namespace$Windows$System$UserProfile: {
        
        
        AccountPictureKind: typeof Windows$System$UserProfile$AccountPictureKind,
SetAccountPictureResult: typeof Windows$System$UserProfile$SetAccountPictureResult,
SetImageFeedResult: typeof Windows$System$UserProfile$SetImageFeedResult,
        AdvertisingManager: typeof Windows$System$UserProfile$AdvertisingManager,
FirstSignInSettings: typeof Windows$System$UserProfile$FirstSignInSettings,
GlobalizationPreferences: typeof Windows$System$UserProfile$GlobalizationPreferences,
LockScreen: typeof Windows$System$UserProfile$LockScreen,
UserInformation: typeof Windows$System$UserProfile$UserInformation,
UserProfilePersonalizationSettings: typeof Windows$System$UserProfile$UserProfilePersonalizationSettings,
        
      }

/**
 * Allows you to request a specific image type when using GetAccountPicture .
 */

declare  var Windows$System$UserProfile$AccountPictureKind: {|
  +smallImage: 0,// 0
+largeImage: 1,// 1
+video: 2,// 2

|};



/**
 * Provides a property that lets the caller retrieve the advertising ID, which is an ID used to provide more relevant advertising by understanding which apps are used by the user and how they are used, and to improve quality of service by determining the frequency and effectiveness of ads and to detect fraud and security issues.
 */
declare class Windows$System$UserProfile$AdvertisingManager  {

/**
 * Retrieves a unique ID used to provide more relevant advertising by understanding which apps are used by the user and how they are used, and to improve quality of service by determining the frequency and effectiveness of ads and to detect fraud and security issues. This ID is per-user, per-device; all of the apps for a single user on a device have the same advertising ID. If the advertising ID feature is turned off, no ID is retrieved.
 */
static advertisingId: string
}


/**
 * Represents a collection of settings that a user can opt-in to during the first run experience.
 */
declare class Windows$System$UserProfile$FirstSignInSettings  {

/**
 * Gets the default instance of the settings.
 * @return The default instance of the settings.
 */
static getDefault(): Windows$System$UserProfile$FirstSignInSettings;

/**
 * Returns an iterator for the items in the collection.
 * @return The iterator.
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Determines whether the map view contains the specified key.
 * @param key The key to locate in the map view.
 * @return true if the key is found; otherwise, false.
 */
hasKey(key: string): boolean;

/**
 * Returns the item in the map view with the specified key.
 * @param key The key to locate in the map view.
 * @return The item associated with the specified key.
 */
lookup(key: string): any;

/**
 * Returns the number of elements in the map.
 */
size: number;

/**
 * Splits the map view into two views.
 */
split(
): {
first: Windows$Foundation$Collections$IMapView<string, any>,
second: Windows$Foundation$Collections$IMapView<string, any>
}
}


/**
 * A static class for holding various user globalization preferences.
 */
declare class Windows$System$UserProfile$GlobalizationPreferences  {

/**
 * Gets the set of calendars that are preferred by the user, in order of preference.
 */
static calendars: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the set of clocks that are preferred by the user, in order of preference.
 */
static clocks: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the set of currencies that are preferred by the user, in order of preference.
 */
static currencies: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the user's home geographic region.
 */
static homeGeographicRegion: string;

/**
 * Gets the set of languages that are preferred by the user, in order of preference.
 */
static languages: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the day of the week that is considered to be the first day of the week.
 */
static weekStartsOn: $Values<typeof Windows$Globalization$DayOfWeek>
}


/**
 * Provides properties and methods to manage the full-screen image used as the lock screen background.
 */
declare class Windows$System$UserProfile$LockScreen  {

/**
 * Gets the current lock screen image as a data stream.
 * @return The stream that contains the lock screen image data.
 */
static getImageStream(): Windows$Storage$Streams$IRandomAccessStream;

/**
 * Gets the current lock screen image.
 */
static originalImageFile: Windows$Foundation$Uri;

/**
 * Registers an RSS image feed to be used as a lock screen slideshow. (Windows 8.1 only)
 * @param syndicationFeedUri The URI of the RSS image feed.
 * @return One of the SetImageFeedResult values.
 */
static requestSetImageFeedAsync(
syndicationFeedUri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$System$UserProfile$SetImageFeedResult>>;

/**
 * Sets the lock screen image from a StorageFile object.
 * @param value The StorageFile object that contains the new image for the lock screen.
 * @return The object used to set the image for the lock screen.
 */
static setImageFileAsync(
value: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Sets the lock screen image from a data stream.
 * @param value The stream that contains the image data.
 * @return The object used to set the lock screen image.
 */
static setImageStreamAsync(
value: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Unregisters the image feed being used in the lock screen slideshow, stopping the slideshow. (Windows 8.1 only)
 * @return true if the image feed was disabled; otherwise, false.
 */
static tryRemoveImageFeed(): boolean
}


/**
 * A result that is returned when you try to set the image for a user account.
 */

declare  var Windows$System$UserProfile$SetAccountPictureResult: {|
  +success: 0,// 0
+changeDisabled: 1,// 1
+largeOrDynamicError: 2,// 2
+videoFrameSizeError: 3,// 3
+fileSizeError: 4,// 4
+failure: 5,// 5

|};



/**
 * Specifies the result of a call to LockScreen.RequestSetImageFeedAsync
 */

declare  var Windows$System$UserProfile$SetImageFeedResult: {|
  +success: 0,// 0
+changeDisabled: 1,// 1
+userCanceled: 2,// 2

|};



/**
 * Represents information about the user, such as name and account picture.
 */
declare class Windows$System$UserProfile$UserInformation  {

/**
 * Determines if the user's account picture can be changed.
 */
static accountPictureChangeEnabled: boolean;

/**
 * Gets the account picture for the user.
 * @param kind An enumeration that you can use to determine what type of image you want (small, large, and so on).
 * @return An object that contains the image.
 */
static getAccountPicture(
kind: $Values<typeof Windows$System$UserProfile$AccountPictureKind>): Windows$Storage$IStorageFile;

/**
 * Gets the display name for the user account.
 * @return The display name for the user account.
 */
static getDisplayNameAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Gets the domain name for the user.
 * @return A string that represents the domain name for the user.
 */
static getDomainNameAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Gets the user's first name.
 * @return The user's first name.
 */
static getFirstNameAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Gets the user's last name.
 * @return The user's last name.
 */
static getLastNameAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Gets the principal name for the user. This name is the User Principal Name (typically the user's address, although this is not always true.)
 * @return The user's principal name.
 */
static getPrincipalNameAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<string>;

/**
 * Gets the Uniform Resource Identifier (URI) of the session initiation protocol for the user.
 * @return The URI of the session initiation protocol.
 */
static getSessionInitiationProtocolUriAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Uri>;

/**
 * Allows you to see if your app is allowed to access the user's information.
 */
static nameAccessAllowed: boolean;

/**
 * Occurs when the user's image or name changes.
 */
static onaccountpicturechanged: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "accountpicturechanged",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "accountpicturechanged",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Sets the picture for the user's account using an IStorageFile object.
 * @param image A file that contains the image.
 * @return A value that indicates the success or failure of the operation.
 */
static setAccountPictureAsync(
image: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$System$UserProfile$SetAccountPictureResult>>;

/**
 * Sets the picture for the user's account using an IRandomAccessStream object.
 * @param image The image.
 * @return A value that indicates the success or failure of the operation.
 */
static setAccountPictureFromStreamAsync(
image: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$System$UserProfile$SetAccountPictureResult>>;

/**
 * Sets the pictures for the user's account using an IStorageFile object. Supports adding a small image, large image, and video.
 * @param smallImage A small version of the image.
 * @param largeImage A large version of the image.
 * @param video A video.
 * @return A value that indicates the success or failure of the operation.
 */
static setAccountPicturesAsync(
smallImage: Windows$Storage$IStorageFile,
largeImage: Windows$Storage$IStorageFile,
video: Windows$Storage$IStorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$System$UserProfile$SetAccountPictureResult>>;

/**
 * Sets the pictures for the user's account using an IRandomAccessStream object. Supports adding a small image, large image, and video.
 * @param smallImage A small version of the image.
 * @param largeImage A large version of the image.
 * @param video A video.
 * @return A value that indicates the success or failure of the operation.
 */
static setAccountPicturesFromStreamsAsync(
smallImage: Windows$Storage$Streams$IRandomAccessStream,
largeImage: Windows$Storage$Streams$IRandomAccessStream,
video: Windows$Storage$Streams$IRandomAccessStream): Windows$Foundation$IPromiseWithIAsyncOperation<$Values<typeof Windows$System$UserProfile$SetAccountPictureResult>>;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides properties and methods to manage the user's desktop wallpaper and lock screen background image.
 */
declare class Windows$System$UserProfile$UserProfilePersonalizationSettings  {

/**
 * Gets the current instance of UserProfilePersonalizationSettings .
 */
static current: Windows$System$UserProfile$UserProfilePersonalizationSettings;

/**
 * Gets a value that indicates whether changing the desktop and lock screen images is supported on the current device.
 * @return true if changing the desktop and lock screen images is supported; otherwise, false.
 */
static isSupported(): boolean;

/**
 * Attempts to set the specified image file as the lock screen background image.
 * @param imageFile The image to set as the lock screen background.
 * @return The result of the async operation. true if the background image was set successfully; otherwise, false.
 */
trySetLockScreenImageAsync(
imageFile: Windows$Storage$StorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Attempts to set the specified image file as the desktop wallpaper image.
 * @param imageFile The image to set as the desktop background.
 * @return The result of the async operation. true if the background image was set successfully; otherwise, false.
 */
trySetWallpaperImageAsync(
imageFile: Windows$Storage$StorageFile): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>
}


/**
 * Represents user types.
 */

declare  var Windows$System$UserType: {|
  +localUser: 0,// 0
+remoteUser: 1,// 1
+localGuest: 2,// 2
+remoteGuest: 3,// 3

|};



/**
 * Provides events that fire during enumeration of users, when the collection of users changes, or when a user's authentication status changes.
 */
declare class Windows$System$UserWatcher  {

/**
 * Fires when a user is added to the collection of users returned by User.FindAllAsync .
 */
onadded: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, Windows$System$UserChangedEventArgs>;
addEventListener(
type: "added",
listener: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, Windows$System$UserChangedEventArgs>): void;
removeEventListener(
type: "added",
listener: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, Windows$System$UserChangedEventArgs>): void;

/**
 * Fires when a user's authentication status has changed.
 */
onauthenticationstatuschanged: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, Windows$System$UserChangedEventArgs>;
addEventListener(
type: "authenticationstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, Windows$System$UserChangedEventArgs>): void;
removeEventListener(
type: "authenticationstatuschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, Windows$System$UserChangedEventArgs>): void;

/**
 * Fires when a user's authentication status is about to change.
 */
onauthenticationstatuschanging: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, Windows$System$UserAuthenticationStatusChangingEventArgs>;
addEventListener(
type: "authenticationstatuschanging",
listener: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, Windows$System$UserAuthenticationStatusChangingEventArgs>): void;
removeEventListener(
type: "authenticationstatuschanging",
listener: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, Windows$System$UserAuthenticationStatusChangingEventArgs>): void;

/**
 * Fires when the initial pass of watcher events has been processed and the collection of users is complete.
 */
onenumerationcompleted: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, any>;
addEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, any>): void;
removeEventListener(
type: "enumerationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, any>): void;

/**
 * Fires when a user is removed from the collection of users returned by User.FindAllAsync .
 */
onremoved: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, Windows$System$UserChangedEventArgs>;
addEventListener(
type: "removed",
listener: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, Windows$System$UserChangedEventArgs>): void;
removeEventListener(
type: "removed",
listener: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, Windows$System$UserChangedEventArgs>): void;

/**
 * Fires when the user watcher has stopped.
 */
onstopped: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, any>;
addEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, any>): void;
removeEventListener(
type: "stopped",
listener: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, any>): void;

/**
 * Fires when the data associated with a user has changed.
 */
onupdated: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, Windows$System$UserChangedEventArgs>;
addEventListener(
type: "updated",
listener: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, Windows$System$UserChangedEventArgs>): void;
removeEventListener(
type: "updated",
listener: Windows$Foundation$TypedEventHandler<Windows$System$UserWatcher, Windows$System$UserChangedEventArgs>): void;

/**
 * Starts the user watcher.
 */
start(): void;

/**
 * Gets the status of a user watcher.
 */
status: $Values<typeof Windows$System$UserWatcherStatus>;

/**
 * Stops the user watcher.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents the status of a user watcher.
 */

declare  var Windows$System$UserWatcherStatus: {|
  +created: 0,// 0
+started: 1,// 1
+enumerationCompleted: 2,// 2
+stopping: 3,// 3
+stopped: 4,// 4
+aborted: 5,// 5

|};



/**
 * Specifies the values for each virtual key.
 */

declare  var Windows$System$VirtualKey: {|
  +none: 0,// 0
+leftButton: 1,// 1
+rightButton: 2,// 2
+cancel: 3,// 3
+middleButton: 4,// 4
+xbutton1: 5,// 5
+xbutton2: 6,// 6
+back: 7,// 7
+tab: 8,// 8
+clear: 9,// 9
+enter: 10,// 10
+shift: 11,// 11
+control: 12,// 12
+menu: 13,// 13
+pause: 14,// 14
+capitalLock: 15,// 15
+kana: 16,// 16
+hangul: 17,// 17
+junja: 18,// 18
+final: 19,// 19
+hanja: 20,// 20
+kanji: 21,// 21
+escape: 22,// 22
+convert: 23,// 23
+nonConvert: 24,// 24
+accept: 25,// 25
+modeChange: 26,// 26
+space: 27,// 27
+pageUp: 28,// 28
+pageDown: 29,// 29
+end: 30,// 30
+home: 31,// 31
+left: 32,// 32
+up: 33,// 33
+right: 34,// 34
+down: 35,// 35
+select: 36,// 36
+print: 37,// 37
+execute: 38,// 38
+snapshot: 39,// 39
+insert: 40,// 40
+delete: 41,// 41
+help: 42,// 42
+number0: 43,// 43
+number1: 44,// 44
+number2: 45,// 45
+number3: 46,// 46
+number4: 47,// 47
+number5: 48,// 48
+number6: 49,// 49
+number7: 50,// 50
+number8: 51,// 51
+number9: 52,// 52
+a: 53,// 53
+b: 54,// 54
+c: 55,// 55
+d: 56,// 56
+e: 57,// 57
+f: 58,// 58
+g: 59,// 59
+h: 60,// 60
+i: 61,// 61
+j: 62,// 62
+k: 63,// 63
+l: 64,// 64
+m: 65,// 65
+n: 66,// 66
+o: 67,// 67
+p: 68,// 68
+q: 69,// 69
+r: 70,// 70
+s: 71,// 71
+t: 72,// 72
+u: 73,// 73
+v: 74,// 74
+w: 75,// 75
+x: 76,// 76
+y: 77,// 77
+z: 78,// 78
+leftWindows: 79,// 79
+rightWindows: 80,// 80
+application: 81,// 81
+sleep: 82,// 82
+numberPad0: 83,// 83
+numberPad1: 84,// 84
+numberPad2: 85,// 85
+numberPad3: 86,// 86
+numberPad4: 87,// 87
+numberPad5: 88,// 88
+numberPad6: 89,// 89
+numberPad7: 90,// 90
+numberPad8: 91,// 91
+numberPad9: 92,// 92
+multiply: 93,// 93
+add: 94,// 94
+separator: 95,// 95
+subtract: 96,// 96
+decimal: 97,// 97
+divide: 98,// 98
+f1: 99,// 99
+f2: 100,// 100
+f3: 101,// 101
+f4: 102,// 102
+f5: 103,// 103
+f6: 104,// 104
+f7: 105,// 105
+f8: 106,// 106
+f9: 107,// 107
+f10: 108,// 108
+f11: 109,// 109
+f12: 110,// 110
+f13: 111,// 111
+f14: 112,// 112
+f15: 113,// 113
+f16: 114,// 114
+f17: 115,// 115
+f18: 116,// 116
+f19: 117,// 117
+f20: 118,// 118
+f21: 119,// 119
+f22: 120,// 120
+f23: 121,// 121
+f24: 122,// 122
+navigationView: 123,// 123
+navigationMenu: 124,// 124
+navigationUp: 125,// 125
+navigationDown: 126,// 126
+navigationLeft: 127,// 127
+navigationRight: 128,// 128
+navigationAccept: 129,// 129
+navigationCancel: 130,// 130
+numberKeyLock: 131,// 131
+scroll: 132,// 132
+leftShift: 133,// 133
+rightShift: 134,// 134
+leftControl: 135,// 135
+rightControl: 136,// 136
+leftMenu: 137,// 137
+rightMenu: 138,// 138
+goBack: 139,// 139
+goForward: 140,// 140
+refresh: 141,// 141
+stop: 142,// 142
+search: 143,// 143
+favorites: 144,// 144
+goHome: 145,// 145
+gamepadA: 146,// 146
+gamepadB: 147,// 147
+gamepadX: 148,// 148
+gamepadY: 149,// 149
+gamepadRightShoulder: 150,// 150
+gamepadLeftShoulder: 151,// 151
+gamepadLeftTrigger: 152,// 152
+gamepadRightTrigger: 153,// 153
+gamepadDPadUp: 154,// 154
+gamepadDPadDown: 155,// 155
+gamepadDPadLeft: 156,// 156
+gamepadDPadRight: 157,// 157
+gamepadMenu: 158,// 158
+gamepadView: 159,// 159
+gamepadLeftThumbstickButton: 160,// 160
+gamepadRightThumbstickButton: 161,// 161
+gamepadLeftThumbstickUp: 162,// 162
+gamepadLeftThumbstickDown: 163,// 163
+gamepadLeftThumbstickRight: 164,// 164
+gamepadLeftThumbstickLeft: 165,// 165
+gamepadRightThumbstickUp: 166,// 166
+gamepadRightThumbstickDown: 167,// 167
+gamepadRightThumbstickRight: 168,// 168
+gamepadRightThumbstickLeft: 169,// 169

|};



/**
 * Specifies the virtual key used to modify another keypress. For example, the Ctrl key when pressed in conjunction with another key, as in Ctrl+C.
 */

declare  var Windows$System$VirtualKeyModifiers: {|
  +none: 0,// 0
+control: 1,// 1
+menu: 2,// 2
+shift: 3,// 3
+windows: 4,// 4

|};



      declare var npm$namespace$Windows$UI: {
        
        
        
        ColorHelper: typeof Windows$UI$ColorHelper,
Colors: typeof Windows$UI$Colors,
        ApplicationSettings: typeof npm$namespace$Windows$UI$ApplicationSettings,
Composition: typeof npm$namespace$Windows$UI$Composition,
Core: typeof npm$namespace$Windows$UI$Core,
Input: typeof npm$namespace$Windows$UI$Input,
Notifications: typeof npm$namespace$Windows$UI$Notifications,
Popups: typeof npm$namespace$Windows$UI$Popups,
StartScreen: typeof npm$namespace$Windows$UI$StartScreen,
Text: typeof npm$namespace$Windows$UI$Text,
ViewManagement: typeof npm$namespace$Windows$UI$ViewManagement,
WebUI: typeof npm$namespace$Windows$UI$WebUI,
Xaml: typeof npm$namespace$Windows$UI$Xaml,
      }

      declare var npm$namespace$Windows$UI$ApplicationSettings: {
        
        
        SettingsEdgeLocation: typeof Windows$UI$ApplicationSettings$SettingsEdgeLocation,
SupportedWebAccountActions: typeof Windows$UI$ApplicationSettings$SupportedWebAccountActions,
WebAccountAction: typeof Windows$UI$ApplicationSettings$WebAccountAction,
        AccountsSettingsPane: typeof Windows$UI$ApplicationSettings$AccountsSettingsPane,
AccountsSettingsPaneCommandsRequestedEventArgs: typeof Windows$UI$ApplicationSettings$AccountsSettingsPaneCommandsRequestedEventArgs,
AccountsSettingsPaneEventDeferral: typeof Windows$UI$ApplicationSettings$AccountsSettingsPaneEventDeferral,
CredentialCommand: typeof Windows$UI$ApplicationSettings$CredentialCommand,
SettingsCommand: typeof Windows$UI$ApplicationSettings$SettingsCommand,
SettingsPane: typeof Windows$UI$ApplicationSettings$SettingsPane,
SettingsPaneCommandsRequest: typeof Windows$UI$ApplicationSettings$SettingsPaneCommandsRequest,
SettingsPaneCommandsRequestedEventArgs: typeof Windows$UI$ApplicationSettings$SettingsPaneCommandsRequestedEventArgs,
WebAccountCommand: typeof Windows$UI$ApplicationSettings$WebAccountCommand,
WebAccountInvokedArgs: typeof Windows$UI$ApplicationSettings$WebAccountInvokedArgs,
WebAccountProviderCommand: typeof Windows$UI$ApplicationSettings$WebAccountProviderCommand,
        
      }

/**
 * Provides methods to show the accounts pane and also to enable the app to register callbacks when the accounts flyout is about to be displayed.
 */
declare class Windows$UI$ApplicationSettings$AccountsSettingsPane  {

/**
 * Gets an AccountsSettingsPane object that is associated with the current app view (that is, with CoreWindow ).
 * @return The account settings pane.
 */
static getForCurrentView(): Windows$UI$ApplicationSettings$AccountsSettingsPane;

/**
 * Displays the account settings pane.
 */
static show(): void;

/**
 * Occurs when the user opens the accounts pane. Handling this event lets the app initialize the accounts commands and pause its UI until the user closes the pane.
 */
onaccountcommandsrequested: Windows$Foundation$TypedEventHandler<Windows$UI$ApplicationSettings$AccountsSettingsPane, Windows$UI$ApplicationSettings$AccountsSettingsPaneCommandsRequestedEventArgs>;
addEventListener(
type: "accountcommandsrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ApplicationSettings$AccountsSettingsPane, Windows$UI$ApplicationSettings$AccountsSettingsPaneCommandsRequestedEventArgs>): void;
removeEventListener(
type: "accountcommandsrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ApplicationSettings$AccountsSettingsPane, Windows$UI$ApplicationSettings$AccountsSettingsPaneCommandsRequestedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the AccountCommandsRequested event.
 */
declare class Windows$UI$ApplicationSettings$AccountsSettingsPaneCommandsRequestedEventArgs  {

/**
 * Gets the SettingsCommand collection for the account settings pane.
 */
commands: Windows$Foundation$Collections$IVector<Windows$UI$ApplicationSettings$SettingsCommand>;

/**
 * Gets the CredentialCommand collection for the account settings pane.
 */
credentialCommands: Windows$Foundation$Collections$IVector<Windows$UI$ApplicationSettings$CredentialCommand>;

/**
 * Gets the deferral object for the AccountCommandsRequested event.
 * @return The deferral object.
 */
getDeferral(): Windows$UI$ApplicationSettings$AccountsSettingsPaneEventDeferral;

/**
 * Gets or sets the header text for the account settings pane.
 */
headerText: string;

/**
 * Gets the WebAccountCommand collection for the account settings pane.
 */
webAccountCommands: Windows$Foundation$Collections$IVector<Windows$UI$ApplicationSettings$WebAccountCommand>;

/**
 * Gets the WebAccountProviderCommand collection for the account settings pane.
 */
webAccountProviderCommands: Windows$Foundation$Collections$IVector<Windows$UI$ApplicationSettings$WebAccountProviderCommand>
}


/**
 * Enables the app to signal when it has finished populating command collections while handling the AccountCommandsRequested event.
 */
declare class Windows$UI$ApplicationSettings$AccountsSettingsPaneEventDeferral  {

/**
 * Signals that the app has finished populating command collections while handling the AccountCommandsRequested event.
 */
complete(): void
}


/**
 * Deprecated. Represents a command for changing web account credentials in the account settings pane.
 */
declare class Windows$UI$ApplicationSettings$CredentialCommand  {

/**
 * Initializes a new instance of the CredentialCommand class with a PasswordCredential object.
 * @param passwordCredential The password credential.
 */
constructor(passwordCredential: Windows$Security$Credentials$PasswordCredential): this;

/**
 * Initializes a new instance of the CredentialCommand class with a PasswordCredential object and a CredentialCommandCredentialDeletedHandler delegate.
 * @param passwordCredential The password credential.
 * @param deleted The delegate that handles credential deletion.
 */
constructor(passwordCredential: Windows$Security$Credentials$PasswordCredential, deleted: Windows$UI$ApplicationSettings$CredentialCommandCredentialDeletedHandler): this;

/**
 * Gets the delegate that's invoked by the account settings pane when the user deletes a credential.
 */
credentialDeleted: Windows$UI$ApplicationSettings$CredentialCommandCredentialDeletedHandler;

/**
 * Gets the password credential that the current command applies to.
 */
passwordCredential: Windows$Security$Credentials$PasswordCredential
}


/**
 * Creates a settings command object that represents a settings entry. This settings command can be appended to the ApplicationCommands vector.
 */
declare class Windows$UI$ApplicationSettings$SettingsCommand  {

/**
 * Gets the command for a web account in the account settings pane.
 */
static accountsCommand: Windows$UI$ApplicationSettings$SettingsCommand;

/**
 * Creates a new settings command.
 * @param settingsCommandId The ID of the command.
 * @param label The label for the command, which is displayed in the settings pane.
 * @param handler The event handler that is called when the user selects this command in the settings pane.
 */
constructor(settingsCommandId: any, label: string, handler: Windows$UI$Popups$UICommandInvokedHandler): this;

/**
 * Gets or sets the command ID.
 */
id: any;

/**
 * Gets or sets the handler for the event that is raised when the user selects the command.
 */
invoked: Windows$UI$Popups$UICommandInvokedHandler;

/**
 * Gets or sets the label for the command.
 */
label: string
}


/**
 * Specifies the edge of the screen where the Settings charms appear.
 */

declare  var Windows$UI$ApplicationSettings$SettingsEdgeLocation: {|
  +right: 0,// 0
+left: 1,// 1

|};



/**
 * A static class that enables the app to control the Settings Charm pane. The app can add or remove commands, receive a notification when the user opens the pane, or open the pane programmatically.
 */
declare class Windows$UI$ApplicationSettings$SettingsPane  {

/**
 * Gets a value indicating whether the Settings charm appears on the left or right edge of the screen.
 */
static edge: $Values<typeof Windows$UI$ApplicationSettings$SettingsEdgeLocation>;

/**
 * Gets a SettingsPane object that is associated with the current app view (that is, with CoreWindow ).
 * @return The settings pane.
 */
static getForCurrentView(): Windows$UI$ApplicationSettings$SettingsPane;

/**
 * Displays the Settings Charm pane to the user.
 */
static show(): void;

/**
 * Occurs when the user opens the settings pane. Listening for this event lets the app initialize the setting commands and pause its UI until the user closes the pane.
 */
oncommandsrequested: Windows$Foundation$TypedEventHandler<Windows$UI$ApplicationSettings$SettingsPane, Windows$UI$ApplicationSettings$SettingsPaneCommandsRequestedEventArgs>;
addEventListener(
type: "commandsrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ApplicationSettings$SettingsPane, Windows$UI$ApplicationSettings$SettingsPaneCommandsRequestedEventArgs>): void;
removeEventListener(
type: "commandsrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ApplicationSettings$SettingsPane, Windows$UI$ApplicationSettings$SettingsPaneCommandsRequestedEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Contains properties that are only available during the CommandsRequested event.
 */
declare class Windows$UI$ApplicationSettings$SettingsPaneCommandsRequest  {

/**
 * A vector that is available during the CommandsRequested event. Append SettingsCommand objects to it to make them available to the SettingsPane UI.
 */
applicationCommands: Windows$Foundation$Collections$IVector<Windows$UI$ApplicationSettings$SettingsCommand>
}


/**
 * Contains arguments that are available from the event object during the CommandsRequested event.
 */
declare class Windows$UI$ApplicationSettings$SettingsPaneCommandsRequestedEventArgs  {

/**
 * An instance of SettingsPaneCommandsRequest that is made available during the CommandsRequested event.
 */
request: Windows$UI$ApplicationSettings$SettingsPaneCommandsRequest
}


/**
 * Specifies actions that your app enables on an web account instance in the account settings pane.
 */

declare  var Windows$UI$ApplicationSettings$SupportedWebAccountActions: {|
  +none: 0,// 0
+reconnect: 1,// 1
+remove: 2,// 2
+viewDetails: 3,// 3
+manage: 4,// 4
+more: 5,// 5

|};



/**
 * Specifies actions that your app does on an web account.
 */

declare  var Windows$UI$ApplicationSettings$WebAccountAction: {|
  +reconnect: 0,// 0
+remove: 1,// 1
+viewDetails: 2,// 2
+manage: 3,// 3
+more: 4,// 4

|};



/**
 * Associates a command with a WebAccount in the account settings pane..
 */
declare class Windows$UI$ApplicationSettings$WebAccountCommand  {

/**
 * Initializes a new instance of the WebAccountCommand class.
 * @param webAccount The web account to associate with the current command.
 * @param invoked The delegate that handles the command.
 * @param actions A bitmask of web account actions.
 */
constructor(webAccount: Windows$Security$Credentials$WebAccount, invoked: Windows$UI$ApplicationSettings$WebAccountCommandInvokedHandler, actions: $Values<typeof Windows$UI$ApplicationSettings$SupportedWebAccountActions>): this;

/**
 * Gets the actions that the command performs on the web account in the accounts pane.
 */
actions: $Values<typeof Windows$UI$ApplicationSettings$SupportedWebAccountActions>;

/**
 * Gets the delegate that's invoked when the user selects an account and a specific action in the account settings pane.
 */
invoked: Windows$UI$ApplicationSettings$WebAccountCommandInvokedHandler;

/**
 * Gets the web account that's associated with the current command.
 */
webAccount: Windows$Security$Credentials$WebAccount
}


/**
 * Provides data for the WebAccountCommandInvokedHandler delegate.
 */
declare class Windows$UI$ApplicationSettings$WebAccountInvokedArgs  {

/**
 * Gets the action for the web account in the accounts pane.
 */
action: $Values<typeof Windows$UI$ApplicationSettings$WebAccountAction>
}


/**
 * Associates a provider command with a WebAccountProvider in the account settings pane.
 */
declare class Windows$UI$ApplicationSettings$WebAccountProviderCommand  {

/**
 * Initializes a new instance of the WebAccountProviderCommand class.
 * @param webAccountProvider The web account provider.
 * @param invoked The delegate that handles the provider command.
 */
constructor(webAccountProvider: Windows$Security$Credentials$WebAccountProvider, invoked: Windows$UI$ApplicationSettings$WebAccountProviderCommandInvokedHandler): this;

/**
 * Gets the delegate that's invoked when the user selects an account and a specific action in the accounts pane.
 */
invoked: Windows$UI$ApplicationSettings$WebAccountProviderCommandInvokedHandler;

/**
 * Gets the web account provider that's associated with the current command.
 */
webAccountProvider: Windows$Security$Credentials$WebAccountProvider
}


/**
 * Represents the method that's invoked by the account settings pane when the user deletes a credential.
 */
declare type Windows$UI$ApplicationSettings$CredentialCommandCredentialDeletedHandler = (command: Windows$UI$ApplicationSettings$CredentialCommand) => void;


/**
 * Represents the method that's invoked when the user selects an account and a specific action in the account settings pane.
 */
declare type Windows$UI$ApplicationSettings$WebAccountCommandInvokedHandler = (
command: Windows$UI$ApplicationSettings$WebAccountCommand,
args: Windows$UI$ApplicationSettings$WebAccountInvokedArgs) => void;


/**
 * Represents the method that's invoked when the user selects an account and a specific action in the account settings pane.
 */
declare type Windows$UI$ApplicationSettings$WebAccountProviderCommandInvokedHandler = (command: Windows$UI$ApplicationSettings$WebAccountProviderCommand) => void;


/**
 * Provides static helper methods for processing Color values. C# and Microsoft Visual Basic code should use methods of Color instead.
 */
declare class Windows$UI$ColorHelper  {

/**
 * Generates a Color structure, based on discrete Byte values for ARGB components. C# and Microsoft Visual Basic code should use Color.FromArgb instead.
 * @param a The A (transparency) component of the desired color. Range is 0-255.
 * @param r The R component of the desired color. Range is 0-255.
 * @param g The G component of the desired color. Range is 0-255.
 * @param b The B component of the desired color. Range is 0-255.
 * @return The generated Color value.
 */
static fromArgb(a: number, r: number, g: number, b: number): Windows$UI$Color
}


/**
 * Implements a set of predefined colors. See Color for usage information.
 */
declare class Windows$UI$Colors  {

/**
 * Gets the color value that represents the AliceBlue named color.
 */
static aliceBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the AntiqueWhite named color.
 */
static antiqueWhite: Windows$UI$Color;

/**
 * Gets the color value that represents the Aqua named color.
 */
static aqua: Windows$UI$Color;

/**
 * Gets the color value that represents the Aquamarine named color.
 */
static aquamarine: Windows$UI$Color;

/**
 * Gets the color value that represents the Azure named color.
 */
static azure: Windows$UI$Color;

/**
 * Gets the color value that represents the Beige named color.
 */
static beige: Windows$UI$Color;

/**
 * Gets the color value that represents the Bisque named color.
 */
static bisque: Windows$UI$Color;

/**
 * Gets the system-defined color that has the ARGB value of #FF000000.
 */
static black: Windows$UI$Color;

/**
 * Gets the color value that represents the BlanchedAlmond named color.
 */
static blanchedAlmond: Windows$UI$Color;

/**
 * Gets the system-defined color that has the ARGB value of #FF0000FF.
 */
static blue: Windows$UI$Color;

/**
 * Gets the color value that represents the BlueViolet named color.
 */
static blueViolet: Windows$UI$Color;

/**
 * Gets the system-defined color that has the ARGB value of #FFA52A2A.
 */
static brown: Windows$UI$Color;

/**
 * Gets the color value that represents the BurlyWood named color.
 */
static burlyWood: Windows$UI$Color;

/**
 * Gets the color value that represents the CadetBlue named color.
 */
static cadetBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the Chartreuse named color.
 */
static chartreuse: Windows$UI$Color;

/**
 * Gets the color value that represents the Chocolate named color.
 */
static chocolate: Windows$UI$Color;

/**
 * Gets the color value that represents the Coral named color.
 */
static coral: Windows$UI$Color;

/**
 * Gets the color value that represents the CornflowerBlue named color.
 */
static cornflowerBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the Cornsilk named color.
 */
static cornsilk: Windows$UI$Color;

/**
 * Gets the color value that represents the Crimson named color.
 */
static crimson: Windows$UI$Color;

/**
 * Gets the system-defined color that has the ARGB value of #FF00FFFF.
 */
static cyan: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkBlue named color.
 */
static darkBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkCyan named color.
 */
static darkCyan: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkGoldenrod named color.
 */
static darkGoldenrod: Windows$UI$Color;

/**
 * Gets the system-defined color that has the ARGB value of #FFA9A9A9.
 */
static darkGray: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkGreen named color.
 */
static darkGreen: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkKhaki named color.
 */
static darkKhaki: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkMagenta named color.
 */
static darkMagenta: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkOliveGreen named color.
 */
static darkOliveGreen: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkOrange named color.
 */
static darkOrange: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkOrchid named color.
 */
static darkOrchid: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkRed named color.
 */
static darkRed: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkSalmon named color.
 */
static darkSalmon: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkSeaGreen named color.
 */
static darkSeaGreen: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkSlateBlue named color.
 */
static darkSlateBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkSlateGray named color.
 */
static darkSlateGray: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkTurquoise named color.
 */
static darkTurquoise: Windows$UI$Color;

/**
 * Gets the color value that represents the DarkViolet named color.
 */
static darkViolet: Windows$UI$Color;

/**
 * Gets the color value that represents the DeepPink named color.
 */
static deepPink: Windows$UI$Color;

/**
 * Gets the color value that represents the DeepSkyBlue named color.
 */
static deepSkyBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the DimGray named color.
 */
static dimGray: Windows$UI$Color;

/**
 * Gets the color value that represents the DodgerBlue named color.
 */
static dodgerBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the Firebrick named color.
 */
static firebrick: Windows$UI$Color;

/**
 * Gets the color value that represents the FloralWhite named color.
 */
static floralWhite: Windows$UI$Color;

/**
 * Gets the color value that represents the ForestGreen named color.
 */
static forestGreen: Windows$UI$Color;

/**
 * Gets the color value that represents the Fuchsia named color.
 */
static fuchsia: Windows$UI$Color;

/**
 * Gets the color value that represents the Gainsboro named color.
 */
static gainsboro: Windows$UI$Color;

/**
 * Gets the color value that represents the GhostWhite named color.
 */
static ghostWhite: Windows$UI$Color;

/**
 * Gets the color value that represents the Gold named color.
 */
static gold: Windows$UI$Color;

/**
 * Gets the color value that represents the Goldenrod named color.
 */
static goldenrod: Windows$UI$Color;

/**
 * Gets the system-defined color that has the ARGB value of #FF808080.
 */
static gray: Windows$UI$Color;

/**
 * Gets the system-defined color that has the ARGB value of #FF008000.
 */
static green: Windows$UI$Color;

/**
 * Gets the color value that represents the GreenYellow named color.
 */
static greenYellow: Windows$UI$Color;

/**
 * Gets the color value that represents the Honeydew named color.
 */
static honeydew: Windows$UI$Color;

/**
 * Gets the color value that represents the HotPink named color.
 */
static hotPink: Windows$UI$Color;

/**
 * Gets the color value that represents the IndianRed named color.
 */
static indianRed: Windows$UI$Color;

/**
 * Gets the color value that represents the Indigo named color.
 */
static indigo: Windows$UI$Color;

/**
 * Gets the color value that represents the Ivory named color.
 */
static ivory: Windows$UI$Color;

/**
 * Gets the color value that represents the Khaki named color.
 */
static khaki: Windows$UI$Color;

/**
 * Gets the color value that represents the Lavender named color.
 */
static lavender: Windows$UI$Color;

/**
 * Gets the color value that represents the LavenderBlush named color.
 */
static lavenderBlush: Windows$UI$Color;

/**
 * Gets the color value that represents the LawnGreen named color.
 */
static lawnGreen: Windows$UI$Color;

/**
 * Gets the color value that represents the LemonChiffon named color.
 */
static lemonChiffon: Windows$UI$Color;

/**
 * Gets the color value that represents the LightBlue named color.
 */
static lightBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the LightCoral named color.
 */
static lightCoral: Windows$UI$Color;

/**
 * Gets the color value that represents the LightCyan named color.
 */
static lightCyan: Windows$UI$Color;

/**
 * Gets the color value that represents the LightGoldenrodYellow named color.
 */
static lightGoldenrodYellow: Windows$UI$Color;

/**
 * Gets the system-defined color that has the ARGB value of #FFD3D3D3.
 */
static lightGray: Windows$UI$Color;

/**
 * Gets the color value that represents the LightGreen named color.
 */
static lightGreen: Windows$UI$Color;

/**
 * Gets the color value that represents the LightPink named color.
 */
static lightPink: Windows$UI$Color;

/**
 * Gets the color value that represents the LightSalmon named color.
 */
static lightSalmon: Windows$UI$Color;

/**
 * Gets the color value that represents the LightSeaGreen named color.
 */
static lightSeaGreen: Windows$UI$Color;

/**
 * Gets the color value that represents the LightSkyBlue named color.
 */
static lightSkyBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the LightSlateGray named color.
 */
static lightSlateGray: Windows$UI$Color;

/**
 * Gets the color value that represents the LightSteelBlue named color.
 */
static lightSteelBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the LightYellow named color.
 */
static lightYellow: Windows$UI$Color;

/**
 * Gets the color value that represents the Lime named color.
 */
static lime: Windows$UI$Color;

/**
 * Gets the color value that represents the LimeGreen named color.
 */
static limeGreen: Windows$UI$Color;

/**
 * Gets the color value that represents the Linen named color.
 */
static linen: Windows$UI$Color;

/**
 * Gets the system-defined color that has the ARGB value of #FFFF00FF..
 */
static magenta: Windows$UI$Color;

/**
 * Gets the color value that represents the Maroon named color.
 */
static maroon: Windows$UI$Color;

/**
 * Gets the color value that represents the MediumAquamarine named color.
 */
static mediumAquamarine: Windows$UI$Color;

/**
 * Gets the color value that represents the MediumBlue named color.
 */
static mediumBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the MediumOrchid named color.
 */
static mediumOrchid: Windows$UI$Color;

/**
 * Gets the color value that represents the MediumPurple named color.
 */
static mediumPurple: Windows$UI$Color;

/**
 * Gets the color value that represents the MediumSeaGreen named color.
 */
static mediumSeaGreen: Windows$UI$Color;

/**
 * Gets the color value that represents the MediumSlateBlue named color.
 */
static mediumSlateBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the MediumSpringGreen named color.
 */
static mediumSpringGreen: Windows$UI$Color;

/**
 * Gets the color value that represents the MediumTurquoise named color.
 */
static mediumTurquoise: Windows$UI$Color;

/**
 * Gets the color value that represents the MediumVioletRed named color.
 */
static mediumVioletRed: Windows$UI$Color;

/**
 * Gets the color value that represents the MidnightBlue named color.
 */
static midnightBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the MintCream named color.
 */
static mintCream: Windows$UI$Color;

/**
 * Gets the color value that represents the MistyRose named color.
 */
static mistyRose: Windows$UI$Color;

/**
 * Gets the color value that represents the Moccasin named color.
 */
static moccasin: Windows$UI$Color;

/**
 * Gets the color value that represents the NavajoWhite named color.
 */
static navajoWhite: Windows$UI$Color;

/**
 * Gets the color value that represents the Navy named color.
 */
static navy: Windows$UI$Color;

/**
 * Gets the color value that represents the OldLace named color.
 */
static oldLace: Windows$UI$Color;

/**
 * Gets the color value that represents the Olive named color.
 */
static olive: Windows$UI$Color;

/**
 * Gets the color value that represents the OliveDrab named color.
 */
static oliveDrab: Windows$UI$Color;

/**
 * Gets the system-defined color that has the ARGB value of #FFFFA500..
 */
static orange: Windows$UI$Color;

/**
 * Gets the color value that represents the OrangeRed named color.
 */
static orangeRed: Windows$UI$Color;

/**
 * Gets the color value that represents the Orchid named color.
 */
static orchid: Windows$UI$Color;

/**
 * Gets the color value that represents the PaleGoldenrod named color.
 */
static paleGoldenrod: Windows$UI$Color;

/**
 * Gets the color value that represents the PaleGreen named color.
 */
static paleGreen: Windows$UI$Color;

/**
 * Gets the color value that represents the PaleTurquoise named color.
 */
static paleTurquoise: Windows$UI$Color;

/**
 * Gets the color value that represents the PaleVioletRed named color.
 */
static paleVioletRed: Windows$UI$Color;

/**
 * Gets the color value that represents the PapayaWhip named color.
 */
static papayaWhip: Windows$UI$Color;

/**
 * Gets the color value that represents the PeachPuff named color.
 */
static peachPuff: Windows$UI$Color;

/**
 * Gets the color value that represents the Peru named color.
 */
static peru: Windows$UI$Color;

/**
 * Gets the color value that represents the Pink named color.
 */
static pink: Windows$UI$Color;

/**
 * Gets the color value that represents the Plum named color.
 */
static plum: Windows$UI$Color;

/**
 * Gets the color value that represents the PowderBlue named color.
 */
static powderBlue: Windows$UI$Color;

/**
 * Gets the system-defined color that has the ARGB value of #FF800080..
 */
static purple: Windows$UI$Color;

/**
 * Gets the system-defined color that has the ARGB value of #FFFF0000.
 */
static red: Windows$UI$Color;

/**
 * Gets the color value that represents the RosyBrown named color.
 */
static rosyBrown: Windows$UI$Color;

/**
 * Gets the color value that represents the RoyalBlue named color.
 */
static royalBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the SaddleBrown named color.
 */
static saddleBrown: Windows$UI$Color;

/**
 * Gets the color value that represents the Salmon named color.
 */
static salmon: Windows$UI$Color;

/**
 * Gets the color value that represents the SandyBrown named color.
 */
static sandyBrown: Windows$UI$Color;

/**
 * Gets the color value that represents the SeaGreen named color.
 */
static seaGreen: Windows$UI$Color;

/**
 * Gets the color value that represents the SeaShell named color.
 */
static seaShell: Windows$UI$Color;

/**
 * Gets the color value that represents the Sienna named color.
 */
static sienna: Windows$UI$Color;

/**
 * Gets the color value that represents the Silver named color.
 */
static silver: Windows$UI$Color;

/**
 * Gets the color value that represents the SkyBlue named color.
 */
static skyBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the SlateBlue named color.
 */
static slateBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the SlateGray named color.
 */
static slateGray: Windows$UI$Color;

/**
 * Gets the color value that represents the Snow named color.
 */
static snow: Windows$UI$Color;

/**
 * Gets the color value that represents the SpringGreen named color.
 */
static springGreen: Windows$UI$Color;

/**
 * Gets the color value that represents the SteelBlue named color.
 */
static steelBlue: Windows$UI$Color;

/**
 * Gets the color value that represents the Tan named color.
 */
static tan: Windows$UI$Color;

/**
 * Gets the color value that represents the Teal named color.
 */
static teal: Windows$UI$Color;

/**
 * Gets the color value that represents the Thistle named color.
 */
static thistle: Windows$UI$Color;

/**
 * Gets the color value that represents the Tomato named color.
 */
static tomato: Windows$UI$Color;

/**
 * Gets the system-defined color that has the ARGB value of #00FFFFFF.
 */
static transparent: Windows$UI$Color;

/**
 * Gets the color value that represents the Turquoise named color.
 */
static turquoise: Windows$UI$Color;

/**
 * Gets the color value that represents the Violet named color.
 */
static violet: Windows$UI$Color;

/**
 * Gets the color value that represents the Wheat named color.
 */
static wheat: Windows$UI$Color;

/**
 * Gets the system-defined color that has the ARGB value of #FFFFFFFF.
 */
static white: Windows$UI$Color;

/**
 * Gets the color value that represents the WhiteSmoke named color.
 */
static whiteSmoke: Windows$UI$Color;

/**
 * Gets the system-defined color that has the ARGB value of #FFFFFF00.
 */
static yellow: Windows$UI$Color;

/**
 * Gets the color value that represents the YellowGreen named color.
 */
static yellowGreen: Windows$UI$Color
}


      declare var npm$namespace$Windows$UI$Composition: {
        
        
        
        CompositionAnimation: typeof Windows$UI$Composition$CompositionAnimation,
CompositionEasingFunction: typeof Windows$UI$Composition$CompositionEasingFunction,
        
      }

/**
 * Represents an animation.
 */
declare class Windows$UI$Composition$CompositionAnimation  {}


/**
 * Represents a function for interpolating between animation key frames.
 */
declare class Windows$UI$Composition$CompositionEasingFunction  {}


      declare var npm$namespace$Windows$UI$Core: {
        
        
        AppViewBackButtonVisibility: typeof Windows$UI$Core$AppViewBackButtonVisibility,
        BackRequestedEventArgs: typeof Windows$UI$Core$BackRequestedEventArgs,
SystemNavigationManager: typeof Windows$UI$Core$SystemNavigationManager,
        AnimationMetrics: typeof npm$namespace$Windows$UI$Core$AnimationMetrics,
      }

      declare var npm$namespace$Windows$UI$Core$AnimationMetrics: {
        
        
        AnimationEffect: typeof Windows$UI$Core$AnimationMetrics$AnimationEffect,
AnimationEffectTarget: typeof Windows$UI$Core$AnimationMetrics$AnimationEffectTarget,
PropertyAnimationType: typeof Windows$UI$Core$AnimationMetrics$PropertyAnimationType,
        AnimationDescription: typeof Windows$UI$Core$AnimationMetrics$AnimationDescription,
OpacityAnimation: typeof Windows$UI$Core$AnimationMetrics$OpacityAnimation,
PropertyAnimation: typeof Windows$UI$Core$AnimationMetrics$PropertyAnimation,
ScaleAnimation: typeof Windows$UI$Core$AnimationMetrics$ScaleAnimation,
TranslationAnimation: typeof Windows$UI$Core$AnimationMetrics$TranslationAnimation,
        
      }

/**
 * Exposes a collection of individual animation effects that are performed on a specific target to make up a complete Windows opacity, scaling, or translation animation.
 */
declare class Windows$UI$Core$AnimationMetrics$AnimationDescription  {

/**
 * Creates an AnimationDescription object with a specific animation and target.
 * @param effect The animation effect to apply to the target.
 * @param target The target of the animation effect.
 */
constructor(effect: $Values<typeof Windows$UI$Core$AnimationMetrics$AnimationEffect>, target: $Values<typeof Windows$UI$Core$AnimationMetrics$AnimationEffectTarget>): this;

/**
 * Gets the collection of animations that are associated with the AnimationDescription object.
 */
animations: Windows$Foundation$Collections$IVectorView<Windows$UI$Core$AnimationMetrics$IPropertyAnimation>;

/**
 * Gets the maximum cumulative delay time for the animation to be applied to the collection of objects in a target.
 */
delayLimit: number;

/**
 * Gets the amount of time between the application of the animation effect to each object in a target that contains multiple objects. The StaggerDelay, together with the StaggerDelayFactor and DelayLimit, is one of the three elements used to control the relative timing of the animation effects.
 */
staggerDelay: number;

/**
 * Gets a multiplier that is applied to each occurrence of the stagger delay, increasing or decreasing the previous delay instance by that amount.
 */
staggerDelayFactor: number;

/**
 * Gets the z-order position of an AnimationDescription object relative to other AnimationDescription objects in the same animation effect. AnimationDescription objects with a higher z-order cover transitions with a lower z-order.
 */
zorder: number
}


/**
 * Specifies an animation.
 */

declare  var Windows$UI$Core$AnimationMetrics$AnimationEffect: {|
  +expand: 0,// 0
+collapse: 1,// 1
+reposition: 2,// 2
+fadeIn: 3,// 3
+fadeOut: 4,// 4
+addToList: 5,// 5
+deleteFromList: 6,// 6
+addToGrid: 7,// 7
+deleteFromGrid: 8,// 8
+addToSearchGrid: 9,// 9
+deleteFromSearchGrid: 10,// 10
+addToSearchList: 11,// 11
+deleteFromSearchList: 12,// 12
+showEdgeUI: 13,// 13
+showPanel: 14,// 14
+hideEdgeUI: 15,// 15
+hidePanel: 16,// 16
+showPopup: 17,// 17
+hidePopup: 18,// 18
+pointerDown: 19,// 19
+pointerUp: 20,// 20
+dragSourceStart: 21,// 21
+dragSourceEnd: 22,// 22
+transitionContent: 23,// 23
+reveal: 24,// 24
+hide: 25,// 25
+dragBetweenEnter: 26,// 26
+dragBetweenLeave: 27,// 27
+swipeSelect: 28,// 28
+swipeDeselect: 29,// 29
+swipeReveal: 30,// 30
+enterPage: 31,// 31
+transitionPage: 32,// 32
+crossFade: 33,// 33
+peek: 34,// 34
+updateBadge: 35,// 35

|};



/**
 * Specifies a participant in an animation.
 */

declare  var Windows$UI$Core$AnimationMetrics$AnimationEffectTarget: {|
  +primary: 0,// 0
+added: 1,// 1
+affected: 2,// 2
+background: 3,// 3
+content: 4,// 4
+deleted: 5,// 5
+deselected: 6,// 6
+dragSource: 7,// 7
+hidden: 8,// 8
+incoming: 9,// 9
+outgoing: 10,// 10
+outline: 11,// 11
+remaining: 12,// 12
+revealed: 13,// 13
+rowIn: 14,// 14
+rowOut: 15,// 15
+selected: 16,// 16
+selection: 17,// 17
+shown: 18,// 18
+tapped: 19,// 19

|};



/**
 * Provides methods that enable you to retrieve the parameters of an opacity (fade in or fade out) animation.
 */
declare class Windows$UI$Core$AnimationMetrics$OpacityAnimation  {

/**
 * Gets the location of the first control point for the cubic Bzier curve that describes how the opacity should animate over time.
 */
control1: Windows$Foundation$Point;

/**
 * Gets the location of the second control point for the cubic Bzier curve that describes how the opacity should animate over time.
 */
control2: Windows$Foundation$Point;

/**
 * Gets the amount of time between when the opacity animation is instructed to begin and when that animation actually begins to draw.
 */
delay: number;

/**
 * Gets the amount of time over which the opacity animation should be performed. This does not include the delay.
 */
duration: number;

/**
 * Gets the object's final opacity.
 */
finalOpacity: number;

/**
 * Gets the object's initial opacity.
 */
initialOpacity: number;

/**
 * Gets the type of animation represented by this object.
 */
type: $Values<typeof Windows$UI$Core$AnimationMetrics$PropertyAnimationType>
}


/**
 * Provides methods that enable you to retrieve animation property values that are common to all property animation types .
 */
declare class Windows$UI$Core$AnimationMetrics$PropertyAnimation  {

/**
 * Gets the location of the first control point for the cubic Bzier curve that describes how this property of this object should animate over time.
 */
control1: Windows$Foundation$Point;

/**
 * Gets the location of the second control point for the cubic Bzier curve that describes how this property of this object should animate over time.
 */
control2: Windows$Foundation$Point;

/**
 * Gets the amount of time between when the animation is instructed to begin and when that animation actually begins to draw.
 */
delay: number;

/**
 * Gets the amount of time over which the animation should be performed. This does not include the delay.
 */
duration: number;

/**
 * Gets the type of animation represented by this object.
 */
type: $Values<typeof Windows$UI$Core$AnimationMetrics$PropertyAnimationType>
}


/**
 * Specifies the animation type represented by a PropertyAnimation object.
 */

declare  var Windows$UI$Core$AnimationMetrics$PropertyAnimationType: {|
  +scale: 0,// 0
+translation: 1,// 1
+opacity: 2,// 2

|};



/**
 * Provides methods that enable you to retrieve the parameters for a scaling (growing or shrinking) animation.
 */
declare class Windows$UI$Core$AnimationMetrics$ScaleAnimation  {

/**
 * Gets the location of the first control point for the cubic Bzier curve that describes how the scale should animate over time.
 */
control1: Windows$Foundation$Point;

/**
 * Gets the location of the second control point for the cubic Bzier curve that describes how the scale should animate over time.
 */
control2: Windows$Foundation$Point;

/**
 * Gets the amount of time between when the scale animation is instructed to begin and when that animation actually begins to draw.
 */
delay: number;

/**
 * Gets the amount of time over which the scale animation should be performed. This does not include the delay.
 */
duration: number;

/**
 * Gets the final horizontal scale factor for the object.
 */
finalScaleX: number;

/**
 * Gets the final vertical scale factor for the object.
 */
finalScaleY: number;

/**
 * Gets the initial horizontal scale factor for the object.
 */
initialScaleX: number;

/**
 * Gets the initial vertical scale factor for the object.
 */
initialScaleY: number;

/**
 * Gets the center point for the scaling animation, expressed as a point relative to the object's normal size.
 */
normalizedOrigin: Windows$Foundation$Point;

/**
 * Gets the type of animation represented by this object.
 */
type: $Values<typeof Windows$UI$Core$AnimationMetrics$PropertyAnimationType>
}


/**
 * Provides methods that enable you to retrieve the parameters for a translation (move to a new location) animation.
 */
declare class Windows$UI$Core$AnimationMetrics$TranslationAnimation  {

/**
 * Gets the location of the first control point for the cubic Bzier curve that describes how the translation should animate over time.
 */
control1: Windows$Foundation$Point;

/**
 * Gets the location of the second control point for the cubic Bzier curve that describes how the translation should animate over time.
 */
control2: Windows$Foundation$Point;

/**
 * Gets the amount of time between when the translation animation is instructed to begin and when that animation actually begins to draw.
 */
delay: number;

/**
 * Gets the amount of time over which the translation animation should be performed. This does not include the delay.
 */
duration: number;

/**
 * Gets the type of animation represented by this object.
 */
type: $Values<typeof Windows$UI$Core$AnimationMetrics$PropertyAnimationType>
}


/**
 * Describes properties of animations that are common to all animation effects.
 */
declare interface Windows$UI$Core$AnimationMetrics$IPropertyAnimation {

/**
 * Gets the location of the first control point for the cubic Bzier curve that describes how this property of this object should animate over time.
 */
control1: Windows$Foundation$Point,

/**
 * Gets the location of the second control point for the cubic Bzier curve that describes how this property of this object should animate over time.
 */
control2: Windows$Foundation$Point,

/**
 * Gets the amount of time between when the animation is instructed to begin and when that animation actually begins to draw.
 */
delay: number,

/**
 * Gets the amount of time over which the animation should be performed. This does not include the delay.
 */
duration: number,

/**
 * Gets the type of animation represented by this object.
 */
type: $Values<typeof Windows$UI$Core$AnimationMetrics$PropertyAnimationType>
} 


/**
 * Defines constants that specify whether the back button is shown in the system UI.
 */

declare  var Windows$UI$Core$AppViewBackButtonVisibility: {|
  +visible: 0,// 0
+collapsed: 1,// 1

|};



/**
 * Provides event data for the SystemNavigationManager.BackRequested event.
 */
declare class Windows$UI$Core$BackRequestedEventArgs  {

/**
 * Gets or sets a value that indicates whether the app performed the requested back-navigation.
 */
handled: boolean
}


/**
 * Provides a way for an app to respond to system provided back-navigation events.
 */
declare class Windows$UI$Core$SystemNavigationManager  {

/**
 * Returns the SystemNavigationManager object associated with the current window.
 * @return The SystemNavigationManager object associated with the current window.
 */
static getForCurrentView(): Windows$UI$Core$SystemNavigationManager;

/**
 * Gets or sets a value that indicates whether a back button is shown in the system UI.
 */
appViewBackButtonVisibility: $Values<typeof Windows$UI$Core$AppViewBackButtonVisibility>;

/**
 * Occurs when the user invokes the system provided button, gesture, or voice command for back-navigation.
 */
onbackrequested: Windows$Foundation$EventHandler<any>;
addEventListener(type: "backrequested", listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: "backrequested", listener: Windows$Foundation$EventHandler<any>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


      declare var npm$namespace$Windows$UI$Input: {
        
        
        CrossSlidingState: typeof Windows$UI$Input$CrossSlidingState,
DraggingState: typeof Windows$UI$Input$DraggingState,
EdgeGestureKind: typeof Windows$UI$Input$EdgeGestureKind,
GestureSettings: typeof Windows$UI$Input$GestureSettings,
HoldingState: typeof Windows$UI$Input$HoldingState,
PointerUpdateKind: typeof Windows$UI$Input$PointerUpdateKind,
        CrossSlidingEventArgs: typeof Windows$UI$Input$CrossSlidingEventArgs,
DraggingEventArgs: typeof Windows$UI$Input$DraggingEventArgs,
EdgeGesture: typeof Windows$UI$Input$EdgeGesture,
EdgeGestureEventArgs: typeof Windows$UI$Input$EdgeGestureEventArgs,
GestureRecognizer: typeof Windows$UI$Input$GestureRecognizer,
HoldingEventArgs: typeof Windows$UI$Input$HoldingEventArgs,
KeyboardDeliveryInterceptor: typeof Windows$UI$Input$KeyboardDeliveryInterceptor,
ManipulationCompletedEventArgs: typeof Windows$UI$Input$ManipulationCompletedEventArgs,
ManipulationInertiaStartingEventArgs: typeof Windows$UI$Input$ManipulationInertiaStartingEventArgs,
ManipulationStartedEventArgs: typeof Windows$UI$Input$ManipulationStartedEventArgs,
ManipulationUpdatedEventArgs: typeof Windows$UI$Input$ManipulationUpdatedEventArgs,
MouseWheelParameters: typeof Windows$UI$Input$MouseWheelParameters,
PointerPoint: typeof Windows$UI$Input$PointerPoint,
PointerPointProperties: typeof Windows$UI$Input$PointerPointProperties,
PointerVisualizationSettings: typeof Windows$UI$Input$PointerVisualizationSettings,
RightTappedEventArgs: typeof Windows$UI$Input$RightTappedEventArgs,
TappedEventArgs: typeof Windows$UI$Input$TappedEventArgs,
        Inking: typeof npm$namespace$Windows$UI$Input$Inking,
Spatial: typeof npm$namespace$Windows$UI$Input$Spatial,
      }

/**
 * Contains event data for the CrossSliding event.
 */
declare class Windows$UI$Input$CrossSlidingEventArgs  {

/**
 * Gets the state of the CrossSliding event.
 */
crossSlidingState: $Values<typeof Windows$UI$Input$CrossSlidingState>;

/**
 * Gets the device type of the input source.
 */
pointerDeviceType: $Values<typeof Windows$Devices$Input$PointerDeviceType>;

/**
 * Gets the location of the touch contact.
 */
position: Windows$Foundation$Point
}


/**
 * Specifies the possible states of the CrossSliding event.
 */

declare  var Windows$UI$Input$CrossSlidingState: {|
  +started: 0,// 0
+dragging: 1,// 1
+selecting: 2,// 2
+selectSpeedBumping: 3,// 3
+speedBumping: 4,// 4
+rearranging: 5,// 5
+completed: 6,// 6

|};



/**
 * Contains event data for the Dragging event.
 */
declare class Windows$UI$Input$DraggingEventArgs  {

/**
 * Gets the state of the Dragging event.
 */
draggingState: $Values<typeof Windows$UI$Input$DraggingState>;

/**
 * Gets the device type of the input source.
 */
pointerDeviceType: $Values<typeof Windows$Devices$Input$PointerDeviceType>;

/**
 * Gets the location of the mouse or pen/stylus contact.
 */
position: Windows$Foundation$Point
}


/**
 * Specifies the possible states of the Dragging event.
 */

declare  var Windows$UI$Input$DraggingState: {|
  +started: 0,// 0
+continuing: 1,// 1
+completed: 2,// 2

|};



/**
 * Provides access to the events that notify an app of triggers to its edge-based UI.
 */
declare class Windows$UI$Input$EdgeGesture  {

/**
 * Gets an instance of the EdgeGesture class that is used to add and remove event delegate handlers for the current view.
 * @return The currently relevant instance of the EdgeGesture object.
 */
static getForCurrentView(): Windows$UI$Input$EdgeGesture;

/**
 * Fires when a user cancels a show or hide action for an edge-based UI.
 */
oncanceled: Windows$Foundation$TypedEventHandler<Windows$UI$Input$EdgeGesture, Windows$UI$Input$EdgeGestureEventArgs>;
addEventListener(
type: "canceled",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$EdgeGesture, Windows$UI$Input$EdgeGestureEventArgs>): void;
removeEventListener(
type: "canceled",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$EdgeGesture, Windows$UI$Input$EdgeGestureEventArgs>): void;

/**
 * Fires to indicate that the user has successfully summoned or dismissed the edge-based UI. This occurs either when the user lifts his or her finger from a touch-enabled screen or when the user presses Win+Z on the keyboard.
 */
oncompleted: Windows$Foundation$TypedEventHandler<Windows$UI$Input$EdgeGesture, Windows$UI$Input$EdgeGestureEventArgs>;
addEventListener(
type: "completed",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$EdgeGesture, Windows$UI$Input$EdgeGestureEventArgs>): void;
removeEventListener(
type: "completed",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$EdgeGesture, Windows$UI$Input$EdgeGestureEventArgs>): void;

/**
 * Fires when a user begins an action to summon or dismiss edge-based UI.
 */
onstarting: Windows$Foundation$TypedEventHandler<Windows$UI$Input$EdgeGesture, Windows$UI$Input$EdgeGestureEventArgs>;
addEventListener(
type: "starting",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$EdgeGesture, Windows$UI$Input$EdgeGestureEventArgs>): void;
removeEventListener(
type: "starting",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$EdgeGesture, Windows$UI$Input$EdgeGestureEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides access to the type of user input that triggered the edge gesture event.
 */
declare class Windows$UI$Input$EdgeGestureEventArgs  {

/**
 * Gets the type of user input that triggered the edge gesture event.
 */
kind: $Values<typeof Windows$UI$Input$EdgeGestureKind>
}


/**
 * Specifies the type of user input that triggered the edge gesture event.
 */

declare  var Windows$UI$Input$EdgeGestureKind: {|
  +touch: 0,// 0
+keyboard: 1,// 1
+mouse: 2,// 2

|};



/**
 * Provides gesture and manipulation recognition, event listeners, and settings.
 */
declare class Windows$UI$Input$GestureRecognizer  {

/**
 * Initializes a new instance of a GestureRecognizer object.
 */
constructor(): this;

/**
 * Gets or sets a value that indicates whether manipulations during inertia are generated automatically.
 */
autoProcessInertia: boolean;

/**
 * Identifies whether a tap can still be interpreted as the second tap of a double tap gesture.
 * @param value The last input pointer.
 * @return True if a UI element supports the double tap gesture and the time threshold to complete the gesture has not been crossed; otherwise false.
 */
canBeDoubleTap(value: Windows$UI$Input$PointerPoint): boolean;

/**
 * Causes the gesture recognizer to finalize an interaction.
 */
completeGesture(): void;

/**
 * Gets or sets a value that indicates whether the exact distance from initial contact to end of the cross-slide interaction is reported.
 */
crossSlideExact: boolean;

/**
 * Gets or sets a value that indicates whether the cross-slide axis is horizontal.
 */
crossSlideHorizontally: boolean;

/**
 * Gets or sets values that indicate the distance thresholds for a CrossSliding interaction.
 */
crossSlideThresholds: Windows$UI$Input$CrossSlideThresholds;

/**
 * Gets or sets a value that indicates the gesture and manipulation settings supported by an application.
 */
gestureSettings: $Values<typeof Windows$UI$Input$GestureSettings>;

/**
 * Gets or sets a value that indicates the relative change in size of an object from the start of inertia to the end of inertia (when resizing, or scaling, is complete).
 */
inertiaExpansion: number;

/**
 * Gets or sets a value that indicates the rate of deceleration from the start of inertia to the end of inertia (when the resizing, or expansion, manipulation is complete).
 */
inertiaExpansionDeceleration: number;

/**
 * Gets or sets a value that indicates the final angle of rotation of an object at the end of inertia (when the rotation manipulation is complete).
 */
inertiaRotationAngle: number;

/**
 * Gets or sets a value that indicates the rate of deceleration from the start of inertia to the end of inertia (when the rotation manipulation is complete).
 */
inertiaRotationDeceleration: number;

/**
 * Gets or sets a value that indicates the rate of deceleration from the start of inertia to the end of inertia (when the translation manipulation is complete).
 */
inertiaTranslationDeceleration: number;

/**
 * Gets or sets a value that indicates the relative change in the screen location of an object from the start of inertia to the end of inertia (when the translation manipulation is complete).
 */
inertiaTranslationDisplacement: number;

/**
 * Gets a value that indicates whether an interaction is being processed.
 */
isActive: boolean;

/**
 * Gets a value that indicates whether a manipulation is still being processed during inertia (no input points are active).
 */
isInertial: boolean;

/**
 * Gets or sets a value that indicates whether the exact distance from initial contact to end of the interaction is reported.
 */
manipulationExact: boolean;

/**
 * Gets a set of properties that are associated with the wheel button of a mouse device.
 */
mouseWheelParameters: Windows$UI$Input$MouseWheelParameters;

/**
 * Occurs when a user performs a slide or swipe gesture (through a single touch contact) within a content area that supports panning along a single axis only. The gesture must occur in a direction that is perpendicular to this panning axis.
 */
oncrosssliding: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$CrossSlidingEventArgs>;
addEventListener(
type: "crosssliding",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$CrossSlidingEventArgs>): void;
removeEventListener(
type: "crosssliding",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$CrossSlidingEventArgs>): void;

/**
 * Occurs when a user performs a slide or swipe gesture with a mouse or pen/stylus (single contact).
 */
ondragging: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$DraggingEventArgs>;
addEventListener(
type: "dragging",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$DraggingEventArgs>): void;
removeEventListener(
type: "dragging",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$DraggingEventArgs>): void;

/**
 * Occurs when a user performs a press and hold gesture (with a single touch, mouse, or pen/stylus contact).
 */
onholding: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$HoldingEventArgs>;
addEventListener(
type: "holding",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$HoldingEventArgs>): void;
removeEventListener(
type: "holding",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$HoldingEventArgs>): void;

/**
 * Occurs when the input points are lifted and all subsequent motion (translation, expansion, or rotation) through inertia has ended.
 */
onmanipulationcompleted: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$ManipulationCompletedEventArgs>;
addEventListener(
type: "manipulationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$ManipulationCompletedEventArgs>): void;
removeEventListener(
type: "manipulationcompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$ManipulationCompletedEventArgs>): void;

/**
 * Occurs when all contact points are lifted during a manipulation and the velocity of the manipulation is significant enough to initiate inertia behavior (translation, expansion, or rotation continue after the input pointers are lifted).
 */
onmanipulationinertiastarting: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$ManipulationInertiaStartingEventArgs>;
addEventListener(
type: "manipulationinertiastarting",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$ManipulationInertiaStartingEventArgs>): void;
removeEventListener(
type: "manipulationinertiastarting",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$ManipulationInertiaStartingEventArgs>): void;

/**
 * Occurs when one or more input points have been initiated and subsequent motion (translation, expansion, or rotation) has begun.
 */
onmanipulationstarted: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$ManipulationStartedEventArgs>;
addEventListener(
type: "manipulationstarted",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$ManipulationStartedEventArgs>): void;
removeEventListener(
type: "manipulationstarted",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$ManipulationStartedEventArgs>): void;

/**
 * Occurs after one or more input points have been initiated and subsequent motion (translation, expansion, or rotation) is under way.
 */
onmanipulationupdated: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$ManipulationUpdatedEventArgs>;
addEventListener(
type: "manipulationupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$ManipulationUpdatedEventArgs>): void;
removeEventListener(
type: "manipulationupdated",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$ManipulationUpdatedEventArgs>): void;

/**
 * Occurs when the pointer input is interpreted as a right-tap gesture, regardless of input device.
 */
onrighttapped: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$RightTappedEventArgs>;
addEventListener(
type: "righttapped",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$RightTappedEventArgs>): void;
removeEventListener(
type: "righttapped",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$RightTappedEventArgs>): void;

/**
 * Occurs when the pointer input is interpreted as a tap gesture.
 */
ontapped: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$TappedEventArgs>;
addEventListener(
type: "tapped",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$TappedEventArgs>): void;
removeEventListener(
type: "tapped",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$GestureRecognizer, Windows$UI$Input$TappedEventArgs>): void;

/**
 * Gets or sets the center point for a rotation interaction when single pointer input is detected.
 */
pivotCenter: Windows$Foundation$Point;

/**
 * Gets or sets the radius, from the PivotCenter to the pointer input, for a rotation interaction when single pointer input is detected.
 */
pivotRadius: number;

/**
 * Processes pointer input and raises the GestureRecognizer events appropriate to a pointer down action for the gestures and manipulations specified by the GestureSettings property.
 * @param value The input point.
 */
processDownEvent(value: Windows$UI$Input$PointerPoint): void;

/**
 * Performs inertia calculations and raises the various inertia events.
 */
processInertia(): void;

/**
 * Processes pointer input and raises the GestureRecognizer events appropriate to a mouse wheel action for the gestures and manipulations specified by the GestureSettings property.
 * @param value The input point.
 * @param isShiftKeyDown True if the Shift key is pressed; otherwise false.
 * @param isControlKeyDown True if the Ctrl key is pressed.
 */
processMouseWheelEvent(
value: Windows$UI$Input$PointerPoint,
isShiftKeyDown: boolean,
isControlKeyDown: boolean): void;

/**
 * Processes pointer input and raises the GestureRecognizer events appropriate to a pointer move action for the gestures and manipulations specified by the GestureSettings property.
 * @param value The pointer location history based on the PointerId . If no history is available then the value is the current location of the input pointer.
 */
processMoveEvents(
value: Windows$Foundation$Collections$IVector<Windows$UI$Input$PointerPoint>): void;

/**
 * Processes pointer input and raises the GestureRecognizer events appropriate to a pointer up action for the gestures and manipulations specified by the GestureSettings property.
 * @param value The input point.
 */
processUpEvent(value: Windows$UI$Input$PointerPoint): void;

/**
 * Gets or sets a value that indicates whether visual feedback is displayed during an interaction.
 */
showGestureFeedback: boolean;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Specifies the interactions that are supported by an application.
 */

declare  var Windows$UI$Input$GestureSettings: {|
  +none: 0,// 0
+tap: 1,// 1
+doubleTap: 2,// 2
+hold: 3,// 3
+holdWithMouse: 4,// 4
+rightTap: 5,// 5
+drag: 6,// 6
+manipulationTranslateX: 7,// 7
+manipulationTranslateY: 8,// 8
+manipulationTranslateRailsX: 9,// 9
+manipulationTranslateRailsY: 10,// 10
+manipulationRotate: 11,// 11
+manipulationScale: 12,// 12
+manipulationTranslateInertia: 13,// 13
+manipulationRotateInertia: 14,// 14
+manipulationScaleInertia: 15,// 15
+crossSlide: 16,// 16
+manipulationMultipleFingerPanning: 17,// 17

|};



/**
 * Contains event data for the Holding event.
 */
declare class Windows$UI$Input$HoldingEventArgs  {

/**
 * Gets the state of the Holding event.
 */
holdingState: $Values<typeof Windows$UI$Input$HoldingState>;

/**
 * Gets the device type of the input source.
 */
pointerDeviceType: $Values<typeof Windows$Devices$Input$PointerDeviceType>;

/**
 * Gets the location of the touch, mouse, or pen/stylus contact.
 */
position: Windows$Foundation$Point
}


/**
 * Specifies the state of the Holding event.
 */

declare  var Windows$UI$Input$HoldingState: {|
  +started: 0,// 0
+completed: 1,// 1
+canceled: 2,// 2

|};



      declare var npm$namespace$Windows$UI$Input$Inking: {
        
        
        InkManipulationMode: typeof Windows$UI$Input$Inking$InkManipulationMode,
InkRecognitionTarget: typeof Windows$UI$Input$Inking$InkRecognitionTarget,
PenTipShape: typeof Windows$UI$Input$Inking$PenTipShape,
        InkDrawingAttributes: typeof Windows$UI$Input$Inking$InkDrawingAttributes,
InkManager: typeof Windows$UI$Input$Inking$InkManager,
InkPoint: typeof Windows$UI$Input$Inking$InkPoint,
InkRecognitionResult: typeof Windows$UI$Input$Inking$InkRecognitionResult,
InkRecognizer: typeof Windows$UI$Input$Inking$InkRecognizer,
InkRecognizerContainer: typeof Windows$UI$Input$Inking$InkRecognizerContainer,
InkStroke: typeof Windows$UI$Input$Inking$InkStroke,
InkStrokeBuilder: typeof Windows$UI$Input$Inking$InkStrokeBuilder,
InkStrokeContainer: typeof Windows$UI$Input$Inking$InkStrokeContainer,
InkStrokeRenderingSegment: typeof Windows$UI$Input$Inking$InkStrokeRenderingSegment,
        
      }



/**
 * Provides properties associated with the drawing of an InkStroke .
 */
declare class Windows$UI$Input$Inking$InkDrawingAttributes  {

/**
 * Creates a new InkDrawingAttributes object that is used to specify InkStroke attributes.
 */
constructor(): this;

/**
 * Gets or sets a value that indicates the color of an InkStroke .
 */
color: Windows$UI$Color;

/**
 * Gets or sets a value that indicates whether the InkStroke is rendered as a highlighter overlay. The stroke is typically set to a bright color, such as yellow.
 */
drawAsHighlighter: boolean;

/**
 * Gets or sets a value that indicates whether a Bezier curve or a collection of straight line segments is used to draw an InkStroke .
 */
fitToCurve: boolean;

/**
 * Gets or sets a value that indicates whether the pressure of the contact on the digitizer surface is ignored when you draw an InkStroke .
 */
ignorePressure: boolean;

/**
 * Gets or sets a value that indicates the shape of the pen tip when you draw an InkStroke .
 */
penTip: $Values<typeof Windows$UI$Input$Inking$PenTipShape>;

/**
 * Gets or sets an affine transformation matrix applied to the PenTipShape used for an InkStroke .
 */
penTipTransform: Windows$Foundation$Numerics$Matrix3x2;

/**
 * Gets or sets a value that indicates the dimensions of the pen tip ( PenTip ) when you draw an InkStroke .
 */
size: Windows$Foundation$Size
}


/**
 * Provides properties and methods to manage the input, manipulation, and processing (including handwriting recognition) of one or more InkStroke objects.
 */
declare class Windows$UI$Input$Inking$InkManager  {

/**
 * Creates a new InkManager object that is used to manage InkStroke objects.
 */
constructor(): this;

/**
 * Adds one or more InkStroke objects to the collection managed by the InkManager .
 * @param stroke The ink stroke to be added.
 */
addStroke(stroke: Windows$UI$Input$Inking$InkStroke): void;

/**
 * Gets the bounding rectangle of the InkStroke collection that is managed by the InkManager .
 */
boundingRect: Windows$Foundation$Rect;

/**
 * Identifies whether content on the clipboard can be added to the InkStroke collection that is managed by the InkManager .
 * @return True if content can be pasted from the clipboard; otherwise, false.
 */
canPasteFromClipboard(): boolean;

/**
 * Copies the selected InkStroke objects (from the InkStroke collection managed by the InkManager ) to the clipboard in Ink Serialized Format (ISF) format.
 */
copySelectedToClipboard(): void;

/**
 * Deletes the selected InkStroke objects from the InkStroke collection managed by the InkManager .
 * @return The bounding rectangle of the selected ink strokes, or the invalidated rectangle (0, 0, 0, 0) if no strokes were removed (no selected strokes).
 */
deleteSelected(): Windows$Foundation$Rect;

/**
 * Retrieves the collection of words returned by handwriting recognition.
 * @return The words returned by the handwriting recognizer as a collection of InkRecognitionResult objects.
 */
getRecognitionResults(
): Windows$Foundation$Collections$IVectorView<Windows$UI$Input$Inking$InkRecognitionResult>;

/**
 * Gets the collection of installed handwriting recognizers.
 * @return The installed handwriting recognizers as a collection of InkRecognizer objects.
 */
getRecognizers(
): Windows$Foundation$Collections$IVectorView<Windows$UI$Input$Inking$InkRecognizer>;

/**
 * Retrieves all ink strokes in the collection managed by the InkManager .
 * @return The ink strokes managed by the InkManager as a collection of InkStroke objects.
 */
getStrokes(
): Windows$Foundation$Collections$IVectorView<Windows$UI$Input$Inking$InkStroke>;

/**
 * Asynchronously loads all InkStroke objects from the specified stream to the InkStroke collection that is managed by the InkManager .
 * @param inputStream The stream that contains the stroke collection. An IRandomAccessStream (requires IOutputStream ) object can be specified instead.
 * @return The status of the asynchronous operation as the number of bytes fetched. For more information, see ReadAsync method.
 */
loadAsync(
inputStream: Windows$Storage$Streams$IInputStream): Windows$Foundation$IPromiseWithIAsyncActionWithProgress<number>;

/**
 * Gets or sets the ink input mode.
 */
mode: $Values<typeof Windows$UI$Input$Inking$InkManipulationMode>;

/**
 * Moves the selected strokes. All affected strokes are re-rendered.
 * @param translation The destination screen coordinates for the upper-left corner of the bounding rectangle of the selected strokes.
 * @return The bounding rectangle of the selected ink strokes.
 */
moveSelected(translation: Windows$Foundation$Point): Windows$Foundation$Rect;

/**
 * Adds the InkStroke content from the clipboard to the InkStroke collection that is managed by the InkManager and renders the new strokes..
 * @param position The screen coordinates for the upper-left corner of the bounding rectangle of the clipboard content.
 * @return The invalidated bounding rectangle of the InkStroke collection.
 */
pasteFromClipboard(position: Windows$Foundation$Point): Windows$Foundation$Rect;

/**
 * Processes information about the position and features of the contact point, like pressure and tilt, on initial down contact. You must call this method before you call ProcessPointerUpdate , and then ProcessPointerUp.
 * @param pointerPoint Information about the position and features of the contact point.
 */
processPointerDown(pointerPoint: Windows$UI$Input$PointerPoint): void;

/**
 * Processes information about the position and features of the contact point, like pressure and tilt, on up contact. You must call this method after you call ProcessPointerUpdate .
 * @param pointerPoint Information about the position and features of the contact point.
 * @return For Inking and Selecting modes, this is the bounding box for the stroke (invalidated rectangle). For Erasing mode, the invalidated rectangle is (0,0,0,0).
 */
processPointerUp(pointerPoint: Windows$UI$Input$PointerPoint): Windows$Foundation$Rect;

/**
 * Processes position and state properties, such as pressure and tilt, for the specified pointer, from the last pointer event up to and including the current pointer event.
 * @param pointerPoint The input pointer for which updates are to be processed.
 * @return When the current InkManipulationMode is Inking or Selecting, this method returns the Point (screen position in ink space) associated with the last ProcessPointerUpdate of pointerPoint.
 */
processPointerUpdate(pointerPoint: Windows$UI$Input$PointerPoint): any;

/**
 * Performs handwriting recognition on one or more InkStroke objects.
 * @param recognitionTarget One of the values from the InkRecognitionTarget enumeration.
 * @return The results of the recognition as a collection of InkRecognitionResult objects.
 */
recognizeAsync(
recognitionTarget: $Values<typeof Windows$UI$Input$Inking$InkRecognitionTarget>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Performs handwriting recognition on one or more InkStroke objects.
 * @param strokeCollection The set of strokes on which recognition is performed.
 * @param recognitionTarget One of the values from the InkRecognitionTarget enumeration.
 * @return The results of the recognition as a collection of InkRecognitionResult objects.
 */
recognizeAsync(
strokeCollection: Windows$UI$Input$Inking$InkStrokeContainer,
recognitionTarget: $Values<typeof Windows$UI$Input$Inking$InkRecognitionTarget>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Asynchronously saves all InkStroke objects in the InkStroke collection that is managed by the InkManager to the specified stream.
 * @param outputStream The target stream. An IRandomAccessStream (requires IOutputStream ) object can be specified instead.
 * @return The size of the saved stream and the status of the asynchronous operation as the number of bytes sent. For more information, see WriteAsync method.
 */
saveAsync(
outputStream: Windows$Storage$Streams$IOutputStream): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>;

/**
 * Selects all strokes intersected by the new stroke.
 * @param from The start of the stroke.
 * @param to The end of the stroke.
 * @return The bounding rectangle of the selected ink strokes.
 */
selectWithLine(
from: Windows$Foundation$Point,
to: Windows$Foundation$Point): Windows$Foundation$Rect;

/**
 * Selects all strokes contained entirely within the polyline.
 * @param polyline The points of the polyline.
 * @return The bounding rectangle of the selected ink strokes.
 */
selectWithPolyLine(
polyline: Windows$Foundation$Collections$IIterable<Windows$Foundation$Point>): Windows$Foundation$Rect;

/**
 * Sets the default InkDrawingAttributes for all new InkStroke objects added to the InkStroke collection managed by the InkManager .
 * @param drawingAttributes The default attributes applied to a new ink stroke.
 */
setDefaultDrawingAttributes(drawingAttributes: Windows$UI$Input$Inking$InkDrawingAttributes): void;

/**
 * Sets the default InkRecognizer used for handwriting recognition.
 * @param recognizer The InkRecognizer .
 */
setDefaultRecognizer(recognizer: Windows$UI$Input$Inking$InkRecognizer): void;

/**
 * Updates the collection of potential text matches from handwriting recognition.
 * @param recognitionResults The results returned by recognition, where each InkRecognitionResult object represents one written word.
 */
updateRecognitionResults(
recognitionResults: Windows$Foundation$Collections$IVectorView<Windows$UI$Input$Inking$InkRecognitionResult>): void
}


/**
 * Identifies the ink input mode.
 */

declare  var Windows$UI$Input$Inking$InkManipulationMode: {|
  +inking: 0,// 0
+erasing: 1,// 1
+selecting: 2,// 2

|};


declare class Windows$UI$Input$Inking$InkPoint  {

/**
 * Creates a new InkPoint object used in the construction of an InkStroke .
 * @param position The screen coordinates for the InkPoint object.
 * @param pressure The pressure of the contact on the digitizer surface. The default is 0.5.
 */
constructor(position: Windows$Foundation$Point, pressure: number): this;

/**
 * The X, Y coordinates of the InkPoint , in device-independent pixels (DIPs) relative to the upper left-hand corner of the inking area.
 */
position: Windows$Foundation$Point;
pressure: any
}


/**
 * Provides properties and methods to manage InkStroke handwriting recognition data.
 */
declare class Windows$UI$Input$Inking$InkRecognitionResult  {

/**
 * Gets the bounding rectangle of the InkStroke data used for handwriting recognition.
 */
boundingRect: Windows$Foundation$Rect;

/**
 * Retrieves all ink strokes used for handwriting recognition.
 * @return The ink strokes used for handwriting recognition as a collection of InkStroke objects.
 */
getStrokes(
): Windows$Foundation$Collections$IVectorView<Windows$UI$Input$Inking$InkStroke>;

/**
 * Retrieves the collection of strings identified as potential matches for each word returned by handwriting recognition.
 * @return The recognition matches as a collection of String objects. The most likely candidate is topmost in the collection.
 */
getTextCandidates(): Windows$Foundation$Collections$IVectorView<string>
}


/**
 * Indicates which strokes you want to include in handwriting recognition.
 */

declare  var Windows$UI$Input$Inking$InkRecognitionTarget: {|
  +all: 0,// 0
+selected: 1,// 1
+recent: 2,// 2

|};



/**
 * Manages all aspects of handwriting recognition.
 */
declare class Windows$UI$Input$Inking$InkRecognizer  {

/**
 * Gets the name of the InkRecognizer .
 */
name: string
}


/**
 * Provides properties and methods to manage one or more InkRecognizer objects used for handwriting recognition.
 */
declare class Windows$UI$Input$Inking$InkRecognizerContainer  {

/**
 * Creates a new InkRecognizerContainer object to manage InkRecognizer objects used for handwriting recognition.
 */
constructor(): this;

/**
 * Gets the collection of installed handwriting recognizers.
 * @return The installed handwriting recognizers as a collection of InkRecognizer objects.
 */
getRecognizers(
): Windows$Foundation$Collections$IVectorView<Windows$UI$Input$Inking$InkRecognizer>;

/**
 * Performs handwriting recognition on one or more InkStroke objects.
 * @param strokeCollection The set of strokes on which recognition is performed.
 * @param recognitionTarget One of the values from the InkRecognitionTarget enumeration.
 * @return The results of the recognition as a collection of InkRecognitionResult objects.
 */
recognizeAsync(
strokeCollection: Windows$UI$Input$Inking$InkStrokeContainer,
recognitionTarget: $Values<typeof Windows$UI$Input$Inking$InkRecognitionTarget>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Sets the default InkRecognizer used for handwriting recognition.
 * @param recognizer The InkRecognizer .
 */
setDefaultRecognizer(recognizer: Windows$UI$Input$Inking$InkRecognizer): void
}


/**
 * A single ink stroke, including the Bzier curve parameters used for final rendering of the stroke.
 */
declare class Windows$UI$Input$Inking$InkStroke  {

/**
 * Gets the bounding box for the InkStroke .
 */
boundingRect: Windows$Foundation$Rect;

/**
 * Copies the InkStroke to another InkManager (or InkStrokeContainer ).
 * @return The new stroke.
 */
clone(): Windows$UI$Input$Inking$InkStroke;

/**
 * Gets or sets the properties associated with an InkStroke .
 */
drawingAttributes: Windows$UI$Input$Inking$InkDrawingAttributes;

/**
 * Gets the collection of InkPoint objects used to construct the InkStroke .
 * @return The collection of InkPoint objects used to construct the InkStroke .
 */
getInkPoints(): Windows$Foundation$Collections$IVectorView<Windows$UI$Input$Inking$InkPoint>;

/**
 * Gets the rendering segments of the stroke.
 * @return The collection of InkStrokeRenderingSegment objects.
 */
getRenderingSegments(
): Windows$Foundation$Collections$IVectorView<Windows$UI$Input$Inking$InkStrokeRenderingSegment>;

/**
 * Gets or sets an affine transformation matrix to apply to the InkStroke object.
 */
pointTransform: Windows$Foundation$Numerics$Matrix3x2;

/**
 * Gets whether the stroke is recognized.
 */
recognized: boolean;

/**
 * Gets whether the stroke is selected.
 */
selected: boolean
}


/**
 * Builds strokes from raw pointer input.
 */
declare class Windows$UI$Input$Inking$InkStrokeBuilder  {

/**
 * Creates a new InkStrokeBuilder object that is used to construct InkStroke objects.
 */
constructor(): this;

/**
 * Adds a new segment to the ink stroke.
 * @param pointerPoint The end point of the new segment.
 * @return The previous end point. This end point can be used when rendering the stroke.
 */
appendToStroke(pointerPoint: Windows$UI$Input$PointerPoint): Windows$UI$Input$PointerPoint;

/**
 * Starts building the ink stroke.
 * @param pointerPoint The first point for the stroke.
 */
beginStroke(pointerPoint: Windows$UI$Input$PointerPoint): void;

/**
 * Creates a stroke from an array of Point coordinates.
 * @param points An array of Point coordinates.
 * @return The new stroke.
 */
createStroke(
points: Windows$Foundation$Collections$IIterable<Windows$Foundation$Point>): Windows$UI$Input$Inking$InkStroke;

/**
 * Creates a stroke from collection of InkPoint objects.
 * @param inkPoints The collection of InkPoint objects.
 * @param transform A 2-D transformation matrix.
 * @return The ink stroke, including the Bzier curve parameters used for final rendering of the stroke.
 */
createStrokeFromInkPoints(
inkPoints: Windows$Foundation$Collections$IIterable<Windows$UI$Input$Inking$InkPoint>,
transform: Windows$Foundation$Numerics$Matrix3x2): Windows$UI$Input$Inking$InkStroke;

/**
 * Stops building the ink stroke.
 * @param pointerPoint The last point for the stroke.
 * @return The stroke built from the points.
 */
endStroke(pointerPoint: Windows$UI$Input$PointerPoint): Windows$UI$Input$Inking$InkStroke;

/**
 * Sets the default InkDrawingAttributes for all new ink strokes created after the current stroke.
 * @param drawingAttributes The default attributes.
 */
setDefaultDrawingAttributes(drawingAttributes: Windows$UI$Input$Inking$InkDrawingAttributes): void
}


/**
 * Provides properties and methods to store and manage the collection of InkStroke objects rendered by the InkPresenter .
 */
declare class Windows$UI$Input$Inking$InkStrokeContainer  {

/**
 * Creates a new InkStrokeContainer object that is used to manage InkStroke objects.
 */
constructor(): this;

/**
 * Adds an InkStroke object to the collection managed by the InkStrokeContainer .
 * @param stroke The ink stroke to be added.
 */
addStroke(stroke: Windows$UI$Input$Inking$InkStroke): void;

/**
 * Adds one or more ink strokes to the collection managed by the InkStrokeContainer .
 * @param strokes The ink strokes to be added as a collection of InkStroke objects.
 */
addStrokes(
strokes: Windows$Foundation$Collections$IIterable<Windows$UI$Input$Inking$InkStroke>): void;

/**
 * Gets the bounding rectangle of the InkStroke collection managed by the InkStrokeContainer .
 */
boundingRect: Windows$Foundation$Rect;

/**
 * Identifies whether content on the clipboard can be added to the InkStroke collection managed by the InkStrokeContainer .
 * @return True if content can be pasted from the clipboard; otherwise, false.
 */
canPasteFromClipboard(): boolean;

/**
 * Deletes all InkStroke objects from the collection managed by the InkStrokeContainer .
 */
clear(): void;

/**
 * Copies the selected InkStroke objects (from the InkStroke collection managed by the InkStrokeContainer ) to the clipboard in Ink Serialized Format (ISF) format.
 */
copySelectedToClipboard(): void;

/**
 * Deletes the selected InkStroke objects from the InkStroke collection managed by the InkStrokeContainer .
 * @return The bounding rectangle of the selected ink strokes, or the invalidated rectangle (0, 0, 0, 0) if no strokes were removed (no selected strokes).
 */
deleteSelected(): Windows$Foundation$Rect;

/**
 * Gets the collection of recognition matches previously processed by an InkRecognizer and stored in an InkRecognizerContainer .
 * @return The results of the recognition as a collection of InkRecognitionResult objects.
 */
getRecognitionResults(
): Windows$Foundation$Collections$IVectorView<Windows$UI$Input$Inking$InkRecognitionResult>;

/**
 * Retrieves all ink strokes in the collection managed by the InkStrokeContainer .
 * @return The ink strokes managed by the InkStrokeContainer as a collection of InkStroke objects.
 */
getStrokes(
): Windows$Foundation$Collections$IVectorView<Windows$UI$Input$Inking$InkStroke>;

/**
 * Asynchronously loads all InkStroke objects from the specified stream to the InkStroke collection that is managed by the InkStrokeContainer .
 * @param inputStream The target stream.
 * @return The status of the asynchronous operation as the number of bytes fetched. For more information, see ReadAsync method.
 */
loadAsync(
inputStream: Windows$Storage$Streams$IInputStream): Windows$Foundation$IPromiseWithIAsyncActionWithProgress<number>;

/**
 * Moves the selected strokes. All affected strokes are re-rendered.
 * @param translation The destination screen coordinates for the upper-left corner of the bounding rectangle of the selected strokes.
 * @return The bounding rectangle of the selected ink strokes.
 */
moveSelected(translation: Windows$Foundation$Point): Windows$Foundation$Rect;

/**
 * Adds the InkStroke content from the clipboard to the InkStroke collection that is managed by the InkStrokeContainer and renders the new strokes..
 * @param position The screen coordinates for the upper-left corner of the bounding rectangle of the clipboard content.
 * @return The invalidated bounding rectangle of the InkStroke collection.
 */
pasteFromClipboard(position: Windows$Foundation$Point): Windows$Foundation$Rect;

/**
 * Asynchronously saves all InkStroke objects in the InkStroke collection that is managed by the InkStrokeContainer to the specified stream.
 * @param outputStream The target stream. An IRandomAccessStream (requires IOutputStream ) object can be specified instead.
 * @return The status of the asynchronous operation as the number of bytes sent. For more information, see WriteAsync method.
 */
saveAsync(
outputStream: Windows$Storage$Streams$IOutputStream): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>;

/**
 * Selects all strokes intersected by the new stroke.
 * @param from The start of the line.
 * @param to The of the line.
 * @return The bounding rectangle of the selected ink strokes.
 */
selectWithLine(
from: Windows$Foundation$Point,
to: Windows$Foundation$Point): Windows$Foundation$Rect;

/**
 * Selects all strokes contained entirely within the polyline.
 * @param polyline The points of the polyline.
 * @return The bounding rectangle of the selected ink strokes.
 */
selectWithPolyLine(
polyline: Windows$Foundation$Collections$IIterable<Windows$Foundation$Point>): Windows$Foundation$Rect;

/**
 * Updates the collection of recognition matches previously processed by an InkRecognizer and stored in an InkRecognizerContainer .
 * @param recognitionResults The updated collection of InkRecognitionResult objects.
 */
updateRecognitionResults(
recognitionResults: Windows$Foundation$Collections$IVectorView<Windows$UI$Input$Inking$InkRecognitionResult>): void
}


/**
 * A single segment of a complete ink stroke.
 */
declare class Windows$UI$Input$Inking$InkStrokeRenderingSegment  {

/**
 * Gets the first control point for the Bzier curve.
 */
bezierControlPoint1: Windows$Foundation$Point;

/**
 * Gets the second control point for the Bzier curve.
 */
bezierControlPoint2: Windows$Foundation$Point;

/**
 * Gets the end point of the segment.
 */
position: Windows$Foundation$Point;

/**
 * Gets the pressure of the contact on the digitizer surface.
 */
pressure: number;

/**
 * Gets the tilt of the contact along the x axis.
 */
tiltX: number;

/**
 * Gets the tilt of the contact along the y axis.
 */
tiltY: number;

/**
 * Gets the twist of the contact along the rotational axis.
 */
twist: number
}


/**
 * Identifies the shape of the PenTip .
 */

declare  var Windows$UI$Input$Inking$PenTipShape: {|
  +circle: 0,// 0
+rectangle: 1,// 1

|};



/**
 * Enables an app to override the system processing of raw keyboard input, including key combinations such as shortcut keys, access keys (or hot keys), accelerator keys, and application keys.
 */
declare class Windows$UI$Input$KeyboardDeliveryInterceptor  {

/**
 * Retrieves a KeyboardDeliveryInterceptor object associated with the current app view.
 * @return The KeyboardDeliveryInterceptor object associated with the current app.
 */
static getForCurrentView(): Windows$UI$Input$KeyboardDeliveryInterceptor;

/**
 * Gets or sets whether the app overrides the system processing of raw keyboard input, including key combinations such as shortcut keys, access keys (or hot keys), accelerator keys, and application keys.
 */
isInterceptionEnabledWhenInForeground: boolean;

/**
 * Occurs when a keyboard key is pressed. State info and event data is routed through this event instead of CoreWindow.KeyDown .
 */
onkeydown: Windows$Foundation$TypedEventHandler<Windows$UI$Input$KeyboardDeliveryInterceptor, any>;
addEventListener(
type: "keydown",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$KeyboardDeliveryInterceptor, any>): void;
removeEventListener(
type: "keydown",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$KeyboardDeliveryInterceptor, any>): void;

/**
 * Occurs when a pressed keyboard key is released. State info and event data is routed through this event instead of CoreWindow.KeyUp .
 */
onkeyup: Windows$Foundation$TypedEventHandler<Windows$UI$Input$KeyboardDeliveryInterceptor, any>;
addEventListener(
type: "keyup",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$KeyboardDeliveryInterceptor, any>): void;
removeEventListener(
type: "keyup",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Input$KeyboardDeliveryInterceptor, any>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Contains event data for the ManipulationCompleted event.
 */
declare class Windows$UI$Input$ManipulationCompletedEventArgs  {

/**
 * Gets values that indicate the accumulated transformation deltas (translation, rotation, scale) of a completed manipulation (from the start of the manipulation to the end of inertia).
 */
cumulative: Windows$UI$Input$ManipulationDelta;

/**
 * Gets the device type of the input source.
 */
pointerDeviceType: $Values<typeof Windows$Devices$Input$PointerDeviceType>;

/**
 * Gets the location of the pointer associated with the manipulation for the last manipulation event.
 */
position: Windows$Foundation$Point;

/**
 * Gets values that indicate the velocities of the transformation deltas (translation, rotation, scale) for a manipulation at the ManipulationCompleted event.
 */
velocities: Windows$UI$Input$ManipulationVelocities
}


/**
 * Contains event data for the GestureRecognizer.ManipulationInertiaStartingEvent .
 */
declare class Windows$UI$Input$ManipulationInertiaStartingEventArgs  {

/**
 * Gets values that indicate the accumulated transformation deltas (translation, rotation, scale) for a manipulation before inertia begins.
 */
cumulative: Windows$UI$Input$ManipulationDelta;

/**
 * Gets values that indicate the changes in the transformation deltas (translation, rotation, scale) of a manipulation since the last manipulation event.
 */
delta: Windows$UI$Input$ManipulationDelta;

/**
 * Gets the device type of the input source.
 */
pointerDeviceType: $Values<typeof Windows$Devices$Input$PointerDeviceType>;

/**
 * Gets the location of the pointer associated with the manipulation for the last manipulation event.
 */
position: Windows$Foundation$Point;

/**
 * Gets values that indicate the velocities of the transformation deltas (translation, rotation, scale) for a manipulation at the ManipulationInertiaStarting event.
 */
velocities: Windows$UI$Input$ManipulationVelocities
}


/**
 * Contains event data for the ManipulationStarted event.
 */
declare class Windows$UI$Input$ManipulationStartedEventArgs  {

/**
 * Gets values that indicate the accumulated transformation deltas (translation, rotation, scale) for a manipulation before the ManipulationStarted event.
 */
cumulative: Windows$UI$Input$ManipulationDelta;

/**
 * Gets the device type of the input source.
 */
pointerDeviceType: $Values<typeof Windows$Devices$Input$PointerDeviceType>;

/**
 * Gets the location of the pointer associated with the manipulation for the last manipulation event.
 */
position: Windows$Foundation$Point
}


/**
 * Contains event data for the ManipulationUpdated event.
 */
declare class Windows$UI$Input$ManipulationUpdatedEventArgs  {

/**
 * Gets values that indicate the accumulated transformation deltas (translation, rotation, scale) for a manipulation from the beginning of the interaction to the ManipulationUpdated event.
 */
cumulative: Windows$UI$Input$ManipulationDelta;

/**
 * Gets values that indicate the changes in the transformation deltas (translation, rotation, scale) of a manipulation since the last manipulation event.
 */
delta: Windows$UI$Input$ManipulationDelta;

/**
 * Gets the device type of the input source.
 */
pointerDeviceType: $Values<typeof Windows$Devices$Input$PointerDeviceType>;

/**
 * Gets the location of the pointer associated with the manipulation for the last manipulation event.
 */
position: Windows$Foundation$Point;

/**
 * Gets values that indicate the velocities of the transformation deltas (translation, rotation, scale) for a manipulation at the ManipulationUpdated event.
 */
velocities: Windows$UI$Input$ManipulationVelocities
}


/**
 * Provides properties associated with the button wheel of a mouse device.
 */
declare class Windows$UI$Input$MouseWheelParameters  {

/**
 * Gets or sets the device-independent pixel (DIP) conversion factors for both character width and line height units (as set in the Wheel settings of the Mouse control panel).
 */
charTranslation: Windows$Foundation$Point;

/**
 * Gets or sets a value that indicates the change in the angle of rotation associated with input from the wheel button of a mouse.
 */
deltaRotationAngle: number;

/**
 * Gets or sets a value that indicates the change in scale associated with input from the wheel button of a mouse.
 */
deltaScale: number;

/**
 * Gets or sets the device-independent pixel (DIP) conversion factors for both page width and height units (as set in the Wheel settings of the Mouse control panel).
 */
pageTranslation: Windows$Foundation$Point
}


/**
 * Provides basic properties for the input pointer associated with a single mouse, pen/stylus, or touch contact.
 */
declare class Windows$UI$Input$PointerPoint  {

/**
 * Retrieves position and state information for the specified pointer.
 * @param pointerId The ID of the pointer.
 * @return The pointer property values.
 */
static getCurrentPoint(pointerId: number): Windows$UI$Input$PointerPoint;

/**
 * Retrieves the transformed information for the specified pointer.
 * @param pointerId The ID of the pointer.
 * @param transform The transform to apply to the pointer.
 * @return The pointer property values.
 */
static getCurrentPoint(
pointerId: number,
transform: Windows$UI$Input$IPointerPointTransform): Windows$UI$Input$PointerPoint;

/**
 * Retrieves the transformed position and state information for the specified pointer, from the last pointer event up to and including the current pointer event.
 * @param pointerId The ID of the pointer.
 * @param transform The transform to apply to the pointer.
 * @return The transformed pointer properties (current and historic).
 */
static getIntermediatePoints(
pointerId: number,
transform: Windows$UI$Input$IPointerPointTransform): Windows$Foundation$Collections$IVector<Windows$UI$Input$PointerPoint>;

/**
 * Retrieves position and state information for the specified pointer, from the last pointer event up to and including the current pointer event.
 * @param pointerId The ID of the pointer.
 * @return The transformed pointer properties (current and historic).
 */
static getIntermediatePoints(
pointerId: number): Windows$Foundation$Collections$IVector<Windows$UI$Input$PointerPoint>;

/**
 * Gets the ID of an input frame.
 */
frameId: number;

/**
 * Gets a value that indicates whether the physical entity (touch, pen/stylus, or mouse button) is pressed down.
 */
isInContact: boolean;

/**
 * Gets information about the device associated with the input pointer.
 */
pointerDevice: Windows$Devices$Input$PointerDevice;

/**
 * Gets a unique identifier for the input pointer.
 */
pointerId: number;

/**
 * Gets the location of the pointer input in client coordinates.
 */
position: Windows$Foundation$Point;

/**
 * Gets extended information about the input pointer.
 */
properties: Windows$UI$Input$PointerPointProperties;

/**
 * Gets the raw location of the pointer input in client coordinates.
 */
rawPosition: Windows$Foundation$Point;

/**
 * Gets the time when the input occurred.
 */
timestamp: number
}


/**
 * Provides extended properties for a PointerPoint object.
 */
declare class Windows$UI$Input$PointerPointProperties  {

/**
 * Gets the bounding rectangle of the contact area (typically from touch input).
 */
contactRect: Windows$Foundation$Rect;

/**
 * Gets the bounding rectangle of the raw input (typically from touch input).
 */
contactRectRaw: Windows$Foundation$Rect;

/**
 * Gets the Human Interface Device (HID) usage value of the raw input.
 * @param usagePage The HID usage page of the pointer device.
 * @param usageId Indicates a usage in a usage page.
 * @return The extended usage of the raw input pointer.
 */
getUsageValue(usagePage: number, usageId: number): number;

/**
 * Gets a value that indicates whether the input data from the pointer device contains the specified Human Interface Device (HID) usage information.
 * @param usagePage The HID usage page of the pointer device.
 * @param usageId Indicates a usage in a usage page.
 * @return True if the input data includes usage information; otherwise false.
 */
hasUsage(usagePage: number, usageId: number): boolean;

/**
 * Gets a value that indicates whether the barrel button of the pen/stylus device is pressed.
 */
isBarrelButtonPressed: boolean;

/**
 * Gets a value that indicates whether the input was canceled by the pointer device.
 */
isCanceled: boolean;

/**
 * Gets a value that indicates whether the input is from a digitizer eraser.
 */
isEraser: boolean;

/**
 * Gets a value that indicates whether the input is from a mouse tilt wheel.
 */
isHorizontalMouseWheel: boolean;

/**
 * Gets a value that indicates whether the pointer device is within detection range of a sensor or digitizer.
 */
isInRange: boolean;

/**
 * Gets a value that indicates whether the digitizer pen is inverted.
 */
isInverted: boolean;

/**
 * Gets a value that indicates whether the input is from the left button of a mouse or other input method.
 */
isLeftButtonPressed: boolean;

/**
 * Gets a value that indicates whether the input is from the middle button of a mouse or other input method.
 */
isMiddleButtonPressed: boolean;

/**
 * Gets a value that indicates whether the input is from the primary pointer when multiple pointers are registered.
 */
isPrimary: boolean;

/**
 * Gets a value that indicates whether the input is from the right button of a mouse or other input method.
 */
isRightButtonPressed: boolean;

/**
 * Gets the pressed state of the first extended mouse button.
 */
isXButton1Pressed: boolean;

/**
 * Gets the pressed state of the second extended mouse button.
 */
isXButton2Pressed: boolean;

/**
 * Gets a value (the raw value reported by the device) that indicates the change in wheel button input from the last pointer event.
 */
mouseWheelDelta: number;

/**
 * Gets the counter-clockwise angle of rotation around the major axis of the pointer device (the z-axis, perpendicular to the surface of the digitizer). A value of 0.0 degrees indicates the device is oriented towards the top of the digitizer.
 */
orientation: number;

/**
 * Gets the kind of pointer state change.
 */
pointerUpdateKind: $Values<typeof Windows$UI$Input$PointerUpdateKind>;

/**
 * Gets a value that indicates the force that the pointer device (typically a pen/stylus) exerts on the surface of the digitizer.
 */
pressure: number;

/**
 * Gets a value that indicates whether the pointer device rejected the touch contact.
 */
touchConfidence: boolean;

/**
 * Gets the clockwise rotation in degrees of a pen device around its own major axis (such as when the user spins the pen in their fingers).
 */
twist: number;

/**
 * Gets the plane angle between the Y-Z plane and the plane that contains the Y axis and the axis of the input device (typically a pen/stylus).
 */
xtilt: number;

/**
 * Gets the plane angle between the X-Z plane and the plane that contains the X axis and the axis of the input device (typically a pen/stylus).
 */
ytilt: number;
zdistance: any
}


/**
 * Specifies the types of pointer updates that are supported by an application.
 */

declare  var Windows$UI$Input$PointerUpdateKind: {|
  +other: 0,// 0
+leftButtonPressed: 1,// 1
+leftButtonReleased: 2,// 2
+rightButtonPressed: 3,// 3
+rightButtonReleased: 4,// 4
+middleButtonPressed: 5,// 5
+middleButtonReleased: 6,// 6
+xbutton1Pressed: 7,// 7
+xbutton1Released: 8,// 8
+xbutton2Pressed: 9,// 9
+xbutton2Released: 10,// 10

|};



/**
 * Provides access to the visual feedback settings for pointer input.
 */
declare class Windows$UI$Input$PointerVisualizationSettings  {

/**
 * Gets a PointerVisualizationSettings object associated with the current app.
 * @return The PointerVisualizationSettings object associated with the current app.
 */
static getForCurrentView(): Windows$UI$Input$PointerVisualizationSettings;

/**
 * Gets or sets a value that indicates whether visual feedback is enabled for pen/stylus input when the barrel button is pressed.
 */
isBarrelButtonFeedbackEnabled: boolean;

/**
 * Gets or sets a value that indicates whether visual feedback is enabled when a pointer contact is detected.
 */
isContactFeedbackEnabled: boolean
}


/**
 * Contains event data for the RightTapped event.
 */
declare class Windows$UI$Input$RightTappedEventArgs  {

/**
 * Gets the device type of the input source.
 */
pointerDeviceType: $Values<typeof Windows$Devices$Input$PointerDeviceType>;

/**
 * Gets the location of the touch, mouse, or pen/stylus contact.
 */
position: Windows$Foundation$Point
}


      declare var npm$namespace$Windows$UI$Input$Spatial: {
        
        
        
        SpatialGestureRecognizer: typeof Windows$UI$Input$Spatial$SpatialGestureRecognizer,
SpatialHoldCanceledEventArgs: typeof Windows$UI$Input$Spatial$SpatialHoldCanceledEventArgs,
SpatialHoldCompletedEventArgs: typeof Windows$UI$Input$Spatial$SpatialHoldCompletedEventArgs,
SpatialHoldStartedEventArgs: typeof Windows$UI$Input$Spatial$SpatialHoldStartedEventArgs,
SpatialInteraction: typeof Windows$UI$Input$Spatial$SpatialInteraction,
SpatialInteractionDetectedEventArgs: typeof Windows$UI$Input$Spatial$SpatialInteractionDetectedEventArgs,
SpatialInteractionManager: typeof Windows$UI$Input$Spatial$SpatialInteractionManager,
SpatialInteractionSource: typeof Windows$UI$Input$Spatial$SpatialInteractionSource,
SpatialInteractionSourceEventArgs: typeof Windows$UI$Input$Spatial$SpatialInteractionSourceEventArgs,
SpatialInteractionSourceLocation: typeof Windows$UI$Input$Spatial$SpatialInteractionSourceLocation,
SpatialInteractionSourceProperties: typeof Windows$UI$Input$Spatial$SpatialInteractionSourceProperties,
SpatialInteractionSourceState: typeof Windows$UI$Input$Spatial$SpatialInteractionSourceState,
SpatialManipulationCanceledEventArgs: typeof Windows$UI$Input$Spatial$SpatialManipulationCanceledEventArgs,
SpatialManipulationCompletedEventArgs: typeof Windows$UI$Input$Spatial$SpatialManipulationCompletedEventArgs,
SpatialManipulationDelta: typeof Windows$UI$Input$Spatial$SpatialManipulationDelta,
SpatialManipulationStartedEventArgs: typeof Windows$UI$Input$Spatial$SpatialManipulationStartedEventArgs,
SpatialManipulationUpdatedEventArgs: typeof Windows$UI$Input$Spatial$SpatialManipulationUpdatedEventArgs,
SpatialNavigationCanceledEventArgs: typeof Windows$UI$Input$Spatial$SpatialNavigationCanceledEventArgs,
SpatialNavigationCompletedEventArgs: typeof Windows$UI$Input$Spatial$SpatialNavigationCompletedEventArgs,
SpatialNavigationStartedEventArgs: typeof Windows$UI$Input$Spatial$SpatialNavigationStartedEventArgs,
SpatialNavigationUpdatedEventArgs: typeof Windows$UI$Input$Spatial$SpatialNavigationUpdatedEventArgs,
SpatialPointerPose: typeof Windows$UI$Input$Spatial$SpatialPointerPose,
SpatialRecognitionEndedEventArgs: typeof Windows$UI$Input$Spatial$SpatialRecognitionEndedEventArgs,
SpatialRecognitionStartedEventArgs: typeof Windows$UI$Input$Spatial$SpatialRecognitionStartedEventArgs,
SpatialTappedEventArgs: typeof Windows$UI$Input$Spatial$SpatialTappedEventArgs,
        SpatialGestureSettings: typeof npm$namespace$Windows$UI$Input$Spatial$SpatialGestureSettings,
SpatialInteractionSourceKind: typeof npm$namespace$Windows$UI$Input$Spatial$SpatialInteractionSourceKind,
      }
declare class Windows$UI$Input$Spatial$SpatialGestureRecognizer  {
addEventListener: any;
cancelPendingGestures: any;
captureInteraction: any;
gestureSettings: any;
onholdcanceled: any;
onholdcompleted: any;
onholdstarted: any;
onmanipulationcanceled: any;
onmanipulationcompleted: any;
onmanipulationstarted: any;
onmanipulationupdated: any;
onnavigationcanceled: any;
onnavigationcompleted: any;
onnavigationstarted: any;
onnavigationupdated: any;
onrecognitionended: any;
onrecognitionstarted: any;
ontapped: any;
removeEventListener: any;
trySetGestureSettings: any
}


      declare var npm$namespace$Windows$UI$Input$Spatial$SpatialGestureSettings: {
        
        none: typeof Windows$UI$Input$Spatial$SpatialGestureSettings$none,
tap: typeof Windows$UI$Input$Spatial$SpatialGestureSettings$tap,
doubleTap: typeof Windows$UI$Input$Spatial$SpatialGestureSettings$doubleTap,
hold: typeof Windows$UI$Input$Spatial$SpatialGestureSettings$hold,
manipulationTranslate: typeof Windows$UI$Input$Spatial$SpatialGestureSettings$manipulationTranslate,
navigationX: typeof Windows$UI$Input$Spatial$SpatialGestureSettings$navigationX,
navigationY: typeof Windows$UI$Input$Spatial$SpatialGestureSettings$navigationY,
navigationZ: typeof Windows$UI$Input$Spatial$SpatialGestureSettings$navigationZ,
navigationRailsX: typeof Windows$UI$Input$Spatial$SpatialGestureSettings$navigationRailsX,
navigationRailsY: typeof Windows$UI$Input$Spatial$SpatialGestureSettings$navigationRailsY,
navigationRailsZ: typeof Windows$UI$Input$Spatial$SpatialGestureSettings$navigationRailsZ,
        
        
        
      }
declare var Windows$UI$Input$Spatial$SpatialGestureSettings$none: any;

declare var Windows$UI$Input$Spatial$SpatialGestureSettings$tap: any;

declare var Windows$UI$Input$Spatial$SpatialGestureSettings$doubleTap: any;

declare var Windows$UI$Input$Spatial$SpatialGestureSettings$hold: any;

declare var Windows$UI$Input$Spatial$SpatialGestureSettings$manipulationTranslate: any;

declare var Windows$UI$Input$Spatial$SpatialGestureSettings$navigationX: any;

declare var Windows$UI$Input$Spatial$SpatialGestureSettings$navigationY: any;

declare var Windows$UI$Input$Spatial$SpatialGestureSettings$navigationZ: any;

declare var Windows$UI$Input$Spatial$SpatialGestureSettings$navigationRailsX: any;

declare var Windows$UI$Input$Spatial$SpatialGestureSettings$navigationRailsY: any;

declare var Windows$UI$Input$Spatial$SpatialGestureSettings$navigationRailsZ: any;

declare class Windows$UI$Input$Spatial$SpatialHoldCanceledEventArgs  {
interactionSourceKind: any
}

declare class Windows$UI$Input$Spatial$SpatialHoldCompletedEventArgs  {
interactionSourceKind: any
}

declare class Windows$UI$Input$Spatial$SpatialHoldStartedEventArgs  {
interactionSourceKind: any;
tryGetPointerPose: any
}

declare class Windows$UI$Input$Spatial$SpatialInteraction  {
sourceState: any
}

declare class Windows$UI$Input$Spatial$SpatialInteractionDetectedEventArgs  {
interaction: any;
interactionSourceKind: any;
tryGetPointerPose: any
}

declare class Windows$UI$Input$Spatial$SpatialInteractionManager  {
static getForCurrentView: any;
addEventListener: any;
getDetectedSourcesAtTimestamp: any;
oninteractiondetected: any;
onsourcedetected: any;
onsourcelost: any;
onsourcepressed: any;
onsourcereleased: any;
onsourceupdated: any;
removeEventListener: any
}

declare class Windows$UI$Input$Spatial$SpatialInteractionSource  {
id: any;
kind: any
}

declare class Windows$UI$Input$Spatial$SpatialInteractionSourceEventArgs  {
state: any
}


      declare var npm$namespace$Windows$UI$Input$Spatial$SpatialInteractionSourceKind: {
        
        other: typeof Windows$UI$Input$Spatial$SpatialInteractionSourceKind$other,
hand: typeof Windows$UI$Input$Spatial$SpatialInteractionSourceKind$hand,
voice: typeof Windows$UI$Input$Spatial$SpatialInteractionSourceKind$voice,
controller: typeof Windows$UI$Input$Spatial$SpatialInteractionSourceKind$controller,
        
        
        
      }
declare var Windows$UI$Input$Spatial$SpatialInteractionSourceKind$other: any;

declare var Windows$UI$Input$Spatial$SpatialInteractionSourceKind$hand: any;

declare var Windows$UI$Input$Spatial$SpatialInteractionSourceKind$voice: any;

declare var Windows$UI$Input$Spatial$SpatialInteractionSourceKind$controller: any;

declare class Windows$UI$Input$Spatial$SpatialInteractionSourceLocation  {
position: any;
velocity: any
}

declare class Windows$UI$Input$Spatial$SpatialInteractionSourceProperties  {
sourceLossRisk: any;
tryGetLocation: any;
tryGetSourceLossMitigationDirection: any
}

declare class Windows$UI$Input$Spatial$SpatialInteractionSourceState  {
isPressed: any;
properties: any;
source: any;
timestamp: any;
tryGetPointerPose: any
}

declare class Windows$UI$Input$Spatial$SpatialManipulationCanceledEventArgs  {
interactionSourceKind: any
}

declare class Windows$UI$Input$Spatial$SpatialManipulationCompletedEventArgs  {
interactionSourceKind: any;
tryGetCumulativeDelta: any
}

declare class Windows$UI$Input$Spatial$SpatialManipulationDelta  {
translation: any
}

declare class Windows$UI$Input$Spatial$SpatialManipulationStartedEventArgs  {
interactionSourceKind: any;
tryGetPointerPose: any
}

declare class Windows$UI$Input$Spatial$SpatialManipulationUpdatedEventArgs  {
interactionSourceKind: any;
tryGetCumulativeDelta: any
}

declare class Windows$UI$Input$Spatial$SpatialNavigationCanceledEventArgs  {
interactionSourceKind: any
}

declare class Windows$UI$Input$Spatial$SpatialNavigationCompletedEventArgs  {
interactionSourceKind: any;
normalizedOffset: any
}

declare class Windows$UI$Input$Spatial$SpatialNavigationStartedEventArgs  {
interactionSourceKind: any;
isNavigatingX: any;
isNavigatingY: any;
isNavigatingZ: any;
tryGetPointerPose: any
}

declare class Windows$UI$Input$Spatial$SpatialNavigationUpdatedEventArgs  {
interactionSourceKind: any;
normalizedOffset: any
}

declare class Windows$UI$Input$Spatial$SpatialPointerPose  {
static tryGetAtTimestamp: any;
head: any;
timestamp: any
}

declare class Windows$UI$Input$Spatial$SpatialRecognitionEndedEventArgs  {
interactionSourceKind: any
}

declare class Windows$UI$Input$Spatial$SpatialRecognitionStartedEventArgs  {
interactionSourceKind: any;
isGesturePossible: any;
tryGetPointerPose: any
}

declare class Windows$UI$Input$Spatial$SpatialTappedEventArgs  {
interactionSourceKind: any;
tapCount: any;
tryGetPointerPose: any
}


/**
 * Contains event data for the Tapped event.
 */
declare class Windows$UI$Input$TappedEventArgs  {

/**
 * Gets the device type of the input source.
 */
pointerDeviceType: $Values<typeof Windows$Devices$Input$PointerDeviceType>;

/**
 * Gets the location of the touch, mouse, or pen/stylus contact.
 */
position: Windows$Foundation$Point;

/**
 * Gets the number of times the tap interaction was detected.
 */
tapCount: number
}


/**
 * Contains the distance thresholds for a CrossSliding interaction.
 */
declare interface Windows$UI$Input$CrossSlideThresholds {

/**
 * The distance, in DIPs, from the initial point of contact until the rearrange action is initiated.
 */
rearrangeStart: number,

/**
 * The distance, in DIPs, from the initial point of contact until the selection action is initiated.
 */
selectionStart: number,

/**
 * The distance, in DIPs, from the initial point of contact until the end of the speed bump.
 */
speedBumpEnd: number,

/**
 * The distance, in DIPs, from the initial point of contact until the speed bump is initiated.
 */
speedBumpStart: number
} 


/**
 * Contains the accumulated transformations for the current manipulation.
 */
declare interface Windows$UI$Input$ManipulationDelta {

/**
 * The change in distance between touch contacts, as DIPs. For example, if the distance between two contacts changes from 100 DIPs to 200 DIPs during a manipulation, the value of Expansion would be 100.0.
 */
expansion: number,

/**
 * The change in angle of rotation, in degrees.
 */
rotation: number,

/**
 * The change in distance between touch contacts, as a percentage. For example, if the distance between two contacts changes from 100 DIPs to 200 DIPs during a manipulation, the value of Scale would be 1.0.
 */
scale: number,

/**
 * The change in x-y screen coordinates, in DIPs.
 */
translation: Windows$Foundation$Point
} 


/**
 * Contains the velocities of the accumulated transformations for the current interaction.
 */
declare interface Windows$UI$Input$ManipulationVelocities {

/**
 * The rotational velocity in degrees per millisecond.
 */
angular: number,

/**
 * The expansion, or scaling, velocity in DIPs per millisecond.
 */
expansion: number,

/**
 * The straight line velocity in DIPs per millisecond.
 */
linear: Windows$Foundation$Point
} 


/**
 * Provides generalized transformation functions.
 */
declare interface Windows$UI$Input$IPointerPointTransform {

/**
 * Transforms the specified bounding rectangle.
 * @param rect The bounding rectangle to transform.
 * @return The smallest, axis-aligned bounding box that encloses rect after the transformation. (An axis-aligned bounding box is one which has all sides parallel to the coordinate axes.)
 */
transformBounds(rect: Windows$Foundation$Rect): Windows$Foundation$Rect,

/**
 * Attempts to perform the transformation on the specified input point.
 * @param inPoint The original input point.
 */
tryTransform(
inPoint: Windows$Foundation$Point): {
outPoint: Windows$Foundation$Point,
returnValue: boolean
},

/**
 * Gets the inverse of the specified transformation.
 */
inverse: Windows$UI$Input$IPointerPointTransform
} 


      declare var npm$namespace$Windows$UI$Notifications: {
        
        
        BadgeTemplateType: typeof Windows$UI$Notifications$BadgeTemplateType,
NotificationSetting: typeof Windows$UI$Notifications$NotificationSetting,
PeriodicUpdateRecurrence: typeof Windows$UI$Notifications$PeriodicUpdateRecurrence,
TileTemplateType: typeof Windows$UI$Notifications$TileTemplateType,
ToastDismissalReason: typeof Windows$UI$Notifications$ToastDismissalReason,
ToastHistoryChangedType: typeof Windows$UI$Notifications$ToastHistoryChangedType,
ToastTemplateType: typeof Windows$UI$Notifications$ToastTemplateType,
        BadgeNotification: typeof Windows$UI$Notifications$BadgeNotification,
BadgeUpdateManager: typeof Windows$UI$Notifications$BadgeUpdateManager,
BadgeUpdater: typeof Windows$UI$Notifications$BadgeUpdater,
ScheduledTileNotification: typeof Windows$UI$Notifications$ScheduledTileNotification,
ScheduledToastNotification: typeof Windows$UI$Notifications$ScheduledToastNotification,
TileFlyoutNotification: typeof Windows$UI$Notifications$TileFlyoutNotification,
TileFlyoutUpdateManager: typeof Windows$UI$Notifications$TileFlyoutUpdateManager,
TileFlyoutUpdater: typeof Windows$UI$Notifications$TileFlyoutUpdater,
TileNotification: typeof Windows$UI$Notifications$TileNotification,
TileUpdateManager: typeof Windows$UI$Notifications$TileUpdateManager,
TileUpdater: typeof Windows$UI$Notifications$TileUpdater,
ToastActivatedEventArgs: typeof Windows$UI$Notifications$ToastActivatedEventArgs,
ToastDismissedEventArgs: typeof Windows$UI$Notifications$ToastDismissedEventArgs,
ToastFailedEventArgs: typeof Windows$UI$Notifications$ToastFailedEventArgs,
ToastNotification: typeof Windows$UI$Notifications$ToastNotification,
ToastNotificationActionTriggerDetail: typeof Windows$UI$Notifications$ToastNotificationActionTriggerDetail,
ToastNotificationHistory: typeof Windows$UI$Notifications$ToastNotificationHistory,
ToastNotificationHistoryChangedTriggerDetail: typeof Windows$UI$Notifications$ToastNotificationHistoryChangedTriggerDetail,
ToastNotificationManager: typeof Windows$UI$Notifications$ToastNotificationManager,
ToastNotifier: typeof Windows$UI$Notifications$ToastNotifier,
        TileFlyoutTemplateType: typeof npm$namespace$Windows$UI$Notifications$TileFlyoutTemplateType,
      }

/**
 * Defines the content, associated metadata, and expiration time of an update to a tile's badge overlay. A badge can display a number from 1 to 99 or a status glyph.
 */
declare class Windows$UI$Notifications$BadgeNotification  {

/**
 * Creates and initializes a new instance of the BadgeNotification .
 * @param content The XML content that defines the badge update.
 */
constructor(content: Windows$Data$Xml$Dom$XmlDocument): this;

/**
 * Gets the XML that defines the value or glyph used as the tile's badge.
 */
content: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets or sets the time that Windows will remove the badge from the tile. By default, local badge notifications do not expire and push, periodic, and scheduled badge notifications expire after three days. It is a best practice to explicitly set an expiration time to avoid stale content.
 */
expirationTime: Date
}


/**
 * Specifies the template to use for a tile's badge overlay. Used by BadgeUpdateManager.getTemplateContent .
 */

declare  var Windows$UI$Notifications$BadgeTemplateType: {|
  +badgeGlyph: 0,// 0
+badgeNumber: 1,// 1

|};



/**
 * Creates BadgeUpdater objects that you use to manipulate a tile's badge overlay. This class also provides access to the XML content of the system-provided badge templates so that you can customize that content for use in updating your badges.
 */
declare class Windows$UI$Notifications$BadgeUpdateManager  {

/**
 * Creates and initializes a new instance of the BadgeUpdater , which lets you change the appearance or content of the badge on the calling app's tile.
 * @return The object you will use to send changes to the app tile's badge.
 */
static createBadgeUpdaterForApplication(): Windows$UI$Notifications$BadgeUpdater;

/**
 * Creates and initializes a new instance of the BadgeUpdater for a specified app tile's badge, usually the tile of another app in the package. The BadgeUpdater lets you change the appearance or content of that badge.
 * @param applicationId The unique ID of the tile whose badge you want to update.
 * @return The object you will use to send changes to the application tile's badge.
 */
static createBadgeUpdaterForApplication(applicationId: string): Windows$UI$Notifications$BadgeUpdater;

/**
 * Creates and initializes a new instance of the BadgeUpdater , which enables you to change the appearance or content of a badge on a secondary tile . The tile can belong to the calling app or any other app in the same package.
 * @param tileId The unique ID of the tile.
 * @return The object you will use to send badge updates to the tile identified by tileID.
 */
static createBadgeUpdaterForSecondaryTile(tileId: string): Windows$UI$Notifications$BadgeUpdater;

/**
 * Gets the XML content of one of the predefined badge templates so that you can customize it for a badge update.
 * @param type The type of badge template, either a glyph or a number.
 * @return The object that contains the template XML.
 */
static getTemplateContent(
type: $Values<typeof Windows$UI$Notifications$BadgeTemplateType>): Windows$Data$Xml$Dom$XmlDocument
}


/**
 * Updates a badge overlay on the specific tile that the updater is bound to.
 */
declare class Windows$UI$Notifications$BadgeUpdater  {

/**
 * Removes the badge from the tile that the updater is bound to.
 */
clear(): void;

/**
 * Begins a series of timed updates for the badge from a web resource that the updater is bound to. Updates begin at a specified time. Note that only web resources (http/https) are allowed in a periodic update.
 * @param badgeContent The URI from which the XML content of the badge update will be retrieved.
 * @param startTime The time at which the URI should first be polled for new badge content.
 * @param requestedInterval The frequency with which the URI is polled for new badge content, following the initial update at startTime.
 */
startPeriodicUpdate(
badgeContent: Windows$Foundation$Uri,
startTime: Date,
requestedInterval: $Values<typeof Windows$UI$Notifications$PeriodicUpdateRecurrence>): void;

/**
 * Begins a series of timed updates for the badge from a web resource that the updater is bound to, beginning immediately. Note that only web resources (http/https) are allowed in a periodic update.
 * @param badgeContent The URI from which the XML content of the badge update will be retrieved.
 * @param requestedInterval The frequency with which the URI is polled for new badge content.
 */
startPeriodicUpdate(
badgeContent: Windows$Foundation$Uri,
requestedInterval: $Values<typeof Windows$UI$Notifications$PeriodicUpdateRecurrence>): void;

/**
 * Cancels the current series of timed updates for the badge that the updater is bound to.
 */
stopPeriodicUpdate(): void;

/**
 * Applies a change to the badge's glyph or number.
 * @param notification The object that supplies the new XML definition for the badge.
 */
update(notification: Windows$UI$Notifications$BadgeNotification): void
}


/**
 * Specifies the limitations on tile or toast notification display.
 */

declare  var Windows$UI$Notifications$NotificationSetting: {|
  +enabled: 0,// 0
+disabledForApplication: 1,// 1
+disabledForUser: 2,// 2
+disabledByGroupPolicy: 3,// 3
+disabledByManifest: 4,// 4

|};



/**
 * Specifies the time period for subsequent polls of the tile or badge data source for new content. Used by BadgeUpdater.StartPeriodicUpdate , TileUpdater.StartPeriodicUpdate , and TileUpdater.StartPeriodicUpdateBatch .
 */

declare  var Windows$UI$Notifications$PeriodicUpdateRecurrence: {|
  +halfHour: 0,// 0
+hour: 1,// 1
+sixHours: 2,// 2
+twelveHours: 3,// 3
+daily: 4,// 4

|};



/**
 * Defines the visual content and timing for a single, non-recurring scheduled update to a tile.
 */
declare class Windows$UI$Notifications$ScheduledTileNotification  {

/**
 * Creates and initializes a new instance of the ScheduledTileNotification object for use with a TileUpdater .
 * @param content The object that provides the content for the tile notification.
 * @param deliveryTime The time at which the tile should be updated with the notification information.
 */
constructor(content: Windows$Data$Xml$Dom$XmlDocument, deliveryTime: Date): this;

/**
 * Gets the XML description of the content of the scheduled tile update.
 */
content: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets the time at which the tile is scheduled to be updated.
 */
deliveryTime: Date;

/**
 * Gets or sets the time after which the tile notification should no longer be shown. By default, a tile notification does not expire. It is a best practice to explicitly set an expiration time to avoid stale content.
 */
expirationTime: Date;

/**
 * Gets or sets the unique ID that is used to identify the scheduled tile in the schedule.
 */
id: string;

/**
 * Gets or sets a string that Windows can use to prevent duplicate notification content from appearing in the queue.
 */
tag: string
}


/**
 * Contains the XML that defines the toast notification that will display at the scheduled time.
 */
declare class Windows$UI$Notifications$ScheduledToastNotification  {

/**
 * Creates and initializes a new instance of a recurring ScheduledToastNotification .
 * @param content The XML that defines the toast notification content.
 * @param deliveryTime The date and time that Windows should first display the toast notification. You must call AddToSchedule before this time.
 * @param snoozeInterval The amount of time between occurrences of the notification. To be valid, this value must be no less than 60 seconds and no more than 60 minutes.
 * @param maximumSnoozeCount The maximum number of times to display this notification. Valid values range from 1 to 5.
 */
constructor(content: Windows$Data$Xml$Dom$XmlDocument, deliveryTime: Date, snoozeInterval: number, maximumSnoozeCount: number): this;

/**
 * Creates and initializes a new instance of a ScheduledToastNotification that will be displayed only once.
 * @param content The XML that defines the toast notification content.
 * @param deliveryTime The date and time that Windows should display the toast notification. You must call AddToSchedule before this time.
 */
constructor(content: Windows$Data$Xml$Dom$XmlDocument, deliveryTime: Date): this;

/**
 * Gets the XML that defines this scheduled toast notification.
 */
content: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets the time that this toast notification is scheduled to be displayed.
 */
deliveryTime: Date;

/**
 * Gets or sets the group identifier for the notification.
 */
group: string;

/**
 * Gets a developer-specified value used to identify a specific scheduled toast.
 */
id: string;

/**
 * Gets the maximum number of times to display this notification.
 */
maximumSnoozeCount: number;

/**
 * Gets the amount of time between occurrences of the notification.
 */
snoozeInterval: number;

/**
 * Gets or sets whether a toast's pop-up UI is displayed on the Windows Phone 8.1 screen.
 */
suppressPopup: boolean;

/**
 * Gets or sets a string that uniquely identifies a toast notification inside a Group .
 */
tag: string
}

declare class Windows$UI$Notifications$TileFlyoutNotification  {
content: any;
expirationTime: any
}


      declare var npm$namespace$Windows$UI$Notifications$TileFlyoutTemplateType: {
        
        tileFlyoutTemplate01: typeof Windows$UI$Notifications$TileFlyoutTemplateType$tileFlyoutTemplate01,
        
        
        
      }
declare var Windows$UI$Notifications$TileFlyoutTemplateType$tileFlyoutTemplate01: any;

declare class Windows$UI$Notifications$TileFlyoutUpdateManager  {
static createTileFlyoutUpdaterForApplication: any;
static createTileFlyoutUpdaterForSecondaryTile: any;
static getTemplateContent: any
}

declare class Windows$UI$Notifications$TileFlyoutUpdater  {
clear: any;
setting: any;
startPeriodicUpdate: any;
stopPeriodicUpdate: any;
update: any
}


/**
 * Defines an update to a tile, including its visuals, identification tag, and expiration time.
 */
declare class Windows$UI$Notifications$TileNotification  {

/**
 * Creates and initializes a new instance of the TileNotification object for use with a TileUpdater .
 * @param content The object that provides the content for the tile notification.
 */
constructor(content: Windows$Data$Xml$Dom$XmlDocument): this;

/**
 * Gets the XML description of the notification content, which you can then manipulate to alter the notification.
 */
content: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets or sets the time that Windows will remove the notification from the tile. By default, a tile update does not expire. It is a best practice to explicitly set an expiration time to avoid stale content.
 */
expirationTime: Date;

/**
 * Gets or sets a string that Windows can use to prevent duplicate notification content from appearing in the queue.
 */
tag: string
}


/**
 * Specifies the content template to use in a tile update. For a more detailed discussion of each tile, including an example of its XML coding, specifics on each template's image sizes, and use with different versions of the tile XML schema, see The tile template catalog.
 */

declare  var Windows$UI$Notifications$TileTemplateType: {|
  +tileSquareImage: 0,// 0
+tileSquareBlock: 1,// 1
+tileSquareText01: 2,// 2
+tileSquareText02: 3,// 3
+tileSquareText03: 4,// 4
+tileSquareText04: 5,// 5
+tileSquarePeekImageAndText01: 6,// 6
+tileSquarePeekImageAndText02: 7,// 7
+tileSquarePeekImageAndText03: 8,// 8
+tileSquarePeekImageAndText04: 9,// 9
+tileWideImage: 10,// 10
+tileWideImageCollection: 11,// 11
+tileWideImageAndText01: 12,// 12
+tileWideImageAndText02: 13,// 13
+tileWideBlockAndText01: 14,// 14
+tileWideBlockAndText02: 15,// 15
+tileWidePeekImageCollection01: 16,// 16
+tileWidePeekImageCollection02: 17,// 17
+tileWidePeekImageCollection03: 18,// 18
+tileWidePeekImageCollection04: 19,// 19
+tileWidePeekImageCollection05: 20,// 20
+tileWidePeekImageCollection06: 21,// 21
+tileWidePeekImageAndText01: 22,// 22
+tileWidePeekImageAndText02: 23,// 23
+tileWidePeekImage01: 24,// 24
+tileWidePeekImage02: 25,// 25
+tileWidePeekImage03: 26,// 26
+tileWidePeekImage04: 27,// 27
+tileWidePeekImage05: 28,// 28
+tileWidePeekImage06: 29,// 29
+tileWideSmallImageAndText01: 30,// 30
+tileWideSmallImageAndText02: 31,// 31
+tileWideSmallImageAndText03: 32,// 32
+tileWideSmallImageAndText04: 33,// 33
+tileWideSmallImageAndText05: 34,// 34
+tileWideText01: 35,// 35
+tileWideText02: 36,// 36
+tileWideText03: 37,// 37
+tileWideText04: 38,// 38
+tileWideText05: 39,// 39
+tileWideText06: 40,// 40
+tileWideText07: 41,// 41
+tileWideText08: 42,// 42
+tileWideText09: 43,// 43
+tileWideText10: 44,// 44
+tileWideText11: 45,// 45
+tileSquare150x150Image: 46,// 46
+tileSquare150x150Block: 47,// 47
+tileSquare150x150Text01: 48,// 48
+tileSquare150x150Text02: 49,// 49
+tileSquare150x150Text03: 50,// 50
+tileSquare150x150Text04: 51,// 51
+tileSquare150x150PeekImageAndText01: 52,// 52
+tileSquare150x150PeekImageAndText02: 53,// 53
+tileSquare150x150PeekImageAndText03: 54,// 54
+tileSquare150x150PeekImageAndText04: 55,// 55
+tileWide310x150Image: 56,// 56
+tileWide310x150ImageCollection: 57,// 57
+tileWide310x150ImageAndText01: 58,// 58
+tileWide310x150ImageAndText02: 59,// 59
+tileWide310x150BlockAndText01: 60,// 60
+tileWide310x150BlockAndText02: 61,// 61
+tileWide310x150PeekImageCollection01: 62,// 62
+tileWide310x150PeekImageCollection02: 63,// 63
+tileWide310x150PeekImageCollection03: 64,// 64
+tileWide310x150PeekImageCollection04: 65,// 65
+tileWide310x150PeekImageCollection05: 66,// 66
+tileWide310x150PeekImageCollection06: 67,// 67
+tileWide310x150PeekImageAndText01: 68,// 68
+tileWide310x150PeekImageAndText02: 69,// 69
+tileWide310x150PeekImage01: 70,// 70
+tileWide310x150PeekImage02: 71,// 71
+tileWide310x150PeekImage03: 72,// 72
+tileWide310x150PeekImage04: 73,// 73
+tileWide310x150PeekImage05: 74,// 74
+tileWide310x150PeekImage06: 75,// 75
+tileWide310x150SmallImageAndText01: 76,// 76
+tileWide310x150SmallImageAndText02: 77,// 77
+tileWide310x150SmallImageAndText03: 78,// 78
+tileWide310x150SmallImageAndText04: 79,// 79
+tileWide310x150SmallImageAndText05: 80,// 80
+tileWide310x150Text01: 81,// 81
+tileWide310x150Text02: 82,// 82
+tileWide310x150Text03: 83,// 83
+tileWide310x150Text04: 84,// 84
+tileWide310x150Text05: 85,// 85
+tileWide310x150Text06: 86,// 86
+tileWide310x150Text07: 87,// 87
+tileWide310x150Text08: 88,// 88
+tileWide310x150Text09: 89,// 89
+tileWide310x150Text10: 90,// 90
+tileWide310x150Text11: 91,// 91
+tileSquare310x310BlockAndText01: 92,// 92
+tileSquare310x310BlockAndText02: 93,// 93
+tileSquare310x310Image: 94,// 94
+tileSquare310x310ImageAndText01: 95,// 95
+tileSquare310x310ImageAndText02: 96,// 96
+tileSquare310x310ImageAndTextOverlay01: 97,// 97
+tileSquare310x310ImageAndTextOverlay02: 98,// 98
+tileSquare310x310ImageAndTextOverlay03: 99,// 99
+tileSquare310x310ImageCollectionAndText01: 100,// 100
+tileSquare310x310ImageCollectionAndText02: 101,// 101
+tileSquare310x310ImageCollection: 102,// 102
+tileSquare310x310SmallImagesAndTextList01: 103,// 103
+tileSquare310x310SmallImagesAndTextList02: 104,// 104
+tileSquare310x310SmallImagesAndTextList03: 105,// 105
+tileSquare310x310SmallImagesAndTextList04: 106,// 106
+tileSquare310x310Text01: 107,// 107
+tileSquare310x310Text02: 108,// 108
+tileSquare310x310Text03: 109,// 109
+tileSquare310x310Text04: 110,// 110
+tileSquare310x310Text05: 111,// 111
+tileSquare310x310Text06: 112,// 112
+tileSquare310x310Text07: 113,// 113
+tileSquare310x310Text08: 114,// 114
+tileSquare310x310TextList01: 115,// 115
+tileSquare310x310TextList02: 116,// 116
+tileSquare310x310TextList03: 117,// 117
+tileSquare310x310SmallImageAndText01: 118,// 118
+tileSquare310x310SmallImagesAndTextList05: 119,// 119
+tileSquare310x310Text09: 120,// 120
+tileSquare71x71IconWithBadge: 121,// 121
+tileSquare150x150IconWithBadge: 122,// 122
+tileWide310x150IconWithBadgeAndText: 123,// 123
+tileSquare71x71Image: 124,// 124
+tileTall150x310Image: 125,// 125

|};



/**
 * Creates TileUpdater objects used to change and update Start menu tiles. This class also provides access to the XML content of the system-provided tile templates so that you can customize that content for use in updating your tiles.
 */
declare class Windows$UI$Notifications$TileUpdateManager  {

/**
 * Creates and initializes a new instance of the TileUpdater , which lets you change the appearance of the calling app's tile.
 * @return The object you will use to send changes to the app's tile.
 */
static createTileUpdaterForApplication(): Windows$UI$Notifications$TileUpdater;

/**
 * Creates and initializes a new instance of the TileUpdater for a tile that belongs to another app in the same package as the calling app. The TileUpdater lets a developer change the appearance of that tile.
 * @param applicationId The Package Relative Application ID (PRAID) of the tile.
 * @return The object you will use to send changes to the tile identified by applicationId.
 */
static createTileUpdaterForApplication(applicationId: string): Windows$UI$Notifications$TileUpdater;

/**
 * Creates and initializes a new instance of the TileUpdater , which enables you to change the appearance of a secondary tile . The tile can belong to the calling app or any other app in the same package.
 * @param tileId A unique ID for the tile.
 * @return The object you will use to send updates to the tile identified by tileID.
 */
static createTileUpdaterForSecondaryTile(tileId: string): Windows$UI$Notifications$TileUpdater;

/**
 * Gets the XML content of one of the predefined tile templates so that you can customize it for a tile update.
 * @param type The name of the template.
 * @return The object that contains the XML.
 */
static getTemplateContent(
type: $Values<typeof Windows$UI$Notifications$TileTemplateType>): Windows$Data$Xml$Dom$XmlDocument
}


/**
 * Changes the content of the specific tile that the updater is bound to.
 */
declare class Windows$UI$Notifications$TileUpdater  {

/**
 * Adds a ScheduledTileNotification to the schedule.
 * @param scheduledTile The scheduled tile update object.
 */
addToSchedule(scheduledTile: Windows$UI$Notifications$ScheduledTileNotification): void;

/**
 * Removes all updates and causes the tile to display its default content as declared in the app's manifest.
 */
clear(): void;

/**
 * Enables the tile to queue up to five notifications. This enables the notification queue on all tile sizes.
 * @param enable True to enable queuing; otherwise false.
 */
enableNotificationQueue(enable: boolean): void;

/**
 * Enables the tile to queue up to five notifications on the medium tile.
 * @param enable True to enable queuing on this tile size; otherwise false.
 */
enableNotificationQueueForSquare150x150(enable: boolean): void;

/**
 * Enables the tile to queue up to five notifications on the large tile.
 * @param enable True to enable queuing on this tile size; otherwise false.
 */
enableNotificationQueueForSquare310x310(enable: boolean): void;

/**
 * Enables the tile to queue up to five notifications on the wide tile.
 * @param enable True to enable queuing on this tile size; otherwise false.
 */
enableNotificationQueueForWide310x150(enable: boolean): void;

/**
 * Retrieves a list of scheduled updates to the tile.
 * @return The collection of scheduled updates for this tile.
 */
getScheduledTileNotifications(
): Windows$Foundation$Collections$IVectorView<Windows$UI$Notifications$ScheduledTileNotification>;

/**
 * Removes an upcoming tile update from the schedule.
 * @param scheduledTile The notification to remove from the schedule.
 */
removeFromSchedule(scheduledTile: Windows$UI$Notifications$ScheduledTileNotification): void;

/**
 * Gets a value that specifies whether a tile can be updated through notifications.
 */
setting: $Values<typeof Windows$UI$Notifications$NotificationSetting>;

/**
 * Begins a series of timed content changes for the tile that the updater is bound to, beginning immediately.
 * @param tileContent The URI from which the XML content of the tile update will be retrieved.
 * @param requestedInterval The frequency with which the URI is polled for new tile content, following the initial update at startTime.
 */
startPeriodicUpdate(
tileContent: Windows$Foundation$Uri,
requestedInterval: $Values<typeof Windows$UI$Notifications$PeriodicUpdateRecurrence>): void;

/**
 * Begins a series of timed updates for the tile that the updater is bound to. Update content is retrieved from a specified Uniform Resource Identifier (URI). Updates begin at a specified time.
 * @param tileContent The URI from which the XML content of the tile update will be retrieved.
 * @param startTime The time at which the URI should first be polled for new tile content.
 * @param requestedInterval The frequency with which the URI is polled for new tile content, following the initial update at startTime.
 */
startPeriodicUpdate(
tileContent: Windows$Foundation$Uri,
startTime: Date,
requestedInterval: $Values<typeof Windows$UI$Notifications$PeriodicUpdateRecurrence>): void;

/**
 * Begins a series of timed updates that cycle on the tile that the updater is bound to. Update content is retrieved from an array of specified Uniform Resource Identifiers (URIs), the first update happening immediately and subsequent updates occurring at the periodic interval thereafter.
 * @param tileContents An array of up to five URIs from which the XML content of the cycling tile updates will be retrieved. If the array contains more than five URIs, the method will fail.
 * @param requestedInterval The frequency with which the URI is polled for new tile content, following the initial update at startTime.
 */
startPeriodicUpdateBatch(
tileContents: Windows$Foundation$Collections$IIterable<Windows$Foundation$Uri>,
requestedInterval: $Values<typeof Windows$UI$Notifications$PeriodicUpdateRecurrence>): void;

/**
 * Begins a series of timed updates that cycle on the tile that the updater is bound to. Update content is retrieved from an array of specified Uniform Resource Identifiers (URIs) with updates beginning at a specified time and subsequent updates occurring at the periodic interval thereafter.
 * @param tileContents An array of up to five URIs from which the XML content of the cycling tile updates will be retrieved. If the array contains more than five URIs, the method will fail.
 * @param startTime The time at which the initial URI should first be polled for new content.
 * @param requestedInterval The frequency with which the URI is polled for new tile content, following the initial update at startTime.
 */
startPeriodicUpdateBatch(
tileContents: Windows$Foundation$Collections$IIterable<Windows$Foundation$Uri>,
startTime: Date,
requestedInterval: $Values<typeof Windows$UI$Notifications$PeriodicUpdateRecurrence>): void;

/**
 * Cancels the current series of timed updates for the tile that the updater is bound to.
 */
stopPeriodicUpdate(): void;

/**
 * Applies a change in content or appearance to the tile.
 * @param notification The object that supplies the new XML definition for the tile's content.
 */
update(notification: Windows$UI$Notifications$TileNotification): void
}


/**
 * Exposes a method that retrieves the arguments associated with a toast action initiated by the user. This lets the app tell which action was taken when multiple actions were exposed.
 */
declare class Windows$UI$Notifications$ToastActivatedEventArgs  {

/**
 * Gets the arguments associated with a toast action initiated by the user. This arguments string was included in the toast's XML payload.
 */
arguments: string
}


/**
 * Specifies the reason that a toast notification is no longer being shown. Used with ToastDismissedEventArgs.Reason .
 */

declare  var Windows$UI$Notifications$ToastDismissalReason: {|
  +userCanceled: 0,// 0
+applicationHidden: 1,// 1
+timedOut: 2,// 2

|};



/**
 * Provides the reason that a toast notification is no longer displayed on-screen.
 */
declare class Windows$UI$Notifications$ToastDismissedEventArgs  {

/**
 * Gets the reason that a toast notification is no longer displayed on-screen.
 */
reason: $Values<typeof Windows$UI$Notifications$ToastDismissalReason>
}


/**
 * Provides the error code that was generated in the process of raising a toast notification.
 */
declare class Windows$UI$Notifications$ToastFailedEventArgs  {

/**
 * Gets the error code that was generated in the process of raising a toast notification.
 */
errorCode: Windows$WinRTError
}


/**
 * Specifies the kind of change that has happened to a notification in toast history. Used with ToastNotificationHistoryChangedTriggerDetail.ChangeType .
 */

declare  var Windows$UI$Notifications$ToastHistoryChangedType: {|
  +cleared: 0,// 0
+removed: 1,// 1
+expired: 2,// 2
+added: 3,// 3

|};



/**
 * Defines the content, associated metadata and events, and expiration time of a toast notification.
 */
declare class Windows$UI$Notifications$ToastNotification  {

/**
 * Creates and initializes a new instance of the ToastNotification .
 * @param content The XML content that defines the toast notification.
 */
constructor(content: Windows$Data$Xml$Dom$XmlDocument): this;

/**
 * Gets the XML that defines the current toast notification.
 */
content: Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets or sets the time after which a toast notification should not be displayed.
 */
expirationTime: Date;

/**
 * Gets or sets the group identifier for the notification.
 */
group: string;

/**
 * Occurs when user activates a toast notification through a click or touch. Apps that are running subscribe to this event.
 */
onactivated: Windows$Foundation$TypedEventHandler<Windows$UI$Notifications$ToastNotification, any>;
addEventListener(
type: "activated",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Notifications$ToastNotification, any>): void;
removeEventListener(
type: "activated",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Notifications$ToastNotification, any>): void;

/**
 * Occurs when a toast notification leaves the screen, either by expiring or being explicitly dismissed by the user. Apps that are running subscribe to this event.
 */
ondismissed: Windows$Foundation$TypedEventHandler<Windows$UI$Notifications$ToastNotification, Windows$UI$Notifications$ToastDismissedEventArgs>;
addEventListener(
type: "dismissed",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Notifications$ToastNotification, Windows$UI$Notifications$ToastDismissedEventArgs>): void;
removeEventListener(
type: "dismissed",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Notifications$ToastNotification, Windows$UI$Notifications$ToastDismissedEventArgs>): void;

/**
 * Occurs when an error is caused when Windows attempts to raise a toast notification. Apps that are running subscribe to this event.
 */
onfailed: Windows$Foundation$TypedEventHandler<Windows$UI$Notifications$ToastNotification, Windows$UI$Notifications$ToastFailedEventArgs>;
addEventListener(
type: "failed",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Notifications$ToastNotification, Windows$UI$Notifications$ToastFailedEventArgs>): void;
removeEventListener(
type: "failed",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Notifications$ToastNotification, Windows$UI$Notifications$ToastFailedEventArgs>): void;

/**
 * Gets or sets whether a toast's pop-up UI is displayed on the Windows Phone 8.1 screen.
 */
suppressPopup: boolean;

/**
 * Gets or sets the unique identifier of this notification within the notification Group .
 */
tag: string;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}

declare class Windows$UI$Notifications$ToastNotificationActionTriggerDetail  {
argument: any;
userInput: any
}


/**
 * Manages the toast notifications for an app including the ability the clear all toast history and removing individual toasts.
 */
declare class Windows$UI$Notifications$ToastNotificationHistory  {

/**
 * Removes all notifications from action center that were sent by another app inside the same app package.
 * @param applicationId The ID of the app inside the app package whose notifications are to be deleted.
 */
clear(applicationId: string): void;

/**
 * Removes all notifications sent by this app from action center.
 */
clear(): void;

/**
 * Gets notification history, for a toast with the specified tag label, from action center.
 * @param applicationId The tag label for the toast being queried-for.
 * @return A collection of toasts.
 */
getHistory(
applicationId: string): Windows$Foundation$Collections$IVectorView<Windows$UI$Notifications$ToastNotification>;

/**
 * Gets notification history, for all notifications sent by this app, from action center.
 * @return A collection of toasts.
 */
getHistory(
): Windows$Foundation$Collections$IVectorView<Windows$UI$Notifications$ToastNotification>;

/**
 * Removes an individual toast, with the specified tag label, from action center.
 * @param tag The tag label of the toast notification to be removed.
 */
remove(tag: string): void;

/**
 * Removes an individual toast notification from action center, identified by the combination of tag label, group label and app ID.
 * @param tag The tag label of the toast notification to be removed.
 * @param group The group label of the toast notification to be removed.
 * @param applicationId The app ID of the app that sent the specified toast notification. This app must be part of the same app package as the app making this remove request.
 */
remove(tag: string, group: string, applicationId: string): void;

/**
 * Removes a toast notification from the action using the notification's tag and group labels.
 * @param tag The tag label of the toast notification to be removed.
 * @param group The group label of the toast notification to be removed.
 */
remove(tag: string, group: string): void;

/**
 * Removes a group of toast notifications, identified by the specified group label, from action center.
 * @param group The group label of the toast notifications to be removed.
 */
removeGroup(group: string): void;

/**
 * Removes a group of toast notifications sent by the another app inside the same app package from action center using the group label.
 * @param group The group label of the toast notifications to be removed.
 * @param applicationId The app ID of the app within the same app package of the calling app.
 */
removeGroup(group: string, applicationId: string): void
}


/**
 * Represents the details of a toast history changed trigger.
 */
declare class Windows$UI$Notifications$ToastNotificationHistoryChangedTriggerDetail  {

/**
 * Gets a value representing the kind of change that caused the toast history changed trigger.
 */
changeType: $Values<typeof Windows$UI$Notifications$ToastHistoryChangedType>
}


/**
 * Creates ToastNotifier objects that you use to raise toast notifications. This class also provides access to the XML content of the system-provided toast templates so that you can customize that content for use in your notifications.
 */
declare class Windows$UI$Notifications$ToastNotificationManager  {

/**
 * Creates and initializes a new instance of the ToastNotification , bound to the calling application, that lets you raise a toast notification to that app.
 * @return The object you will use to send the toast notification to the app.
 */
static createToastNotifier(): Windows$UI$Notifications$ToastNotifier;

/**
 * Creates and initializes a new instance of the ToastNotification , bound to a specified app, usually another app in the same package.
 * @param applicationId The unique ID of the app.
 * @return The object you will use to send the toast notification to the tile.
 */
static createToastNotifier(applicationId: string): Windows$UI$Notifications$ToastNotifier;

/**
 * Gets the XML content of one of the predefined toast templates so that you can customize it for use in your notification.
 * @param type One of the system-provided toast templates.
 * @return The object that contains the template XML.
 */
static getTemplateContent(
type: $Values<typeof Windows$UI$Notifications$ToastTemplateType>): Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets the ToastNotificationHistory object.
 */
static history: Windows$UI$Notifications$ToastNotificationHistory
}


/**
 * Raises a toast notification to the specific app to which the ToastNotifier is bound. This class also lets you schedule and remove toast notifications.
 */
declare class Windows$UI$Notifications$ToastNotifier  {

/**
 * Adds a ScheduledToastNotification for later display by Windows.
 * @param scheduledToast The scheduled toast notification, which includes its content and timing instructions.
 */
addToSchedule(scheduledToast: Windows$UI$Notifications$ScheduledToastNotification): void;

/**
 * Gets the collection of ScheduledToastNotification objects that this app has scheduled for display.
 * @return The collection of scheduled toast notifications that the app bound to this notifier has scheduled for timed display.
 */
getScheduledToastNotifications(
): Windows$Foundation$Collections$IVectorView<Windows$UI$Notifications$ScheduledToastNotification>;

/**
 * Removes the specified toast notification from the screen.
 * @param notification The object that specifies the toast to hide.
 */
hide(notification: Windows$UI$Notifications$ToastNotification): void;

/**
 * Cancels the scheduled display of a specified ScheduledToastNotification .
 * @param scheduledToast The notification to remove from the schedule.
 */
removeFromSchedule(scheduledToast: Windows$UI$Notifications$ScheduledToastNotification): void;

/**
 * Gets a value that tells you whether there is an app, user, or system block that prevents the display of a toast notification.
 */
setting: $Values<typeof Windows$UI$Notifications$NotificationSetting>;

/**
 * Displays the specified toast notification.
 * @param notification The object that contains the content of the toast notification to display.
 */
show(notification: Windows$UI$Notifications$ToastNotification): void
}


/**
 * Specifies the template to use in a toast notification.
 */

declare  var Windows$UI$Notifications$ToastTemplateType: {|
  +toastImageAndText01: 0,// 0
+toastImageAndText02: 1,// 1
+toastImageAndText03: 2,// 2
+toastImageAndText04: 3,// 3
+toastText01: 4,// 4
+toastText02: 5,// 5
+toastText03: 6,// 6
+toastText04: 7,// 7

|};



      declare var npm$namespace$Windows$UI$Popups: {
        
        
        MessageDialogOptions: typeof Windows$UI$Popups$MessageDialogOptions,
Placement: typeof Windows$UI$Popups$Placement,
        MessageDialog: typeof Windows$UI$Popups$MessageDialog,
PopupMenu: typeof Windows$UI$Popups$PopupMenu,
UICommand: typeof Windows$UI$Popups$UICommand,
UICommandSeparator: typeof Windows$UI$Popups$UICommandSeparator,
        
      }

/**
 * Represents a dialog. The dialog has a command bar that can support up to three commands. If you don't specify any commands, then a default command is added to close the dialog.
 */
declare class Windows$UI$Popups$MessageDialog  {

/**
 * Initializes a new instance of the MessageDialog class to display a titled message dialog that can be used to ask your user simple questions.
 * @param content The message displayed to the user.
 * @param title The title you want displayed on the dialog.
 */
constructor(content: string, title: string): this;

/**
 * Initializes a new instance of the MessageDialog class to display an untitled message dialog that can be used to ask your user simple questions.
 * @param content The message displayed to the user.
 */
constructor(content: string): this;

/**
 * Gets or sets the index of the command you want to use as the cancel command. This is the command that fires when users press the ESC key.
 */
cancelCommandIndex: number;

/**
 * Gets an array of commands that appear in the command bar of the message dialog. These commands makes the dialog actionable.
 */
commands: Windows$Foundation$Collections$IVector<Windows$UI$Popups$IUICommand>;

/**
 * Gets or sets the message to be displayed to the user.
 */
content: string;

/**
 * Gets or sets the index of the command you want to use as the default. This is the command that fires by default when users press the ENTER key.
 */
defaultCommandIndex: number;

/**
 * Gets or sets the options for a MessageDialog .
 */
options: $Values<typeof Windows$UI$Popups$MessageDialogOptions>;

/**
 * Begins an asynchronous operation showing a dialog.
 * @return An object that represents the asynchronous operation. For more on the async pattern, see Asynchronous programming.
 */
showAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$UI$Popups$IUICommand>;

/**
 * Gets or sets the title to display on the dialog, if any.
 */
title: string
}


/**
 * Specifies less frequently used options for a MessageDialog .
 */

declare  var Windows$UI$Popups$MessageDialogOptions: {|
  +none: 0,// 0
+acceptUserInputAfterDelay: 1,// 1

|};



/**
 * Specifies where the context menu should be positioned relative to the selection rectangle.
 */

declare  var Windows$UI$Popups$Placement: {|
  +default: 0,// 0
+above: 1,// 1
+below: 2,// 2
+left: 3,// 3
+right: 4,// 4

|};



/**
 * Represents a context menu.
 */
declare class Windows$UI$Popups$PopupMenu  {

/**
 * Creates a new instance of the PopupMenu class.
 */
constructor(): this;

/**
 * Gets the commands for the context menu.
 */
commands: Windows$Foundation$Collections$IVector<Windows$UI$Popups$IUICommand>;

/**
 * Shows the context menu at the specified client coordinates.
 * @param invocationPoint The coordinates (in DIPs), relative to the window, of the user's finger or mouse pointer when the oncontextmenu event fired. The menu is placed above and centered on this point.
 * @return A IUICommand object that represents the context menu command that was invoked by the user, after the ShowAsync call completes.
 */
showAsync(
invocationPoint: Windows$Foundation$Point): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$UI$Popups$IUICommand>;

/**
 * Shows the context menu above the specified selection.
 * @param selection The coordinates (in DIPs) of the selected rectangle, relative to the window. The context menu is placed directly above and centered on this rectangle such that selection is not covered.
 * @return A IUICommand object that represents the context menu command invoked by the user, after the ShowForSelectionAsync call completes.
 */
showForSelectionAsync(
selection: Windows$Foundation$Rect): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$UI$Popups$IUICommand>;

/**
 * Shows the context menu in the preferred placement relative to the specified selection.
 * @param selection The coordinates (in DIPs) of the selected rectangle, relative to the window.
 * @param preferredPlacement The preferred placement of the context menu relative to the selection rectangle.
 * @return A IUICommand object that represents the context menu command invoked by the user, after the ShowForSelectionAsync call completes.
 */
showForSelectionAsync(
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$UI$Popups$IUICommand>
}


/**
 * Represents a command in a context menu.
 */
declare class Windows$UI$Popups$UICommand  {

/**
 * Creates a new instance of the UICommand class.
 */
constructor(): this;

/**
 * Creates a new instance of the UICommand class using the specified label and event handler.
 * @param label The label for the new command.
 * @param action The event handler for the new command.
 */
constructor(label: string, action: Windows$UI$Popups$UICommandInvokedHandler): this;

/**
 * Creates a new instance of the UICommand class using the specified label, event handler, and command identifier.
 * @param label The label for the new command.
 * @param action The event handler for the new command.
 * @param commandId The command identifier for the new command.
 */
constructor(label: string, action: Windows$UI$Popups$UICommandInvokedHandler, commandId: any): this;

/**
 * Creates a new instance of the UICommand class using the specified label.
 * @param label The label for the UICommand .
 */
constructor(label: string): this;

/**
 * Gets or sets the identifier of the command.
 */
id: any;

/**
 * Gets or sets the handler for the event that is fired when the user selects the UICommand .
 */
invoked: Windows$UI$Popups$UICommandInvokedHandler;

/**
 * Gets or sets the label for the command.
 */
label: string
}


/**
 * Represents a command separator in a context menu.
 */
declare class Windows$UI$Popups$UICommandSeparator  {

/**
 * Creates a new instance of the UICommandSeparator class.
 */
constructor(): this;

/**
 * Gets or sets the identifier of the command separator.
 */
id: any;

/**
 * Gets or sets the handler for the event that is fired for the command separator.
 */
invoked: Windows$UI$Popups$UICommandInvokedHandler;

/**
 * Gets or sets the label for the command separator.
 */
label: string
}


/**
 * Represents a callback function that handles the event that is fired when the user invokes a context menu command.
 */
declare type Windows$UI$Popups$UICommandInvokedHandler = (command: Windows$UI$Popups$IUICommand) => void;


/**
 * Represents a command in a context menu or message dialog box.
 */
declare interface Windows$UI$Popups$IUICommand {

/**
 * Gets or sets the identifier of the command.
 */
id: any,

/**
 * Gets or sets the handler for the event that is fired when the user invokes the command.
 */
invoked: Windows$UI$Popups$UICommandInvokedHandler,

/**
 * Gets or sets the label for the command.
 */
label: string
} 


      declare var npm$namespace$Windows$UI$StartScreen: {
        
        
        ForegroundText: typeof Windows$UI$StartScreen$ForegroundText,
JumpListItemKind: typeof Windows$UI$StartScreen$JumpListItemKind,
JumpListSystemGroupKind: typeof Windows$UI$StartScreen$JumpListSystemGroupKind,
TileOptions: typeof Windows$UI$StartScreen$TileOptions,
TileSize: typeof Windows$UI$StartScreen$TileSize,
        JumpList: typeof Windows$UI$StartScreen$JumpList,
JumpListItem: typeof Windows$UI$StartScreen$JumpListItem,
SecondaryTile: typeof Windows$UI$StartScreen$SecondaryTile,
SecondaryTileVisualElements: typeof Windows$UI$StartScreen$SecondaryTileVisualElements,
VisualElementsRequest: typeof Windows$UI$StartScreen$VisualElementsRequest,
VisualElementsRequestDeferral: typeof Windows$UI$StartScreen$VisualElementsRequestDeferral,
VisualElementsRequestedEventArgs: typeof Windows$UI$StartScreen$VisualElementsRequestedEventArgs,
        
      }

/**
 * Specifies the color of the tile's foreground text.
 */

declare  var Windows$UI$StartScreen$ForegroundText: {|
  +dark: 0,// 0
+light: 1,// 1

|};



/**
 * Provides functionality for selecting the type of system-managed jump list that is used by an app, adding custom task entry points to an app's jump list, and adding custom groups to an app's jump list. A jump list consists of an optional system-provided list of items, as well as optional app-provided items. Not all device families support jump lists.
 */
declare class Windows$UI$StartScreen$JumpList  {

/**
 * Gets a value that indicates whether the system supports jump lists.
 * @return A boolean value that is True if jump lists are supported. Otherwise, False.
 */
static isSupported(): boolean;

/**
 * Asynchronously retrieves the current jump list and its items.
 * @return When this method completes successfully, it returns the current JumpList . If the system does not support jump lists, this method returns an empty jump list and the SaveAsync method has no effect. Apps can check for this case using the isSupported method.
 */
static loadCurrentAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$UI$StartScreen$JumpList>;

/**
 * Gets the list of JumpListItem 's for the jump list. Items is of type IVector(JumpListItem) .
 */
items: Windows$Foundation$Collections$IVector<Windows$UI$StartScreen$JumpListItem>;

/**
 * Asynchronously saves changes to the jump list and its items.
 * @return Returns an IAsyncAction object that is used to control the asynchronous operation. If the system does not support jump lists, the SaveAsync method has no effect and future calls to LoadCurrentAsync will produce an empty jump list. An app can check for this case using the IsSupported method.
 */
saveAsync(): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Gets or sets the current type of the system managed jump list group.
 */
systemGroupKind: $Values<typeof Windows$UI$StartScreen$JumpListSystemGroupKind>
}


/**
 * Provides functionality for creating and defining jump list items for an app's jump list.
 */
declare class Windows$UI$StartScreen$JumpListItem  {

/**
 * Creates a jump list item that is an inert separator for a custom group within the app's jump list.
 * @return A jump list item that can be added to an app's jump list through the items property.
 */
static createSeparator(): Windows$UI$StartScreen$JumpListItem;

/**
 * Creates a new jump list item for an app's jump list.
 * @param arguments String that specifies any command line arguments that should be passed onto the app when the jump list item is selected by a user.
 * @param displayName String that specifies a display name for the jump list item. If localization is desired, this string must be a ms-resource: scheme specified URI.
 * @return A jump list item with the specified parameters that can be added to an app's jump list through the items property.
 */
static createWithArguments(args: string, displayName: string): Windows$UI$StartScreen$JumpListItem;

/**
 * Gets the command line arguments for the jump list item.
 */
arguments: string;

/**
 * Gets or sets the jump list item task description.
 */
description: string;

/**
 * Gets or sets the jump list item display name. The display name can also be specified as a parameter using the CreateWithArguments method when the jump list item is created.
 */
displayName: string;

/**
 * Gets or sets the jump list item custom group name. If no name is specified, the item will be added to the Tasks group by default.
 */
groupName: string;

/**
 * Gets the JumpListItemKind of a jump list item.
 */
kind: $Values<typeof Windows$UI$StartScreen$JumpListItemKind>;

/**
 * Gets or sets the jump list item's logo.
 */
logo: Windows$Foundation$Uri;

/**
 * Gets a boolean indicating whether the jump list item was removed from the app's jump list by the user.
 */
removedByUser: boolean
}


/**
 * Specifies the kind of jump list item.
 */

declare  var Windows$UI$StartScreen$JumpListItemKind: {|
  +arguments: 0,// 0
+separator: 1,// 1

|};



/**
 * Indicates the kind of system group used by an app's jump list.
 */

declare  var Windows$UI$StartScreen$JumpListSystemGroupKind: {|
  +none: 0,// 0
+frequent: 1,// 1
+recent: 2,// 2

|};



/**
 * Creates, enumerates, and provides information about a secondary tile.
 */
declare class Windows$UI$StartScreen$SecondaryTile  {

/**
 * Checks whether a specific secondary tile exists for the calling app.
 * @param tileId The unique ID string that was assigned to the tile when it was created.
 * @return True if the tile exists in the calling application; otherwise, false.
 */
static exists(tileId: string): boolean;

/**
 * Retrieves a list of secondary tiles created for the calling app.
 * @return An enumeration object that allows you to examine the set of tiles.
 */
static findAllAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a list of secondary tiles created for another app in the same package as the calling app.
 * @param applicationId The Package Relative Application ID (PRAID) of the app.
 * @return An enumeration object that allows you to examine the set of tiles.
 */
static findAllAsync(
applicationId: string): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Retrieves a list of secondary tiles created for all of the apps in the package of the calling app.
 * @return An enumeration object that allows you to examine the set of tiles.
 */
static findAllForPackageAsync(
): Windows$Foundation$IPromiseWithIAsyncOperation<Windows$Foundation$Collections$IVectorView<any>>;

/**
 * Creates a SecondaryTile object. The caller must then set any mandatory properties through the object before attempting to pin, update, or delete the tile.
 */
constructor(): this;

/**
 * Creates a SecondaryTile object as a wide tile.
 * @param tileId A string that will uniquely identify the tile within your app's package. Choose a unique ID that is descriptive and meaningful to your app. It is limited to 64 characters and must begin with a number or letter and be composed of the characters a-z, A-Z, 0-9, period (.), or underscore (_). If you provide the same ID as that of an existing secondary tile, the existing secondary tile will be overwritten. Can be set or retrieved through the TileId property.
 * @param shortName A short name to display directly on the tile if the app chooses to do so. Anything over 40 characters will be truncated. The user has the option to change this value as part of the pinning process. Can be set or retrieved through the ShortName property.
 * @param displayName A name to be displayed on the tile, in the tile's tooltip, and when showing small tiles, such as on the Apps or search results screens. This string is equivalent to the display name given in the manifest for the main tile. It is restricted to 256 characters, but in practice should be kept short to avoid truncation. This value can be set or retrieved through the DisplayName property.
 * @param arguments An app-defined string meaningful to the calling application. This argument string is passed back to the app when the app is activated from the secondary tile. It will be truncated after 2048 characters. Can be set or retrieved through the Arguments property.
 * @param tileOptions A value that specifies various options such as whether the name will be displayed on the secondary tile. Can be set or retrieved through the TileOptions property.
 * @param logoReference A reference to a medium logo image stored at a URI. Can be set or retrieved through the Square150x150Logo property. This value can be expressed using one of these schemes:
 * @param wideLogoReference A reference to a wide logo image stored at a URI. Can be set or retrieved through the WideLogo property. This value can be expressed using one of these schemes:
 */
constructor(tileId: string, shortName: string, displayName: string, args: string, tileOptions: $Values<typeof Windows$UI$StartScreen$TileOptions>, logoReference: Windows$Foundation$Uri, wideLogoReference: Windows$Foundation$Uri): this;

/**
 * Creates a SecondaryTile object with a specific ID. This form of the constructor should be used to create a secondary tile object to perform a tile update or deletion.
 * @param tileId A string that will uniquely identify the tile within your app. Choose a unique ID that is descriptive and meaningful to your app. If you provide the same ID as that of an existing secondary tile, the existing secondary tile will be overwritten.
 */
constructor(tileId: string): this;

/**
 * Creates a SecondaryTile object as a medium tile.
 * @param tileId A string that will uniquely identify the tile within your app's package. Choose a unique ID that is descriptive and meaningful to your app. It is limited to 64 characters and must begin with a number or letter and be composed of the characters a-z, A-Z, 0-9, period (.), or underscore (_). If you provide the same ID as that of an existing secondary tile, the existing secondary tile will be overwritten. Can be set or retrieved through the TileId property.
 * @param shortName A short name to display directly on the tile if the app chooses to do so. Anything over 40 characters will be truncated. The user has the option to change this value as part of the pinning process. Can be set or retrieved through the ShortName property.
 * @param displayName A name to be displayed on the tile, in the tile's tooltip, and when showing small tiles, such as on the Apps or search results screens. This string is equivalent to the display name given in the manifest for the main tile. It is restricted to 256 characters, but in practice should be kept short to avoid truncation. This value can be set or retrieved through the DisplayName property.
 * @param arguments An app-defined string meaningful to the calling application. This argument string is passed back to the app when the app is activated from the secondary tile. It will be truncated after 2048 characters. Can be set or retrieved through the Arguments property.
 * @param tileOptions A value that specifies various options such as whether the name will be displayed on the secondary tile. Can be set or retrieved through the TileOptions property.
 * @param logoReference A reference to a square logo image stored at a URI. Can be set or retrieved through the Logo property. This value can be expressed using one of these schemes:
 */
constructor(tileId: string, shortName: string, displayName: string, args: string, tileOptions: $Values<typeof Windows$UI$StartScreen$TileOptions>, logoReference: Windows$Foundation$Uri): this;

/**
 * Creates a SecondaryTile object that includes all of the mandatory properties required to create a medium tile.
 * @param tileId A string that will uniquely identify the tile within your app's package. Choose a unique ID that is descriptive and meaningful to your app. It is limited to 64 characters and must begin with a number or letter and be composed of the characters a-z, A-Z, 0-9, period (.), or underscore (_). If you provide the same ID as that of an existing secondary tile, the existing secondary tile will be overwritten. Can be set or retrieved through the TileId property.
 * @param displayName A name to be displayed on the tile, in the tile's tooltip, and when showing small tiles, such as on the Apps or search results screens. This string is equivalent to the display name given in the manifest for the main tile. It is restricted to 256 characters, but in practice should be kept short to avoid truncation. This value can be set or retrieved through the DisplayName property.
 * @param arguments An app-defined string meaningful to the calling application. This argument string is passed back to the app when the app is activated from the secondary tile. It will be truncated after 2048 characters. Can be set or retrieved through the Arguments property.
 * @param square150x150Logo A reference to a medium logo image stored at a URI. Can be set or retrieved through the SecondaryTileVisualElements.Square150x150Logo property. This value can be expressed using one of these schemes:
 * @param desiredSize The size of tile to pin. This value must be Default (which provides Windows 8 behavior), Square150x150, or Wide310x150. Any other TileSize value causes an exception to be thrown during runtime.
 */
constructor(tileId: string, displayName: string, args: string, square150x150Logo: Windows$Foundation$Uri, desiredSize: $Values<typeof Windows$UI$StartScreen$TileSize>): this;

/**
 * Gets or sets an app-defined set of information that is passed from the secondary tile to the app on activation. This property is required when you create a tile.
 */
arguments: string;

/**
 * Gets or sets the tile's background color.
 */
backgroundColor: Windows$UI$Color;

/**
 * Gets or sets a name that is associated with and displayed on the tile. This name is displayed on the tile in Start, in the tile's tooltip, next to the small tile representation in the Apps list, and in some Control Panel applications. This property is required when you create a tile. It is the equivalent of the display name declared in the manifest for the app's main tile.
 */
displayName: string;

/**
 * Gets or sets whether the tile should use dark or light text.
 */
foregroundText: $Values<typeof Windows$UI$StartScreen$ForegroundText>;

/**
 * Gets or sets the location of a badge logo image to represent the secondary tile on the lock screen. By supplying this image, you declare that the secondary tile is eligible to display a badge on the lock screen. If you also want the secondary tile to be eligible for the lock screen's detailed tile slot, you must also set the LockScreenDisplayBadgeAndTileText property to True.
 */
lockScreenBadgeLogo: Windows$Foundation$Uri;

/**
 * Gets or sets whether the secondary tile is eligible to display both a badge and a detailed tile on the lock screen. If you set this property to True, you must also provide a badge image through the LockScreenBadgeLogo property. If you do not want to use the detailed tile capability, provide a badge image through the LockScreenBadgeLogo property and set LockScreenDisplayBadgeAndTileText to False.
 */
lockScreenDisplayBadgeAndTileText: boolean;

/**
 * Gets or sets the logo image used in a medium tile. This property is required when you create either a square or a wide tile.
 */
logo: Windows$Foundation$Uri;

/**
 * Fired when a call is made to RequestCreateAsync .
 */
onvisualelementsrequested: Windows$Foundation$TypedEventHandler<Windows$UI$StartScreen$SecondaryTile, Windows$UI$StartScreen$VisualElementsRequestedEventArgs>;
addEventListener(
type: "visualelementsrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$StartScreen$SecondaryTile, Windows$UI$StartScreen$VisualElementsRequestedEventArgs>): void;
removeEventListener(
type: "visualelementsrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$StartScreen$SecondaryTile, Windows$UI$StartScreen$VisualElementsRequestedEventArgs>): void;

/**
 * Gets or sets a phonetic version of the secondary tile name. Used with character-based languages for UI sorting purposes.
 */
phoneticName: string;

/**
 * Displays the Pin to Start flyout above a specified location, through which the user can confirm that they want to create the secondary tile, which in turn creates the tile.
 * @param invocationPoint The point used as the lower-right corner of the Pin to Start flyout.
 * @return An object that provides information concerning the asynchronous create operation.
 */
requestCreateAsync(
invocationPoint: Windows$Foundation$Point): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Displays the Pin to Start flyout, through which the user can confirm that they want to create the secondary tile, which in turn creates the tile. Overloads of this method let you specify the on-screen location of the flyout.
 * @return An object used to launch the asynchronous create operation as well as to retrieve information about it.
 */
requestCreateAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Displays the Pin to Start flyout above a specified area. This flyout is used by the user to confirm that they want to create the secondary tile, which in turn creates the tile.
 * @param selection The area that the flyout is displayed directly above.
 * @return An object that provides information concerning the asynchronous create operation.
 */
requestCreateForSelectionAsync(
selection: Windows$Foundation$Rect): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Displays the Pin to Start flyout at the specified side of a specified area. This flyout is used by the user to confirm that they want to create the secondary tile, which in turn creates the tile.
 * @param selection The area to one side of which the flyout will be displayed.
 * @param preferredPlacement The side of the rectangle where the flyout should appear.
 * @return An object that provides information concerning the asynchronous create operation.
 */
requestCreateForSelectionAsync(
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Displays the Unpin from Start flyout. This flyout lets the user confirm removal of the secondary tile.
 * @return An object that provides information concerning the asynchronous delete operation.
 */
requestDeleteAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Displays the Unpin from Start flyout at a specified point. This flyout lets the user confirm removal of the secondary tile.
 * @param invocationPoint The point used as the lower-right corner of the Pin to Start flyout.
 * @return An object that provides information concerning the asynchronous delete operation.
 */
requestDeleteAsync(
invocationPoint: Windows$Foundation$Point): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Displays the Unpin from Start flyout above a specified area. This flyout lets the user confirm removal of the secondary tile.
 * @param selection The area that the secondary tile is displayed directly above.
 * @return An object that provides information concerning the asynchronous delete operation.
 */
requestDeleteForSelectionAsync(
selection: Windows$Foundation$Rect): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Displays the Unpin from Start flyout at the specified side of a specified area. This flyout lets the user confirm removal of the secondary tile.
 * @param selection The area to the side of which the flyout will be displayed.
 * @param preferredPlacement One of the enumeration values that specifies the side of the rectangle where the flyout should be shown.
 * @return An object that provides information concerning the asynchronous delete operation.
 */
requestDeleteForSelectionAsync(
selection: Windows$Foundation$Rect,
preferredPlacement: $Values<typeof Windows$UI$Popups$Placement>): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets or sets a value that determines whether the secondary tile will be reacquired through the cloud when the parent app is installed by the user, using their Microsoft account, on another computer. Note that as of Windows 8.1, roaming is the default behavior. This is the opposite of the default Windows 8 behavior, where roaming was opt-in.
 */
roamingEnabled: boolean;

/**
 * Gets or sets a short name to display directly on the tile.
 */
shortName: string;

/**
 * Gets or sets the small logo image, used in search results, the All Programs list, and other locations in the UI.
 */
smallLogo: Windows$Foundation$Uri;

/**
 * Gets or sets a unique string to identify the tile within the package. This property is required when you create or delete a tile.
 */
tileId: string;

/**
 * Gets or sets options available to a secondary tile.
 */
tileOptions: $Values<typeof Windows$UI$StartScreen$TileOptions>;

/**
 * Updates a secondary tile after that tile is pinned to the Start screen.
 * @return An object used to launch the asynchronous create operation as well as to retrieve information about it.
 */
updateAsync(): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Gets an object through which you can get or set a secondary tile's background color, foreground text, tile images, and app name display options. As of Windows 8.1, the properties of this object replace these SecondaryTile properties:
 */
visualElements: Windows$UI$StartScreen$SecondaryTileVisualElements;

/**
 * Gets or sets the logo image used in a wide secondary tile. This property is required when you create a wide secondary tile and gives the user the option of a wide tile when they resize the tile.
 */
wideLogo: Windows$Foundation$Uri;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Contains properties through which you can get or set a secondary tile's background color, foreground text, tile images, and app name display options. The properties in this class replace these SecondaryTile properties:
 */
declare class Windows$UI$StartScreen$SecondaryTileVisualElements  {

/**
 * Gets or sets the secondary tile's background color.
 */
backgroundColor: Windows$UI$Color;

/**
 * Specifies whether the tile should use dark or light text.
 */
foregroundText: $Values<typeof Windows$UI$StartScreen$ForegroundText>;

/**
 * Specifies whether the display name should be shown on the medium secondary tile.
 */
showNameOnSquare150x150Logo: boolean;

/**
 * Specifies whether the display name should be shown on the large secondary tile.
 */
showNameOnSquare310x310Logo: boolean;

/**
 * Specifies whether the display name should be shown on the wide secondary tile.
 */
showNameOnWide310x150Logo: boolean;

/**
 * Gets or sets the medium secondary tile image.
 */
square150x150Logo: Windows$Foundation$Uri;

/**
 * Gets or sets the square30x30 secondary tile image.
 */
square30x30Logo: Windows$Foundation$Uri;

/**
 * Gets or sets the large secondary tile image.
 */
square310x310Logo: Windows$Foundation$Uri;

/**
 * Gets or sets the square44x44 secondary tile image.
 */
square44x44Logo: Windows$Foundation$Uri;

/**
 * Gets or sets the small secondary tile image.
 */
square70x70Logo: Windows$Foundation$Uri;

/**
 * Gets or sets the small secondary tile image.
 */
square71x71Logo: Windows$Foundation$Uri;

/**
 * Gets or sets the wide secondary tile image.
 */
wide310x150Logo: Windows$Foundation$Uri
}


/**
 * Specifies options available to a secondary tile.
 */

declare  var Windows$UI$StartScreen$TileOptions: {|
  +none: 0,// 0
+showNameOnLogo: 1,// 1
+showNameOnWideLogo: 2,// 2
+copyOnDeployment: 3,// 3

|};



/**
 * Specifies the size of tile to pin. Used by some secondary tile constructors.
 */

declare  var Windows$UI$StartScreen$TileSize: {|
  +default: 0,// 0
+square30x30: 1,// 1
+square70x70: 2,// 2
+square150x150: 3,// 3
+wide310x150: 4,// 4
+square310x310: 5,// 5
+square71x71: 6,// 6
+square44x44: 7,// 7

|};



/**
 * Provides a method to delay the display of the Pin to Start flyout, as well as methods through which you can set the visual elements of the secondary tile to be presented in that flyout as well as alternate versions of the tile that can also be presented as options.
 */
declare class Windows$UI$StartScreen$VisualElementsRequest  {

/**
 * Gets a set of objects that provide alternate logo images, background and foreground colors, and display name. These alternates are shown to the user in the Pin to Start flyout.
 */
alternateVisualElements: Windows$Foundation$Collections$IVectorView<Windows$UI$StartScreen$SecondaryTileVisualElements>;

/**
 * Gets the approximate time at which the deferral will time-out.
 */
deadline: Date;

/**
 * Retrieves a deferral object, which allows the app time to provide information and assets used in the Pin to Start flyout.
 * @return The deferral object.
 */
getDeferral(): Windows$UI$StartScreen$VisualElementsRequestDeferral;

/**
 * Gets a copy of the parent secondary tile's SecondaryTileVisualElements object. The visual elements properties can be set or read through this object. When deferral is complete (or the handler returns without a deferral), the properties in this object are verified and then reflected in the Pin to Start flyout.
 */
visualElements: Windows$UI$StartScreen$SecondaryTileVisualElements
}


/**
 * A deferral object used during the creation of the Pin to Start flyout. By using this object, the app can delay the display of the flyout while it gathers the information and assets that will be shown in that flyout.
 */
declare class Windows$UI$StartScreen$VisualElementsRequestDeferral  {

/**
 * Tells Windows that the app is ready to display the Pin to Start flyout. The app calls this method when it has finished setting the properties that specify what to show in that flyout.
 */
complete(): void
}


/**
 * Passed to the SecondaryTile.VisualElementsRequested event handler to provide the visual elements details.
 */
declare class Windows$UI$StartScreen$VisualElementsRequestedEventArgs  {

/**
 * Gets the VisualElementsRequest object for the event.
 */
request: Windows$UI$StartScreen$VisualElementsRequest
}


      declare var npm$namespace$Windows$UI$Text: {
        
        
        CaretType: typeof Windows$UI$Text$CaretType,
FindOptions: typeof Windows$UI$Text$FindOptions,
FontStretch: typeof Windows$UI$Text$FontStretch,
FontStyle: typeof Windows$UI$Text$FontStyle,
FormatEffect: typeof Windows$UI$Text$FormatEffect,
HorizontalCharacterAlignment: typeof Windows$UI$Text$HorizontalCharacterAlignment,
LetterCase: typeof Windows$UI$Text$LetterCase,
LineSpacingRule: typeof Windows$UI$Text$LineSpacingRule,
LinkType: typeof Windows$UI$Text$LinkType,
MarkerAlignment: typeof Windows$UI$Text$MarkerAlignment,
MarkerStyle: typeof Windows$UI$Text$MarkerStyle,
MarkerType: typeof Windows$UI$Text$MarkerType,
ParagraphAlignment: typeof Windows$UI$Text$ParagraphAlignment,
ParagraphStyle: typeof Windows$UI$Text$ParagraphStyle,
PointOptions: typeof Windows$UI$Text$PointOptions,
RangeGravity: typeof Windows$UI$Text$RangeGravity,
SelectionOptions: typeof Windows$UI$Text$SelectionOptions,
SelectionType: typeof Windows$UI$Text$SelectionType,
TabAlignment: typeof Windows$UI$Text$TabAlignment,
TabLeader: typeof Windows$UI$Text$TabLeader,
TextGetOptions: typeof Windows$UI$Text$TextGetOptions,
TextRangeUnit: typeof Windows$UI$Text$TextRangeUnit,
TextScript: typeof Windows$UI$Text$TextScript,
TextSetOptions: typeof Windows$UI$Text$TextSetOptions,
UnderlineType: typeof Windows$UI$Text$UnderlineType,
VerticalCharacterAlignment: typeof Windows$UI$Text$VerticalCharacterAlignment,
        
        Core: typeof npm$namespace$Windows$UI$Text$Core,
      }

/**
 * Specifies the caret type.
 */

declare  var Windows$UI$Text$CaretType: {|
  +normal: 0,// 0
+null: 1,// 1

|};



      declare var npm$namespace$Windows$UI$Text$Core: {
        
        
        CoreTextFormatUpdatingReason: typeof Windows$UI$Text$Core$CoreTextFormatUpdatingReason,
CoreTextFormatUpdatingResult: typeof Windows$UI$Text$Core$CoreTextFormatUpdatingResult,
CoreTextInputPaneDisplayPolicy: typeof Windows$UI$Text$Core$CoreTextInputPaneDisplayPolicy,
CoreTextInputScope: typeof Windows$UI$Text$Core$CoreTextInputScope,
CoreTextSelectionUpdatingResult: typeof Windows$UI$Text$Core$CoreTextSelectionUpdatingResult,
CoreTextTextUpdatingResult: typeof Windows$UI$Text$Core$CoreTextTextUpdatingResult,
        CoreTextCompositionCompletedEventArgs: typeof Windows$UI$Text$Core$CoreTextCompositionCompletedEventArgs,
CoreTextCompositionSegment: typeof Windows$UI$Text$Core$CoreTextCompositionSegment,
CoreTextCompositionStartedEventArgs: typeof Windows$UI$Text$Core$CoreTextCompositionStartedEventArgs,
CoreTextEditContext: typeof Windows$UI$Text$Core$CoreTextEditContext,
CoreTextFormatUpdatingEventArgs: typeof Windows$UI$Text$Core$CoreTextFormatUpdatingEventArgs,
CoreTextLayoutBounds: typeof Windows$UI$Text$Core$CoreTextLayoutBounds,
CoreTextLayoutRequest: typeof Windows$UI$Text$Core$CoreTextLayoutRequest,
CoreTextLayoutRequestedEventArgs: typeof Windows$UI$Text$Core$CoreTextLayoutRequestedEventArgs,
CoreTextSelectionRequest: typeof Windows$UI$Text$Core$CoreTextSelectionRequest,
CoreTextSelectionRequestedEventArgs: typeof Windows$UI$Text$Core$CoreTextSelectionRequestedEventArgs,
CoreTextSelectionUpdatingEventArgs: typeof Windows$UI$Text$Core$CoreTextSelectionUpdatingEventArgs,
CoreTextServicesConstants: typeof Windows$UI$Text$Core$CoreTextServicesConstants,
CoreTextServicesManager: typeof Windows$UI$Text$Core$CoreTextServicesManager,
CoreTextTextRequest: typeof Windows$UI$Text$Core$CoreTextTextRequest,
CoreTextTextRequestedEventArgs: typeof Windows$UI$Text$Core$CoreTextTextRequestedEventArgs,
CoreTextTextUpdatingEventArgs: typeof Windows$UI$Text$Core$CoreTextTextUpdatingEventArgs,
        
      }

/**
 * Provides data for the CompositionCompleted event.
 */
declare class Windows$UI$Text$Core$CoreTextCompositionCompletedEventArgs  {

/**
 * Gets a collection of CoreTextCompositionSegment objects representing the segments in the composition string. Applications can use this property, for example, to get the pre-conversion string for each composition segment.
 */
compositionSegments: Windows$Foundation$Collections$IVectorView<Windows$UI$Text$Core$CoreTextCompositionSegment>;

/**
 * Requests that the operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return A Deferral object.
 */
getDeferral(): Windows$Foundation$Deferral;

/**
 * Gets a value that indicates whether the operation is canceled.
 */
isCanceled: boolean
}


/**
 * Represents a segment in a composition string. See Remarks for an illustration.
 */
declare class Windows$UI$Text$Core$CoreTextCompositionSegment  {

/**
 * Gets a string that represents the state of the user input after IME-processing but before final conversion.
 */
preconversionString: string;

/**
 * Gets an object that represents the range that defines this composition segment.
 */
range: Windows$UI$Text$Core$CoreTextRange
}


/**
 * Provides data for the CompositionStarted event.
 */
declare class Windows$UI$Text$Core$CoreTextCompositionStartedEventArgs  {

/**
 * Requests that the operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return A Deferral object.
 */
getDeferral(): Windows$Foundation$Deferral;

/**
 * Gets a value that indicates whether the operation is canceled.
 */
isCanceled: boolean
}


/**
 * The primary object used by text input controls to communicate with the text input server.
 */
declare class Windows$UI$Text$Core$CoreTextEditContext  {

/**
 * Gets or sets a value that indicates whether the input pane should be shown automatically when focus enters your text input control. The default value is Automatic, indicating that the input pane will be shown automatically. A value of Manual indicates that your app will be responsible for showing and hiding the input pane using InputPane.TryShow and TryHide .
 */
inputPaneDisplayPolicy: $Values<typeof Windows$UI$Text$Core$CoreTextInputPaneDisplayPolicy>;

/**
 * Gets or sets a value that indicates the input scope of the text input control.
 */
inputScope: $Values<typeof Windows$UI$Text$Core$CoreTextInputScope>;

/**
 * Gets or sets a value that indicates whether the edit control is editable.
 */
isReadOnly: boolean;

/**
 * Gets or sets a descriptive name for the text input control. An application framework usually uses properties such as "name" or "id" to identify a control, so its recommended that you set this property accordingly on the text input server so that input processors can better preserve the input context, and provide better suggestions.
 */
name: string;

/**
 * Notifies the text input server that focus has entered the text input control.
 */
notifyFocusEnter(): void;

/**
 * Notifies the text input server that focus has left the text input control.
 */
notifyFocusLeave(): void;

/**
 * Notifies the text input server that the layout of text inside the text input control has changed.
 */
notifyLayoutChanged(): void;

/**
 * Notifies the text input server about any change that the text input control needs to make to the selection range. This is important in order to keep the internal state of the control and the internal state of the server synchronized.
 * @param selection The range of selection currently in effect.
 */
notifySelectionChanged(selection: Windows$UI$Text$Core$CoreTextRange): void;

/**
 * Notifies the text input server about any change that the text input control needs to make to the text. This is important in order to keep the internal state of the control and the internal state of the server synchronized. Since a change to the text is also likely to affect the selection range, the method takes the selection range as a parameter.
 * @param modifiedRange The range of text to replace, in terms of the state the text buffer is in prior to this text change.
 * @param newLength The length of the text that should replace modifiedRange.
 * @param newSelection The range of selection in effect after the text change.
 */
notifyTextChanged(
modifiedRange: Windows$UI$Text$Core$CoreTextRange,
newLength: number,
newSelection: Windows$UI$Text$Core$CoreTextRange): void;

/**
 * Occurs when composition has completed.
 */
oncompositioncompleted: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextCompositionCompletedEventArgs>;
addEventListener(
type: "compositioncompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextCompositionCompletedEventArgs>): void;
removeEventListener(
type: "compositioncompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextCompositionCompletedEventArgs>): void;

/**
 * Occurs when composition has started.
 */
oncompositionstarted: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextCompositionStartedEventArgs>;
addEventListener(
type: "compositionstarted",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextCompositionStartedEventArgs>): void;
removeEventListener(
type: "compositionstarted",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextCompositionStartedEventArgs>): void;

/**
 * Occurs when focus was forcibly removed from a text input control. The application should handle this event to remove focus for the text input control accordingly.
 */
onfocusremoved: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, any>;
addEventListener(
type: "focusremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, any>): void;
removeEventListener(
type: "focusremoved",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, any>): void;

/**
 * Occurs when the text input server needs to apply a different format to a particular range of text. This usually happens during composition.
 */
onformatupdating: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextFormatUpdatingEventArgs>;
addEventListener(
type: "formatupdating",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextFormatUpdatingEventArgs>): void;
removeEventListener(
type: "formatupdating",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextFormatUpdatingEventArgs>): void;

/**
 * Occurs when the text input server needs to get the bounding box of a range of text and of the text input control itself. The application should handle this event and return the geometry information requested.
 */
onlayoutrequested: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextLayoutRequestedEventArgs>;
addEventListener(
type: "layoutrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextLayoutRequestedEventArgs>): void;
removeEventListener(
type: "layoutrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextLayoutRequestedEventArgs>): void;

/**
 * Occurs after focus has left the text input control.
 */
onnotifyfocusleavecompleted: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, any>;
addEventListener(
type: "notifyfocusleavecompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, any>): void;
removeEventListener(
type: "notifyfocusleavecompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, any>): void;

/**
 * Occurs when the text input server needs to get the text range representing the currently selected text in the text input control. The application should handle this event and return the range requested.
 */
onselectionrequested: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextSelectionRequestedEventArgs>;
addEventListener(
type: "selectionrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextSelectionRequestedEventArgs>): void;
removeEventListener(
type: "selectionrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextSelectionRequestedEventArgs>): void;

/**
 * Occurs when the text input server needs to modify the range of text currently selected in the text input control. This event could be the result of an input processor needing to select some text, or to move the caret. The text input control should set its selection range accordingly.
 */
onselectionupdating: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextSelectionUpdatingEventArgs>;
addEventListener(
type: "selectionupdating",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextSelectionUpdatingEventArgs>): void;
removeEventListener(
type: "selectionupdating",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextSelectionUpdatingEventArgs>): void;

/**
 * Occurs when the text input server needs to get a range of text from the text input control. The application should handle this event and return the range requested.
 */
ontextrequested: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextTextRequestedEventArgs>;
addEventListener(
type: "textrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextTextRequestedEventArgs>): void;
removeEventListener(
type: "textrequested",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextTextRequestedEventArgs>): void;

/**
 * Occurs when the text input server needs to modify text inside the text input control. This event could be the result of a key eventsuch as inserting a single characteror the result of processing done by an input processor, such as auto-correction and prediction.
 */
ontextupdating: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextTextUpdatingEventArgs>;
addEventListener(
type: "textupdating",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextTextUpdatingEventArgs>): void;
removeEventListener(
type: "textupdating",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextEditContext, Windows$UI$Text$Core$CoreTextTextUpdatingEventArgs>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the FormatUpdating event.
 */
declare class Windows$UI$Text$Core$CoreTextFormatUpdatingEventArgs  {

/**
 * Gets a value that represents the background color to be applied to the text range. The text input server populates this property before raising the event.
 */
backgroundColor: $Values<typeof Windows$UI$ViewManagement$UIElementType>;

/**
 * Requests that the format update operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return A Deferral object.
 */
getDeferral(): Windows$Foundation$Deferral;

/**
 * Gets a value that indicates whether the format update operation is canceled.
 */
isCanceled: boolean;

/**
 * Gets a value that indicates the range of text that the text input server needs to format. The server populates this property before raising the event.
 */
range: Windows$UI$Text$Core$CoreTextRange;

/**
 * Gets a value that indicates the reason that the text input server needs to apply formatting to this range of text. The server populates this property before raising the event.
 */
reason: $Values<typeof Windows$UI$Text$Core$CoreTextFormatUpdatingReason>;

/**
 * Gets or sets a value that indicates the result of handling the FormatUpdating event. The default value is Succeeded but if you can't action the operation as the text input server expects then before returning from the event handler set the property to the appropriate value to indicate what has happened.
 */
result: $Values<typeof Windows$UI$Text$Core$CoreTextFormatUpdatingResult>;

/**
 * Gets a value that represents the text color to be applied to the text range. The text input server populates this property before raising the event.
 */
textColor: $Values<typeof Windows$UI$ViewManagement$UIElementType>;

/**
 * Gets a value that represents the underline color to be applied to the text range. The text input server populates this property before raising the event.
 */
underlineColor: $Values<typeof Windows$UI$ViewManagement$UIElementType>;

/**
 * Gets a value that represents the underline type to be applied to the text range. The text input server populates this property before raising the event.
 */
underlineType: $Values<typeof Windows$UI$Text$UnderlineType>
}


/**
 * Defines constants that specify the set of state applied during text composition.
 */

declare  var Windows$UI$Text$Core$CoreTextFormatUpdatingReason: {|
  +none: 0,// 0
+compositionUnconverted: 1,// 1
+compositionConverted: 2,// 2
+compositionTargetUnconverted: 3,// 3
+compositionTargetConverted: 4,// 4

|};



/**
 * Defines constants that specify the result of handling the FormatUpdating event.
 */

declare  var Windows$UI$Text$Core$CoreTextFormatUpdatingResult: {|
  +succeeded: 0,// 0
+failed: 1,// 1

|};



/**
 * Defines constants that specify whether the input pane should be shown automatically when focus enters your text input control.
 */

declare  var Windows$UI$Text$Core$CoreTextInputPaneDisplayPolicy: {|
  +automatic: 0,// 0
+manual: 1,// 1

|};



/**
 * Defines constants that specify the set of input scope names. Input scope is used by the text input server and input processors to determine the layout of the Soft Input Panel (SIP), and what type of language model to use.
 */

declare  var Windows$UI$Text$Core$CoreTextInputScope: {|
  +default: 0,// 0
+url: 1,// 1
+filePath: 2,// 2
+fileName: 3,// 3
+emailUserName: 4,// 4
+emailAddress: 5,// 5
+userName: 6,// 6
+personalFullName: 7,// 7
+personalNamePrefix: 8,// 8
+personalGivenName: 9,// 9
+personalMiddleName: 10,// 10
+personalSurname: 11,// 11
+personalNameSuffix: 12,// 12
+address: 13,// 13
+addressPostalCode: 14,// 14
+addressStreet: 15,// 15
+addressStateOrProvince: 16,// 16
+addressCity: 17,// 17
+addressCountryName: 18,// 18
+addressCountryShortName: 19,// 19
+currencyAmountAndSymbol: 20,// 20
+currencyAmount: 21,// 21
+date: 22,// 22
+dateMonth: 23,// 23
+dateDay: 24,// 24
+dateYear: 25,// 25
+dateMonthName: 26,// 26
+dateDayName: 27,// 27
+number: 28,// 28
+singleCharacter: 29,// 29
+password: 30,// 30
+telephoneNumber: 31,// 31
+telephoneCountryCode: 32,// 32
+telephoneAreaCode: 33,// 33
+telephoneLocalNumber: 34,// 34
+time: 35,// 35
+timeHour: 36,// 36
+timeMinuteOrSecond: 37,// 37
+numberFullWidth: 38,// 38
+alphanumericHalfWidth: 39,// 39
+alphanumericFullWidth: 40,// 40
+currencyChinese: 41,// 41
+bopomofo: 42,// 42
+hiragana: 43,// 43
+katakanaHalfWidth: 44,// 44
+katakanaFullWidth: 45,// 45
+hanja: 46,// 46
+hangulHalfWidth: 47,// 47
+hangulFullWidth: 48,// 48
+search: 49,// 49
+formula: 50,// 50
+searchIncremental: 51,// 51
+chineseHalfWidth: 52,// 52
+chineseFullWidth: 53,// 53
+nativeScript: 54,// 54
+text: 55,// 55
+chat: 56,// 56
+nameOrPhoneNumber: 57,// 57
+emailUserNameOrAddress: 58,// 58
+private: 59,// 59
+maps: 60,// 60
+passwordNumeric: 61,// 61
+formulaNumber: 62,// 62

|};



/**
 * Represents the bounding boxesin screen coordinatesof a range of text, and of a text input control.
 */
declare class Windows$UI$Text$Core$CoreTextLayoutBounds  {

/**
 * Gets or sets the bounding box in screen coordinates of a text input control.
 */
controlBounds: Windows$Foundation$Rect;

/**
 * Gets or sets the bounding box in screen coordinates of a range of text.
 */
textBounds: Windows$Foundation$Rect
}


/**
 * Represents information about a LayoutRequested event.
 */
declare class Windows$UI$Text$Core$CoreTextLayoutRequest  {

/**
 * Requests that the layout request operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return A Deferral object.
 */
getDeferral(): Windows$Foundation$Deferral;

/**
 * Gets a value that indicates whether the layout request operation is canceled.
 */
isCanceled: boolean;

/**
 * Gets an object that represents the layout bounds information requested by the text input server. The application should populate the properties of this object to the layout bounds being requested before returning from the event handler.
 */
layoutBounds: Windows$UI$Text$Core$CoreTextLayoutBounds;

/**
 * Gets a value that indicates the range of text whose bounding box is being requested by the text input server. The server populates this property before raising the event.
 */
range: Windows$UI$Text$Core$CoreTextRange
}


/**
 * Provides data for the LayoutRequested event.
 */
declare class Windows$UI$Text$Core$CoreTextLayoutRequestedEventArgs  {

/**
 * Gets information about a LayoutRequested event.
 */
request: Windows$UI$Text$Core$CoreTextLayoutRequest
}


/**
 * Represents information about a SelectionRequested event.
 */
declare class Windows$UI$Text$Core$CoreTextSelectionRequest  {

/**
 * Requests that the selection request operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return A Deferral object.
 */
getDeferral(): Windows$Foundation$Deferral;

/**
 * Gets a value that indicates whether the selection request operation is canceled.
 */
isCanceled: boolean;

/**
 * Gets or sets the selection range that the text input server is requesting. The application should set the current range of selection before returning from the event handler.
 */
selection: Windows$UI$Text$Core$CoreTextRange
}


/**
 * Provides data for the SelectionRequested event.
 */
declare class Windows$UI$Text$Core$CoreTextSelectionRequestedEventArgs  {

/**
 * Gets information about a SelectionRequested event.
 */
request: Windows$UI$Text$Core$CoreTextSelectionRequest
}


/**
 * Provides data for the SelectionUpdating event.
 */
declare class Windows$UI$Text$Core$CoreTextSelectionUpdatingEventArgs  {

/**
 * Requests that the selection update operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return A Deferral object.
 */
getDeferral(): Windows$Foundation$Deferral;

/**
 * Gets a value that indicates whether the selection update operation is canceled.
 */
isCanceled: boolean;

/**
 * Gets or sets a value that indicates the result of handling the SelectionUpdating event. The default value is Succeeded but if you can't action the operation as the text input server expects then before returning from the event handler set the property to the appropriate value to indicate what has happened.
 */
result: $Values<typeof Windows$UI$Text$Core$CoreTextSelectionUpdatingResult>;

/**
 * Gets a value that indicates the range of text that the text input server indicates should be selected. The server populates this property before raising the event.
 */
selection: Windows$UI$Text$Core$CoreTextRange
}


/**
 * Defines constants that specify the result of handling the SelectionUpdating event.
 */

declare  var Windows$UI$Text$Core$CoreTextSelectionUpdatingResult: {|
  +succeeded: 0,// 0
+failed: 1,// 1

|};



/**
 * Provides constant values for use with the Windows core text APIs and the text input server.
 */
declare class Windows$UI$Text$Core$CoreTextServicesConstants  {

/**
 * Gets a value to use to replace hidden data inside a text stream before returning the text to the text input server.
 */
static hiddenCharacter: string
}


/**
 * The entry point to all services provided by the Windows core text APIs and the text input server. This object is associated with an application's UI thread (the thread that CoreWindow runs on).
 */
declare class Windows$UI$Text$Core$CoreTextServicesManager  {

/**
 * Gets the CoreTextServicesManager object for the currently active view.
 * @return A CoreTextServicesManager instance, which can be used to create further objects to support the app's text input scenarios.
 */
static getForCurrentView(): Windows$UI$Text$Core$CoreTextServicesManager;

/**
 * Creates a context object used by a text input control to communicate with the text input server. Each text input control must create its own context object.
 * @return A CoreTextEditContext instance, which is the primary object used for communicating with the text input server.
 */
createEditContext(): Windows$UI$Text$Core$CoreTextEditContext;

/**
 * Gets a Language object representing the current input language.
 */
inputLanguage: Windows$Globalization$Language;

/**
 * Occurs when the current input language has changed.
 */
oninputlanguagechanged: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextServicesManager, any>;
addEventListener(
type: "inputlanguagechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextServicesManager, any>): void;
removeEventListener(
type: "inputlanguagechanged",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$Text$Core$CoreTextServicesManager, any>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents information about a TextRequested event.
 */
declare class Windows$UI$Text$Core$CoreTextTextRequest  {

/**
 * Requests that the text request operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return A Deferral object.
 */
getDeferral(): Windows$Foundation$Deferral;

/**
 * Gets a value that indicates whether the text request operation is canceled.
 */
isCanceled: boolean;

/**
 * Gets a value that indicates the range of text being requested by the text input server. The server populates this property before raising the event.
 */
range: Windows$UI$Text$Core$CoreTextRange;

/**
 * Gets or sets the text that the text input server is requesting. The application should set the text being requested before returning from the event handler.
 */
text: string
}


/**
 * Provides data for the TextRequested event.
 */
declare class Windows$UI$Text$Core$CoreTextTextRequestedEventArgs  {

/**
 * Gets information about a TextRequested event.
 */
request: Windows$UI$Text$Core$CoreTextTextRequest
}


/**
 * Provides data for the TextUpdating event.
 */
declare class Windows$UI$Text$Core$CoreTextTextUpdatingEventArgs  {

/**
 * Requests that the text update operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return A Deferral deferral object.
 */
getDeferral(): Windows$Foundation$Deferral;

/**
 * Gets a Language object representing the current input language.
 */
inputLanguage: Windows$Globalization$Language;

/**
 * Gets a value that indicates whether the text update operation is canceled.
 */
isCanceled: boolean;

/**
 * Gets a value that indicates the range of text that the text input server indicates should be selected. The server populates this property before raising the event.
 */
newSelection: Windows$UI$Text$Core$CoreTextRange;

/**
 * Gets a value that indicates the range of text that the text input server needs to modify. The server populates this property before raising the event.
 */
range: Windows$UI$Text$Core$CoreTextRange;

/**
 * Gets or sets a value that indicates the result of handling the TextUpdating event. The default value is Succeeded but if you can't action the operation as the text input server expects then before returning from the event handler set the property to the appropriate value to indicate what has happened.
 */
result: $Values<typeof Windows$UI$Text$Core$CoreTextTextUpdatingResult>;

/**
 * Gets the text that the text input server is requesting to be set into the modified range. The server populates this property before raising the event.
 */
text: string
}


/**
 * Defines constants that specify the result of handling the TextUpdating event.
 */

declare  var Windows$UI$Text$Core$CoreTextTextUpdatingResult: {|
  +succeeded: 0,// 0
+failed: 1,// 1

|};



/**
 * Defines a range of text inside a text input control.
 */
declare interface Windows$UI$Text$Core$CoreTextRange {

/**
 * The end position of a range in Application Character Position (ACP) terms.
 */
endCaretPosition: number,

/**
 * The start position of a range in Application Character Position (ACP) terms.
 */
startCaretPosition: number
} 


/**
 * Specifies the options to use when doing a text search.
 */

declare  var Windows$UI$Text$FindOptions: {|
  +none: 0,// 0
+word: 1,// 1
+case: 2,// 2

|};



/**
 * Describes the degree to which a font has been stretched, compared to the normal aspect ratio of that font.
 */

declare  var Windows$UI$Text$FontStretch: {|
  +undefined: 0,// 0
+ultraCondensed: 1,// 1
+extraCondensed: 2,// 2
+condensed: 3,// 3
+semiCondensed: 4,// 4
+normal: 5,// 5
+semiExpanded: 6,// 6
+expanded: 7,// 7
+extraExpanded: 8,// 8
+ultraExpanded: 9,// 9

|};



/**
 * Represents the style of a font face (for example, normal or italic).
 */

declare  var Windows$UI$Text$FontStyle: {|
  +normal: 0,// 0
+oblique: 1,// 1
+italic: 2,// 2

|};



/**
 * Defines values that indicate the state of a character or paragraph formatting property.
 */

declare  var Windows$UI$Text$FormatEffect: {|
  +off: 0,// 0
+on: 1,// 1
+toggle: 2,// 2
+undefined: 3,// 3

|};



/**
 * Specifies the horizontal position of a character relative to a bounding rectangle.
 */

declare  var Windows$UI$Text$HorizontalCharacterAlignment: {|
  +left: 0,// 0
+right: 1,// 1
+center: 2,// 2

|};



/**
 * Represents the character case formatting.
 */

declare  var Windows$UI$Text$LetterCase: {|
  +lower: 0,// 0
+upper: 1,// 1

|};



/**
 * Specifies options for line-spacing rules.
 */

declare  var Windows$UI$Text$LineSpacingRule: {|
  +undefined: 0,// 0
+single: 1,// 1
+oneAndHalf: 2,// 2
+double: 3,// 3
+atLeast: 4,// 4
+exactly: 5,// 5
+multiple: 6,// 6
+percent: 7,// 7

|};



/**
 * Indicates the link type of a range of text.
 */

declare  var Windows$UI$Text$LinkType: {|
  +undefined: 0,// 0
+notALink: 1,// 1
+clientLink: 2,// 2
+friendlyLinkName: 3,// 3
+friendlyLinkAddress: 4,// 4
+autoLink: 5,// 5
+autoLinkEmail: 6,// 6
+autoLinkPhone: 7,// 7
+autoLinkPath: 8,// 8

|};



/**
 * Defines bullet and numbering alignment.
 */

declare  var Windows$UI$Text$MarkerAlignment: {|
  +undefined: 0,// 0
+left: 1,// 1
+center: 2,// 2
+right: 3,// 3

|};



/**
 * Specifies the style used to mark the item paragraphs in a list.
 */

declare  var Windows$UI$Text$MarkerStyle: {|
  +undefined: 0,// 0
+parenthesis: 1,// 1
+parentheses: 2,// 2
+period: 3,// 3
+plain: 4,// 4
+minus: 5,// 5
+noNumber: 6,// 6

|};



/**
 * Specifies the kind of characters used to mark the item paragraphs in a list.
 */

declare  var Windows$UI$Text$MarkerType: {|
  +undefined: 0,// 0
+none: 1,// 1
+bullet: 2,// 2
+arabic: 3,// 3
+lowercaseEnglishLetter: 4,// 4
+uppercaseEnglishLetter: 5,// 5
+lowercaseRoman: 6,// 6
+uppercaseRoman: 7,// 7
+unicodeSequence: 8,// 8
+circledNumber: 9,// 9
+blackCircleWingding: 10,// 10
+whiteCircleWingding: 11,// 11
+arabicWide: 12,// 12
+simplifiedChinese: 13,// 13
+traditionalChinese: 14,// 14
+japanSimplifiedChinese: 15,// 15
+japanKorea: 16,// 16
+arabicDictionary: 17,// 17
+arabicAbjad: 18,// 18
+hebrew: 19,// 19
+thaiAlphabetic: 20,// 20
+thaiNumeric: 21,// 21
+devanagariVowel: 22,// 22
+devanagariConsonant: 23,// 23
+devanagariNumeric: 24,// 24

|};



/**
 * Specifies values for aligning paragraphs.
 */

declare  var Windows$UI$Text$ParagraphAlignment: {|
  +undefined: 0,// 0
+left: 1,// 1
+center: 2,// 2
+right: 3,// 3
+justify: 4,// 4

|};



/**
 * Specifies the paragraph style.
 */

declare  var Windows$UI$Text$ParagraphStyle: {|
  +undefined: 0,// 0
+none: 1,// 1
+normal: 2,// 2
+heading1: 3,// 3
+heading2: 4,// 4
+heading3: 5,// 5
+heading4: 6,// 6
+heading5: 7,// 7
+heading6: 8,// 8
+heading7: 9,// 9
+heading8: 10,// 10
+heading9: 11,// 11

|};



/**
 * Defines options for specifying or retrieving a point.
 */

declare  var Windows$UI$Text$PointOptions: {|
  +none: 0,// 0
+includeInset: 1,// 1
+start: 2,// 2
+clientCoordinates: 3,// 3
+allowOffClient: 4,// 4
+transform: 5,// 5
+noHorizontalScroll: 6,// 6
+noVerticalScroll: 7,// 7

|};



/**
 * Specifies the gravity for a text range.
 */

declare  var Windows$UI$Text$RangeGravity: {|
  +uiBehavior: 0,// 0
+backward: 1,// 1
+forward: 2,// 2
+inward: 3,// 3
+outward: 4,// 4

|};



/**
 * Describes the options that apply to a selection.
 */

declare  var Windows$UI$Text$SelectionOptions: {|
  +startActive: 0,// 0
+atEndOfLine: 1,// 1
+overtype: 2,// 2
+active: 3,// 3
+replace: 4,// 4

|};



/**
 * Specifies the type of a selection.
 */

declare  var Windows$UI$Text$SelectionType: {|
  +none: 0,// 0
+insertionPoint: 1,// 1
+normal: 2,// 2
+inlineShape: 3,// 3
+shape: 4,// 4

|};



/**
 * Alignment options for tab positions.
 */

declare  var Windows$UI$Text$TabAlignment: {|
  +left: 0,// 0
+center: 1,// 1
+right: 2,// 2
+decimal: 3,// 3
+bar: 4,// 4

|};



/**
 * The character that is used to fill the space taken by a tab character.
 */

declare  var Windows$UI$Text$TabLeader: {|
  +spaces: 0,// 0
+dots: 1,// 1
+dashes: 2,// 2
+lines: 3,// 3
+thickLines: 4,// 4
+equals: 5,// 5

|};



/**
 * Specifies options for retrieving the text in a document or text range.
 */

declare  var Windows$UI$Text$TextGetOptions: {|
  +none: 0,// 0
+adjustCrlf: 1,// 1
+useCrlf: 2,// 2
+useObjectText: 3,// 3
+allowFinalEop: 4,// 4
+noHidden: 5,// 5
+includeNumbering: 6,// 6
+formatRtf: 7,// 7

|};



/**
 * Specifies the units to use when navigating a text range.
 */

declare  var Windows$UI$Text$TextRangeUnit: {|
  +character: 0,// 0
+word: 1,// 1
+sentence: 2,// 2
+paragraph: 3,// 3
+line: 4,// 4
+story: 5,// 5
+screen: 6,// 6
+section: 7,// 7
+window: 8,// 8
+characterFormat: 9,// 9
+paragraphFormat: 10,// 10
+object: 11,// 11
+hardParagraph: 12,// 12
+cluster: 13,// 13
+bold: 14,// 14
+italic: 15,// 15
+underline: 16,// 16
+strikethrough: 17,// 17
+protectedText: 18,// 18
+link: 19,// 19
+smallCaps: 20,// 20
+allCaps: 21,// 21
+hidden: 22,// 22
+outline: 23,// 23
+shadow: 24,// 24
+imprint: 25,// 25
+disabled: 26,// 26
+revised: 27,// 27
+subscript: 28,// 28
+superscript: 29,// 29
+fontBound: 30,// 30
+linkProtected: 31,// 31

|};



/**
 * Specifies the character repertoire (typically the script) for a run of character formatting.
 */

declare  var Windows$UI$Text$TextScript: {|
  +undefined: 0,// 0
+ansi: 1,// 1
+eastEurope: 2,// 2
+cyrillic: 3,// 3
+greek: 4,// 4
+turkish: 5,// 5
+hebrew: 6,// 6
+arabic: 7,// 7
+baltic: 8,// 8
+vietnamese: 9,// 9
+default: 10,// 10
+symbol: 11,// 11
+thai: 12,// 12
+shiftJis: 13,// 13
+gb2312: 14,// 14
+hangul: 15,// 15
+big5: 16,// 16
+pc437: 17,// 17
+oem: 18,// 18
+mac: 19,// 19
+armenian: 20,// 20
+syriac: 21,// 21
+thaana: 22,// 22
+devanagari: 23,// 23
+bengali: 24,// 24
+gurmukhi: 25,// 25
+gujarati: 26,// 26
+oriya: 27,// 27
+tamil: 28,// 28
+telugu: 29,// 29
+kannada: 30,// 30
+malayalam: 31,// 31
+sinhala: 32,// 32
+lao: 33,// 33
+tibetan: 34,// 34
+myanmar: 35,// 35
+georgian: 36,// 36
+jamo: 37,// 37
+ethiopic: 38,// 38
+cherokee: 39,// 39
+aboriginal: 40,// 40
+ogham: 41,// 41
+runic: 42,// 42
+khmer: 43,// 43
+mongolian: 44,// 44
+braille: 45,// 45
+yi: 46,// 46
+limbu: 47,// 47
+taiLe: 48,// 48
+newTaiLue: 49,// 49
+sylotiNagri: 50,// 50
+kharoshthi: 51,// 51
+kayahli: 52,// 52
+unicodeSymbol: 53,// 53
+emoji: 54,// 54
+glagolitic: 55,// 55
+lisu: 56,// 56
+vai: 57,// 57
+nko: 58,// 58
+osmanya: 59,// 59
+phagsPa: 60,// 60
+gothic: 61,// 61
+deseret: 62,// 62
+tifinagh: 63,// 63

|};



/**
 * Specifies options for setting the text in a text range.
 */

declare  var Windows$UI$Text$TextSetOptions: {|
  +none: 0,// 0
+unicodeBidi: 1,// 1
+unlink: 2,// 2
+unhide: 3,// 3
+checkTextLimit: 4,// 4
+formatRtf: 5,// 5
+applyRtfDocumentDefaults: 6,// 6

|};



/**
 * Specifies the type of character underlining.
 */

declare  var Windows$UI$Text$UnderlineType: {|
  +undefined: 0,// 0
+none: 1,// 1
+single: 2,// 2
+words: 3,// 3
+double: 4,// 4
+dotted: 5,// 5
+dash: 6,// 6
+dashDot: 7,// 7
+dashDotDot: 8,// 8
+wave: 9,// 9
+thick: 10,// 10
+thin: 11,// 11
+doubleWave: 12,// 12
+heavyWave: 13,// 13
+longDash: 14,// 14
+thickDash: 15,// 15
+thickDashDot: 16,// 16
+thickDashDotDot: 17,// 17
+thickDotted: 18,// 18
+thickLongDash: 19,// 19

|};



/**
 * Specifies the vertical position of a character relative to a bounding rectangle.
 */

declare  var Windows$UI$Text$VerticalCharacterAlignment: {|
  +top: 0,// 0
+baseline: 1,// 1
+bottom: 2,// 2

|};



/**
 * Refers to the density of a typeface, in terms of the lightness or heaviness of the strokes.
 */
declare interface Windows$UI$Text$FontWeight {

/**
 * The font weight expressed as a numeric value. See Remarks.
 */
weight: number
} 


      declare var npm$namespace$Windows$UI$ViewManagement: {
        
        
        ApplicationViewBoundsMode: typeof Windows$UI$ViewManagement$ApplicationViewBoundsMode,
ApplicationViewOrientation: typeof Windows$UI$ViewManagement$ApplicationViewOrientation,
ApplicationViewState: typeof Windows$UI$ViewManagement$ApplicationViewState,
ApplicationViewSwitchingOptions: typeof Windows$UI$ViewManagement$ApplicationViewSwitchingOptions,
ApplicationViewWindowingMode: typeof Windows$UI$ViewManagement$ApplicationViewWindowingMode,
FullScreenSystemOverlayMode: typeof Windows$UI$ViewManagement$FullScreenSystemOverlayMode,
HandPreference: typeof Windows$UI$ViewManagement$HandPreference,
UIColorType: typeof Windows$UI$ViewManagement$UIColorType,
UIElementType: typeof Windows$UI$ViewManagement$UIElementType,
UserInteractionMode: typeof Windows$UI$ViewManagement$UserInteractionMode,
ViewSizePreference: typeof Windows$UI$ViewManagement$ViewSizePreference,
        AccessibilitySettings: typeof Windows$UI$ViewManagement$AccessibilitySettings,
ActivationViewSwitcher: typeof Windows$UI$ViewManagement$ActivationViewSwitcher,
ApplicationView: typeof Windows$UI$ViewManagement$ApplicationView,
ApplicationViewConsolidatedEventArgs: typeof Windows$UI$ViewManagement$ApplicationViewConsolidatedEventArgs,
ApplicationViewSwitcher: typeof Windows$UI$ViewManagement$ApplicationViewSwitcher,
ApplicationViewTitleBar: typeof Windows$UI$ViewManagement$ApplicationViewTitleBar,
ApplicationViewTransferContext: typeof Windows$UI$ViewManagement$ApplicationViewTransferContext,
InputPane: typeof Windows$UI$ViewManagement$InputPane,
InputPaneVisibilityEventArgs: typeof Windows$UI$ViewManagement$InputPaneVisibilityEventArgs,
ProjectionManager: typeof Windows$UI$ViewManagement$ProjectionManager,
UISettings: typeof Windows$UI$ViewManagement$UISettings,
UIViewSettings: typeof Windows$UI$ViewManagement$UIViewSettings,
        
      }

/**
 * Provides access to the high contrast accessibility settings.
 */
declare class Windows$UI$ViewManagement$AccessibilitySettings  {

/**
 * Initializes a new AccessibilitySettings object.
 */
constructor(): this;

/**
 * Gets a value that indicates whether the system high contrast feature is on or off.
 */
highContrast: boolean;

/**
 * Gets the name of the default high contrast color scheme.
 */
highContrastScheme: string;

/**
 * Occurs when the system high contrast feature turns on or off.
 */
onhighcontrastchanged: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$AccessibilitySettings, any>;
addEventListener(
type: "highcontrastchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$AccessibilitySettings, any>): void;
removeEventListener(
type: "highcontrastchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$AccessibilitySettings, any>): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}

declare class Windows$UI$ViewManagement$ActivationViewSwitcher  {
isViewPresentedOnActivationVirtualDesktop: any;

/**
 * Shows the view in a new standalone window and sets the size preference for the view.
 * @param viewId The identifier for the view.
 * @param sizePreference The preferred size of the view.
 * @return The asynchronous results of the operation. Use this to determine when the async call is complete.
 */
showAsStandaloneAsync(
viewId: number,
sizePreference: $Values<typeof Windows$UI$ViewManagement$ViewSizePreference>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Shows the view in a new standalone window.
 * @param viewId The identifier for the view.
 * @return The asynchronous results of the operation. Use this to determine when the async call is complete.
 */
showAsStandaloneAsync(viewId: number): Windows$Foundation$IPromiseWithIAsyncAction
}


/**
 * Represents the active application view and associated states and behaviors.
 */
declare class Windows$UI$ViewManagement$ApplicationView  {

/**
 * Gets the view state and behavior settings of the active application.
 * @return An ApplicationView instance that can be used to get and set app display properties.
 */
static getForCurrentView(): Windows$UI$ViewManagement$ApplicationView;

/**
 * Gets or sets the size the app launches with if no view size is remembered by Windows.
 */
static preferredLaunchViewSize: Windows$Foundation$Size;

/**
 * Gets or sets a value that indicates the windowing mode the app launches with.
 */
static preferredLaunchWindowingMode: $Values<typeof Windows$UI$ViewManagement$ApplicationViewWindowingMode>;

/**
 * Indicates whether the app terminates when the last window is closed.
 */
static terminateAppOnFinalViewClose: boolean;

/**
 * Attempts to unsnap a previously snapped app. This call will only succeed when the app is running in the foreground.
 * @return true if the app has been successfully unsnapped; false if the unsnap attempt failed.
 */
static tryUnsnap(): boolean;
static tryUnsnapToFullscreen: any;

/**
 * Gets the state of the current window (app view).
 */
static value: $Values<typeof Windows$UI$ViewManagement$ApplicationViewState>;

/**
 * Gets whether the current window (app view) is adjacent to the left edge of the screen, whether the window is full-screen or docked.
 */
adjacentToLeftDisplayEdge: boolean;

/**
 * Gets whether the current window (app view) is adjacent to the right edge of the screen, whether the window is full-screen or docked.
 */
adjacentToRightDisplayEdge: boolean;

/**
 * Gets a value that indicates the bounds used by the framework to lay out the contents of the window (app view).
 */
desiredBoundsMode: $Values<typeof Windows$UI$ViewManagement$ApplicationViewBoundsMode>;

/**
 * Takes the app out of full-screen mode.
 */
exitFullScreenMode(): void;

/**
 * Gets or sets a value that indicates how an app in full-screen mode responds to edge swipe actions.
 */
fullScreenSystemOverlayMode: $Values<typeof Windows$UI$ViewManagement$FullScreenSystemOverlayMode>;

/**
 * Gets the ID of the window (app view).
 */
id: number;

/**
 * Gets whether the window (app view) fills the entire screen.
 */
isFullScreen: boolean;
isFullScreenMode: any;

/**
 * Gets whether the window (app view) is on the Windows lock screen.
 */
isOnLockScreen: boolean;

/**
 * Gets or sets whether screen capture is enabled for the window (app view).
 */
isScreenCaptureEnabled: boolean;

/**
 * Occurs when the window is removed from the list of recently used apps, or if the user executes a close gesture on it.
 */
onconsolidated: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$ApplicationView, Windows$UI$ViewManagement$ApplicationViewConsolidatedEventArgs>;
addEventListener(
type: "consolidated",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$ApplicationView, Windows$UI$ViewManagement$ApplicationViewConsolidatedEventArgs>): void;
removeEventListener(
type: "consolidated",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$ApplicationView, Windows$UI$ViewManagement$ApplicationViewConsolidatedEventArgs>): void;

/**
 * This event is raised when the value of VisibleBounds changes, typically as a result of the status bar, app bar, or other chrome being shown or hidden.
 */
onvisibleboundschanged: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$ApplicationView, any>;
addEventListener(
type: "visibleboundschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$ApplicationView, any>): void;
removeEventListener(
type: "visibleboundschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$ApplicationView, any>): void;

/**
 * Gets the current orientation (landscape or portrait) of the window (app view) with respect to the display.
 */
orientation: $Values<typeof Windows$UI$ViewManagement$ApplicationViewOrientation>;

/**
 * Sets a value indicating the bounds used by the framework to lay out the contents of the window (app view).
 * @param boundsMode The bounds that the framework should use to lay out the contents of the window (app view).
 * @return true to confirm that the change to DesiredBoundsMode was successful; otherwise, false.
 */
setDesiredBoundsMode(
boundsMode: $Values<typeof Windows$UI$ViewManagement$ApplicationViewBoundsMode>): boolean;

/**
 * Sets the smallest size, in effective pixels, allowed for the app window.
 * @param minSize The smallest size allowed for the app window, or a Size whose height and width are both zero to use the system default minimum size.
 */
setPreferredMinSize(minSize: Windows$Foundation$Size): void;

/**
 * Shows system UI elements, like the title bar, over a full-screen app.
 */
showStandardSystemOverlays(): void;

/**
 * Gets or sets a value indicating whether or not system overlays (such as overlay applications or the soft steering wheel) should be shown.
 */
suppressSystemOverlays: boolean;

/**
 * Gets or sets the displayed title of the window.
 */
title: string;

/**
 * Gets the title bar of the app.
 */
titleBar: Windows$UI$ViewManagement$ApplicationViewTitleBar;

/**
 * Attempts to place the app in full-screen mode.
 * @return true if the app is placed in full-screen mode; otherwise, false.
 */
tryEnterFullScreenMode(): boolean;

/**
 * Attempts to change the size of the view to the specified size.
 * @param value The new size of the view.
 * @return true if the view is resized; otherwise, false.
 */
tryResizeView(value: Windows$Foundation$Size): boolean;

/**
 * Gets the visible region of the window (app view). The visible region is the region not occluded by chrome such as the status bar and app bar.
 */
visibleBounds: Windows$Foundation$Rect;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * The bounds used by the framework to lay out the contents of a window (app view).
 */

declare  var Windows$UI$ViewManagement$ApplicationViewBoundsMode: {|
  +useVisible: 0,// 0
+useCoreWindow: 1,// 1

|};



/**
 * Contains the results of a window (app view) consolidation operation.
 */
declare class Windows$UI$ViewManagement$ApplicationViewConsolidatedEventArgs  {

/**
 * Indicates whether the window consolidation was user- or system-initiated.
 */
isUserInitiated: boolean
}


/**
 * Defines the set of display orientation modes for a window (app view).
 */

declare  var Windows$UI$ViewManagement$ApplicationViewOrientation: {|
  +landscape: 0,// 0
+portrait: 1,// 1

|};



/**
 * Specifies the set of app view state changes that can be handled.
 */

declare  var Windows$UI$ViewManagement$ApplicationViewState: {|
  +fullScreenLandscape: 0,// 0
+filled: 1,// 1
+snapped: 2,// 2
+fullScreenPortrait: 3,// 3

|};



/**
 * Represents the app view switching behaviors for an app.
 */
declare class Windows$UI$ViewManagement$ApplicationViewSwitcher  {

/**
 * Disables the primary window (app view) when the app is activated, showing the most recently displayed window instead.
 */
static disableShowingMainViewOnActivation(): void;
static disableSystemViewActivationPolicy: any;

/**
 * Prepares your app to visually transition between two windows with a custom animation.
 * @param toViewId The ID of the window from which your app is transitioning.
 * @param fromViewId The ID of the window to which your app is transitioning.
 * @param options Enumeration value that specifies thw view switching behaviors.
 * @return Asynchronously returns true if the call succeeds; false if it does not.
 */
static prepareForCustomAnimatedSwitchAsync(
toViewId: number,
fromViewId: number,
options: $Values<typeof Windows$UI$ViewManagement$ApplicationViewSwitchingOptions>): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Visually replaces the calling window (app view) with a specified window.
 * @param viewId The ID of the window under preparation for display.
 * @return The asynchronous results of the operation. Use this to determine when the async call is complete.
 */
static switchAsync(viewId: number): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Visually replaces the calling window (app view) with a specified window.
 * @param toViewId The ID of the window under preparation for display.
 * @param fromViewId The ID of the calling, currently displayed window.
 * @return The asynchronous results of the operation. Use this to determine when the async call is complete.
 */
static switchAsync(
toViewId: number,
fromViewId: number): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Visually replaces the calling window (app view) with a specified window.
 * @param toViewId The ID of the window under preparation for display.
 * @param fromViewId The ID of the calling, currently displayed window.
 * @param options Options for the display transition behaviors.
 * @return The asynchronous results of the operation. Use this to determine when the async call is complete.
 */
static switchAsync(
toViewId: number,
fromViewId: number,
options: $Values<typeof Windows$UI$ViewManagement$ApplicationViewSwitchingOptions>): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Displays another window (app view) for the app on the screen, adjacent to the original window.
 * @param viewId The ID of the new window to display.
 * @param sizePreference The preferred general sizing of the new window.
 * @param anchorViewId The ID of the calling (anchor) window.
 * @param anchorSizePreference The preferred new general sizing of the calling window if this call succeeds.
 * @return Asynchronously returns true if the call succeeds; false if it does not.
 */
static tryShowAsStandaloneAsync(
viewId: number,
sizePreference: $Values<typeof Windows$UI$ViewManagement$ViewSizePreference>,
anchorViewId: number,
anchorSizePreference: $Values<typeof Windows$UI$ViewManagement$ViewSizePreference>): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Displays another window (app view) for the app on the screen, adjacent to the original window
 * @param viewId The ID of the new window to display.
 * @return Asynchronously returns true if the call succeeds; false if it does not.
 */
static tryShowAsStandaloneAsync(viewId: number): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Displays another window (app view) for the app on the screen, adjacent to the original window
 * @param viewId The ID of the new window to display.
 * @param sizePreference The preferred general sizing of the new window.
 * @return Asynchronously returns true if the call succeeds; false if it does not.
 */
static tryShowAsStandaloneAsync(
viewId: number,
sizePreference: $Values<typeof Windows$UI$ViewManagement$ViewSizePreference>): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>
}


/**
 * Defines a set of options for window (app view) switching behaviors.
 */

declare  var Windows$UI$ViewManagement$ApplicationViewSwitchingOptions: {|
  +default: 0,// 0
+skipAnimation: 1,// 1
+consolidateViews: 2,// 2

|};



/**
 * Represents the title bar of an app.
 */
declare class Windows$UI$ViewManagement$ApplicationViewTitleBar  {

/**
 * Gets or sets the color of the title bar background.
 */
backgroundColor: Windows$UI$Color;

/**
 * Gets or sets the background color of the title bar buttons.
 */
buttonBackgroundColor: Windows$UI$Color;

/**
 * Gets or sets the foreground color of the title bar buttons.
 */
buttonForegroundColor: Windows$UI$Color;

/**
 * Gets or sets the background color of a title bar button when the pointer is over it.
 */
buttonHoverBackgroundColor: Windows$UI$Color;

/**
 * Gets or sets the foreground color of a title bar button when the pointer is over it.
 */
buttonHoverForegroundColor: Windows$UI$Color;

/**
 * Gets or sets the background color of a title bar button when it's inactive.
 */
buttonInactiveBackgroundColor: Windows$UI$Color;

/**
 * Gets or sets the foreground color of a title bar button when it's inactive.
 */
buttonInactiveForegroundColor: Windows$UI$Color;

/**
 * Gets or sets the background color of a title bar button when it's pressed.
 */
buttonPressedBackgroundColor: Windows$UI$Color;

/**
 * Gets or sets the foreground color of a title bar button when it's pressed.
 */
buttonPressedForegroundColor: Windows$UI$Color;

/**
 * Gets or sets the color of the title bar foreground.
 */
foregroundColor: Windows$UI$Color;

/**
 * Gets or sets the color of the title bar background when it's inactive.
 */
inactiveBackgroundColor: Windows$UI$Color;

/**
 * Gets or sets the color of the title bar foreground when it's inactive.
 */
inactiveForegroundColor: Windows$UI$Color
}

declare class Windows$UI$ViewManagement$ApplicationViewTransferContext  {
static dataPackageFormatId: any;
viewId: any
}


/**
 * Defines constants that specify whether the app window is auto-sized, full-screen, or set to a specific size on launch.
 */

declare  var Windows$UI$ViewManagement$ApplicationViewWindowingMode: {|
  +auto: 0,// 0
+preferredLaunchViewSize: 1,// 1
+fullScreen: 2,// 2

|};



/**
 * Defines constants that specify how the app responds to edge gestures when in full-screen mode.
 */

declare  var Windows$UI$ViewManagement$FullScreenSystemOverlayMode: {|
  +standard: 0,// 0
+minimal: 1,// 1

|};



/**
 * Defines the set of directional preferences for the user interface presented by the app view.
 */

declare  var Windows$UI$ViewManagement$HandPreference: {|
  +leftHanded: 0,// 0
+rightHanded: 1,// 1

|};



/**
 * Enables an app to register to receive notifications when the input pane is about to be displayed or hidden, and to determine which portion of the application's window is being obscured by the input pane.
 */
declare class Windows$UI$ViewManagement$InputPane  {

/**
 * Gets the InputPane object associated with the application window that is currently visible.
 * @return The input pane.
 */
static getForCurrentView(): Windows$UI$ViewManagement$InputPane;

/**
 * Gets the region of the app window obscured by the input pane.
 */
occludedRect: Windows$Foundation$Rect;

/**
 * Occurs when the input pane is about to be hidden by sliding out of view.
 */
onhiding: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$InputPane, Windows$UI$ViewManagement$InputPaneVisibilityEventArgs>;
addEventListener(
type: "hiding",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$InputPane, Windows$UI$ViewManagement$InputPaneVisibilityEventArgs>): void;
removeEventListener(
type: "hiding",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$InputPane, Windows$UI$ViewManagement$InputPaneVisibilityEventArgs>): void;

/**
 * Occurs when the input pane is about to be displayed by sliding into view.
 */
onshowing: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$InputPane, Windows$UI$ViewManagement$InputPaneVisibilityEventArgs>;
addEventListener(
type: "showing",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$InputPane, Windows$UI$ViewManagement$InputPaneVisibilityEventArgs>): void;
removeEventListener(
type: "showing",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$InputPane, Windows$UI$ViewManagement$InputPaneVisibilityEventArgs>): void;

/**
 * Hides the InputPane if it is showing.
 * @return true if the InputPane was hidden successfully; otherwise false.
 */
tryHide(): boolean;

/**
 * Shows the InputPane if it is hidden.
 * @return true if the InputPane was shown successfully; otherwise false.
 */
tryShow(): boolean;

/**
 * Gets or sets a value that indicates whether the input pane is shown.
 */
visible: boolean;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the input pane Hiding and Showing events.
 */
declare class Windows$UI$ViewManagement$InputPaneVisibilityEventArgs  {

/**
 * Identifies whether the application has taken steps to ensure that the input pane doesn't cover the UI element that has focus.
 */
ensuredFocusedElementInView: boolean;

/**
 * Gets the region of the application's window that the input pane is covering.
 */
occludedRect: Windows$Foundation$Rect
}


/**
 * Defines a set of methods for managing the windows (app views) sent to secondary displays, such as projectors.
 */
declare class Windows$UI$ViewManagement$ProjectionManager  {

/**
 * Returns a string that is used to enumerate device services.
 * @return A string that is used to enumerate device services.
 */
static getDeviceSelector(): string;

/**
 * Occurs when a projector or other secondary display becomes available or unavailable.
 */
static onprojectiondisplayavailablechanged: Windows$Foundation$EventHandler<any>;
static addEventListener(
type: "projectiondisplayavailablechanged",
listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(
type: "projectiondisplayavailablechanged",
listener: Windows$Foundation$EventHandler<any>): void;

/**
 * Gets whether or not a projection display is available to use.
 */
static projectionDisplayAvailable: boolean;

/**
 * Makes a request to asynchronously sends a window (app view) to the projector or other secondary display with the specified preferred placement.
 * @param projectionViewId The new ID of the window to be displayed by the projector or other secondary display.
 * @param anchorViewId The ID of the original window before projection.
 * @param selection The area to one side of which the flyout is displayed.
 * @param prefferedPlacement The side of the rectangle where the flyout should appear.
 * @return true if projection started; otherwise, false.
 */
static requestStartProjectingAsync(
projectionViewId: number,
anchorViewId: number,
selection: Windows$Foundation$Rect,
prefferedPlacement: $Values<typeof Windows$UI$Popups$Placement>): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Makes a request to asynchronously sends a window (app view) to the projector or other secondary display.
 * @param projectionViewId The new ID of the window to be displayed by the projector or other secondary display.
 * @param anchorViewId The ID of the original window before projection.
 * @param selection The area to one side of which the flyout is displayed.
 * @return true if projection started; otherwise, false.
 */
static requestStartProjectingAsync(
projectionViewId: number,
anchorViewId: number,
selection: Windows$Foundation$Rect): Windows$Foundation$IPromiseWithIAsyncOperation<boolean>;

/**
 * Asynchronously sends a window (app view) to the projector or other secondary display.
 * @param projectionViewId The new ID of the window to be displayed by the projector or other secondary display.
 * @param anchorViewId The ID of the original window before projection.
 * @return The asynchronous results of the operation. Use this to determine when the async call is complete.
 */
static startProjectingAsync(
projectionViewId: number,
anchorViewId: number): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously sends a window (app view) to the projector or other secondary display, and provides info about the display.
 * @param projectionViewId The new ID of the window to be displayed by the projector or other secondary display.
 * @param anchorViewId The ID of the original window before projection.
 * @param displayDeviceInfo Information about the display device.
 * @return The asynchronous results of the operation. Use this to determine when the async call is complete.
 */
static startProjectingAsync(
projectionViewId: number,
anchorViewId: number,
displayDeviceInfo: Windows$Devices$Enumeration$DeviceInformation): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously hides a window (app view) displayed by a projector or other secondary display.
 * @param projectionViewId The ID of the window currently displayed by the projector or other secondary display.
 * @param anchorViewId The ID of the original window before projection.
 * @return The asynchronous results of the operation. Use this to determine when the async call is complete.
 */
static stopProjectingAsync(
projectionViewId: number,
anchorViewId: number): Windows$Foundation$IPromiseWithIAsyncAction;

/**
 * Asynchronously swaps the calling window (app view) with the window displayed on the projector or other secondary display. The result is that the calling window is displayed on the projector, and the formerly projected window is displayed on the device screen.
 * @param projectionViewId The ID of the window currently displayed by the projector.
 * @param anchorViewId The ID of the window to swap with the projected window.
 * @return The asynchronous results of the operation. Use this to determine when the async call is complete.
 */
static swapDisplaysForViewsAsync(
projectionViewId: number,
anchorViewId: number): Windows$Foundation$IPromiseWithIAsyncAction;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Defines constants that specify known system color values.
 */

declare  var Windows$UI$ViewManagement$UIColorType: {|
  +background: 0,// 0
+foreground: 1,// 1
+accentDark3: 2,// 2
+accentDark2: 3,// 3
+accentDark1: 4,// 4
+accent: 5,// 5
+accentLight1: 6,// 6
+accentLight2: 7,// 7
+accentLight3: 8,// 8
+complement: 9,// 9

|};



/**
 * Defines the set of user interface element types.
 */

declare  var Windows$UI$ViewManagement$UIElementType: {|
  +activeCaption: 0,// 0
+background: 1,// 1
+buttonFace: 2,// 2
+buttonText: 3,// 3
+captionText: 4,// 4
+grayText: 5,// 5
+highlight: 6,// 6
+highlightText: 7,// 7
+hotlight: 8,// 8
+inactiveCaption: 9,// 9
+inactiveCaptionText: 10,// 10
+window: 11,// 11
+windowText: 12,// 12

|};



/**
 * Contains a set of common app user interface settings and operations.
 */
declare class Windows$UI$ViewManagement$UISettings  {

/**
 * Creates a new default instance of the UISettings class.
 */
constructor(): this;

/**
 * Gets whether animations are enabled for the user interface.
 */
animationsEnabled: boolean;

/**
 * Gets the blink rate of a new caret created by the app view.
 */
caretBlinkRate: number;

/**
 * Gets whether the caret can be used for browse operations.
 */
caretBrowsingEnabled: boolean;

/**
 * Gets the width of a new caret created by the app view.
 */
caretWidth: number;

/**
 * Gets the size of a new cursor created by the app view.
 */
cursorSize: Windows$Foundation$Size;

/**
 * Gets the maximum allowed time between clicks in a double-click operation.
 */
doubleClickTime: number;

/**
 * Returns the color value of the specified color type.
 * @param desiredColor An enumeration value that specifies the type of color to get a value for.
 * @return The color value of the specified color type.
 */
getColorValue(
desiredColor: $Values<typeof Windows$UI$ViewManagement$UIColorType>): Windows$UI$Color;

/**
 * Gets the directional preference of the user interface created by the app view.
 */
handPreference: $Values<typeof Windows$UI$ViewManagement$HandPreference>;

/**
 * Gets the length of time a message is displayed for the app view.
 */
messageDuration: number;

/**
 * Gets the amount of time the mouse pointer can rest in a hover rectangle before a hover event is raised.
 */
mouseHoverTime: number;

/**
 * Occurs when color values have changed.
 */
oncolorvalueschanged: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$UISettings, any>;
addEventListener(
type: "colorvalueschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$UISettings, any>): void;
removeEventListener(
type: "colorvalueschanged",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$UISettings, any>): void;

/**
 * Occurs when the system text size setting is changed.
 */
ontextscalefactorchanged: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$UISettings, any>;
addEventListener(
type: "textscalefactorchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$UISettings, any>): void;
removeEventListener(
type: "textscalefactorchanged",
listener: Windows$Foundation$TypedEventHandler<Windows$UI$ViewManagement$UISettings, any>): void;

/**
 * Gets the size of a scroll bar arrow for windows associated with the app view.
 */
scrollBarArrowSize: Windows$Foundation$Size;

/**
 * Gets the size of a scroll bar for windows associated with the app view.
 */
scrollBarSize: Windows$Foundation$Size;

/**
 * Gets the size of a thumb box for windows associated with the app view.
 */
scrollBarThumbBoxSize: Windows$Foundation$Size;

/**
 * Gets the value of the system text size setting.
 */
textScaleFactor: number;

/**
 * Gets the color used for a specific user interface element type, such as a button face or window text.
 * @param desiredElement The type of element for which the color will be obtained.
 * @return The color of the element type, expressed as a 32-bit color value.
 */
uiElementColor(
desiredElement: $Values<typeof Windows$UI$ViewManagement$UIElementType>): Windows$UI$Color;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Represents UI states and behaviors associated with the device mode (Tablet or Desktop) and input device type.
 */
declare class Windows$UI$ViewManagement$UIViewSettings  {

/**
 * Gets the UI states and behaviors associated with the device mode (Tablet or Desktop) for the active app.
 * @return A UIViewSettings instance that can be used to get and set view settings properties.
 */
static getForCurrentView(): Windows$UI$ViewManagement$UIViewSettings;

/**
 * Gets a value that indicates whether the device UI is optimized for touch input or mouse input.
 */
userInteractionMode: $Values<typeof Windows$UI$ViewManagement$UserInteractionMode>
}


/**
 * Specifies the UI view, optimized for input device type.
 */

declare  var Windows$UI$ViewManagement$UserInteractionMode: {|
  +mouse: 0,// 0
+touch: 1,// 1

|};



/**
 * Defines the set of possible general window (app view) size preferences.
 */

declare  var Windows$UI$ViewManagement$ViewSizePreference: {|
  +default: 0,// 0
+useLess: 1,// 1
+useHalf: 2,// 2
+useMore: 3,// 3
+useMinimum: 4,// 4
+useNone: 5,// 5

|};



      declare var npm$namespace$Windows$UI$WebUI: {
        
        
        PrintContent: typeof Windows$UI$WebUI$PrintContent,
        ActivatedDeferral: typeof Windows$UI$WebUI$ActivatedDeferral,
ActivatedOperation: typeof Windows$UI$WebUI$ActivatedOperation,
HtmlPrintDocumentSource: typeof Windows$UI$WebUI$HtmlPrintDocumentSource,
SuspendingDeferral: typeof Windows$UI$WebUI$SuspendingDeferral,
SuspendingEventArgs: typeof Windows$UI$WebUI$SuspendingEventArgs,
SuspendingOperation: typeof Windows$UI$WebUI$SuspendingOperation,
WebUIApplication: typeof Windows$UI$WebUI$WebUIApplication,
WebUIAppointmentsProviderAddAppointmentActivatedEventArgs: typeof Windows$UI$WebUI$WebUIAppointmentsProviderAddAppointmentActivatedEventArgs,
WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs: typeof Windows$UI$WebUI$WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs,
WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs: typeof Windows$UI$WebUI$WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs,
WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs: typeof Windows$UI$WebUI$WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs,
WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs: typeof Windows$UI$WebUI$WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs,
WebUIBackgroundTaskInstance: typeof Windows$UI$WebUI$WebUIBackgroundTaskInstance,
WebUIBackgroundTaskInstanceRuntimeClass: typeof Windows$UI$WebUI$WebUIBackgroundTaskInstanceRuntimeClass,
WebUICachedFileUpdaterActivatedEventArgs: typeof Windows$UI$WebUI$WebUICachedFileUpdaterActivatedEventArgs,
WebUICameraSettingsActivatedEventArgs: typeof Windows$UI$WebUI$WebUICameraSettingsActivatedEventArgs,
WebUIContactCallActivatedEventArgs: typeof Windows$UI$WebUI$WebUIContactCallActivatedEventArgs,
WebUIContactMapActivatedEventArgs: typeof Windows$UI$WebUI$WebUIContactMapActivatedEventArgs,
WebUIContactMessageActivatedEventArgs: typeof Windows$UI$WebUI$WebUIContactMessageActivatedEventArgs,
WebUIContactPickerActivatedEventArgs: typeof Windows$UI$WebUI$WebUIContactPickerActivatedEventArgs,
WebUIContactPostActivatedEventArgs: typeof Windows$UI$WebUI$WebUIContactPostActivatedEventArgs,
WebUIContactVideoCallActivatedEventArgs: typeof Windows$UI$WebUI$WebUIContactVideoCallActivatedEventArgs,
WebUIDeviceActivatedEventArgs: typeof Windows$UI$WebUI$WebUIDeviceActivatedEventArgs,
WebUIDevicePairingActivatedEventArgs: typeof Windows$UI$WebUI$WebUIDevicePairingActivatedEventArgs,
WebUIDialReceiverActivatedEventArgs: typeof Windows$UI$WebUI$WebUIDialReceiverActivatedEventArgs,
WebUIFileActivatedEventArgs: typeof Windows$UI$WebUI$WebUIFileActivatedEventArgs,
WebUIFileOpenPickerActivatedEventArgs: typeof Windows$UI$WebUI$WebUIFileOpenPickerActivatedEventArgs,
WebUIFileOpenPickerContinuationEventArgs: typeof Windows$UI$WebUI$WebUIFileOpenPickerContinuationEventArgs,
WebUIFileSavePickerActivatedEventArgs: typeof Windows$UI$WebUI$WebUIFileSavePickerActivatedEventArgs,
WebUIFileSavePickerContinuationEventArgs: typeof Windows$UI$WebUI$WebUIFileSavePickerContinuationEventArgs,
WebUIFolderPickerContinuationEventArgs: typeof Windows$UI$WebUI$WebUIFolderPickerContinuationEventArgs,
WebUILaunchActivatedEventArgs: typeof Windows$UI$WebUI$WebUILaunchActivatedEventArgs,
WebUILockScreenActivatedEventArgs: typeof Windows$UI$WebUI$WebUILockScreenActivatedEventArgs,
WebUILockScreenCallActivatedEventArgs: typeof Windows$UI$WebUI$WebUILockScreenCallActivatedEventArgs,
WebUINavigatedDeferral: typeof Windows$UI$WebUI$WebUINavigatedDeferral,
WebUINavigatedEventArgs: typeof Windows$UI$WebUI$WebUINavigatedEventArgs,
WebUINavigatedOperation: typeof Windows$UI$WebUI$WebUINavigatedOperation,
WebUIPrint3DWorkflowActivatedEventArgs: typeof Windows$UI$WebUI$WebUIPrint3DWorkflowActivatedEventArgs,
WebUIPrintTaskSettingsActivatedEventArgs: typeof Windows$UI$WebUI$WebUIPrintTaskSettingsActivatedEventArgs,
WebUIProtocolActivatedEventArgs: typeof Windows$UI$WebUI$WebUIProtocolActivatedEventArgs,
WebUIProtocolForResultsActivatedEventArgs: typeof Windows$UI$WebUI$WebUIProtocolForResultsActivatedEventArgs,
WebUIRestrictedLaunchActivatedEventArgs: typeof Windows$UI$WebUI$WebUIRestrictedLaunchActivatedEventArgs,
WebUISearchActivatedEventArgs: typeof Windows$UI$WebUI$WebUISearchActivatedEventArgs,
WebUIShareTargetActivatedEventArgs: typeof Windows$UI$WebUI$WebUIShareTargetActivatedEventArgs,
WebUIToastNotificationActivatedEventArgs: typeof Windows$UI$WebUI$WebUIToastNotificationActivatedEventArgs,
WebUIVoiceCommandActivatedEventArgs: typeof Windows$UI$WebUI$WebUIVoiceCommandActivatedEventArgs,
WebUIWalletActionActivatedEventArgs: typeof Windows$UI$WebUI$WebUIWalletActionActivatedEventArgs,
WebUIWebAccountProviderActivatedEventArgs: typeof Windows$UI$WebUI$WebUIWebAccountProviderActivatedEventArgs,
WebUIWebAuthenticationBrokerContinuationEventArgs: typeof Windows$UI$WebUI$WebUIWebAuthenticationBrokerContinuationEventArgs,
        
      }

/**
 * Manages delayed activation for an app.
 */
declare class Windows$UI$WebUI$ActivatedDeferral  {

/**
 * Notifies the system that the app has set up its state and initial UI and is ready to be displayed.
 */
complete(): void
}


/**
 * Manages an app activation operation.
 */
declare class Windows$UI$WebUI$ActivatedOperation  {

/**
 * Requests that the completion of app activation be delayed.
 * @return The activation deferral object.
 */
getDeferral(): Windows$UI$WebUI$ActivatedDeferral
}


/**
 * Manages the document source for app printing.
 */
declare class Windows$UI$WebUI$HtmlPrintDocumentSource  {

/**
 * Gets and sets the bottom margin of the document source.
 */
bottomMargin: number;

/**
 * Performs app-defined tasks that are associated with freeing, releasing, or resetting resources that were allocated for the document source.
 */
close(): void;

/**
 * Gets and sets the content of the document source to print.
 */
content: $Values<typeof Windows$UI$WebUI$PrintContent>;

/**
 * Gets and sets a value that controls whether header and footer are enabled in the document source.
 */
enableHeaderFooter: boolean;

/**
 * Gets and sets the left margin of the document source.
 */
leftMargin: number;

/**
 * Gets the range of pages that prints.
 */
pageRange: string;

/**
 * Gets and sets the size of the document source by percentage.
 */
percentScale: number;

/**
 * Gets and sets the right margin of the document source.
 */
rightMargin: number;

/**
 * Gets and sets a value that controls whether content shrinks to fit the document source.
 */
shrinkToFit: boolean;

/**
 * Gets and sets the top margin of the document source.
 */
topMargin: number;

/**
 * Tries to set the page range of the document source.
 * @param strPageRange The page range to set.
 * @return A Boolean value that indicates whether trySetPageRange set the page range in strPageRange. TRUE indicates the page range was set and FALSE otherwise.
 */
trySetPageRange(strPageRange: string): boolean
}


/**
 * Specifies the content that HtmlPrintDocumentSource.content prints.
 */

declare  var Windows$UI$WebUI$PrintContent: {|
  +allPages: 0,// 0
+currentPage: 1,// 1
+customPageRange: 2,// 2
+currentSelection: 3,// 3

|};



/**
 * Manages delayed suspension for an app. GetDeferral
 */
declare class Windows$UI$WebUI$SuspendingDeferral  {

/**
 * Notifies the system that the app has saved its data and is ready to be suspended.
 */
complete(): void
}


/**
 * Provides data for an app suspension event.
 */
declare class Windows$UI$WebUI$SuspendingEventArgs  {

/**
 * Gets the app suspension operation.
 */
suspendingOperation: Windows$ApplicationModel$SuspendingOperation
}


/**
 * Manages an app suspension operation.
 */
declare class Windows$UI$WebUI$SuspendingOperation  {

/**
 * Gets the time remaining before a delayed app suspension operation continues.
 */
deadline: Date;

/**
 * Requests that the app suspension operation be delayed.
 * @return The suspension deferral.
 */
getDeferral(): Windows$ApplicationModel$SuspendingDeferral
}


/**
 * Enables an app to receive notifications related to the lifetime of the app.
 */
declare class Windows$UI$WebUI$WebUIApplication  {

/**
 * Occurs when the app is activated.
 */
static onactivated: Windows$UI$WebUI$ActivatedEventHandler;
static addEventListener(type: "activated", listener: Windows$UI$WebUI$ActivatedEventHandler): void;
static removeEventListener(type: "activated", listener: Windows$UI$WebUI$ActivatedEventHandler): void;

/**
 * Occurs when the app is navigating.
 */
static onnavigated: Windows$UI$WebUI$NavigatedEventHandler;
static addEventListener(type: "navigated", listener: Windows$UI$WebUI$NavigatedEventHandler): void;
static removeEventListener(type: "navigated", listener: Windows$UI$WebUI$NavigatedEventHandler): void;

/**
 * Occurs when the app is resuming.
 */
static onresuming: Windows$UI$WebUI$ResumingEventHandler;
static addEventListener(type: "resuming", listener: Windows$UI$WebUI$ResumingEventHandler): void;
static removeEventListener(type: "resuming", listener: Windows$UI$WebUI$ResumingEventHandler): void;

/**
 * Occurs when the app is suspending.
 */
static onsuspending: Windows$UI$WebUI$SuspendingEventHandler;
static addEventListener(type: "suspending", listener: Windows$UI$WebUI$SuspendingEventHandler): void;
static removeEventListener(type: "suspending", listener: Windows$UI$WebUI$SuspendingEventHandler): void;
static addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
static removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data when an app is activated to add an appointment to the users calendar.
 */
declare class Windows$UI$WebUI$WebUIAppointmentsProviderAddAppointmentActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the appointment that is provided to the app when the user tries to add it.
 */
addAppointmentOperation: Windows$ApplicationModel$Appointments$AppointmentsProvider$AddAppointmentOperation;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed by the appointments provider.
 */
verb: string
}


/**
 * Provides data when an app is activated to remove an appointment from the users calendar.
 */
declare class Windows$UI$WebUI$WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the appointment that is provided to the app when the user tries to remove it.
 */
removeAppointmentOperation: Windows$ApplicationModel$Appointments$AppointmentsProvider$RemoveAppointmentOperation;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed by the appointments provider.
 */
verb: string
}


/**
 * Provides data when an app is activated to replace an appointment in the users calendar.
 */
declare class Windows$UI$WebUI$WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the appointment that is provided to the app when the user tries to replace it.
 */
replaceAppointmentOperation: Windows$ApplicationModel$Appointments$AppointmentsProvider$ReplaceAppointmentOperation;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed by the appointments provider.
 */
verb: string
}


/**
 * Provides data when an app is activated to show the details of an appointment.
 */
declare class Windows$UI$WebUI$WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs  {

/**
 * Gets the app activation operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the start date of the appointment instance for which the app should display details.
 */
instanceStartDate: Date;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the local identifier of the appointment for which the app should display details.
 */
localId: string;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the roaming identifier of the appointment for which the app should display details.
 */
roamingId: string;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed by the appointments provider.
 */
verb: string
}


/**
 * Provides data when an app is activated to show a specified time frame on the users calendar.
 */
declare class Windows$UI$WebUI$WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the duration of the time frame to be shown.
 */
duration: number;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the starting date and time of the time frame to be shown.
 */
timeToShow: Date;

/**
 * Gets the action to be performed by the appointments provider.
 */
verb: string
}


/**
 * Represents an instance of a background task that has been triggered to run.
 */
declare class Windows$UI$WebUI$WebUIBackgroundTaskInstance  {

/**
 * Gets the current background task.
 */
static current: Windows$UI$WebUI$IWebUIBackgroundTaskInstance
}


/**
 * Provides access to an instance of a background task.
 */
declare class Windows$UI$WebUI$WebUIBackgroundTaskInstanceRuntimeClass  {

/**
 * Informs the system that the background task might continue to perform work after the IBackgroundTask.Run method returns. This method is not applicable to JavaScript background tasks.
 * @return A background task deferral.
 */
getDeferral(): Windows$ApplicationModel$Background$BackgroundTaskDeferral;

/**
 * Gets the instance ID of the background task instance.
 */
instanceId: string;

/**
 * Attaches a cancellation event handler to the background task instance.
 */
oncanceled: Windows$ApplicationModel$Background$BackgroundTaskCanceledEventHandler;
addEventListener(
type: "canceled",
listener: Windows$ApplicationModel$Background$BackgroundTaskCanceledEventHandler): void;
removeEventListener(
type: "canceled",
listener: Windows$ApplicationModel$Background$BackgroundTaskCanceledEventHandler): void;

/**
 * Gets or sets progress status for a background task instance.
 */
progress: number;

/**
 * Gets or sets the success value for the background task. The success value is what is returned to the foreground instance of your app in the completed event.
 */
succeeded: boolean;

/**
 * Gets the number of times resource management policy caused the background task to be suspended.
 */
suspendedCount: number;

/**
 * Gets access to the registered background task for this background task instance.
 */
task: Windows$ApplicationModel$Background$BackgroundTaskRegistration;

/**
 * Gets additional information associated with a background task instance.
 */
triggerDetails: any;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides information about the activated event that fires when the user saves or opens a file that needs updates from the app.
 */
declare class Windows$UI$WebUI$WebUICachedFileUpdaterActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the letterbox UI of the file picker that is displayed when a file needs updates from the app.
 */
cachedFileUpdaterUI: Windows$Storage$Provider$CachedFileUpdaterUI;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Enables a camera settings app to handle the activation parameters for the app.
 */
declare class Windows$UI$WebUI$WebUICameraSettingsActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the object that controls device settings on the camera.
 */
videoDeviceController: any;

/**
 * Gets the object that implements additional extended settings for the camera.
 */
videoDeviceExtension: any
}


/**
 * Provides data when an app is activated to call a contact.
 */
declare class Windows$UI$WebUI$WebUIContactCallActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the contact for the call.
 */
contact: Windows$ApplicationModel$Contacts$Contact;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the identifier of the service used for the call.
 */
serviceId: string;

/**
 * Gets the user identifier of the service used for the call.
 */
serviceUserId: string;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed.
 */
verb: string
}


/**
 * Provides data when an app is activated to map a contact.
 */
declare class Windows$UI$WebUI$WebUIContactMapActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the address of a contact for the mapping operation.
 */
address: Windows$ApplicationModel$Contacts$ContactAddress;

/**
 * Gets the contact for the mapping operation.
 */
contact: Windows$ApplicationModel$Contacts$Contact;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed.
 */
verb: string
}


/**
 * Provides data when an app is activated to message a contact.
 */
declare class Windows$UI$WebUI$WebUIContactMessageActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the contact for the message.
 */
contact: Windows$ApplicationModel$Contacts$Contact;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the identifier of the service used for the message.
 */
serviceId: string;

/**
 * Gets the user identifier of the service used for the message.
 */
serviceUserId: string;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed.
 */
verb: string
}


/**
 * Provides data when an app is activated because it uses the Contact Picker.
 */
declare class Windows$UI$WebUI$WebUIContactPickerActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the letterbox UI of the contact picker that is displayed when the user wants to pick contacts that are provided by the app.
 */
contactPickerUI: Windows$ApplicationModel$Contacts$Provider$ContactPickerUI;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides data when an app is activated to post a contact.
 */
declare class Windows$UI$WebUI$WebUIContactPostActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the contact for the post.
 */
contact: Windows$ApplicationModel$Contacts$Contact;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the identifier of the service used for the post.
 */
serviceId: string;

/**
 * Gets the user identifier of the service used for the post.
 */
serviceUserId: string;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed.
 */
verb: string
}


/**
 * Provides data when an app is activated to video call a contact.
 */
declare class Windows$UI$WebUI$WebUIContactVideoCallActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the contact for the video call.
 */
contact: Windows$ApplicationModel$Contacts$Contact;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the identifier of the service used for the video call.
 */
serviceId: string;

/**
 * Gets the user identifier of the service used for the video call.
 */
serviceUserId: string;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action to be performed.
 */
verb: string
}


/**
 * Provides information for a device that invokes AutoPlay.
 */
declare class Windows$UI$WebUI$WebUIDeviceActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Gets the device identifier for the device that invoked AutoPlay.
 */
deviceInformationId: string;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action associated with the activated device.
 */
verb: string
}


/**
 * Provides information for a device that invokes pairing.
 */
declare class Windows$UI$WebUI$WebUIDevicePairingActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets info about the device that triggered the operation.
 */
deviceInformation: Windows$Devices$Enumeration$DeviceInformation;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides data when an app is activated from another app by using the DIAL protocol.
 */
declare class Windows$UI$WebUI$WebUIDialReceiverActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the name of the app that invoked the dial receiver app.
 */
appName: string;

/**
 * Gets the arguments that are passed to the app during its launch activation.
 */
arguments: string;

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the identifier of the source tile that launched the app.
 */
tileId: string
}


/**
 * Provides data when an app is activated because it is the app associated with a file.
 */
declare class Windows$UI$WebUI$WebUIFileActivatedEventArgs  {

/**
 * Gets the app activation operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Gets the files for which the app was activated.
 */
files: Windows$Foundation$Collections$IVectorView<Windows$Storage$IStorageItem>;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the neighboring files of the files for which the app was activated.
 */
neighboringFilesQuery: Windows$Storage$Search$StorageFileQueryResult;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the action associated with the activated file.
 */
verb: string
}


/**
 * Provides information about an activated event that fires when the user tries to pick files or folders that are provided by the app.
 */
declare class Windows$UI$WebUI$WebUIFileOpenPickerActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the family name of the caller's package.
 */
callerPackageFamilyName: string;

/**
 * Gets the letterbox UI of the file picker that is displayed when the user wants to pick files or folders that are provided by the app.
 */
fileOpenPickerUI: Windows$Storage$Pickers$Provider$FileOpenPickerUI;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information about an activated event that fires after the app was suspended for a file open picker operation.
 */
declare class Windows$UI$WebUI$WebUIFileOpenPickerContinuationEventArgs  {

/**
 * Gets the app activation operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets a set of values populated by the app before a FileOpenPicker operation that deactivates the app in order to provide context when the app is activated.
 */
continuationData: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the files for which the app was activated.
 */
files: Windows$Foundation$Collections$IVectorView<Windows$Storage$StorageFile>;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information about an activated event that fires when the user saves a file through the file picker and selects the app as the location.
 */
declare class Windows$UI$WebUI$WebUIFileSavePickerActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the family name of the caller's package.
 */
callerPackageFamilyName: string;

/**
 * Gets the ID of the enterprise that owns the file.
 */
enterpriseId: string;

/**
 * Gets the letterbox UI of the file picker that is displayed when the user saves a file and selects the app as the save location.
 */
fileSavePickerUI: Windows$Storage$Pickers$Provider$FileSavePickerUI;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information about an activated event that fires after the app was suspended for a file save picker operation.
 */
declare class Windows$UI$WebUI$WebUIFileSavePickerContinuationEventArgs  {

/**
 * Gets the app activation operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets a set of values populated by the app before a FileSavePicker operation that deactivates the app in order to provide context when the app is activated.
 */
continuationData: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the file for which the app was activated.
 */
file: Windows$Storage$StorageFile;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information about an activated event that fires after the app was suspended for a folder picker operation.
 */
declare class Windows$UI$WebUI$WebUIFolderPickerContinuationEventArgs  {

/**
 * Gets the app activation operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets a set of values populated by the app before a FolderPicker operation that deactivates the app in order to provide context when the app is activated.
 */
continuationData: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the folder selected by the user during the folder picker operation.
 */
folder: Windows$Storage$StorageFolder;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides event information when an app is launched.
 */
declare class Windows$UI$WebUI$WebUILaunchActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the arguments that are passed to the app during its launch activation.
 */
arguments: string;

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * (Applies to Windows only) Gets an indication about whether a pre-launch has been activated.
 */
prelaunchActivated: boolean;

/**
 * Gets the execution state of the app before this activation.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the ID of the source that was invoked to launch the application.
 */
tileId: string
}


/**
 * Represents arguments used when the lock screen is activated.
 */
declare class Windows$UI$WebUI$WebUILockScreenActivatedEventArgs  {

/**
 * Gets the object that manages an app activation operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Gets information about the app activation operation.
 */
info: any;

/**
 * Gets and activation kind for the app activation operation.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the previous execution state.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides event information when communication to and from the lock screen is required.
 */
declare class Windows$UI$WebUI$WebUILockScreenCallActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the arguments that are passed to the app during its launch activation.
 */
arguments: string;

/**
 * Gets the UI that handles communication to and from the lock screen.
 */
callUI: Windows$ApplicationModel$Calls$LockScreenCallUI;

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the identifier of the source that launched the app.
 */
tileId: string
}


/**
 * Manages delayed navigation for an app.
 */
declare class Windows$UI$WebUI$WebUINavigatedDeferral  {

/**
 * Notifies the system that the app has set up its state and UI and is ready to be displayed after a top level navigation.
 */
complete(): void
}


/**
 * Provides data for an app navigation event.
 */
declare class Windows$UI$WebUI$WebUINavigatedEventArgs  {

/**
 * Gets the app navigation operation.
 */
navigatedOperation: Windows$UI$WebUI$WebUINavigatedOperation
}


/**
 * Manages an app navigation operation.
 */
declare class Windows$UI$WebUI$WebUINavigatedOperation  {

/**
 * Requests that the completion of app navigation be delayed.
 * @return The navigated deferral object.
 */
getDeferral(): Windows$UI$WebUI$WebUINavigatedDeferral
}


/**
 * Represents the arguments related to activating a 3D print workflow.
 */
declare class Windows$UI$WebUI$WebUIPrint3DWorkflowActivatedEventArgs  {

/**
 * Gets the activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the kind of activation.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the previous execution state.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the print workflow.
 */
workflow: Windows$Devices$Printers$Extensions$Print3DWorkflow
}


/**
 * Provided in response to the event that is raised when print task settings are activated.
 */
declare class Windows$UI$WebUI$WebUIPrintTaskSettingsActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the configuration information for the print task.
 */
configuration: Windows$Devices$Printers$Extensions$PrintTaskConfiguration;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before the settings were activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides data when an app is activated because it is the app associated with a URI scheme name.
 */
declare class Windows$UI$WebUI$WebUIProtocolActivatedEventArgs  {

/**
 * Gets the app activation operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the family name of the caller's package.
 */
callerPackageFamilyName: string;

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Gets the data used for activation.
 */
data: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the Uniform Resource Identifier (URI) for which the app was activated.
 */
uri: Windows$Foundation$Uri
}


/**
 * Describes the activation arguments when an app is launched via LaunchUriForResultsAsync .
 */
declare class Windows$UI$WebUI$WebUIProtocolForResultsActivatedEventArgs  {

/**
 * Gets the app activation operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the family name of the caller's package.
 */
callerPackageFamilyName: string;

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Gets the data associated with the activation.
 */
data: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the kind of activation.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the previous execution state.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets info about the protocol for results operation that triggered the activation.
 */
protocolForResultsOperation: Windows$System$ProtocolForResultsOperation;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the Uniform Resource Identifier (URI) for which the app was activated.
 */
uri: Windows$Foundation$Uri
}


/**
 * Provides event information when a restricted app is launched.
 */
declare class Windows$UI$WebUI$WebUIRestrictedLaunchActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets information about a shared context for the restricted launch.
 */
sharedContext: any;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information about the activated event that fires when the user searches the app from the Search charm and the app isn't the main app on screen.
 */
declare class Windows$UI$WebUI$WebUISearchActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the identifier for the currently shown app view.
 */
currentlyShownApplicationViewId: number;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the Internet Engineering Task Force (IETF) language tag (BCP 47 standard) that identifies the language currently associated with the user's text input device.
 */
language: string;

/**
 * Gets a SearchPaneQueryLinguisticDetails object that provides info about query text that the user enters through an Input Method Editor (IME).
 */
linguisticDetails: Windows$ApplicationModel$Search$SearchPaneQueryLinguisticDetails;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the text that the user wants the app to search for. The user entered this text into the search box of the search pane.
 */
queryText: string;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information for an application that is a target for share operations.
 */
declare class Windows$UI$WebUI$WebUIShareTargetActivatedEventArgs  {

/**
 * Gets the app activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets information about data included in a share operation.
 */
shareOperation: Windows$ApplicationModel$DataTransfer$ShareTarget$ShareOperation;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information about an event that occurs when the app is activated because a user tapped on the body of a toast notification or performed an action inside a toast notification.
 */
declare class Windows$UI$WebUI$WebUIToastNotificationActivatedEventArgs  {

/**
 * Gets the app activation operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the arguments that the app can retrieve after it is activated through an interactive toast notification.
 */
argument: string;

/**
 * Gets the kind of activation.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the previous execution state of the app.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets a set of values that you can use to obtain the user input from an interactive toast notification.
 */
userInput: Windows$Foundation$Collections$ValueSet
}


/**
 * Provides information about an activated event raised when the app is activated from a voice command.
 */
declare class Windows$UI$WebUI$WebUIVoiceCommandActivatedEventArgs  {

/**
 * Gets the app activation operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the SpeechRecognitionResult object representing the voice command that activated the app.
 */
result: Windows$Media$SpeechRecognition$SpeechRecognitionResult;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information to an app that was launched as the result of a wallet action.
 */
declare class Windows$UI$WebUI$WebUIWalletActionActivatedEventArgs  {

/**
 * Gets the ID of the action, such as the id of the verb, transaction and so on.
 */
actionId: string;

/**
 * Gets the action that was performed on the WalletItem.
 */
actionKind: $Values<typeof Windows$ApplicationModel$Wallet$WalletActionKind>;

/**
 * Gets the app activation operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the ID of the WalletItem on which the user performed the action.
 */
itemId: string;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Represents the arguments involved in activated a web account provider.
 */
declare class Windows$UI$WebUI$WebUIWebAccountProviderActivatedEventArgs  {

/**
 * Gets the activated operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets the kind of activation.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the web account provider operation.
 */
operation: Windows$Security$Authentication$Web$Provider$IWebAccountProviderOperation;

/**
 * Gets the previous execution state of the app.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen
}


/**
 * Provides information to an app that was launched after being suspended for a web authentication broker operation.
 */
declare class Windows$UI$WebUI$WebUIWebAuthenticationBrokerContinuationEventArgs  {

/**
 * Gets the app activation operation.
 */
activatedOperation: Windows$UI$WebUI$ActivatedOperation;

/**
 * Gets a set of values populated by the app before a web authentication broker operation that deactivates the app in order to provide context when the app is activated.
 */
continuationData: Windows$Foundation$Collections$ValueSet;

/**
 * Gets the activation type.
 */
kind: $Values<typeof Windows$ApplicationModel$Activation$ActivationKind>;

/**
 * Gets the execution state of the app before it was activated.
 */
previousExecutionState: $Values<typeof Windows$ApplicationModel$Activation$ApplicationExecutionState>;

/**
 * Gets the splash screen object that provides information about the transition from the splash screen to the activated app.
 */
splashScreen: Windows$ApplicationModel$Activation$SplashScreen;

/**
 * Gets the WebAuthenticationResult object returned from the web authentication broker operation.
 */
webAuthenticationResult: Windows$Security$Authentication$Web$WebAuthenticationResult
}


/**
 * Represents a method that handles the app activation event.
 */
declare type Windows$UI$WebUI$ActivatedEventHandler = (
ev: Windows$ApplicationModel$Activation$IActivatedEventArgs & Windows$WinRTEvent<any>) => void;


/**
 * Represents a method that handles the app navigation event.
 */
declare type Windows$UI$WebUI$NavigatedEventHandler = (
ev: Windows$UI$WebUI$IWebUINavigatedEventArgs & Windows$WinRTEvent<any>) => void;


/**
 * Represents a method that handles the app resumption event.
 */
declare type Windows$UI$WebUI$ResumingEventHandler = (ev: Windows$WinRTEvent<any>) => void;


/**
 * Represents a method that handles the app suspension event.
 */
declare type Windows$UI$WebUI$SuspendingEventHandler = (
ev: Windows$ApplicationModel$ISuspendingEventArgs & Windows$WinRTEvent<any>) => void;


/**
 * Provides access to an instance of a background task.
 */
declare interface Windows$UI$WebUI$IWebUIBackgroundTaskInstance {

/**
 * Gets or sets the success value for the background task. The success value is what is returned to the foreground instance of your app in the completed event.
 */
succeeded: boolean
} 


/**
 * Provides data for an app navigation event.
 */
declare interface Windows$UI$WebUI$IWebUINavigatedEventArgs {

/**
 * Gets the app navigation operation.
 */
navigatedOperation: Windows$UI$WebUI$WebUINavigatedOperation
} 


      declare var npm$namespace$Windows$UI$Xaml: {
        
        
        
        
        Automation: typeof npm$namespace$Windows$UI$Xaml$Automation,
Controls: typeof npm$namespace$Windows$UI$Xaml$Controls,
Media: typeof npm$namespace$Windows$UI$Xaml$Media,
      }





































/**
 * Describes a color in terms of alpha, red, green, and blue channels.
 */
declare interface Windows$UI$Color {

/**
 * Gets or sets the sRGB alpha channel value of the color.
 */
a: number,

/**
 * Gets or sets the sRGB blue channel value of the color.
 */
b: number,

/**
 * Gets or sets the sRGB green channel value of the color.
 */
g: number,

/**
 * Gets or sets the sRGB red channel value of the color.
 */
r: number
} 


      declare var npm$namespace$Windows$Web: {
        
        
        WebErrorStatus: typeof Windows$Web$WebErrorStatus,
        WebError: typeof Windows$Web$WebError,
        AtomPub: typeof npm$namespace$Windows$Web$AtomPub,
Http: typeof npm$namespace$Windows$Web$Http,
Syndication: typeof npm$namespace$Windows$Web$Syndication,
      }

      declare var npm$namespace$Windows$Web$AtomPub: {
        
        
        
        AtomPubClient: typeof Windows$Web$AtomPub$AtomPubClient,
ResourceCollection: typeof Windows$Web$AtomPub$ResourceCollection,
ServiceDocument: typeof Windows$Web$AtomPub$ServiceDocument,
Workspace: typeof Windows$Web$AtomPub$Workspace,
        
      }

/**
 * Encapsulates the methods needed to implement the AtomPub protocol which enables HTTP CRUD access to Web resources using the Atom 1.0 wire format.
 */
declare class Windows$Web$AtomPub$AtomPubClient  {

/**
 * Creates a new AtomPubClient object with the credential to use when making requests to the server. Initially, a 'username/password' tuple. However, for domain credentials, the username must be in 'domain\user form'.
 * @param serverCredential The specified security credentials.
 */
constructor(serverCredential: Windows$Security$Credentials$PasswordCredential): this;

/**
 * Creates a new AtomPubClient object.
 */
constructor(): this;

/**
 * Gets or sets a Boolean value that specifies whether to bypass the cache when retrieving the feed.
 */
bypassCacheOnRetrieve: boolean;

/**
 * Cancels any in-progress asynchronous operations, causing them to fail (asynchronously) with an error code indicating cancellation.
 */
cancelAsyncOperations(): void;

/**
 * Creates a new media resource in the specified collection.
 * @param uri The URI of the specified collection in which the new resource should be created.
 * @param mediaType The type for the media resource.
 * @param description The description of the new resource that is turned into the Slug: header of the POST request.
 * @param mediaStream Specifies the IInputStream to use as the media resource.
 * @return The object that is used to create the resource asynchronously and to report the progress and completion status of the operation.
 */
createMediaResourceAsync(
uri: Windows$Foundation$Uri,
mediaType: string,
description: string,
mediaStream: Windows$Storage$Streams$IInputStream): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Web$Syndication$SyndicationItem, Windows$Web$Syndication$TransferProgress>;

/**
 * Creates a new Entry resource in the specified collection. The Uri of the collection in which to create the new resource can be discovered from the ResourceCollection object retrieved from the RetrieveResourceAsync method.
 * @param uri The Uri of the specified collection in which the new resource should be created.
 * @param description The description of the new resource that is turned into the Slug: header of the POST request.
 * @param item The new resource to be created.
 * @return The object that is used to create the resource asynchronously and to report the progress and completion status of the operation.
 */
createResourceAsync(
uri: Windows$Foundation$Uri,
description: string,
item: Windows$Web$Syndication$SyndicationItem): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Web$Syndication$SyndicationItem, Windows$Web$Syndication$TransferProgress>;

/**
 * Deletes an existing Entry or Media Link resource.
 * @param uri The Uri of the resource to be deleted.
 * @return The object that is used to delete the resource asynchronously and to report the progress and completion status of the operation.
 */
deleteResourceAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncActionWithProgress<Windows$Web$Syndication$TransferProgress>;

/**
 * Deletes an existing Entry or Media Link resource. This differs from the DeleteResourceAsync method in that the SyndicationItem object that represents the resource to be deleted is specified instead of the Uri. The DeleteResourceItemAsync method uses the EditUri property of the specified SyndicationItem as the Uri of the resource to be deleted.
 * @param item The resource to be deleted.
 * @return The object that is used to delete the resource asynchronously and to report the progress and completion status of the operation.
 */
deleteResourceItemAsync(
item: Windows$Web$Syndication$SyndicationItem): Windows$Foundation$IPromiseWithIAsyncActionWithProgress<Windows$Web$Syndication$TransferProgress>;

/**
 * Gets or sets the maximum number of bytes to buffer when receiving a response from a server.
 */
maxResponseBufferSize: number;

/**
 * Gets or sets the credentials to use when making requests via a proxy.
 */
proxyCredential: Windows$Security$Credentials$PasswordCredential;

/**
 * Starts an asynchronous operation to download the syndication feed from the given URI. This method instantiates a SyndicationFeed object from the feed string, which can be in one of the formats specified in SyndicationFormat .
 * @param uri The URI from which the feed is downloaded.
 * @return Contains the results of the operation.
 */
retrieveFeedAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Web$Syndication$SyndicationFeed, Windows$Web$Syndication$RetrievalProgress>;

/**
 * Retrieves a media link resource from the specified Uniform Resource Identifier (URI).
 * @param uri The URI for the media resource.
 * @return The object used to retrieve the media resource and report the progress and completion status of the operation.
 */
retrieveMediaResourceAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IInputStream, Windows$Web$Syndication$RetrievalProgress>;

/**
 * Retrieves an Entry resource or Media Link resource from the specified Uniform Resource Identifier (URI).
 * @param uri The specified URI.
 * @return The object that is used to retrieve the resource asynchronously and to report the progress and completion status of the operation.
 */
retrieveResourceAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Web$Syndication$SyndicationItem, Windows$Web$Syndication$RetrievalProgress>;

/**
 * Retrieves a service document from the specified Uri.
 * @param uri The specified Uri.
 * @return The object that is used to retrieve the service document asynchronously and to report the progress and completion status of the operation.
 */
retrieveServiceDocumentAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Web$AtomPub$ServiceDocument, Windows$Web$Syndication$RetrievalProgress>;

/**
 * Gets or sets the credentials to use when making requests to the server.
 */
serverCredential: Windows$Security$Credentials$PasswordCredential;

/**
 * Sets an HTTP header for the request. This method can be called multiple times to set multiple headers. When the same header is set multiple times, the values will be concatenated and separated by ",".
 * @param name The name of the header.
 * @param value The value of the header.
 */
setRequestHeader(name: string, value: string): void;

/**
 * Gets or sets the maximum amount of time, in milliseconds, to wait for any of the asynchronous operations to complete. If the operation is not complete within this amount of time, it will fail with a status code indicating that it timed out.
 */
timeout: number;

/**
 * Updates a media link resource from the specified Uniform Resource Identifier (URI).
 * @param uri The URI of the resource to be updated.
 * @param mediaType The media type of the resource.
 * @param mediaStream The IInputStream of the media that is updating the media resource.
 * @return Completion status or error codes.
 */
updateMediaResourceAsync(
uri: Windows$Foundation$Uri,
mediaType: string,
mediaStream: Windows$Storage$Streams$IInputStream): Windows$Foundation$IPromiseWithIAsyncActionWithProgress<Windows$Web$Syndication$TransferProgress>;

/**
 * Updates an existing Entry or Media Link resource. If an ETag: header has previously been seen while retrieving this resource (in a response to RetrieveResourceAsync , CreateResourceAsync or a previous call to UpdateResourceAsync), this method automatically sends an If-Match: header with the remembered value.
 * @param uri The URI of the resource to be updated.
 * @param item The resource to be updated.
 * @return The object that is used to update the resource asynchronously and to report the progress and completion status of the operation.
 */
updateResourceAsync(
uri: Windows$Foundation$Uri,
item: Windows$Web$Syndication$SyndicationItem): Windows$Foundation$IPromiseWithIAsyncActionWithProgress<Windows$Web$Syndication$TransferProgress>;

/**
 * Updates an existing Entry or Media Link resource. This differs from the UpdateResourceAsync method in that the EditUri property of the specified SyndicationItem object is used as the Uri of the resource to be updated.
 * @param item The resource to be updated.
 * @return The object that is used to update the resource asynchronously and to report the progress and completion status of the operation.
 */
updateResourceItemAsync(
item: Windows$Web$Syndication$SyndicationItem): Windows$Foundation$IPromiseWithIAsyncActionWithProgress<Windows$Web$Syndication$TransferProgress>
}


/**
 * Encapsulates one or more collections within a workspace.
 */
declare class Windows$Web$AtomPub$ResourceCollection  {

/**
 * Gets or sets the collection of app:accept elements.
 */
accepts: Windows$Foundation$Collections$IVectorView<string>;

/**
 * Gets the list of attributes of the element.
 */
attributeExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationAttribute>;

/**
 * Gets or sets the Uniform Resource Identifier (URI) for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element.
 */
baseUri: Windows$Foundation$Uri;

/**
 * Gets the collection of atom:category elements within the app:categories element.
 */
categories: Windows$Foundation$Collections$IVectorView<Windows$Web$Syndication$SyndicationCategory>;

/**
 * Gets the list of child elements within the element.
 */
elementExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$ISyndicationNode>;

/**
 * Generates the DOM object that represents this element, and all the attributes and child elements including foreign markups.
 * @param format The format of the element. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @return The XML document.
 */
getXmlDocument(
format: $Values<typeof Windows$Web$Syndication$SyndicationFormat>): Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0.
 */
language: string;

/**
 * Gets or sets the local name of the element. It must be valid according to XML 1.0.
 */
nodeName: string;

/**
 * Gets or sets the namespace of the element.
 */
nodeNamespace: string;

/**
 * Gets or sets the text content of the element. If the element contains only child elements, this attribute is NULL.
 */
nodeValue: string;

/**
 * Gets the atom:title element under the app:collection element.
 */
title: Windows$Web$Syndication$ISyndicationText;

/**
 * Gets the Uniform Resource Identifier (URI) representing the href attribute of the app:collection element. This is the absolute URI resolved against the xml:base attribute when it is present. If the href attribute is a relative URI string and there is no xml:base attribute, this property will be Null.
 */
uri: Windows$Foundation$Uri
}


/**
 * Encapsulates a service document.
 */
declare class Windows$Web$AtomPub$ServiceDocument  {

/**
 * Gets the list of attributes of the element.
 */
attributeExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationAttribute>;

/**
 * Gets or sets the Uniform Resource Identifier (URI) for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element.
 */
baseUri: Windows$Foundation$Uri;

/**
 * Gets the list of child elements within the element.
 */
elementExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$ISyndicationNode>;

/**
 * Generates the DOM object that represents this element, and all the attributes and child elements including foreign markups.
 * @param format The format of the element. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @return The XML document.
 */
getXmlDocument(
format: $Values<typeof Windows$Web$Syndication$SyndicationFormat>): Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0.
 */
language: string;

/**
 * Gets or sets the local name of the element. It must be valid according to XML 1.0.
 */
nodeName: string;

/**
 * Gets or sets the namespace of the element.
 */
nodeNamespace: string;

/**
 * Gets or sets the text content of the element. If the element contains only child elements, this attribute is NULL.
 */
nodeValue: string;

/**
 * Gets the collection of app:workspace elements in the service document.
 */
workspaces: Windows$Foundation$Collections$IVectorView<Windows$Web$AtomPub$Workspace>
}


/**
 * Encapsulates a workspace in a service document.
 */
declare class Windows$Web$AtomPub$Workspace  {

/**
 * Gets the list of attributes of the element.
 */
attributeExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationAttribute>;

/**
 * Gets or sets the Uniform Resource Identifier (URI) for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element.
 */
baseUri: Windows$Foundation$Uri;

/**
 * Gets the read-only collection of app:collection elements within the app:workspace element.
 */
collections: Windows$Foundation$Collections$IVectorView<Windows$Web$AtomPub$ResourceCollection>;

/**
 * Gets the list of child elements within the element.
 */
elementExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$ISyndicationNode>;

/**
 * Generates the DOM object that represents this element, and all the attributes and child elements including foreign markups.
 * @param format The format for the element. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @return The XML document.
 */
getXmlDocument(
format: $Values<typeof Windows$Web$Syndication$SyndicationFormat>): Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0.
 */
language: string;

/**
 * Gets or sets the local name of the element. It must be valid according to XML 1.0.
 */
nodeName: string;

/**
 * Gets or sets the namespace of the element.
 */
nodeNamespace: string;

/**
 * Gets or sets the text content of the element. If the element contains only child elements, this attribute is NULL.
 */
nodeValue: string;

/**
 * Gets the atom:title element under the app:workspace element.
 */
title: Windows$Web$Syndication$ISyndicationText
}


      declare var npm$namespace$Windows$Web$Http: {
        
        
        HttpCompletionOption: typeof Windows$Web$Http$HttpCompletionOption,
HttpProgressStage: typeof Windows$Web$Http$HttpProgressStage,
HttpResponseMessageSource: typeof Windows$Web$Http$HttpResponseMessageSource,
HttpStatusCode: typeof Windows$Web$Http$HttpStatusCode,
HttpVersion: typeof Windows$Web$Http$HttpVersion,
        HttpBufferContent: typeof Windows$Web$Http$HttpBufferContent,
HttpClient: typeof Windows$Web$Http$HttpClient,
HttpCookie: typeof Windows$Web$Http$HttpCookie,
HttpCookieCollection: typeof Windows$Web$Http$HttpCookieCollection,
HttpCookieManager: typeof Windows$Web$Http$HttpCookieManager,
HttpFormUrlEncodedContent: typeof Windows$Web$Http$HttpFormUrlEncodedContent,
HttpMethod: typeof Windows$Web$Http$HttpMethod,
HttpMultipartContent: typeof Windows$Web$Http$HttpMultipartContent,
HttpMultipartFormDataContent: typeof Windows$Web$Http$HttpMultipartFormDataContent,
HttpRequestMessage: typeof Windows$Web$Http$HttpRequestMessage,
HttpResponseMessage: typeof Windows$Web$Http$HttpResponseMessage,
HttpStreamContent: typeof Windows$Web$Http$HttpStreamContent,
HttpStringContent: typeof Windows$Web$Http$HttpStringContent,
HttpTransportInformation: typeof Windows$Web$Http$HttpTransportInformation,
        Diagnostics: typeof npm$namespace$Windows$Web$Http$Diagnostics,
Filters: typeof npm$namespace$Windows$Web$Http$Filters,
Headers: typeof npm$namespace$Windows$Web$Http$Headers,
      }

      declare var npm$namespace$Windows$Web$Http$Diagnostics: {
        
        
        HttpDiagnosticRequestInitiator: typeof Windows$Web$Http$Diagnostics$HttpDiagnosticRequestInitiator,
        HttpDiagnosticProvider: typeof Windows$Web$Http$Diagnostics$HttpDiagnosticProvider,
HttpDiagnosticProviderRequestResponseCompletedEventArgs: typeof Windows$Web$Http$Diagnostics$HttpDiagnosticProviderRequestResponseCompletedEventArgs,
HttpDiagnosticProviderRequestResponseTimestamps: typeof Windows$Web$Http$Diagnostics$HttpDiagnosticProviderRequestResponseTimestamps,
HttpDiagnosticProviderRequestSentEventArgs: typeof Windows$Web$Http$Diagnostics$HttpDiagnosticProviderRequestSentEventArgs,
HttpDiagnosticProviderResponseReceivedEventArgs: typeof Windows$Web$Http$Diagnostics$HttpDiagnosticProviderResponseReceivedEventArgs,
HttpDiagnosticSourceLocation: typeof Windows$Web$Http$Diagnostics$HttpDiagnosticSourceLocation,
        
      }

/**
 * Provides a simple diagnostic facility for tracing and profiling web traffic in applications built on Microsofts HTTP stacks.
 */
declare class Windows$Web$Http$Diagnostics$HttpDiagnosticProvider  {

/**
 * Creates a new HttpDiagnosticProvider based on the specified ProcessDiagnosticInfo object.
 * @param processDiagnosticInfo The ProcessDiagnosticInfo that identifies the process to watch.
 * @return The newly created HttpDiagnosticProvider .
 */
static createFromProcessDiagnosticInfo(
processDiagnosticInfo: Windows$System$Diagnostics$ProcessDiagnosticInfo): Windows$Web$Http$Diagnostics$HttpDiagnosticProvider;

/**
 * Subscribe to the RequestResponseCompleted event to receive a notification that a request has been submitted.
 */
onrequestresponsecompleted: Windows$Foundation$TypedEventHandler<Windows$Web$Http$Diagnostics$HttpDiagnosticProvider, Windows$Web$Http$Diagnostics$HttpDiagnosticProviderRequestResponseCompletedEventArgs>;
addEventListener(
type: "requestresponsecompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Web$Http$Diagnostics$HttpDiagnosticProvider, Windows$Web$Http$Diagnostics$HttpDiagnosticProviderRequestResponseCompletedEventArgs>): void;
removeEventListener(
type: "requestresponsecompleted",
listener: Windows$Foundation$TypedEventHandler<Windows$Web$Http$Diagnostics$HttpDiagnosticProvider, Windows$Web$Http$Diagnostics$HttpDiagnosticProviderRequestResponseCompletedEventArgs>): void;

/**
 * Subscribe to the RequestSent event to receive a notification that a request has been sent.
 */
onrequestsent: Windows$Foundation$TypedEventHandler<Windows$Web$Http$Diagnostics$HttpDiagnosticProvider, Windows$Web$Http$Diagnostics$HttpDiagnosticProviderRequestSentEventArgs>;
addEventListener(
type: "requestsent",
listener: Windows$Foundation$TypedEventHandler<Windows$Web$Http$Diagnostics$HttpDiagnosticProvider, Windows$Web$Http$Diagnostics$HttpDiagnosticProviderRequestSentEventArgs>): void;
removeEventListener(
type: "requestsent",
listener: Windows$Foundation$TypedEventHandler<Windows$Web$Http$Diagnostics$HttpDiagnosticProvider, Windows$Web$Http$Diagnostics$HttpDiagnosticProviderRequestSentEventArgs>): void;

/**
 * Subscribe to the ResponseReceived event to receive a notification that a response has been received.
 */
onresponsereceived: Windows$Foundation$TypedEventHandler<Windows$Web$Http$Diagnostics$HttpDiagnosticProvider, Windows$Web$Http$Diagnostics$HttpDiagnosticProviderResponseReceivedEventArgs>;
addEventListener(
type: "responsereceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Web$Http$Diagnostics$HttpDiagnosticProvider, Windows$Web$Http$Diagnostics$HttpDiagnosticProviderResponseReceivedEventArgs>): void;
removeEventListener(
type: "responsereceived",
listener: Windows$Foundation$TypedEventHandler<Windows$Web$Http$Diagnostics$HttpDiagnosticProvider, Windows$Web$Http$Diagnostics$HttpDiagnosticProviderResponseReceivedEventArgs>): void;

/**
 * Starts the HttpDiagnosticProvider monitoring the attached process target.
 */
start(): void;

/**
 * Stops the HttpDiagnosticProvider from monitoring the attached process target.
 */
stop(): void;
addEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void;
removeEventListener(type: string, listener: Windows$Foundation$EventHandler<any>): void
}


/**
 * Provides data for the RequestResponseCompleted event.
 */
declare class Windows$Web$Http$Diagnostics$HttpDiagnosticProviderRequestResponseCompletedEventArgs  {

/**
 * Gets a locally unique ID for this activity, for correlating with other events.
 */
activityId: string;

/**
 * Gets the type of operation initiating this request.
 */
initiator: $Values<typeof Windows$Web$Http$Diagnostics$HttpDiagnosticRequestInitiator>;
processId: any;

/**
 * Gets the URI of the requested response.
 */
requestedUri: Windows$Foundation$Uri;
sourceLocations: any;
threadId: any;

/**
 * Gets the timestamp for connection events.
 */
timestamps: Windows$Web$Http$Diagnostics$HttpDiagnosticProviderRequestResponseTimestamps
}


/**
 * Provides all the timestamps for connection events.
 */
declare class Windows$Web$Http$Diagnostics$HttpDiagnosticProviderRequestResponseTimestamps  {

/**
 * Gets the last time local cache was checked.
 */
cacheCheckedTimestamp: Date;

/**
 * Gets the timestamp for the end of the TCP connection phase.
 */
connectionCompletedTimestamp: Date;

/**
 * Gets the timestamp for the start of the TCP connection phase.
 */
connectionInitiatedTimestamp: Date;

/**
 * Gets the time of the DNS name resolution.
 */
nameResolvedTimestamp: Date;

/**
 * Gets the timestamp for the last byte sent.
 */
requestCompletedTimestamp: Date;

/**
 * Gets the timestamp for the first byte sent.
 */
requestSentTimestamp: Date;

/**
 * Gets the timestamp for the last byte received.
 */
responseCompletedTimestamp: Date;

/**
 * Gets the timestamp for the fir byte received.
 */
responseReceivedTimestamp: Date;

/**
 * Gets the time of the SSL handshake negotiation.
 */
sslNegotiatedTimestamp: Date
}


/**
 * Provides data for the RequestSent event.
 */
declare class Windows$Web$Http$Diagnostics$HttpDiagnosticProviderRequestSentEventArgs  {

/**
 * Gets a locally unique ID for this activity, for correlating with other events.
 */
activityId: string;

/**
 * Gets the type of operation initiating this request.
 */
initiator: $Values<typeof Windows$Web$Http$Diagnostics$HttpDiagnosticRequestInitiator>;

/**
 * Gets the HttpRequestMessage including headers.
 */
message: Windows$Web$Http$HttpRequestMessage;

/**
 * Gets the process ID.
 */
processId: number;

/**
 * Gets the source location call stack.
 */
sourceLocations: Windows$Foundation$Collections$IVectorView<Windows$Web$Http$Diagnostics$HttpDiagnosticSourceLocation>;

/**
 * Gets the thread ID.
 */
threadId: number;

/**
 * Gets the timestamp of when the HttpRequestMessage was sent.
 */
timestamp: Date
}


/**
 * Provides data for the ResponseReceived event.
 */
declare class Windows$Web$Http$Diagnostics$HttpDiagnosticProviderResponseReceivedEventArgs  {

/**
 * Gets a locally unique ID for this activity, for correlating with other events.
 */
activityId: string;

/**
 * Gets the HttpResponseMessage including headers, the status code, and data.
 */
message: Windows$Web$Http$HttpResponseMessage;

/**
 * Gets the timestamp of when the HttpResponseMessage was received.
 */
timestamp: Date
}


/**
 * Provides the source of the request.
 */

declare  var Windows$Web$Http$Diagnostics$HttpDiagnosticRequestInitiator: {|
  +parsedElement: 0,// 0
+script: 1,// 1
+image: 2,// 2
+link: 3,// 3
+style: 4,// 4
+xmlHttpRequest: 5,// 5
+media: 6,// 6
+htmlDownload: 7,// 7
+prefetch: 8,// 8
+other: 9,// 9

|};



/**
 * Contains the source location of the HTTP activity.
 */
declare class Windows$Web$Http$Diagnostics$HttpDiagnosticSourceLocation  {

/**
 * Gets the column number.
 */
columnNumber: number;

/**
 * Gets the line number.
 */
lineNumber: number;

/**
 * Gets the source URI.
 */
sourceUri: Windows$Foundation$Uri
}


      declare var npm$namespace$Windows$Web$Http$Filters: {
        
        
        HttpCacheReadBehavior: typeof Windows$Web$Http$Filters$HttpCacheReadBehavior,
HttpCacheWriteBehavior: typeof Windows$Web$Http$Filters$HttpCacheWriteBehavior,
HttpCookieUsageBehavior: typeof Windows$Web$Http$Filters$HttpCookieUsageBehavior,
        HttpBaseProtocolFilter: typeof Windows$Web$Http$Filters$HttpBaseProtocolFilter,
HttpCacheControl: typeof Windows$Web$Http$Filters$HttpCacheControl,
        
      }

/**
 * The base protocol filter for an HttpClient instance.
 */
declare class Windows$Web$Http$Filters$HttpBaseProtocolFilter  {

/**
 * Initializes a new instance of the HttpBaseProtocolFilter class.
 */
constructor(): this;

/**
 * Get or set a value that indicates whether the HttpBaseProtocolFilter should follow redirection responses.
 */
allowAutoRedirect: boolean;

/**
 * Get or set a value that indicates whether the HttpBaseProtocolFilter can prompt for user credentials when requested by the server.
 */
allowUI: boolean;

/**
 * Gets or sets a value that indicates whether the HttpBaseProtocolFilter can automatically decompress the HTTP content response.
 */
automaticDecompression: boolean;

/**
 * Get or set the read and write cache control behavior to be used on the HttpBaseProtocolFilter object.
 */
cacheControl: Windows$Web$Http$Filters$HttpCacheControl;

/**
 * Get or set the client SSL certificate that will be sent to the server if the server requests a client certificate.
 */
clientCertificate: Windows$Security$Cryptography$Certificates$Certificate;

/**
 * Closes the HttpBaseProtocolFilter instance and releases allocated resources.
 */
close(): void;

/**
 * Get the HttpCookieManager with the cookies associated with an app.
 */
cookieManager: Windows$Web$Http$HttpCookieManager;

/**
 * Gets or sets the cookie usage behavior. By default, cookies are handled automatically.
 */
cookieUsageBehavior: $Values<typeof Windows$Web$Http$Filters$HttpCookieUsageBehavior>;

/**
 * Get a vector of SSL server certificate errors that the app might subsequently choose to ignore.
 */
ignorableServerCertificateErrors: Windows$Foundation$Collections$IVector<$Values<typeof Windows$Security$Cryptography$Certificates$ChainValidationResult>>;

/**
 * Get or set the maximum number of TCP connections allowed per HTTP server by the HttpBaseProtocolFilter object.
 */
maxConnectionsPerServer: number;

/**
 * Gets or sets the version of the HTTP protocol used.
 */
maxVersion: $Values<typeof Windows$Web$Http$HttpVersion>;

/**
 * Get or set the credentials to be used to negotiate with an HTTP proxy.
 */
proxyCredential: Windows$Security$Credentials$PasswordCredential;

/**
 * Send an HTTP request using the HttpBaseProtocolFilter as an asynchronous operation.
 * @param request The HTTP request message to send.
 * @return The object representing the asynchronous operation.
 */
sendRequestAsync(
request: Windows$Web$Http$HttpRequestMessage): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Web$Http$HttpResponseMessage, Windows$Web$Http$HttpProgress>;

/**
 * Get or set the credentials to be used to authenticate with an HTTP server.
 */
serverCredential: Windows$Security$Credentials$PasswordCredential;

/**
 * Get or set a value that indicates whether the HttpBaseProtocolFilter can use a proxy for sending HTTP requests.
 */
useProxy: boolean
}


/**
 * Provides control of the local HTTP cache for responses to HTTP requests by methods in the Windows.Web.Http and Windows.Web.Http.Filters namespaces.
 */
declare class Windows$Web$Http$Filters$HttpCacheControl  {

/**
 * Get or set the read behavior to use for cache control on the HttpCacheControl object.
 */
readBehavior: $Values<typeof Windows$Web$Http$Filters$HttpCacheReadBehavior>;

/**
 * Get or set the write behavior to use for cache control on the HttpCacheControl object.
 */
writeBehavior: $Values<typeof Windows$Web$Http$Filters$HttpCacheWriteBehavior>
}


/**
 * Indicates if read requests by class methods in the Windows.Web.Http and Windows.Web.Http.Filters namespaces use the local HTTP cache for the response.
 */

declare  var Windows$Web$Http$Filters$HttpCacheReadBehavior: {|
  +default: 0,// 0
+mostRecent: 1,// 1
+onlyFromCache: 2,// 2

|};



/**
 * Indicates if content returned by requests used by class methods in the Windows.Web.Http and Windows.Web.Http.Filters namespaces is written to the local HTTP cache.
 */

declare  var Windows$Web$Http$Filters$HttpCacheWriteBehavior: {|
  +default: 0,// 0
+noCache: 1,// 1

|};



/**
 * Defines the cookie usage behavior that is used in the CookieUsageBehavior property.
 */

declare  var Windows$Web$Http$Filters$HttpCookieUsageBehavior: {|
  +default: 0,// 0
+noCookies: 1,// 1

|};



/**
 * An interface used to implement custom filters for an HttpClient instance.
 */
declare type Windows$Web$Http$Filters$IHttpFilter = {

/**
 * Send an HTTP request on the IHttpFilter instance as an asynchronous operation.
 * @param request The HTTP request message to send.
 * @return The object representing the asynchronous operation.
 */
sendRequestAsync(
request: Windows$Web$Http$HttpRequestMessage): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Web$Http$HttpResponseMessage, Windows$Web$Http$HttpProgress>
} & Windows$Foundation$IClosable



      declare var npm$namespace$Windows$Web$Http$Headers: {
        
        
        
        HttpCacheDirectiveHeaderValueCollection: typeof Windows$Web$Http$Headers$HttpCacheDirectiveHeaderValueCollection,
HttpChallengeHeaderValue: typeof Windows$Web$Http$Headers$HttpChallengeHeaderValue,
HttpChallengeHeaderValueCollection: typeof Windows$Web$Http$Headers$HttpChallengeHeaderValueCollection,
HttpConnectionOptionHeaderValue: typeof Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue,
HttpConnectionOptionHeaderValueCollection: typeof Windows$Web$Http$Headers$HttpConnectionOptionHeaderValueCollection,
HttpContentCodingHeaderValue: typeof Windows$Web$Http$Headers$HttpContentCodingHeaderValue,
HttpContentCodingHeaderValueCollection: typeof Windows$Web$Http$Headers$HttpContentCodingHeaderValueCollection,
HttpContentCodingWithQualityHeaderValue: typeof Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue,
HttpContentCodingWithQualityHeaderValueCollection: typeof Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValueCollection,
HttpContentDispositionHeaderValue: typeof Windows$Web$Http$Headers$HttpContentDispositionHeaderValue,
HttpContentHeaderCollection: typeof Windows$Web$Http$Headers$HttpContentHeaderCollection,
HttpContentRangeHeaderValue: typeof Windows$Web$Http$Headers$HttpContentRangeHeaderValue,
HttpCookiePairHeaderValue: typeof Windows$Web$Http$Headers$HttpCookiePairHeaderValue,
HttpCookiePairHeaderValueCollection: typeof Windows$Web$Http$Headers$HttpCookiePairHeaderValueCollection,
HttpCredentialsHeaderValue: typeof Windows$Web$Http$Headers$HttpCredentialsHeaderValue,
HttpDateOrDeltaHeaderValue: typeof Windows$Web$Http$Headers$HttpDateOrDeltaHeaderValue,
HttpExpectationHeaderValue: typeof Windows$Web$Http$Headers$HttpExpectationHeaderValue,
HttpExpectationHeaderValueCollection: typeof Windows$Web$Http$Headers$HttpExpectationHeaderValueCollection,
HttpLanguageHeaderValueCollection: typeof Windows$Web$Http$Headers$HttpLanguageHeaderValueCollection,
HttpLanguageRangeWithQualityHeaderValue: typeof Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue,
HttpLanguageRangeWithQualityHeaderValueCollection: typeof Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValueCollection,
HttpMediaTypeHeaderValue: typeof Windows$Web$Http$Headers$HttpMediaTypeHeaderValue,
HttpMediaTypeWithQualityHeaderValue: typeof Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue,
HttpMediaTypeWithQualityHeaderValueCollection: typeof Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValueCollection,
HttpMethodHeaderValueCollection: typeof Windows$Web$Http$Headers$HttpMethodHeaderValueCollection,
HttpNameValueHeaderValue: typeof Windows$Web$Http$Headers$HttpNameValueHeaderValue,
HttpProductHeaderValue: typeof Windows$Web$Http$Headers$HttpProductHeaderValue,
HttpProductInfoHeaderValue: typeof Windows$Web$Http$Headers$HttpProductInfoHeaderValue,
HttpProductInfoHeaderValueCollection: typeof Windows$Web$Http$Headers$HttpProductInfoHeaderValueCollection,
HttpRequestHeaderCollection: typeof Windows$Web$Http$Headers$HttpRequestHeaderCollection,
HttpResponseHeaderCollection: typeof Windows$Web$Http$Headers$HttpResponseHeaderCollection,
HttpTransferCodingHeaderValue: typeof Windows$Web$Http$Headers$HttpTransferCodingHeaderValue,
HttpTransferCodingHeaderValueCollection: typeof Windows$Web$Http$Headers$HttpTransferCodingHeaderValueCollection,
        
      }

/**
 * Represents the value of the Cache-Control HTTP header on HTTP content associated with an HTTP request or response.
 */
declare class Windows$Web$Http$Headers$HttpCacheDirectiveHeaderValueCollection mixins Array<Windows$Web$Http$Headers$HttpNameValueHeaderValue> {

/**
 * Adds a new HttpNameValueHeaderValue item to the end of the collection.
 * @param value The HttpNameValueHeaderValue object to append.
 */
append(value: Windows$Web$Http$Headers$HttpNameValueHeaderValue): void;

/**
 * Removes all objects from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator to the first HttpNameValueHeaderValue item in the collection.
 * @return An object that can be used to enumerate the HttpNameValueHeaderValue items in the collection. The iterator points to the first HttpNameValueHeaderValue item in the HttpCacheDirectiveHeaderValueCollection .
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Web$Http$Headers$HttpNameValueHeaderValue>;

/**
 * Returns the HttpNameValueHeaderValue at the specified index in the collection.
 * @param index The zero-based index of a specified item in the HttpCacheDirectiveHeaderValueCollection .
 * @return The HttpNameValueHeaderValue at the specified index in the HttpCacheDirectiveHeaderValueCollection .
 */
getAt(index: number): Windows$Web$Http$Headers$HttpNameValueHeaderValue;

/**
 * Retrieves the HttpNameValueHeaderValue items that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the HttpNameValueHeaderValue items in the HttpCacheDirectiveHeaderValueCollection .
 */
getMany(
startIndex: number): {
items: Windows$Web$Http$Headers$HttpNameValueHeaderValue,
returnValue: number
};

/**
 * Returns an immutable view of the HttpCacheDirectiveHeaderValueCollection .
 * @return The view of the HttpCacheDirectiveHeaderValueCollection .
 */
getView(
): Windows$Foundation$Collections$IVectorView<Windows$Web$Http$Headers$HttpNameValueHeaderValue>;

/**
 * Retrieves the index of an HttpNameValueHeaderValue in the collection.
 * @param value The HttpNameValueHeaderValue to find in the HttpCacheDirectiveHeaderValueCollection .
 */
indexOf(
value: Windows$Web$Http$Headers$HttpNameValueHeaderValue): {
index: number,
returnValue: boolean
};

/**
 * Determines the index of a specific item in the collection.
 * @param item The object to locate in the collection.
 * @return The index of item if found in the collection; otherwise, 1.
 */
indexOf(item: Windows$Web$Http$Headers$HttpNameValueHeaderValue): number;

/**
 * Inserts an HttpNameValueHeaderValue into the collection at the specified index.
 * @param index The zero-based index at which value should be inserted.
 * @param value The object to insert into the collection.
 */
insertAt(index: number, value: Windows$Web$Http$Headers$HttpNameValueHeaderValue): void;

/**
 * Gets or sets the value of the max-age directive in the Cache-Control HTTP header.
 */
maxAge: number;

/**
 * Gets or sets the value of the max-stale directive in the Cache-Control HTTP header.
 */
maxStale: number;

/**
 * Gets or sets the value of the min-fresh directive in the Cache-Control HTTP header.
 */
minFresh: number;

/**
 * Parses and adds an entry to the HttpCacheDirectiveHeaderValueCollection .
 * @param input The entry to add.
 */
parseAdd(input: string): void;

/**
 * Removes the entry at the specified index from the HttpCacheDirectiveHeaderValueCollection .
 * @param index The index of the entry to remove.
 */
removeAt(index: number): void;

/**
 * Removes the element at the specified index of the collection.
 * @param index The zero-based index of the element to remove.
 */
removeAt(index: number): void;

/**
 * Removes the last HttpNameValueHeaderValue item from the collection.
 */
removeAtEnd(): void;

/**
 * Replaces all the HttpNameValueHeaderValue items in the collection with the specified HttpNameValueHeaderValue items.
 * @param items The collection of HttpNameValueHeaderValue items to add to the collection.
 */
replaceAll(items: Windows$Web$Http$Headers$HttpNameValueHeaderValue): void;

/**
 * Sets the HttpNameValueHeaderValue at the specified index in the collection.
 * @param index The zero-based index at which to set the HttpNameValueHeaderValue .
 * @param value The item to set.
 */
setAt(index: number, value: Windows$Web$Http$Headers$HttpNameValueHeaderValue): void;

/**
 * Gets or sets the value of the s-maxage directive in the Cache-Control HTTP header.
 */
sharedMaxAge: number;

/**
 * Gets the number of HttpNameValueHeaderValue objects in the collection.
 */
size: number;

/**
 * Tries to parse and add the specified item to the HttpCacheDirectiveHeaderValueCollection .
 * @param input The item to parse and add.
 * @return true if the item successfully parsed and was added; otherwise false.
 */
tryParseAdd(input: string): boolean;
indexOf(
value: Windows$Web$Http$Headers$HttpNameValueHeaderValue,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Web$Http$Headers$HttpNameValueHeaderValue,
fromIndex?: number): number
}


/**
 * Represents authentication information used in the Proxy-Authenticate and WWW-Authenticate HTTP header values.
 */
declare class Windows$Web$Http$Headers$HttpChallengeHeaderValue  {

/**
 * Converts a string to an HttpChallengeHeaderValue instance.
 * @param input A string that represents authentication header value information.
 * @return An HttpChallengeHeaderValue instance.
 */
static parse(input: string): Windows$Web$Http$Headers$HttpChallengeHeaderValue;

/**
 * Determines whether a string is valid HttpChallengeHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
challengeHeaderValue: Windows$Web$Http$Headers$HttpChallengeHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpChallengeHeaderValue class with the scheme to use for authorization and the SPNEGO token.
 * @param scheme The scheme to use for authorization.
 * @param token The SPNEGO token to use with the Negotiate protocol scheme.
 */
constructor(scheme: string, token: string): this;

/**
 * Initializes a new instance of the HttpChallengeHeaderValue class with the scheme to use for authorization.
 * @param scheme The scheme to use for authorization.
 */
constructor(scheme: string): this;

/**
 * Gets the credentials that contain the authentication information of the user agent for the resource being requested.
 */
parameters: Windows$Foundation$Collections$IVector<Windows$Web$Http$Headers$HttpNameValueHeaderValue>;

/**
 * Gets the scheme to use for authentication.
 */
scheme: string;

/**
 * The SPNEGO token to use with the Negotiate protocol scheme.
 */
token: string
}


/**
 * Represents the value of the Proxy-Authenticate or WWW-Authenticate HTTP header on an HTTP response.
 */
declare class Windows$Web$Http$Headers$HttpChallengeHeaderValueCollection mixins Array<Windows$Web$Http$Headers$HttpChallengeHeaderValue> {

/**
 * Adds a new HttpChallengeHeaderValue item to the end of the collection.
 * @param value The HttpChallengeHeaderValue object to append.
 */
append(value: Windows$Web$Http$Headers$HttpChallengeHeaderValue): void;

/**
 * Removes all HttpChallengeHeaderValue objects from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator to the first HttpChallengeHeaderValue item in the collection.
 * @return An object that can be used to enumerate the HttpChallengeHeaderValue items in the collection. The iterator points to the first HttpChallengeHeaderValue item in the HttpChallengeHeaderValueCollection .
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Web$Http$Headers$HttpChallengeHeaderValue>;

/**
 * Returns the HttpChallengeHeaderValue at the specified index in the collection.
 * @param index The zero-based index of a specified item in the HttpChallengeHeaderValueCollection .
 * @return The HttpChallengeHeaderValue at the specified index in the HttpChallengeHeaderValueCollection
 */
getAt(index: number): Windows$Web$Http$Headers$HttpChallengeHeaderValue;

/**
 * Retrieves the HttpChallengeHeaderValue items that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the HttpChallengeHeaderValue items in the HttpChallengeHeaderValueCollection .
 */
getMany(
startIndex: number): {
items: Windows$Web$Http$Headers$HttpChallengeHeaderValue,
returnValue: number
};

/**
 * Returns an immutable view of the HttpChallengeHeaderValueCollection .
 * @return The view of the HttpChallengeHeaderValueCollection .
 */
getView(
): Windows$Foundation$Collections$IVectorView<Windows$Web$Http$Headers$HttpChallengeHeaderValue>;

/**
 * Retrieves the index of an HttpChallengeHeaderValue in the collection.
 * @param value The HttpChallengeHeaderValue to find in the HttpChallengeHeaderValueCollection .
 */
indexOf(
value: Windows$Web$Http$Headers$HttpChallengeHeaderValue): {
index: number,
returnValue: boolean
};

/**
 * Determines the index of a specific item in the collection.
 * @param item The object to locate in the collection.
 * @return The index of item if found in the collection; otherwise, 1.
 */
indexOf(item: Windows$Web$Http$Headers$HttpChallengeHeaderValue): number;

/**
 * Inserts an HttpChallengeHeaderValue into the collection at the specified index.
 * @param index The zero-based index at which value should be inserted.
 * @param value The object to insert into the collection.
 */
insertAt(index: number, value: Windows$Web$Http$Headers$HttpChallengeHeaderValue): void;

/**
 * Parses and adds an entry to the HttpChallengeHeaderValueCollection .
 * @param input The entry to add.
 */
parseAdd(input: string): void;

/**
 * Removes the entry at the specified index from the HttpChallengeHeaderValueCollection .
 * @param index The index of the entry to remove.
 */
removeAt(index: number): void;

/**
 * Removes the element at the specified index of the collection.
 * @param index The zero-based index of the element to remove.
 */
removeAt(index: number): void;

/**
 * Removes the last HttpChallengeHeaderValue item from the collection.
 */
removeAtEnd(): void;

/**
 * Replaces all the HttpChallengeHeaderValue items in the collection with the specified HttpChallengeHeaderValue items.
 * @param items The collection of HttpChallengeHeaderValue items to add to the collection.
 */
replaceAll(items: Windows$Web$Http$Headers$HttpChallengeHeaderValue): void;

/**
 * Sets the HttpChallengeHeaderValue at the specified index in the collection.
 * @param index The zero-based index at which to set the HttpChallengeHeaderValue .
 * @param value The item to set.
 */
setAt(index: number, value: Windows$Web$Http$Headers$HttpChallengeHeaderValue): void;

/**
 * Gets the number of HttpChallengeHeaderValue objects in the collection.
 */
size: number;

/**
 * Tries to parse and add the specified item to the HttpChallengeHeaderValueCollection .
 * @param input The item to parse and add.
 * @return true if the item successfully parsed and was added; otherwise false.
 */
tryParseAdd(input: string): boolean;
indexOf(
value: Windows$Web$Http$Headers$HttpChallengeHeaderValue,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Web$Http$Headers$HttpChallengeHeaderValue,
fromIndex?: number): number
}


/**
 * Represents connection information used in the Connection HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue  {

/**
 * Converts a string to an HttpConnectionOptionHeaderValue instance.
 * @param input A string that represents the connection information in the Connection HTTP header.
 * @return An HttpConnectionOptionHeaderValue instance.
 */
static parse(input: string): Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue;

/**
 * Determines whether a string is valid HttpConnectionOptionHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
connectionOptionHeaderValue: Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpConnectionOptionHeaderValue class.
 * @param token The value of the connection-token to use.
 */
constructor(token: string): this;

/**
 * Gets the value of the connection-token in the Connection HTTP header.
 */
token: string
}


/**
 * Represents the value of the Connection HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpConnectionOptionHeaderValueCollection mixins Array<Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue> {

/**
 * Adds a new HttpConnectionOptionHeaderValue item to the end of the collection.
 * @param value The HttpConnectionOptionHeaderValue object to append.
 */
append(value: Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue): void;

/**
 * Removes all HttpConnectionOptionHeaderValue objects from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator to the first HttpConnectionOptionHeaderValue item in the collection.
 * @return An object that can be used to enumerate the HttpConnectionOptionHeaderValue items in the collection. The iterator points to the first HttpConnectionOptionHeaderValue item in the HttpConnectionOptionHeaderValueCollection .
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue>;

/**
 * Returns the HttpConnectionOptionHeaderValue at the specified index in the collection.
 * @param index The zero-based index of a specified item in the HttpConnectionOptionHeaderValueCollection .
 * @return The HttpConnectionOptionHeaderValue at the specified index in the HttpConnectionOptionHeaderValueCollection .
 */
getAt(index: number): Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue;

/**
 * Retrieves the HttpConnectionOptionHeaderValue items that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the HttpConnectionOptionHeaderValue items in the HttpConnectionOptionHeaderValueCollection .
 */
getMany(
startIndex: number): {
items: Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue,
returnValue: number
};

/**
 * Returns an immutable view of the HttpConnectionOptionHeaderValueCollection .
 * @return The view of the HttpConnectionOptionHeaderValueCollection .
 */
getView(
): Windows$Foundation$Collections$IVectorView<Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue>;

/**
 * Retrieves the index of an HttpConnectionOptionHeaderValue in the collection.
 * @param value The HttpConnectionOptionHeaderValue to find in the HttpConnectionOptionHeaderValueCollection .
 */
indexOf(
value: Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue): {
index: number,
returnValue: boolean
};

/**
 * Determines the index of a specific item in the collection.
 * @param item The object to locate in the collection.
 * @return The index of item if found in the collection; otherwise, 1.
 */
indexOf(item: Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue): number;

/**
 * Inserts an HttpConnectionOptionHeaderValue into the collection at the specified index.
 * @param index The zero-based index at which value should be inserted.
 * @param value The object to insert into the collection.
 */
insertAt(
index: number,
value: Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue): void;

/**
 * Parses and adds an entry to the HttpConnectionOptionHeaderValueCollection .
 * @param input The entry to add.
 */
parseAdd(input: string): void;

/**
 * Removes the entry at the specified index from the HttpConnectionOptionHeaderValueCollection .
 * @param index The index of the entry to remove.
 */
removeAt(index: number): void;

/**
 * Removes the element at the specified index of the collection.
 * @param index The zero-based index of the element to remove.
 */
removeAt(index: number): void;

/**
 * Removes the last HttpConnectionOptionHeaderValue item from the collection.
 */
removeAtEnd(): void;

/**
 * Replaces all the HttpConnectionOptionHeaderValue items in the collection with the specified HttpConnectionOptionHeaderValue items.
 * @param items The collection of HttpConnectionOptionHeaderValue items to add to the collection.
 */
replaceAll(items: Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue): void;

/**
 * Sets the HttpConnectionOptionHeaderValue at the specified index in the collection.
 * @param index The zero-based index at which to set the HttpConnectionOptionHeaderValue .
 * @param value The item to set.
 */
setAt(
index: number,
value: Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue): void;

/**
 * Gets the number of HttpConnectionOptionHeaderValue objects in the collection.
 */
size: number;

/**
 * Tries to parse and add the specified item to the HttpConnectionOptionHeaderValueCollection .
 * @param input The item to parse and add.
 * @return true if the item successfully parsed and was added; otherwise false.
 */
tryParseAdd(input: string): boolean;
indexOf(
value: Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Web$Http$Headers$HttpConnectionOptionHeaderValue,
fromIndex?: number): number
}


/**
 * Represents content encoding information used in the Content-Encoding HTTP header on HTTP content in a request or a response.
 */
declare class Windows$Web$Http$Headers$HttpContentCodingHeaderValue  {

/**
 * Converts a string to an HttpContentCodingHeaderValue instance.
 * @param input A string that represents the content coding information in the Content-Encoding HTTP header.
 * @return An HttpContentCodingHeaderValue instance.
 */
static parse(input: string): Windows$Web$Http$Headers$HttpContentCodingHeaderValue;

/**
 * Determines whether a string is valid HttpContentCodingHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
contentCodingHeaderValue: Windows$Web$Http$Headers$HttpContentCodingHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpContentCodingHeaderValue class.
 * @param contentCoding The value of the content-coding to use.
 */
constructor(contentCoding: string): this;

/**
 * Gets the value of the content-coding information used in the Content-Encoding HTTP header.
 */
contentCoding: string
}


/**
 * Represents the value of the Content-Encoding HTTP header on HTTP content in a request or a response.
 */
declare class Windows$Web$Http$Headers$HttpContentCodingHeaderValueCollection mixins Array<Windows$Web$Http$Headers$HttpContentCodingHeaderValue> {

/**
 * Adds a new HttpContentCodingHeaderValue item to the end of the collection.
 * @param value The HttpContentCodingHeaderValue object to append.
 */
append(value: Windows$Web$Http$Headers$HttpContentCodingHeaderValue): void;

/**
 * Removes all objects from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator to the first HttpContentCodingHeaderValue item in the collection.
 * @return An object that can be used to enumerate the HttpContentCodingHeaderValue items in the collection. The iterator points to the first HttpContentCodingHeaderValue item in the HttpContentCodingHeaderValueCollection .
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Web$Http$Headers$HttpContentCodingHeaderValue>;

/**
 * Returns the HttpContentCodingHeaderValue at the specified index in the collection.
 * @param index The zero-based index of a specified item in the HttpContentCodingHeaderValueCollection .
 * @return The HttpContentCodingHeaderValue at the specified index in the HttpContentCodingHeaderValueCollection .
 */
getAt(index: number): Windows$Web$Http$Headers$HttpContentCodingHeaderValue;

/**
 * Retrieves the HttpContentCodingHeaderValue items that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the HttpContentCodingHeaderValue items in the HttpContentCodingHeaderValueCollection .
 */
getMany(
startIndex: number): {
items: Windows$Web$Http$Headers$HttpContentCodingHeaderValue,
returnValue: number
};

/**
 * Returns an immutable view of the HttpContentCodingHeaderValueCollection .
 * @return The view of the HttpContentCodingHeaderValueCollection .
 */
getView(
): Windows$Foundation$Collections$IVectorView<Windows$Web$Http$Headers$HttpContentCodingHeaderValue>;

/**
 * Retrieves the index of an HttpContentCodingHeaderValue in the collection.
 * @param value The HttpContentCodingHeaderValue to find in the HttpContentCodingHeaderValueCollection .
 */
indexOf(
value: Windows$Web$Http$Headers$HttpContentCodingHeaderValue): {
index: number,
returnValue: boolean
};

/**
 * Determines the index of a specific item in the collection.
 * @param item The object to locate in the collection.
 * @return The index of item if found in the collection; otherwise, 1.
 */
indexOf(item: Windows$Web$Http$Headers$HttpContentCodingHeaderValue): number;

/**
 * Inserts an HttpContentCodingHeaderValue into the collection at the specified index.
 * @param index The zero-based index at which value should be inserted.
 * @param value The object to insert into the collection.
 */
insertAt(
index: number,
value: Windows$Web$Http$Headers$HttpContentCodingHeaderValue): void;

/**
 * Parses and adds an entry to the HttpContentCodingHeaderValueCollection .
 * @param input The entry to add.
 */
parseAdd(input: string): void;

/**
 * Removes the entry at the specified index from the HttpContentCodingHeaderValueCollection .
 * @param index The index of the entry to remove.
 */
removeAt(index: number): void;

/**
 * Removes the element at the specified index of the collection.
 * @param index The zero-based index of the element to remove.
 */
removeAt(index: number): void;

/**
 * Removes the last HttpContentCodingHeaderValue item from the collection.
 */
removeAtEnd(): void;

/**
 * Replaces all the HttpContentCodingHeaderValue items in the collection with the specified HttpContentCodingHeaderValue items.
 * @param items The HttpContentCodingHeaderValue items to add to the collection.
 */
replaceAll(items: Windows$Web$Http$Headers$HttpContentCodingHeaderValue): void;

/**
 * Sets the HttpContentCodingHeaderValue at the specified index in the collection.
 * @param index The zero-based index at which to set the HttpContentCodingHeaderValue .
 * @param value The item to set.
 */
setAt(
index: number,
value: Windows$Web$Http$Headers$HttpContentCodingHeaderValue): void;

/**
 * Gets the number of HttpContentCodingHeaderValue objects in the collection.
 */
size: number;

/**
 * Tries to parse and add the specified item to the HttpContentCodingHeaderValueCollection .
 * @param input The item to parse and add.
 * @return true if the item successfully parsed and was added; otherwise false.
 */
tryParseAdd(input: string): boolean;
indexOf(
value: Windows$Web$Http$Headers$HttpContentCodingHeaderValue,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Web$Http$Headers$HttpContentCodingHeaderValue,
fromIndex?: number): number
}


/**
 * Represents accept encoding information used in the Accept-Encoding HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue  {

/**
 * Converts a string to an HttpContentCodingWithQualityHeaderValue instance.
 * @param input A string that represents the content coding information in the Accept-Encoding HTTP header.
 * @return An HttpContentCodingWithQualityHeaderValue instance.
 */
static parse(
input: string): Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue;

/**
 * Determines whether a string is valid HttpContentCodingWithQualityHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
contentCodingWithQualityHeaderValue: Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpContentCodingHeaderValue class with content-coding information and a qvalue.
 * @param contentCoding The value of the content-coding information to use.
 * @param quality The value of the qvalue to use.
 */
constructor(contentCoding: string, quality: number): this;

/**
 * Initializes a new instance of the HttpContentCodingHeaderValue class with content-coding information.
 * @param contentCoding The value of the content-coding to use.
 */
constructor(contentCoding: string): this;

/**
 * Gets the value of the content-coding characteristic in the Accept-Encoding HTTP header.
 */
contentCoding: string;

/**
 * Gets the value of the qvalue attribute in the Accept-Encoding HTTP header.
 */
quality: number
}


/**
 * Represents the value of the Accept-Encoding HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValueCollection mixins Array<Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue> {

/**
 * Adds a new HttpContentCodingWithQualityHeaderValue item to the end of the collection.
 * @param value The HttpContentCodingWithQualityHeaderValue object to append.
 */
append(value: Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue): void;

/**
 * Removes all objects from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator to the first HttpContentCodingWithQualityHeaderValue item in the collection.
 * @return An object that can be used to enumerate the HttpContentCodingWithQualityHeaderValue items in the collection. The iterator points to the first HttpContentCodingWithQualityHeaderValue item in the HttpContentCodingWithQualityHeaderValueCollection .
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue>;

/**
 * Returns the HttpContentCodingWithQualityHeaderValue at the specified index in the collection.
 * @param index The zero-based index of a specified item in the collection.
 * @return The HttpContentCodingWithQualityHeaderValue at the specified index in the HttpContentCodingWithQualityHeaderValueCollection .
 */
getAt(
index: number): Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue;

/**
 * Retrieves the HttpContentCodingWithQualityHeaderValue items that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the HttpContentCodingWithQualityHeaderValue items in the HttpContentCodingWithQualityHeaderValueCollection .
 */
getMany(
startIndex: number): {
items: Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue,
returnValue: number
};

/**
 * Returns an immutable view of the HttpContentCodingWithQualityHeaderValueCollection .
 * @return The view of the HttpContentCodingWithQualityHeaderValueCollection .
 */
getView(
): Windows$Foundation$Collections$IVectorView<Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue>;

/**
 * Retrieves the index of an HttpContentCodingWithQualityHeaderValue in the collection.
 * @param value The HttpContentCodingWithQualityHeaderValue to find in the HttpContentCodingWithQualityHeaderValueCollection .
 */
indexOf(
value: Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue): {
index: number,
returnValue: boolean
};

/**
 * Determines the index of a specific item in the collection.
 * @param item The object to locate in the collection.
 * @return The index of item if found in the collection; otherwise, 1.
 */
indexOf(item: Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue): number;

/**
 * Inserts an HttpContentCodingWithQualityHeaderValue into the collection at the specified index.
 * @param index The zero-based index at which value should be inserted.
 * @param value The object to insert into the collection.
 */
insertAt(
index: number,
value: Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue): void;

/**
 * Parses and adds an entry to the HttpContentCodingWithQualityHeaderValueCollection .
 * @param input The entry to add.
 */
parseAdd(input: string): void;

/**
 * Removes the entry at the specified index from the HttpContentCodingWithQualityHeaderValueCollection .
 * @param index The index of the entry to remove.
 */
removeAt(index: number): void;

/**
 * Removes the element at the specified index of the collection.
 * @param index The zero-based index of the element to remove.
 */
removeAt(index: number): void;

/**
 * Removes the last HttpContentCodingWithQualityHeaderValue item from the collection.
 */
removeAtEnd(): void;

/**
 * Replaces all the HttpContentCodingWithQualityHeaderValue items in the collection with the specified HttpContentCodingWithQualityHeaderValue items.
 * @param items The HttpContentCodingWithQualityHeaderValue items to add to the collection.
 */
replaceAll(items: Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue): void;

/**
 * Sets the HttpContentCodingWithQualityHeaderValue at the specified index in the collection.
 * @param index The zero-based index at which to set the HttpContentCodingWithQualityHeaderValue .
 * @param value The item to set.
 */
setAt(
index: number,
value: Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue): void;

/**
 * Gets the number of HttpContentCodingWithQualityHeaderValue objects in the collection.
 */
size: number;

/**
 * Tries to parse and add the specified item to the HttpContentCodingWithQualityHeaderValueCollection .
 * @param input The item to parse and add.
 * @return true if the item successfully parsed and was added; otherwise false.
 */
tryParseAdd(input: string): boolean;
indexOf(
value: Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValue,
fromIndex?: number): number
}


/**
 * Represents the value of the Content-Disposition HTTP header on HTTP content in a request or a response.
 */
declare class Windows$Web$Http$Headers$HttpContentDispositionHeaderValue  {

/**
 * Converts a string to an HttpContentDispositionHeaderValue instance.
 * @param input A string that represents the content disposition information in the Content-Disposition HTTP header.
 * @return An HttpContentDispositionHeaderValue instance.
 */
static parse(input: string): Windows$Web$Http$Headers$HttpContentDispositionHeaderValue;

/**
 * Determines whether a string is valid HttpContentDispositionHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
contentDispositionHeaderValue: Windows$Web$Http$Headers$HttpContentDispositionHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpContentDispositionHeaderValue class with content-coding information for use in the Content-Disposition HTTP header.
 * @param dispositionType The value of the disposition-type information to be used in the Content-Disposition HTTP header.
 */
constructor(dispositionType: string): this;

/**
 * Gets or sets the value of the disposition-type information in the Content-Disposition HTTP header.
 */
dispositionType: string;

/**
 * Gets or sets the value of the filename-parm information in the Content-Disposition HTTP header for a single file.
 */
fileName: string;

/**
 * Gets or sets the value of the filename-parm characteristic in the Content-Disposition HTTP header for multiple files.
 */
fileNameStar: string;

/**
 * Gets or sets the name for a content body part in the Content-Disposition HTTP header.
 */
name: string;

/**
 * Gets a set of parameters included in the Content-Disposition HTTP header.
 */
parameters: Windows$Foundation$Collections$IVector<Windows$Web$Http$Headers$HttpNameValueHeaderValue>;

/**
 * Gets or sets the approximate size, in bytes, of the file used in the Content-Disposition HTTP header.
 */
size: number
}


/**
 * Provides a collection of the HTTP headers associated with content on an HTTP request or response.
 */
declare class Windows$Web$Http$Headers$HttpContentHeaderCollection  {

/**
 * Initializes a new instance of the HttpContentHeaderCollection class.
 */
constructor(): this;

/**
 * Adds a new item to the end of the HttpContentHeaderCollection .
 * @param name The name of the value to add.
 * @param value The item value to add.
 */
append(name: string, value: string): void;

/**
 * Removes all objects from the HttpContentHeaderCollection .
 */
clear(): void;

/**
 * Gets or sets the HttpContentDispositionHeaderValue object that represents the value of an HTTP Content-Disposition header on the HTTP content.
 */
contentDisposition: Windows$Web$Http$Headers$HttpContentDispositionHeaderValue;

/**
 * Gets the HttpContentCodingHeaderValueCollection of HttpContentCodingHeaderValue objects that represent the value of an HTTP Content-Encoding header on the HTTP content.
 */
contentEncoding: Windows$Web$Http$Headers$HttpContentCodingHeaderValueCollection;

/**
 * Gets the HttpLanguageHeaderValueCollection of objects that represent the value of an HTTP Content-Language header on the HTTP content.
 */
contentLanguage: Windows$Web$Http$Headers$HttpLanguageHeaderValueCollection;

/**
 * Gets or sets the value of the HTTP Content-Length header on the HTTP content.
 */
contentLength: number;

/**
 * Gets or sets the value of the HTTP Content-Location header on the HTTP content.
 */
contentLocation: Windows$Foundation$Uri;

/**
 * Gets or sets the value of an HTTP Content-MD5 header on the HTTP content.
 */
contentMD5: Windows$Storage$Streams$IBuffer;

/**
 * Gets or sets the HttpContentRangeHeaderValue object that represent the value of an HTTP Content-Range header on the HTTP content.
 */
contentRange: Windows$Web$Http$Headers$HttpContentRangeHeaderValue;

/**
 * Gets or sets the HttpMediaTypeHeaderValue object that represent the value of an HTTP Content-Type header on the HTTP content.
 */
contentType: Windows$Web$Http$Headers$HttpMediaTypeHeaderValue;

/**
 * Gets or sets the DateTime object that represents the value of an HTTP Expires header on the HTTP content.
 */
expires: Date;

/**
 * Retrieves an iterator to the first item in the HttpContentHeaderCollection .
 * @return An object that can be used to enumerate the items in the collection. The iterator points to the first item in the HttpContentHeaderCollection .
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Returns an immutable view of the HttpContentHeaderCollection .
 * @return The view of the HttpContentHeaderCollection .
 */
getView(): Windows$Foundation$Collections$IMapView<string, string>;

/**
 * Determines whether the HttpContentHeaderCollection contains the specified key.
 * @param key The key associated with the item to locate.
 * @return true if the key is found; otherwise, false.
 */
hasKey(key: string): boolean;

/**
 * Inserts or replaces an item in the HttpContentHeaderCollection with the specified key and value.
 * @param key The key of the item to be inserted.
 * @param value The value of the item to insert.
 * @return true if an item with the specified key is an existing item that was replaced; otherwise false.
 */
insert(key: string, value: string): boolean;

/**
 * Gets or sets the DateTime object that represents the value of an HTTP Last-Modified header on the HTTP content.
 */
lastModified: Date;

/**
 * Finds an item in the HttpContentHeaderCollection if it exists.
 * @param key The key of the item to lookup.
 * @return The value of the item if found.
 */
lookup(key: string): string;

/**
 * Removes a specific object from the HttpContentHeaderCollection .
 * @param key The key of the item to remove.
 */
remove(key: string): void;

/**
 * Removes a specific item from the HttpContentHeaderCollection .
 * @param key The key of the item to remove.
 * @return true if the item was removed, otherwise false.
 */
remove(key: string): boolean;

/**
 * Gets the number of objects in the HttpContentHeaderCollection .
 */
size: number;

/**
 * Try to append the specified item to the HttpContentHeaderCollection without validation.
 * @param name The name of the item to append.
 * @param value The value of the item to append.
 * @return true if the item was appended; otherwise false.
 */
tryAppendWithoutValidation(name: string, value: string): boolean
}


/**
 * Represents the value of the Content-Range HTTP header on HTTP content in a request or a response.
 */
declare class Windows$Web$Http$Headers$HttpContentRangeHeaderValue  {

/**
 * Converts a string to an HttpContentRangeHeaderValue instance.
 * @param input A string that represents the content range information in the Content-Range HTTP header.
 * @return An HttpContentRangeHeaderValue instance.
 */
static parse(input: string): Windows$Web$Http$Headers$HttpContentRangeHeaderValue;

/**
 * Determines whether a string is valid HttpContentRangeHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
contentRangeHeaderValue: Windows$Web$Http$Headers$HttpContentRangeHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpContentRangeHeaderValue class with a content length.
 * @param length The length, in bytes, of the full content entity body.
 */
constructor(length: number): this;

/**
 * Initializes a new instance of the HttpContentRangeHeaderValue class with a start and stop position.
 * @param from The position, in bytes, at which to start sending data.
 * @param to The position, in bytes, at which to stop sending data.
 */
constructor(from: number, to: number): this;

/**
 * Initializes a new instance of the HttpContentRangeHeaderValue class with a start and stop position and a content length.
 * @param from The position, in bytes, at which to start sending data.
 * @param to The position, in bytes, at which to stop sending data.
 * @param length The length, in bytes, of the full content entity body.
 */
constructor(from: number, to: number, length: number): this;

/**
 * Gets the position at which to start sending data in the Content-Range HTTP header.
 */
firstBytePosition: number;

/**
 * Gets the position at which to stop sending data in the Content-Range HTTP header.
 */
lastBytePosition: number;

/**
 * Gets the length of the full content entity body in the Content-Range HTTP header.
 */
length: number;

/**
 * Gets or sets the value of the range units used in the Content-Range HTTP header.
 */
unit: string
}


/**
 * Represents cookie information used in the Cookie HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpCookiePairHeaderValue  {

/**
 * Converts a string to an HttpCookiePairHeaderValue instance.
 * @param input A string that represents the cookie name and value in the Cookie HTTP header.
 * @return An HttpCookiePairHeaderValue instance.
 */
static parse(input: string): Windows$Web$Http$Headers$HttpCookiePairHeaderValue;

/**
 * Determines whether a string is valid HttpCookiePairHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
cookiePairHeaderValue: Windows$Web$Http$Headers$HttpCookiePairHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpCookiePairHeaderValue class. with a cookie name and a value for the cookie.
 * @param name A token that represents the cookie name.
 * @param value A value for the cookie.
 */
constructor(name: string, value: string): this;

/**
 * Initializes a new instance of the HttpCookiePairHeaderValue class. with a cookie name.
 * @param name A token that represents the cookie name.
 */
constructor(name: string): this;

/**
 * Gets a token that represents the cookie name used in the Cookie HTTP header.
 */
name: string;

/**
 * Gets or sets a value for the cookie used in the Cookie HTTP header.
 */
value: string
}


/**
 * Represents the value of the Cookie HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpCookiePairHeaderValueCollection mixins Array<Windows$Web$Http$Headers$HttpCookiePairHeaderValue> {

/**
 * Adds a new HttpCookiePairHeaderValue item to the end of the collection.
 * @param value The new item to add.
 */
append(value: Windows$Web$Http$Headers$HttpCookiePairHeaderValue): void;

/**
 * Removes all objects from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator to the first HttpCookiePairHeaderValue item in the collection.
 * @return An object that can be used to enumerate the HttpCookiePairHeaderValue items in the collection. The iterator points to the first HttpCookiePairHeaderValue item in the HttpCookiePairHeaderValueCollection .
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Web$Http$Headers$HttpCookiePairHeaderValue>;

/**
 * Returns the HttpCookiePairHeaderValue at the specified index in the collection.
 * @param index The zero-based index of a specified item in the collection.
 * @return The HttpCookiePairHeaderValue at the specified index in the HttpCookiePairHeaderValueCollection .
 */
getAt(index: number): Windows$Web$Http$Headers$HttpCookiePairHeaderValue;

/**
 * Retrieves the HttpCookiePairHeaderValue items that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the HttpCookiePairHeaderValue items in the HttpCookiePairHeaderValueCollection .
 */
getMany(
startIndex: number): {
items: Windows$Web$Http$Headers$HttpCookiePairHeaderValue,
returnValue: number
};

/**
 * Returns an immutable view of the HttpCookiePairHeaderValueCollection .
 * @return The view of the HttpCookiePairHeaderValueCollection .
 */
getView(
): Windows$Foundation$Collections$IVectorView<Windows$Web$Http$Headers$HttpCookiePairHeaderValue>;

/**
 * Retrieves the index of an HttpCookiePairHeaderValue in the collection.
 * @param value The HttpCookiePairHeaderValue to find in the HttpCookiePairHeaderValueCollection .
 */
indexOf(
value: Windows$Web$Http$Headers$HttpCookiePairHeaderValue): {
index: number,
returnValue: boolean
};

/**
 * Determines the index of a specific item in the collection.
 * @param item The object to locate in the collection.
 * @return The index of item if found in the collection; otherwise, 1.
 */
indexOf(item: Windows$Web$Http$Headers$HttpCookiePairHeaderValue): number;

/**
 * Inserts an HttpCookiePairHeaderValue into the collection at the specified index.
 * @param index The zero-based index at which value should be inserted.
 * @param value The object to insert into the collection.
 */
insertAt(index: number, value: Windows$Web$Http$Headers$HttpCookiePairHeaderValue): void;

/**
 * Parses and adds an entry to the HttpCookiePairHeaderValueCollection .
 * @param input The entry to add.
 */
parseAdd(input: string): void;

/**
 * Removes the entry at the specified index from the HttpCookiePairHeaderValueCollection .
 * @param index The index of the entry to remove.
 */
removeAt(index: number): void;

/**
 * Removes the element at the specified index of the collection.
 * @param index The zero-based index of the element to remove.
 */
removeAt(index: number): void;

/**
 * Removes the last HttpCookiePairHeaderValue item from the collection.
 */
removeAtEnd(): void;

/**
 * Replaces all the HttpCookiePairHeaderValue items in the collection with the specified HttpCookiePairHeaderValue items.
 * @param items The HttpCookiePairHeaderValue items to add to the collection.
 */
replaceAll(items: Windows$Web$Http$Headers$HttpCookiePairHeaderValue): void;

/**
 * Sets the HttpCookiePairHeaderValue at the specified index in the collection.
 * @param index The zero-based index at which to set the HttpCookiePairHeaderValue .
 * @param value The item to set.
 */
setAt(index: number, value: Windows$Web$Http$Headers$HttpCookiePairHeaderValue): void;

/**
 * Gets the number of HttpCookiePairHeaderValue objects in the collection.
 */
size: number;

/**
 * Tries to parse and add the specified item to the HttpCookiePairHeaderValueCollection .
 * @param input The item to parse and add.
 * @return true if the item successfully parsed and was added; otherwise false.
 */
tryParseAdd(input: string): boolean;
indexOf(
value: Windows$Web$Http$Headers$HttpCookiePairHeaderValue,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Web$Http$Headers$HttpCookiePairHeaderValue,
fromIndex?: number): number
}


/**
 * Represents the value of the Authorization or Proxy-Authorization HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpCredentialsHeaderValue  {

/**
 * Converts a string to an HttpCredentialsHeaderValue instance.
 * @param input A string that represents the credential information in the Authorization or Proxy-Authorization HTTP header.
 * @return An HttpCredentialsHeaderValue instance.
 */
static parse(input: string): Windows$Web$Http$Headers$HttpCredentialsHeaderValue;

/**
 * Determines whether a string is valid HttpCredentialsHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
credentialsHeaderValue: Windows$Web$Http$Headers$HttpCredentialsHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpCredentialsHeaderValue class with the scheme and user token information to use for authentication.
 * @param scheme The scheme to use for authentication.
 * @param token The user token information to use for authentication.
 */
constructor(scheme: string, token: string): this;

/**
 * Initializes a new instance of the HttpCredentialsHeaderValue class with the scheme to use for authentication.
 * @param scheme The scheme to use for authentication.
 */
constructor(scheme: string): this;

/**
 * Gets a set of name/value pairs included in the Authorization or Proxy-Authorization HTTP header.
 */
parameters: Windows$Foundation$Collections$IVector<Windows$Web$Http$Headers$HttpNameValueHeaderValue>;

/**
 * Gets the scheme to use for authentication.
 */
scheme: string;

/**
 * Gets the user token information used in the Authorization or Proxy-Authorization HTTP header.
 */
token: string
}


/**
 * Represents the value of the Retry-After HTTP header on an HTTP response.
 */
declare class Windows$Web$Http$Headers$HttpDateOrDeltaHeaderValue  {

/**
 * Converts a string to an HttpDateOrDeltaHeaderValue instance.
 * @param input A string that represents the HTTP-date or delta-seconds information in the Retry-After HTTP header.
 * @return An HttpDateOrDeltaHeaderValue instance.
 */
static parse(input: string): Windows$Web$Http$Headers$HttpDateOrDeltaHeaderValue;

/**
 * Determines whether a string is valid HttpDateOrDeltaHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
dateOrDeltaHeaderValue: Windows$Web$Http$Headers$HttpDateOrDeltaHeaderValue,
returnValue: boolean
};

/**
 * Gets the value of the HTTP-date information used in the Retry-After HTTP header.
 */
date: Date;

/**
 * Gets the value of the delta-seconds information used in the Retry-After HTTP header.
 */
delta: number
}


/**
 * Represents a token for a particular server behavior required by the client that is used in the Expect HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpExpectationHeaderValue  {

/**
 * Converts a string to an HttpExpectationHeaderValue instance.
 * @param input A string that represents the information in the Expect HTTP header.
 * @return An HttpExpectationHeaderValue instance.
 */
static parse(input: string): Windows$Web$Http$Headers$HttpExpectationHeaderValue;

/**
 * Determines whether a string is valid HttpCredentialsHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
expectationHeaderValue: Windows$Web$Http$Headers$HttpExpectationHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpExpectationHeaderValue class with a name and value for the name.
 * @param name A token that represents a name used in the Expect HTTP header.
 * @param value A value for the name used in the Expect HTTP header.
 */
constructor(name: string, value: string): this;

/**
 * Initializes a new instance of the HttpExpectationHeaderValue class with a name.
 * @param name A token that represents a name used in the Expect HTTP header.
 */
constructor(name: string): this;

/**
 * Gets or sets a token that represents a name for a server behavior used in the Expect HTTP header.
 */
name: string;

/**
 * Gets a set of parameters for a server behavior included in the Expect HTTP header.
 */
parameters: Windows$Foundation$Collections$IVector<Windows$Web$Http$Headers$HttpNameValueHeaderValue>;

/**
 * Gets or sets a value for a server behavior used in the Expect HTTP header.
 */
value: string
}


/**
 * Represents the value of the Expect HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpExpectationHeaderValueCollection mixins Array<Windows$Web$Http$Headers$HttpExpectationHeaderValue> {

/**
 * Adds a new HttpExpectationHeaderValue item to the end of the collection.
 * @param value The new item to add.
 */
append(value: Windows$Web$Http$Headers$HttpExpectationHeaderValue): void;

/**
 * Removes all objects from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator to the first HttpExpectationHeaderValue item in the collection.
 * @return An object that can be used to enumerate the HttpExpectationHeaderValue items in the collection. The iterator points to the first HttpExpectationHeaderValue item in the HttpExpectationHeaderValueCollection .
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Web$Http$Headers$HttpExpectationHeaderValue>;

/**
 * Returns the HttpExpectationHeaderValue at the specified index in the collection.
 * @param index The zero-based index of a specified item in the collection.
 * @return The HttpExpectationHeaderValue at the specified index in the HttpExpectationHeaderValueCollection .
 */
getAt(index: number): Windows$Web$Http$Headers$HttpExpectationHeaderValue;

/**
 * Retrieves the HttpExpectationHeaderValue items that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the HttpExpectationHeaderValue items in the HttpExpectationHeaderValueCollection .
 */
getMany(
startIndex: number): {
items: Windows$Web$Http$Headers$HttpExpectationHeaderValue,
returnValue: number
};

/**
 * Returns an immutable view of the HttpExpectationHeaderValueCollection .
 * @return The view of the HttpExpectationHeaderValueCollection .
 */
getView(
): Windows$Foundation$Collections$IVectorView<Windows$Web$Http$Headers$HttpExpectationHeaderValue>;

/**
 * Retrieves the index of an HttpExpectationHeaderValue in the collection.
 * @param value The HttpExpectationHeaderValue to find in the HttpExpectationHeaderValueCollection .
 */
indexOf(
value: Windows$Web$Http$Headers$HttpExpectationHeaderValue): {
index: number,
returnValue: boolean
};

/**
 * Determines the index of a specific item in the collection.
 * @param item The object to locate in the collection.
 * @return The index of item if found in the collection; otherwise, 1.
 */
indexOf(item: Windows$Web$Http$Headers$HttpExpectationHeaderValue): number;

/**
 * Inserts an HttpExpectationHeaderValue into the collection at the specified index.
 * @param index The zero-based index at which value should be inserted.
 * @param value The object to insert into the collection.
 */
insertAt(
index: number,
value: Windows$Web$Http$Headers$HttpExpectationHeaderValue): void;

/**
 * Parses and adds an entry to the HttpExpectationHeaderValueCollection .
 * @param input The entry to add.
 */
parseAdd(input: string): void;

/**
 * Removes the entry at the specified index from the HttpExpectationHeaderValueCollection .
 * @param index The index of the entry to remove.
 */
removeAt(index: number): void;

/**
 * Removes the element at the specified index of the collection.
 * @param index The zero-based index of the element to remove.
 */
removeAt(index: number): void;

/**
 * Removes the last HttpExpectationHeaderValue item from the collection.
 */
removeAtEnd(): void;

/**
 * Replaces all the HttpExpectationHeaderValue items in the collection with the specified HttpExpectationHeaderValue items.
 * @param items The HttpExpectationHeaderValue items to add to the collection.
 */
replaceAll(items: Windows$Web$Http$Headers$HttpExpectationHeaderValue): void;

/**
 * Sets the HttpExpectationHeaderValue at the specified index in the collection.
 * @param index The zero-based index at which to set the HttpExpectationHeaderValue .
 * @param value The item to set.
 */
setAt(
index: number,
value: Windows$Web$Http$Headers$HttpExpectationHeaderValue): void;

/**
 * Gets the number of HttpExpectationHeaderValue objects in the collection.
 */
size: number;

/**
 * Tries to parse and add the specified item to the HttpExpectationHeaderValueCollection .
 * @param input The item to parse and add.
 * @return true if the item successfully parsed and was added; otherwise false.
 */
tryParseAdd(input: string): boolean;
indexOf(
value: Windows$Web$Http$Headers$HttpExpectationHeaderValue,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Web$Http$Headers$HttpExpectationHeaderValue,
fromIndex?: number): number
}


/**
 * Represents the value of the Content-Language HTTP header on HTTP content in a request or a response.
 */
declare class Windows$Web$Http$Headers$HttpLanguageHeaderValueCollection mixins Array<Windows$Globalization$Language> {

/**
 * Adds a new Language item to the end of the collection.
 * @param value The new item to add.
 */
append(value: Windows$Globalization$Language): void;

/**
 * Removes all objects from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator to the first Language item in the collection.
 * @return An object that can be used to enumerate the Language items in the collection. The iterator points to the first Language item in the HttpLanguageHeaderValueCollection .
 */
first(): Windows$Foundation$Collections$IIterator<Windows$Globalization$Language>;

/**
 * Returns the Language item at the specified index in the collection.
 * @param index The zero-based index of a specified item in the collection.
 * @return The Language item at the specified index in the HttpLanguageHeaderValueCollection .
 */
getAt(index: number): Windows$Globalization$Language;

/**
 * Retrieves the Language items that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the Language items in the HttpLanguageHeaderValueCollection .
 */
getMany(
startIndex: number): {
items: Windows$Globalization$Language,
returnValue: number
};

/**
 * Returns an immutable view of the HttpLanguageHeaderValueCollection .
 * @return The view of the HttpLanguageHeaderValueCollection .
 */
getView(): Windows$Foundation$Collections$IVectorView<Windows$Globalization$Language>;

/**
 * Retrieves the index of a Language in the collection.
 * @param value The item to find in the HttpLanguageHeaderValueCollection .
 */
indexOf(value: Windows$Globalization$Language): {
index: number,
returnValue: boolean
};

/**
 * Determines the index of a specific item in the collection.
 * @param item The object to locate in the collection.
 * @return The index of item if found in the collection; otherwise, 1.
 */
indexOf(item: Windows$Globalization$Language): number;

/**
 * Inserts a Language into the collection at the specified index.
 * @param index The zero-based index at which value should be inserted.
 * @param value The object to insert into the collection.
 */
insertAt(index: number, value: Windows$Globalization$Language): void;

/**
 * Parses and adds an entry to the HttpLanguageHeaderValueCollection .
 * @param input The entry to add.
 */
parseAdd(input: string): void;

/**
 * Removes the entry at the specified index from the HttpLanguageHeaderValueCollection .
 * @param index The index of the entry to remove.
 */
removeAt(index: number): void;

/**
 * Removes the element at the specified index of the collection.
 * @param index The zero-based index of the element to remove.
 */
removeAt(index: number): void;

/**
 * Removes the last Language item from the collection.
 */
removeAtEnd(): void;

/**
 * Replaces all the Language items in the collection with the specified Language items.
 * @param items The Language items to add to the collection.
 */
replaceAll(items: Windows$Globalization$Language): void;

/**
 * Sets the Language at the specified index in the collection.
 * @param index The zero-based index at which to set the Language .
 * @param value The item to set.
 */
setAt(index: number, value: Windows$Globalization$Language): void;

/**
 * Gets the number of Language objects in the collection.
 */
size: number;

/**
 * Tries to parse and add the specified item to the HttpLanguageHeaderValueCollection .
 * @param input The item to parse and add.
 * @return true if the item successfully parsed and was added; otherwise false.
 */
tryParseAdd(input: string): boolean;
indexOf(
value: Windows$Globalization$Language,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(searchElement: Windows$Globalization$Language, fromIndex?: number): number
}


/**
 * Represents accept language information used in the Accept-Language HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue  {

/**
 * Converts a string to an HttpLanguageRangeWithQualityHeaderValue instance.
 * @param input A string that represents the language-range and quality factor information used in the Accept-Encoding HTTP header.
 * @return An HttpLanguageRangeWithQualityHeaderValue instance.
 */
static parse(
input: string): Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue;

/**
 * Determines whether a string is valid HttpLanguageRangeWithQualityHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
languageRangeWithQualityHeaderValue: Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpLanguageRangeWithQualityHeaderValue class with language-range and quality information.
 * @param languageRange The value of the language-range information used in the Accept-Language HTTP header.
 * @param quality The value of the qvalue or quality factor used in the Accept-Language HTTP header.
 */
constructor(languageRange: string, quality: number): this;

/**
 * Initializes a new instance of the HttpLanguageRangeWithQualityHeaderValue class with language-range information.
 * @param languageRange The value of the language-range information used in the Accept-Language HTTP header.
 */
constructor(languageRange: string): this;

/**
 * Gets the value of the language-range information from the HttpLanguageRangeWithQualityHeaderValue used in the Accept-Language HTTP header.
 */
languageRange: string;

/**
 * Gets the value of the qvalue or quality factor from the HttpLanguageRangeWithQualityHeaderValue used in the Accept-Language HTTP header.
 */
quality: number
}


/**
 * Represents the value of the Accept-Language HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValueCollection mixins Array<Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue> {

/**
 * Adds a new HttpLanguageRangeWithQualityHeaderValue item to the end of the collection.
 * @param value The new item to add.
 */
append(value: Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue): void;

/**
 * Removes all objects from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator to the first HttpLanguageRangeWithQualityHeaderValue item in the collection.
 * @return An object that can be used to enumerate the HttpLanguageRangeWithQualityHeaderValue items in the collection. The iterator points to the first HttpLanguageRangeWithQualityHeaderValue item in the HttpLanguageRangeWithQualityHeaderValueCollection .
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue>;

/**
 * Returns the HttpLanguageRangeWithQualityHeaderValue at the specified index in the collection.
 * @param index The zero-based index of a specified item in the collection.
 * @return The HttpLanguageRangeWithQualityHeaderValue at the specified index in the HttpLanguageRangeWithQualityHeaderValueCollection .
 */
getAt(
index: number): Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue;

/**
 * Retrieves the HttpLanguageRangeWithQualityHeaderValue items that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the HttpLanguageRangeWithQualityHeaderValue items in the HttpLanguageRangeWithQualityHeaderValueCollection .
 */
getMany(
startIndex: number): {
items: Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue,
returnValue: number
};

/**
 * Returns an immutable view of the HttpLanguageRangeWithQualityHeaderValueCollection .
 * @return The view of the HttpLanguageRangeWithQualityHeaderValueCollection .
 */
getView(
): Windows$Foundation$Collections$IVectorView<Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue>;

/**
 * Retrieves the index of an HttpLanguageRangeWithQualityHeaderValue in the collection.
 * @param value The HttpLanguageRangeWithQualityHeaderValue to find in the HttpLanguageRangeWithQualityHeaderValueCollection .
 */
indexOf(
value: Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue): {
index: number,
returnValue: boolean
};

/**
 * Determines the index of a specific item in the collection.
 * @param item The object to locate in the collection.
 * @return The index of item if found in the collection; otherwise, 1.
 */
indexOf(item: Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue): number;

/**
 * Inserts an HttpLanguageRangeWithQualityHeaderValue into the collection at the specified index.
 * @param index The zero-based index at which value should be inserted.
 * @param value The object to insert into the collection.
 */
insertAt(
index: number,
value: Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue): void;

/**
 * Parses and adds an entry to the HttpLanguageRangeWithQualityHeaderValueCollection .
 * @param input The entry to add.
 */
parseAdd(input: string): void;

/**
 * Removes the entry at the specified index from the HttpLanguageRangeWithQualityHeaderValueCollection .
 * @param index The index of the entry to remove.
 */
removeAt(index: number): void;

/**
 * Removes the element at the specified index of the collection.
 * @param index The zero-based index of the element to remove.
 */
removeAt(index: number): void;

/**
 * Removes the last HttpLanguageRangeWithQualityHeaderValue item from the collection.
 */
removeAtEnd(): void;

/**
 * Replaces all the HttpLanguageRangeWithQualityHeaderValue items in the collection with the specified HttpLanguageRangeWithQualityHeaderValue items.
 * @param items The HttpLanguageRangeWithQualityHeaderValue items to add to the collection.
 */
replaceAll(items: Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue): void;

/**
 * Sets the HttpLanguageRangeWithQualityHeaderValue at the specified index in the collection.
 * @param index The zero-based index at which to set the HttpLanguageRangeWithQualityHeaderValue .
 * @param value The item to set.
 */
setAt(
index: number,
value: Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue): void;

/**
 * Gets the number of HttpLanguageRangeWithQualityHeaderValue objects in the collection.
 */
size: number;

/**
 * Tries to parse and add the specified item to the HttpLanguageRangeWithQualityHeaderValueCollection .
 * @param input The item to parse and add.
 * @return true if the item successfully parsed and was added; otherwise false.
 */
tryParseAdd(input: string): boolean;
indexOf(
value: Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValue,
fromIndex?: number): number
}


/**
 * Represents the value of the Content-Type HTTP header on the HTTP content in a request or a response.
 */
declare class Windows$Web$Http$Headers$HttpMediaTypeHeaderValue  {

/**
 * Converts a string to an HttpMediaTypeHeaderValue instance.
 * @param input A string that represents the media-type and character set information used in the Content-Type HTTP header.
 * @return An HttpMediaTypeHeaderValue instance.
 */
static parse(input: string): Windows$Web$Http$Headers$HttpMediaTypeHeaderValue;

/**
 * Determines whether a string is valid HttpMediaTypeHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
mediaTypeHeaderValue: Windows$Web$Http$Headers$HttpMediaTypeHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpMediaTypeHeaderValue class.
 * @param mediaType The media-type of the entity-body used in the Content-Type HTTP header.
 */
constructor(mediaType: string): this;

/**
 * Gets or sets the character set of the entity-body used in the Content-Type HTTP header.
 */
charSet: string;

/**
 * Gets or sets the media-type of the entity-body used in the Content-Type HTTP header.
 */
mediaType: string;

/**
 * Gets a set of parameters included in the Content-Type HTTP header.
 */
parameters: Windows$Foundation$Collections$IVector<Windows$Web$Http$Headers$HttpNameValueHeaderValue>
}


/**
 * Represents accept information used in the Accept HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue  {

/**
 * Converts a string to an HttpMediaTypeWithQualityHeaderValue instance.
 * @param input A string that represents the media-type, character set, and quality information used in the Accept HTTP header.
 * @return An HttpMediaTypeWithQualityHeaderValue instance.
 */
static parse(input: string): Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue;

/**
 * Determines whether a string is valid HttpMediaTypeWithQualityHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
mediaTypeWithQualityHeaderValue: Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpMediaTypeHeaderValue class with a media type and quality.
 * @param mediaType The media-type of the entity-body to accept that is used in the Accept HTTP header.
 * @param quality The qvalue or quality.
 */
constructor(mediaType: string, quality: number): this;

/**
 * Initializes a new instance of the HttpMediaTypeHeaderValue class with a media type.
 * @param mediaType The media-type of the entity-body to accept that is used in the Accept HTTP header.
 */
constructor(mediaType: string): this;

/**
 * Gets or sets the character set of the content to accept that is used in the Accept HTTP header.
 */
charSet: string;

/**
 * Gets or sets the media-type of the content to accept that is used in the Accept HTTP header.
 */
mediaType: string;

/**
 * Gets a set of parameters included in the Accept HTTP header.
 */
parameters: Windows$Foundation$Collections$IVector<Windows$Web$Http$Headers$HttpNameValueHeaderValue>;

/**
 * Get or set the qvalue or quality used in the Accept HTTP header.
 */
quality: number
}


/**
 * Represents the value of the Accept HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValueCollection mixins Array<Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue> {

/**
 * Adds a new HttpMediaTypeWithQualityHeaderValue item to the end of the collection.
 * @param value The new item to add.
 */
append(value: Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue): void;

/**
 * Removes all objects from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator to the first HttpMediaTypeWithQualityHeaderValue item in the collection.
 * @return An object that can be used to enumerate the HttpMediaTypeWithQualityHeaderValue items in the collection. The iterator points to the first HttpMediaTypeWithQualityHeaderValue item in the HttpMediaTypeWithQualityHeaderValueCollection .
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue>;

/**
 * Returns the HttpMediaTypeWithQualityHeaderValue at the specified index in the collection.
 * @param index The zero-based index of a specified item in the collection.
 * @return The HttpMediaTypeWithQualityHeaderValue at the specified index in the HttpMediaTypeWithQualityHeaderValueCollection .
 */
getAt(index: number): Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue;

/**
 * Retrieves the HttpMediaTypeWithQualityHeaderValue items that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the HttpMediaTypeWithQualityHeaderValue items in the HttpMediaTypeWithQualityHeaderValueCollection .
 */
getMany(
startIndex: number): {
items: Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue,
returnValue: number
};

/**
 * Returns an immutable view of the HttpMediaTypeWithQualityHeaderValueCollection .
 * @return The view of the HttpMediaTypeWithQualityHeaderValueCollection .
 */
getView(
): Windows$Foundation$Collections$IVectorView<Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue>;

/**
 * Retrieves the index of an HttpMediaTypeWithQualityHeaderValue in the collection.
 * @param value The HttpMediaTypeWithQualityHeaderValue to find in the HttpMediaTypeWithQualityHeaderValueCollection .
 */
indexOf(
value: Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue): {
index: number,
returnValue: boolean
};

/**
 * Determines the index of a specific item in the collection.
 * @param item The object to locate in the collection.
 * @return The index of item if found in the collection; otherwise, 1.
 */
indexOf(item: Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue): number;

/**
 * Inserts an HttpMediaTypeWithQualityHeaderValue into the collection at the specified index.
 * @param index The zero-based index at which value should be inserted.
 * @param value The object to insert into the collection.
 */
insertAt(
index: number,
value: Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue): void;

/**
 * Parses and adds an entry to the HttpMediaTypeWithQualityHeaderValueCollection .
 * @param input The entry to add.
 */
parseAdd(input: string): void;

/**
 * Removes the entry at the specified index from the HttpMediaTypeWithQualityHeaderValueCollection .
 * @param index The index of the entry to remove.
 */
removeAt(index: number): void;

/**
 * Removes the element at the specified index of the collection.
 * @param index The zero-based index of the element to remove.
 */
removeAt(index: number): void;

/**
 * Removes the last HttpMediaTypeWithQualityHeaderValue item from the collection.
 */
removeAtEnd(): void;

/**
 * Replaces all the HttpMediaTypeWithQualityHeaderValue items in the collection with the specified HttpMediaTypeWithQualityHeaderValue items.
 * @param items The HttpMediaTypeWithQualityHeaderValue items to add to the collection.
 */
replaceAll(items: Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue): void;

/**
 * Sets the HttpMediaTypeWithQualityHeaderValue at the specified index in the collection.
 * @param index The zero-based index at which to set the HttpMediaTypeWithQualityHeaderValue .
 * @param value The item to set.
 */
setAt(
index: number,
value: Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue): void;

/**
 * Gets the number of HttpMediaTypeWithQualityHeaderValue objects in the collection.
 */
size: number;

/**
 * Tries to parse and add the specified item to the HttpMediaTypeWithQualityHeaderValueCollection .
 * @param input The item to parse and add.
 * @return true if the item successfully parsed and was added; otherwise false.
 */
tryParseAdd(input: string): boolean;
indexOf(
value: Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValue,
fromIndex?: number): number
}


/**
 * Represents the value of the Allow HTTP header on an HTTP response.
 */
declare class Windows$Web$Http$Headers$HttpMethodHeaderValueCollection mixins Array<Windows$Web$Http$HttpMethod> {

/**
 * Adds a new HttpMethod item to the end of the collection.
 * @param value The new item to add.
 */
append(value: Windows$Web$Http$HttpMethod): void;

/**
 * Removes all objects from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator to the first HttpMethod item in the collection.
 * @return An object that can be used to enumerate the HttpMethod items in the collection. The iterator points to the first HttpMethod item in the HttpMethodHeaderValueCollection .
 */
first(): Windows$Foundation$Collections$IIterator<Windows$Web$Http$HttpMethod>;

/**
 * Returns the HttpMethod at the specified index in the collection.
 * @param index The zero-based index of a specified item in the collection.
 * @return The HttpMethod at the specified index in the HttpMethodHeaderValueCollection .
 */
getAt(index: number): Windows$Web$Http$HttpMethod;

/**
 * Retrieves the HttpMethod items that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the HttpMethod items in the HttpMethodHeaderValueCollection .
 */
getMany(
startIndex: number): {
items: Windows$Web$Http$HttpMethod,
returnValue: number
};

/**
 * Returns an immutable view of the HttpMethodHeaderValueCollection .
 * @return The view of the HttpMethodHeaderValueCollection .
 */
getView(): Windows$Foundation$Collections$IVectorView<Windows$Web$Http$HttpMethod>;

/**
 * Retrieves the index of an HttpMethod in the collection.
 * @param value The HttpMethod to find in the HttpMethodHeaderValueCollection .
 */
indexOf(value: Windows$Web$Http$HttpMethod): {
index: number,
returnValue: boolean
};

/**
 * Determines the index of a specific item in the collection.
 * @param item The object to locate in the collection.
 * @return The index of item if found in the collection; otherwise, 1.
 */
indexOf(item: Windows$Web$Http$HttpMethod): number;

/**
 * Inserts an HttpMethod into the collection at the specified index.
 * @param index The zero-based index at which value should be inserted.
 * @param value The object to insert into the collection.
 */
insertAt(index: number, value: Windows$Web$Http$HttpMethod): void;

/**
 * Parses and adds an entry to the HttpMethodHeaderValueCollection .
 * @param input The entry to add.
 */
parseAdd(input: string): void;

/**
 * Removes the entry at the specified index from the HttpMethodHeaderValueCollection .
 * @param index The index of the entry to remove.
 */
removeAt(index: number): void;

/**
 * Removes the element at the specified index of the collection.
 * @param index The zero-based index of the element to remove.
 */
removeAt(index: number): void;

/**
 * Removes the last HttpMethod item from the collection.
 */
removeAtEnd(): void;

/**
 * Replaces all the HttpMethod items in the collection with the specified HttpMethod items.
 * @param items The HttpMethod items to add to the collection.
 */
replaceAll(items: Windows$Web$Http$HttpMethod): void;

/**
 * Sets the HttpMethod at the specified index in the collection.
 * @param index The zero-based index at which to set the HttpMethod .
 * @param value The item to set.
 */
setAt(index: number, value: Windows$Web$Http$HttpMethod): void;

/**
 * Gets the number of HttpMethod objects in the collection.
 */
size: number;

/**
 * Tries to parse and add the specified item to the HttpMethodHeaderValueCollection .
 * @param input The item to parse and add.
 * @return true if the item successfully parsed and was added; otherwise false.
 */
tryParseAdd(input: string): boolean;
indexOf(
value: Windows$Web$Http$HttpMethod,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(searchElement: Windows$Web$Http$HttpMethod, fromIndex?: number): number
}


/**
 * Represents name and value information used in a number of HTTP headers.
 */
declare class Windows$Web$Http$Headers$HttpNameValueHeaderValue  {

/**
 * Converts a string to an HttpNameValueHeaderValue instance.
 * @param input A string that represents the name and value.
 * @return An HttpNameValueHeaderValue instance.
 */
static parse(input: string): Windows$Web$Http$Headers$HttpNameValueHeaderValue;

/**
 * Determines whether a string is valid HttpNameValueHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
nameValueHeaderValue: Windows$Web$Http$Headers$HttpNameValueHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpNameValueHeaderValue class. with a name and value.
 * @param name The name to be used.
 * @param value The value to associate with the name.
 */
constructor(name: string, value: string): this;

/**
 * Initializes a new instance of the HttpNameValueHeaderValue class. with a name.
 * @param name The name to be used.
 */
constructor(name: string): this;

/**
 * Gets the name used in the HttpNameValueHeaderValue object.
 */
name: string;

/**
 * Gets or sets the value associated with a name used in the HttpNameValueHeaderValue object.
 */
value: string
}


/**
 * Represents product information used by the HttpProductHeaderValue and HttpProductInfoHeaderValueCollection classes in the User-Agent HTTP header.
 */
declare class Windows$Web$Http$Headers$HttpProductHeaderValue  {

/**
 * Converts a string to an HttpProductHeaderValue instance.
 * @param input A string that represents the product name and version.
 * @return An HttpProductHeaderValue instance.
 */
static parse(input: string): Windows$Web$Http$Headers$HttpProductHeaderValue;

/**
 * Determines whether a string is valid HttpProductHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
productHeaderValue: Windows$Web$Http$Headers$HttpProductHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpProductHeaderValue class with a product name and a product version.
 * @param productName The name of the product token used in the User-Agent HTTP header.
 * @param productVersion The version of the product token used in the User-Agent HTTP header.
 */
constructor(productName: string, productVersion: string): this;

/**
 * Initializes a new instance of the HttpProductHeaderValue class with a product name.
 * @param productName The name of the product token used in the User-Agent HTTP header.
 */
constructor(productName: string): this;

/**
 * Gets a token that represents the name of the product to be used in the User-Agent HTTP header.
 */
name: string;

/**
 * Gets a token that represents the version of the product to be used in the User-Agent HTTP header.
 */
version: string
}


/**
 * Represents product information used in the User-Agent HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpProductInfoHeaderValue  {

/**
 * Converts a string to an HttpProductInfoHeaderValue instance.
 * @param input A string that represents the product information.
 * @return An HttpProductInfoHeaderValue instance.
 */
static parse(input: string): Windows$Web$Http$Headers$HttpProductInfoHeaderValue;

/**
 * Determines whether a string is valid HttpProductInfoHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
productInfoHeaderValue: Windows$Web$Http$Headers$HttpProductInfoHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpProductInfoHeaderValue class with a product name and version.
 * @param productName The name of the product token used in the User-Agent HTTP header.
 * @param productVersion The version of the product token used in the User-Agent HTTP header.
 */
constructor(productName: string, productVersion: string): this;

/**
 * Initializes a new instance of the HttpProductInfoHeaderValue class with a product comment.
 * @param productComment The product comment used in the User-Agent HTTP header.
 */
constructor(productComment: string): this;

/**
 * Gets the product comment from the HttpProductInfoHeaderValue used in the User-Agent HTTP header.
 */
comment: string;

/**
 * Gets the product from the HttpProductInfoHeaderValue used in the User-Agent HTTP header.
 */
product: Windows$Web$Http$Headers$HttpProductHeaderValue
}


/**
 * Represents the value of the User-Agent HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpProductInfoHeaderValueCollection mixins Array<Windows$Web$Http$Headers$HttpProductInfoHeaderValue> {

/**
 * Adds a new HttpProductInfoHeaderValue item to the end of the collection.
 * @param value The new item to add.
 */
append(value: Windows$Web$Http$Headers$HttpProductInfoHeaderValue): void;

/**
 * Removes all objects from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator to the first HttpProductInfoHeaderValue item in the collection.
 * @return An object that can be used to enumerate the HttpProductInfoHeaderValue items in the collection. The iterator points to the first HttpProductInfoHeaderValue item in the HttpProductInfoHeaderValueCollection .
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Web$Http$Headers$HttpProductInfoHeaderValue>;

/**
 * Returns the HttpProductInfoHeaderValue at the specified index in the collection.
 * @param index The zero-based index of a specified item in the collection.
 * @return The HttpProductInfoHeaderValue at the specified index in the HttpProductInfoHeaderValueCollection .
 */
getAt(index: number): Windows$Web$Http$Headers$HttpProductInfoHeaderValue;

/**
 * Retrieves the HttpProductInfoHeaderValue items that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the HttpProductInfoHeaderValue items in the HttpProductInfoHeaderValueCollection .
 */
getMany(
startIndex: number): {
items: Windows$Web$Http$Headers$HttpProductInfoHeaderValue,
returnValue: number
};

/**
 * Returns an immutable view of the HttpProductInfoHeaderValueCollection .
 * @return The view of the HttpProductInfoHeaderValueCollection .
 */
getView(
): Windows$Foundation$Collections$IVectorView<Windows$Web$Http$Headers$HttpProductInfoHeaderValue>;

/**
 * Determines whether an element is in the collection.
 * @param item The item to find in the collection.
 * @return true if the item was found in the collection; otherwise, false.
 */
indexOf(item: Windows$Web$Http$Headers$HttpProductInfoHeaderValue): boolean;

/**
 * Retrieves the index of an HttpProductInfoHeaderValue in the collection.
 * @param value The HttpProductInfoHeaderValue to find in the HttpProductInfoHeaderValueCollection .
 */
indexOf(
value: Windows$Web$Http$Headers$HttpProductInfoHeaderValue): {
index: number,
returnValue: boolean
};

/**
 * Determines the index of a specific item in the collection.
 * @param item The object to locate in the collection.
 * @return The index of item if found in the collection; otherwise, 1.
 */
indexOf(item: Windows$Web$Http$Headers$HttpProductInfoHeaderValue): number;

/**
 * Inserts an HttpProductInfoHeaderValue into the collection at the specified index.
 * @param index The zero-based index at which value should be inserted.
 * @param value The object to insert into the collection.
 */
insertAt(
index: number,
value: Windows$Web$Http$Headers$HttpProductInfoHeaderValue): void;

/**
 * Parses and adds an entry to the HttpProductInfoHeaderValueCollection .
 * @param input The entry to add.
 */
parseAdd(input: string): void;

/**
 * Removes the entry at the specified index from the HttpMethodHeaderValueCollection.
 * @param index The index of the entry to remove.
 */
removeAt(index: number): void;

/**
 * Removes the element at the specified index of the collection.
 * @param index The zero-based index of the element to remove.
 */
removeAt(index: number): void;

/**
 * Removes the last HttpProductInfoHeaderValue item from the collection.
 */
removeAtEnd(): void;

/**
 * Replaces all the HttpProductInfoHeaderValue items in the collection with the specified HttpProductInfoHeaderValue items.
 * @param items The HttpProductInfoHeaderValue items to add to the collection.
 */
replaceAll(items: Windows$Web$Http$Headers$HttpProductInfoHeaderValue): void;

/**
 * Sets the HttpProductInfoHeaderValue at the specified index in the collection.
 * @param index The zero-based index at which to set the HttpProductInfoHeaderValue .
 * @param value The item to set.
 */
setAt(
index: number,
value: Windows$Web$Http$Headers$HttpProductInfoHeaderValue): void;

/**
 * Gets the number of HttpProductInfoHeaderValue objects in the collection.
 */
size: number;

/**
 * Tries to parse and add the specified item to the HttpProductInfoHeaderValueCollection .
 * @param input The item to parse and add.
 * @return true if the item successfully parsed and was added; otherwise false.
 */
tryParseAdd(input: string): boolean;
indexOf(
value: Windows$Web$Http$Headers$HttpProductInfoHeaderValue,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Web$Http$Headers$HttpProductInfoHeaderValue,
fromIndex?: number): number
}


/**
 * Provides a collection of the HTTP headers associated with an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpRequestHeaderCollection  {

/**
 * Gets the HttpMediaTypeWithQualityHeaderValueCollection of HttpMediaTypeWithQualityHeaderValue objects that represent the value of an Accept HTTP header on an HTTP request.
 */
accept: Windows$Web$Http$Headers$HttpMediaTypeWithQualityHeaderValueCollection;

/**
 * Gets the HttpContentCodingWithQualityHeaderValueCollection of HttpContentCodingWithQualityHeaderValue objects that represent the value of an Accept-Encoding HTTP header on an HTTP request.
 */
acceptEncoding: Windows$Web$Http$Headers$HttpContentCodingWithQualityHeaderValueCollection;

/**
 * Gets the HttpLanguageRangeWithQualityHeaderValueCollection of HttpLanguageRangeWithQualityHeaderValue objects that represent the value of an Accept-Language HTTP header on an HTTP request.
 */
acceptLanguage: Windows$Web$Http$Headers$HttpLanguageRangeWithQualityHeaderValueCollection;

/**
 * Adds a new item to the end of the HttpRequestHeaderCollection .
 * @param name The name of the value to add.
 * @param value The item value to add.
 */
append(name: string, value: string): void;

/**
 * Gets or sets the HttpCredentialsHeaderValue object that represents the value of an Authorization HTTP header on an HTTP request.
 */
authorization: Windows$Web$Http$Headers$HttpCredentialsHeaderValue;

/**
 * Gets the HttpCacheDirectiveHeaderValueCollection that represents the value of a Cache-Control HTTP header on an HTTP request.
 */
cacheControl: Windows$Web$Http$Headers$HttpCacheDirectiveHeaderValueCollection;

/**
 * Removes all objects from the HttpRequestHeaderCollection .
 */
clear(): void;

/**
 * Gets the HttpConnectionOptionHeaderValueCollection of HttpConnectionOptionHeaderValue objects that represent the value of a Connection HTTP header on an HTTP request.
 */
connection: Windows$Web$Http$Headers$HttpConnectionOptionHeaderValueCollection;

/**
 * Gets the HttpCookiePairHeaderValueCollection of HttpCookiePairHeaderValue objects that represent the value of an Cookie HTTP header sent on an HTTP request.
 */
cookie: Windows$Web$Http$Headers$HttpCookiePairHeaderValueCollection;

/**
 * Gets or sets the DateTime object that represents the value of a Date HTTP header on an HTTP request.
 */
date: Date;

/**
 * Gets the HttpExpectationHeaderValueCollection of HttpExpectationHeaderValue objects that represent the value of an Expect HTTP header on an HTTP request.
 */
expect: Windows$Web$Http$Headers$HttpExpectationHeaderValueCollection;

/**
 * Retrieves an iterator to the first item in the HttpRequestHeaderCollection .
 * @return An object that can be used to enumerate the items in the collection. The iterator points to the first item in the HttpRequestHeaderCollection .
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Gets or sets the String that represents the value of a From HTTP header on an HTTP request.
 */
from: string;

/**
 * Returns an immutable view of the HttpRequestHeaderCollection .
 * @return The view of the HttpRequestHeaderCollection .
 */
getView(): Windows$Foundation$Collections$IMapView<string, string>;

/**
 * Determines whether the HttpRequestHeaderCollection contains the specified key.
 * @param key The key associated with the item to locate.
 * @return true if the key is found; otherwise, false.
 */
hasKey(key: string): boolean;

/**
 * Gets or sets the HostName that represents the value of a Host HTTP header on an HTTP request.
 */
host: Windows$Networking$HostName;

/**
 * Gets or sets the DateTime object that represents the value of an If-Modified-Since HTTP header on an HTTP request.
 */
ifModifiedSince: Date;

/**
 * Gets or sets the DateTime object that represents the value of an If-Unmodified-Since HTTP header on an HTTP request.
 */
ifUnmodifiedSince: Date;

/**
 * Inserts or replaces an item in the HttpRequestHeaderCollection with the specified key and value.
 * @param key The key of the item to be inserted.
 * @param value The value of the item to insert.
 * @return true if an item with the specified key is an existing item that was replaced; otherwise false.
 */
insert(key: string, value: string): boolean;

/**
 * Finds an item in the HttpRequestHeaderCollection if it exists.
 * @param key The key of the item to lookup.
 * @return The value of the item if found.
 */
lookup(key: string): string;

/**
 * Gets or sets an integer value that represents the value of a Max-Forwards HTTP header on an HTTP request.
 */
maxForwards: number;

/**
 * Gets or sets the HttpCredentialsHeaderValue object that represent the value of a Proxy-Authorization HTTP header on an HTTP request.
 */
proxyAuthorization: Windows$Web$Http$Headers$HttpCredentialsHeaderValue;

/**
 * Gets or sets the Uri that represents the value of a Referer HTTP header on an HTTP request.
 */
referer: Windows$Foundation$Uri;

/**
 * Removes a specific object from the HttpRequestHeaderCollection .
 * @param key The key of the item to remove.
 */
remove(key: string): void;

/**
 * Removes a specific item from the HttpRequestHeaderCollection .
 * @param key The key of the item to remove.
 * @return true if the item was removed, otherwise false.
 */
remove(key: string): boolean;

/**
 * Gets the number of objects in the HttpRequestHeaderCollection .
 */
size: number;

/**
 * Gets the HttpTransferCodingHeaderValueCollection of HttpTransferCodingHeaderValue objects that represent the value of a Transfer-Encoding HTTP header on an HTTP request.
 */
transferEncoding: Windows$Web$Http$Headers$HttpTransferCodingHeaderValueCollection;

/**
 * Try to append the specified item to the HttpRequestHeaderCollection without validation.
 * @param name The name of the item to append.
 * @param value The value of the item to append.
 * @return true if the item was appended; otherwise false.
 */
tryAppendWithoutValidation(name: string, value: string): boolean;

/**
 * Gets the HttpProductInfoHeaderValueCollection of HttpProductInfoHeaderValue objects that represent the value of a User-Agent HTTP header on an HTTP request.
 */
userAgent: Windows$Web$Http$Headers$HttpProductInfoHeaderValueCollection
}


/**
 * Provides a collection of the HTTP headers associated with an HTTP response.
 */
declare class Windows$Web$Http$Headers$HttpResponseHeaderCollection  {

/**
 * Gets or sets the TimeSpan object that represents the value of an Age HTTP header on an HTTP response.
 */
age: number;

/**
 * Gets the HttpMethodHeaderValueCollection of HttpMethod objects that represent the value of an Allow HTTP header on an HTTP response.
 */
allow: Windows$Web$Http$Headers$HttpMethodHeaderValueCollection;

/**
 * Adds a new item to the end of the HttpResponseHeaderCollection .
 * @param name The name of the value to add.
 * @param value The item value to add.
 */
append(name: string, value: string): void;

/**
 * Gets the HttpCacheDirectiveHeaderValueCollection of objects that represent the value of a Cache-Control HTTP header on an HTTP response.
 */
cacheControl: Windows$Web$Http$Headers$HttpCacheDirectiveHeaderValueCollection;

/**
 * Removes all objects from the collection.
 */
clear(): void;

/**
 * Gets the HttpConnectionOptionHeaderValueCollection of HttpConnectionOptionHeaderValue objects that represent the value of a Connection HTTP header on an HTTP response.
 */
connection: Windows$Web$Http$Headers$HttpConnectionOptionHeaderValueCollection;

/**
 * Gets or sets the DateTime object that represents the value of a Date HTTP header on an HTTP response.
 */
date: Date;

/**
 * Retrieves an iterator to the first item in the HttpResponseHeaderCollection .
 * @return An object that can be used to enumerate the items in the collection. The iterator points to the first item in the HttpResponseHeaderCollection .
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Foundation$Collections$IKeyValuePair<any, any>>;

/**
 * Returns an immutable view of the HttpResponseHeaderCollection .
 * @return The view of the HttpResponseHeaderCollection .
 */
getView(): Windows$Foundation$Collections$IMapView<string, string>;

/**
 * Determines whether the HttpResponseHeaderCollection contains the specified key.
 * @param key The key associated with the item to locate.
 * @return true if the key is found; otherwise, false.
 */
hasKey(key: string): boolean;

/**
 * Inserts or replaces an item in the HttpResponseHeaderCollection with the specified key and value.
 * @param key The key of the item to be inserted.
 * @param value The value of the item to insert.
 * @return true if an item with the specified key is an existing item that was replaced; otherwise false.
 */
insert(key: string, value: string): boolean;

/**
 * Gets or sets the Uri that represents the value or a Location HTTP header on an HTTP response.
 */
location: Windows$Foundation$Uri;

/**
 * Lookup an item in the HttpResponseHeaderCollection .
 * @param key The key of the item to lookup.
 * @return The value of the item if found.
 */
lookup(key: string): string;

/**
 * Gets the HttpChallengeHeaderValueCollection of HttpChallengeHeaderValue objects that represent the value of a Proxy-Authenticate HTTP header on an HTTP response.
 */
proxyAuthenticate: Windows$Web$Http$Headers$HttpChallengeHeaderValueCollection;

/**
 * Removes an item with a given key from the HttpResponseHeaderCollection .
 * @param key Key of the item to be removed.
 */
remove(key: string): void;

/**
 * Gets or sets the HttpDateOrDeltaHeaderValue object that represent the value of a Retry-After HTTP header on an HTTP response.
 */
retryAfter: Windows$Web$Http$Headers$HttpDateOrDeltaHeaderValue;

/**
 * Gets the number of objects in the HttpResponseHeaderCollection .
 */
size: number;

/**
 * Gets the HttpTransferCodingHeaderValueCollection of HttpTransferCodingHeaderValue objects that represent the value of a Transfer-Encoding HTTP header on an HTTP response.
 */
transferEncoding: Windows$Web$Http$Headers$HttpTransferCodingHeaderValueCollection;

/**
 * Try to append the specified item to the HttpResponseHeaderCollection without validation.
 * @param name The name of the item to append.
 * @param value The value of the item to append.
 * @return true if the item was appended; otherwise false.
 */
tryAppendWithoutValidation(name: string, value: string): boolean;

/**
 * Gets the HttpChallengeHeaderValueCollection of HttpChallengeHeaderValue objects that represent the value of a WWW-Authenticate HTTP header on an HTTP response.
 */
wwwAuthenticate: Windows$Web$Http$Headers$HttpChallengeHeaderValueCollection
}


/**
 * Represents transfer coding information used in the Transfer-Encoding HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpTransferCodingHeaderValue  {

/**
 * Converts a string to an HttpTransferCodingHeaderValue instance.
 * @param input A string that represents the transfer-coding information.
 * @return An HttpProductInfoHeaderValue instance.
 */
static parse(input: string): Windows$Web$Http$Headers$HttpTransferCodingHeaderValue;

/**
 * Determines whether a string is valid HttpTransferCodingHeaderValue information.
 * @param input The string to validate.
 */
static tryParse(
input: string): {
transferCodingHeaderValue: Windows$Web$Http$Headers$HttpTransferCodingHeaderValue,
returnValue: boolean
};

/**
 * Initializes a new instance of the HttpProductInfoHeaderValue class.
 * @param input The transfer-coding information to initialize the HttpProductInfoHeaderValue object.
 */
constructor(input: string): this;

/**
 * Gets a set of parameters used in the Transfer-Encoding HTTP header.
 */
parameters: Windows$Foundation$Collections$IVector<Windows$Web$Http$Headers$HttpNameValueHeaderValue>;

/**
 * Gets the transfer-coding value used in the Transfer-Encoding HTTP header.
 */
value: string
}


/**
 * Represents the value of the Transfer-Encoding HTTP header on an HTTP request.
 */
declare class Windows$Web$Http$Headers$HttpTransferCodingHeaderValueCollection mixins Array<Windows$Web$Http$Headers$HttpTransferCodingHeaderValue> {

/**
 * Adds a new HttpTransferCodingHeaderValue item to the end of the collection.
 * @param value The new item to add.
 */
append(value: Windows$Web$Http$Headers$HttpTransferCodingHeaderValue): void;

/**
 * Removes all objects from the collection.
 */
clear(): void;

/**
 * Retrieves an iterator to the first HttpTransferCodingHeaderValue item in the collection.
 * @return An object that can be used to enumerate the HttpTransferCodingHeaderValue items in the collection. The iterator points to the first HttpTransferCodingHeaderValue item in the HttpTransferCodingHeaderValueCollection .
 */
first(
): Windows$Foundation$Collections$IIterator<Windows$Web$Http$Headers$HttpTransferCodingHeaderValue>;

/**
 * Returns the HttpTransferCodingHeaderValue at the specified index in the collection.
 * @param index The zero-based index of a specified item in the collection.
 * @return The HttpTransferCodingHeaderValue at the specified index in the HttpTransferCodingHeaderValueCollection .
 */
getAt(index: number): Windows$Web$Http$Headers$HttpTransferCodingHeaderValue;

/**
 * Retrieves the HttpTransferCodingHeaderValue items that start at the specified index in the collection.
 * @param startIndex The zero-based index of the start of the HttpTransferCodingHeaderValue items in the HttpTransferCodingHeaderValueCollection .
 */
getMany(
startIndex: number): {
items: Windows$Web$Http$Headers$HttpTransferCodingHeaderValue,
returnValue: number
};

/**
 * Returns an immutable view of the HttpTransferCodingHeaderValueCollection .
 * @return The view of the HttpTransferCodingHeaderValueCollection .
 */
getView(
): Windows$Foundation$Collections$IVectorView<Windows$Web$Http$Headers$HttpTransferCodingHeaderValue>;

/**
 * Determines the index of a specific item in the collection.
 * @param item The object to locate in the collection.
 * @return The index of item if found in the collection; otherwise, 1.
 */
indexOf(item: Windows$Web$Http$Headers$HttpTransferCodingHeaderValue): number;

/**
 * Determines whether an element is in the collection.
 * @param item The item to find in the collection.
 * @return true if the item was found in the collection; otherwise, false.
 */
indexOf(item: Windows$Web$Http$Headers$HttpTransferCodingHeaderValue): boolean;

/**
 * Retrieves the index of an HttpTransferCodingHeaderValue in the collection.
 * @param value The HttpTransferCodingHeaderValue to find in the HttpTransferCodingHeaderValueCollection .
 */
indexOf(
value: Windows$Web$Http$Headers$HttpTransferCodingHeaderValue): {
index: number,
returnValue: boolean
};

/**
 * Inserts an HttpTransferCodingHeaderValue into the collection at the specified index.
 * @param index The zero-based index at which value should be inserted.
 * @param value The object to insert into the collection.
 */
insertAt(
index: number,
value: Windows$Web$Http$Headers$HttpTransferCodingHeaderValue): void;

/**
 * Parses and adds an entry to the HttpTransferCodingHeaderValueCollection .
 * @param input The entry to add.
 */
parseAdd(input: string): void;

/**
 * Removes the entry at the specified index from the HttpTransferCodingHeaderValueCollection .
 * @param index The index of the entry to remove.
 */
removeAt(index: number): void;

/**
 * Removes the element at the specified index of the collection.
 * @param index The zero-based index of the element to remove.
 */
removeAt(index: number): void;

/**
 * Removes the last HttpTransferCodingHeaderValue item from the collection.
 */
removeAtEnd(): void;

/**
 * Replaces all the HttpTransferCodingHeaderValue items in the collection with the specified HttpTransferCodingHeaderValue items.
 * @param items The HttpTransferCodingHeaderValue items to add to the collection.
 */
replaceAll(items: Windows$Web$Http$Headers$HttpTransferCodingHeaderValue): void;

/**
 * Sets the HttpTransferCodingHeaderValue at the specified index in the collection.
 * @param index The zero-based index at which to set the HttpTransferCodingHeaderValue .
 * @param value The item to set.
 */
setAt(
index: number,
value: Windows$Web$Http$Headers$HttpTransferCodingHeaderValue): void;

/**
 * Gets the number of HttpTransferCodingHeaderValue objects in the collection.
 */
size: number;

/**
 * Tries to parse and add the specified item to the HttpTransferCodingHeaderValueCollection .
 * @param input The item to parse and add.
 * @return true if the item successfully parsed and was added; otherwise false.
 */
tryParseAdd(input: string): boolean;
indexOf(
value: Windows$Web$Http$Headers$HttpTransferCodingHeaderValue,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(
searchElement: Windows$Web$Http$Headers$HttpTransferCodingHeaderValue,
fromIndex?: number): number
}


/**
 * Provides HTTP content that uses a buffer.
 */
declare class Windows$Web$Http$HttpBufferContent  {

/**
 * Initializes a new instance of the HttpBufferContent class with the specified buffer.
 * @param content The content used to initialize the HttpBufferContent .
 */
constructor(content: Windows$Storage$Streams$IBuffer): this;

/**
 * Initializes a new instance of the HttpBufferContent class with an offset and count of bytes from the specified buffer.
 * @param content The content used to initialize the HttpBufferContent .
 * @param offset The offset in bytes from the beginning of the content buffer to initialize the HttpBufferContent .
 * @param count The count of bytes in the content buffer to initialize the HttpBufferContent .
 */
constructor(content: Windows$Storage$Streams$IBuffer, offset: number, count: number): this;

/**
 * Serialize the HttpBufferContent into memory as an asynchronous operation.
 * @return The object that represents the asynchronous operation.
 */
bufferAllAsync(): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>;

/**
 * Closes the HttpBufferContent instance and releases allocated resources.
 */
close(): void;

/**
 * Get a collection of content headers set on the HttpBufferContent .
 */
headers: Windows$Web$Http$Headers$HttpContentHeaderCollection;

/**
 * Serialize the HttpBufferContent to a buffer as an asynchronous operation.
 * @return The object that represents the asynchronous operation.
 */
readAsBufferAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>;

/**
 * Serialize the HttpBufferContent and return an input stream that represents the content as an asynchronous operation.
 * @return The object that represents the asynchronous operation.
 */
readAsInputStreamAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IInputStream, number>;

/**
 * Serialize the HttpBufferContent to a String as an asynchronous operation.
 * @return The object that represents the asynchronous operation.
 */
readAsStringAsync(): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<string, number>;

/**
 * Computes the HttpBufferContent length in bytes.
 */
tryComputeLength(): {
length: number,
returnValue: boolean
};

/**
 * Write the HttpBufferContent to an output stream as an asynchronous operation.
 * @param outputStream The output stream to write to.
 * @return The object that represents the asynchronous operation.
 */
writeToStreamAsync(
outputStream: Windows$Storage$Streams$IOutputStream): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Sends HTTP requests and receives HTTP responses from a resource identified by a URI.
 */
declare class Windows$Web$Http$HttpClient  {

/**
 * Initializes a new instance of the HttpClient class.
 */
constructor(): this;

/**
 * Initializes a new instance of the HttpClient class with a specific filter for handling HTTP response messages.
 * @param filter The HTTP filter to use for handling response messages.
 */
constructor(filter: Windows$Web$Http$Filters$IHttpFilter): this;

/**
 * Closes the HttpClient instance and releases allocated resources.
 */
close(): void;

/**
 * Gets a collection of headers that should be sent with each request.
 */
defaultRequestHeaders: Windows$Web$Http$Headers$HttpRequestHeaderCollection;

/**
 * Send a DELETE request to the specified Uri as an asynchronous operation.
 * @param uri The Uri the request is sent to.
 * @return The object representing the asynchronous operation.
 */
deleteAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Web$Http$HttpResponseMessage, Windows$Web$Http$HttpProgress>;

/**
 * Send a GET request to the specified Uri with an HTTP completion option as an asynchronous operation.
 * @param uri The Uri the request is sent to.
 * @param completionOption An HTTP completion option value that indicates when the operation should be considered completed.
 * @return The object representing the asynchronous operation.
 */
getAsync(
uri: Windows$Foundation$Uri,
completionOption: $Values<typeof Windows$Web$Http$HttpCompletionOption>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Web$Http$HttpResponseMessage, Windows$Web$Http$HttpProgress>;

/**
 * Send a GET request to the specified Uri as an asynchronous operation.
 * @param uri The Uri to which the request is to be sent.
 * @return The object representing the asynchronous operation.
 */
getAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Web$Http$HttpResponseMessage, Windows$Web$Http$HttpProgress>;

/**
 * Send a GET request to the specified Uri and return the response body as a buffer in an asynchronous operation.
 * @param uri The Uri the request is sent to.
 * @return The object representing the asynchronous operation.
 */
getBufferAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, Windows$Web$Http$HttpProgress>;

/**
 * Send a GET request to the specified Uri and return the response body as a stream in an asynchronous operation.
 * @param uri The Uri the request is sent to.
 * @return The object representing the asynchronous operation.
 */
getInputStreamAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IInputStream, Windows$Web$Http$HttpProgress>;

/**
 * Send a GET request to the specified Uri and return the response body as a string in an asynchronous operation.
 * @param uri The Uri the request is sent to.
 * @return The object representing the asynchronous operation.
 */
getStringAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<string, Windows$Web$Http$HttpProgress>;

/**
 * Send a POST request to the specified Uri as an asynchronous operation.
 * @param uri The Uri the request is sent to.
 * @param content The HTTP request content to send to the server.
 * @return The object representing the asynchronous operation.
 */
postAsync(
uri: Windows$Foundation$Uri,
content: Windows$Web$Http$IHttpContent): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Web$Http$HttpResponseMessage, Windows$Web$Http$HttpProgress>;

/**
 * Send a PUT request to the specified Uri as an asynchronous operation.
 * @param uri The Uri the request is sent to.
 * @param content The HTTP request content to send to the server.
 * @return The object representing the asynchronous operation.
 */
putAsync(
uri: Windows$Foundation$Uri,
content: Windows$Web$Http$IHttpContent): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Web$Http$HttpResponseMessage, Windows$Web$Http$HttpProgress>;

/**
 * Send an HTTP request with an HTTP completion option as an asynchronous operation.
 * @param request The HTTP request message to send.
 * @param completionOption A value that indicates whether the HttpClient operation is considered completed when all of the response is read, or when just the headers are read.
 * @return The object representing the asynchronous operation.
 */
sendRequestAsync(
request: Windows$Web$Http$HttpRequestMessage,
completionOption: $Values<typeof Windows$Web$Http$HttpCompletionOption>): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Web$Http$HttpResponseMessage, Windows$Web$Http$HttpProgress>;

/**
 * Send an HTTP request as an asynchronous operation.
 * @param request The HTTP request message to send.
 * @return The object representing the asynchronous operation.
 */
sendRequestAsync(
request: Windows$Web$Http$HttpRequestMessage): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Web$Http$HttpResponseMessage, Windows$Web$Http$HttpProgress>
}


/**
 * Indicates whether asynchronous HttpClient operations are considered completed when all of the response is read, or when just the headers are read.
 */

declare  var Windows$Web$Http$HttpCompletionOption: {|
  +responseContentRead: 0,// 0
+responseHeadersRead: 1,// 1

|};



/**
 * Provides a set of properties and methods to manage an HTTP cookie.
 */
declare class Windows$Web$Http$HttpCookie  {

/**
 * Initializes a new instance of the HttpCookie class with a specified name, domain, and path.
 * @param name The name for the HttpCookie
 * @param domain The domain for which the HttpCookie is valid.
 * @param path The URIs to which the HttpCookie applies.
 */
constructor(name: string, domain: string, path: string): this;

/**
 * Get the domain for which the HttpCookie is valid.
 */
domain: string;

/**
 * Get or set the expiration date and time for the HttpCookie .
 */
expires: Date;

/**
 * Get or set a value that controls whether a script or other active content can access this HttpCookie .
 */
httpOnly: boolean;

/**
 * Get the token that represents the HttpCookie name.
 */
name: string;

/**
 * Get the URI path component to which the HttpCookie applies.
 */
path: string;

/**
 * Get or set the security level for the HttpCookie .
 */
secure: boolean;

/**
 * Get or set the value for the HttpCookie .
 */
value: string
}


/**
 * Provides a collection container for instances of the HttpCookie class.
 */
declare class Windows$Web$Http$HttpCookieCollection mixins Array<Windows$Web$Http$HttpCookie> {

/**
 * Retrieves an iterator to the first HttpCookie item in the HttpCookieCollection .
 * @return An iterator to the first HttpCookie item in the HttpCookieCollection .
 */
first(): Windows$Foundation$Collections$IIterator<Windows$Web$Http$HttpCookie>;

/**
 * Returns the HttpCookie at the specified index from the HttpCookieCollection .
 * @param index The zero-based index of a specified item in the HttpCookieCollection .
 * @return The HTTP cookie at the specified index from the HttpCookieCollection .
 */
getAt(index: number): Windows$Web$Http$HttpCookie;

/**
 * Retrieves the HttpCookie items that start at the specified index in the HttpCookieCollection .
 * @param startIndex The zero-based index of the start of the HttpCookie items in the HttpCookieCollection .
 */
getMany(
startIndex: number): {
items: Windows$Web$Http$HttpCookie,
returnValue: number
};

/**
 * Retrieves the index of an HttpCookie in the HttpCookieCollection .
 * @param value The HttpCookie to find in the HttpCookieCollection .
 */
indexOf(value: Windows$Web$Http$HttpCookie): {
index: number,
returnValue: boolean
};

/**
 * Gets the number of cookies in the HttpCookieCollection .
 */
size: number;
indexOf(
value: Windows$Web$Http$HttpCookie,
...extra: any[]): {
index: number,
returnValue: boolean
};
indexOf(searchElement: Windows$Web$Http$HttpCookie, fromIndex?: number): number
}


/**
 * Add or delete an HttpCookie or view the cookies associated with an app.
 */
declare class Windows$Web$Http$HttpCookieManager  {

/**
 * Delete an HttpCookie from the cookies associated with an app.
 * @param cookie The HttpCookie to delete.
 */
deleteCookie(cookie: Windows$Web$Http$HttpCookie): void;

/**
 * Gets an HttpCookieCollection that contains the HttpCookie instances that are associated with a specific URI.
 * @param uri The URI of the HttpCookie instances desired.
 * @return The HttpCookieCollection that contains the HttpCookie instances that are associated with a specific URI.
 */
getCookies(uri: Windows$Foundation$Uri): Windows$Web$Http$HttpCookieCollection;

/**
 * Add or change an HttpCookie in the cookies associated with an app.
 * @param cookie The HttpCookie to change or add.
 * @param thirdParty A value that indicates whether the HttpCookie is a third party HTTP cookie.
 * @return true if the HttpCookie replaced an existing cookie; otherwise false.
 */
setCookie(cookie: Windows$Web$Http$HttpCookie, thirdParty: boolean): boolean;

/**
 * Add or change an HttpCookie in the cookies associated with an app that is sent on future requests.
 * @param cookie The HttpCookie to change or add.
 * @return true if the HttpCookie replaced an existing cookie; otherwise false.
 */
setCookie(cookie: Windows$Web$Http$HttpCookie): boolean
}


/**
 * Provides HTTP content that uses name/value data encoded with the application/x-www-form-urlencoded MIME type.
 */
declare class Windows$Web$Http$HttpFormUrlEncodedContent  {

/**
 * Initializes a new instance of the HttpFormUrlEncodedContent class with the specified content.
 * @param content The content used to initialize the HttpFormUrlEncodedContent .
 */
constructor(content: Windows$Foundation$Collections$IIterable<Windows$Foundation$Collections$IKeyValuePair<any, any>>): this;

/**
 * Serialize the HttpFormUrlEncodedContent into memory as an asynchronous operation.
 * @return The object that represents the asynchronous operation.
 */
bufferAllAsync(): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>;

/**
 * Closes the HttpFormUrlEncodedContent instance and releases allocated resources.
 */
close(): void;

/**
 * Get a collection of content headers set on the HttpFormUrlEncodedContent .
 */
headers: Windows$Web$Http$Headers$HttpContentHeaderCollection;

/**
 * Serialize the HttpFormUrlEncodedContent to a buffer as an asynchronous operation.
 * @return The object representing the asynchronous operation.
 */
readAsBufferAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>;

/**
 * Serialize the HttpFormUrlEncodedContent and return an input stream that represents the content as an asynchronous operation.
 * @return The object representing the asynchronous operation.
 */
readAsInputStreamAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IInputStream, number>;

/**
 * Serialize the HttpFormUrlEncodedContent to a String as an asynchronous operation.
 * @return The object representing the asynchronous operation.
 */
readAsStringAsync(): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<string, number>;

/**
 * Computes the HttpFormUrlEncodedContent length in bytes.
 */
tryComputeLength(): {
length: number,
returnValue: boolean
};

/**
 * Write the HttpFormUrlEncodedContent to an output stream as an asynchronous operation.
 * @param outputStream The output stream to write to.
 * @return The object that represents the asynchronous operation.
 */
writeToStreamAsync(
outputStream: Windows$Storage$Streams$IOutputStream): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Retrieves standard HTTP methods such as GET and POST and creates new HTTP methods.
 */
declare class Windows$Web$Http$HttpMethod  {

/**
 * Gets the HTTP DELETE method.
 */
static delete: Windows$Web$Http$HttpMethod;

/**
 * Gets the HTTP GET method.
 */
static get: Windows$Web$Http$HttpMethod;

/**
 * Gets the HTTP HEAD method.
 */
static head: Windows$Web$Http$HttpMethod;

/**
 * Gets the HTTP OPTIONS method.
 */
static options: Windows$Web$Http$HttpMethod;

/**
 * Gets the HTTP PATCH method,
 */
static patch: Windows$Web$Http$HttpMethod;

/**
 * Gets the HTTP POST method.
 */
static post: Windows$Web$Http$HttpMethod;

/**
 * Gets the HTTP PUT method.
 */
static put: Windows$Web$Http$HttpMethod;

/**
 * Initializes a new instance of the HttpMethod class with a specific HTTP method.
 * @param method The HTTP method.
 */
constructor(method: string): this;

/**
 * Gets the HTTP method.
 */
method: string
}


/**
 * Provides HTTP content that uses the multipart/* MIME type.
 */
declare class Windows$Web$Http$HttpMultipartContent  {

/**
 * Initializes a new instance of the HttpMultipartContent class.
 */
constructor(): this;

/**
 * Initializes a new instance of the HttpMultipartContent class with the specified MIME subtype and boundary string.
 * @param subtype The MIME subtype of the multipart content.
 * @param boundary The boundary string for the multipart content.
 */
constructor(subtype: string, boundary: string): this;

/**
 * Initializes a new instance of the HttpMultipartContent class with the specified MIME subtype.
 * @param subtype The MIME subtype of the multipart content.
 */
constructor(subtype: string): this;

/**
 * Add HTTP content to the HttpMultipartContent instance.
 * @param content The HTTP content to add to HttpMultipartContent .
 */
add(content: Windows$Web$Http$IHttpContent): void;

/**
 * Serialize the HttpMultipartContent into memory as an asynchronous operation.
 * @return The object that represents the asynchronous operation.
 */
bufferAllAsync(): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>;

/**
 * Closes the HttpMultipartContent instance and releases allocated resources.
 */
close(): void;

/**
 * Gets an object that can be used to enumerate the contents in the HttpMultipartContent object.
 * @return An object that can be used to enumerate the contents in the HttpMultipartContent object.
 */
first(): Windows$Foundation$Collections$IIterator<Windows$Web$Http$IHttpContent>;

/**
 * Get a collection of content headers set on the HttpMultipartContent .
 */
headers: Windows$Web$Http$Headers$HttpContentHeaderCollection;

/**
 * Serialize the HttpMultipartContent to a buffer as an asynchronous operation.
 * @return The object representing the asynchronous operation.
 */
readAsBufferAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>;

/**
 * Serialize the HttpMultipartContent and return an input stream that represents the content as an asynchronous operation.
 * @return The object representing the asynchronous operation.
 */
readAsInputStreamAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IInputStream, number>;

/**
 * Serialize the HttpMultipartContent to a String as an asynchronous operation.
 * @return The object representing the asynchronous operation.
 */
readAsStringAsync(): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<string, number>;

/**
 * Determines whether the HttpMultipartContent has a valid length in bytes.
 */
tryComputeLength(): {
length: number,
returnValue: boolean
};

/**
 * Write the HttpMultipartContent to an output stream as an asynchronous operation.
 * @param outputStream The output stream to write to.
 * @return The object that represents the asynchronous operation.
 */
writeToStreamAsync(
outputStream: Windows$Storage$Streams$IOutputStream): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Provides HTTP content that uses the multipart/form-data MIME type.
 */
declare class Windows$Web$Http$HttpMultipartFormDataContent  {

/**
 * Initializes a new instance of the HttpMultipartFormDataContent class.
 */
constructor(): this;

/**
 * Initializes a new instance of the HttpMultipartFormDataContent class with the specified boundary string.
 * @param boundary The boundary string for the multipart content.
 */
constructor(boundary: string): this;

/**
 * Add HTTP content with a specified name from a file to the HttpMultipartFormDataContent instance.
 * @param content The HTTP content to add to HttpMultipartFormDataContent .
 * @param name The name for the HTTP content to add to HttpMultipartFormDataContent .
 * @param fileName The file name for the HTTP content to add to HttpMultipartFormDataContent .
 */
add(content: Windows$Web$Http$IHttpContent, name: string, fileName: string): void;

/**
 * Add HTTP content to the HttpMultipartFormDataContent instance.
 * @param content The HTTP content to add to HttpMultipartFormDataContent .
 */
add(content: Windows$Web$Http$IHttpContent): void;

/**
 * Add HTTP content with a specified name to the HttpMultipartFormDataContent instance.
 * @param content The HTTP content to add to HttpMultipartFormDataContent .
 * @param name The name for the HTTP content to add to HttpMultipartFormDataContent .
 */
add(content: Windows$Web$Http$IHttpContent, name: string): void;

/**
 * Serialize the HttpMultipartFormDataContent into memory as an asynchronous operation.
 * @return The object that represents the asynchronous operation.
 */
bufferAllAsync(): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>;

/**
 * Closes the HttpMultipartFormDataContent instance and releases allocated resources.
 */
close(): void;

/**
 * Gets an object that can be used to enumerate the contents in the HttpMultipartFormDataContent object.
 * @return An object that can be used to enumerate the contents in the HttpMultipartFormDataContent object.
 */
first(): Windows$Foundation$Collections$IIterator<Windows$Web$Http$IHttpContent>;

/**
 * Get a collection of content headers set on the HttpMultipartFormDataContent .
 */
headers: Windows$Web$Http$Headers$HttpContentHeaderCollection;

/**
 * Serialize the HttpMultipartFormDataContent to a buffer as an asynchronous operation.
 * @return The object representing the asynchronous operation.
 */
readAsBufferAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>;

/**
 * Serialize the HttpMultipartFormDataContent and return an input stream that represents the content as an asynchronous operation.
 * @return The object representing the asynchronous operation.
 */
readAsInputStreamAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IInputStream, number>;

/**
 * Serialize the HttpMultipartFormDataContent to a String as an asynchronous operation.
 * @return The object representing the asynchronous operation.
 */
readAsStringAsync(): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<string, number>;

/**
 * Determines whether the HttpMultipartFormDataContent has a valid length in bytes.
 */
tryComputeLength(): {
length: number,
returnValue: boolean
};

/**
 * Write the HttpMultipartFormDataContent to an output stream as an asynchronous operation.
 * @param outputStream The output stream to write to.
 * @return The object that represents the asynchronous operation.
 */
writeToStreamAsync(
outputStream: Windows$Storage$Streams$IOutputStream): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Indicates the step in the progress for an HTTP connection.
 */

declare  var Windows$Web$Http$HttpProgressStage: {|
  +none: 0,// 0
+detectingProxy: 1,// 1
+resolvingName: 2,// 2
+connectingToServer: 3,// 3
+negotiatingSsl: 4,// 4
+sendingHeaders: 5,// 5
+sendingContent: 6,// 6
+waitingForResponse: 7,// 7
+receivingHeaders: 8,// 8
+receivingContent: 9,// 9

|};



/**
 * Represents an HTTP request message including headers.
 */
declare class Windows$Web$Http$HttpRequestMessage  {

/**
 * Initializes a new instance of the HttpRequestMessage class.
 */
constructor(): this;

/**
 * Initializes a new instance of the HttpRequestMessage class with an HTTP method and a request Uri .
 * @param method The HTTP method to perform
 * @param uri The Uri to request.
 */
constructor(method: Windows$Web$Http$HttpMethod, uri: Windows$Foundation$Uri): this;

/**
 * Closes the HttpRequestMessage instance and releases allocated resources.
 */
close(): void;

/**
 * Gets or sets the HTTP content to send to the server on the HttpRequestMessage object.
 */
content: Windows$Web$Http$IHttpContent;

/**
 * Gets the collection of the HTTP request headers associated with the HttpRequestMessage .
 */
headers: Windows$Web$Http$Headers$HttpRequestHeaderCollection;

/**
 * Gets or sets the HTTP method to be performed on the request URI.
 */
method: Windows$Web$Http$HttpMethod;

/**
 * Gets a set of properties on the HttpRequestMessage instance that are for use by the developer.
 */
properties: Windows$Foundation$Collections$IMap<string, any>;

/**
 * Gets or sets the Uri used for the HttpRequestMessage object.
 */
requestUri: Windows$Foundation$Uri;

/**
 * Get information about the underlying transport socket used by an HTTP connection.
 */
transportInformation: Windows$Web$Http$HttpTransportInformation
}


/**
 * Represents an HTTP response message including headers, the status code, and data.
 */
declare class Windows$Web$Http$HttpResponseMessage  {

/**
 * Initializes a new instance of the HttpResponseMessage class with a specific HttpStatusCode .
 * @param statusCode The status code of the HTTP response.
 */
constructor(statusCode: $Values<typeof Windows$Web$Http$HttpStatusCode>): this;

/**
 * Initializes a new instance of the HttpResponseMessage class.
 */
constructor(): this;

/**
 * Closes the HttpResponseMessage instance and releases allocated resources.
 */
close(): void;

/**
 * Gets or sets the content of the HTTP response message on the HttpResponseMessage object.
 */
content: Windows$Web$Http$IHttpContent;

/**
 * Throws an exception if the IsSuccessStatusCode property for the HTTP response is false.
 * @return The HTTP response if the request was successful.
 */
ensureSuccessStatusCode(): Windows$Web$Http$HttpResponseMessage;

/**
 * Gets the collection of HTTP response headers associated with the HttpResponseMessage that were sent by the server.
 */
headers: Windows$Web$Http$Headers$HttpResponseHeaderCollection;

/**
 * Gets a value that indicates whether the HTTP response was successful.
 */
isSuccessStatusCode: boolean;

/**
 * Gets or sets the reason phrase which typically is sent by servers together with the status code.
 */
reasonPhrase: string;

/**
 * Gets or sets the request message which led to this response message.
 */
requestMessage: Windows$Web$Http$HttpRequestMessage;

/**
 * Gets the source of the data received in the HttpResponseMessage .
 */
source: $Values<typeof Windows$Web$Http$HttpResponseMessageSource>;

/**
 * Gets or sets the status code of the HTTP response.
 */
statusCode: $Values<typeof Windows$Web$Http$HttpStatusCode>;

/**
 * Gets or sets the HTTP protocol version used on the HttpResponseMessage object.
 */
version: $Values<typeof Windows$Web$Http$HttpVersion>
}


/**
 * Indicates the source of the data received in the HttpResponseMessage .
 */

declare  var Windows$Web$Http$HttpResponseMessageSource: {|
  +none: 0,// 0
+cache: 1,// 1
+network: 2,// 2

|};



/**
 * Contains the values of status codes defined for HTTP in the response to an HTTP request.
 */

declare  var Windows$Web$Http$HttpStatusCode: {|
  +none: 0,// 0
+continue: 1,// 1
+switchingProtocols: 2,// 2
+processing: 3,// 3
+ok: 4,// 4
+created: 5,// 5
+accepted: 6,// 6
+nonAuthoritativeInformation: 7,// 7
+noContent: 8,// 8
+resetContent: 9,// 9
+partialContent: 10,// 10
+multiStatus: 11,// 11
+alreadyReported: 12,// 12
+imUsed: 13,// 13
+multipleChoices: 14,// 14
+movedPermanently: 15,// 15
+found: 16,// 16
+seeOther: 17,// 17
+notModified: 18,// 18
+useProxy: 19,// 19
+temporaryRedirect: 20,// 20
+permanentRedirect: 21,// 21
+badRequest: 22,// 22
+unauthorized: 23,// 23
+paymentRequired: 24,// 24
+forbidden: 25,// 25
+notFound: 26,// 26
+methodNotAllowed: 27,// 27
+notAcceptable: 28,// 28
+proxyAuthenticationRequired: 29,// 29
+requestTimeout: 30,// 30
+conflict: 31,// 31
+gone: 32,// 32
+lengthRequired: 33,// 33
+preconditionFailed: 34,// 34
+requestEntityTooLarge: 35,// 35
+requestUriTooLong: 36,// 36
+unsupportedMediaType: 37,// 37
+requestedRangeNotSatisfiable: 38,// 38
+expectationFailed: 39,// 39
+unprocessableEntity: 40,// 40
+locked: 41,// 41
+failedDependency: 42,// 42
+upgradeRequired: 43,// 43
+preconditionRequired: 44,// 44
+tooManyRequests: 45,// 45
+requestHeaderFieldsTooLarge: 46,// 46
+internalServerError: 47,// 47
+notImplemented: 48,// 48
+badGateway: 49,// 49
+serviceUnavailable: 50,// 50
+gatewayTimeout: 51,// 51
+httpVersionNotSupported: 52,// 52
+variantAlsoNegotiates: 53,// 53
+insufficientStorage: 54,// 54
+loopDetected: 55,// 55
+notExtended: 56,// 56
+networkAuthenticationRequired: 57,// 57

|};



/**
 * Provides HTTP content that uses a stream.
 */
declare class Windows$Web$Http$HttpStreamContent  {

/**
 * Initializes a new instance of the HttpStreamContent class with the specified content.
 * @param content The content used to initialize the HttpStreamContent .
 */
constructor(content: Windows$Storage$Streams$IInputStream): this;

/**
 * Serialize the HttpStreamContent into memory as an asynchronous operation.
 * @return The object that represents the asynchronous operation.
 */
bufferAllAsync(): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>;

/**
 * Closes the HttpStreamContent instance and releases allocated resources.
 */
close(): void;

/**
 * Get a collection of content headers set on the HttpStreamContent .
 */
headers: Windows$Web$Http$Headers$HttpContentHeaderCollection;

/**
 * Serialize the HttpStreamContent to a buffer as an asynchronous operation.
 * @return The object representing the asynchronous operation.
 */
readAsBufferAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>;

/**
 * Serialize the HttpStreamContent and return an input stream that represents the content as an asynchronous operation.
 * @return The object representing the asynchronous operation.
 */
readAsInputStreamAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IInputStream, number>;

/**
 * Serialize the HttpStreamContent to a String as an asynchronous operation.
 * @return The object representing the asynchronous operation.
 */
readAsStringAsync(): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<string, number>;

/**
 * Determines whether the HttpStreamContent has a valid length in bytes.
 */
tryComputeLength(): {
length: number,
returnValue: boolean
};

/**
 * Write the HttpStreamContent to an output stream as an asynchronous operation.
 * @param outputStream The output stream to write to.
 * @return The object that represents the asynchronous operation.
 */
writeToStreamAsync(
outputStream: Windows$Storage$Streams$IOutputStream): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Provides HTTP content that uses a string.
 */
declare class Windows$Web$Http$HttpStringContent  {

/**
 * Initializes a new instance of the HttpStringContent class with the specified content and encoding.
 * @param content The content used to initialize the HttpStringContent .
 * @param encoding The encoding to use for the content.
 */
constructor(content: string, encoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>): this;

/**
 * Initializes a new instance of the HttpStringContent class with the specified content, encoding, and media type.
 * @param content The content used to initialize the HttpStringContent .
 * @param encoding The encoding to use for the content.
 * @param mediaType The media type to use for the content.
 */
constructor(content: string, encoding: $Values<typeof Windows$Storage$Streams$UnicodeEncoding>, mediaType: string): this;

/**
 * Initializes a new instance of the HttpStringContent class with the specified content.
 * @param content The content used to initialize the HttpStringContent .
 */
constructor(content: string): this;

/**
 * Serialize the HttpStringContent into memory as an asynchronous operation.
 * @return The object that represents the asynchronous operation.
 */
bufferAllAsync(): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>;

/**
 * Closes the HttpStringContent instance and releases allocated resources.
 */
close(): void;

/**
 * Get a collection of content headers set on the HttpStringContent .
 */
headers: Windows$Web$Http$Headers$HttpContentHeaderCollection;

/**
 * Serialize the HttpStringContent to a buffer as an asynchronous operation.
 * @return The object that represents the asynchronous operation.
 */
readAsBufferAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>;

/**
 * Serialize the HttpStringContent and return an input stream that represents the content as an asynchronous operation.
 * @return The object that represents the asynchronous operation.
 */
readAsInputStreamAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IInputStream, number>;

/**
 * Serialize the HttpStringContent to a String as an asynchronous operation.
 * @return The object that represents the asynchronous operation.
 */
readAsStringAsync(): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<string, number>;

/**
 * Compute the HttpStringContent length in bytes.
 */
tryComputeLength(): {
length: number,
returnValue: boolean
};

/**
 * Write the HttpStringContent to an output stream as an asynchronous operation.
 * @param outputStream The output stream to write to.
 * @return The object that represents the asynchronous operation.
 */
writeToStreamAsync(
outputStream: Windows$Storage$Streams$IOutputStream): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>
}


/**
 * Provides information about the underlying transport used by the HTTP connection.
 */
declare class Windows$Web$Http$HttpTransportInformation  {

/**
 * Gets the certificate from the server with the SSL information.
 */
serverCertificate: Windows$Security$Cryptography$Certificates$Certificate;

/**
 * Gets the category of an error on an SSL connection.
 */
serverCertificateErrorSeverity: $Values<typeof Windows$Networking$Sockets$SocketSslErrorSeverity>;

/**
 * Gets the list of errors that occurred making an SSL connection.
 */
serverCertificateErrors: Windows$Foundation$Collections$IVectorView<$Values<typeof Windows$Security$Cryptography$Certificates$ChainValidationResult>>;

/**
 * Gets the intermediate certificates sent by the server during SSL negotiation on this HttpTransportInformation object.
 */
serverIntermediateCertificates: Windows$Foundation$Collections$IVectorView<Windows$Security$Cryptography$Certificates$Certificate>
}


/**
 * Represents the HTTP protocol version.
 */

declare  var Windows$Web$Http$HttpVersion: {|
  +none: 0,// 0
+http10: 1,// 1
+http11: 2,// 2
+http20: 3,// 3

|};



/**
 * Contains status information on the progress of an HttpClient operation.
 */
declare interface Windows$Web$Http$HttpProgress {

/**
 * The total number of bytes received.
 */
bytesReceived: number,

/**
 * The total number of bytes sent.
 */
bytesSent: number,

/**
 * The number of retries.
 */
retries: number,

/**
 * The step in the progress of an HTTP connection.
 */
stage: $Values<typeof Windows$Web$Http$HttpProgressStage>,

/**
 * The total number of data bytes to receive.
 */
totalBytesToReceive: number,

/**
 * The total number of data bytes to send.
 */
totalBytesToSend: number
} 


/**
 * Provides a base interface for an HTTP entity body and content headers.
 */
declare type Windows$Web$Http$IHttpContent = {

/**
 * Serialize the HTTP content into memory as an asynchronous operation.
 * @return The object that represents the asynchronous operation.
 */
bufferAllAsync(): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>,

/**
 * Serialize the HTTP content to a buffer as an asynchronous operation.
 * @return The object representing the asynchronous operation.
 */
readAsBufferAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IBuffer, number>,

/**
 * Serialize the HTTP content and return an input stream that represents the content as an asynchronous operation.
 * @return The object representing the asynchronous operation.
 */
readAsInputStreamAsync(
): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Storage$Streams$IInputStream, number>,

/**
 * Serialize the HTTP content to a String as an asynchronous operation.
 * @return The object representing the asynchronous operation.
 */
readAsStringAsync(): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<string, number>,

/**
 * Determines whether the HTTP content has a valid length in bytes.
 */
tryComputeLength(): {
length: number,
returnValue: boolean
},

/**
 * Write the HTTP content to an output stream as an asynchronous operation.
 * @param outputStream The output stream to write to.
 * @return The object representing the asynchronous operation.
 */
writeToStreamAsync(
outputStream: Windows$Storage$Streams$IOutputStream): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<number, number>,

/**
 * Get a collection of content headers set on the IHttpContent .
 */
headers: Windows$Web$Http$Headers$HttpContentHeaderCollection
} & Windows$Foundation$IClosable & Windows$Foundation$IStringable



      declare var npm$namespace$Windows$Web$Syndication: {
        
        
        SyndicationErrorStatus: typeof Windows$Web$Syndication$SyndicationErrorStatus,
SyndicationFormat: typeof Windows$Web$Syndication$SyndicationFormat,
SyndicationTextType: typeof Windows$Web$Syndication$SyndicationTextType,
        SyndicationAttribute: typeof Windows$Web$Syndication$SyndicationAttribute,
SyndicationCategory: typeof Windows$Web$Syndication$SyndicationCategory,
SyndicationClient: typeof Windows$Web$Syndication$SyndicationClient,
SyndicationContent: typeof Windows$Web$Syndication$SyndicationContent,
SyndicationError: typeof Windows$Web$Syndication$SyndicationError,
SyndicationFeed: typeof Windows$Web$Syndication$SyndicationFeed,
SyndicationGenerator: typeof Windows$Web$Syndication$SyndicationGenerator,
SyndicationItem: typeof Windows$Web$Syndication$SyndicationItem,
SyndicationLink: typeof Windows$Web$Syndication$SyndicationLink,
SyndicationNode: typeof Windows$Web$Syndication$SyndicationNode,
SyndicationPerson: typeof Windows$Web$Syndication$SyndicationPerson,
SyndicationText: typeof Windows$Web$Syndication$SyndicationText,
        
      }

/**
 * Represents a custom attribute not defined in the specification.
 */
declare class Windows$Web$Syndication$SyndicationAttribute  {

/**
 * Creates a new SyndicationAttribute object.
 */
constructor(): this;

/**
 * Creates a new SyndicationAttribute object with the specified Name, Namespace, and Value property values.
 * @param attributeName The name of the attribute.
 * @param attributeNamespace The namespace of the attribute.
 * @param attributeValue The value of the attribute.
 */
constructor(attributeName: string, attributeNamespace: string, attributeValue: string): this;

/**
 * Gets the name of the syndication attribute.
 */
name: string;

/**
 * Gets the namespace of the attribute.
 */
namespace: string;

/**
 * Gets or sets the value of the attribute.
 */
value: string
}


/**
 * Represents the category of a feed or an item. This class encapsulates information in the /rss/channel/item/category element in RSS 2.0 or the atom:category element in Atom 1.0.
 */
declare class Windows$Web$Syndication$SyndicationCategory  {

/**
 * Creates SyndicationCategory object with the specified property values.
 * @param term A string that identifies the category.
 * @param scheme The scheme of the category.
 * @param label A label for display in end-user applications.
 */
constructor(term: string, scheme: string, label: string): this;

/**
 * Creates a SyndicationCategory object.
 */
constructor(): this;

/**
 * Creates a SyndicationCategory object with the specified term property.
 * @param term A string that identifies the category. This parameter represents the required term attribute on atom:category or the text content of the category element in RSS 2.0.
 */
constructor(term: string): this;

/**
 * Gets the list of custom attributes of the element.
 */
attributeExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationAttribute>;

/**
 * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element.
 */
baseUri: Windows$Foundation$Uri;

/**
 * Gets the list of child elements within the element.
 */
elementExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$ISyndicationNode>;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param format The format of the data.
 * @return The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
getXmlDocument(
format: $Values<typeof Windows$Web$Syndication$SyndicationFormat>): Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets or sets the label for the category. This property represents the label attribute on atom:category. It provides a label for display in end-user applications.
 */
label: string;

/**
 * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0.
 */
language: string;

/**
 * Gets or sets the local name of the element.
 */
nodeName: string;

/**
 * Gets or sets the namespace of the element.
 */
nodeNamespace: string;

/**
 * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL.
 */
nodeValue: string;

/**
 * Gets or sets the scheme of the category. This property represents the scheme attribute on atom:category or the domain attribute on the category element in RSS 2.0.
 */
scheme: string;

/**
 * Gets or sets a string that identifies the category. This property represents the required term attribute on atom:category or the text content of the category element in RSS 2.0.
 */
term: string
}


/**
 * Implements the ISyndicationClient interface which retrieves feeds from a URI asynchronously.
 */
declare class Windows$Web$Syndication$SyndicationClient  {

/**
 * Creates a new SyndicationClient object.
 */
constructor(): this;

/**
 * Creates a new SyndicationClient object with authentication credentials.
 * @param serverCredential Credentials for user authentication.
 */
constructor(serverCredential: Windows$Security$Credentials$PasswordCredential): this;

/**
 * Gets or sets a Boolean value that specifies whether to bypass the cache when retrieving the feed.
 */
bypassCacheOnRetrieve: boolean;

/**
 * Gets or sets the maximum number of bytes to buffer when receiving a response from a server.
 */
maxResponseBufferSize: number;

/**
 * Gets or sets the credentials to use when making requests via a proxy.
 */
proxyCredential: Windows$Security$Credentials$PasswordCredential;

/**
 * Starts an asynchronous operation to download the syndication feed from the given URI. This method instantiates a SyndicationFeed object from the feed string, which can be in one of the formats specified in SyndicationFormat .
 * @param uri The URI from which the feed is downloaded.
 * @return Contains the results of the operation.
 */
retrieveFeedAsync(
uri: Windows$Foundation$Uri): Windows$Foundation$IPromiseWithIAsyncOperationWithProgress<Windows$Web$Syndication$SyndicationFeed, Windows$Web$Syndication$RetrievalProgress>;

/**
 * Gets or sets the credentials to use when making requests to the server.
 */
serverCredential: Windows$Security$Credentials$PasswordCredential;

/**
 * Sets an HTTP header for the request. This method can be called multiple times to set multiple headers. When the same header is set multiple times, the values will be concatenated and separated by ",".
 * @param name The name of the header.
 * @param value The value of the header.
 */
setRequestHeader(name: string, value: string): void;

/**
 * Gets or sets the maximum amount of time, in milliseconds, to wait for any of the asynchronous operations to complete. If the operation is not complete within this amount of time, it will fail with a status code indicating that it timed out.
 */
timeout: number
}


/**
 * Represents feed content including Text, HTML, XHTML, URL, and XML. This object encapsulates the atom:content element in Atom 1.0 and can contain a link to external content.
 */
declare class Windows$Web$Syndication$SyndicationContent  {

/**
 * Creates a new SyndicationContent object with the specified Uri property value.
 * @param sourceUri The Uri value.
 */
constructor(sourceUri: Windows$Foundation$Uri): this;

/**
 * Creates a new SyndicationContent object.
 */
constructor(): this;

/**
 * Creates a new SyndicationContent object with the specified Text and Type property values.
 * @param text The text of the content.
 * @param type The type of the content.
 */
constructor(text: string, type: $Values<typeof Windows$Web$Syndication$SyndicationTextType>): this;

/**
 * Gets the list of custom attributes of the element.
 */
attributeExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationAttribute>;

/**
 * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element.
 */
baseUri: Windows$Foundation$Uri;

/**
 * Gets the list of child elements within the element.
 */
elementExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$ISyndicationNode>;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param format The format of the data.
 * @return The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
getXmlDocument(
format: $Values<typeof Windows$Web$Syndication$SyndicationFormat>): Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0.
 */
language: string;

/**
 * Gets or sets the local name of the element.
 */
nodeName: string;

/**
 * Gets or sets the namespace of the element.
 */
nodeNamespace: string;

/**
 * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL.
 */
nodeValue: string;

/**
 * Gets or sets the URI to the content. This property represents the src attribute on atom:content.
 */
sourceUri: Windows$Foundation$Uri;

/**
 * Gets the syndication content.
 */
text: string;

/**
 * Gets or sets the type of the content.
 */
type: string;

/**
 * Gets or sets the XML content.
 */
xml: Windows$Data$Xml$Dom$XmlDocument
}


/**
 * Represents an error encountered during a Syndication operation.
 */
declare class Windows$Web$Syndication$SyndicationError  {

/**
 * Gets the specific error using the returned HRESULT value. Possible values are defined by SyndicationErrorStatus .
 * @param hresult An HRESULT returned during the operation.
 * @return The error encountered.
 */
static getStatus(
hresult: number): $Values<typeof Windows$Web$Syndication$SyndicationErrorStatus>
}


/**
 * Defines errors encountered during a Syndication operation.
 */

declare  var Windows$Web$Syndication$SyndicationErrorStatus: {|
  +unknown: 0,// 0
+missingRequiredElement: 1,// 1
+missingRequiredAttribute: 2,// 2
+invalidXml: 3,// 3
+unexpectedContent: 4,// 4
+unsupportedFormat: 5,// 5

|};



/**
 * Contains information about a feed. This class encapsulates the information in the /rss/channel element in RSS 2.0 or the atom:feed element in Atom 1.0.
 */
declare class Windows$Web$Syndication$SyndicationFeed  {

/**
 * Creates a new SyndicationFeed object.
 */
constructor(): this;

/**
 * Creates a new SyndicationFeed object with a Title, Subtitle, and Uri.
 * @param title The Title of the syndication feed.
 * @param subtitle The Subtitle of the syndication feed.
 * @param uri The Uri value.
 */
constructor(title: string, subtitle: string, uri: Windows$Foundation$Uri): this;

/**
 * Gets the list of custom attributes of the element.
 */
attributeExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationAttribute>;

/**
 * Gets the authors of an item. This property represents the collection of all the atom:author elements under atom:entry.
 */
authors: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationPerson>;

/**
 * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element.
 */
baseUri: Windows$Foundation$Uri;

/**
 * Gets a collection of categories of the feed. This property represents the collection of all the atom:category elements under atom:feed.
 */
categories: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationCategory>;

/**
 * Gets a collection of the contributors of the feed. This property represents the collection of all the atom:contributor elements under atom:feed.
 */
contributors: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationPerson>;

/**
 * Gets the list of child elements within the element.
 */
elementExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$ISyndicationNode>;

/**
 * Gets the first Uniform Resource Identifier (URI) in a sequence. This property represents the atom:link element with attribute rel=first.
 */
firstUri: Windows$Foundation$Uri;

/**
 * Gets or sets the generator of the feed. This property represents the atom:generator element or the generator element in RSS 2.0.
 */
generator: Windows$Web$Syndication$SyndicationGenerator;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param format The format of the data.
 * @return The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
getXmlDocument(
format: $Values<typeof Windows$Web$Syndication$SyndicationFormat>): Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets or sets the Uniform Resource Identifier (URI) for the image for the feed. This property represents the atom:icon element.
 */
iconUri: Windows$Foundation$Uri;

/**
 * Gets or sets the identifier for the syndication feed.
 */
id: string;

/**
 * Gets or sets the Uniform Resource Identifier (URI) of the logo for the feed. This property represents the atom:logo element or image/uri element in RSS 2.0.
 */
imageUri: Windows$Foundation$Uri;

/**
 * Gets the collection of items in the feed. This property represents the collection of atom:entry elements or a collection of item elements in RSS 2.0.
 */
items: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationItem>;

/**
 * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0.
 */
language: string;

/**
 * Gets or sets the time the feed was last modified. This property represents the /rss/channel/lastBuildDate or atom:updated element.
 */
lastUpdatedTime: Date;

/**
 * Gets the last Uniform Resource Identifier (URI) in the sequence. This property represents the atom:link element with attribute rel=last.
 */
lastUri: Windows$Foundation$Uri;

/**
 * Gets the links associated with the feed. This property represents a collection of the atom:link elements under atom:feed. In RSS 2.0, this maps to the link element.
 */
links: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationLink>;

/**
 * Initializes the object from the given feed string, which can be in either RSS 2.0 or Atom 1.0 format.
 * @param feed The feed string, which can be in either RSS 2.0 or Atom 1.0 format.
 */
load(feed: string): void;

/**
 * Initializes the SyndicationFeed object from the given DOM object, which can contain XML content in either RSS 2.0 or Atom 1.0 format.
 * @param feedDocument The DOM object which contains XML content in either RSS 2.0 or Atom 1.0 format.
 */
loadFromXml(feedDocument: Windows$Data$Xml$Dom$XmlDocument): void;

/**
 * Gets the next Uniform Resource Identifier (URI) in the sequence. This property represents the atom:link element with attribute rel="next".
 */
nextUri: Windows$Foundation$Uri;

/**
 * Gets or sets the local name of the element.
 */
nodeName: string;

/**
 * Gets or sets the namespace of the element.
 */
nodeNamespace: string;

/**
 * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL.
 */
nodeValue: string;

/**
 * Gets the previous Uniform Resource Identifier (URI) in the sequence. This property represents the atom:link element with attribute rel="previous".
 */
previousUri: Windows$Foundation$Uri;

/**
 * Gets or sets information about the rights for the feed. This property represents the atom:rights element or the copyright element in RSS 2.0.
 */
rights: Windows$Web$Syndication$ISyndicationText;

/**
 * Gets the format of the source document. If the object is not loaded from a document, this property will return SyndicationFormat_Atom10.
 */
sourceFormat: $Values<typeof Windows$Web$Syndication$SyndicationFormat>;

/**
 * Gets or sets the subtitle of the feed. This property represents the atom:subtitle element or the description element in RSS 2.0.
 */
subtitle: Windows$Web$Syndication$ISyndicationText;

/**
 * Gets or sets the title of the syndication feed.
 */
title: Windows$Web$Syndication$ISyndicationText
}


/**
 * Specifies the syndication formats supported by the API.
 */

declare  var Windows$Web$Syndication$SyndicationFormat: {|
  +atom10: 0,// 0
+rss20: 1,// 1
+rss10: 2,// 2
+rss092: 3,// 3
+rss091: 4,// 4
+atom03: 5,// 5

|};



/**
 * Describes the agent or the tool used to generate the feed. This class encapsulates information in the /rss/channel/generator element in RSS 2.0 or the /atom:feed/atom:generator element in Atom 1.0.
 */
declare class Windows$Web$Syndication$SyndicationGenerator  {

/**
 * Creates a new SyndicationGenerator object.
 */
constructor(): this;

/**
 * Creates a new SyndicationGenerator object with the specified Text property value.
 * @param text Identifies the generator. This parameter represents the text content in the atom:generator element or the generator element in RSS 2.0.
 */
constructor(text: string): this;

/**
 * Gets the list of custom attributes of the element.
 */
attributeExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationAttribute>;

/**
 * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element.
 */
baseUri: Windows$Foundation$Uri;

/**
 * Gets the list of child elements within the element.
 */
elementExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$ISyndicationNode>;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param format The format of the data.
 * @return The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
getXmlDocument(
format: $Values<typeof Windows$Web$Syndication$SyndicationFormat>): Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0.
 */
language: string;

/**
 * Gets or sets the local name of the element.
 */
nodeName: string;

/**
 * Gets or sets the namespace of the element.
 */
nodeNamespace: string;

/**
 * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL.
 */
nodeValue: string;

/**
 * Gets or sets the text that identifies the generator.
 */
text: string;

/**
 * Gets or sets the Uniform Resource Identifier (URI) of the syndication generator.
 */
uri: Windows$Foundation$Uri;

/**
 * Gets or sets the version of the generator.
 */
version: string
}


/**
 * Represents an item in the feed. This class encapsulates information in the /rss/channel/item element in RSS 2.0 or the atom:entry element in Atom 1.0.
 */
declare class Windows$Web$Syndication$SyndicationItem  {

/**
 * Creates a new SyndicationItem object with a title, content, and URI.
 * @param title Title of the new item.
 * @param content The content for this feed item.
 * @param uri The URI associated with this item.
 */
constructor(title: string, content: Windows$Web$Syndication$SyndicationContent, uri: Windows$Foundation$Uri): this;

/**
 * Creates a new SyndicationItem object.
 */
constructor(): this;

/**
 * Gets the list of custom attributes of the element.
 */
attributeExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationAttribute>;

/**
 * Gets the authors of an item. This property represents the collection of all the atom:author elements under atom:entry.
 */
authors: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationPerson>;

/**
 * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element.
 */
baseUri: Windows$Foundation$Uri;

/**
 * Gets a collection of categories of the feed. This property represents the collection of all the atom:category elements under atom:feed.
 */
categories: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationCategory>;

/**
 * Gets or sets the Uniform Resource Identifier (URI) of the comments for the item. This property represents the /rss/channel/item/comments element.
 */
commentsUri: Windows$Foundation$Uri;

/**
 * Gets or sets the content of the item.
 */
content: Windows$Web$Syndication$SyndicationContent;

/**
 * Gets a collection of the contributors of the feed. This property represents the collection of all the atom:contributor elements under atom:feed.
 */
contributors: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationPerson>;

/**
 * Gets the Uniform Resource Identifier (URI) of an editable media resource.
 */
editMediaUri: Windows$Foundation$Uri;

/**
 * Gets the Uniform Resource Identifier (URI) of an editable resource.
 */
editUri: Windows$Foundation$Uri;

/**
 * Gets the list of child elements within the element.
 */
elementExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$ISyndicationNode>;

/**
 * Gets an ETag HTTP header.
 */
etag: string;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param format The format of the data.
 * @return The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
getXmlDocument(
format: $Values<typeof Windows$Web$Syndication$SyndicationFormat>): Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets or sets the identifier for the syndication feed.
 */
id: string;

/**
 * Gets the Uniform Resource Identifier (URI) of this item. AtomPubClient creates this property after new resource is created.
 */
itemUri: Windows$Foundation$Uri;

/**
 * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0.
 */
language: string;

/**
 * Gets or sets the most recent time the item was modified. This property represents the atom:updated element.
 */
lastUpdatedTime: Date;

/**
 * Gets the links contained in the item.
 */
links: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationLink>;

/**
 * Initializes the object from the given feed string, which can be in either RSS 2.0 or Atom 1.0 format.
 * @param item The feed string, which can be in either RSS 2.0 or Atom 1.0 format.
 */
load(item: string): void;

/**
 * Initializes the object from the given DOM object, which can contain XML content in either RSS 2.0 or Atom 1.0 format.
 * @param itemDocument The DOM object, which can contain XML content in either RSS 2.0 or Atom 1.0 format.
 */
loadFromXml(itemDocument: Windows$Data$Xml$Dom$XmlDocument): void;

/**
 * Gets or sets the local name of the element.
 */
nodeName: string;

/**
 * Gets or sets the namespace of the element.
 */
nodeNamespace: string;

/**
 * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL.
 */
nodeValue: string;

/**
 * Gets or sets the date the item was published.
 */
publishedDate: Date;

/**
 * Gets or sets information about the rights of an item. This property represents the atom:rights element.
 */
rights: Windows$Web$Syndication$ISyndicationText;

/**
 * Gets or sets the source feed of the item. This property represents the atom:source element or the source element in RSS 2.0.
 */
source: Windows$Web$Syndication$SyndicationFeed;

/**
 * Gets or sets a summary of the item.
 */
summary: Windows$Web$Syndication$ISyndicationText;

/**
 * Gets or sets the title of the item.
 */
title: Windows$Web$Syndication$ISyndicationText
}


/**
 * Represents a link within a syndication feed or item. This class encapsulates information in the /rss/channel/link or / rss/channel/item/link element in RSS 2.0 or the atom:link element in Atom 1.0.
 */
declare class Windows$Web$Syndication$SyndicationLink  {

/**
 * Creates a new SyndicationLink object.
 */
constructor(): this;

/**
 * Creates a new SyndicationLink object with a Uri, Relationship, Title, MediaType, and Length.
 * @param uri The Uri value.
 * @param relationship The relationship type.
 * @param title The title of the syndication link.
 * @param mediaType The MediaType of the syndication link.
 * @param length The length, in bytes, of the syndication link.
 */
constructor(uri: Windows$Foundation$Uri, relationship: string, title: string, mediaType: string, length: number): this;

/**
 * Creates a new SyndicationLink with a Uri.
 * @param uri The Uri value.
 */
constructor(uri: Windows$Foundation$Uri): this;

/**
 * Gets the list of custom attributes of the element.
 */
attributeExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationAttribute>;

/**
 * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element.
 */
baseUri: Windows$Foundation$Uri;

/**
 * Gets the list of child elements within the element.
 */
elementExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$ISyndicationNode>;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param format The format of the data.
 * @return The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
getXmlDocument(
format: $Values<typeof Windows$Web$Syndication$SyndicationFormat>): Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0.
 */
language: string;

/**
 * Gets or sets the length of the linked resource, in bytes.
 */
length: number;

/**
 * Gets or sets the media type of the linked resource. The string must have the pattern ".+/.+".
 */
mediaType: string;

/**
 * Gets or sets the local name of the element.
 */
nodeName: string;

/**
 * Gets or sets the namespace of the element.
 */
nodeNamespace: string;

/**
 * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL.
 */
nodeValue: string;

/**
 * Gets or sets the relationship type of the link.
 */
relationship: string;

/**
 * Gets or sets the language of the resource pointed to by the Uri property. This property represents the hreflang attribute on atom:link. It must adhere to the pattern defined by RFC 3066.
 */
resourceLanguage: string;

/**
 * Gets or sets the title of the syndication link.
 */
title: string;

/**
 * Gets or sets the URI of the linked resource.
 */
uri: Windows$Foundation$Uri
}


/**
 * Implements the ISyndicationNode interface which represents a generic XML syndication element.
 */
declare class Windows$Web$Syndication$SyndicationNode  {

/**
 * Creates a new SyndicationNode object with the specified NodeName, NodeNamespace, and NodeValue property values.
 * @param nodeName The local name of the element. It must be valid according to XML 1.0.
 * @param nodeNamespace The namespace of the element.
 * @param nodeValue The text content of the element. If the element contains only child elements, this parameter is NULL.
 */
constructor(nodeName: string, nodeNamespace: string, nodeValue: string): this;

/**
 * Creates a new SyndicationNode object.
 */
constructor(): this;

/**
 * Gets the list of custom attributes of the element.
 */
attributeExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationAttribute>;

/**
 * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element.
 */
baseUri: Windows$Foundation$Uri;

/**
 * Gets the list of child elements within the element.
 */
elementExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$ISyndicationNode>;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param format The format of the data.
 * @return The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
getXmlDocument(
format: $Values<typeof Windows$Web$Syndication$SyndicationFormat>): Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0.
 */
language: string;

/**
 * Gets or sets the local name of the element.
 */
nodeName: string;

/**
 * Gets or sets the namespace of the element.
 */
nodeNamespace: string;

/**
 * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL.
 */
nodeValue: string
}


/**
 * Represents an author or contributor of syndication content.
 */
declare class Windows$Web$Syndication$SyndicationPerson  {

/**
 * Creates a SyndicationPerson object with the specified Name, Email, and Uri property values.
 * @param name The name of the SyndicationPerson . This parameter represents the atom:name element.
 * @param email Gets or sets the email address of the person. This property represents the atom:email element.
 * @param uri Gets or sets the URI of the person. This property represents the atom:uri element. It is the absolute URI resolved against the xml:base attribute, if it is present. If the href attribute is a relative URI string and there is no xml:base attribute, this property is NULL because relative URI is not supported by the runtime URI class.
 */
constructor(name: string, email: string, uri: Windows$Foundation$Uri): this;

/**
 * Creates a SyndicationPerson object.
 */
constructor(): this;

/**
 * Creates a SyndicationPerson object with the specified Name property value.
 * @param name The name of the SyndicationPerson . This parameter represents the atom:name element.
 */
constructor(name: string): this;

/**
 * Gets the list of custom attributes of the element.
 */
attributeExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationAttribute>;

/**
 * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element.
 */
baseUri: Windows$Foundation$Uri;

/**
 * Gets the list of child elements within the element.
 */
elementExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$ISyndicationNode>;

/**
 * Gets or sets the email address of the person.
 */
email: string;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param format The format of the data.
 * @return The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
getXmlDocument(
format: $Values<typeof Windows$Web$Syndication$SyndicationFormat>): Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0.
 */
language: string;

/**
 * Gets the name of the syndication person.
 */
name: string;

/**
 * Gets or sets the local name of the element.
 */
nodeName: string;

/**
 * Gets or sets the namespace of the element.
 */
nodeNamespace: string;

/**
 * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL.
 */
nodeValue: string;

/**
 * Gets or sets the Uniform Resource Identifier (URI) of the person. This property represents the atom:uri element. It is the absolute URI resolved against the xml:base attribute, if it is present. If the href attribute is a relative URI string and there is no xml:base attribute, this property is NULL because the relative URI is not supported by the runtime URI class.
 */
uri: Windows$Foundation$Uri
}


/**
 * Implements the ISyndicationText interface that encapsulates elements in RSS 2.0 or Atom 1.0 that can have either text, HTML, or XHTML. In Atom 1.0, this object maps to an atomTextConstruct in the schema, which can be atom:title, atom:subtitle, atom:rights, or atom:summary elements.
 */
declare class Windows$Web$Syndication$SyndicationText  {

/**
 * Creates a new SyndicationText object with the specified Text and Type property values.
 * @param text The content of a text content construct like atom:title.
 * @param type The type of the content. This value can be "text", "html", and "xhtml".
 */
constructor(text: string, type: $Values<typeof Windows$Web$Syndication$SyndicationTextType>): this;

/**
 * Creates a new SyndicationText object.
 */
constructor(): this;

/**
 * Creates a new SyndicationText object with the specified Text property value.
 * @param text The content of a text content construct like atom:title.
 */
constructor(text: string): this;

/**
 * Gets the list of custom attributes of the element.
 */
attributeExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationAttribute>;

/**
 * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element.
 */
baseUri: Windows$Foundation$Uri;

/**
 * Gets the list of child elements within the element.
 */
elementExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$ISyndicationNode>;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param format The format of the data.
 * @return The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
getXmlDocument(
format: $Values<typeof Windows$Web$Syndication$SyndicationFormat>): Windows$Data$Xml$Dom$XmlDocument;

/**
 * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0.
 */
language: string;

/**
 * Gets or sets the local name of the element.
 */
nodeName: string;

/**
 * Gets or sets the namespace of the element.
 */
nodeNamespace: string;

/**
 * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL.
 */
nodeValue: string;

/**
 * Gets the content of a text content construct like atom:title.
 */
text: string;

/**
 * Gets or sets the type of the content.
 */
type: string;

/**
 * Gets or sets the XML content.
 */
xml: Windows$Data$Xml$Dom$XmlDocument
}


/**
 * Specifies the text types supported for syndication content.
 */

declare  var Windows$Web$Syndication$SyndicationTextType: {|
  +text: 0,// 0
+html: 1,// 1
+xhtml: 2,// 2

|};



/**
 * Contains progress information for a data transfer operation.
 */
declare interface Windows$Web$Syndication$TransferProgress {

/**
 * The number of bytes received.
 */
bytesRetrieved: number,

/**
 * The number of bytes sent.
 */
bytesSent: number,

/**
 * The total number of bytes that will be received during the transfer operation.
 */
totalBytesToRetrieve: number,

/**
 * The total number of bytes that will be sent during the transfer operation.
 */
totalBytesToSend: number
} 


/**
 * Contains progress information for a data retrieval operation.
 */
declare interface Windows$Web$Syndication$RetrievalProgress {

/**
 * The number of bytes that have been received in this data retrieval operation.
 */
bytesRetrieved: number,

/**
 * The total number of bytes to be received during this data retrieval operation.
 */
totalBytesToRetrieve: number
} 


/**
 * Represents a generic syndication XML element extension.
 */
declare interface Windows$Web$Syndication$ISyndicationNode {

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param format The format of the data.
 * @return The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
getXmlDocument(
format: $Values<typeof Windows$Web$Syndication$SyndicationFormat>): Windows$Data$Xml$Dom$XmlDocument,

/**
 * Gets the list of custom attributes of the element.
 */
attributeExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$SyndicationAttribute>,

/**
 * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element.
 */
baseUri: Windows$Foundation$Uri,

/**
 * Gets the list of child elements within the element.
 */
elementExtensions: Windows$Foundation$Collections$IVector<Windows$Web$Syndication$ISyndicationNode>,

/**
 * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0.
 */
language: string,

/**
 * Gets or sets the local name of the element.
 */
nodeName: string,

/**
 * Gets or sets the namespace of the element.
 */
nodeNamespace: string,

/**
 * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL.
 */
nodeValue: string
} 


/**
 * Represents text, HTML, or XHTML content. This interface encapsulates elements in RSS 2.0 or Atom 1.0 that can have either text, HTML, or XHTML content. In Atom 1.0 this interface maps to an atomTextConstruct in the schema, which can be element atom:title, atom:subtitle, atom:rights or atom:summary.
 */
declare type Windows$Web$Syndication$ISyndicationText = {

/**
 * Gets or sets the content of a text content construct like atom:title.
 */
text: string,

/**
 * Gets or sets the type of the content.
 */
type: string,

/**
 * Gets or sets the XML content.
 */
xml: Windows$Data$Xml$Dom$XmlDocument
} & Windows$Web$Syndication$ISyndicationNode



/**
 * Provides error status resulting from a web service operation.
 */
declare class Windows$Web$WebError  {

/**
 * Gets a WebErrorStatus value based on an error encountered by a web service operation.
 * @param hresult The error encountered by a web service operation represented as an hResult.
 * @return The error status value for a web service operation.
 */
static getStatus(hresult: number): $Values<typeof Windows$Web$WebErrorStatus>
}


/**
 * Defines errors encountered during operations involving web services, such as authentication, proxy configuration, and destination URIs.
 */

declare  var Windows$Web$WebErrorStatus: {|
  +unknown: 0,// 0
+certificateCommonNameIsIncorrect: 1,// 1
+certificateExpired: 2,// 2
+certificateContainsErrors: 3,// 3
+certificateRevoked: 4,// 4
+certificateIsInvalid: 5,// 5
+serverUnreachable: 6,// 6
+timeout: 7,// 7
+errorHttpInvalidServerResponse: 8,// 8
+connectionAborted: 9,// 9
+connectionReset: 10,// 10
+disconnected: 11,// 11
+httpToHttpsOnRedirection: 12,// 12
+httpsToHttpOnRedirection: 13,// 13
+cannotConnect: 14,// 14
+hostNameNotResolved: 15,// 15
+operationCanceled: 16,// 16
+redirectFailed: 17,// 17
+unexpectedStatusCode: 18,// 18
+unexpectedRedirection: 19,// 19
+unexpectedClientError: 20,// 20
+unexpectedServerError: 21,// 21
+multipleChoices: 22,// 22
+movedPermanently: 23,// 23
+found: 24,// 24
+seeOther: 25,// 25
+notModified: 26,// 26
+useProxy: 27,// 27
+temporaryRedirect: 28,// 28
+badRequest: 29,// 29
+unauthorized: 30,// 30
+paymentRequired: 31,// 31
+forbidden: 32,// 32
+notFound: 33,// 33
+methodNotAllowed: 34,// 34
+notAcceptable: 35,// 35
+proxyAuthenticationRequired: 36,// 36
+requestTimeout: 37,// 37
+conflict: 38,// 38
+gone: 39,// 39
+lengthRequired: 40,// 40
+preconditionFailed: 41,// 41
+requestEntityTooLarge: 42,// 42
+requestUriTooLong: 43,// 43
+unsupportedMediaType: 44,// 44
+requestedRangeNotSatisfiable: 45,// 45
+expectationFailed: 46,// 46
+internalServerError: 47,// 47
+notImplemented: 48,// 48
+badGateway: 49,// 49
+serviceUnavailable: 50,// 50
+gatewayTimeout: 51,// 51
+httpVersionNotSupported: 52,// 52

|};

    }

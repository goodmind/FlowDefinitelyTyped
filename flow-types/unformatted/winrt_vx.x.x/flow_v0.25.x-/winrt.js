declare module 'winrt' {
        declare module 'Foundation' {
        declare module 'Collections' {
        declare export  class CollectionChange {
  constructor(...args: empty): mixed;
static +reset: Class<CollectionChange__reset> & CollectionChange__reset & 0;// 0
static +itemInserted: Class<CollectionChange__itemInserted> & CollectionChange__itemInserted & 1;// 1
static +itemRemoved: Class<CollectionChange__itemRemoved> & CollectionChange__itemRemoved & 2;// 2
static +itemChanged: Class<CollectionChange__itemChanged> & CollectionChange__itemChanged & 3;// 3

}

declare class CollectionChange__reset mixins CollectionChange {}
declare class CollectionChange__itemInserted mixins CollectionChange {}
declare class CollectionChange__itemRemoved mixins CollectionChange {}
declare class CollectionChange__itemChanged mixins CollectionChange {}

	declare export interface IVectorChangedEventArgs {
collectionChange: Windows$Windows$Foundation.Collections.CollectionChange,
index: number
} 
	declare export type IPropertySet = {} & undefined.IObservableMap<string, any> & undefined.IMap<string, any> & undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>

	declare export class PropertySet mixins undefined.IPropertySet, undefined.IObservableMap<string, any>, undefined.IMap<string, any>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>> {
size: number;
onmapchanged: any;
lookup(key: string): any;
hasKey(key: string): boolean;
getView(): Windows$Windows$Foundation.Collections.IMapView<string, any>;
insert(key: string, value: any): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>
}
	declare export class ValueSet mixins undefined.IPropertySet, undefined.IObservableMap<string, any>, undefined.IMap<string, any>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>> {
size: number;
onmapchanged: any;
lookup(key: string): any;
hasKey(key: string): boolean;
getView(): Windows$Windows$Foundation.Collections.IMapView<string, any>;
insert(key: string, value: any): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>
}
	declare export interface IIterable<T> {
first(): Windows$Windows$Foundation.Collections.IIterator<T>
} 
	declare export interface IIterator<T> {
current: T,
hasCurrent: boolean,
moveNext(): boolean,
getMany(): {
items: T[],
returnValue: number
}
} 
	declare export type IVectorView<T> = {
size: number,
getAt(index: number): T,
indexOf(value: T): {
index: number,
returnValue: boolean
},
getMany(startIndex: number): {
items: T[],
returnValue: number
},
toString(): string,
toLocaleString(): string,
concat(...items: T[][]): T[],
join(seperator: string): string,
pop(): T,
push(...items: T[]): void,
reverse(): T[],
shift(): T,
slice(start: number): T[],
slice(start: number, end: number): T[],
sort(): T[],
sort(compareFn: (a: T, b: T) => number): T[],
splice(start: number): T[],
splice(start: number, deleteCount: number, ...items: T[]): T[],
unshift(...items: T[]): number,
lastIndexOf(searchElement: T): number,
lastIndexOf(searchElement: T, fromIndex: number): number,
every(callbackfn: (value: T, index: number, array: T[]) => boolean): boolean,
every(
callbackfn: (value: T, index: number, array: T[]) => boolean,
thisArg: any): boolean,
some(callbackfn: (value: T, index: number, array: T[]) => boolean): boolean,
some(
callbackfn: (value: T, index: number, array: T[]) => boolean,
thisArg: any): boolean,
forEach(callbackfn: (value: T, index: number, array: T[]) => void): void,
forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg: any): void,
map(callbackfn: (value: T, index: number, array: T[]) => any): any[],
map(callbackfn: (value: T, index: number, array: T[]) => any, thisArg: any): any[],
filter(callbackfn: (value: T, index: number, array: T[]) => boolean): T[],
filter(
callbackfn: (value: T, index: number, array: T[]) => boolean,
thisArg: any): T[],
reduce(
callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any): any,
reduce(
callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any,
initialValue: any): any,
reduceRight(
callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any): any,
reduceRight(
callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any,
initialValue: any): any,
length: number
} & undefined.IIterable<T>

	declare export type IVector<T> = {
size: number,
getAt(index: number): T,
getView(): Windows$Windows$Foundation.Collections.IVectorView<T>,
indexOf(value: T): {
index: number,
returnValue: boolean
},
setAt(index: number, value: T): void,
insertAt(index: number, value: T): void,
removeAt(index: number): void,
append(value: T): void,
removeAtEnd(): void,
clear(): void,
getMany(startIndex: number): {
items: T[],
returnValue: number
},
replaceAll(items: T[]): void,
toString(): string,
toLocaleString(): string,
concat(...items: T[][]): T[],
join(seperator: string): string,
pop(): T,
push(...items: T[]): void,
reverse(): T[],
shift(): T,
slice(start: number): T[],
slice(start: number, end: number): T[],
sort(): T[],
sort(compareFn: (a: T, b: T) => number): T[],
splice(start: number): T[],
splice(start: number, deleteCount: number, ...items: T[]): T[],
unshift(...items: T[]): number,
lastIndexOf(searchElement: T): number,
lastIndexOf(searchElement: T, fromIndex: number): number,
every(callbackfn: (value: T, index: number, array: T[]) => boolean): boolean,
every(
callbackfn: (value: T, index: number, array: T[]) => boolean,
thisArg: any): boolean,
some(callbackfn: (value: T, index: number, array: T[]) => boolean): boolean,
some(
callbackfn: (value: T, index: number, array: T[]) => boolean,
thisArg: any): boolean,
forEach(callbackfn: (value: T, index: number, array: T[]) => void): void,
forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg: any): void,
map(callbackfn: (value: T, index: number, array: T[]) => any): any[],
map(callbackfn: (value: T, index: number, array: T[]) => any, thisArg: any): any[],
filter(callbackfn: (value: T, index: number, array: T[]) => boolean): T[],
filter(
callbackfn: (value: T, index: number, array: T[]) => boolean,
thisArg: any): T[],
reduce(
callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any): any,
reduce(
callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any,
initialValue: any): any,
reduceRight(
callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any): any,
reduceRight(
callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any,
initialValue: any): any,
length: number
} & undefined.IIterable<T>

	declare export interface IKeyValuePair<K, V> {
key: K,
value: V
} 
	declare export type IMap<K, V> = {
size: number,
lookup(key: K): V,
hasKey(key: K): boolean,
getView(): Windows$Windows$Foundation.Collections.IMapView<K, V>,
insert(key: K, value: V): boolean,
remove(key: K): void,
clear(): void
} & undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<K, V>>

	declare export type IMapView<K, V> = {
size: number,
lookup(key: K): V,
hasKey(key: K): boolean,
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<K, V>,
second: Windows$Windows$Foundation.Collections.IMapView<K, V>
}
} & undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<K, V>>

	declare export interface VectorChangedEventHandler<T> {
(sender: Windows$Windows$Foundation.Collections.IObservableVector<T>, event: Windows$Windows$Foundation.Collections.IVectorChangedEventArgs): void
} 
	declare export type IObservableVector<T> = {
onvectorchanged: any
} & undefined.IVector<T> & undefined.IIterable<T>

	declare export interface IMapChangedEventArgs<K> {
collectionChange: Windows$Windows$Foundation.Collections.CollectionChange,
key: K
} 
	declare export interface MapChangedEventHandler<K, V> {
(sender: Windows$Windows$Foundation.Collections.IObservableMap<K, V>, event: Windows$Windows$Foundation.Collections.IMapChangedEventArgs<K>): void
} 
	declare export type IObservableMap<K, V> = {
onmapchanged: any
} & undefined.IMap<K, V> & undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<K, V>>

    }

	declare export interface IUriRuntimeClass {
absoluteUri: string,
displayUri: string,
domain: string,
extension: string,
fragment: string,
host: string,
password: string,
path: string,
port: number,
query: string,
queryParsed: Windows$Windows$Foundation.WwwFormUrlDecoder,
rawUri: string,
schemeName: string,
suspicious: boolean,
userName: string,
equals(pUri: Windows$Windows$Foundation.Uri): boolean,
combineUri(relativeUri: string): Windows$Windows$Foundation.Uri
} 
	declare export class WwwFormUrlDecoder mixins undefined.IWwwFormUrlDecoderRuntimeClass, undefined.IIterable<Windows$Windows$Foundation.IWwwFormUrlDecoderEntry>, undefined.IVectorView<Windows$Windows$Foundation.IWwwFormUrlDecoderEntry> {
constructor(query: string): this;
size: number;
getFirstValueByName(name: string): string;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.IWwwFormUrlDecoderEntry>;
getAt(index: number): Windows$Windows$Foundation.IWwwFormUrlDecoderEntry;
indexOf(
value: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[],
returnValue: number
};
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[][]): Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[];
join(seperator: string): string;
pop(): Windows$Windows$Foundation.IWwwFormUrlDecoderEntry;
push(...items: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]): void;
reverse(): Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[];
shift(): Windows$Windows$Foundation.IWwwFormUrlDecoderEntry;
slice(start: number): Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[];
slice(
start: number,
end: number): Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[];
sort(): Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[];
sort(
compareFn: (
a: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry,
b: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry) => number): Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[];
splice(start: number): Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]): Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[];
unshift(...items: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]): number;
lastIndexOf(searchElement: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry): number;
lastIndexOf(
searchElement: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry,
index: number,
array: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry,
index: number,
array: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry,
index: number,
array: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry,
index: number,
array: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry,
index: number,
array: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry,
index: number,
array: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry,
index: number,
array: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry,
index: number,
array: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry,
index: number,
array: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]) => boolean): Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[];
filter(
callbackfn: (
value: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry,
index: number,
array: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]) => boolean,
thisArg: any): Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Foundation.IWwwFormUrlDecoderEntry[]) => any,
initialValue: any): any;
length: number
}
	declare export class Uri mixins undefined.IUriRuntimeClass, undefined.IUriRuntimeClassWithAbsoluteCanonicalUri {
constructor(uri: string): this;
constructor(baseUri: string, relativeUri: string): this;
absoluteUri: string;
displayUri: string;
domain: string;
extension: string;
fragment: string;
host: string;
password: string;
path: string;
port: number;
query: string;
queryParsed: Windows$Windows$Foundation.WwwFormUrlDecoder;
rawUri: string;
schemeName: string;
suspicious: boolean;
userName: string;
absoluteCanonicalUri: string;
displayIri: string;
equals(pUri: Windows$Windows$Foundation.Uri): boolean;
combineUri(relativeUri: string): Windows$Windows$Foundation.Uri;
static unescapeComponent(toUnescape: string): string;
static escapeComponent(toEscape: string): string
}
	declare export interface IUriRuntimeClassWithAbsoluteCanonicalUri {
absoluteCanonicalUri: string,
displayIri: string
} 
	declare export interface IUriEscapeStatics {
unescapeComponent(toUnescape: string): string,
escapeComponent(toEscape: string): string
} 
	declare export interface IUriRuntimeClassFactory {
createUri(uri: string): Windows$Windows$Foundation.Uri,
createUri(baseUri: string, relativeUri: string): Windows$Windows$Foundation.Uri
} 
	declare export interface IWwwFormUrlDecoderEntry {
name: string,
value: string
} 
	declare export type IWwwFormUrlDecoderRuntimeClass = {
getFirstValueByName(name: string): string
} & undefined.IIterable<Windows$Windows$Foundation.IWwwFormUrlDecoderEntry> & undefined.IVectorView<Windows$Windows$Foundation.IWwwFormUrlDecoderEntry>

	declare export interface IWwwFormUrlDecoderRuntimeClassFactory {
createWwwFormUrlDecoder(query: string): Windows$Windows$Foundation.WwwFormUrlDecoder
} 
	declare export interface IGetActivationFactory {
getActivationFactory(activatableClassId: string): any
} 
	declare export interface IClosable {
close(): void
} 
	declare export  class PropertyType {
  constructor(...args: empty): mixed;
static +empty: Class<PropertyType__empty> & PropertyType__empty & 0;// 0
static +uInt8: Class<PropertyType__uInt8> & PropertyType__uInt8 & 1;// 1
static +int16: Class<PropertyType__int16> & PropertyType__int16 & 2;// 2
static +uInt16: Class<PropertyType__uInt16> & PropertyType__uInt16 & 3;// 3
static +int32: Class<PropertyType__int32> & PropertyType__int32 & 4;// 4
static +uInt32: Class<PropertyType__uInt32> & PropertyType__uInt32 & 5;// 5
static +int64: Class<PropertyType__int64> & PropertyType__int64 & 6;// 6
static +uInt64: Class<PropertyType__uInt64> & PropertyType__uInt64 & 7;// 7
static +single: Class<PropertyType__single> & PropertyType__single & 8;// 8
static +double: Class<PropertyType__double> & PropertyType__double & 9;// 9
static +char16: Class<PropertyType__char16> & PropertyType__char16 & 10;// 10
static +boolean: Class<PropertyType__boolean> & PropertyType__boolean & 11;// 11
static +string: Class<PropertyType__string> & PropertyType__string & 12;// 12
static +inspectable: Class<PropertyType__inspectable> & PropertyType__inspectable & 13;// 13
static +dateTime: Class<PropertyType__dateTime> & PropertyType__dateTime & 14;// 14
static +timeSpan: Class<PropertyType__timeSpan> & PropertyType__timeSpan & 15;// 15
static +guid: Class<PropertyType__guid> & PropertyType__guid & 16;// 16
static +point: Class<PropertyType__point> & PropertyType__point & 17;// 17
static +size: Class<PropertyType__size> & PropertyType__size & 18;// 18
static +rect: Class<PropertyType__rect> & PropertyType__rect & 19;// 19
static +otherType: Class<PropertyType__otherType> & PropertyType__otherType & 20;// 20
static +uInt8Array: Class<PropertyType__uInt8Array> & PropertyType__uInt8Array & 21;// 21
static +int16Array: Class<PropertyType__int16Array> & PropertyType__int16Array & 22;// 22
static +uInt16Array: Class<PropertyType__uInt16Array> & PropertyType__uInt16Array & 23;// 23
static +int32Array: Class<PropertyType__int32Array> & PropertyType__int32Array & 24;// 24
static +uInt32Array: Class<PropertyType__uInt32Array> & PropertyType__uInt32Array & 25;// 25
static +int64Array: Class<PropertyType__int64Array> & PropertyType__int64Array & 26;// 26
static +uInt64Array: Class<PropertyType__uInt64Array> & PropertyType__uInt64Array & 27;// 27
static +singleArray: Class<PropertyType__singleArray> & PropertyType__singleArray & 28;// 28
static +doubleArray: Class<PropertyType__doubleArray> & PropertyType__doubleArray & 29;// 29
static +char16Array: Class<PropertyType__char16Array> & PropertyType__char16Array & 30;// 30
static +booleanArray: Class<PropertyType__booleanArray> & PropertyType__booleanArray & 31;// 31
static +stringArray: Class<PropertyType__stringArray> & PropertyType__stringArray & 32;// 32
static +inspectableArray: Class<PropertyType__inspectableArray> & PropertyType__inspectableArray & 33;// 33
static +dateTimeArray: Class<PropertyType__dateTimeArray> & PropertyType__dateTimeArray & 34;// 34
static +timeSpanArray: Class<PropertyType__timeSpanArray> & PropertyType__timeSpanArray & 35;// 35
static +guidArray: Class<PropertyType__guidArray> & PropertyType__guidArray & 36;// 36
static +pointArray: Class<PropertyType__pointArray> & PropertyType__pointArray & 37;// 37
static +sizeArray: Class<PropertyType__sizeArray> & PropertyType__sizeArray & 38;// 38
static +rectArray: Class<PropertyType__rectArray> & PropertyType__rectArray & 39;// 39
static +otherTypeArray: Class<PropertyType__otherTypeArray> & PropertyType__otherTypeArray & 40;// 40

}

declare class PropertyType__empty mixins PropertyType {}
declare class PropertyType__uInt8 mixins PropertyType {}
declare class PropertyType__int16 mixins PropertyType {}
declare class PropertyType__uInt16 mixins PropertyType {}
declare class PropertyType__int32 mixins PropertyType {}
declare class PropertyType__uInt32 mixins PropertyType {}
declare class PropertyType__int64 mixins PropertyType {}
declare class PropertyType__uInt64 mixins PropertyType {}
declare class PropertyType__single mixins PropertyType {}
declare class PropertyType__double mixins PropertyType {}
declare class PropertyType__char16 mixins PropertyType {}
declare class PropertyType__boolean mixins PropertyType {}
declare class PropertyType__string mixins PropertyType {}
declare class PropertyType__inspectable mixins PropertyType {}
declare class PropertyType__dateTime mixins PropertyType {}
declare class PropertyType__timeSpan mixins PropertyType {}
declare class PropertyType__guid mixins PropertyType {}
declare class PropertyType__point mixins PropertyType {}
declare class PropertyType__size mixins PropertyType {}
declare class PropertyType__rect mixins PropertyType {}
declare class PropertyType__otherType mixins PropertyType {}
declare class PropertyType__uInt8Array mixins PropertyType {}
declare class PropertyType__int16Array mixins PropertyType {}
declare class PropertyType__uInt16Array mixins PropertyType {}
declare class PropertyType__int32Array mixins PropertyType {}
declare class PropertyType__uInt32Array mixins PropertyType {}
declare class PropertyType__int64Array mixins PropertyType {}
declare class PropertyType__uInt64Array mixins PropertyType {}
declare class PropertyType__singleArray mixins PropertyType {}
declare class PropertyType__doubleArray mixins PropertyType {}
declare class PropertyType__char16Array mixins PropertyType {}
declare class PropertyType__booleanArray mixins PropertyType {}
declare class PropertyType__stringArray mixins PropertyType {}
declare class PropertyType__inspectableArray mixins PropertyType {}
declare class PropertyType__dateTimeArray mixins PropertyType {}
declare class PropertyType__timeSpanArray mixins PropertyType {}
declare class PropertyType__guidArray mixins PropertyType {}
declare class PropertyType__pointArray mixins PropertyType {}
declare class PropertyType__sizeArray mixins PropertyType {}
declare class PropertyType__rectArray mixins PropertyType {}
declare class PropertyType__otherTypeArray mixins PropertyType {}

	declare export interface Point {
x: number,
y: number
} 
	declare export interface Size {
width: number,
height: number
} 
	declare export interface Rect {
x: number,
y: number,
width: number,
height: number
} 
	declare export interface DateTime {
universalTime: number
} 
	declare export interface TimeSpan {
duration: number
} 
	declare export interface IPropertyValue {
isNumericScalar: boolean,
type: Windows$Windows$Foundation.PropertyType,
getUInt8(): number,
getInt16(): number,
getUInt16(): number,
getInt32(): number,
getUInt32(): number,
getInt64(): number,
getUInt64(): number,
getSingle(): number,
getDouble(): number,
getChar16(): string,
getBoolean(): boolean,
getString(): string,
getGuid(): string,
getDateTime(): Date,
getTimeSpan(): number,
getPoint(): Windows$Windows$Foundation.Point,
getSize(): Windows$Windows$Foundation.Size,
getRect(): Windows$Windows$Foundation.Rect,
getUInt8Array(): Uint8Array,
getInt16Array(): Int16Array,
getUInt16Array(): Uint16Array,
getInt32Array(): Int32Array,
getUInt32Array(): Uint32Array,
getInt64Array(): number[],
getUInt64Array(): number[],
getSingleArray(): Float32Array,
getDoubleArray(): Float64Array,
getChar16Array(): string[],
getBooleanArray(): boolean[],
getStringArray(): string[],
getInspectableArray(): any[],
getGuidArray(): string[],
getDateTimeArray(): Date[],
getTimeSpanArray(): number[],
getPointArray(): Windows$Windows$Foundation.Point[],
getSizeArray(): Windows$Windows$Foundation.Size[],
getRectArray(): Windows$Windows$Foundation.Rect[]
} 
	declare export interface IPropertyValueStatics {
createEmpty(): any,
createUInt8(value: number): any,
createInt16(value: number): any,
createUInt16(value: number): any,
createInt32(value: number): any,
createUInt32(value: number): any,
createInt64(value: number): any,
createUInt64(value: number): any,
createSingle(value: number): any,
createDouble(value: number): any,
createChar16(value: string): any,
createBoolean(value: boolean): any,
createString(value: string): any,
createInspectable(value: any): any,
createGuid(value: string): any,
createDateTime(value: Date): any,
createTimeSpan(value: number): any,
createPoint(value: Windows$Windows$Foundation.Point): any,
createSize(value: Windows$Windows$Foundation.Size): any,
createRect(value: Windows$Windows$Foundation.Rect): any,
createUInt8Array(value: Uint8Array): any,
createInt16Array(value: Int16Array): any,
createUInt16Array(value: Uint16Array): any,
createInt32Array(value: Int32Array): any,
createUInt32Array(value: Uint32Array): any,
createInt64Array(value: number[]): any,
createUInt64Array(value: number[]): any,
createSingleArray(value: Float32Array): any,
createDoubleArray(value: Float64Array): any,
createChar16Array(value: string[]): any,
createBooleanArray(value: boolean[]): any,
createStringArray(value: string[]): any,
createInspectableArray(value: any[]): any,
createGuidArray(value: string[]): any,
createDateTimeArray(value: Date[]): any,
createTimeSpanArray(value: number[]): any,
createPointArray(value: Windows$Windows$Foundation.Point[]): any,
createSizeArray(value: Windows$Windows$Foundation.Size[]): any,
createRectArray(value: Windows$Windows$Foundation.Rect[]): any
} 
	declare export class PropertyValue  {
static createEmpty(): any;
static createUInt8(value: number): any;
static createInt16(value: number): any;
static createUInt16(value: number): any;
static createInt32(value: number): any;
static createUInt32(value: number): any;
static createInt64(value: number): any;
static createUInt64(value: number): any;
static createSingle(value: number): any;
static createDouble(value: number): any;
static createChar16(value: string): any;
static createBoolean(value: boolean): any;
static createString(value: string): any;
static createInspectable(value: any): any;
static createGuid(value: string): any;
static createDateTime(value: Date): any;
static createTimeSpan(value: number): any;
static createPoint(value: Windows$Windows$Foundation.Point): any;
static createSize(value: Windows$Windows$Foundation.Size): any;
static createRect(value: Windows$Windows$Foundation.Rect): any;
static createUInt8Array(value: Uint8Array): any;
static createInt16Array(value: Int16Array): any;
static createUInt16Array(value: Uint16Array): any;
static createInt32Array(value: Int32Array): any;
static createUInt32Array(value: Uint32Array): any;
static createInt64Array(value: number[]): any;
static createUInt64Array(value: number[]): any;
static createSingleArray(value: Float32Array): any;
static createDoubleArray(value: Float64Array): any;
static createChar16Array(value: string[]): any;
static createBooleanArray(value: boolean[]): any;
static createStringArray(value: string[]): any;
static createInspectableArray(value: any[]): any;
static createGuidArray(value: string[]): any;
static createDateTimeArray(value: Date[]): any;
static createTimeSpanArray(value: number[]): any;
static createPointArray(value: Windows$Windows$Foundation.Point[]): any;
static createSizeArray(value: Windows$Windows$Foundation.Size[]): any;
static createRectArray(value: Windows$Windows$Foundation.Rect[]): any
}
	declare export interface AsyncActionCompletedHandler {
(asyncInfo: Windows$Windows$Foundation.IAsyncAction, asyncStatus: Windows$Windows$Foundation.AsyncStatus): void
} 
	declare export  class AsyncStatus {
  constructor(...args: empty): mixed;
static +canceled: Class<AsyncStatus__canceled> & AsyncStatus__canceled & 0;// 0
static +completed: Class<AsyncStatus__completed> & AsyncStatus__completed & 1;// 1
static +error: Class<AsyncStatus__error> & AsyncStatus__error & 2;// 2
static +started: Class<AsyncStatus__started> & AsyncStatus__started & 3;// 3

}

declare class AsyncStatus__canceled mixins AsyncStatus {}
declare class AsyncStatus__completed mixins AsyncStatus {}
declare class AsyncStatus__error mixins AsyncStatus {}
declare class AsyncStatus__started mixins AsyncStatus {}

	declare export interface EventRegistrationToken {
value: number
} 
	declare export interface HResult {
value: number
} 
	declare export interface IAsyncInfo {
errorCode: number,
id: number,
status: Windows$Windows$Foundation.AsyncStatus,
cancel(): void,
close(): void
} 
	declare export type IAsyncAction = {
then<U>(
success?: () => Foundation$IPromise<U>,
error?: (error: any) => Foundation$IPromise<U>,
progress?: (progress: any) => void): Foundation$IPromise<U>,
then<U>(
success?: () => Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Foundation$IPromise<U>,
then<U>(
success?: () => U,
error?: (error: any) => Foundation$IPromise<U>,
progress?: (progress: any) => void): Foundation$IPromise<U>,
then<U>(
success?: () => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Foundation$IPromise<U>,
done?: <U>(
success?: () => any,
error?: (error: any) => any,
progress?: (progress: any) => void) => void,
cancel(): void,
completed: Windows$Windows$Foundation.AsyncActionCompletedHandler,
getResults(): void
} & undefined.IAsyncInfo

	declare export interface AsyncOperationWithProgressCompletedHandler<TResult, TProgress> {
(asyncInfo: Windows$Windows$Foundation.IAsyncOperationWithProgress<TResult, TProgress>, asyncStatus: Windows$Windows$Foundation.AsyncStatus): void
} 
	declare export type IAsyncOperationWithProgress<TResult, TProgress> = {
operation: {
progress: Windows$Windows$Foundation.AsyncOperationProgressHandler<TResult, TProgress>,
completed: Windows$Windows$Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress>,
getResults(): TResult
}
} & undefined.Foundation$IPromise<TResult>

	declare export interface AsyncOperationCompletedHandler<TResult> {
(asyncInfo: Windows$Windows$Foundation.IAsyncOperation<TResult>, asyncStatus: Windows$Windows$Foundation.AsyncStatus): void
} 
	declare export type IAsyncOperation<TResult> = {
operation: {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<TResult>,
getResults(): TResult
}
} & undefined.Foundation$IPromise<TResult>

	declare export interface AsyncActionWithProgressCompletedHandler<TProgress> {
(asyncInfo: Windows$Windows$Foundation.IAsyncActionWithProgress<TProgress>, asyncStatus: Windows$Windows$Foundation.AsyncStatus): void
} 
	declare export type IAsyncActionWithProgress<TProgress> = {
progress: Windows$Windows$Foundation.AsyncActionProgressHandler<TProgress>,
completed: Windows$Windows$Foundation.AsyncActionWithProgressCompletedHandler<TProgress>,
getResults(): void
} & undefined.IAsyncInfo & undefined.Foundation$IPromise<void>

	declare export interface AsyncOperationProgressHandler<TResult, TProgress> {
(asyncInfo: Windows$Windows$Foundation.IAsyncOperationWithProgress<TResult, TProgress>, progressInfo: TProgress): void
} 
	declare export interface AsyncActionProgressHandler<TProgress> {
(asyncInfo: Windows$Windows$Foundation.IAsyncActionWithProgress<TProgress>, progressInfo: TProgress): void
} 
	declare export type IReference<T> = {
value: T
} & undefined.IPropertyValue

	declare export type IReferenceArray<T> = {
value: T[]
} & undefined.IPropertyValue

	declare export interface TypedEventHandler<TSender, TResult> {
(sender: TSender, args: TResult): void
} 
	declare export interface EventHandler<T> {
(sender: any, args: T): void
} 
	declare module 'Metadata' {
        declare export class WebHostHiddenAttribute  {}
	declare export class VariantAttribute  {}
	declare export class HasVariantAttribute  {}
	declare export class DualApiPartitionAttribute  {}
	declare export class MuseAttribute  {}
	declare export  class GCPressureAmount {
  constructor(...args: empty): mixed;
static +low: Class<GCPressureAmount__low> & GCPressureAmount__low & 0;// 0
static +medium: Class<GCPressureAmount__medium> & GCPressureAmount__medium & 1;// 1
static +high: Class<GCPressureAmount__high> & GCPressureAmount__high & 2;// 2

}

declare class GCPressureAmount__low mixins GCPressureAmount {}
declare class GCPressureAmount__medium mixins GCPressureAmount {}
declare class GCPressureAmount__high mixins GCPressureAmount {}

	declare export class GCPressureAttribute  {}
	declare export class ActivatableAttribute  {
constructor(version: number): this;
constructor(type: string, version: number): this
}
	declare export class VersionAttribute  {
constructor(version: number): this
}
	declare export class AllowMultipleAttribute  {}
	declare export class AttributeUsageAttribute  {
constructor(targets: Windows$Windows$Foundation.Metadata.AttributeTargets): this
}
	declare export  class AttributeTargets {
  constructor(...args: empty): mixed;
static +all: Class<AttributeTargets__all> & AttributeTargets__all & 0;// 0
static +delegate: Class<AttributeTargets__delegate> & AttributeTargets__delegate & 1;// 1
static +enum: Class<AttributeTargets__enum> & AttributeTargets__enum & 2;// 2
static +event: Class<AttributeTargets__event> & AttributeTargets__event & 3;// 3
static +field: Class<AttributeTargets__field> & AttributeTargets__field & 4;// 4
static +interface: Class<AttributeTargets__interface> & AttributeTargets__interface & 5;// 5
static +method: Class<AttributeTargets__method> & AttributeTargets__method & 6;// 6
static +parameter: Class<AttributeTargets__parameter> & AttributeTargets__parameter & 7;// 7
static +property: Class<AttributeTargets__property> & AttributeTargets__property & 8;// 8
static +runtimeClass: Class<AttributeTargets__runtimeClass> & AttributeTargets__runtimeClass & 9;// 9
static +struct: Class<AttributeTargets__struct> & AttributeTargets__struct & 10;// 10
static +interfaceImpl: Class<AttributeTargets__interfaceImpl> & AttributeTargets__interfaceImpl & 11;// 11

}

declare class AttributeTargets__all mixins AttributeTargets {}
declare class AttributeTargets__delegate mixins AttributeTargets {}
declare class AttributeTargets__enum mixins AttributeTargets {}
declare class AttributeTargets__event mixins AttributeTargets {}
declare class AttributeTargets__field mixins AttributeTargets {}
declare class AttributeTargets__interface mixins AttributeTargets {}
declare class AttributeTargets__method mixins AttributeTargets {}
declare class AttributeTargets__parameter mixins AttributeTargets {}
declare class AttributeTargets__property mixins AttributeTargets {}
declare class AttributeTargets__runtimeClass mixins AttributeTargets {}
declare class AttributeTargets__struct mixins AttributeTargets {}
declare class AttributeTargets__interfaceImpl mixins AttributeTargets {}

	declare export class DefaultOverloadAttribute  {}
	declare export class DefaultAttribute  {}
	declare export class GuidAttribute  {
constructor(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number): this
}
	declare export class ComposableAttribute  {
constructor(type: string, compositionType: Windows$Windows$Foundation.Metadata.CompositionType, version: number): this
}
	declare export  class CompositionType {
  constructor(...args: empty): mixed;
static +protected: Class<CompositionType__protected> & CompositionType__protected & 0;// 0
static +public: Class<CompositionType__public> & CompositionType__public & 1;// 1

}

declare class CompositionType__protected mixins CompositionType {}
declare class CompositionType__public mixins CompositionType {}

	declare export class OverloadAttribute  {
constructor(method: string): this
}
	declare export class StaticAttribute  {
constructor(type: string, version: number): this
}
	declare export class OverridableAttribute  {}
	declare export class ProtectedAttribute  {}
	declare export class ThreadingAttribute  {
constructor(model: Windows$Windows$Foundation.Metadata.ThreadingModel): this
}
	declare export  class ThreadingModel {
  constructor(...args: empty): mixed;
static +sTA: Class<ThreadingModel__sTA> & ThreadingModel__sTA & 0;// 0
static +mTA: Class<ThreadingModel__mTA> & ThreadingModel__mTA & 1;// 1
static +both: Class<ThreadingModel__both> & ThreadingModel__both & 2;// 2
static +invalidThreading: Class<ThreadingModel__invalidThreading> & ThreadingModel__invalidThreading & 3;// 3

}

declare class ThreadingModel__sTA mixins ThreadingModel {}
declare class ThreadingModel__mTA mixins ThreadingModel {}
declare class ThreadingModel__both mixins ThreadingModel {}
declare class ThreadingModel__invalidThreading mixins ThreadingModel {}

	declare export class MarshalingBehaviorAttribute  {
constructor(behavior: Windows$Windows$Foundation.Metadata.MarshalingType): this
}
	declare export  class MarshalingType {
  constructor(...args: empty): mixed;
static +none: Class<MarshalingType__none> & MarshalingType__none & 0;// 0
static +agile: Class<MarshalingType__agile> & MarshalingType__agile & 1;// 1
static +standard: Class<MarshalingType__standard> & MarshalingType__standard & 2;// 2
static +invalidMarshaling: Class<MarshalingType__invalidMarshaling> & MarshalingType__invalidMarshaling & 3;// 3

}

declare class MarshalingType__none mixins MarshalingType {}
declare class MarshalingType__agile mixins MarshalingType {}
declare class MarshalingType__standard mixins MarshalingType {}
declare class MarshalingType__invalidMarshaling mixins MarshalingType {}

	declare export class ExclusiveToAttribute  {
constructor(typeName: string): this
}
	declare export class LengthIsAttribute  {
constructor(indexLengthParameter: number): this
}
	declare export class RangeAttribute  {
constructor(minValue: number, maxValue: number): this
}
    }

	declare module 'Diagnostics' {
        declare export  class ErrorOptions {
  constructor(...args: empty): mixed;
static +none: Class<ErrorOptions__none> & ErrorOptions__none & 0;// 0
static +suppressExceptions: Class<ErrorOptions__suppressExceptions> & ErrorOptions__suppressExceptions & 1;// 1
static +forceExceptions: Class<ErrorOptions__forceExceptions> & ErrorOptions__forceExceptions & 2;// 2
static +useSetErrorInfo: Class<ErrorOptions__useSetErrorInfo> & ErrorOptions__useSetErrorInfo & 3;// 3
static +suppressSetErrorInfo: Class<ErrorOptions__suppressSetErrorInfo> & ErrorOptions__suppressSetErrorInfo & 4;// 4

}

declare class ErrorOptions__none mixins ErrorOptions {}
declare class ErrorOptions__suppressExceptions mixins ErrorOptions {}
declare class ErrorOptions__forceExceptions mixins ErrorOptions {}
declare class ErrorOptions__useSetErrorInfo mixins ErrorOptions {}
declare class ErrorOptions__suppressSetErrorInfo mixins ErrorOptions {}

	declare export interface IErrorReportingSettings {
setErrorOptions(value: Windows$Windows$Foundation.Diagnostics.ErrorOptions): void,
getErrorOptions(): Windows$Windows$Foundation.Diagnostics.ErrorOptions
} 
	declare export class RuntimeBrokerErrorSettings mixins undefined.IErrorReportingSettings {
setErrorOptions(value: Windows$Windows$Foundation.Diagnostics.ErrorOptions): void;
getErrorOptions(): Windows$Windows$Foundation.Diagnostics.ErrorOptions
}
    }

    }


declare module 'ApplicationModel' {
        declare module 'Background' {
        declare export  class BackgroundAccessStatus {
  constructor(...args: empty): mixed;
static +unspecified: Class<BackgroundAccessStatus__unspecified> & BackgroundAccessStatus__unspecified & 0;// 0
static +allowedWithAlwaysOnRealTimeConnectivity: Class<BackgroundAccessStatus__allowedWithAlwaysOnRealTimeConnectivity> & BackgroundAccessStatus__allowedWithAlwaysOnRealTimeConnectivity & 1;// 1
static +allowedMayUseActiveRealTimeConnectivity: Class<BackgroundAccessStatus__allowedMayUseActiveRealTimeConnectivity> & BackgroundAccessStatus__allowedMayUseActiveRealTimeConnectivity & 2;// 2
static +denied: Class<BackgroundAccessStatus__denied> & BackgroundAccessStatus__denied & 3;// 3

}

declare class BackgroundAccessStatus__unspecified mixins BackgroundAccessStatus {}
declare class BackgroundAccessStatus__allowedWithAlwaysOnRealTimeConnectivity mixins BackgroundAccessStatus {}
declare class BackgroundAccessStatus__allowedMayUseActiveRealTimeConnectivity mixins BackgroundAccessStatus {}
declare class BackgroundAccessStatus__denied mixins BackgroundAccessStatus {}

	declare export interface IBackgroundExecutionManagerStatics {
requestAccessAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$ApplicationModel.Background.BackgroundAccessStatus>,
requestAccessAsync(
applicationId: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$ApplicationModel.Background.BackgroundAccessStatus>,
removeAccess(): void,
removeAccess(applicationId: string): void,
getAccessStatus(): Windows$Windows$ApplicationModel.Background.BackgroundAccessStatus,
getAccessStatus(
applicationId: string): Windows$Windows$ApplicationModel.Background.BackgroundAccessStatus
} 
	declare export class BackgroundExecutionManager  {
static requestAccessAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$ApplicationModel.Background.BackgroundAccessStatus>;
static requestAccessAsync(
applicationId: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$ApplicationModel.Background.BackgroundAccessStatus>;
static removeAccess(): void;
static removeAccess(applicationId: string): void;
static getAccessStatus(): Windows$Windows$ApplicationModel.Background.BackgroundAccessStatus;
static getAccessStatus(
applicationId: string): Windows$Windows$ApplicationModel.Background.BackgroundAccessStatus
}
	declare export  class BackgroundTaskCancellationReason {
  constructor(...args: empty): mixed;
static +abort: Class<BackgroundTaskCancellationReason__abort> & BackgroundTaskCancellationReason__abort & 0;// 0
static +terminating: Class<BackgroundTaskCancellationReason__terminating> & BackgroundTaskCancellationReason__terminating & 1;// 1
static +loggingOff: Class<BackgroundTaskCancellationReason__loggingOff> & BackgroundTaskCancellationReason__loggingOff & 2;// 2
static +servicingUpdate: Class<BackgroundTaskCancellationReason__servicingUpdate> & BackgroundTaskCancellationReason__servicingUpdate & 3;// 3

}

declare class BackgroundTaskCancellationReason__abort mixins BackgroundTaskCancellationReason {}
declare class BackgroundTaskCancellationReason__terminating mixins BackgroundTaskCancellationReason {}
declare class BackgroundTaskCancellationReason__loggingOff mixins BackgroundTaskCancellationReason {}
declare class BackgroundTaskCancellationReason__servicingUpdate mixins BackgroundTaskCancellationReason {}

	declare export interface BackgroundTaskCanceledEventHandler {
(sender: Windows$Windows$ApplicationModel.Background.IBackgroundTaskInstance, reason: Windows$Windows$ApplicationModel.Background.BackgroundTaskCancellationReason): void
} 
	declare export interface IBackgroundTaskInstance {
instanceId: string,
progress: number,
suspendedCount: number,
task: Windows$Windows$ApplicationModel.Background.BackgroundTaskRegistration,
triggerDetails: any,
oncanceled: any,
getDeferral(): Windows$Windows$ApplicationModel.Background.BackgroundTaskDeferral
} 
	declare export class BackgroundTaskRegistration mixins undefined.IBackgroundTaskRegistration {
name: string;
taskId: string;
onprogress: any;
oncompleted: any;
unregister(cancelTask: boolean): void;
static allTasks: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Background.IBackgroundTaskRegistration>
}
	declare export class BackgroundTaskDeferral mixins undefined.IBackgroundTaskDeferral {
complete(): void
}
	declare export interface BackgroundTaskProgressEventHandler {
(sender: Windows$Windows$ApplicationModel.Background.BackgroundTaskRegistration, args: Windows$Windows$ApplicationModel.Background.BackgroundTaskProgressEventArgs): void
} 
	declare export class BackgroundTaskProgressEventArgs mixins undefined.IBackgroundTaskProgressEventArgs {
instanceId: string;
progress: number
}
	declare export interface BackgroundTaskCompletedEventHandler {
(sender: Windows$Windows$ApplicationModel.Background.BackgroundTaskRegistration, args: Windows$Windows$ApplicationModel.Background.BackgroundTaskCompletedEventArgs): void
} 
	declare export class BackgroundTaskCompletedEventArgs mixins undefined.IBackgroundTaskCompletedEventArgs {
instanceId: string;
checkResult(): void
}
	declare export interface IBackgroundTaskDeferral {
complete(): void
} 
	declare export interface IBackgroundTask {
run(
taskInstance: Windows$Windows$ApplicationModel.Background.IBackgroundTaskInstance): void
} 
	declare export interface IBackgroundTaskRegistration {
name: string,
taskId: string,
onprogress: any,
oncompleted: any,
unregister(cancelTask: boolean): void
} 
	declare export interface IBackgroundTaskRegistrationStatics {
allTasks: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Background.IBackgroundTaskRegistration>
} 
	declare export interface IBackgroundTaskBuilder {
name: string,
taskEntryPoint: string,
setTrigger(trigger: Windows$Windows$ApplicationModel.Background.IBackgroundTrigger): void,
addCondition(
condition: Windows$Windows$ApplicationModel.Background.IBackgroundCondition): void,
register(): Windows$Windows$ApplicationModel.Background.BackgroundTaskRegistration
} 
	declare export interface IBackgroundTrigger {} 
	declare export interface IBackgroundCondition {} 
	declare export interface IBackgroundTaskCompletedEventArgs {
instanceId: string,
checkResult(): void
} 
	declare export interface IBackgroundTaskProgressEventArgs {
instanceId: string,
progress: number
} 
	declare export class BackgroundTaskBuilder mixins undefined.IBackgroundTaskBuilder {
name: string;
taskEntryPoint: string;
setTrigger(trigger: Windows$Windows$ApplicationModel.Background.IBackgroundTrigger): void;
addCondition(
condition: Windows$Windows$ApplicationModel.Background.IBackgroundCondition): void;
register(): Windows$Windows$ApplicationModel.Background.BackgroundTaskRegistration
}
	declare export  class SystemTriggerType {
  constructor(...args: empty): mixed;
static +invalid: Class<SystemTriggerType__invalid> & SystemTriggerType__invalid & 0;// 0
static +smsReceived: Class<SystemTriggerType__smsReceived> & SystemTriggerType__smsReceived & 1;// 1
static +userPresent: Class<SystemTriggerType__userPresent> & SystemTriggerType__userPresent & 2;// 2
static +userAway: Class<SystemTriggerType__userAway> & SystemTriggerType__userAway & 3;// 3
static +networkStateChange: Class<SystemTriggerType__networkStateChange> & SystemTriggerType__networkStateChange & 4;// 4
static +controlChannelReset: Class<SystemTriggerType__controlChannelReset> & SystemTriggerType__controlChannelReset & 5;// 5
static +internetAvailable: Class<SystemTriggerType__internetAvailable> & SystemTriggerType__internetAvailable & 6;// 6
static +sessionConnected: Class<SystemTriggerType__sessionConnected> & SystemTriggerType__sessionConnected & 7;// 7
static +servicingComplete: Class<SystemTriggerType__servicingComplete> & SystemTriggerType__servicingComplete & 8;// 8
static +lockScreenApplicationAdded: Class<SystemTriggerType__lockScreenApplicationAdded> & SystemTriggerType__lockScreenApplicationAdded & 9;// 9
static +lockScreenApplicationRemoved: Class<SystemTriggerType__lockScreenApplicationRemoved> & SystemTriggerType__lockScreenApplicationRemoved & 10;// 10
static +timeZoneChange: Class<SystemTriggerType__timeZoneChange> & SystemTriggerType__timeZoneChange & 11;// 11
static +onlineIdConnectedStateChange: Class<SystemTriggerType__onlineIdConnectedStateChange> & SystemTriggerType__onlineIdConnectedStateChange & 12;// 12

}

declare class SystemTriggerType__invalid mixins SystemTriggerType {}
declare class SystemTriggerType__smsReceived mixins SystemTriggerType {}
declare class SystemTriggerType__userPresent mixins SystemTriggerType {}
declare class SystemTriggerType__userAway mixins SystemTriggerType {}
declare class SystemTriggerType__networkStateChange mixins SystemTriggerType {}
declare class SystemTriggerType__controlChannelReset mixins SystemTriggerType {}
declare class SystemTriggerType__internetAvailable mixins SystemTriggerType {}
declare class SystemTriggerType__sessionConnected mixins SystemTriggerType {}
declare class SystemTriggerType__servicingComplete mixins SystemTriggerType {}
declare class SystemTriggerType__lockScreenApplicationAdded mixins SystemTriggerType {}
declare class SystemTriggerType__lockScreenApplicationRemoved mixins SystemTriggerType {}
declare class SystemTriggerType__timeZoneChange mixins SystemTriggerType {}
declare class SystemTriggerType__onlineIdConnectedStateChange mixins SystemTriggerType {}

	declare export  class SystemConditionType {
  constructor(...args: empty): mixed;
static +invalid: Class<SystemConditionType__invalid> & SystemConditionType__invalid & 0;// 0
static +userPresent: Class<SystemConditionType__userPresent> & SystemConditionType__userPresent & 1;// 1
static +userNotPresent: Class<SystemConditionType__userNotPresent> & SystemConditionType__userNotPresent & 2;// 2
static +internetAvailable: Class<SystemConditionType__internetAvailable> & SystemConditionType__internetAvailable & 3;// 3
static +internetNotAvailable: Class<SystemConditionType__internetNotAvailable> & SystemConditionType__internetNotAvailable & 4;// 4
static +sessionConnected: Class<SystemConditionType__sessionConnected> & SystemConditionType__sessionConnected & 5;// 5
static +sessionDisconnected: Class<SystemConditionType__sessionDisconnected> & SystemConditionType__sessionDisconnected & 6;// 6

}

declare class SystemConditionType__invalid mixins SystemConditionType {}
declare class SystemConditionType__userPresent mixins SystemConditionType {}
declare class SystemConditionType__userNotPresent mixins SystemConditionType {}
declare class SystemConditionType__internetAvailable mixins SystemConditionType {}
declare class SystemConditionType__internetNotAvailable mixins SystemConditionType {}
declare class SystemConditionType__sessionConnected mixins SystemConditionType {}
declare class SystemConditionType__sessionDisconnected mixins SystemConditionType {}

	declare export type ISystemTrigger = {
oneShot: boolean,
triggerType: Windows$Windows$ApplicationModel.Background.SystemTriggerType
} & undefined.IBackgroundTrigger

	declare export interface ISystemTriggerFactory {
create(
triggerType: Windows$Windows$ApplicationModel.Background.SystemTriggerType,
oneShot: boolean): Windows$Windows$ApplicationModel.Background.SystemTrigger
} 
	declare export class SystemTrigger mixins undefined.ISystemTrigger, undefined.IBackgroundTrigger {
constructor(triggerType: Windows$Windows$ApplicationModel.Background.SystemTriggerType, oneShot: boolean): this;
oneShot: boolean;
triggerType: Windows$Windows$ApplicationModel.Background.SystemTriggerType
}
	declare export type ISystemCondition = {
conditionType: Windows$Windows$ApplicationModel.Background.SystemConditionType
} & undefined.IBackgroundCondition

	declare export interface ISystemConditionFactory {
create(
conditionType: Windows$Windows$ApplicationModel.Background.SystemConditionType): Windows$Windows$ApplicationModel.Background.SystemCondition
} 
	declare export class SystemCondition mixins undefined.ISystemCondition, undefined.IBackgroundCondition {
constructor(conditionType: Windows$Windows$ApplicationModel.Background.SystemConditionType): this;
conditionType: Windows$Windows$ApplicationModel.Background.SystemConditionType
}
	declare export type INetworkOperatorNotificationTrigger = {
networkAccountId: string
} & undefined.IBackgroundTrigger

	declare export interface INetworkOperatorNotificationTriggerFactory {
create(
networkAccountId: string): Windows$Windows$ApplicationModel.Background.NetworkOperatorNotificationTrigger
} 
	declare export class NetworkOperatorNotificationTrigger mixins undefined.INetworkOperatorNotificationTrigger, undefined.IBackgroundTrigger {
constructor(networkAccountId: string): this;
networkAccountId: string
}
	declare export type ITimeTrigger = {
freshnessTime: number,
oneShot: boolean
} & undefined.IBackgroundTrigger

	declare export interface ITimeTriggerFactory {
create(
freshnessTime: number,
oneShot: boolean): Windows$Windows$ApplicationModel.Background.TimeTrigger
} 
	declare export class TimeTrigger mixins undefined.ITimeTrigger, undefined.IBackgroundTrigger {
constructor(freshnessTime: number, oneShot: boolean): this;
freshnessTime: number;
oneShot: boolean
}
	declare export type IMaintenanceTrigger = {
freshnessTime: number,
oneShot: boolean
} & undefined.IBackgroundTrigger

	declare export interface IMaintenanceTriggerFactory {
create(
freshnessTime: number,
oneShot: boolean): Windows$Windows$ApplicationModel.Background.MaintenanceTrigger
} 
	declare export class MaintenanceTrigger mixins undefined.IMaintenanceTrigger, undefined.IBackgroundTrigger {
constructor(freshnessTime: number, oneShot: boolean): this;
freshnessTime: number;
oneShot: boolean
}
	declare export type INetworkOperatorHotspotAuthenticationTrigger = {} & undefined.IBackgroundTrigger

	declare export class NetworkOperatorHotspotAuthenticationTrigger mixins undefined.INetworkOperatorHotspotAuthenticationTrigger, undefined.IBackgroundTrigger {}
	declare export interface IPushNotificationTriggerFactory {
create(
applicationId: string): Windows$Windows$ApplicationModel.Background.PushNotificationTrigger
} 
	declare export class PushNotificationTrigger mixins undefined.IBackgroundTrigger {
constructor(applicationId: string): this;
constructor(): this
}
    }

	declare module 'Contacts' {
        declare export  class ContactFieldType {
  constructor(...args: empty): mixed;
static +email: Class<ContactFieldType__email> & ContactFieldType__email & 0;// 0
static +phoneNumber: Class<ContactFieldType__phoneNumber> & ContactFieldType__phoneNumber & 1;// 1
static +location: Class<ContactFieldType__location> & ContactFieldType__location & 2;// 2
static +instantMessage: Class<ContactFieldType__instantMessage> & ContactFieldType__instantMessage & 3;// 3
static +custom: Class<ContactFieldType__custom> & ContactFieldType__custom & 4;// 4

}

declare class ContactFieldType__email mixins ContactFieldType {}
declare class ContactFieldType__phoneNumber mixins ContactFieldType {}
declare class ContactFieldType__location mixins ContactFieldType {}
declare class ContactFieldType__instantMessage mixins ContactFieldType {}
declare class ContactFieldType__custom mixins ContactFieldType {}

	declare export  class ContactFieldCategory {
  constructor(...args: empty): mixed;
static +none: Class<ContactFieldCategory__none> & ContactFieldCategory__none & 0;// 0
static +home: Class<ContactFieldCategory__home> & ContactFieldCategory__home & 1;// 1
static +work: Class<ContactFieldCategory__work> & ContactFieldCategory__work & 2;// 2
static +mobile: Class<ContactFieldCategory__mobile> & ContactFieldCategory__mobile & 3;// 3
static +other: Class<ContactFieldCategory__other> & ContactFieldCategory__other & 4;// 4

}

declare class ContactFieldCategory__none mixins ContactFieldCategory {}
declare class ContactFieldCategory__home mixins ContactFieldCategory {}
declare class ContactFieldCategory__work mixins ContactFieldCategory {}
declare class ContactFieldCategory__mobile mixins ContactFieldCategory {}
declare class ContactFieldCategory__other mixins ContactFieldCategory {}

	declare export  class ContactSelectionMode {
  constructor(...args: empty): mixed;
static +contacts: Class<ContactSelectionMode__contacts> & ContactSelectionMode__contacts & 0;// 0
static +fields: Class<ContactSelectionMode__fields> & ContactSelectionMode__fields & 1;// 1

}

declare class ContactSelectionMode__contacts mixins ContactSelectionMode {}
declare class ContactSelectionMode__fields mixins ContactSelectionMode {}

	declare export interface IContactField {
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory,
name: string,
type: Windows$Windows$ApplicationModel.Contacts.ContactFieldType,
value: string
} 
	declare export class ContactField mixins undefined.IContactField {
constructor(value: string, type: Windows$Windows$ApplicationModel.Contacts.ContactFieldType): this;
constructor(value: string, type: Windows$Windows$ApplicationModel.Contacts.ContactFieldType, category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory): this;
constructor(name: string, value: string, type: Windows$Windows$ApplicationModel.Contacts.ContactFieldType, category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory): this;
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory;
name: string;
type: Windows$Windows$ApplicationModel.Contacts.ContactFieldType;
value: string
}
	declare export type IContactLocationField = {
city: string,
country: string,
postalCode: string,
region: string,
street: string,
unstructuredAddress: string
} & undefined.IContactField

	declare export class ContactLocationField mixins undefined.IContactLocationField, undefined.IContactField {
constructor(unstructuredAddress: string): this;
constructor(unstructuredAddress: string, category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory): this;
constructor(unstructuredAddress: string, category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory, street: string, city: string, region: string, country: string, postalCode: string): this;
city: string;
country: string;
postalCode: string;
region: string;
street: string;
unstructuredAddress: string;
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory;
name: string;
type: Windows$Windows$ApplicationModel.Contacts.ContactFieldType;
value: string
}
	declare export type IContactInstantMessageField = {
displayText: string,
launchUri: Windows$Windows$Foundation.Uri,
service: string,
userName: string
} & undefined.IContactField

	declare export class ContactInstantMessageField mixins undefined.IContactInstantMessageField, undefined.IContactField {
constructor(userName: string): this;
constructor(userName: string, category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory): this;
constructor(userName: string, category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory, service: string, displayText: string, verb: Windows$Windows$Foundation.Uri): this;
displayText: string;
launchUri: Windows$Windows$Foundation.Uri;
service: string;
userName: string;
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory;
name: string;
type: Windows$Windows$ApplicationModel.Contacts.ContactFieldType;
value: string
}
	declare export interface IKnownContactFieldStatics {
email: string,
instantMessage: string,
location: string,
phoneNumber: string,
convertNameToType(name: string): Windows$Windows$ApplicationModel.Contacts.ContactFieldType,
convertTypeToName(type: Windows$Windows$ApplicationModel.Contacts.ContactFieldType): string
} 
	declare export class KnownContactField  {
static email: string;
static instantMessage: string;
static location: string;
static phoneNumber: string;
static convertNameToType(name: string): Windows$Windows$ApplicationModel.Contacts.ContactFieldType;
static convertTypeToName(type: Windows$Windows$ApplicationModel.Contacts.ContactFieldType): string
}
	declare export interface IContactInformation {
customFields: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Contacts.ContactField>,
emails: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Contacts.ContactField>,
instantMessages: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Contacts.ContactInstantMessageField>,
locations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Contacts.ContactLocationField>,
name: string,
phoneNumbers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Contacts.ContactField>,
getThumbnailAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IRandomAccessStreamWithContentType>,
queryCustomFields(
customName: string): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Contacts.ContactField>
} 
	declare export class ContactInformation mixins undefined.IContactInformation {
customFields: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Contacts.ContactField>;
emails: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Contacts.ContactField>;
instantMessages: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Contacts.ContactInstantMessageField>;
locations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Contacts.ContactLocationField>;
name: string;
phoneNumbers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Contacts.ContactField>;
getThumbnailAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IRandomAccessStreamWithContentType>;
queryCustomFields(
customName: string): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Contacts.ContactField>
}
	declare export interface IContactPicker {
commitButtonText: string,
desiredFields: Windows$Windows$Foundation.Collections.IVector<string>,
selectionMode: Windows$Windows$ApplicationModel.Contacts.ContactSelectionMode,
pickSingleContactAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$ApplicationModel.Contacts.ContactInformation>,
pickMultipleContactsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Contacts.ContactInformation>>
} 
	declare export class ContactPicker mixins undefined.IContactPicker {
commitButtonText: string;
desiredFields: Windows$Windows$Foundation.Collections.IVector<string>;
selectionMode: Windows$Windows$ApplicationModel.Contacts.ContactSelectionMode;
pickSingleContactAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$ApplicationModel.Contacts.ContactInformation>;
pickMultipleContactsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Contacts.ContactInformation>>
}
	declare export interface IContact {
fields: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$ApplicationModel.Contacts.IContactField>,
name: string,
thumbnail: Windows$Windows$Storage.Streams.IRandomAccessStreamReference
} 
	declare export class Contact mixins undefined.IContact {
fields: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$ApplicationModel.Contacts.IContactField>;
name: string;
thumbnail: Windows$Windows$Storage.Streams.IRandomAccessStreamReference
}
	declare export interface IContactFieldFactory {
createField(
value: string,
type: Windows$Windows$ApplicationModel.Contacts.ContactFieldType): Windows$Windows$ApplicationModel.Contacts.ContactField,
createField(
value: string,
type: Windows$Windows$ApplicationModel.Contacts.ContactFieldType,
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory): Windows$Windows$ApplicationModel.Contacts.ContactField,
createField(
name: string,
value: string,
type: Windows$Windows$ApplicationModel.Contacts.ContactFieldType,
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory): Windows$Windows$ApplicationModel.Contacts.ContactField
} 
	declare export interface IContactLocationFieldFactory {
createLocation(
unstructuredAddress: string): Windows$Windows$ApplicationModel.Contacts.ContactLocationField,
createLocation(
unstructuredAddress: string,
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory): Windows$Windows$ApplicationModel.Contacts.ContactLocationField,
createLocation(
unstructuredAddress: string,
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory,
street: string,
city: string,
region: string,
country: string,
postalCode: string): Windows$Windows$ApplicationModel.Contacts.ContactLocationField
} 
	declare export interface IContactInstantMessageFieldFactory {
createInstantMessage(
userName: string): Windows$Windows$ApplicationModel.Contacts.ContactInstantMessageField,
createInstantMessage(
userName: string,
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory): Windows$Windows$ApplicationModel.Contacts.ContactInstantMessageField,
createInstantMessage(
userName: string,
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory,
service: string,
displayText: string,
verb: Windows$Windows$Foundation.Uri): Windows$Windows$ApplicationModel.Contacts.ContactInstantMessageField
} 
	declare export class ContactFieldFactory mixins undefined.IContactFieldFactory, undefined.IContactLocationFieldFactory, undefined.IContactInstantMessageFieldFactory {
createField(
value: string,
type: Windows$Windows$ApplicationModel.Contacts.ContactFieldType): Windows$Windows$ApplicationModel.Contacts.ContactField;
createField(
value: string,
type: Windows$Windows$ApplicationModel.Contacts.ContactFieldType,
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory): Windows$Windows$ApplicationModel.Contacts.ContactField;
createField(
name: string,
value: string,
type: Windows$Windows$ApplicationModel.Contacts.ContactFieldType,
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory): Windows$Windows$ApplicationModel.Contacts.ContactField;
createLocation(
unstructuredAddress: string): Windows$Windows$ApplicationModel.Contacts.ContactLocationField;
createLocation(
unstructuredAddress: string,
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory): Windows$Windows$ApplicationModel.Contacts.ContactLocationField;
createLocation(
unstructuredAddress: string,
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory,
street: string,
city: string,
region: string,
country: string,
postalCode: string): Windows$Windows$ApplicationModel.Contacts.ContactLocationField;
createInstantMessage(
userName: string): Windows$Windows$ApplicationModel.Contacts.ContactInstantMessageField;
createInstantMessage(
userName: string,
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory): Windows$Windows$ApplicationModel.Contacts.ContactInstantMessageField;
createInstantMessage(
userName: string,
category: Windows$Windows$ApplicationModel.Contacts.ContactFieldCategory,
service: string,
displayText: string,
verb: Windows$Windows$Foundation.Uri): Windows$Windows$ApplicationModel.Contacts.ContactInstantMessageField
}
	declare module 'Provider' {
        declare export interface IContactRemovedEventArgs {
id: string
} 
	declare export class ContactRemovedEventArgs mixins undefined.IContactRemovedEventArgs {
id: string
}
	declare export  class AddContactResult {
  constructor(...args: empty): mixed;
static +added: Class<AddContactResult__added> & AddContactResult__added & 0;// 0
static +alreadyAdded: Class<AddContactResult__alreadyAdded> & AddContactResult__alreadyAdded & 1;// 1
static +unavailable: Class<AddContactResult__unavailable> & AddContactResult__unavailable & 2;// 2

}

declare class AddContactResult__added mixins AddContactResult {}
declare class AddContactResult__alreadyAdded mixins AddContactResult {}
declare class AddContactResult__unavailable mixins AddContactResult {}

	declare export interface IContactPickerUI {
desiredFields: Windows$Windows$Foundation.Collections.IVectorView<string>,
selectionMode: Windows$Windows$ApplicationModel.Contacts.ContactSelectionMode,
addContact(
id: string,
contact: Windows$Windows$ApplicationModel.Contacts.Contact): Windows$Windows$ApplicationModel.Contacts.Provider.AddContactResult,
removeContact(id: string): void,
containsContact(id: string): boolean,
oncontactremoved: any
} 
	declare export class ContactPickerUI mixins undefined.IContactPickerUI {
desiredFields: Windows$Windows$Foundation.Collections.IVectorView<string>;
selectionMode: Windows$Windows$ApplicationModel.Contacts.ContactSelectionMode;
addContact(
id: string,
contact: Windows$Windows$ApplicationModel.Contacts.Contact): Windows$Windows$ApplicationModel.Contacts.Provider.AddContactResult;
removeContact(id: string): void;
containsContact(id: string): boolean;
oncontactremoved: any
}
	declare export interface IFileRemovedEventArgs {
id: string
} 
	declare export class FileRemovedEventArgs mixins undefined.IFileRemovedEventArgs {
id: string
}
	declare export  class AddFileResult {
  constructor(...args: empty): mixed;
static +added: Class<AddFileResult__added> & AddFileResult__added & 0;// 0
static +alreadyAdded: Class<AddFileResult__alreadyAdded> & AddFileResult__alreadyAdded & 1;// 1
static +notAllowed: Class<AddFileResult__notAllowed> & AddFileResult__notAllowed & 2;// 2
static +unavailable: Class<AddFileResult__unavailable> & AddFileResult__unavailable & 3;// 3

}

declare class AddFileResult__added mixins AddFileResult {}
declare class AddFileResult__alreadyAdded mixins AddFileResult {}
declare class AddFileResult__notAllowed mixins AddFileResult {}
declare class AddFileResult__unavailable mixins AddFileResult {}

	declare export  class FileSelectionMode {
  constructor(...args: empty): mixed;
static +single: Class<FileSelectionMode__single> & FileSelectionMode__single & 0;// 0
static +multiple: Class<FileSelectionMode__multiple> & FileSelectionMode__multiple & 1;// 1

}

declare class FileSelectionMode__single mixins FileSelectionMode {}
declare class FileSelectionMode__multiple mixins FileSelectionMode {}

	declare export interface IFileOpenPickerUI {
allowedFileTypes: Windows$Windows$Foundation.Collections.IVectorView<string>,
selectionMode: Windows$Windows$Storage.Pickers.Provider.FileSelectionMode,
settingsIdentifier: string,
title: string,
addFile(
id: string,
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Storage.Pickers.Provider.AddFileResult,
removeFile(id: string): void,
containsFile(id: string): boolean,
canAddFile(file: Windows$Windows$Storage.IStorageFile): boolean,
onfileremoved: any,
onclosing: any
} 
	declare export class FileOpenPickerUI mixins undefined.IFileOpenPickerUI {
allowedFileTypes: Windows$Windows$Foundation.Collections.IVectorView<string>;
selectionMode: Windows$Windows$Storage.Pickers.Provider.FileSelectionMode;
settingsIdentifier: string;
title: string;
addFile(
id: string,
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Storage.Pickers.Provider.AddFileResult;
removeFile(id: string): void;
containsFile(id: string): boolean;
canAddFile(file: Windows$Windows$Storage.IStorageFile): boolean;
onfileremoved: any;
onclosing: any
}
	declare export class PickerClosingEventArgs mixins undefined.IPickerClosingEventArgs {
closingOperation: Windows$Windows$Storage.Pickers.Provider.PickerClosingOperation;
isCanceled: boolean
}
	declare export interface IPickerClosingEventArgs {
closingOperation: Windows$Windows$Storage.Pickers.Provider.PickerClosingOperation,
isCanceled: boolean
} 
	declare export class PickerClosingOperation mixins undefined.IPickerClosingOperation {
deadline: Date;
getDeferral(): Windows$Windows$Storage.Pickers.Provider.PickerClosingDeferral
}
	declare export interface IPickerClosingOperation {
deadline: Date,
getDeferral(): Windows$Windows$Storage.Pickers.Provider.PickerClosingDeferral
} 
	declare export class PickerClosingDeferral mixins undefined.IPickerClosingDeferral {
complete(): void
}
	declare export interface IPickerClosingDeferral {
complete(): void
} 
	declare export  class SetFileNameResult {
  constructor(...args: empty): mixed;
static +succeeded: Class<SetFileNameResult__succeeded> & SetFileNameResult__succeeded & 0;// 0
static +notAllowed: Class<SetFileNameResult__notAllowed> & SetFileNameResult__notAllowed & 1;// 1
static +unavailable: Class<SetFileNameResult__unavailable> & SetFileNameResult__unavailable & 2;// 2

}

declare class SetFileNameResult__succeeded mixins SetFileNameResult {}
declare class SetFileNameResult__notAllowed mixins SetFileNameResult {}
declare class SetFileNameResult__unavailable mixins SetFileNameResult {}

	declare export interface IFileSavePickerUI {
allowedFileTypes: Windows$Windows$Foundation.Collections.IVectorView<string>,
fileName: string,
settingsIdentifier: string,
title: string,
trySetFileName(value: string): Windows$Windows$Storage.Pickers.Provider.SetFileNameResult,
onfilenamechanged: any,
ontargetfilerequested: any
} 
	declare export class FileSavePickerUI mixins undefined.IFileSavePickerUI {
allowedFileTypes: Windows$Windows$Foundation.Collections.IVectorView<string>;
fileName: string;
settingsIdentifier: string;
title: string;
trySetFileName(value: string): Windows$Windows$Storage.Pickers.Provider.SetFileNameResult;
onfilenamechanged: any;
ontargetfilerequested: any
}
	declare export class TargetFileRequestedEventArgs mixins undefined.ITargetFileRequestedEventArgs {
request: Windows$Windows$Storage.Pickers.Provider.TargetFileRequest
}
	declare export interface ITargetFileRequestedEventArgs {
request: Windows$Windows$Storage.Pickers.Provider.TargetFileRequest
} 
	declare export class TargetFileRequest mixins undefined.ITargetFileRequest {
targetFile: Windows$Windows$Storage.IStorageFile;
getDeferral(): Windows$Windows$Storage.Pickers.Provider.TargetFileRequestDeferral
}
	declare export interface ITargetFileRequest {
targetFile: Windows$Windows$Storage.IStorageFile,
getDeferral(): Windows$Windows$Storage.Pickers.Provider.TargetFileRequestDeferral
} 
	declare export class TargetFileRequestDeferral mixins undefined.ITargetFileRequestDeferral {
complete(): void
}
	declare export interface ITargetFileRequestDeferral {
complete(): void
} 
	declare export  class CachedFileTarget {
  constructor(...args: empty): mixed;
static +local: Class<CachedFileTarget__local> & CachedFileTarget__local & 0;// 0
static +remote: Class<CachedFileTarget__remote> & CachedFileTarget__remote & 1;// 1

}

declare class CachedFileTarget__local mixins CachedFileTarget {}
declare class CachedFileTarget__remote mixins CachedFileTarget {}

	declare export  class UIStatus {
  constructor(...args: empty): mixed;
static +unavailable: Class<UIStatus__unavailable> & UIStatus__unavailable & 0;// 0
static +hidden: Class<UIStatus__hidden> & UIStatus__hidden & 1;// 1
static +visible: Class<UIStatus__visible> & UIStatus__visible & 2;// 2
static +complete: Class<UIStatus__complete> & UIStatus__complete & 3;// 3

}

declare class UIStatus__unavailable mixins UIStatus {}
declare class UIStatus__hidden mixins UIStatus {}
declare class UIStatus__visible mixins UIStatus {}
declare class UIStatus__complete mixins UIStatus {}

	declare export interface ICachedFileUpdaterUI {
title: string,
uIStatus: Windows$Windows$Storage.Provider.UIStatus,
updateTarget: Windows$Windows$Storage.Provider.CachedFileTarget,
onfileupdaterequested: any,
onuirequested: any
} 
	declare export class CachedFileUpdaterUI mixins undefined.ICachedFileUpdaterUI {
title: string;
uIStatus: Windows$Windows$Storage.Provider.UIStatus;
updateTarget: Windows$Windows$Storage.Provider.CachedFileTarget;
onfileupdaterequested: any;
onuirequested: any
}
	declare export class FileUpdateRequestedEventArgs mixins undefined.IFileUpdateRequestedEventArgs {
request: Windows$Windows$Storage.Provider.FileUpdateRequest
}
	declare export interface IFileUpdateRequestedEventArgs {
request: Windows$Windows$Storage.Provider.FileUpdateRequest
} 
	declare export class FileUpdateRequest mixins undefined.IFileUpdateRequest {
contentId: string;
file: Windows$Windows$Storage.StorageFile;
status: Windows$Windows$Storage.Provider.FileUpdateStatus;
getDeferral(): Windows$Windows$Storage.Provider.FileUpdateRequestDeferral;
updateLocalFile(value: Windows$Windows$Storage.IStorageFile): void
}
	declare export interface IFileUpdateRequest {
contentId: string,
file: Windows$Windows$Storage.StorageFile,
status: Windows$Windows$Storage.Provider.FileUpdateStatus,
getDeferral(): Windows$Windows$Storage.Provider.FileUpdateRequestDeferral,
updateLocalFile(value: Windows$Windows$Storage.IStorageFile): void
} 
	declare export class FileUpdateRequestDeferral mixins undefined.IFileUpdateRequestDeferral {
complete(): void
}
	declare export interface IFileUpdateRequestDeferral {
complete(): void
} 
	declare export  class FileUpdateStatus {
  constructor(...args: empty): mixed;
static +incomplete: Class<FileUpdateStatus__incomplete> & FileUpdateStatus__incomplete & 0;// 0
static +complete: Class<FileUpdateStatus__complete> & FileUpdateStatus__complete & 1;// 1
static +userInputNeeded: Class<FileUpdateStatus__userInputNeeded> & FileUpdateStatus__userInputNeeded & 2;// 2
static +currentlyUnavailable: Class<FileUpdateStatus__currentlyUnavailable> & FileUpdateStatus__currentlyUnavailable & 3;// 3
static +failed: Class<FileUpdateStatus__failed> & FileUpdateStatus__failed & 4;// 4
static +completeAndRenamed: Class<FileUpdateStatus__completeAndRenamed> & FileUpdateStatus__completeAndRenamed & 5;// 5

}

declare class FileUpdateStatus__incomplete mixins FileUpdateStatus {}
declare class FileUpdateStatus__complete mixins FileUpdateStatus {}
declare class FileUpdateStatus__userInputNeeded mixins FileUpdateStatus {}
declare class FileUpdateStatus__currentlyUnavailable mixins FileUpdateStatus {}
declare class FileUpdateStatus__failed mixins FileUpdateStatus {}
declare class FileUpdateStatus__completeAndRenamed mixins FileUpdateStatus {}

	declare export  class CachedFileOptions {
  constructor(...args: empty): mixed;
static +none: Class<CachedFileOptions__none> & CachedFileOptions__none & 0;// 0
static +requireUpdateOnAccess: Class<CachedFileOptions__requireUpdateOnAccess> & CachedFileOptions__requireUpdateOnAccess & 1;// 1
static +useCachedFileWhenOffline: Class<CachedFileOptions__useCachedFileWhenOffline> & CachedFileOptions__useCachedFileWhenOffline & 2;// 2
static +denyAccessWhenOffline: Class<CachedFileOptions__denyAccessWhenOffline> & CachedFileOptions__denyAccessWhenOffline & 3;// 3

}

declare class CachedFileOptions__none mixins CachedFileOptions {}
declare class CachedFileOptions__requireUpdateOnAccess mixins CachedFileOptions {}
declare class CachedFileOptions__useCachedFileWhenOffline mixins CachedFileOptions {}
declare class CachedFileOptions__denyAccessWhenOffline mixins CachedFileOptions {}

	declare export  class ReadActivationMode {
  constructor(...args: empty): mixed;
static +notNeeded: Class<ReadActivationMode__notNeeded> & ReadActivationMode__notNeeded & 0;// 0
static +beforeAccess: Class<ReadActivationMode__beforeAccess> & ReadActivationMode__beforeAccess & 1;// 1

}

declare class ReadActivationMode__notNeeded mixins ReadActivationMode {}
declare class ReadActivationMode__beforeAccess mixins ReadActivationMode {}

	declare export  class WriteActivationMode {
  constructor(...args: empty): mixed;
static +readOnly: Class<WriteActivationMode__readOnly> & WriteActivationMode__readOnly & 0;// 0
static +notNeeded: Class<WriteActivationMode__notNeeded> & WriteActivationMode__notNeeded & 1;// 1
static +afterWrite: Class<WriteActivationMode__afterWrite> & WriteActivationMode__afterWrite & 2;// 2

}

declare class WriteActivationMode__readOnly mixins WriteActivationMode {}
declare class WriteActivationMode__notNeeded mixins WriteActivationMode {}
declare class WriteActivationMode__afterWrite mixins WriteActivationMode {}

	declare export interface ICachedFileUpdaterStatics {
setUpdateInformation(
file: Windows$Windows$Storage.IStorageFile,
contentId: string,
readMode: Windows$Windows$Storage.Provider.ReadActivationMode,
writeMode: Windows$Windows$Storage.Provider.WriteActivationMode,
options: Windows$Windows$Storage.Provider.CachedFileOptions): void
} 
	declare export class CachedFileUpdater  {
static setUpdateInformation(
file: Windows$Windows$Storage.IStorageFile,
contentId: string,
readMode: Windows$Windows$Storage.Provider.ReadActivationMode,
writeMode: Windows$Windows$Storage.Provider.WriteActivationMode,
options: Windows$Windows$Storage.Provider.CachedFileOptions): void
}
    }

    }

	declare module 'DataTransfer' {
        declare export interface IStandardDataFormatsStatics {
bitmap: string,
html: string,
rtf: string,
storageItems: string,
text: string,
uri: string
} 
	declare export class StandardDataFormats  {
static bitmap: string;
static html: string;
static rtf: string;
static storageItems: string;
static text: string;
static uri: string
}
	declare export type IDataPackagePropertySetView = {
applicationListingUri: Windows$Windows$Foundation.Uri,
applicationName: string,
description: string,
fileTypes: Windows$Windows$Foundation.Collections.IVectorView<string>,
thumbnail: Windows$Windows$Storage.Streams.RandomAccessStreamReference,
title: string
} & undefined.IMapView<string, any> & undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>

	declare export type IDataPackagePropertySet = {
applicationListingUri: Windows$Windows$Foundation.Uri,
applicationName: string,
description: string,
fileTypes: Windows$Windows$Foundation.Collections.IVector<string>,
thumbnail: Windows$Windows$Storage.Streams.IRandomAccessStreamReference,
title: string
} & undefined.IMap<string, any> & undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>

	declare export class DataPackagePropertySetView mixins undefined.IDataPackagePropertySetView, undefined.IMapView<string, any>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>> {
applicationListingUri: Windows$Windows$Foundation.Uri;
applicationName: string;
description: string;
fileTypes: Windows$Windows$Foundation.Collections.IVectorView<string>;
thumbnail: Windows$Windows$Storage.Streams.RandomAccessStreamReference;
title: string;
size: number;
lookup(key: string): any;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, any>,
second: Windows$Windows$Foundation.Collections.IMapView<string, any>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>
}
	declare export class DataPackagePropertySet mixins undefined.IDataPackagePropertySet, undefined.IMap<string, any>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>> {
applicationListingUri: Windows$Windows$Foundation.Uri;
applicationName: string;
description: string;
fileTypes: Windows$Windows$Foundation.Collections.IVector<string>;
thumbnail: Windows$Windows$Storage.Streams.IRandomAccessStreamReference;
title: string;
size: number;
lookup(key: string): any;
hasKey(key: string): boolean;
getView(): Windows$Windows$Foundation.Collections.IMapView<string, any>;
insert(key: string, value: any): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>
}
	declare export interface IDataProviderDeferral {
complete(): void
} 
	declare export class DataProviderDeferral mixins undefined.IDataProviderDeferral {
complete(): void
}
	declare export interface IDataProviderRequest {
deadline: Date,
formatId: string,
getDeferral(): Windows$Windows$ApplicationModel.DataTransfer.DataProviderDeferral,
setData(value: any): void
} 
	declare export class DataProviderRequest mixins undefined.IDataProviderRequest {
deadline: Date;
formatId: string;
getDeferral(): Windows$Windows$ApplicationModel.DataTransfer.DataProviderDeferral;
setData(value: any): void
}
	declare export interface DataProviderHandler {
(request: Windows$Windows$ApplicationModel.DataTransfer.DataProviderRequest): void
} 
	declare export  class DataPackageOperation {
  constructor(...args: empty): mixed;
static +none: Class<DataPackageOperation__none> & DataPackageOperation__none & 0;// 0
static +copy: Class<DataPackageOperation__copy> & DataPackageOperation__copy & 1;// 1
static +move: Class<DataPackageOperation__move> & DataPackageOperation__move & 2;// 2
static +link: Class<DataPackageOperation__link> & DataPackageOperation__link & 3;// 3

}

declare class DataPackageOperation__none mixins DataPackageOperation {}
declare class DataPackageOperation__copy mixins DataPackageOperation {}
declare class DataPackageOperation__move mixins DataPackageOperation {}
declare class DataPackageOperation__link mixins DataPackageOperation {}

	declare export interface IOperationCompletedEventArgs {
operation: Windows$Windows$ApplicationModel.DataTransfer.DataPackageOperation
} 
	declare export class OperationCompletedEventArgs mixins undefined.IOperationCompletedEventArgs {
operation: Windows$Windows$ApplicationModel.DataTransfer.DataPackageOperation
}
	declare export interface IDataPackageView {
availableFormats: Windows$Windows$Foundation.Collections.IVectorView<string>,
properties: Windows$Windows$ApplicationModel.DataTransfer.DataPackagePropertySetView,
requestedOperation: Windows$Windows$ApplicationModel.DataTransfer.DataPackageOperation,
reportOperationCompleted(
value: Windows$Windows$ApplicationModel.DataTransfer.DataPackageOperation): void,
contains(formatId: string): boolean,
getDataAsync(formatId: string): Windows$Windows$Foundation.IAsyncOperation<any>,
getTextAsync(): Windows$Windows$Foundation.IAsyncOperation<string>,
getTextAsync(formatId: string): Windows$Windows$Foundation.IAsyncOperation<string>,
getUriAsync(): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Uri>,
getHtmlFormatAsync(): Windows$Windows$Foundation.IAsyncOperation<string>,
getResourceMapAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$Storage.Streams.RandomAccessStreamReference>>,
getRtfAsync(): Windows$Windows$Foundation.IAsyncOperation<string>,
getBitmapAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.RandomAccessStreamReference>,
getStorageItemsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>
} 
	declare export interface IDataPackage {
properties: Windows$Windows$ApplicationModel.DataTransfer.DataPackagePropertySet,
requestedOperation: Windows$Windows$ApplicationModel.DataTransfer.DataPackageOperation,
resourceMap: Windows$Windows$Foundation.Collections.IMap<string, Windows$Windows$Storage.Streams.RandomAccessStreamReference>,
getView(): Windows$Windows$ApplicationModel.DataTransfer.DataPackageView,
onoperationcompleted: any,
ondestroyed: any,
setData(formatId: string, value: any): void,
setDataProvider(
formatId: string,
delayRenderer: Windows$Windows$ApplicationModel.DataTransfer.DataProviderHandler): void,
setText(value: string): void,
setUri(value: Windows$Windows$Foundation.Uri): void,
setHtmlFormat(value: string): void,
setRtf(value: string): void,
setBitmap(value: Windows$Windows$Storage.Streams.RandomAccessStreamReference): void,
setStorageItems(
value: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageItem>): void,
setStorageItems(
value: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageItem>,
readOnly: boolean): void
} 
	declare export class DataPackageView mixins undefined.IDataPackageView {
availableFormats: Windows$Windows$Foundation.Collections.IVectorView<string>;
properties: Windows$Windows$ApplicationModel.DataTransfer.DataPackagePropertySetView;
requestedOperation: Windows$Windows$ApplicationModel.DataTransfer.DataPackageOperation;
reportOperationCompleted(
value: Windows$Windows$ApplicationModel.DataTransfer.DataPackageOperation): void;
contains(formatId: string): boolean;
getDataAsync(formatId: string): Windows$Windows$Foundation.IAsyncOperation<any>;
getTextAsync(): Windows$Windows$Foundation.IAsyncOperation<string>;
getTextAsync(formatId: string): Windows$Windows$Foundation.IAsyncOperation<string>;
getUriAsync(): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Uri>;
getHtmlFormatAsync(): Windows$Windows$Foundation.IAsyncOperation<string>;
getResourceMapAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$Storage.Streams.RandomAccessStreamReference>>;
getRtfAsync(): Windows$Windows$Foundation.IAsyncOperation<string>;
getBitmapAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.RandomAccessStreamReference>;
getStorageItemsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>
}
	declare export class DataPackage mixins undefined.IDataPackage {
properties: Windows$Windows$ApplicationModel.DataTransfer.DataPackagePropertySet;
requestedOperation: Windows$Windows$ApplicationModel.DataTransfer.DataPackageOperation;
resourceMap: Windows$Windows$Foundation.Collections.IMap<string, Windows$Windows$Storage.Streams.RandomAccessStreamReference>;
getView(): Windows$Windows$ApplicationModel.DataTransfer.DataPackageView;
onoperationcompleted: any;
ondestroyed: any;
setData(formatId: string, value: any): void;
setDataProvider(
formatId: string,
delayRenderer: Windows$Windows$ApplicationModel.DataTransfer.DataProviderHandler): void;
setText(value: string): void;
setUri(value: Windows$Windows$Foundation.Uri): void;
setHtmlFormat(value: string): void;
setRtf(value: string): void;
setBitmap(value: Windows$Windows$Storage.Streams.RandomAccessStreamReference): void;
setStorageItems(
value: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageItem>): void;
setStorageItems(
value: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageItem>,
readOnly: boolean): void
}
	declare export interface IHtmlFormatHelperStatics {
getStaticFragment(htmlFormat: string): string,
createHtmlFormat(htmlFragment: string): string
} 
	declare export class HtmlFormatHelper  {
static getStaticFragment(htmlFormat: string): string;
static createHtmlFormat(htmlFragment: string): string
}
	declare export interface IClipboardStatics {
getContent(): Windows$Windows$ApplicationModel.DataTransfer.DataPackageView,
setContent(content: Windows$Windows$ApplicationModel.DataTransfer.DataPackage): void,
flush(): void,
clear(): void,
oncontentchanged: any
} 
	declare export class Clipboard  {
static getContent(): Windows$Windows$ApplicationModel.DataTransfer.DataPackageView;
static setContent(content: Windows$Windows$ApplicationModel.DataTransfer.DataPackage): void;
static flush(): void;
static clear(): void;
static oncontentchanged: any
}
	declare export interface IDataRequestDeferral {
complete(): void
} 
	declare export class DataRequestDeferral mixins undefined.IDataRequestDeferral {
complete(): void
}
	declare export interface IDataRequest {
data: Windows$Windows$ApplicationModel.DataTransfer.DataPackage,
deadline: Date,
failWithDisplayText(value: string): void,
getDeferral(): Windows$Windows$ApplicationModel.DataTransfer.DataRequestDeferral
} 
	declare export class DataRequest mixins undefined.IDataRequest {
data: Windows$Windows$ApplicationModel.DataTransfer.DataPackage;
deadline: Date;
failWithDisplayText(value: string): void;
getDeferral(): Windows$Windows$ApplicationModel.DataTransfer.DataRequestDeferral
}
	declare export interface IDataRequestedEventArgs {
request: Windows$Windows$ApplicationModel.DataTransfer.DataRequest
} 
	declare export class DataRequestedEventArgs mixins undefined.IDataRequestedEventArgs {
request: Windows$Windows$ApplicationModel.DataTransfer.DataRequest
}
	declare export interface ITargetApplicationChosenEventArgs {
applicationName: string
} 
	declare export class TargetApplicationChosenEventArgs mixins undefined.ITargetApplicationChosenEventArgs {
applicationName: string
}
	declare export interface IDataTransferManager {
ondatarequested: any,
ontargetapplicationchosen: any
} 
	declare export class DataTransferManager mixins undefined.IDataTransferManager {
ondatarequested: any;
ontargetapplicationchosen: any;
static showShareUI(): void;
static getForCurrentView(): Windows$Windows$ApplicationModel.DataTransfer.DataTransferManager
}
	declare export interface IDataTransferManagerStatics {
showShareUI(): void,
getForCurrentView(): Windows$Windows$ApplicationModel.DataTransfer.DataTransferManager
} 
	declare module 'ShareTarget' {
        declare export interface IQuickLink {
id: string,
supportedDataFormats: Windows$Windows$Foundation.Collections.IVector<string>,
supportedFileTypes: Windows$Windows$Foundation.Collections.IVector<string>,
thumbnail: Windows$Windows$Storage.Streams.RandomAccessStreamReference,
title: string
} 
	declare export class QuickLink mixins undefined.IQuickLink {
id: string;
supportedDataFormats: Windows$Windows$Foundation.Collections.IVector<string>;
supportedFileTypes: Windows$Windows$Foundation.Collections.IVector<string>;
thumbnail: Windows$Windows$Storage.Streams.RandomAccessStreamReference;
title: string
}
	declare export interface IShareOperation {
data: Windows$Windows$ApplicationModel.DataTransfer.DataPackageView,
quickLinkId: string,
removeThisQuickLink(): void,
reportStarted(): void,
reportDataRetrieved(): void,
reportSubmittedBackgroundTask(): void,
reportCompleted(
quicklink: Windows$Windows$ApplicationModel.DataTransfer.ShareTarget.QuickLink): void,
reportCompleted(): void,
reportError(value: string): void
} 
	declare export class ShareOperation mixins undefined.IShareOperation {
data: Windows$Windows$ApplicationModel.DataTransfer.DataPackageView;
quickLinkId: string;
removeThisQuickLink(): void;
reportStarted(): void;
reportDataRetrieved(): void;
reportSubmittedBackgroundTask(): void;
reportCompleted(
quicklink: Windows$Windows$ApplicationModel.DataTransfer.ShareTarget.QuickLink): void;
reportCompleted(): void;
reportError(value: string): void
}
    }

    }

	declare module 'Search' {
        declare export interface ISearchPaneQueryLinguisticDetails {
queryTextAlternatives: Windows$Windows$Foundation.Collections.IVectorView<string>,
queryTextCompositionLength: number,
queryTextCompositionStart: number
} 
	declare export class SearchPaneQueryLinguisticDetails mixins undefined.ISearchPaneQueryLinguisticDetails {
queryTextAlternatives: Windows$Windows$Foundation.Collections.IVectorView<string>;
queryTextCompositionLength: number;
queryTextCompositionStart: number
}
	declare export interface ISearchPaneVisibilityChangedEventArgs {
visible: boolean
} 
	declare export class SearchPaneVisibilityChangedEventArgs mixins undefined.ISearchPaneVisibilityChangedEventArgs {
visible: boolean
}
	declare export interface ISearchPaneQueryChangedEventArgs {
language: string,
linguisticDetails: Windows$Windows$ApplicationModel.Search.SearchPaneQueryLinguisticDetails,
queryText: string
} 
	declare export class SearchPaneQueryChangedEventArgs mixins undefined.ISearchPaneQueryChangedEventArgs {
language: string;
linguisticDetails: Windows$Windows$ApplicationModel.Search.SearchPaneQueryLinguisticDetails;
queryText: string
}
	declare export interface ISearchPaneQuerySubmittedEventArgs {
language: string,
queryText: string
} 
	declare export class SearchPaneQuerySubmittedEventArgs mixins undefined.ISearchPaneQuerySubmittedEventArgs {
language: string;
queryText: string
}
	declare export interface ISearchPaneResultSuggestionChosenEventArgs {
tag: string
} 
	declare export class SearchPaneResultSuggestionChosenEventArgs mixins undefined.ISearchPaneResultSuggestionChosenEventArgs {
tag: string
}
	declare export interface ISearchSuggestionCollection {
size: number,
appendQuerySuggestion(text: string): void,
appendQuerySuggestions(suggestions: Windows$Windows$Foundation.Collections.IIterable<string>): void,
appendResultSuggestion(
text: string,
detailText: string,
tag: string,
image: Windows$Windows$Storage.Streams.IRandomAccessStreamReference,
imageAlternateText: string): void,
appendSearchSeparator(label: string): void
} 
	declare export class SearchSuggestionCollection mixins undefined.ISearchSuggestionCollection {
size: number;
appendQuerySuggestion(text: string): void;
appendQuerySuggestions(suggestions: Windows$Windows$Foundation.Collections.IIterable<string>): void;
appendResultSuggestion(
text: string,
detailText: string,
tag: string,
image: Windows$Windows$Storage.Streams.IRandomAccessStreamReference,
imageAlternateText: string): void;
appendSearchSeparator(label: string): void
}
	declare export interface ISearchPaneSuggestionsRequestDeferral {
complete(): void
} 
	declare export interface ISearchPaneSuggestionsRequest {
isCanceled: boolean,
searchSuggestionCollection: Windows$Windows$ApplicationModel.Search.SearchSuggestionCollection,
getDeferral(): Windows$Windows$ApplicationModel.Search.SearchPaneSuggestionsRequestDeferral
} 
	declare export class SearchPaneSuggestionsRequestDeferral mixins undefined.ISearchPaneSuggestionsRequestDeferral {
complete(): void
}
	declare export class SearchPaneSuggestionsRequest mixins undefined.ISearchPaneSuggestionsRequest {
isCanceled: boolean;
searchSuggestionCollection: Windows$Windows$ApplicationModel.Search.SearchSuggestionCollection;
getDeferral(): Windows$Windows$ApplicationModel.Search.SearchPaneSuggestionsRequestDeferral
}
	declare export type ISearchPaneSuggestionsRequestedEventArgs = {
request: Windows$Windows$ApplicationModel.Search.SearchPaneSuggestionsRequest
} & undefined.ISearchPaneQueryChangedEventArgs

	declare export class SearchPaneSuggestionsRequestedEventArgs mixins undefined.ISearchPaneSuggestionsRequestedEventArgs, undefined.ISearchPaneQueryChangedEventArgs {
request: Windows$Windows$ApplicationModel.Search.SearchPaneSuggestionsRequest;
language: string;
linguisticDetails: Windows$Windows$ApplicationModel.Search.SearchPaneQueryLinguisticDetails;
queryText: string
}
	declare export interface ILocalContentSuggestionSettings {
aqsFilter: string,
enabled: boolean,
locations: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Storage.StorageFolder>,
propertiesToMatch: Windows$Windows$Foundation.Collections.IVector<string>
} 
	declare export class LocalContentSuggestionSettings mixins undefined.ILocalContentSuggestionSettings {
aqsFilter: string;
enabled: boolean;
locations: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Storage.StorageFolder>;
propertiesToMatch: Windows$Windows$Foundation.Collections.IVector<string>
}
	declare export interface ISearchPaneStatics {
getForCurrentView(): Windows$Windows$ApplicationModel.Search.SearchPane
} 
	declare export class SearchPane mixins undefined.ISearchPane {
language: string;
placeholderText: string;
queryText: string;
searchHistoryContext: string;
searchHistoryEnabled: boolean;
showOnKeyboardInput: boolean;
visible: boolean;
onvisibilitychanged: any;
onquerychanged: any;
onsuggestionsrequested: any;
onquerysubmitted: any;
onresultsuggestionchosen: any;
setLocalContentSuggestionSettings(
settings: Windows$Windows$ApplicationModel.Search.LocalContentSuggestionSettings): void;
show(): void;
show(query: string): void;
trySetQueryText(query: string): boolean;
static getForCurrentView(): Windows$Windows$ApplicationModel.Search.SearchPane
}
	declare export interface ISearchPane {
language: string,
placeholderText: string,
queryText: string,
searchHistoryContext: string,
searchHistoryEnabled: boolean,
showOnKeyboardInput: boolean,
visible: boolean,
onvisibilitychanged: any,
onquerychanged: any,
onsuggestionsrequested: any,
onquerysubmitted: any,
onresultsuggestionchosen: any,
setLocalContentSuggestionSettings(
settings: Windows$Windows$ApplicationModel.Search.LocalContentSuggestionSettings): void,
show(): void,
show(query: string): void,
trySetQueryText(query: string): boolean
} 
	declare export interface SortEntry {
propertyName: string,
ascendingOrder: boolean
} 
	declare export  class DateStackOption {
  constructor(...args: empty): mixed;
static +none: Class<DateStackOption__none> & DateStackOption__none & 0;// 0
static +year: Class<DateStackOption__year> & DateStackOption__year & 1;// 1
static +month: Class<DateStackOption__month> & DateStackOption__month & 2;// 2

}

declare class DateStackOption__none mixins DateStackOption {}
declare class DateStackOption__year mixins DateStackOption {}
declare class DateStackOption__month mixins DateStackOption {}

	declare export  class IndexerOption {
  constructor(...args: empty): mixed;
static +useIndexerWhenAvailable: Class<IndexerOption__useIndexerWhenAvailable> & IndexerOption__useIndexerWhenAvailable & 0;// 0
static +onlyUseIndexer: Class<IndexerOption__onlyUseIndexer> & IndexerOption__onlyUseIndexer & 1;// 1
static +doNotUseIndexer: Class<IndexerOption__doNotUseIndexer> & IndexerOption__doNotUseIndexer & 2;// 2

}

declare class IndexerOption__useIndexerWhenAvailable mixins IndexerOption {}
declare class IndexerOption__onlyUseIndexer mixins IndexerOption {}
declare class IndexerOption__doNotUseIndexer mixins IndexerOption {}

	declare export  class FolderDepth {
  constructor(...args: empty): mixed;
static +shallow: Class<FolderDepth__shallow> & FolderDepth__shallow & 0;// 0
static +deep: Class<FolderDepth__deep> & FolderDepth__deep & 1;// 1

}

declare class FolderDepth__shallow mixins FolderDepth {}
declare class FolderDepth__deep mixins FolderDepth {}

	declare export  class CommonFileQuery {
  constructor(...args: empty): mixed;
static +defaultQuery: Class<CommonFileQuery__defaultQuery> & CommonFileQuery__defaultQuery & 0;// 0
static +orderByName: Class<CommonFileQuery__orderByName> & CommonFileQuery__orderByName & 1;// 1
static +orderByTitle: Class<CommonFileQuery__orderByTitle> & CommonFileQuery__orderByTitle & 2;// 2
static +orderByMusicProperties: Class<CommonFileQuery__orderByMusicProperties> & CommonFileQuery__orderByMusicProperties & 3;// 3
static +orderBySearchRank: Class<CommonFileQuery__orderBySearchRank> & CommonFileQuery__orderBySearchRank & 4;// 4
static +orderByDate: Class<CommonFileQuery__orderByDate> & CommonFileQuery__orderByDate & 5;// 5

}

declare class CommonFileQuery__defaultQuery mixins CommonFileQuery {}
declare class CommonFileQuery__orderByName mixins CommonFileQuery {}
declare class CommonFileQuery__orderByTitle mixins CommonFileQuery {}
declare class CommonFileQuery__orderByMusicProperties mixins CommonFileQuery {}
declare class CommonFileQuery__orderBySearchRank mixins CommonFileQuery {}
declare class CommonFileQuery__orderByDate mixins CommonFileQuery {}

	declare export  class CommonFolderQuery {
  constructor(...args: empty): mixed;
static +defaultQuery: Class<CommonFolderQuery__defaultQuery> & CommonFolderQuery__defaultQuery & 0;// 0
static +groupByYear: Class<CommonFolderQuery__groupByYear> & CommonFolderQuery__groupByYear & 1;// 1
static +groupByMonth: Class<CommonFolderQuery__groupByMonth> & CommonFolderQuery__groupByMonth & 2;// 2
static +groupByArtist: Class<CommonFolderQuery__groupByArtist> & CommonFolderQuery__groupByArtist & 3;// 3
static +groupByAlbum: Class<CommonFolderQuery__groupByAlbum> & CommonFolderQuery__groupByAlbum & 4;// 4
static +groupByAlbumArtist: Class<CommonFolderQuery__groupByAlbumArtist> & CommonFolderQuery__groupByAlbumArtist & 5;// 5
static +groupByComposer: Class<CommonFolderQuery__groupByComposer> & CommonFolderQuery__groupByComposer & 6;// 6
static +groupByGenre: Class<CommonFolderQuery__groupByGenre> & CommonFolderQuery__groupByGenre & 7;// 7
static +groupByPublishedYear: Class<CommonFolderQuery__groupByPublishedYear> & CommonFolderQuery__groupByPublishedYear & 8;// 8
static +groupByRating: Class<CommonFolderQuery__groupByRating> & CommonFolderQuery__groupByRating & 9;// 9
static +groupByTag: Class<CommonFolderQuery__groupByTag> & CommonFolderQuery__groupByTag & 10;// 10
static +groupByAuthor: Class<CommonFolderQuery__groupByAuthor> & CommonFolderQuery__groupByAuthor & 11;// 11
static +groupByType: Class<CommonFolderQuery__groupByType> & CommonFolderQuery__groupByType & 12;// 12

}

declare class CommonFolderQuery__defaultQuery mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByYear mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByMonth mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByArtist mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByAlbum mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByAlbumArtist mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByComposer mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByGenre mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByPublishedYear mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByRating mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByTag mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByAuthor mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByType mixins CommonFolderQuery {}

	declare export  class IndexedState {
  constructor(...args: empty): mixed;
static +unknown: Class<IndexedState__unknown> & IndexedState__unknown & 0;// 0
static +notIndexed: Class<IndexedState__notIndexed> & IndexedState__notIndexed & 1;// 1
static +partiallyIndexed: Class<IndexedState__partiallyIndexed> & IndexedState__partiallyIndexed & 2;// 2
static +fullyIndexed: Class<IndexedState__fullyIndexed> & IndexedState__fullyIndexed & 3;// 3

}

declare class IndexedState__unknown mixins IndexedState {}
declare class IndexedState__notIndexed mixins IndexedState {}
declare class IndexedState__partiallyIndexed mixins IndexedState {}
declare class IndexedState__fullyIndexed mixins IndexedState {}

	declare export interface IQueryOptions {
applicationSearchFilter: string,
dateStackOption: Windows$Windows$Storage.Search.DateStackOption,
fileTypeFilter: Windows$Windows$Foundation.Collections.IVector<string>,
folderDepth: Windows$Windows$Storage.Search.FolderDepth,
groupPropertyName: string,
indexerOption: Windows$Windows$Storage.Search.IndexerOption,
language: string,
sortOrder: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Storage.Search.SortEntry>,
userSearchFilter: string,
saveToString(): string,
loadFromString(value: string): void,
setThumbnailPrefetch(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedSize: number,
options: Windows$Windows$Storage.FileProperties.ThumbnailOptions): void,
setPropertyPrefetch(
options: Windows$Windows$Storage.FileProperties.PropertyPrefetchOptions,
propertiesToRetrieve: Windows$Windows$Foundation.Collections.IIterable<string>): void
} 
	declare export interface IQueryOptionsFactory {
createCommonFileQuery(
query: Windows$Windows$Storage.Search.CommonFileQuery,
fileTypeFilter: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Storage.Search.QueryOptions,
createCommonFolderQuery(
query: Windows$Windows$Storage.Search.CommonFolderQuery): Windows$Windows$Storage.Search.QueryOptions
} 
	declare export class QueryOptions mixins undefined.IQueryOptions {
constructor(query: Windows$Windows$Storage.Search.CommonFileQuery, fileTypeFilter: Windows$Windows$Foundation.Collections.IIterable<string>): this;
constructor(query: Windows$Windows$Storage.Search.CommonFolderQuery): this;
constructor(): this;
applicationSearchFilter: string;
dateStackOption: Windows$Windows$Storage.Search.DateStackOption;
fileTypeFilter: Windows$Windows$Foundation.Collections.IVector<string>;
folderDepth: Windows$Windows$Storage.Search.FolderDepth;
groupPropertyName: string;
indexerOption: Windows$Windows$Storage.Search.IndexerOption;
language: string;
sortOrder: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Storage.Search.SortEntry>;
userSearchFilter: string;
saveToString(): string;
loadFromString(value: string): void;
setThumbnailPrefetch(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedSize: number,
options: Windows$Windows$Storage.FileProperties.ThumbnailOptions): void;
setPropertyPrefetch(
options: Windows$Windows$Storage.FileProperties.PropertyPrefetchOptions,
propertiesToRetrieve: Windows$Windows$Foundation.Collections.IIterable<string>): void
}
	declare export interface IStorageQueryResultBase {
folder: Windows$Windows$Storage.StorageFolder,
getItemCountAsync(): Windows$Windows$Foundation.IAsyncOperation<number>,
oncontentschanged: any,
onoptionschanged: any,
findStartIndexAsync(value: any): Windows$Windows$Foundation.IAsyncOperation<number>,
getCurrentQueryOptions(): Windows$Windows$Storage.Search.QueryOptions,
applyNewQueryOptions(newQueryOptions: Windows$Windows$Storage.Search.QueryOptions): void
} 
	declare export type IStorageFileQueryResult = {
getFilesAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>,
getFilesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>
} & undefined.IStorageQueryResultBase

	declare export type IStorageFolderQueryResult = {
getFoldersAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>,
getFoldersAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>
} & undefined.IStorageQueryResultBase

	declare export type IStorageItemQueryResult = {
getItemsAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>,
getItemsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>
} & undefined.IStorageQueryResultBase

	declare export interface IStorageFolderQueryOperations {
getIndexedStateAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Search.IndexedState>,
createFileQuery(): Windows$Windows$Storage.Search.StorageFileQueryResult,
createFileQuery(
query: Windows$Windows$Storage.Search.CommonFileQuery): Windows$Windows$Storage.Search.StorageFileQueryResult,
createFileQueryWithOptions(
queryOptions: Windows$Windows$Storage.Search.QueryOptions): Windows$Windows$Storage.Search.StorageFileQueryResult,
createFolderQuery(): Windows$Windows$Storage.Search.StorageFolderQueryResult,
createFolderQuery(
query: Windows$Windows$Storage.Search.CommonFolderQuery): Windows$Windows$Storage.Search.StorageFolderQueryResult,
createFolderQueryWithOptions(
queryOptions: Windows$Windows$Storage.Search.QueryOptions): Windows$Windows$Storage.Search.StorageFolderQueryResult,
createItemQuery(): Windows$Windows$Storage.Search.StorageItemQueryResult,
createItemQueryWithOptions(
queryOptions: Windows$Windows$Storage.Search.QueryOptions): Windows$Windows$Storage.Search.StorageItemQueryResult,
getFilesAsync(
query: Windows$Windows$Storage.Search.CommonFileQuery,
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>,
getFilesAsync(
query: Windows$Windows$Storage.Search.CommonFileQuery): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>,
getFoldersAsync(
query: Windows$Windows$Storage.Search.CommonFolderQuery,
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>,
getFoldersAsync(
query: Windows$Windows$Storage.Search.CommonFolderQuery): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>,
getItemsAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>,
areQueryOptionsSupported(queryOptions: Windows$Windows$Storage.Search.QueryOptions): boolean,
isCommonFolderQuerySupported(query: Windows$Windows$Storage.Search.CommonFolderQuery): boolean,
isCommonFileQuerySupported(query: Windows$Windows$Storage.Search.CommonFileQuery): boolean
} 
	declare export class StorageFileQueryResult mixins undefined.IStorageFileQueryResult, undefined.IStorageQueryResultBase {
folder: Windows$Windows$Storage.StorageFolder;
getFilesAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>;
getFilesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>;
getItemCountAsync(): Windows$Windows$Foundation.IAsyncOperation<number>;
oncontentschanged: any;
onoptionschanged: any;
findStartIndexAsync(value: any): Windows$Windows$Foundation.IAsyncOperation<number>;
getCurrentQueryOptions(): Windows$Windows$Storage.Search.QueryOptions;
applyNewQueryOptions(newQueryOptions: Windows$Windows$Storage.Search.QueryOptions): void
}
	declare export class StorageFolderQueryResult mixins undefined.IStorageFolderQueryResult, undefined.IStorageQueryResultBase {
folder: Windows$Windows$Storage.StorageFolder;
getFoldersAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>;
getFoldersAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>;
getItemCountAsync(): Windows$Windows$Foundation.IAsyncOperation<number>;
oncontentschanged: any;
onoptionschanged: any;
findStartIndexAsync(value: any): Windows$Windows$Foundation.IAsyncOperation<number>;
getCurrentQueryOptions(): Windows$Windows$Storage.Search.QueryOptions;
applyNewQueryOptions(newQueryOptions: Windows$Windows$Storage.Search.QueryOptions): void
}
	declare export class StorageItemQueryResult mixins undefined.IStorageItemQueryResult, undefined.IStorageQueryResultBase {
folder: Windows$Windows$Storage.StorageFolder;
getItemsAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>;
getItemsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>;
getItemCountAsync(): Windows$Windows$Foundation.IAsyncOperation<number>;
oncontentschanged: any;
onoptionschanged: any;
findStartIndexAsync(value: any): Windows$Windows$Foundation.IAsyncOperation<number>;
getCurrentQueryOptions(): Windows$Windows$Storage.Search.QueryOptions;
applyNewQueryOptions(newQueryOptions: Windows$Windows$Storage.Search.QueryOptions): void
}
	declare export class SortEntryVector mixins undefined.IVector<Windows$Windows$Storage.Search.SortEntry>, undefined.IIterable<Windows$Windows$Storage.Search.SortEntry> {
size: number;
getAt(index: number): Windows$Windows$Storage.Search.SortEntry;
getView(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.Search.SortEntry>;
indexOf(
value: Windows$Windows$Storage.Search.SortEntry): {
index: number,
returnValue: boolean
};
setAt(index: number, value: Windows$Windows$Storage.Search.SortEntry): void;
insertAt(index: number, value: Windows$Windows$Storage.Search.SortEntry): void;
removeAt(index: number): void;
append(value: Windows$Windows$Storage.Search.SortEntry): void;
removeAtEnd(): void;
clear(): void;
getMany(
startIndex: number): {
items: Windows$Windows$Storage.Search.SortEntry[],
returnValue: number
};
replaceAll(items: Windows$Windows$Storage.Search.SortEntry[]): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Storage.Search.SortEntry>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$Storage.Search.SortEntry[][]): Windows$Windows$Storage.Search.SortEntry[];
join(seperator: string): string;
pop(): Windows$Windows$Storage.Search.SortEntry;
push(...items: Windows$Windows$Storage.Search.SortEntry[]): void;
reverse(): Windows$Windows$Storage.Search.SortEntry[];
shift(): Windows$Windows$Storage.Search.SortEntry;
slice(start: number): Windows$Windows$Storage.Search.SortEntry[];
slice(start: number, end: number): Windows$Windows$Storage.Search.SortEntry[];
sort(): Windows$Windows$Storage.Search.SortEntry[];
sort(
compareFn: (
a: Windows$Windows$Storage.Search.SortEntry,
b: Windows$Windows$Storage.Search.SortEntry) => number): Windows$Windows$Storage.Search.SortEntry[];
splice(start: number): Windows$Windows$Storage.Search.SortEntry[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$Storage.Search.SortEntry[]): Windows$Windows$Storage.Search.SortEntry[];
unshift(...items: Windows$Windows$Storage.Search.SortEntry[]): number;
lastIndexOf(searchElement: Windows$Windows$Storage.Search.SortEntry): number;
lastIndexOf(
searchElement: Windows$Windows$Storage.Search.SortEntry,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => boolean): Windows$Windows$Storage.Search.SortEntry[];
filter(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => boolean,
thisArg: any): Windows$Windows$Storage.Search.SortEntry[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => any,
initialValue: any): any;
length: number
}
    }

	declare module 'Activation' {
        declare export interface ISplashScreen {
imageLocation: Windows$Windows$Foundation.Rect,
ondismissed: any
} 
	declare export class SplashScreen mixins undefined.ISplashScreen {
imageLocation: Windows$Windows$Foundation.Rect;
ondismissed: any
}
	declare export  class ApplicationExecutionState {
  constructor(...args: empty): mixed;
static +notRunning: Class<ApplicationExecutionState__notRunning> & ApplicationExecutionState__notRunning & 0;// 0
static +running: Class<ApplicationExecutionState__running> & ApplicationExecutionState__running & 1;// 1
static +suspended: Class<ApplicationExecutionState__suspended> & ApplicationExecutionState__suspended & 2;// 2
static +terminated: Class<ApplicationExecutionState__terminated> & ApplicationExecutionState__terminated & 3;// 3
static +closedByUser: Class<ApplicationExecutionState__closedByUser> & ApplicationExecutionState__closedByUser & 4;// 4

}

declare class ApplicationExecutionState__notRunning mixins ApplicationExecutionState {}
declare class ApplicationExecutionState__running mixins ApplicationExecutionState {}
declare class ApplicationExecutionState__suspended mixins ApplicationExecutionState {}
declare class ApplicationExecutionState__terminated mixins ApplicationExecutionState {}
declare class ApplicationExecutionState__closedByUser mixins ApplicationExecutionState {}

	declare export  class ActivationKind {
  constructor(...args: empty): mixed;
static +launch: Class<ActivationKind__launch> & ActivationKind__launch & 0;// 0
static +search: Class<ActivationKind__search> & ActivationKind__search & 1;// 1
static +shareTarget: Class<ActivationKind__shareTarget> & ActivationKind__shareTarget & 2;// 2
static +file: Class<ActivationKind__file> & ActivationKind__file & 3;// 3
static +protocol: Class<ActivationKind__protocol> & ActivationKind__protocol & 4;// 4
static +fileOpenPicker: Class<ActivationKind__fileOpenPicker> & ActivationKind__fileOpenPicker & 5;// 5
static +fileSavePicker: Class<ActivationKind__fileSavePicker> & ActivationKind__fileSavePicker & 6;// 6
static +cachedFileUpdater: Class<ActivationKind__cachedFileUpdater> & ActivationKind__cachedFileUpdater & 7;// 7
static +contactPicker: Class<ActivationKind__contactPicker> & ActivationKind__contactPicker & 8;// 8
static +device: Class<ActivationKind__device> & ActivationKind__device & 9;// 9
static +printTaskSettings: Class<ActivationKind__printTaskSettings> & ActivationKind__printTaskSettings & 10;// 10
static +cameraSettings: Class<ActivationKind__cameraSettings> & ActivationKind__cameraSettings & 11;// 11
static +restrictedLaunch: Class<ActivationKind__restrictedLaunch> & ActivationKind__restrictedLaunch & 12;// 12
static +appointmentsProvider: Class<ActivationKind__appointmentsProvider> & ActivationKind__appointmentsProvider & 13;// 13
static +contact: Class<ActivationKind__contact> & ActivationKind__contact & 14;// 14
static +lockScreenCall: Class<ActivationKind__lockScreenCall> & ActivationKind__lockScreenCall & 15;// 15
static +voiceCommand: Class<ActivationKind__voiceCommand> & ActivationKind__voiceCommand & 16;// 16
static +lockScreen: Class<ActivationKind__lockScreen> & ActivationKind__lockScreen & 17;// 17
static +pickerReturned: Class<ActivationKind__pickerReturned> & ActivationKind__pickerReturned & 18;// 18
static +walletAction: Class<ActivationKind__walletAction> & ActivationKind__walletAction & 19;// 19
static +pickFileContinuation: Class<ActivationKind__pickFileContinuation> & ActivationKind__pickFileContinuation & 20;// 20
static +pickSaveFileContinuation: Class<ActivationKind__pickSaveFileContinuation> & ActivationKind__pickSaveFileContinuation & 21;// 21
static +pickFolderContinuation: Class<ActivationKind__pickFolderContinuation> & ActivationKind__pickFolderContinuation & 22;// 22
static +webAuthenticationBrokerContinuation: Class<ActivationKind__webAuthenticationBrokerContinuation> & ActivationKind__webAuthenticationBrokerContinuation & 23;// 23
static +webAccountProvider: Class<ActivationKind__webAccountProvider> & ActivationKind__webAccountProvider & 24;// 24
static +componentUI: Class<ActivationKind__componentUI> & ActivationKind__componentUI & 25;// 25
static +protocolForResults: Class<ActivationKind__protocolForResults> & ActivationKind__protocolForResults & 26;// 26
static +toastNotification: Class<ActivationKind__toastNotification> & ActivationKind__toastNotification & 27;// 27
static +print3DWorkflow: Class<ActivationKind__print3DWorkflow> & ActivationKind__print3DWorkflow & 28;// 28
static +dialReceiver: Class<ActivationKind__dialReceiver> & ActivationKind__dialReceiver & 29;// 29

}

declare class ActivationKind__launch mixins ActivationKind {}
declare class ActivationKind__search mixins ActivationKind {}
declare class ActivationKind__shareTarget mixins ActivationKind {}
declare class ActivationKind__file mixins ActivationKind {}
declare class ActivationKind__protocol mixins ActivationKind {}
declare class ActivationKind__fileOpenPicker mixins ActivationKind {}
declare class ActivationKind__fileSavePicker mixins ActivationKind {}
declare class ActivationKind__cachedFileUpdater mixins ActivationKind {}
declare class ActivationKind__contactPicker mixins ActivationKind {}
declare class ActivationKind__device mixins ActivationKind {}
declare class ActivationKind__printTaskSettings mixins ActivationKind {}
declare class ActivationKind__cameraSettings mixins ActivationKind {}
declare class ActivationKind__restrictedLaunch mixins ActivationKind {}
declare class ActivationKind__appointmentsProvider mixins ActivationKind {}
declare class ActivationKind__contact mixins ActivationKind {}
declare class ActivationKind__lockScreenCall mixins ActivationKind {}
declare class ActivationKind__voiceCommand mixins ActivationKind {}
declare class ActivationKind__lockScreen mixins ActivationKind {}
declare class ActivationKind__pickerReturned mixins ActivationKind {}
declare class ActivationKind__walletAction mixins ActivationKind {}
declare class ActivationKind__pickFileContinuation mixins ActivationKind {}
declare class ActivationKind__pickSaveFileContinuation mixins ActivationKind {}
declare class ActivationKind__pickFolderContinuation mixins ActivationKind {}
declare class ActivationKind__webAuthenticationBrokerContinuation mixins ActivationKind {}
declare class ActivationKind__webAccountProvider mixins ActivationKind {}
declare class ActivationKind__componentUI mixins ActivationKind {}
declare class ActivationKind__protocolForResults mixins ActivationKind {}
declare class ActivationKind__toastNotification mixins ActivationKind {}
declare class ActivationKind__print3DWorkflow mixins ActivationKind {}
declare class ActivationKind__dialReceiver mixins ActivationKind {}

	declare export interface IActivatedEventArgs {
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind,
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState,
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen
} 
	declare export type ILaunchActivatedEventArgs = {
arguments: string,
tileId: string
} & undefined.IActivatedEventArgs

	declare export class LaunchActivatedEventArgs mixins undefined.ILaunchActivatedEventArgs, undefined.IActivatedEventArgs {
arguments: string;
tileId: string;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen
}
	declare export type ISearchActivatedEventArgs = {
language: string,
queryText: string
} & undefined.IActivatedEventArgs

	declare export class SearchActivatedEventArgs mixins undefined.ISearchActivatedEventArgs, undefined.IActivatedEventArgs {
language: string;
queryText: string;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen
}
	declare export type IShareTargetActivatedEventArgs = {
shareOperation: Windows$Windows$ApplicationModel.DataTransfer.ShareTarget.ShareOperation
} & undefined.IActivatedEventArgs

	declare export class ShareTargetActivatedEventArgs mixins undefined.IShareTargetActivatedEventArgs, undefined.IActivatedEventArgs {
shareOperation: Windows$Windows$ApplicationModel.DataTransfer.ShareTarget.ShareOperation;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen
}
	declare export type IFileActivatedEventArgs = {
files: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>,
verb: string
} & undefined.IActivatedEventArgs

	declare export class FileActivatedEventArgs mixins undefined.IFileActivatedEventArgs, undefined.IActivatedEventArgs {
files: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>;
verb: string;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen
}
	declare export type IProtocolActivatedEventArgs = {
uri: Windows$Windows$Foundation.Uri
} & undefined.IActivatedEventArgs

	declare export class ProtocolActivatedEventArgs mixins undefined.IProtocolActivatedEventArgs, undefined.IActivatedEventArgs {
uri: Windows$Windows$Foundation.Uri;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen
}
	declare export type IFileOpenPickerActivatedEventArgs = {
fileOpenPickerUI: Windows$Windows$Storage.Pickers.Provider.FileOpenPickerUI
} & undefined.IActivatedEventArgs

	declare export class FileOpenPickerActivatedEventArgs mixins undefined.IFileOpenPickerActivatedEventArgs, undefined.IActivatedEventArgs {
fileOpenPickerUI: Windows$Windows$Storage.Pickers.Provider.FileOpenPickerUI;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen
}
	declare export type IFileSavePickerActivatedEventArgs = {
fileSavePickerUI: Windows$Windows$Storage.Pickers.Provider.FileSavePickerUI
} & undefined.IActivatedEventArgs

	declare export class FileSavePickerActivatedEventArgs mixins undefined.IFileSavePickerActivatedEventArgs, undefined.IActivatedEventArgs {
fileSavePickerUI: Windows$Windows$Storage.Pickers.Provider.FileSavePickerUI;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen
}
	declare export type ICachedFileUpdaterActivatedEventArgs = {
cachedFileUpdaterUI: Windows$Windows$Storage.Provider.CachedFileUpdaterUI
} & undefined.IActivatedEventArgs

	declare export class CachedFileUpdaterActivatedEventArgs mixins undefined.ICachedFileUpdaterActivatedEventArgs, undefined.IActivatedEventArgs {
cachedFileUpdaterUI: Windows$Windows$Storage.Provider.CachedFileUpdaterUI;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen
}
	declare export type IContactPickerActivatedEventArgs = {
contactPickerUI: Windows$Windows$ApplicationModel.Contacts.Provider.ContactPickerUI
} & undefined.IActivatedEventArgs

	declare export class ContactPickerActivatedEventArgs mixins undefined.IContactPickerActivatedEventArgs, undefined.IActivatedEventArgs {
contactPickerUI: Windows$Windows$ApplicationModel.Contacts.Provider.ContactPickerUI;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen
}
	declare export type IDeviceActivatedEventArgs = {
deviceInformationId: string,
verb: string
} & undefined.IActivatedEventArgs

	declare export class DeviceActivatedEventArgs mixins undefined.IDeviceActivatedEventArgs, undefined.IActivatedEventArgs {
deviceInformationId: string;
verb: string;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen
}
	declare export type IPrintTaskSettingsActivatedEventArgs = {
configuration: Windows$Windows$Devices.Printers.Extensions.PrintTaskConfiguration
} & undefined.IActivatedEventArgs

	declare export class PrintTaskSettingsActivatedEventArgs mixins undefined.IPrintTaskSettingsActivatedEventArgs, undefined.IActivatedEventArgs {
configuration: Windows$Windows$Devices.Printers.Extensions.PrintTaskConfiguration;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen
}
	declare export type ICameraSettingsActivatedEventArgs = {
videoDeviceController: any,
videoDeviceExtension: any
} & undefined.IActivatedEventArgs

	declare export class CameraSettingsActivatedEventArgs mixins undefined.ICameraSettingsActivatedEventArgs, undefined.IActivatedEventArgs {
videoDeviceController: any;
videoDeviceExtension: any;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen
}
    }

	declare module 'Core' {
        declare export class CoreApplication  {
static mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>;
static id: string;
static properties: Windows$Windows$Foundation.Collections.IPropertySet;
static incrementApplicationUseCount(): void;
static decrementApplicationUseCount(): void;
static createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static exit(): void;
static onexiting: any;
static onsuspending: any;
static onresuming: any;
static getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void;
static runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
}
	declare export class CoreApplicationView mixins undefined.ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow;
isHosted: boolean;
isMain: boolean;
onactivated: any
}
	declare export interface IFrameworkView {
initialize(
applicationView: Windows$Windows$ApplicationModel.Core.CoreApplicationView): void,
setWindow(window: Windows$Windows$UI.Core.CoreWindow): void,
load(entryPoint: string): void,
run(): void,
uninitialize(): void
} 
	declare export interface IFrameworkViewSource {
createView(): Windows$Windows$ApplicationModel.Core.IFrameworkView
} 
	declare export interface ICoreApplication {
id: string,
properties: Windows$Windows$Foundation.Collections.IPropertySet,
onsuspending: any,
onresuming: any,
getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView,
run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void,
runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
} 
	declare export interface ICoreApplicationUseCount {
incrementApplicationUseCount(): void,
decrementApplicationUseCount(): void
} 
	declare export interface ICoreApplicationExit {
exit(): void,
onexiting: any
} 
	declare export interface ICoreImmersiveApplication {
mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView,
views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>,
createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView
} 
	declare export interface ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow,
isHosted: boolean,
isMain: boolean,
onactivated: any
} 
	declare export interface IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext,
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap,
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void,
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void
} 
	declare export class ResourceMap mixins undefined.IResourceMap, undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
uri: Windows$Windows$Foundation.Uri;
size: number;
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.NamedResource;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>
}
	declare export class ResourceContext mixins undefined.IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>;
reset(): void;
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void;
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void;
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
static createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
}
	declare export interface IResourceManagerStatics {
current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager,
isResourceReference(resourceReference: string): boolean
} 
	declare export class ResourceManager mixins undefined.IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
static current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager;
static isResourceReference(resourceReference: string): boolean
}
	declare export interface IResourceQualifier {
isDefault: boolean,
isMatch: boolean,
qualifierName: string,
qualifierValue: string,
score: number
} 
	declare export class ResourceQualifier mixins undefined.IResourceQualifier {
isDefault: boolean;
isMatch: boolean;
qualifierName: string;
qualifierValue: string;
score: number
}
	declare export interface IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>,
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>,
reset(): void,
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void,
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void,
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceContextStatics {
createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceCandidate {
isDefault: boolean,
isMatch: boolean,
isMatchAsDefault: boolean,
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>,
valueAsString: string,
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
getQualifierValue(qualifierName: string): string
} 
	declare export class ResourceCandidate mixins undefined.IResourceCandidate {
isDefault: boolean;
isMatch: boolean;
isMatchAsDefault: boolean;
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
valueAsString: string;
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
getQualifierValue(qualifierName: string): string
}
	declare export interface INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
uri: Windows$Windows$Foundation.Uri,
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
} 
	declare export class NamedResource mixins undefined.INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
uri: Windows$Windows$Foundation.Uri;
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
}
	declare export type IResourceMap = {
uri: Windows$Windows$Foundation.Uri,
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap
} & undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource> & undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>

	declare export class ResourceMapIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>[],
returnValue: number
}
}
	declare export class ResourceMapMapView mixins undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
size: number;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>>
}
	declare export class ResourceMapMapViewIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>[],
returnValue: number
}
}
	declare export class ResourceQualifierObservableMap mixins undefined.IObservableMap<string, string>, undefined.IMap<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
onmapchanged: any;
lookup(key: string): string;
hasKey(key: string): boolean;
getView(): Windows$Windows$Foundation.Collections.IMapView<string, string>;
insert(key: string, value: string): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierMapView mixins undefined.IMapView<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
lookup(key: string): string;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, string>,
second: Windows$Windows$Foundation.Collections.IMapView<string, string>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceCandidateVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceContextLanguagesVectorView mixins undefined.IVectorView<string>, undefined.IIterable<string> {
size: number;
getAt(index: number): string;
indexOf(value: string): {
index: number,
returnValue: boolean
};
getMany(startIndex: number): {
items: string[],
returnValue: number
};
first(): Windows$Windows$Foundation.Collections.IIterator<string>;
toString(): string;
toLocaleString(): string;
concat(...items: string[][]): string[];
join(seperator: string): string;
pop(): string;
push(...items: string[]): void;
reverse(): string[];
shift(): string;
slice(start: number): string[];
slice(start: number, end: number): string[];
sort(): string[];
sort(compareFn: (a: string, b: string) => number): string[];
splice(start: number): string[];
splice(start: number, deleteCount: number, ...items: string[]): string[];
unshift(...items: string[]): number;
lastIndexOf(searchElement: string): number;
lastIndexOf(searchElement: string, fromIndex: number): number;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
forEach(callbackfn: (value: string, index: number, array: string[]) => void): void;
forEach(
callbackfn: (value: string, index: number, array: string[]) => void,
thisArg: any): void;
map(callbackfn: (value: string, index: number, array: string[]) => any): any[];
map(
callbackfn: (value: string, index: number, array: string[]) => any,
thisArg: any): any[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean): string[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): string[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
length: number
}
	declare export interface IApplicationDataManagerStatics {
createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
} 
	declare export interface IApplicationDataManager {} 
	declare export class ApplicationDataManager mixins undefined.IApplicationDataManager {
static createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
}
	declare export  class CryptographicPrivateKeyBlobType {
  constructor(...args: empty): mixed;
static +pkcs8RawPrivateKeyInfo: Class<CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo> & CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo & 0;// 0
static +pkcs1RsaPrivateKey: Class<CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey> & CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey & 1;// 1
static +bCryptPrivateKey: Class<CryptographicPrivateKeyBlobType__bCryptPrivateKey> & CryptographicPrivateKeyBlobType__bCryptPrivateKey & 2;// 2
static +capi1PrivateKey: Class<CryptographicPrivateKeyBlobType__capi1PrivateKey> & CryptographicPrivateKeyBlobType__capi1PrivateKey & 3;// 3

}

declare class CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__bCryptPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__capi1PrivateKey mixins CryptographicPrivateKeyBlobType {}

	declare export  class CryptographicPublicKeyBlobType {
  constructor(...args: empty): mixed;
static +x509SubjectPublicKeyInfo: Class<CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo> & CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo & 0;// 0
static +pkcs1RsaPublicKey: Class<CryptographicPublicKeyBlobType__pkcs1RsaPublicKey> & CryptographicPublicKeyBlobType__pkcs1RsaPublicKey & 1;// 1
static +bCryptPublicKey: Class<CryptographicPublicKeyBlobType__bCryptPublicKey> & CryptographicPublicKeyBlobType__bCryptPublicKey & 2;// 2
static +capi1PublicKey: Class<CryptographicPublicKeyBlobType__capi1PublicKey> & CryptographicPublicKeyBlobType__capi1PublicKey & 3;// 3

}

declare class CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__pkcs1RsaPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__bCryptPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__capi1PublicKey mixins CryptographicPublicKeyBlobType {}

	declare export interface IKeyDerivationParameters {
iterationCount: number,
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export interface IKeyDerivationParametersStatics {
buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
} 
	declare export class KeyDerivationParameters mixins undefined.IKeyDerivationParameters {
iterationCount: number;
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer;
static buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
}
	declare export interface ICryptographicKey {
keySize: number,
export(): Windows$Windows$Storage.Streams.IBuffer,
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicKey mixins undefined.ICryptographicKey {
keySize: number;
export(): Windows$Windows$Storage.Streams.IBuffer;
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void,
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicHash mixins undefined.IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void;
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProvider {
algorithmName: string,
hashLength: number,
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash
} 
	declare export interface IMacAlgorithmProvider {
algorithmName: string,
macLength: number,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IKeyDerivationAlgorithmProvider {
algorithmName: string,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface ISymmetricKeyAlgorithmProvider {
algorithmName: string,
blockLength: number,
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IAsymmetricKeyAlgorithmProvider {
algorithmName: string,
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
encryptedData: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class EncryptedAndAuthenticatedData mixins undefined.IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer;
encryptedData: Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface ICryptographicEngineStatics {
encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData,
decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean,
deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicEngine  {
static encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData;
static decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean;
static deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
} 
	declare export class HashAlgorithmProvider mixins undefined.IHashAlgorithmProvider {
algorithmName: string;
hashLength: number;
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
}
	declare export interface IMacAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
} 
	declare export class MacAlgorithmProvider mixins undefined.IMacAlgorithmProvider {
algorithmName: string;
macLength: number;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
}
	declare export interface IKeyDerivationAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
} 
	declare export class KeyDerivationAlgorithmProvider mixins undefined.IKeyDerivationAlgorithmProvider {
algorithmName: string;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
}
	declare export interface ISymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
} 
	declare export class SymmetricKeyAlgorithmProvider mixins undefined.ISymmetricKeyAlgorithmProvider {
algorithmName: string;
blockLength: number;
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
}
	declare export interface IAsymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
} 
	declare export class AsymmetricKeyAlgorithmProvider mixins undefined.IAsymmetricKeyAlgorithmProvider {
algorithmName: string;
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
}
	declare export interface IHashAlgorithmNamesStatics {
md5: string,
sha1: string,
sha256: string,
sha384: string,
sha512: string
} 
	declare export class HashAlgorithmNames  {
static md5: string;
static sha1: string;
static sha256: string;
static sha384: string;
static sha512: string
}
	declare export interface IMacAlgorithmNamesStatics {
aesCmac: string,
hmacMd5: string,
hmacSha1: string,
hmacSha256: string,
hmacSha384: string,
hmacSha512: string
} 
	declare export class MacAlgorithmNames  {
static aesCmac: string;
static hmacMd5: string;
static hmacSha1: string;
static hmacSha256: string;
static hmacSha384: string;
static hmacSha512: string
}
	declare export interface ISymmetricAlgorithmNamesStatics {
aesCbc: string,
aesCbcPkcs7: string,
aesCcm: string,
aesEcb: string,
aesEcbPkcs7: string,
aesGcm: string,
desCbc: string,
desCbcPkcs7: string,
desEcb: string,
desEcbPkcs7: string,
rc2Cbc: string,
rc2CbcPkcs7: string,
rc2Ecb: string,
rc2EcbPkcs7: string,
rc4: string,
tripleDesCbc: string,
tripleDesCbcPkcs7: string,
tripleDesEcb: string,
tripleDesEcbPkcs7: string
} 
	declare export class SymmetricAlgorithmNames  {
static aesCbc: string;
static aesCbcPkcs7: string;
static aesCcm: string;
static aesEcb: string;
static aesEcbPkcs7: string;
static aesGcm: string;
static desCbc: string;
static desCbcPkcs7: string;
static desEcb: string;
static desEcbPkcs7: string;
static rc2Cbc: string;
static rc2CbcPkcs7: string;
static rc2Ecb: string;
static rc2EcbPkcs7: string;
static rc4: string;
static tripleDesCbc: string;
static tripleDesCbcPkcs7: string;
static tripleDesEcb: string;
static tripleDesEcbPkcs7: string
}
	declare export interface IAsymmetricAlgorithmNamesStatics {
dsaSha1: string,
dsaSha256: string,
ecdsaP256Sha256: string,
ecdsaP384Sha384: string,
ecdsaP521Sha512: string,
rsaOaepSha1: string,
rsaOaepSha256: string,
rsaOaepSha384: string,
rsaOaepSha512: string,
rsaPkcs1: string,
rsaSignPkcs1Sha1: string,
rsaSignPkcs1Sha256: string,
rsaSignPkcs1Sha384: string,
rsaSignPkcs1Sha512: string,
rsaSignPssSha1: string,
rsaSignPssSha256: string,
rsaSignPssSha384: string,
rsaSignPssSha512: string
} 
	declare export class AsymmetricAlgorithmNames  {
static dsaSha1: string;
static dsaSha256: string;
static ecdsaP256Sha256: string;
static ecdsaP384Sha384: string;
static ecdsaP521Sha512: string;
static rsaOaepSha1: string;
static rsaOaepSha256: string;
static rsaOaepSha384: string;
static rsaOaepSha512: string;
static rsaPkcs1: string;
static rsaSignPkcs1Sha1: string;
static rsaSignPkcs1Sha256: string;
static rsaSignPkcs1Sha384: string;
static rsaSignPkcs1Sha512: string;
static rsaSignPssSha1: string;
static rsaSignPssSha256: string;
static rsaSignPssSha384: string;
static rsaSignPssSha512: string
}
	declare export interface IKeyDerivationAlgorithmNamesStatics {
pbkdf2Md5: string,
pbkdf2Sha1: string,
pbkdf2Sha256: string,
pbkdf2Sha384: string,
pbkdf2Sha512: string,
sp800108CtrHmacMd5: string,
sp800108CtrHmacSha1: string,
sp800108CtrHmacSha256: string,
sp800108CtrHmacSha384: string,
sp800108CtrHmacSha512: string,
sp80056aConcatMd5: string,
sp80056aConcatSha1: string,
sp80056aConcatSha256: string,
sp80056aConcatSha384: string,
sp80056aConcatSha512: string
} 
	declare export class KeyDerivationAlgorithmNames  {
static pbkdf2Md5: string;
static pbkdf2Sha1: string;
static pbkdf2Sha256: string;
static pbkdf2Sha384: string;
static pbkdf2Sha512: string;
static sp800108CtrHmacMd5: string;
static sp800108CtrHmacSha1: string;
static sp800108CtrHmacSha256: string;
static sp800108CtrHmacSha384: string;
static sp800108CtrHmacSha512: string;
static sp80056aConcatMd5: string;
static sp80056aConcatSha1: string;
static sp80056aConcatSha256: string;
static sp80056aConcatSha384: string;
static sp80056aConcatSha512: string
}
	declare export interface SignalHandler {
(signalNotifier: Windows$Windows$System.Threading.Core.SignalNotifier, timedOut: boolean): void
} 
	declare export class SignalNotifier mixins undefined.ISignalNotifier {
enable(): void;
terminate(): void;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
}
	declare export interface ISignalNotifierStatics {
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
} 
	declare export interface IPreallocatedWorkItemFactory {
createWorkItem(
handler: Windows$Windows$System.Threading.WorkItemHandler): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriority(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriorityAndOptions(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority,
options: Windows$Windows$System.Threading.WorkItemOptions): Windows$Windows$System.Threading.Core.PreallocatedWorkItem
} 
	declare export class PreallocatedWorkItem mixins undefined.IPreallocatedWorkItem {
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority, options: Windows$Windows$System.Threading.WorkItemOptions): this;
runAsync(): Windows$Windows$Foundation.IAsyncAction
}
	declare export interface IPreallocatedWorkItem {
runAsync(): Windows$Windows$Foundation.IAsyncAction
} 
	declare export interface ISignalNotifier {
enable(): void,
terminate(): void
} 
	declare module 'AnimationMetrics' {
        declare export  class PropertyAnimationType {
  constructor(...args: empty): mixed;
static +scale: Class<PropertyAnimationType__scale> & PropertyAnimationType__scale & 0;// 0
static +translation: Class<PropertyAnimationType__translation> & PropertyAnimationType__translation & 1;// 1
static +opacity: Class<PropertyAnimationType__opacity> & PropertyAnimationType__opacity & 2;// 2

}

declare class PropertyAnimationType__scale mixins PropertyAnimationType {}
declare class PropertyAnimationType__translation mixins PropertyAnimationType {}
declare class PropertyAnimationType__opacity mixins PropertyAnimationType {}

	declare export interface IPropertyAnimation {
control1: Windows$Windows$Foundation.Point,
control2: Windows$Windows$Foundation.Point,
delay: number,
duration: number,
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
} 
	declare export type IScaleAnimation = {
finalScaleX: number,
finalScaleY: number,
initialScaleX: number,
initialScaleY: number,
normalizedOrigin: Windows$Windows$Foundation.Point
} & undefined.IPropertyAnimation

	declare export type IOpacityAnimation = {
finalOpacity: number,
initialOpacity: number
} & undefined.IPropertyAnimation

	declare export  class AnimationEffect {
  constructor(...args: empty): mixed;
static +expand: Class<AnimationEffect__expand> & AnimationEffect__expand & 0;// 0
static +collapse: Class<AnimationEffect__collapse> & AnimationEffect__collapse & 1;// 1
static +reposition: Class<AnimationEffect__reposition> & AnimationEffect__reposition & 2;// 2
static +fadeIn: Class<AnimationEffect__fadeIn> & AnimationEffect__fadeIn & 3;// 3
static +fadeOut: Class<AnimationEffect__fadeOut> & AnimationEffect__fadeOut & 4;// 4
static +addToList: Class<AnimationEffect__addToList> & AnimationEffect__addToList & 5;// 5
static +deleteFromList: Class<AnimationEffect__deleteFromList> & AnimationEffect__deleteFromList & 6;// 6
static +addToGrid: Class<AnimationEffect__addToGrid> & AnimationEffect__addToGrid & 7;// 7
static +deleteFromGrid: Class<AnimationEffect__deleteFromGrid> & AnimationEffect__deleteFromGrid & 8;// 8
static +addToSearchGrid: Class<AnimationEffect__addToSearchGrid> & AnimationEffect__addToSearchGrid & 9;// 9
static +deleteFromSearchGrid: Class<AnimationEffect__deleteFromSearchGrid> & AnimationEffect__deleteFromSearchGrid & 10;// 10
static +addToSearchList: Class<AnimationEffect__addToSearchList> & AnimationEffect__addToSearchList & 11;// 11
static +deleteFromSearchList: Class<AnimationEffect__deleteFromSearchList> & AnimationEffect__deleteFromSearchList & 12;// 12
static +showEdgeUI: Class<AnimationEffect__showEdgeUI> & AnimationEffect__showEdgeUI & 13;// 13
static +showPanel: Class<AnimationEffect__showPanel> & AnimationEffect__showPanel & 14;// 14
static +hideEdgeUI: Class<AnimationEffect__hideEdgeUI> & AnimationEffect__hideEdgeUI & 15;// 15
static +hidePanel: Class<AnimationEffect__hidePanel> & AnimationEffect__hidePanel & 16;// 16
static +showPopup: Class<AnimationEffect__showPopup> & AnimationEffect__showPopup & 17;// 17
static +hidePopup: Class<AnimationEffect__hidePopup> & AnimationEffect__hidePopup & 18;// 18
static +pointerDown: Class<AnimationEffect__pointerDown> & AnimationEffect__pointerDown & 19;// 19
static +pointerUp: Class<AnimationEffect__pointerUp> & AnimationEffect__pointerUp & 20;// 20
static +dragSourceStart: Class<AnimationEffect__dragSourceStart> & AnimationEffect__dragSourceStart & 21;// 21
static +dragSourceEnd: Class<AnimationEffect__dragSourceEnd> & AnimationEffect__dragSourceEnd & 22;// 22
static +transitionContent: Class<AnimationEffect__transitionContent> & AnimationEffect__transitionContent & 23;// 23
static +reveal: Class<AnimationEffect__reveal> & AnimationEffect__reveal & 24;// 24
static +hide: Class<AnimationEffect__hide> & AnimationEffect__hide & 25;// 25
static +dragBetweenEnter: Class<AnimationEffect__dragBetweenEnter> & AnimationEffect__dragBetweenEnter & 26;// 26
static +dragBetweenLeave: Class<AnimationEffect__dragBetweenLeave> & AnimationEffect__dragBetweenLeave & 27;// 27
static +swipeSelect: Class<AnimationEffect__swipeSelect> & AnimationEffect__swipeSelect & 28;// 28
static +swipeDeselect: Class<AnimationEffect__swipeDeselect> & AnimationEffect__swipeDeselect & 29;// 29
static +swipeReveal: Class<AnimationEffect__swipeReveal> & AnimationEffect__swipeReveal & 30;// 30
static +enterPage: Class<AnimationEffect__enterPage> & AnimationEffect__enterPage & 31;// 31
static +transitionPage: Class<AnimationEffect__transitionPage> & AnimationEffect__transitionPage & 32;// 32
static +crossFade: Class<AnimationEffect__crossFade> & AnimationEffect__crossFade & 33;// 33
static +peek: Class<AnimationEffect__peek> & AnimationEffect__peek & 34;// 34
static +updateBadge: Class<AnimationEffect__updateBadge> & AnimationEffect__updateBadge & 35;// 35

}

declare class AnimationEffect__expand mixins AnimationEffect {}
declare class AnimationEffect__collapse mixins AnimationEffect {}
declare class AnimationEffect__reposition mixins AnimationEffect {}
declare class AnimationEffect__fadeIn mixins AnimationEffect {}
declare class AnimationEffect__fadeOut mixins AnimationEffect {}
declare class AnimationEffect__addToList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromList mixins AnimationEffect {}
declare class AnimationEffect__addToGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchList mixins AnimationEffect {}
declare class AnimationEffect__showEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__showPanel mixins AnimationEffect {}
declare class AnimationEffect__hideEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__hidePanel mixins AnimationEffect {}
declare class AnimationEffect__showPopup mixins AnimationEffect {}
declare class AnimationEffect__hidePopup mixins AnimationEffect {}
declare class AnimationEffect__pointerDown mixins AnimationEffect {}
declare class AnimationEffect__pointerUp mixins AnimationEffect {}
declare class AnimationEffect__dragSourceStart mixins AnimationEffect {}
declare class AnimationEffect__dragSourceEnd mixins AnimationEffect {}
declare class AnimationEffect__transitionContent mixins AnimationEffect {}
declare class AnimationEffect__reveal mixins AnimationEffect {}
declare class AnimationEffect__hide mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenEnter mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenLeave mixins AnimationEffect {}
declare class AnimationEffect__swipeSelect mixins AnimationEffect {}
declare class AnimationEffect__swipeDeselect mixins AnimationEffect {}
declare class AnimationEffect__swipeReveal mixins AnimationEffect {}
declare class AnimationEffect__enterPage mixins AnimationEffect {}
declare class AnimationEffect__transitionPage mixins AnimationEffect {}
declare class AnimationEffect__crossFade mixins AnimationEffect {}
declare class AnimationEffect__peek mixins AnimationEffect {}
declare class AnimationEffect__updateBadge mixins AnimationEffect {}

	declare export  class AnimationEffectTarget {
  constructor(...args: empty): mixed;
static +primary: Class<AnimationEffectTarget__primary> & AnimationEffectTarget__primary & 0;// 0
static +added: Class<AnimationEffectTarget__added> & AnimationEffectTarget__added & 1;// 1
static +affected: Class<AnimationEffectTarget__affected> & AnimationEffectTarget__affected & 2;// 2
static +background: Class<AnimationEffectTarget__background> & AnimationEffectTarget__background & 3;// 3
static +content: Class<AnimationEffectTarget__content> & AnimationEffectTarget__content & 4;// 4
static +deleted: Class<AnimationEffectTarget__deleted> & AnimationEffectTarget__deleted & 5;// 5
static +deselected: Class<AnimationEffectTarget__deselected> & AnimationEffectTarget__deselected & 6;// 6
static +dragSource: Class<AnimationEffectTarget__dragSource> & AnimationEffectTarget__dragSource & 7;// 7
static +hidden: Class<AnimationEffectTarget__hidden> & AnimationEffectTarget__hidden & 8;// 8
static +incoming: Class<AnimationEffectTarget__incoming> & AnimationEffectTarget__incoming & 9;// 9
static +outgoing: Class<AnimationEffectTarget__outgoing> & AnimationEffectTarget__outgoing & 10;// 10
static +outline: Class<AnimationEffectTarget__outline> & AnimationEffectTarget__outline & 11;// 11
static +remaining: Class<AnimationEffectTarget__remaining> & AnimationEffectTarget__remaining & 12;// 12
static +revealed: Class<AnimationEffectTarget__revealed> & AnimationEffectTarget__revealed & 13;// 13
static +rowIn: Class<AnimationEffectTarget__rowIn> & AnimationEffectTarget__rowIn & 14;// 14
static +rowOut: Class<AnimationEffectTarget__rowOut> & AnimationEffectTarget__rowOut & 15;// 15
static +selected: Class<AnimationEffectTarget__selected> & AnimationEffectTarget__selected & 16;// 16
static +selection: Class<AnimationEffectTarget__selection> & AnimationEffectTarget__selection & 17;// 17
static +shown: Class<AnimationEffectTarget__shown> & AnimationEffectTarget__shown & 18;// 18
static +tapped: Class<AnimationEffectTarget__tapped> & AnimationEffectTarget__tapped & 19;// 19

}

declare class AnimationEffectTarget__primary mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__added mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__affected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__background mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__content mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deleted mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deselected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__dragSource mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__hidden mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__incoming mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outgoing mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outline mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__remaining mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__revealed mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowIn mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowOut mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selection mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__shown mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__tapped mixins AnimationEffectTarget {}

	declare export interface IAnimationDescription {
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>,
delayLimit: number,
staggerDelay: number,
staggerDelayFactor: number,
zOrder: number
} 
	declare export interface IAnimationDescriptionFactory {
createInstance(
effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect,
target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): Windows$Windows$UI.Core.AnimationMetrics.AnimationDescription
} 
	declare export class AnimationDescription mixins undefined.IAnimationDescription {
constructor(effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect, target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): this;
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>;
delayLimit: number;
staggerDelay: number;
staggerDelayFactor: number;
zOrder: number
}
	declare export class PropertyAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class ScaleAnimation mixins undefined.IScaleAnimation, undefined.IPropertyAnimation {
finalScaleX: number;
finalScaleY: number;
initialScaleX: number;
initialScaleY: number;
normalizedOrigin: Windows$Windows$Foundation.Point;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class TranslationAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class OpacityAnimation mixins undefined.IOpacityAnimation, undefined.IPropertyAnimation {
finalOpacity: number;
initialOpacity: number;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
    }

	declare export  class CoreWindowActivationState {
  constructor(...args: empty): mixed;
static +codeActivated: Class<CoreWindowActivationState__codeActivated> & CoreWindowActivationState__codeActivated & 0;// 0
static +deactivated: Class<CoreWindowActivationState__deactivated> & CoreWindowActivationState__deactivated & 1;// 1
static +pointerActivated: Class<CoreWindowActivationState__pointerActivated> & CoreWindowActivationState__pointerActivated & 2;// 2

}

declare class CoreWindowActivationState__codeActivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__deactivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__pointerActivated mixins CoreWindowActivationState {}

	declare export  class CoreCursorType {
  constructor(...args: empty): mixed;
static +arrow: Class<CoreCursorType__arrow> & CoreCursorType__arrow & 0;// 0
static +cross: Class<CoreCursorType__cross> & CoreCursorType__cross & 1;// 1
static +custom: Class<CoreCursorType__custom> & CoreCursorType__custom & 2;// 2
static +hand: Class<CoreCursorType__hand> & CoreCursorType__hand & 3;// 3
static +help: Class<CoreCursorType__help> & CoreCursorType__help & 4;// 4
static +iBeam: Class<CoreCursorType__iBeam> & CoreCursorType__iBeam & 5;// 5
static +sizeAll: Class<CoreCursorType__sizeAll> & CoreCursorType__sizeAll & 6;// 6
static +sizeNortheastSouthwest: Class<CoreCursorType__sizeNortheastSouthwest> & CoreCursorType__sizeNortheastSouthwest & 7;// 7
static +sizeNorthSouth: Class<CoreCursorType__sizeNorthSouth> & CoreCursorType__sizeNorthSouth & 8;// 8
static +sizeNorthwestSoutheast: Class<CoreCursorType__sizeNorthwestSoutheast> & CoreCursorType__sizeNorthwestSoutheast & 9;// 9
static +sizeWestEast: Class<CoreCursorType__sizeWestEast> & CoreCursorType__sizeWestEast & 10;// 10
static +universalNo: Class<CoreCursorType__universalNo> & CoreCursorType__universalNo & 11;// 11
static +upArrow: Class<CoreCursorType__upArrow> & CoreCursorType__upArrow & 12;// 12
static +wait: Class<CoreCursorType__wait> & CoreCursorType__wait & 13;// 13

}

declare class CoreCursorType__arrow mixins CoreCursorType {}
declare class CoreCursorType__cross mixins CoreCursorType {}
declare class CoreCursorType__custom mixins CoreCursorType {}
declare class CoreCursorType__hand mixins CoreCursorType {}
declare class CoreCursorType__help mixins CoreCursorType {}
declare class CoreCursorType__iBeam mixins CoreCursorType {}
declare class CoreCursorType__sizeAll mixins CoreCursorType {}
declare class CoreCursorType__sizeNortheastSouthwest mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthSouth mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthwestSoutheast mixins CoreCursorType {}
declare class CoreCursorType__sizeWestEast mixins CoreCursorType {}
declare class CoreCursorType__universalNo mixins CoreCursorType {}
declare class CoreCursorType__upArrow mixins CoreCursorType {}
declare class CoreCursorType__wait mixins CoreCursorType {}

	declare export  class CoreDispatcherPriority {
  constructor(...args: empty): mixed;
static +low: Class<CoreDispatcherPriority__low> & CoreDispatcherPriority__low & 0;// 0
static +normal: Class<CoreDispatcherPriority__normal> & CoreDispatcherPriority__normal & 1;// 1
static +high: Class<CoreDispatcherPriority__high> & CoreDispatcherPriority__high & 2;// 2

}

declare class CoreDispatcherPriority__low mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__normal mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__high mixins CoreDispatcherPriority {}

	declare export  class CoreProcessEventsOption {
  constructor(...args: empty): mixed;
static +processOneAndAllPending: Class<CoreProcessEventsOption__processOneAndAllPending> & CoreProcessEventsOption__processOneAndAllPending & 0;// 0
static +processOneIfPresent: Class<CoreProcessEventsOption__processOneIfPresent> & CoreProcessEventsOption__processOneIfPresent & 1;// 1
static +processUntilQuit: Class<CoreProcessEventsOption__processUntilQuit> & CoreProcessEventsOption__processUntilQuit & 2;// 2
static +processAllIfPresent: Class<CoreProcessEventsOption__processAllIfPresent> & CoreProcessEventsOption__processAllIfPresent & 3;// 3

}

declare class CoreProcessEventsOption__processOneAndAllPending mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processOneIfPresent mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processUntilQuit mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processAllIfPresent mixins CoreProcessEventsOption {}

	declare export  class CoreWindowFlowDirection {
  constructor(...args: empty): mixed;
static +leftToRight: Class<CoreWindowFlowDirection__leftToRight> & CoreWindowFlowDirection__leftToRight & 0;// 0
static +rightToLeft: Class<CoreWindowFlowDirection__rightToLeft> & CoreWindowFlowDirection__rightToLeft & 1;// 1

}

declare class CoreWindowFlowDirection__leftToRight mixins CoreWindowFlowDirection {}
declare class CoreWindowFlowDirection__rightToLeft mixins CoreWindowFlowDirection {}

	declare export  class CoreVirtualKeyStates {
  constructor(...args: empty): mixed;
static +none: Class<CoreVirtualKeyStates__none> & CoreVirtualKeyStates__none & 0;// 0
static +down: Class<CoreVirtualKeyStates__down> & CoreVirtualKeyStates__down & 1;// 1
static +locked: Class<CoreVirtualKeyStates__locked> & CoreVirtualKeyStates__locked & 2;// 2

}

declare class CoreVirtualKeyStates__none mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__down mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__locked mixins CoreVirtualKeyStates {}

	declare export  class CoreAcceleratorKeyEventType {
  constructor(...args: empty): mixed;
static +character: Class<CoreAcceleratorKeyEventType__character> & CoreAcceleratorKeyEventType__character & 0;// 0
static +deadCharacter: Class<CoreAcceleratorKeyEventType__deadCharacter> & CoreAcceleratorKeyEventType__deadCharacter & 1;// 1
static +keyDown: Class<CoreAcceleratorKeyEventType__keyDown> & CoreAcceleratorKeyEventType__keyDown & 2;// 2
static +keyUp: Class<CoreAcceleratorKeyEventType__keyUp> & CoreAcceleratorKeyEventType__keyUp & 3;// 3
static +systemCharacter: Class<CoreAcceleratorKeyEventType__systemCharacter> & CoreAcceleratorKeyEventType__systemCharacter & 4;// 4
static +systemDeadCharacter: Class<CoreAcceleratorKeyEventType__systemDeadCharacter> & CoreAcceleratorKeyEventType__systemDeadCharacter & 5;// 5
static +systemKeyDown: Class<CoreAcceleratorKeyEventType__systemKeyDown> & CoreAcceleratorKeyEventType__systemKeyDown & 6;// 6
static +systemKeyUp: Class<CoreAcceleratorKeyEventType__systemKeyUp> & CoreAcceleratorKeyEventType__systemKeyUp & 7;// 7
static +unicodeCharacter: Class<CoreAcceleratorKeyEventType__unicodeCharacter> & CoreAcceleratorKeyEventType__unicodeCharacter & 8;// 8

}

declare class CoreAcceleratorKeyEventType__character mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__deadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemDeadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__unicodeCharacter mixins CoreAcceleratorKeyEventType {}

	declare export  class CoreProximityEvaluationScore {
  constructor(...args: empty): mixed;
static +closest: Class<CoreProximityEvaluationScore__closest> & CoreProximityEvaluationScore__closest & 0;// 0
static +farthest: Class<CoreProximityEvaluationScore__farthest> & CoreProximityEvaluationScore__farthest & 1;// 1

}

declare class CoreProximityEvaluationScore__closest mixins CoreProximityEvaluationScore {}
declare class CoreProximityEvaluationScore__farthest mixins CoreProximityEvaluationScore {}

	declare export interface CorePhysicalKeyStatus {
repeatCount: number,
scanCode: number,
isExtendedKey: boolean,
isMenuKeyDown: boolean,
wasKeyDown: boolean,
isKeyReleased: boolean
} 
	declare export interface CoreProximityEvaluation {
score: number,
adjustedPoint: Windows$Windows$Foundation.Point
} 
	declare export interface ICoreWindowEventArgs {
handled: boolean
} 
	declare export type IAutomationProviderRequestedEventArgs = {
automationProvider: any
} & undefined.ICoreWindowEventArgs

	declare export type ICharacterReceivedEventArgs = {
keyCode: number,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus
} & undefined.ICoreWindowEventArgs

	declare export type IInputEnabledEventArgs = {
inputEnabled: boolean
} & undefined.ICoreWindowEventArgs

	declare export type IKeyEventArgs = {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export type IPointerEventArgs = {
currentPoint: Windows$Windows$UI.Input.PointerPoint,
keyModifiers: Windows$Windows$System.VirtualKeyModifiers,
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
} & undefined.ICoreWindowEventArgs

	declare export type ITouchHitTestingEventArgs = {
boundingBox: Windows$Windows$Foundation.Rect,
point: Windows$Windows$Foundation.Point,
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
} & undefined.ICoreWindowEventArgs

	declare export type IWindowActivatedEventArgs = {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState
} & undefined.ICoreWindowEventArgs

	declare export type IWindowSizeChangedEventArgs = {
size: Windows$Windows$Foundation.Size
} & undefined.ICoreWindowEventArgs

	declare export type IVisibilityChangedEventArgs = {
visible: boolean
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreWindow {
automationHostProvider: any,
bounds: Windows$Windows$Foundation.Rect,
customProperties: Windows$Windows$Foundation.Collections.IPropertySet,
dispatcher: Windows$Windows$UI.Core.CoreDispatcher,
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection,
isInputEnabled: boolean,
pointerCursor: Windows$Windows$UI.Core.CoreCursor,
pointerPosition: Windows$Windows$Foundation.Point,
visible: boolean,
activate(): void,
close(): void,
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
releasePointerCapture(): void,
setPointerCapture(): void,
onactivated: any,
onautomationproviderrequested: any,
oncharacterreceived: any,
onclosed: any,
oninputenabled: any,
onkeydown: any,
onkeyup: any,
onpointercapturelost: any,
onpointerentered: any,
onpointerexited: any,
onpointermoved: any,
onpointerpressed: any,
onpointerreleased: any,
ontouchhittesting: any,
onpointerwheelchanged: any,
onsizechanged: any,
onvisibilitychanged: any
} 
	declare export class CoreDispatcher mixins undefined.ICoreDispatcher, undefined.ICoreAcceleratorKeys {
hasThreadAccess: boolean;
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void;
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
onacceleratorkeyactivated: any
}
	declare export class CoreCursor mixins undefined.ICoreCursor {
constructor(type: Windows$Windows$UI.Core.CoreCursorType, id: number): this;
id: number;
type: Windows$Windows$UI.Core.CoreCursorType
}
	declare export class CoreWindow mixins undefined.ICoreWindow {
automationHostProvider: any;
bounds: Windows$Windows$Foundation.Rect;
customProperties: Windows$Windows$Foundation.Collections.IPropertySet;
dispatcher: Windows$Windows$UI.Core.CoreDispatcher;
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection;
isInputEnabled: boolean;
pointerCursor: Windows$Windows$UI.Core.CoreCursor;
pointerPosition: Windows$Windows$Foundation.Point;
visible: boolean;
activate(): void;
close(): void;
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
releasePointerCapture(): void;
setPointerCapture(): void;
onactivated: any;
onautomationproviderrequested: any;
oncharacterreceived: any;
onclosed: any;
oninputenabled: any;
onkeydown: any;
onkeyup: any;
onpointercapturelost: any;
onpointerentered: any;
onpointerexited: any;
onpointermoved: any;
onpointerpressed: any;
onpointerreleased: any;
ontouchhittesting: any;
onpointerwheelchanged: any;
onsizechanged: any;
onvisibilitychanged: any;
static getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
}
	declare export class WindowActivatedEventArgs mixins undefined.IWindowActivatedEventArgs, undefined.ICoreWindowEventArgs {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState;
handled: boolean
}
	declare export class AutomationProviderRequestedEventArgs mixins undefined.IAutomationProviderRequestedEventArgs, undefined.ICoreWindowEventArgs {
automationProvider: any;
handled: boolean
}
	declare export class CharacterReceivedEventArgs mixins undefined.ICharacterReceivedEventArgs, undefined.ICoreWindowEventArgs {
keyCode: number;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
handled: boolean
}
	declare export class CoreWindowEventArgs mixins undefined.ICoreWindowEventArgs {
handled: boolean
}
	declare export class InputEnabledEventArgs mixins undefined.IInputEnabledEventArgs, undefined.ICoreWindowEventArgs {
inputEnabled: boolean;
handled: boolean
}
	declare export class KeyEventArgs mixins undefined.IKeyEventArgs, undefined.ICoreWindowEventArgs {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export class PointerEventArgs mixins undefined.IPointerEventArgs, undefined.ICoreWindowEventArgs {
currentPoint: Windows$Windows$UI.Input.PointerPoint;
keyModifiers: Windows$Windows$System.VirtualKeyModifiers;
handled: boolean;
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
}
	declare export class TouchHitTestingEventArgs mixins undefined.ITouchHitTestingEventArgs, undefined.ICoreWindowEventArgs {
boundingBox: Windows$Windows$Foundation.Rect;
point: Windows$Windows$Foundation.Point;
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation;
handled: boolean;
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation;
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
}
	declare export class WindowSizeChangedEventArgs mixins undefined.IWindowSizeChangedEventArgs, undefined.ICoreWindowEventArgs {
size: Windows$Windows$Foundation.Size;
handled: boolean
}
	declare export class VisibilityChangedEventArgs mixins undefined.IVisibilityChangedEventArgs, undefined.ICoreWindowEventArgs {
visible: boolean;
handled: boolean
}
	declare export interface ICoreWindowStatic {
getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
} 
	declare export interface DispatchedHandler {
(): void
} 
	declare export interface IdleDispatchedHandler {
(e: Windows$Windows$UI.Core.IdleDispatchedHandlerArgs): void
} 
	declare export class IdleDispatchedHandlerArgs mixins undefined.IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
}
	declare export type IAcceleratorKeyEventArgs = {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
} 
	declare export class AcceleratorKeyEventArgs mixins undefined.IAcceleratorKeyEventArgs, undefined.ICoreWindowEventArgs {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export type ICoreDispatcher = {
hasThreadAccess: boolean,
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void,
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction,
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction
} & undefined.ICoreAcceleratorKeys

	declare export interface IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
} 
	declare export class CoreAcceleratorKeys mixins undefined.ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
}
	declare export interface ICoreCursor {
id: number,
type: Windows$Windows$UI.Core.CoreCursorType
} 
	declare export interface ICoreCursorFactory {
createCursor(
type: Windows$Windows$UI.Core.CoreCursorType,
id: number): Windows$Windows$UI.Core.CoreCursor
} 
	declare export interface IInitializeWithCoreWindow {
initialize(window: Windows$Windows$UI.Core.CoreWindow): void
} 
	declare export interface ICoreWindowResizeManager {
notifyLayoutCompleted(): void
} 
	declare export interface ICoreWindowResizeManagerStatics {
getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
} 
	declare export class CoreWindowResizeManager mixins undefined.ICoreWindowResizeManager {
notifyLayoutCompleted(): void;
static getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
}
	declare export interface ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
} 
	declare export class CoreWindowPopupShowingEventArgs mixins undefined.ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
}
	declare export interface ICoreWindowDialog {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
cancelCommandIndex: number,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowDialogFactory {
createWithTitle(title: string): Windows$Windows$UI.Core.CoreWindowDialog
} 
	declare export class CoreWindowDialog mixins undefined.ICoreWindowDialog {
constructor(title: string): this;
constructor(): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
cancelCommandIndex: number;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
	declare export interface ICoreWindowFlyout {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowFlyoutFactory {
create(
position: Windows$Windows$Foundation.Point): Windows$Windows$UI.Core.CoreWindowFlyout,
createWithTitle(
position: Windows$Windows$Foundation.Point,
title: string): Windows$Windows$UI.Core.CoreWindowFlyout
} 
	declare export class CoreWindowFlyout mixins undefined.ICoreWindowFlyout {
constructor(position: Windows$Windows$Foundation.Point): this;
constructor(position: Windows$Windows$Foundation.Point, title: string): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
    }

	declare export class SuspendingEventArgs mixins undefined.ISuspendingEventArgs {
suspendingOperation: Windows$Windows$ApplicationModel.SuspendingOperation
}
	declare export interface ISuspendingDeferral {
complete(): void
} 
	declare export class SuspendingDeferral mixins undefined.ISuspendingDeferral {
complete(): void
}
	declare export interface ISuspendingOperation {
deadline: Date,
getDeferral(): Windows$Windows$ApplicationModel.SuspendingDeferral
} 
	declare export class SuspendingOperation mixins undefined.ISuspendingOperation {
deadline: Date;
getDeferral(): Windows$Windows$ApplicationModel.SuspendingDeferral
}
	declare export interface ISuspendingEventArgs {
suspendingOperation: Windows$Windows$ApplicationModel.SuspendingOperation
} 
	declare export interface PackageVersion {
major: number,
minor: number,
build: number,
revision: number
} 
	declare export interface IPackageId {
architecture: Windows$Windows$System.ProcessorArchitecture,
familyName: string,
fullName: string,
name: string,
publisher: string,
publisherId: string,
resourceId: string,
version: Windows$Windows$ApplicationModel.PackageVersion
} 
	declare export class PackageId mixins undefined.IPackageId {
architecture: Windows$Windows$System.ProcessorArchitecture;
familyName: string;
fullName: string;
name: string;
publisher: string;
publisherId: string;
resourceId: string;
version: Windows$Windows$ApplicationModel.PackageVersion
}
	declare export interface IPackage {
dependencies: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Package>,
description: string,
displayName: string,
id: Windows$Windows$ApplicationModel.PackageId,
installedLocation: Windows$Windows$Storage.StorageFolder,
isBundle: boolean,
isDevelopmentMode: boolean,
isFramework: boolean,
isResourcePackage: boolean,
logo: Windows$Windows$Foundation.Uri,
publisherDisplayName: string
} 
	declare export class Package mixins undefined.IPackage {
static current: Windows$Windows$ApplicationModel.Package;
dependencies: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Package>;
description: string;
displayName: string;
id: Windows$Windows$ApplicationModel.PackageId;
installedLocation: Windows$Windows$Storage.StorageFolder;
isBundle: boolean;
isDevelopmentMode: boolean;
isFramework: boolean;
isResourcePackage: boolean;
logo: Windows$Windows$Foundation.Uri;
publisherDisplayName: string
}
	declare export interface IPackageStatics {
current: Windows$Windows$ApplicationModel.Package
} 
	declare export interface IDesignModeStatics {
designModeEnabled: boolean
} 
	declare export class DesignMode  {
static designModeEnabled: boolean
}
	declare module 'Resources' {
        declare export interface IResourceLoader {
getString(resource: string): string
} 
	declare export class ResourceLoader mixins undefined.IResourceLoader {
constructor(name: string): this;
constructor(): this;
getString(resource: string): string;
static getStringForReference(uri: Windows$Windows$Foundation.Uri): string
}
	declare export interface IResourceLoaderStatics {
getStringForReference(uri: Windows$Windows$Foundation.Uri): string
} 
	declare export interface IResourceLoaderFactory {
createResourceLoaderByName(name: string): Windows$Windows$ApplicationModel.Resources.ResourceLoader
} 
	declare module 'Core' {
        declare export class CoreApplication  {
static mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>;
static id: string;
static properties: Windows$Windows$Foundation.Collections.IPropertySet;
static incrementApplicationUseCount(): void;
static decrementApplicationUseCount(): void;
static createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static exit(): void;
static onexiting: any;
static onsuspending: any;
static onresuming: any;
static getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void;
static runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
}
	declare export class CoreApplicationView mixins undefined.ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow;
isHosted: boolean;
isMain: boolean;
onactivated: any
}
	declare export interface IFrameworkView {
initialize(
applicationView: Windows$Windows$ApplicationModel.Core.CoreApplicationView): void,
setWindow(window: Windows$Windows$UI.Core.CoreWindow): void,
load(entryPoint: string): void,
run(): void,
uninitialize(): void
} 
	declare export interface IFrameworkViewSource {
createView(): Windows$Windows$ApplicationModel.Core.IFrameworkView
} 
	declare export interface ICoreApplication {
id: string,
properties: Windows$Windows$Foundation.Collections.IPropertySet,
onsuspending: any,
onresuming: any,
getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView,
run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void,
runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
} 
	declare export interface ICoreApplicationUseCount {
incrementApplicationUseCount(): void,
decrementApplicationUseCount(): void
} 
	declare export interface ICoreApplicationExit {
exit(): void,
onexiting: any
} 
	declare export interface ICoreImmersiveApplication {
mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView,
views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>,
createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView
} 
	declare export interface ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow,
isHosted: boolean,
isMain: boolean,
onactivated: any
} 
	declare export interface IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext,
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap,
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void,
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void
} 
	declare export class ResourceMap mixins undefined.IResourceMap, undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
uri: Windows$Windows$Foundation.Uri;
size: number;
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.NamedResource;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>
}
	declare export class ResourceContext mixins undefined.IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>;
reset(): void;
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void;
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void;
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
static createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
}
	declare export interface IResourceManagerStatics {
current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager,
isResourceReference(resourceReference: string): boolean
} 
	declare export class ResourceManager mixins undefined.IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
static current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager;
static isResourceReference(resourceReference: string): boolean
}
	declare export interface IResourceQualifier {
isDefault: boolean,
isMatch: boolean,
qualifierName: string,
qualifierValue: string,
score: number
} 
	declare export class ResourceQualifier mixins undefined.IResourceQualifier {
isDefault: boolean;
isMatch: boolean;
qualifierName: string;
qualifierValue: string;
score: number
}
	declare export interface IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>,
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>,
reset(): void,
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void,
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void,
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceContextStatics {
createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceCandidate {
isDefault: boolean,
isMatch: boolean,
isMatchAsDefault: boolean,
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>,
valueAsString: string,
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
getQualifierValue(qualifierName: string): string
} 
	declare export class ResourceCandidate mixins undefined.IResourceCandidate {
isDefault: boolean;
isMatch: boolean;
isMatchAsDefault: boolean;
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
valueAsString: string;
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
getQualifierValue(qualifierName: string): string
}
	declare export interface INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
uri: Windows$Windows$Foundation.Uri,
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
} 
	declare export class NamedResource mixins undefined.INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
uri: Windows$Windows$Foundation.Uri;
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
}
	declare export type IResourceMap = {
uri: Windows$Windows$Foundation.Uri,
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap
} & undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource> & undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>

	declare export class ResourceMapIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>[],
returnValue: number
}
}
	declare export class ResourceMapMapView mixins undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
size: number;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>>
}
	declare export class ResourceMapMapViewIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>[],
returnValue: number
}
}
	declare export class ResourceQualifierObservableMap mixins undefined.IObservableMap<string, string>, undefined.IMap<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
onmapchanged: any;
lookup(key: string): string;
hasKey(key: string): boolean;
getView(): Windows$Windows$Foundation.Collections.IMapView<string, string>;
insert(key: string, value: string): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierMapView mixins undefined.IMapView<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
lookup(key: string): string;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, string>,
second: Windows$Windows$Foundation.Collections.IMapView<string, string>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceCandidateVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceContextLanguagesVectorView mixins undefined.IVectorView<string>, undefined.IIterable<string> {
size: number;
getAt(index: number): string;
indexOf(value: string): {
index: number,
returnValue: boolean
};
getMany(startIndex: number): {
items: string[],
returnValue: number
};
first(): Windows$Windows$Foundation.Collections.IIterator<string>;
toString(): string;
toLocaleString(): string;
concat(...items: string[][]): string[];
join(seperator: string): string;
pop(): string;
push(...items: string[]): void;
reverse(): string[];
shift(): string;
slice(start: number): string[];
slice(start: number, end: number): string[];
sort(): string[];
sort(compareFn: (a: string, b: string) => number): string[];
splice(start: number): string[];
splice(start: number, deleteCount: number, ...items: string[]): string[];
unshift(...items: string[]): number;
lastIndexOf(searchElement: string): number;
lastIndexOf(searchElement: string, fromIndex: number): number;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
forEach(callbackfn: (value: string, index: number, array: string[]) => void): void;
forEach(
callbackfn: (value: string, index: number, array: string[]) => void,
thisArg: any): void;
map(callbackfn: (value: string, index: number, array: string[]) => any): any[];
map(
callbackfn: (value: string, index: number, array: string[]) => any,
thisArg: any): any[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean): string[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): string[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
length: number
}
	declare export interface IApplicationDataManagerStatics {
createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
} 
	declare export interface IApplicationDataManager {} 
	declare export class ApplicationDataManager mixins undefined.IApplicationDataManager {
static createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
}
	declare export  class CryptographicPrivateKeyBlobType {
  constructor(...args: empty): mixed;
static +pkcs8RawPrivateKeyInfo: Class<CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo> & CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo & 0;// 0
static +pkcs1RsaPrivateKey: Class<CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey> & CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey & 1;// 1
static +bCryptPrivateKey: Class<CryptographicPrivateKeyBlobType__bCryptPrivateKey> & CryptographicPrivateKeyBlobType__bCryptPrivateKey & 2;// 2
static +capi1PrivateKey: Class<CryptographicPrivateKeyBlobType__capi1PrivateKey> & CryptographicPrivateKeyBlobType__capi1PrivateKey & 3;// 3

}

declare class CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__bCryptPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__capi1PrivateKey mixins CryptographicPrivateKeyBlobType {}

	declare export  class CryptographicPublicKeyBlobType {
  constructor(...args: empty): mixed;
static +x509SubjectPublicKeyInfo: Class<CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo> & CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo & 0;// 0
static +pkcs1RsaPublicKey: Class<CryptographicPublicKeyBlobType__pkcs1RsaPublicKey> & CryptographicPublicKeyBlobType__pkcs1RsaPublicKey & 1;// 1
static +bCryptPublicKey: Class<CryptographicPublicKeyBlobType__bCryptPublicKey> & CryptographicPublicKeyBlobType__bCryptPublicKey & 2;// 2
static +capi1PublicKey: Class<CryptographicPublicKeyBlobType__capi1PublicKey> & CryptographicPublicKeyBlobType__capi1PublicKey & 3;// 3

}

declare class CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__pkcs1RsaPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__bCryptPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__capi1PublicKey mixins CryptographicPublicKeyBlobType {}

	declare export interface IKeyDerivationParameters {
iterationCount: number,
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export interface IKeyDerivationParametersStatics {
buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
} 
	declare export class KeyDerivationParameters mixins undefined.IKeyDerivationParameters {
iterationCount: number;
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer;
static buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
}
	declare export interface ICryptographicKey {
keySize: number,
export(): Windows$Windows$Storage.Streams.IBuffer,
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicKey mixins undefined.ICryptographicKey {
keySize: number;
export(): Windows$Windows$Storage.Streams.IBuffer;
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void,
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicHash mixins undefined.IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void;
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProvider {
algorithmName: string,
hashLength: number,
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash
} 
	declare export interface IMacAlgorithmProvider {
algorithmName: string,
macLength: number,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IKeyDerivationAlgorithmProvider {
algorithmName: string,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface ISymmetricKeyAlgorithmProvider {
algorithmName: string,
blockLength: number,
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IAsymmetricKeyAlgorithmProvider {
algorithmName: string,
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
encryptedData: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class EncryptedAndAuthenticatedData mixins undefined.IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer;
encryptedData: Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface ICryptographicEngineStatics {
encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData,
decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean,
deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicEngine  {
static encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData;
static decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean;
static deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
} 
	declare export class HashAlgorithmProvider mixins undefined.IHashAlgorithmProvider {
algorithmName: string;
hashLength: number;
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
}
	declare export interface IMacAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
} 
	declare export class MacAlgorithmProvider mixins undefined.IMacAlgorithmProvider {
algorithmName: string;
macLength: number;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
}
	declare export interface IKeyDerivationAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
} 
	declare export class KeyDerivationAlgorithmProvider mixins undefined.IKeyDerivationAlgorithmProvider {
algorithmName: string;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
}
	declare export interface ISymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
} 
	declare export class SymmetricKeyAlgorithmProvider mixins undefined.ISymmetricKeyAlgorithmProvider {
algorithmName: string;
blockLength: number;
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
}
	declare export interface IAsymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
} 
	declare export class AsymmetricKeyAlgorithmProvider mixins undefined.IAsymmetricKeyAlgorithmProvider {
algorithmName: string;
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
}
	declare export interface IHashAlgorithmNamesStatics {
md5: string,
sha1: string,
sha256: string,
sha384: string,
sha512: string
} 
	declare export class HashAlgorithmNames  {
static md5: string;
static sha1: string;
static sha256: string;
static sha384: string;
static sha512: string
}
	declare export interface IMacAlgorithmNamesStatics {
aesCmac: string,
hmacMd5: string,
hmacSha1: string,
hmacSha256: string,
hmacSha384: string,
hmacSha512: string
} 
	declare export class MacAlgorithmNames  {
static aesCmac: string;
static hmacMd5: string;
static hmacSha1: string;
static hmacSha256: string;
static hmacSha384: string;
static hmacSha512: string
}
	declare export interface ISymmetricAlgorithmNamesStatics {
aesCbc: string,
aesCbcPkcs7: string,
aesCcm: string,
aesEcb: string,
aesEcbPkcs7: string,
aesGcm: string,
desCbc: string,
desCbcPkcs7: string,
desEcb: string,
desEcbPkcs7: string,
rc2Cbc: string,
rc2CbcPkcs7: string,
rc2Ecb: string,
rc2EcbPkcs7: string,
rc4: string,
tripleDesCbc: string,
tripleDesCbcPkcs7: string,
tripleDesEcb: string,
tripleDesEcbPkcs7: string
} 
	declare export class SymmetricAlgorithmNames  {
static aesCbc: string;
static aesCbcPkcs7: string;
static aesCcm: string;
static aesEcb: string;
static aesEcbPkcs7: string;
static aesGcm: string;
static desCbc: string;
static desCbcPkcs7: string;
static desEcb: string;
static desEcbPkcs7: string;
static rc2Cbc: string;
static rc2CbcPkcs7: string;
static rc2Ecb: string;
static rc2EcbPkcs7: string;
static rc4: string;
static tripleDesCbc: string;
static tripleDesCbcPkcs7: string;
static tripleDesEcb: string;
static tripleDesEcbPkcs7: string
}
	declare export interface IAsymmetricAlgorithmNamesStatics {
dsaSha1: string,
dsaSha256: string,
ecdsaP256Sha256: string,
ecdsaP384Sha384: string,
ecdsaP521Sha512: string,
rsaOaepSha1: string,
rsaOaepSha256: string,
rsaOaepSha384: string,
rsaOaepSha512: string,
rsaPkcs1: string,
rsaSignPkcs1Sha1: string,
rsaSignPkcs1Sha256: string,
rsaSignPkcs1Sha384: string,
rsaSignPkcs1Sha512: string,
rsaSignPssSha1: string,
rsaSignPssSha256: string,
rsaSignPssSha384: string,
rsaSignPssSha512: string
} 
	declare export class AsymmetricAlgorithmNames  {
static dsaSha1: string;
static dsaSha256: string;
static ecdsaP256Sha256: string;
static ecdsaP384Sha384: string;
static ecdsaP521Sha512: string;
static rsaOaepSha1: string;
static rsaOaepSha256: string;
static rsaOaepSha384: string;
static rsaOaepSha512: string;
static rsaPkcs1: string;
static rsaSignPkcs1Sha1: string;
static rsaSignPkcs1Sha256: string;
static rsaSignPkcs1Sha384: string;
static rsaSignPkcs1Sha512: string;
static rsaSignPssSha1: string;
static rsaSignPssSha256: string;
static rsaSignPssSha384: string;
static rsaSignPssSha512: string
}
	declare export interface IKeyDerivationAlgorithmNamesStatics {
pbkdf2Md5: string,
pbkdf2Sha1: string,
pbkdf2Sha256: string,
pbkdf2Sha384: string,
pbkdf2Sha512: string,
sp800108CtrHmacMd5: string,
sp800108CtrHmacSha1: string,
sp800108CtrHmacSha256: string,
sp800108CtrHmacSha384: string,
sp800108CtrHmacSha512: string,
sp80056aConcatMd5: string,
sp80056aConcatSha1: string,
sp80056aConcatSha256: string,
sp80056aConcatSha384: string,
sp80056aConcatSha512: string
} 
	declare export class KeyDerivationAlgorithmNames  {
static pbkdf2Md5: string;
static pbkdf2Sha1: string;
static pbkdf2Sha256: string;
static pbkdf2Sha384: string;
static pbkdf2Sha512: string;
static sp800108CtrHmacMd5: string;
static sp800108CtrHmacSha1: string;
static sp800108CtrHmacSha256: string;
static sp800108CtrHmacSha384: string;
static sp800108CtrHmacSha512: string;
static sp80056aConcatMd5: string;
static sp80056aConcatSha1: string;
static sp80056aConcatSha256: string;
static sp80056aConcatSha384: string;
static sp80056aConcatSha512: string
}
	declare export interface SignalHandler {
(signalNotifier: Windows$Windows$System.Threading.Core.SignalNotifier, timedOut: boolean): void
} 
	declare export class SignalNotifier mixins undefined.ISignalNotifier {
enable(): void;
terminate(): void;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
}
	declare export interface ISignalNotifierStatics {
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
} 
	declare export interface IPreallocatedWorkItemFactory {
createWorkItem(
handler: Windows$Windows$System.Threading.WorkItemHandler): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriority(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriorityAndOptions(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority,
options: Windows$Windows$System.Threading.WorkItemOptions): Windows$Windows$System.Threading.Core.PreallocatedWorkItem
} 
	declare export class PreallocatedWorkItem mixins undefined.IPreallocatedWorkItem {
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority, options: Windows$Windows$System.Threading.WorkItemOptions): this;
runAsync(): Windows$Windows$Foundation.IAsyncAction
}
	declare export interface IPreallocatedWorkItem {
runAsync(): Windows$Windows$Foundation.IAsyncAction
} 
	declare export interface ISignalNotifier {
enable(): void,
terminate(): void
} 
	declare module 'AnimationMetrics' {
        declare export  class PropertyAnimationType {
  constructor(...args: empty): mixed;
static +scale: Class<PropertyAnimationType__scale> & PropertyAnimationType__scale & 0;// 0
static +translation: Class<PropertyAnimationType__translation> & PropertyAnimationType__translation & 1;// 1
static +opacity: Class<PropertyAnimationType__opacity> & PropertyAnimationType__opacity & 2;// 2

}

declare class PropertyAnimationType__scale mixins PropertyAnimationType {}
declare class PropertyAnimationType__translation mixins PropertyAnimationType {}
declare class PropertyAnimationType__opacity mixins PropertyAnimationType {}

	declare export interface IPropertyAnimation {
control1: Windows$Windows$Foundation.Point,
control2: Windows$Windows$Foundation.Point,
delay: number,
duration: number,
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
} 
	declare export type IScaleAnimation = {
finalScaleX: number,
finalScaleY: number,
initialScaleX: number,
initialScaleY: number,
normalizedOrigin: Windows$Windows$Foundation.Point
} & undefined.IPropertyAnimation

	declare export type IOpacityAnimation = {
finalOpacity: number,
initialOpacity: number
} & undefined.IPropertyAnimation

	declare export  class AnimationEffect {
  constructor(...args: empty): mixed;
static +expand: Class<AnimationEffect__expand> & AnimationEffect__expand & 0;// 0
static +collapse: Class<AnimationEffect__collapse> & AnimationEffect__collapse & 1;// 1
static +reposition: Class<AnimationEffect__reposition> & AnimationEffect__reposition & 2;// 2
static +fadeIn: Class<AnimationEffect__fadeIn> & AnimationEffect__fadeIn & 3;// 3
static +fadeOut: Class<AnimationEffect__fadeOut> & AnimationEffect__fadeOut & 4;// 4
static +addToList: Class<AnimationEffect__addToList> & AnimationEffect__addToList & 5;// 5
static +deleteFromList: Class<AnimationEffect__deleteFromList> & AnimationEffect__deleteFromList & 6;// 6
static +addToGrid: Class<AnimationEffect__addToGrid> & AnimationEffect__addToGrid & 7;// 7
static +deleteFromGrid: Class<AnimationEffect__deleteFromGrid> & AnimationEffect__deleteFromGrid & 8;// 8
static +addToSearchGrid: Class<AnimationEffect__addToSearchGrid> & AnimationEffect__addToSearchGrid & 9;// 9
static +deleteFromSearchGrid: Class<AnimationEffect__deleteFromSearchGrid> & AnimationEffect__deleteFromSearchGrid & 10;// 10
static +addToSearchList: Class<AnimationEffect__addToSearchList> & AnimationEffect__addToSearchList & 11;// 11
static +deleteFromSearchList: Class<AnimationEffect__deleteFromSearchList> & AnimationEffect__deleteFromSearchList & 12;// 12
static +showEdgeUI: Class<AnimationEffect__showEdgeUI> & AnimationEffect__showEdgeUI & 13;// 13
static +showPanel: Class<AnimationEffect__showPanel> & AnimationEffect__showPanel & 14;// 14
static +hideEdgeUI: Class<AnimationEffect__hideEdgeUI> & AnimationEffect__hideEdgeUI & 15;// 15
static +hidePanel: Class<AnimationEffect__hidePanel> & AnimationEffect__hidePanel & 16;// 16
static +showPopup: Class<AnimationEffect__showPopup> & AnimationEffect__showPopup & 17;// 17
static +hidePopup: Class<AnimationEffect__hidePopup> & AnimationEffect__hidePopup & 18;// 18
static +pointerDown: Class<AnimationEffect__pointerDown> & AnimationEffect__pointerDown & 19;// 19
static +pointerUp: Class<AnimationEffect__pointerUp> & AnimationEffect__pointerUp & 20;// 20
static +dragSourceStart: Class<AnimationEffect__dragSourceStart> & AnimationEffect__dragSourceStart & 21;// 21
static +dragSourceEnd: Class<AnimationEffect__dragSourceEnd> & AnimationEffect__dragSourceEnd & 22;// 22
static +transitionContent: Class<AnimationEffect__transitionContent> & AnimationEffect__transitionContent & 23;// 23
static +reveal: Class<AnimationEffect__reveal> & AnimationEffect__reveal & 24;// 24
static +hide: Class<AnimationEffect__hide> & AnimationEffect__hide & 25;// 25
static +dragBetweenEnter: Class<AnimationEffect__dragBetweenEnter> & AnimationEffect__dragBetweenEnter & 26;// 26
static +dragBetweenLeave: Class<AnimationEffect__dragBetweenLeave> & AnimationEffect__dragBetweenLeave & 27;// 27
static +swipeSelect: Class<AnimationEffect__swipeSelect> & AnimationEffect__swipeSelect & 28;// 28
static +swipeDeselect: Class<AnimationEffect__swipeDeselect> & AnimationEffect__swipeDeselect & 29;// 29
static +swipeReveal: Class<AnimationEffect__swipeReveal> & AnimationEffect__swipeReveal & 30;// 30
static +enterPage: Class<AnimationEffect__enterPage> & AnimationEffect__enterPage & 31;// 31
static +transitionPage: Class<AnimationEffect__transitionPage> & AnimationEffect__transitionPage & 32;// 32
static +crossFade: Class<AnimationEffect__crossFade> & AnimationEffect__crossFade & 33;// 33
static +peek: Class<AnimationEffect__peek> & AnimationEffect__peek & 34;// 34
static +updateBadge: Class<AnimationEffect__updateBadge> & AnimationEffect__updateBadge & 35;// 35

}

declare class AnimationEffect__expand mixins AnimationEffect {}
declare class AnimationEffect__collapse mixins AnimationEffect {}
declare class AnimationEffect__reposition mixins AnimationEffect {}
declare class AnimationEffect__fadeIn mixins AnimationEffect {}
declare class AnimationEffect__fadeOut mixins AnimationEffect {}
declare class AnimationEffect__addToList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromList mixins AnimationEffect {}
declare class AnimationEffect__addToGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchList mixins AnimationEffect {}
declare class AnimationEffect__showEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__showPanel mixins AnimationEffect {}
declare class AnimationEffect__hideEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__hidePanel mixins AnimationEffect {}
declare class AnimationEffect__showPopup mixins AnimationEffect {}
declare class AnimationEffect__hidePopup mixins AnimationEffect {}
declare class AnimationEffect__pointerDown mixins AnimationEffect {}
declare class AnimationEffect__pointerUp mixins AnimationEffect {}
declare class AnimationEffect__dragSourceStart mixins AnimationEffect {}
declare class AnimationEffect__dragSourceEnd mixins AnimationEffect {}
declare class AnimationEffect__transitionContent mixins AnimationEffect {}
declare class AnimationEffect__reveal mixins AnimationEffect {}
declare class AnimationEffect__hide mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenEnter mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenLeave mixins AnimationEffect {}
declare class AnimationEffect__swipeSelect mixins AnimationEffect {}
declare class AnimationEffect__swipeDeselect mixins AnimationEffect {}
declare class AnimationEffect__swipeReveal mixins AnimationEffect {}
declare class AnimationEffect__enterPage mixins AnimationEffect {}
declare class AnimationEffect__transitionPage mixins AnimationEffect {}
declare class AnimationEffect__crossFade mixins AnimationEffect {}
declare class AnimationEffect__peek mixins AnimationEffect {}
declare class AnimationEffect__updateBadge mixins AnimationEffect {}

	declare export  class AnimationEffectTarget {
  constructor(...args: empty): mixed;
static +primary: Class<AnimationEffectTarget__primary> & AnimationEffectTarget__primary & 0;// 0
static +added: Class<AnimationEffectTarget__added> & AnimationEffectTarget__added & 1;// 1
static +affected: Class<AnimationEffectTarget__affected> & AnimationEffectTarget__affected & 2;// 2
static +background: Class<AnimationEffectTarget__background> & AnimationEffectTarget__background & 3;// 3
static +content: Class<AnimationEffectTarget__content> & AnimationEffectTarget__content & 4;// 4
static +deleted: Class<AnimationEffectTarget__deleted> & AnimationEffectTarget__deleted & 5;// 5
static +deselected: Class<AnimationEffectTarget__deselected> & AnimationEffectTarget__deselected & 6;// 6
static +dragSource: Class<AnimationEffectTarget__dragSource> & AnimationEffectTarget__dragSource & 7;// 7
static +hidden: Class<AnimationEffectTarget__hidden> & AnimationEffectTarget__hidden & 8;// 8
static +incoming: Class<AnimationEffectTarget__incoming> & AnimationEffectTarget__incoming & 9;// 9
static +outgoing: Class<AnimationEffectTarget__outgoing> & AnimationEffectTarget__outgoing & 10;// 10
static +outline: Class<AnimationEffectTarget__outline> & AnimationEffectTarget__outline & 11;// 11
static +remaining: Class<AnimationEffectTarget__remaining> & AnimationEffectTarget__remaining & 12;// 12
static +revealed: Class<AnimationEffectTarget__revealed> & AnimationEffectTarget__revealed & 13;// 13
static +rowIn: Class<AnimationEffectTarget__rowIn> & AnimationEffectTarget__rowIn & 14;// 14
static +rowOut: Class<AnimationEffectTarget__rowOut> & AnimationEffectTarget__rowOut & 15;// 15
static +selected: Class<AnimationEffectTarget__selected> & AnimationEffectTarget__selected & 16;// 16
static +selection: Class<AnimationEffectTarget__selection> & AnimationEffectTarget__selection & 17;// 17
static +shown: Class<AnimationEffectTarget__shown> & AnimationEffectTarget__shown & 18;// 18
static +tapped: Class<AnimationEffectTarget__tapped> & AnimationEffectTarget__tapped & 19;// 19

}

declare class AnimationEffectTarget__primary mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__added mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__affected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__background mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__content mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deleted mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deselected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__dragSource mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__hidden mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__incoming mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outgoing mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outline mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__remaining mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__revealed mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowIn mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowOut mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selection mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__shown mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__tapped mixins AnimationEffectTarget {}

	declare export interface IAnimationDescription {
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>,
delayLimit: number,
staggerDelay: number,
staggerDelayFactor: number,
zOrder: number
} 
	declare export interface IAnimationDescriptionFactory {
createInstance(
effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect,
target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): Windows$Windows$UI.Core.AnimationMetrics.AnimationDescription
} 
	declare export class AnimationDescription mixins undefined.IAnimationDescription {
constructor(effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect, target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): this;
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>;
delayLimit: number;
staggerDelay: number;
staggerDelayFactor: number;
zOrder: number
}
	declare export class PropertyAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class ScaleAnimation mixins undefined.IScaleAnimation, undefined.IPropertyAnimation {
finalScaleX: number;
finalScaleY: number;
initialScaleX: number;
initialScaleY: number;
normalizedOrigin: Windows$Windows$Foundation.Point;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class TranslationAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class OpacityAnimation mixins undefined.IOpacityAnimation, undefined.IPropertyAnimation {
finalOpacity: number;
initialOpacity: number;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
    }

	declare export  class CoreWindowActivationState {
  constructor(...args: empty): mixed;
static +codeActivated: Class<CoreWindowActivationState__codeActivated> & CoreWindowActivationState__codeActivated & 0;// 0
static +deactivated: Class<CoreWindowActivationState__deactivated> & CoreWindowActivationState__deactivated & 1;// 1
static +pointerActivated: Class<CoreWindowActivationState__pointerActivated> & CoreWindowActivationState__pointerActivated & 2;// 2

}

declare class CoreWindowActivationState__codeActivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__deactivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__pointerActivated mixins CoreWindowActivationState {}

	declare export  class CoreCursorType {
  constructor(...args: empty): mixed;
static +arrow: Class<CoreCursorType__arrow> & CoreCursorType__arrow & 0;// 0
static +cross: Class<CoreCursorType__cross> & CoreCursorType__cross & 1;// 1
static +custom: Class<CoreCursorType__custom> & CoreCursorType__custom & 2;// 2
static +hand: Class<CoreCursorType__hand> & CoreCursorType__hand & 3;// 3
static +help: Class<CoreCursorType__help> & CoreCursorType__help & 4;// 4
static +iBeam: Class<CoreCursorType__iBeam> & CoreCursorType__iBeam & 5;// 5
static +sizeAll: Class<CoreCursorType__sizeAll> & CoreCursorType__sizeAll & 6;// 6
static +sizeNortheastSouthwest: Class<CoreCursorType__sizeNortheastSouthwest> & CoreCursorType__sizeNortheastSouthwest & 7;// 7
static +sizeNorthSouth: Class<CoreCursorType__sizeNorthSouth> & CoreCursorType__sizeNorthSouth & 8;// 8
static +sizeNorthwestSoutheast: Class<CoreCursorType__sizeNorthwestSoutheast> & CoreCursorType__sizeNorthwestSoutheast & 9;// 9
static +sizeWestEast: Class<CoreCursorType__sizeWestEast> & CoreCursorType__sizeWestEast & 10;// 10
static +universalNo: Class<CoreCursorType__universalNo> & CoreCursorType__universalNo & 11;// 11
static +upArrow: Class<CoreCursorType__upArrow> & CoreCursorType__upArrow & 12;// 12
static +wait: Class<CoreCursorType__wait> & CoreCursorType__wait & 13;// 13

}

declare class CoreCursorType__arrow mixins CoreCursorType {}
declare class CoreCursorType__cross mixins CoreCursorType {}
declare class CoreCursorType__custom mixins CoreCursorType {}
declare class CoreCursorType__hand mixins CoreCursorType {}
declare class CoreCursorType__help mixins CoreCursorType {}
declare class CoreCursorType__iBeam mixins CoreCursorType {}
declare class CoreCursorType__sizeAll mixins CoreCursorType {}
declare class CoreCursorType__sizeNortheastSouthwest mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthSouth mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthwestSoutheast mixins CoreCursorType {}
declare class CoreCursorType__sizeWestEast mixins CoreCursorType {}
declare class CoreCursorType__universalNo mixins CoreCursorType {}
declare class CoreCursorType__upArrow mixins CoreCursorType {}
declare class CoreCursorType__wait mixins CoreCursorType {}

	declare export  class CoreDispatcherPriority {
  constructor(...args: empty): mixed;
static +low: Class<CoreDispatcherPriority__low> & CoreDispatcherPriority__low & 0;// 0
static +normal: Class<CoreDispatcherPriority__normal> & CoreDispatcherPriority__normal & 1;// 1
static +high: Class<CoreDispatcherPriority__high> & CoreDispatcherPriority__high & 2;// 2

}

declare class CoreDispatcherPriority__low mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__normal mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__high mixins CoreDispatcherPriority {}

	declare export  class CoreProcessEventsOption {
  constructor(...args: empty): mixed;
static +processOneAndAllPending: Class<CoreProcessEventsOption__processOneAndAllPending> & CoreProcessEventsOption__processOneAndAllPending & 0;// 0
static +processOneIfPresent: Class<CoreProcessEventsOption__processOneIfPresent> & CoreProcessEventsOption__processOneIfPresent & 1;// 1
static +processUntilQuit: Class<CoreProcessEventsOption__processUntilQuit> & CoreProcessEventsOption__processUntilQuit & 2;// 2
static +processAllIfPresent: Class<CoreProcessEventsOption__processAllIfPresent> & CoreProcessEventsOption__processAllIfPresent & 3;// 3

}

declare class CoreProcessEventsOption__processOneAndAllPending mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processOneIfPresent mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processUntilQuit mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processAllIfPresent mixins CoreProcessEventsOption {}

	declare export  class CoreWindowFlowDirection {
  constructor(...args: empty): mixed;
static +leftToRight: Class<CoreWindowFlowDirection__leftToRight> & CoreWindowFlowDirection__leftToRight & 0;// 0
static +rightToLeft: Class<CoreWindowFlowDirection__rightToLeft> & CoreWindowFlowDirection__rightToLeft & 1;// 1

}

declare class CoreWindowFlowDirection__leftToRight mixins CoreWindowFlowDirection {}
declare class CoreWindowFlowDirection__rightToLeft mixins CoreWindowFlowDirection {}

	declare export  class CoreVirtualKeyStates {
  constructor(...args: empty): mixed;
static +none: Class<CoreVirtualKeyStates__none> & CoreVirtualKeyStates__none & 0;// 0
static +down: Class<CoreVirtualKeyStates__down> & CoreVirtualKeyStates__down & 1;// 1
static +locked: Class<CoreVirtualKeyStates__locked> & CoreVirtualKeyStates__locked & 2;// 2

}

declare class CoreVirtualKeyStates__none mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__down mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__locked mixins CoreVirtualKeyStates {}

	declare export  class CoreAcceleratorKeyEventType {
  constructor(...args: empty): mixed;
static +character: Class<CoreAcceleratorKeyEventType__character> & CoreAcceleratorKeyEventType__character & 0;// 0
static +deadCharacter: Class<CoreAcceleratorKeyEventType__deadCharacter> & CoreAcceleratorKeyEventType__deadCharacter & 1;// 1
static +keyDown: Class<CoreAcceleratorKeyEventType__keyDown> & CoreAcceleratorKeyEventType__keyDown & 2;// 2
static +keyUp: Class<CoreAcceleratorKeyEventType__keyUp> & CoreAcceleratorKeyEventType__keyUp & 3;// 3
static +systemCharacter: Class<CoreAcceleratorKeyEventType__systemCharacter> & CoreAcceleratorKeyEventType__systemCharacter & 4;// 4
static +systemDeadCharacter: Class<CoreAcceleratorKeyEventType__systemDeadCharacter> & CoreAcceleratorKeyEventType__systemDeadCharacter & 5;// 5
static +systemKeyDown: Class<CoreAcceleratorKeyEventType__systemKeyDown> & CoreAcceleratorKeyEventType__systemKeyDown & 6;// 6
static +systemKeyUp: Class<CoreAcceleratorKeyEventType__systemKeyUp> & CoreAcceleratorKeyEventType__systemKeyUp & 7;// 7
static +unicodeCharacter: Class<CoreAcceleratorKeyEventType__unicodeCharacter> & CoreAcceleratorKeyEventType__unicodeCharacter & 8;// 8

}

declare class CoreAcceleratorKeyEventType__character mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__deadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemDeadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__unicodeCharacter mixins CoreAcceleratorKeyEventType {}

	declare export  class CoreProximityEvaluationScore {
  constructor(...args: empty): mixed;
static +closest: Class<CoreProximityEvaluationScore__closest> & CoreProximityEvaluationScore__closest & 0;// 0
static +farthest: Class<CoreProximityEvaluationScore__farthest> & CoreProximityEvaluationScore__farthest & 1;// 1

}

declare class CoreProximityEvaluationScore__closest mixins CoreProximityEvaluationScore {}
declare class CoreProximityEvaluationScore__farthest mixins CoreProximityEvaluationScore {}

	declare export interface CorePhysicalKeyStatus {
repeatCount: number,
scanCode: number,
isExtendedKey: boolean,
isMenuKeyDown: boolean,
wasKeyDown: boolean,
isKeyReleased: boolean
} 
	declare export interface CoreProximityEvaluation {
score: number,
adjustedPoint: Windows$Windows$Foundation.Point
} 
	declare export interface ICoreWindowEventArgs {
handled: boolean
} 
	declare export type IAutomationProviderRequestedEventArgs = {
automationProvider: any
} & undefined.ICoreWindowEventArgs

	declare export type ICharacterReceivedEventArgs = {
keyCode: number,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus
} & undefined.ICoreWindowEventArgs

	declare export type IInputEnabledEventArgs = {
inputEnabled: boolean
} & undefined.ICoreWindowEventArgs

	declare export type IKeyEventArgs = {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export type IPointerEventArgs = {
currentPoint: Windows$Windows$UI.Input.PointerPoint,
keyModifiers: Windows$Windows$System.VirtualKeyModifiers,
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
} & undefined.ICoreWindowEventArgs

	declare export type ITouchHitTestingEventArgs = {
boundingBox: Windows$Windows$Foundation.Rect,
point: Windows$Windows$Foundation.Point,
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
} & undefined.ICoreWindowEventArgs

	declare export type IWindowActivatedEventArgs = {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState
} & undefined.ICoreWindowEventArgs

	declare export type IWindowSizeChangedEventArgs = {
size: Windows$Windows$Foundation.Size
} & undefined.ICoreWindowEventArgs

	declare export type IVisibilityChangedEventArgs = {
visible: boolean
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreWindow {
automationHostProvider: any,
bounds: Windows$Windows$Foundation.Rect,
customProperties: Windows$Windows$Foundation.Collections.IPropertySet,
dispatcher: Windows$Windows$UI.Core.CoreDispatcher,
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection,
isInputEnabled: boolean,
pointerCursor: Windows$Windows$UI.Core.CoreCursor,
pointerPosition: Windows$Windows$Foundation.Point,
visible: boolean,
activate(): void,
close(): void,
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
releasePointerCapture(): void,
setPointerCapture(): void,
onactivated: any,
onautomationproviderrequested: any,
oncharacterreceived: any,
onclosed: any,
oninputenabled: any,
onkeydown: any,
onkeyup: any,
onpointercapturelost: any,
onpointerentered: any,
onpointerexited: any,
onpointermoved: any,
onpointerpressed: any,
onpointerreleased: any,
ontouchhittesting: any,
onpointerwheelchanged: any,
onsizechanged: any,
onvisibilitychanged: any
} 
	declare export class CoreDispatcher mixins undefined.ICoreDispatcher, undefined.ICoreAcceleratorKeys {
hasThreadAccess: boolean;
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void;
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
onacceleratorkeyactivated: any
}
	declare export class CoreCursor mixins undefined.ICoreCursor {
constructor(type: Windows$Windows$UI.Core.CoreCursorType, id: number): this;
id: number;
type: Windows$Windows$UI.Core.CoreCursorType
}
	declare export class CoreWindow mixins undefined.ICoreWindow {
automationHostProvider: any;
bounds: Windows$Windows$Foundation.Rect;
customProperties: Windows$Windows$Foundation.Collections.IPropertySet;
dispatcher: Windows$Windows$UI.Core.CoreDispatcher;
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection;
isInputEnabled: boolean;
pointerCursor: Windows$Windows$UI.Core.CoreCursor;
pointerPosition: Windows$Windows$Foundation.Point;
visible: boolean;
activate(): void;
close(): void;
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
releasePointerCapture(): void;
setPointerCapture(): void;
onactivated: any;
onautomationproviderrequested: any;
oncharacterreceived: any;
onclosed: any;
oninputenabled: any;
onkeydown: any;
onkeyup: any;
onpointercapturelost: any;
onpointerentered: any;
onpointerexited: any;
onpointermoved: any;
onpointerpressed: any;
onpointerreleased: any;
ontouchhittesting: any;
onpointerwheelchanged: any;
onsizechanged: any;
onvisibilitychanged: any;
static getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
}
	declare export class WindowActivatedEventArgs mixins undefined.IWindowActivatedEventArgs, undefined.ICoreWindowEventArgs {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState;
handled: boolean
}
	declare export class AutomationProviderRequestedEventArgs mixins undefined.IAutomationProviderRequestedEventArgs, undefined.ICoreWindowEventArgs {
automationProvider: any;
handled: boolean
}
	declare export class CharacterReceivedEventArgs mixins undefined.ICharacterReceivedEventArgs, undefined.ICoreWindowEventArgs {
keyCode: number;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
handled: boolean
}
	declare export class CoreWindowEventArgs mixins undefined.ICoreWindowEventArgs {
handled: boolean
}
	declare export class InputEnabledEventArgs mixins undefined.IInputEnabledEventArgs, undefined.ICoreWindowEventArgs {
inputEnabled: boolean;
handled: boolean
}
	declare export class KeyEventArgs mixins undefined.IKeyEventArgs, undefined.ICoreWindowEventArgs {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export class PointerEventArgs mixins undefined.IPointerEventArgs, undefined.ICoreWindowEventArgs {
currentPoint: Windows$Windows$UI.Input.PointerPoint;
keyModifiers: Windows$Windows$System.VirtualKeyModifiers;
handled: boolean;
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
}
	declare export class TouchHitTestingEventArgs mixins undefined.ITouchHitTestingEventArgs, undefined.ICoreWindowEventArgs {
boundingBox: Windows$Windows$Foundation.Rect;
point: Windows$Windows$Foundation.Point;
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation;
handled: boolean;
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation;
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
}
	declare export class WindowSizeChangedEventArgs mixins undefined.IWindowSizeChangedEventArgs, undefined.ICoreWindowEventArgs {
size: Windows$Windows$Foundation.Size;
handled: boolean
}
	declare export class VisibilityChangedEventArgs mixins undefined.IVisibilityChangedEventArgs, undefined.ICoreWindowEventArgs {
visible: boolean;
handled: boolean
}
	declare export interface ICoreWindowStatic {
getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
} 
	declare export interface DispatchedHandler {
(): void
} 
	declare export interface IdleDispatchedHandler {
(e: Windows$Windows$UI.Core.IdleDispatchedHandlerArgs): void
} 
	declare export class IdleDispatchedHandlerArgs mixins undefined.IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
}
	declare export type IAcceleratorKeyEventArgs = {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
} 
	declare export class AcceleratorKeyEventArgs mixins undefined.IAcceleratorKeyEventArgs, undefined.ICoreWindowEventArgs {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export type ICoreDispatcher = {
hasThreadAccess: boolean,
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void,
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction,
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction
} & undefined.ICoreAcceleratorKeys

	declare export interface IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
} 
	declare export class CoreAcceleratorKeys mixins undefined.ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
}
	declare export interface ICoreCursor {
id: number,
type: Windows$Windows$UI.Core.CoreCursorType
} 
	declare export interface ICoreCursorFactory {
createCursor(
type: Windows$Windows$UI.Core.CoreCursorType,
id: number): Windows$Windows$UI.Core.CoreCursor
} 
	declare export interface IInitializeWithCoreWindow {
initialize(window: Windows$Windows$UI.Core.CoreWindow): void
} 
	declare export interface ICoreWindowResizeManager {
notifyLayoutCompleted(): void
} 
	declare export interface ICoreWindowResizeManagerStatics {
getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
} 
	declare export class CoreWindowResizeManager mixins undefined.ICoreWindowResizeManager {
notifyLayoutCompleted(): void;
static getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
}
	declare export interface ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
} 
	declare export class CoreWindowPopupShowingEventArgs mixins undefined.ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
}
	declare export interface ICoreWindowDialog {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
cancelCommandIndex: number,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowDialogFactory {
createWithTitle(title: string): Windows$Windows$UI.Core.CoreWindowDialog
} 
	declare export class CoreWindowDialog mixins undefined.ICoreWindowDialog {
constructor(title: string): this;
constructor(): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
cancelCommandIndex: number;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
	declare export interface ICoreWindowFlyout {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowFlyoutFactory {
create(
position: Windows$Windows$Foundation.Point): Windows$Windows$UI.Core.CoreWindowFlyout,
createWithTitle(
position: Windows$Windows$Foundation.Point,
title: string): Windows$Windows$UI.Core.CoreWindowFlyout
} 
	declare export class CoreWindowFlyout mixins undefined.ICoreWindowFlyout {
constructor(position: Windows$Windows$Foundation.Point): this;
constructor(position: Windows$Windows$Foundation.Point, title: string): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
    }

	declare module 'Management' {
        declare export  class IndexedResourceType {
  constructor(...args: empty): mixed;
static +string: Class<IndexedResourceType__string> & IndexedResourceType__string & 0;// 0
static +path: Class<IndexedResourceType__path> & IndexedResourceType__path & 1;// 1

}

declare class IndexedResourceType__string mixins IndexedResourceType {}
declare class IndexedResourceType__path mixins IndexedResourceType {}

	declare export interface IResourceIndexer {
indexFilePath(
filePath: Windows$Windows$Foundation.Uri): Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceCandidate,
indexFileContentsAsync(
file: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceCandidate>>
} 
	declare export class IndexedResourceCandidate mixins undefined.IIndexedResourceCandidate {
metadata: Windows$Windows$Foundation.Collections.IMapView<string, string>;
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceQualifier>;
type: Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceType;
uri: Windows$Windows$Foundation.Uri;
valueAsString: string;
getQualifierValue(qualifierName: string): string
}
	declare export interface IResourceIndexerFactory {
createResourceIndexer(
projectRoot: Windows$Windows$Foundation.Uri): Windows$Windows$ApplicationModel.Resources.Windows$Management.ResourceIndexer
} 
	declare export class ResourceIndexer mixins undefined.IResourceIndexer {
constructor(projectRoot: Windows$Windows$Foundation.Uri): this;
indexFilePath(
filePath: Windows$Windows$Foundation.Uri): Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceCandidate;
indexFileContentsAsync(
file: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceCandidate>>
}
	declare export interface IIndexedResourceQualifier {
qualifierName: string,
qualifierValue: string
} 
	declare export interface IIndexedResourceCandidate {
metadata: Windows$Windows$Foundation.Collections.IMapView<string, string>,
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceQualifier>,
type: Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceType,
uri: Windows$Windows$Foundation.Uri,
valueAsString: string,
getQualifierValue(qualifierName: string): string
} 
	declare export class IndexedResourceQualifier mixins undefined.IIndexedResourceQualifier {
qualifierName: string;
qualifierValue: string
}
	declare module 'Deployment' {
        declare export  class DeploymentProgressState {
  constructor(...args: empty): mixed;
static +queued: Class<DeploymentProgressState__queued> & DeploymentProgressState__queued & 0;// 0
static +processing: Class<DeploymentProgressState__processing> & DeploymentProgressState__processing & 1;// 1

}

declare class DeploymentProgressState__queued mixins DeploymentProgressState {}
declare class DeploymentProgressState__processing mixins DeploymentProgressState {}

	declare export interface DeploymentProgress {
state: Windows$Windows$Management.Deployment.DeploymentProgressState,
percentage: number
} 
	declare export  class DeploymentOptions {
  constructor(...args: empty): mixed;
static +none: Class<DeploymentOptions__none> & DeploymentOptions__none & 0;// 0
static +forceApplicationShutdown: Class<DeploymentOptions__forceApplicationShutdown> & DeploymentOptions__forceApplicationShutdown & 1;// 1
static +developmentMode: Class<DeploymentOptions__developmentMode> & DeploymentOptions__developmentMode & 2;// 2

}

declare class DeploymentOptions__none mixins DeploymentOptions {}
declare class DeploymentOptions__forceApplicationShutdown mixins DeploymentOptions {}
declare class DeploymentOptions__developmentMode mixins DeploymentOptions {}

	declare export interface IDeploymentResult {
activityId: string,
errorText: string,
extendedErrorCode: number
} 
	declare export class DeploymentResult mixins undefined.IDeploymentResult {
activityId: string;
errorText: string;
extendedErrorCode: number
}
	declare export  class PackageInstallState {
  constructor(...args: empty): mixed;
static +notInstalled: Class<PackageInstallState__notInstalled> & PackageInstallState__notInstalled & 0;// 0
static +staged: Class<PackageInstallState__staged> & PackageInstallState__staged & 1;// 1
static +installed: Class<PackageInstallState__installed> & PackageInstallState__installed & 2;// 2

}

declare class PackageInstallState__notInstalled mixins PackageInstallState {}
declare class PackageInstallState__staged mixins PackageInstallState {}
declare class PackageInstallState__installed mixins PackageInstallState {}

	declare export interface IPackageUserInformation {
installState: Windows$Windows$Management.Deployment.PackageInstallState,
userSecurityId: string
} 
	declare export class PackageUserInformation mixins undefined.IPackageUserInformation {
installState: Windows$Windows$Management.Deployment.PackageInstallState;
userSecurityId: string
}
	declare export  class PackageState {
  constructor(...args: empty): mixed;
static +normal: Class<PackageState__normal> & PackageState__normal & 0;// 0
static +licenseInvalid: Class<PackageState__licenseInvalid> & PackageState__licenseInvalid & 1;// 1
static +modified: Class<PackageState__modified> & PackageState__modified & 2;// 2
static +tampered: Class<PackageState__tampered> & PackageState__tampered & 3;// 3

}

declare class PackageState__normal mixins PackageState {}
declare class PackageState__licenseInvalid mixins PackageState {}
declare class PackageState__modified mixins PackageState {}
declare class PackageState__tampered mixins PackageState {}

	declare export interface IPackageManager {
addPackageAsync(
packageUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
deploymentOptions: Windows$Windows$Management.Deployment.DeploymentOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>,
updatePackageAsync(
packageUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
deploymentOptions: Windows$Windows$Management.Deployment.DeploymentOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>,
removePackageAsync(
packageFullName: string): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>,
stagePackageAsync(
packageUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>,
registerPackageAsync(
manifestUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
deploymentOptions: Windows$Windows$Management.Deployment.DeploymentOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>,
findPackages(
): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>,
findPackagesForUser(
userSecurityId: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>,
findPackages(
packageName: string,
packagePublisher: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>,
findPackagesForUser(
userSecurityId: string,
packageName: string,
packagePublisher: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>,
findUsers(
packageFullName: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Management.Deployment.PackageUserInformation>,
setPackageState(
packageFullName: string,
packageState: Windows$Windows$Management.Deployment.PackageState): void,
findPackage(packageFullName: string): Windows$Windows$ApplicationModel.Package,
cleanupPackageForUserAsync(
packageName: string,
userSecurityId: string): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>,
findPackages(
packageFamilyName: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>,
findPackagesForUser(
userSecurityId: string,
packageFamilyName: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>,
findPackageForUser(
userSecurityId: string,
packageFullName: string): Windows$Windows$ApplicationModel.Package
} 
	declare export class PackageManager mixins undefined.IPackageManager {
addPackageAsync(
packageUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
deploymentOptions: Windows$Windows$Management.Deployment.DeploymentOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>;
updatePackageAsync(
packageUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
deploymentOptions: Windows$Windows$Management.Deployment.DeploymentOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>;
removePackageAsync(
packageFullName: string): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>;
stagePackageAsync(
packageUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>;
registerPackageAsync(
manifestUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
deploymentOptions: Windows$Windows$Management.Deployment.DeploymentOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>;
findPackages(
): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>;
findPackagesForUser(
userSecurityId: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>;
findPackages(
packageName: string,
packagePublisher: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>;
findPackagesForUser(
userSecurityId: string,
packageName: string,
packagePublisher: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>;
findUsers(
packageFullName: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Management.Deployment.PackageUserInformation>;
setPackageState(
packageFullName: string,
packageState: Windows$Windows$Management.Deployment.PackageState): void;
findPackage(packageFullName: string): Windows$Windows$ApplicationModel.Package;
cleanupPackageForUserAsync(
packageName: string,
userSecurityId: string): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>;
findPackages(
packageFamilyName: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>;
findPackagesForUser(
userSecurityId: string,
packageFamilyName: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>;
findPackageForUser(
userSecurityId: string,
packageFullName: string): Windows$Windows$ApplicationModel.Package
}
    }

	declare module 'Core' {
        declare export class CoreApplication  {
static mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>;
static id: string;
static properties: Windows$Windows$Foundation.Collections.IPropertySet;
static incrementApplicationUseCount(): void;
static decrementApplicationUseCount(): void;
static createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static exit(): void;
static onexiting: any;
static onsuspending: any;
static onresuming: any;
static getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void;
static runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
}
	declare export class CoreApplicationView mixins undefined.ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow;
isHosted: boolean;
isMain: boolean;
onactivated: any
}
	declare export interface IFrameworkView {
initialize(
applicationView: Windows$Windows$ApplicationModel.Core.CoreApplicationView): void,
setWindow(window: Windows$Windows$UI.Core.CoreWindow): void,
load(entryPoint: string): void,
run(): void,
uninitialize(): void
} 
	declare export interface IFrameworkViewSource {
createView(): Windows$Windows$ApplicationModel.Core.IFrameworkView
} 
	declare export interface ICoreApplication {
id: string,
properties: Windows$Windows$Foundation.Collections.IPropertySet,
onsuspending: any,
onresuming: any,
getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView,
run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void,
runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
} 
	declare export interface ICoreApplicationUseCount {
incrementApplicationUseCount(): void,
decrementApplicationUseCount(): void
} 
	declare export interface ICoreApplicationExit {
exit(): void,
onexiting: any
} 
	declare export interface ICoreImmersiveApplication {
mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView,
views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>,
createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView
} 
	declare export interface ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow,
isHosted: boolean,
isMain: boolean,
onactivated: any
} 
	declare export interface IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext,
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap,
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void,
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void
} 
	declare export class ResourceMap mixins undefined.IResourceMap, undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
uri: Windows$Windows$Foundation.Uri;
size: number;
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.NamedResource;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>
}
	declare export class ResourceContext mixins undefined.IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>;
reset(): void;
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void;
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void;
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
static createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
}
	declare export interface IResourceManagerStatics {
current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager,
isResourceReference(resourceReference: string): boolean
} 
	declare export class ResourceManager mixins undefined.IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
static current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager;
static isResourceReference(resourceReference: string): boolean
}
	declare export interface IResourceQualifier {
isDefault: boolean,
isMatch: boolean,
qualifierName: string,
qualifierValue: string,
score: number
} 
	declare export class ResourceQualifier mixins undefined.IResourceQualifier {
isDefault: boolean;
isMatch: boolean;
qualifierName: string;
qualifierValue: string;
score: number
}
	declare export interface IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>,
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>,
reset(): void,
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void,
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void,
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceContextStatics {
createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceCandidate {
isDefault: boolean,
isMatch: boolean,
isMatchAsDefault: boolean,
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>,
valueAsString: string,
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
getQualifierValue(qualifierName: string): string
} 
	declare export class ResourceCandidate mixins undefined.IResourceCandidate {
isDefault: boolean;
isMatch: boolean;
isMatchAsDefault: boolean;
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
valueAsString: string;
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
getQualifierValue(qualifierName: string): string
}
	declare export interface INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
uri: Windows$Windows$Foundation.Uri,
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
} 
	declare export class NamedResource mixins undefined.INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
uri: Windows$Windows$Foundation.Uri;
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
}
	declare export type IResourceMap = {
uri: Windows$Windows$Foundation.Uri,
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap
} & undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource> & undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>

	declare export class ResourceMapIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>[],
returnValue: number
}
}
	declare export class ResourceMapMapView mixins undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
size: number;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>>
}
	declare export class ResourceMapMapViewIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>[],
returnValue: number
}
}
	declare export class ResourceQualifierObservableMap mixins undefined.IObservableMap<string, string>, undefined.IMap<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
onmapchanged: any;
lookup(key: string): string;
hasKey(key: string): boolean;
getView(): Windows$Windows$Foundation.Collections.IMapView<string, string>;
insert(key: string, value: string): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierMapView mixins undefined.IMapView<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
lookup(key: string): string;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, string>,
second: Windows$Windows$Foundation.Collections.IMapView<string, string>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceCandidateVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceContextLanguagesVectorView mixins undefined.IVectorView<string>, undefined.IIterable<string> {
size: number;
getAt(index: number): string;
indexOf(value: string): {
index: number,
returnValue: boolean
};
getMany(startIndex: number): {
items: string[],
returnValue: number
};
first(): Windows$Windows$Foundation.Collections.IIterator<string>;
toString(): string;
toLocaleString(): string;
concat(...items: string[][]): string[];
join(seperator: string): string;
pop(): string;
push(...items: string[]): void;
reverse(): string[];
shift(): string;
slice(start: number): string[];
slice(start: number, end: number): string[];
sort(): string[];
sort(compareFn: (a: string, b: string) => number): string[];
splice(start: number): string[];
splice(start: number, deleteCount: number, ...items: string[]): string[];
unshift(...items: string[]): number;
lastIndexOf(searchElement: string): number;
lastIndexOf(searchElement: string, fromIndex: number): number;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
forEach(callbackfn: (value: string, index: number, array: string[]) => void): void;
forEach(
callbackfn: (value: string, index: number, array: string[]) => void,
thisArg: any): void;
map(callbackfn: (value: string, index: number, array: string[]) => any): any[];
map(
callbackfn: (value: string, index: number, array: string[]) => any,
thisArg: any): any[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean): string[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): string[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
length: number
}
	declare export interface IApplicationDataManagerStatics {
createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
} 
	declare export interface IApplicationDataManager {} 
	declare export class ApplicationDataManager mixins undefined.IApplicationDataManager {
static createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
}
	declare export  class CryptographicPrivateKeyBlobType {
  constructor(...args: empty): mixed;
static +pkcs8RawPrivateKeyInfo: Class<CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo> & CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo & 0;// 0
static +pkcs1RsaPrivateKey: Class<CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey> & CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey & 1;// 1
static +bCryptPrivateKey: Class<CryptographicPrivateKeyBlobType__bCryptPrivateKey> & CryptographicPrivateKeyBlobType__bCryptPrivateKey & 2;// 2
static +capi1PrivateKey: Class<CryptographicPrivateKeyBlobType__capi1PrivateKey> & CryptographicPrivateKeyBlobType__capi1PrivateKey & 3;// 3

}

declare class CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__bCryptPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__capi1PrivateKey mixins CryptographicPrivateKeyBlobType {}

	declare export  class CryptographicPublicKeyBlobType {
  constructor(...args: empty): mixed;
static +x509SubjectPublicKeyInfo: Class<CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo> & CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo & 0;// 0
static +pkcs1RsaPublicKey: Class<CryptographicPublicKeyBlobType__pkcs1RsaPublicKey> & CryptographicPublicKeyBlobType__pkcs1RsaPublicKey & 1;// 1
static +bCryptPublicKey: Class<CryptographicPublicKeyBlobType__bCryptPublicKey> & CryptographicPublicKeyBlobType__bCryptPublicKey & 2;// 2
static +capi1PublicKey: Class<CryptographicPublicKeyBlobType__capi1PublicKey> & CryptographicPublicKeyBlobType__capi1PublicKey & 3;// 3

}

declare class CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__pkcs1RsaPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__bCryptPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__capi1PublicKey mixins CryptographicPublicKeyBlobType {}

	declare export interface IKeyDerivationParameters {
iterationCount: number,
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export interface IKeyDerivationParametersStatics {
buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
} 
	declare export class KeyDerivationParameters mixins undefined.IKeyDerivationParameters {
iterationCount: number;
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer;
static buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
}
	declare export interface ICryptographicKey {
keySize: number,
export(): Windows$Windows$Storage.Streams.IBuffer,
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicKey mixins undefined.ICryptographicKey {
keySize: number;
export(): Windows$Windows$Storage.Streams.IBuffer;
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void,
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicHash mixins undefined.IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void;
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProvider {
algorithmName: string,
hashLength: number,
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash
} 
	declare export interface IMacAlgorithmProvider {
algorithmName: string,
macLength: number,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IKeyDerivationAlgorithmProvider {
algorithmName: string,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface ISymmetricKeyAlgorithmProvider {
algorithmName: string,
blockLength: number,
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IAsymmetricKeyAlgorithmProvider {
algorithmName: string,
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
encryptedData: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class EncryptedAndAuthenticatedData mixins undefined.IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer;
encryptedData: Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface ICryptographicEngineStatics {
encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData,
decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean,
deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicEngine  {
static encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData;
static decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean;
static deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
} 
	declare export class HashAlgorithmProvider mixins undefined.IHashAlgorithmProvider {
algorithmName: string;
hashLength: number;
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
}
	declare export interface IMacAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
} 
	declare export class MacAlgorithmProvider mixins undefined.IMacAlgorithmProvider {
algorithmName: string;
macLength: number;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
}
	declare export interface IKeyDerivationAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
} 
	declare export class KeyDerivationAlgorithmProvider mixins undefined.IKeyDerivationAlgorithmProvider {
algorithmName: string;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
}
	declare export interface ISymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
} 
	declare export class SymmetricKeyAlgorithmProvider mixins undefined.ISymmetricKeyAlgorithmProvider {
algorithmName: string;
blockLength: number;
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
}
	declare export interface IAsymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
} 
	declare export class AsymmetricKeyAlgorithmProvider mixins undefined.IAsymmetricKeyAlgorithmProvider {
algorithmName: string;
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
}
	declare export interface IHashAlgorithmNamesStatics {
md5: string,
sha1: string,
sha256: string,
sha384: string,
sha512: string
} 
	declare export class HashAlgorithmNames  {
static md5: string;
static sha1: string;
static sha256: string;
static sha384: string;
static sha512: string
}
	declare export interface IMacAlgorithmNamesStatics {
aesCmac: string,
hmacMd5: string,
hmacSha1: string,
hmacSha256: string,
hmacSha384: string,
hmacSha512: string
} 
	declare export class MacAlgorithmNames  {
static aesCmac: string;
static hmacMd5: string;
static hmacSha1: string;
static hmacSha256: string;
static hmacSha384: string;
static hmacSha512: string
}
	declare export interface ISymmetricAlgorithmNamesStatics {
aesCbc: string,
aesCbcPkcs7: string,
aesCcm: string,
aesEcb: string,
aesEcbPkcs7: string,
aesGcm: string,
desCbc: string,
desCbcPkcs7: string,
desEcb: string,
desEcbPkcs7: string,
rc2Cbc: string,
rc2CbcPkcs7: string,
rc2Ecb: string,
rc2EcbPkcs7: string,
rc4: string,
tripleDesCbc: string,
tripleDesCbcPkcs7: string,
tripleDesEcb: string,
tripleDesEcbPkcs7: string
} 
	declare export class SymmetricAlgorithmNames  {
static aesCbc: string;
static aesCbcPkcs7: string;
static aesCcm: string;
static aesEcb: string;
static aesEcbPkcs7: string;
static aesGcm: string;
static desCbc: string;
static desCbcPkcs7: string;
static desEcb: string;
static desEcbPkcs7: string;
static rc2Cbc: string;
static rc2CbcPkcs7: string;
static rc2Ecb: string;
static rc2EcbPkcs7: string;
static rc4: string;
static tripleDesCbc: string;
static tripleDesCbcPkcs7: string;
static tripleDesEcb: string;
static tripleDesEcbPkcs7: string
}
	declare export interface IAsymmetricAlgorithmNamesStatics {
dsaSha1: string,
dsaSha256: string,
ecdsaP256Sha256: string,
ecdsaP384Sha384: string,
ecdsaP521Sha512: string,
rsaOaepSha1: string,
rsaOaepSha256: string,
rsaOaepSha384: string,
rsaOaepSha512: string,
rsaPkcs1: string,
rsaSignPkcs1Sha1: string,
rsaSignPkcs1Sha256: string,
rsaSignPkcs1Sha384: string,
rsaSignPkcs1Sha512: string,
rsaSignPssSha1: string,
rsaSignPssSha256: string,
rsaSignPssSha384: string,
rsaSignPssSha512: string
} 
	declare export class AsymmetricAlgorithmNames  {
static dsaSha1: string;
static dsaSha256: string;
static ecdsaP256Sha256: string;
static ecdsaP384Sha384: string;
static ecdsaP521Sha512: string;
static rsaOaepSha1: string;
static rsaOaepSha256: string;
static rsaOaepSha384: string;
static rsaOaepSha512: string;
static rsaPkcs1: string;
static rsaSignPkcs1Sha1: string;
static rsaSignPkcs1Sha256: string;
static rsaSignPkcs1Sha384: string;
static rsaSignPkcs1Sha512: string;
static rsaSignPssSha1: string;
static rsaSignPssSha256: string;
static rsaSignPssSha384: string;
static rsaSignPssSha512: string
}
	declare export interface IKeyDerivationAlgorithmNamesStatics {
pbkdf2Md5: string,
pbkdf2Sha1: string,
pbkdf2Sha256: string,
pbkdf2Sha384: string,
pbkdf2Sha512: string,
sp800108CtrHmacMd5: string,
sp800108CtrHmacSha1: string,
sp800108CtrHmacSha256: string,
sp800108CtrHmacSha384: string,
sp800108CtrHmacSha512: string,
sp80056aConcatMd5: string,
sp80056aConcatSha1: string,
sp80056aConcatSha256: string,
sp80056aConcatSha384: string,
sp80056aConcatSha512: string
} 
	declare export class KeyDerivationAlgorithmNames  {
static pbkdf2Md5: string;
static pbkdf2Sha1: string;
static pbkdf2Sha256: string;
static pbkdf2Sha384: string;
static pbkdf2Sha512: string;
static sp800108CtrHmacMd5: string;
static sp800108CtrHmacSha1: string;
static sp800108CtrHmacSha256: string;
static sp800108CtrHmacSha384: string;
static sp800108CtrHmacSha512: string;
static sp80056aConcatMd5: string;
static sp80056aConcatSha1: string;
static sp80056aConcatSha256: string;
static sp80056aConcatSha384: string;
static sp80056aConcatSha512: string
}
	declare export interface SignalHandler {
(signalNotifier: Windows$Windows$System.Threading.Core.SignalNotifier, timedOut: boolean): void
} 
	declare export class SignalNotifier mixins undefined.ISignalNotifier {
enable(): void;
terminate(): void;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
}
	declare export interface ISignalNotifierStatics {
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
} 
	declare export interface IPreallocatedWorkItemFactory {
createWorkItem(
handler: Windows$Windows$System.Threading.WorkItemHandler): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriority(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriorityAndOptions(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority,
options: Windows$Windows$System.Threading.WorkItemOptions): Windows$Windows$System.Threading.Core.PreallocatedWorkItem
} 
	declare export class PreallocatedWorkItem mixins undefined.IPreallocatedWorkItem {
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority, options: Windows$Windows$System.Threading.WorkItemOptions): this;
runAsync(): Windows$Windows$Foundation.IAsyncAction
}
	declare export interface IPreallocatedWorkItem {
runAsync(): Windows$Windows$Foundation.IAsyncAction
} 
	declare export interface ISignalNotifier {
enable(): void,
terminate(): void
} 
	declare module 'AnimationMetrics' {
        declare export  class PropertyAnimationType {
  constructor(...args: empty): mixed;
static +scale: Class<PropertyAnimationType__scale> & PropertyAnimationType__scale & 0;// 0
static +translation: Class<PropertyAnimationType__translation> & PropertyAnimationType__translation & 1;// 1
static +opacity: Class<PropertyAnimationType__opacity> & PropertyAnimationType__opacity & 2;// 2

}

declare class PropertyAnimationType__scale mixins PropertyAnimationType {}
declare class PropertyAnimationType__translation mixins PropertyAnimationType {}
declare class PropertyAnimationType__opacity mixins PropertyAnimationType {}

	declare export interface IPropertyAnimation {
control1: Windows$Windows$Foundation.Point,
control2: Windows$Windows$Foundation.Point,
delay: number,
duration: number,
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
} 
	declare export type IScaleAnimation = {
finalScaleX: number,
finalScaleY: number,
initialScaleX: number,
initialScaleY: number,
normalizedOrigin: Windows$Windows$Foundation.Point
} & undefined.IPropertyAnimation

	declare export type IOpacityAnimation = {
finalOpacity: number,
initialOpacity: number
} & undefined.IPropertyAnimation

	declare export  class AnimationEffect {
  constructor(...args: empty): mixed;
static +expand: Class<AnimationEffect__expand> & AnimationEffect__expand & 0;// 0
static +collapse: Class<AnimationEffect__collapse> & AnimationEffect__collapse & 1;// 1
static +reposition: Class<AnimationEffect__reposition> & AnimationEffect__reposition & 2;// 2
static +fadeIn: Class<AnimationEffect__fadeIn> & AnimationEffect__fadeIn & 3;// 3
static +fadeOut: Class<AnimationEffect__fadeOut> & AnimationEffect__fadeOut & 4;// 4
static +addToList: Class<AnimationEffect__addToList> & AnimationEffect__addToList & 5;// 5
static +deleteFromList: Class<AnimationEffect__deleteFromList> & AnimationEffect__deleteFromList & 6;// 6
static +addToGrid: Class<AnimationEffect__addToGrid> & AnimationEffect__addToGrid & 7;// 7
static +deleteFromGrid: Class<AnimationEffect__deleteFromGrid> & AnimationEffect__deleteFromGrid & 8;// 8
static +addToSearchGrid: Class<AnimationEffect__addToSearchGrid> & AnimationEffect__addToSearchGrid & 9;// 9
static +deleteFromSearchGrid: Class<AnimationEffect__deleteFromSearchGrid> & AnimationEffect__deleteFromSearchGrid & 10;// 10
static +addToSearchList: Class<AnimationEffect__addToSearchList> & AnimationEffect__addToSearchList & 11;// 11
static +deleteFromSearchList: Class<AnimationEffect__deleteFromSearchList> & AnimationEffect__deleteFromSearchList & 12;// 12
static +showEdgeUI: Class<AnimationEffect__showEdgeUI> & AnimationEffect__showEdgeUI & 13;// 13
static +showPanel: Class<AnimationEffect__showPanel> & AnimationEffect__showPanel & 14;// 14
static +hideEdgeUI: Class<AnimationEffect__hideEdgeUI> & AnimationEffect__hideEdgeUI & 15;// 15
static +hidePanel: Class<AnimationEffect__hidePanel> & AnimationEffect__hidePanel & 16;// 16
static +showPopup: Class<AnimationEffect__showPopup> & AnimationEffect__showPopup & 17;// 17
static +hidePopup: Class<AnimationEffect__hidePopup> & AnimationEffect__hidePopup & 18;// 18
static +pointerDown: Class<AnimationEffect__pointerDown> & AnimationEffect__pointerDown & 19;// 19
static +pointerUp: Class<AnimationEffect__pointerUp> & AnimationEffect__pointerUp & 20;// 20
static +dragSourceStart: Class<AnimationEffect__dragSourceStart> & AnimationEffect__dragSourceStart & 21;// 21
static +dragSourceEnd: Class<AnimationEffect__dragSourceEnd> & AnimationEffect__dragSourceEnd & 22;// 22
static +transitionContent: Class<AnimationEffect__transitionContent> & AnimationEffect__transitionContent & 23;// 23
static +reveal: Class<AnimationEffect__reveal> & AnimationEffect__reveal & 24;// 24
static +hide: Class<AnimationEffect__hide> & AnimationEffect__hide & 25;// 25
static +dragBetweenEnter: Class<AnimationEffect__dragBetweenEnter> & AnimationEffect__dragBetweenEnter & 26;// 26
static +dragBetweenLeave: Class<AnimationEffect__dragBetweenLeave> & AnimationEffect__dragBetweenLeave & 27;// 27
static +swipeSelect: Class<AnimationEffect__swipeSelect> & AnimationEffect__swipeSelect & 28;// 28
static +swipeDeselect: Class<AnimationEffect__swipeDeselect> & AnimationEffect__swipeDeselect & 29;// 29
static +swipeReveal: Class<AnimationEffect__swipeReveal> & AnimationEffect__swipeReveal & 30;// 30
static +enterPage: Class<AnimationEffect__enterPage> & AnimationEffect__enterPage & 31;// 31
static +transitionPage: Class<AnimationEffect__transitionPage> & AnimationEffect__transitionPage & 32;// 32
static +crossFade: Class<AnimationEffect__crossFade> & AnimationEffect__crossFade & 33;// 33
static +peek: Class<AnimationEffect__peek> & AnimationEffect__peek & 34;// 34
static +updateBadge: Class<AnimationEffect__updateBadge> & AnimationEffect__updateBadge & 35;// 35

}

declare class AnimationEffect__expand mixins AnimationEffect {}
declare class AnimationEffect__collapse mixins AnimationEffect {}
declare class AnimationEffect__reposition mixins AnimationEffect {}
declare class AnimationEffect__fadeIn mixins AnimationEffect {}
declare class AnimationEffect__fadeOut mixins AnimationEffect {}
declare class AnimationEffect__addToList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromList mixins AnimationEffect {}
declare class AnimationEffect__addToGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchList mixins AnimationEffect {}
declare class AnimationEffect__showEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__showPanel mixins AnimationEffect {}
declare class AnimationEffect__hideEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__hidePanel mixins AnimationEffect {}
declare class AnimationEffect__showPopup mixins AnimationEffect {}
declare class AnimationEffect__hidePopup mixins AnimationEffect {}
declare class AnimationEffect__pointerDown mixins AnimationEffect {}
declare class AnimationEffect__pointerUp mixins AnimationEffect {}
declare class AnimationEffect__dragSourceStart mixins AnimationEffect {}
declare class AnimationEffect__dragSourceEnd mixins AnimationEffect {}
declare class AnimationEffect__transitionContent mixins AnimationEffect {}
declare class AnimationEffect__reveal mixins AnimationEffect {}
declare class AnimationEffect__hide mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenEnter mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenLeave mixins AnimationEffect {}
declare class AnimationEffect__swipeSelect mixins AnimationEffect {}
declare class AnimationEffect__swipeDeselect mixins AnimationEffect {}
declare class AnimationEffect__swipeReveal mixins AnimationEffect {}
declare class AnimationEffect__enterPage mixins AnimationEffect {}
declare class AnimationEffect__transitionPage mixins AnimationEffect {}
declare class AnimationEffect__crossFade mixins AnimationEffect {}
declare class AnimationEffect__peek mixins AnimationEffect {}
declare class AnimationEffect__updateBadge mixins AnimationEffect {}

	declare export  class AnimationEffectTarget {
  constructor(...args: empty): mixed;
static +primary: Class<AnimationEffectTarget__primary> & AnimationEffectTarget__primary & 0;// 0
static +added: Class<AnimationEffectTarget__added> & AnimationEffectTarget__added & 1;// 1
static +affected: Class<AnimationEffectTarget__affected> & AnimationEffectTarget__affected & 2;// 2
static +background: Class<AnimationEffectTarget__background> & AnimationEffectTarget__background & 3;// 3
static +content: Class<AnimationEffectTarget__content> & AnimationEffectTarget__content & 4;// 4
static +deleted: Class<AnimationEffectTarget__deleted> & AnimationEffectTarget__deleted & 5;// 5
static +deselected: Class<AnimationEffectTarget__deselected> & AnimationEffectTarget__deselected & 6;// 6
static +dragSource: Class<AnimationEffectTarget__dragSource> & AnimationEffectTarget__dragSource & 7;// 7
static +hidden: Class<AnimationEffectTarget__hidden> & AnimationEffectTarget__hidden & 8;// 8
static +incoming: Class<AnimationEffectTarget__incoming> & AnimationEffectTarget__incoming & 9;// 9
static +outgoing: Class<AnimationEffectTarget__outgoing> & AnimationEffectTarget__outgoing & 10;// 10
static +outline: Class<AnimationEffectTarget__outline> & AnimationEffectTarget__outline & 11;// 11
static +remaining: Class<AnimationEffectTarget__remaining> & AnimationEffectTarget__remaining & 12;// 12
static +revealed: Class<AnimationEffectTarget__revealed> & AnimationEffectTarget__revealed & 13;// 13
static +rowIn: Class<AnimationEffectTarget__rowIn> & AnimationEffectTarget__rowIn & 14;// 14
static +rowOut: Class<AnimationEffectTarget__rowOut> & AnimationEffectTarget__rowOut & 15;// 15
static +selected: Class<AnimationEffectTarget__selected> & AnimationEffectTarget__selected & 16;// 16
static +selection: Class<AnimationEffectTarget__selection> & AnimationEffectTarget__selection & 17;// 17
static +shown: Class<AnimationEffectTarget__shown> & AnimationEffectTarget__shown & 18;// 18
static +tapped: Class<AnimationEffectTarget__tapped> & AnimationEffectTarget__tapped & 19;// 19

}

declare class AnimationEffectTarget__primary mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__added mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__affected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__background mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__content mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deleted mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deselected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__dragSource mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__hidden mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__incoming mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outgoing mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outline mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__remaining mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__revealed mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowIn mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowOut mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selection mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__shown mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__tapped mixins AnimationEffectTarget {}

	declare export interface IAnimationDescription {
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>,
delayLimit: number,
staggerDelay: number,
staggerDelayFactor: number,
zOrder: number
} 
	declare export interface IAnimationDescriptionFactory {
createInstance(
effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect,
target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): Windows$Windows$UI.Core.AnimationMetrics.AnimationDescription
} 
	declare export class AnimationDescription mixins undefined.IAnimationDescription {
constructor(effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect, target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): this;
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>;
delayLimit: number;
staggerDelay: number;
staggerDelayFactor: number;
zOrder: number
}
	declare export class PropertyAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class ScaleAnimation mixins undefined.IScaleAnimation, undefined.IPropertyAnimation {
finalScaleX: number;
finalScaleY: number;
initialScaleX: number;
initialScaleY: number;
normalizedOrigin: Windows$Windows$Foundation.Point;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class TranslationAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class OpacityAnimation mixins undefined.IOpacityAnimation, undefined.IPropertyAnimation {
finalOpacity: number;
initialOpacity: number;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
    }

	declare export  class CoreWindowActivationState {
  constructor(...args: empty): mixed;
static +codeActivated: Class<CoreWindowActivationState__codeActivated> & CoreWindowActivationState__codeActivated & 0;// 0
static +deactivated: Class<CoreWindowActivationState__deactivated> & CoreWindowActivationState__deactivated & 1;// 1
static +pointerActivated: Class<CoreWindowActivationState__pointerActivated> & CoreWindowActivationState__pointerActivated & 2;// 2

}

declare class CoreWindowActivationState__codeActivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__deactivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__pointerActivated mixins CoreWindowActivationState {}

	declare export  class CoreCursorType {
  constructor(...args: empty): mixed;
static +arrow: Class<CoreCursorType__arrow> & CoreCursorType__arrow & 0;// 0
static +cross: Class<CoreCursorType__cross> & CoreCursorType__cross & 1;// 1
static +custom: Class<CoreCursorType__custom> & CoreCursorType__custom & 2;// 2
static +hand: Class<CoreCursorType__hand> & CoreCursorType__hand & 3;// 3
static +help: Class<CoreCursorType__help> & CoreCursorType__help & 4;// 4
static +iBeam: Class<CoreCursorType__iBeam> & CoreCursorType__iBeam & 5;// 5
static +sizeAll: Class<CoreCursorType__sizeAll> & CoreCursorType__sizeAll & 6;// 6
static +sizeNortheastSouthwest: Class<CoreCursorType__sizeNortheastSouthwest> & CoreCursorType__sizeNortheastSouthwest & 7;// 7
static +sizeNorthSouth: Class<CoreCursorType__sizeNorthSouth> & CoreCursorType__sizeNorthSouth & 8;// 8
static +sizeNorthwestSoutheast: Class<CoreCursorType__sizeNorthwestSoutheast> & CoreCursorType__sizeNorthwestSoutheast & 9;// 9
static +sizeWestEast: Class<CoreCursorType__sizeWestEast> & CoreCursorType__sizeWestEast & 10;// 10
static +universalNo: Class<CoreCursorType__universalNo> & CoreCursorType__universalNo & 11;// 11
static +upArrow: Class<CoreCursorType__upArrow> & CoreCursorType__upArrow & 12;// 12
static +wait: Class<CoreCursorType__wait> & CoreCursorType__wait & 13;// 13

}

declare class CoreCursorType__arrow mixins CoreCursorType {}
declare class CoreCursorType__cross mixins CoreCursorType {}
declare class CoreCursorType__custom mixins CoreCursorType {}
declare class CoreCursorType__hand mixins CoreCursorType {}
declare class CoreCursorType__help mixins CoreCursorType {}
declare class CoreCursorType__iBeam mixins CoreCursorType {}
declare class CoreCursorType__sizeAll mixins CoreCursorType {}
declare class CoreCursorType__sizeNortheastSouthwest mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthSouth mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthwestSoutheast mixins CoreCursorType {}
declare class CoreCursorType__sizeWestEast mixins CoreCursorType {}
declare class CoreCursorType__universalNo mixins CoreCursorType {}
declare class CoreCursorType__upArrow mixins CoreCursorType {}
declare class CoreCursorType__wait mixins CoreCursorType {}

	declare export  class CoreDispatcherPriority {
  constructor(...args: empty): mixed;
static +low: Class<CoreDispatcherPriority__low> & CoreDispatcherPriority__low & 0;// 0
static +normal: Class<CoreDispatcherPriority__normal> & CoreDispatcherPriority__normal & 1;// 1
static +high: Class<CoreDispatcherPriority__high> & CoreDispatcherPriority__high & 2;// 2

}

declare class CoreDispatcherPriority__low mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__normal mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__high mixins CoreDispatcherPriority {}

	declare export  class CoreProcessEventsOption {
  constructor(...args: empty): mixed;
static +processOneAndAllPending: Class<CoreProcessEventsOption__processOneAndAllPending> & CoreProcessEventsOption__processOneAndAllPending & 0;// 0
static +processOneIfPresent: Class<CoreProcessEventsOption__processOneIfPresent> & CoreProcessEventsOption__processOneIfPresent & 1;// 1
static +processUntilQuit: Class<CoreProcessEventsOption__processUntilQuit> & CoreProcessEventsOption__processUntilQuit & 2;// 2
static +processAllIfPresent: Class<CoreProcessEventsOption__processAllIfPresent> & CoreProcessEventsOption__processAllIfPresent & 3;// 3

}

declare class CoreProcessEventsOption__processOneAndAllPending mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processOneIfPresent mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processUntilQuit mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processAllIfPresent mixins CoreProcessEventsOption {}

	declare export  class CoreWindowFlowDirection {
  constructor(...args: empty): mixed;
static +leftToRight: Class<CoreWindowFlowDirection__leftToRight> & CoreWindowFlowDirection__leftToRight & 0;// 0
static +rightToLeft: Class<CoreWindowFlowDirection__rightToLeft> & CoreWindowFlowDirection__rightToLeft & 1;// 1

}

declare class CoreWindowFlowDirection__leftToRight mixins CoreWindowFlowDirection {}
declare class CoreWindowFlowDirection__rightToLeft mixins CoreWindowFlowDirection {}

	declare export  class CoreVirtualKeyStates {
  constructor(...args: empty): mixed;
static +none: Class<CoreVirtualKeyStates__none> & CoreVirtualKeyStates__none & 0;// 0
static +down: Class<CoreVirtualKeyStates__down> & CoreVirtualKeyStates__down & 1;// 1
static +locked: Class<CoreVirtualKeyStates__locked> & CoreVirtualKeyStates__locked & 2;// 2

}

declare class CoreVirtualKeyStates__none mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__down mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__locked mixins CoreVirtualKeyStates {}

	declare export  class CoreAcceleratorKeyEventType {
  constructor(...args: empty): mixed;
static +character: Class<CoreAcceleratorKeyEventType__character> & CoreAcceleratorKeyEventType__character & 0;// 0
static +deadCharacter: Class<CoreAcceleratorKeyEventType__deadCharacter> & CoreAcceleratorKeyEventType__deadCharacter & 1;// 1
static +keyDown: Class<CoreAcceleratorKeyEventType__keyDown> & CoreAcceleratorKeyEventType__keyDown & 2;// 2
static +keyUp: Class<CoreAcceleratorKeyEventType__keyUp> & CoreAcceleratorKeyEventType__keyUp & 3;// 3
static +systemCharacter: Class<CoreAcceleratorKeyEventType__systemCharacter> & CoreAcceleratorKeyEventType__systemCharacter & 4;// 4
static +systemDeadCharacter: Class<CoreAcceleratorKeyEventType__systemDeadCharacter> & CoreAcceleratorKeyEventType__systemDeadCharacter & 5;// 5
static +systemKeyDown: Class<CoreAcceleratorKeyEventType__systemKeyDown> & CoreAcceleratorKeyEventType__systemKeyDown & 6;// 6
static +systemKeyUp: Class<CoreAcceleratorKeyEventType__systemKeyUp> & CoreAcceleratorKeyEventType__systemKeyUp & 7;// 7
static +unicodeCharacter: Class<CoreAcceleratorKeyEventType__unicodeCharacter> & CoreAcceleratorKeyEventType__unicodeCharacter & 8;// 8

}

declare class CoreAcceleratorKeyEventType__character mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__deadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemDeadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__unicodeCharacter mixins CoreAcceleratorKeyEventType {}

	declare export  class CoreProximityEvaluationScore {
  constructor(...args: empty): mixed;
static +closest: Class<CoreProximityEvaluationScore__closest> & CoreProximityEvaluationScore__closest & 0;// 0
static +farthest: Class<CoreProximityEvaluationScore__farthest> & CoreProximityEvaluationScore__farthest & 1;// 1

}

declare class CoreProximityEvaluationScore__closest mixins CoreProximityEvaluationScore {}
declare class CoreProximityEvaluationScore__farthest mixins CoreProximityEvaluationScore {}

	declare export interface CorePhysicalKeyStatus {
repeatCount: number,
scanCode: number,
isExtendedKey: boolean,
isMenuKeyDown: boolean,
wasKeyDown: boolean,
isKeyReleased: boolean
} 
	declare export interface CoreProximityEvaluation {
score: number,
adjustedPoint: Windows$Windows$Foundation.Point
} 
	declare export interface ICoreWindowEventArgs {
handled: boolean
} 
	declare export type IAutomationProviderRequestedEventArgs = {
automationProvider: any
} & undefined.ICoreWindowEventArgs

	declare export type ICharacterReceivedEventArgs = {
keyCode: number,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus
} & undefined.ICoreWindowEventArgs

	declare export type IInputEnabledEventArgs = {
inputEnabled: boolean
} & undefined.ICoreWindowEventArgs

	declare export type IKeyEventArgs = {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export type IPointerEventArgs = {
currentPoint: Windows$Windows$UI.Input.PointerPoint,
keyModifiers: Windows$Windows$System.VirtualKeyModifiers,
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
} & undefined.ICoreWindowEventArgs

	declare export type ITouchHitTestingEventArgs = {
boundingBox: Windows$Windows$Foundation.Rect,
point: Windows$Windows$Foundation.Point,
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
} & undefined.ICoreWindowEventArgs

	declare export type IWindowActivatedEventArgs = {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState
} & undefined.ICoreWindowEventArgs

	declare export type IWindowSizeChangedEventArgs = {
size: Windows$Windows$Foundation.Size
} & undefined.ICoreWindowEventArgs

	declare export type IVisibilityChangedEventArgs = {
visible: boolean
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreWindow {
automationHostProvider: any,
bounds: Windows$Windows$Foundation.Rect,
customProperties: Windows$Windows$Foundation.Collections.IPropertySet,
dispatcher: Windows$Windows$UI.Core.CoreDispatcher,
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection,
isInputEnabled: boolean,
pointerCursor: Windows$Windows$UI.Core.CoreCursor,
pointerPosition: Windows$Windows$Foundation.Point,
visible: boolean,
activate(): void,
close(): void,
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
releasePointerCapture(): void,
setPointerCapture(): void,
onactivated: any,
onautomationproviderrequested: any,
oncharacterreceived: any,
onclosed: any,
oninputenabled: any,
onkeydown: any,
onkeyup: any,
onpointercapturelost: any,
onpointerentered: any,
onpointerexited: any,
onpointermoved: any,
onpointerpressed: any,
onpointerreleased: any,
ontouchhittesting: any,
onpointerwheelchanged: any,
onsizechanged: any,
onvisibilitychanged: any
} 
	declare export class CoreDispatcher mixins undefined.ICoreDispatcher, undefined.ICoreAcceleratorKeys {
hasThreadAccess: boolean;
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void;
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
onacceleratorkeyactivated: any
}
	declare export class CoreCursor mixins undefined.ICoreCursor {
constructor(type: Windows$Windows$UI.Core.CoreCursorType, id: number): this;
id: number;
type: Windows$Windows$UI.Core.CoreCursorType
}
	declare export class CoreWindow mixins undefined.ICoreWindow {
automationHostProvider: any;
bounds: Windows$Windows$Foundation.Rect;
customProperties: Windows$Windows$Foundation.Collections.IPropertySet;
dispatcher: Windows$Windows$UI.Core.CoreDispatcher;
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection;
isInputEnabled: boolean;
pointerCursor: Windows$Windows$UI.Core.CoreCursor;
pointerPosition: Windows$Windows$Foundation.Point;
visible: boolean;
activate(): void;
close(): void;
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
releasePointerCapture(): void;
setPointerCapture(): void;
onactivated: any;
onautomationproviderrequested: any;
oncharacterreceived: any;
onclosed: any;
oninputenabled: any;
onkeydown: any;
onkeyup: any;
onpointercapturelost: any;
onpointerentered: any;
onpointerexited: any;
onpointermoved: any;
onpointerpressed: any;
onpointerreleased: any;
ontouchhittesting: any;
onpointerwheelchanged: any;
onsizechanged: any;
onvisibilitychanged: any;
static getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
}
	declare export class WindowActivatedEventArgs mixins undefined.IWindowActivatedEventArgs, undefined.ICoreWindowEventArgs {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState;
handled: boolean
}
	declare export class AutomationProviderRequestedEventArgs mixins undefined.IAutomationProviderRequestedEventArgs, undefined.ICoreWindowEventArgs {
automationProvider: any;
handled: boolean
}
	declare export class CharacterReceivedEventArgs mixins undefined.ICharacterReceivedEventArgs, undefined.ICoreWindowEventArgs {
keyCode: number;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
handled: boolean
}
	declare export class CoreWindowEventArgs mixins undefined.ICoreWindowEventArgs {
handled: boolean
}
	declare export class InputEnabledEventArgs mixins undefined.IInputEnabledEventArgs, undefined.ICoreWindowEventArgs {
inputEnabled: boolean;
handled: boolean
}
	declare export class KeyEventArgs mixins undefined.IKeyEventArgs, undefined.ICoreWindowEventArgs {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export class PointerEventArgs mixins undefined.IPointerEventArgs, undefined.ICoreWindowEventArgs {
currentPoint: Windows$Windows$UI.Input.PointerPoint;
keyModifiers: Windows$Windows$System.VirtualKeyModifiers;
handled: boolean;
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
}
	declare export class TouchHitTestingEventArgs mixins undefined.ITouchHitTestingEventArgs, undefined.ICoreWindowEventArgs {
boundingBox: Windows$Windows$Foundation.Rect;
point: Windows$Windows$Foundation.Point;
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation;
handled: boolean;
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation;
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
}
	declare export class WindowSizeChangedEventArgs mixins undefined.IWindowSizeChangedEventArgs, undefined.ICoreWindowEventArgs {
size: Windows$Windows$Foundation.Size;
handled: boolean
}
	declare export class VisibilityChangedEventArgs mixins undefined.IVisibilityChangedEventArgs, undefined.ICoreWindowEventArgs {
visible: boolean;
handled: boolean
}
	declare export interface ICoreWindowStatic {
getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
} 
	declare export interface DispatchedHandler {
(): void
} 
	declare export interface IdleDispatchedHandler {
(e: Windows$Windows$UI.Core.IdleDispatchedHandlerArgs): void
} 
	declare export class IdleDispatchedHandlerArgs mixins undefined.IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
}
	declare export type IAcceleratorKeyEventArgs = {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
} 
	declare export class AcceleratorKeyEventArgs mixins undefined.IAcceleratorKeyEventArgs, undefined.ICoreWindowEventArgs {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export type ICoreDispatcher = {
hasThreadAccess: boolean,
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void,
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction,
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction
} & undefined.ICoreAcceleratorKeys

	declare export interface IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
} 
	declare export class CoreAcceleratorKeys mixins undefined.ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
}
	declare export interface ICoreCursor {
id: number,
type: Windows$Windows$UI.Core.CoreCursorType
} 
	declare export interface ICoreCursorFactory {
createCursor(
type: Windows$Windows$UI.Core.CoreCursorType,
id: number): Windows$Windows$UI.Core.CoreCursor
} 
	declare export interface IInitializeWithCoreWindow {
initialize(window: Windows$Windows$UI.Core.CoreWindow): void
} 
	declare export interface ICoreWindowResizeManager {
notifyLayoutCompleted(): void
} 
	declare export interface ICoreWindowResizeManagerStatics {
getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
} 
	declare export class CoreWindowResizeManager mixins undefined.ICoreWindowResizeManager {
notifyLayoutCompleted(): void;
static getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
}
	declare export interface ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
} 
	declare export class CoreWindowPopupShowingEventArgs mixins undefined.ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
}
	declare export interface ICoreWindowDialog {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
cancelCommandIndex: number,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowDialogFactory {
createWithTitle(title: string): Windows$Windows$UI.Core.CoreWindowDialog
} 
	declare export class CoreWindowDialog mixins undefined.ICoreWindowDialog {
constructor(title: string): this;
constructor(): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
cancelCommandIndex: number;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
	declare export interface ICoreWindowFlyout {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowFlyoutFactory {
create(
position: Windows$Windows$Foundation.Point): Windows$Windows$UI.Core.CoreWindowFlyout,
createWithTitle(
position: Windows$Windows$Foundation.Point,
title: string): Windows$Windows$UI.Core.CoreWindowFlyout
} 
	declare export class CoreWindowFlyout mixins undefined.ICoreWindowFlyout {
constructor(position: Windows$Windows$Foundation.Point): this;
constructor(position: Windows$Windows$Foundation.Point, title: string): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
    }

    }

    }

	declare module 'Store' {
        declare export interface LicenseChangedEventHandler {
(): void
} 
	declare export interface ICurrentApp {
appId: string,
licenseInformation: Windows$Windows$ApplicationModel.Store.LicenseInformation,
linkUri: Windows$Windows$Foundation.Uri,
requestAppPurchaseAsync(includeReceipt: boolean): Windows$Windows$Foundation.IAsyncOperation<string>,
requestProductPurchaseAsync(
productId: string,
includeReceipt: boolean): Windows$Windows$Foundation.IAsyncOperation<string>,
loadListingInformationAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$ApplicationModel.Store.ListingInformation>,
getAppReceiptAsync(): Windows$Windows$Foundation.IAsyncOperation<string>,
getProductReceiptAsync(productId: string): Windows$Windows$Foundation.IAsyncOperation<string>
} 
	declare export class LicenseInformation mixins undefined.ILicenseInformation {
expirationDate: Date;
isActive: boolean;
isTrial: boolean;
productLicenses: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Store.ProductLicense>;
onlicensechanged: any
}
	declare export class ListingInformation mixins undefined.IListingInformation {
ageRating: number;
currentMarket: string;
description: string;
formattedPrice: string;
name: string;
productListings: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Store.ProductListing>
}
	declare export interface ICurrentAppSimulator {
appId: string,
licenseInformation: Windows$Windows$ApplicationModel.Store.LicenseInformation,
linkUri: Windows$Windows$Foundation.Uri,
requestAppPurchaseAsync(includeReceipt: boolean): Windows$Windows$Foundation.IAsyncOperation<string>,
requestProductPurchaseAsync(
productId: string,
includeReceipt: boolean): Windows$Windows$Foundation.IAsyncOperation<string>,
loadListingInformationAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$ApplicationModel.Store.ListingInformation>,
getAppReceiptAsync(): Windows$Windows$Foundation.IAsyncOperation<string>,
getProductReceiptAsync(productId: string): Windows$Windows$Foundation.IAsyncOperation<string>,
reloadSimulatorAsync(
simulatorSettingsFile: Windows$Windows$Storage.StorageFile): Windows$Windows$Foundation.IAsyncAction
} 
	declare export interface ILicenseInformation {
expirationDate: Date,
isActive: boolean,
isTrial: boolean,
productLicenses: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Store.ProductLicense>,
onlicensechanged: any
} 
	declare export class ProductLicense mixins undefined.IProductLicense {
expirationDate: Date;
isActive: boolean;
productId: string
}
	declare export interface IProductLicense {
expirationDate: Date,
isActive: boolean,
productId: string
} 
	declare export interface IListingInformation {
ageRating: number,
currentMarket: string,
description: string,
formattedPrice: string,
name: string,
productListings: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Store.ProductListing>
} 
	declare export class ProductListing mixins undefined.IProductListing {
formattedPrice: string;
name: string;
productId: string
}
	declare export interface IProductListing {
formattedPrice: string,
name: string,
productId: string
} 
	declare export class CurrentApp  {
static appId: string;
static licenseInformation: Windows$Windows$ApplicationModel.Store.LicenseInformation;
static linkUri: Windows$Windows$Foundation.Uri;
static requestAppPurchaseAsync(includeReceipt: boolean): Windows$Windows$Foundation.IAsyncOperation<string>;
static requestProductPurchaseAsync(
productId: string,
includeReceipt: boolean): Windows$Windows$Foundation.IAsyncOperation<string>;
static loadListingInformationAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$ApplicationModel.Store.ListingInformation>;
static getAppReceiptAsync(): Windows$Windows$Foundation.IAsyncOperation<string>;
static getProductReceiptAsync(productId: string): Windows$Windows$Foundation.IAsyncOperation<string>
}
	declare export class CurrentAppSimulator  {
static appId: string;
static licenseInformation: Windows$Windows$ApplicationModel.Store.LicenseInformation;
static linkUri: Windows$Windows$Foundation.Uri;
static requestAppPurchaseAsync(includeReceipt: boolean): Windows$Windows$Foundation.IAsyncOperation<string>;
static requestProductPurchaseAsync(
productId: string,
includeReceipt: boolean): Windows$Windows$Foundation.IAsyncOperation<string>;
static loadListingInformationAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$ApplicationModel.Store.ListingInformation>;
static getAppReceiptAsync(): Windows$Windows$Foundation.IAsyncOperation<string>;
static getProductReceiptAsync(productId: string): Windows$Windows$Foundation.IAsyncOperation<string>;
static reloadSimulatorAsync(
simulatorSettingsFile: Windows$Windows$Storage.StorageFile): Windows$Windows$Foundation.IAsyncAction
}
    }

    }


declare module 'Data' {
        declare module 'Html' {
        declare export interface IHtmlUtilities {
convertToText(html: string): string
} 
	declare export class HtmlUtilities  {
static convertToText(html: string): string
}
    }

	declare module 'Json' {
        declare export  class JsonValueType {
  constructor(...args: empty): mixed;
static +null_: Class<JsonValueType__null_> & JsonValueType__null_ & 0;// 0
static +boolean: Class<JsonValueType__boolean> & JsonValueType__boolean & 1;// 1
static +number: Class<JsonValueType__number> & JsonValueType__number & 2;// 2
static +string: Class<JsonValueType__string> & JsonValueType__string & 3;// 3
static +array: Class<JsonValueType__array> & JsonValueType__array & 4;// 4
static +object: Class<JsonValueType__object> & JsonValueType__object & 5;// 5

}

declare class JsonValueType__null_ mixins JsonValueType {}
declare class JsonValueType__boolean mixins JsonValueType {}
declare class JsonValueType__number mixins JsonValueType {}
declare class JsonValueType__string mixins JsonValueType {}
declare class JsonValueType__array mixins JsonValueType {}
declare class JsonValueType__object mixins JsonValueType {}

	declare export  class JsonErrorStatus {
  constructor(...args: empty): mixed;
static +unknown: Class<JsonErrorStatus__unknown> & JsonErrorStatus__unknown & 0;// 0
static +invalidJsonString: Class<JsonErrorStatus__invalidJsonString> & JsonErrorStatus__invalidJsonString & 1;// 1
static +invalidJsonNumber: Class<JsonErrorStatus__invalidJsonNumber> & JsonErrorStatus__invalidJsonNumber & 2;// 2
static +jsonValueNotFound: Class<JsonErrorStatus__jsonValueNotFound> & JsonErrorStatus__jsonValueNotFound & 3;// 3
static +implementationLimit: Class<JsonErrorStatus__implementationLimit> & JsonErrorStatus__implementationLimit & 4;// 4

}

declare class JsonErrorStatus__unknown mixins JsonErrorStatus {}
declare class JsonErrorStatus__invalidJsonString mixins JsonErrorStatus {}
declare class JsonErrorStatus__invalidJsonNumber mixins JsonErrorStatus {}
declare class JsonErrorStatus__jsonValueNotFound mixins JsonErrorStatus {}
declare class JsonErrorStatus__implementationLimit mixins JsonErrorStatus {}

	declare export interface IJsonValue {
valueType: Windows$Windows$Data.Json.JsonValueType,
stringify(): string,
getString(): string,
getNumber(): number,
getBoolean(): boolean,
getArray(): Windows$Windows$Data.Json.JsonArray,
getObject(): Windows$Windows$Data.Json.JsonObject
} 
	declare export class JsonArray mixins undefined.IJsonArray, undefined.IJsonValue, undefined.IVector<Windows$Windows$Data.Json.IJsonValue>, undefined.IIterable<Windows$Windows$Data.Json.IJsonValue> {
valueType: Windows$Windows$Data.Json.JsonValueType;
size: number;
getObjectAt(index: number): Windows$Windows$Data.Json.JsonObject;
getArrayAt(index: number): Windows$Windows$Data.Json.JsonArray;
getStringAt(index: number): string;
getNumberAt(index: number): number;
getBooleanAt(index: number): boolean;
stringify(): string;
getString(): string;
getNumber(): number;
getBoolean(): boolean;
getArray(): Windows$Windows$Data.Json.JsonArray;
getObject(): Windows$Windows$Data.Json.JsonObject;
getAt(index: number): Windows$Windows$Data.Json.IJsonValue;
getView(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Data.Json.IJsonValue>;
indexOf(
value: Windows$Windows$Data.Json.IJsonValue): {
index: number,
returnValue: boolean
};
setAt(index: number, value: Windows$Windows$Data.Json.IJsonValue): void;
insertAt(index: number, value: Windows$Windows$Data.Json.IJsonValue): void;
removeAt(index: number): void;
append(value: Windows$Windows$Data.Json.IJsonValue): void;
removeAtEnd(): void;
clear(): void;
getMany(
startIndex: number): {
items: Windows$Windows$Data.Json.IJsonValue[],
returnValue: number
};
replaceAll(items: Windows$Windows$Data.Json.IJsonValue[]): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Data.Json.IJsonValue>;
static parse(input: string): Windows$Windows$Data.Json.JsonArray;
static tryParse(
input: string): {
result: Windows$Windows$Data.Json.JsonArray,
succeeded: boolean
};
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$Data.Json.IJsonValue[][]): Windows$Windows$Data.Json.IJsonValue[];
join(seperator: string): string;
pop(): Windows$Windows$Data.Json.IJsonValue;
push(...items: Windows$Windows$Data.Json.IJsonValue[]): void;
reverse(): Windows$Windows$Data.Json.IJsonValue[];
shift(): Windows$Windows$Data.Json.IJsonValue;
slice(start: number): Windows$Windows$Data.Json.IJsonValue[];
slice(start: number, end: number): Windows$Windows$Data.Json.IJsonValue[];
sort(): Windows$Windows$Data.Json.IJsonValue[];
sort(
compareFn: (
a: Windows$Windows$Data.Json.IJsonValue,
b: Windows$Windows$Data.Json.IJsonValue) => number): Windows$Windows$Data.Json.IJsonValue[];
splice(start: number): Windows$Windows$Data.Json.IJsonValue[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$Data.Json.IJsonValue[]): Windows$Windows$Data.Json.IJsonValue[];
unshift(...items: Windows$Windows$Data.Json.IJsonValue[]): number;
lastIndexOf(searchElement: Windows$Windows$Data.Json.IJsonValue): number;
lastIndexOf(searchElement: Windows$Windows$Data.Json.IJsonValue, fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$Data.Json.IJsonValue,
index: number,
array: Windows$Windows$Data.Json.IJsonValue[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$Data.Json.IJsonValue,
index: number,
array: Windows$Windows$Data.Json.IJsonValue[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$Data.Json.IJsonValue,
index: number,
array: Windows$Windows$Data.Json.IJsonValue[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$Data.Json.IJsonValue,
index: number,
array: Windows$Windows$Data.Json.IJsonValue[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$Data.Json.IJsonValue,
index: number,
array: Windows$Windows$Data.Json.IJsonValue[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$Data.Json.IJsonValue,
index: number,
array: Windows$Windows$Data.Json.IJsonValue[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$Data.Json.IJsonValue,
index: number,
array: Windows$Windows$Data.Json.IJsonValue[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$Data.Json.IJsonValue,
index: number,
array: Windows$Windows$Data.Json.IJsonValue[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$Data.Json.IJsonValue,
index: number,
array: Windows$Windows$Data.Json.IJsonValue[]) => boolean): Windows$Windows$Data.Json.IJsonValue[];
filter(
callbackfn: (
value: Windows$Windows$Data.Json.IJsonValue,
index: number,
array: Windows$Windows$Data.Json.IJsonValue[]) => boolean,
thisArg: any): Windows$Windows$Data.Json.IJsonValue[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Data.Json.IJsonValue[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Data.Json.IJsonValue[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Data.Json.IJsonValue[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Data.Json.IJsonValue[]) => any,
initialValue: any): any;
length: number
}
	declare export class JsonObject mixins undefined.IJsonObject, undefined.IJsonValue, undefined.IMap<string, Windows$Windows$Data.Json.IJsonValue>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$Data.Json.IJsonValue>> {
valueType: Windows$Windows$Data.Json.JsonValueType;
size: number;
getNamedValue(name: string): Windows$Windows$Data.Json.JsonValue;
setNamedValue(name: string, value: Windows$Windows$Data.Json.IJsonValue): void;
getNamedObject(name: string): Windows$Windows$Data.Json.JsonObject;
getNamedArray(name: string): Windows$Windows$Data.Json.JsonArray;
getNamedString(name: string): string;
getNamedNumber(name: string): number;
getNamedBoolean(name: string): boolean;
stringify(): string;
getString(): string;
getNumber(): number;
getBoolean(): boolean;
getArray(): Windows$Windows$Data.Json.JsonArray;
getObject(): Windows$Windows$Data.Json.JsonObject;
lookup(key: string): Windows$Windows$Data.Json.IJsonValue;
hasKey(key: string): boolean;
getView(
): Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$Data.Json.IJsonValue>;
insert(key: string, value: Windows$Windows$Data.Json.IJsonValue): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$Data.Json.IJsonValue>>;
static parse(input: string): Windows$Windows$Data.Json.JsonObject;
static tryParse(
input: string): {
result: Windows$Windows$Data.Json.JsonObject,
succeeded: boolean
}
}
	declare export interface IJsonValueStatics {
parse(input: string): Windows$Windows$Data.Json.JsonValue,
tryParse(
input: string): {
result: Windows$Windows$Data.Json.JsonValue,
succeeded: boolean
},
createBooleanValue(input: boolean): Windows$Windows$Data.Json.JsonValue,
createNumberValue(input: number): Windows$Windows$Data.Json.JsonValue,
createStringValue(input: string): Windows$Windows$Data.Json.JsonValue
} 
	declare export class JsonValue mixins undefined.IJsonValue {
valueType: Windows$Windows$Data.Json.JsonValueType;
stringify(): string;
getString(): string;
getNumber(): number;
getBoolean(): boolean;
getArray(): Windows$Windows$Data.Json.JsonArray;
getObject(): Windows$Windows$Data.Json.JsonObject;
static parse(input: string): Windows$Windows$Data.Json.JsonValue;
static tryParse(
input: string): {
result: Windows$Windows$Data.Json.JsonValue,
succeeded: boolean
};
static createBooleanValue(input: boolean): Windows$Windows$Data.Json.JsonValue;
static createNumberValue(input: number): Windows$Windows$Data.Json.JsonValue;
static createStringValue(input: string): Windows$Windows$Data.Json.JsonValue
}
	declare export type IJsonObject = {
getNamedValue(name: string): Windows$Windows$Data.Json.JsonValue,
setNamedValue(name: string, value: Windows$Windows$Data.Json.IJsonValue): void,
getNamedObject(name: string): Windows$Windows$Data.Json.JsonObject,
getNamedArray(name: string): Windows$Windows$Data.Json.JsonArray,
getNamedString(name: string): string,
getNamedNumber(name: string): number,
getNamedBoolean(name: string): boolean
} & undefined.IJsonValue

	declare export interface IJsonObjectStatics {
parse(input: string): Windows$Windows$Data.Json.JsonObject,
tryParse(
input: string): {
result: Windows$Windows$Data.Json.JsonObject,
succeeded: boolean
}
} 
	declare export type IJsonArray = {
getObjectAt(index: number): Windows$Windows$Data.Json.JsonObject,
getArrayAt(index: number): Windows$Windows$Data.Json.JsonArray,
getStringAt(index: number): string,
getNumberAt(index: number): number,
getBooleanAt(index: number): boolean
} & undefined.IJsonValue

	declare export interface IJsonArrayStatics {
parse(input: string): Windows$Windows$Data.Json.JsonArray,
tryParse(
input: string): {
result: Windows$Windows$Data.Json.JsonArray,
succeeded: boolean
}
} 
	declare export interface IJsonErrorStatics {
getStatus(hresult: number): Windows$Windows$Data.Json.JsonErrorStatus
} 
	declare export class JsonError  {
static getStatus(hresult: number): Windows$Windows$Data.Json.JsonErrorStatus
}
    }

	declare module 'Xml' {
        declare module 'Dom' {
        declare export  class NodeType {
  constructor(...args: empty): mixed;
static +invalid: Class<NodeType__invalid> & NodeType__invalid & 0;// 0
static +elementNode: Class<NodeType__elementNode> & NodeType__elementNode & 1;// 1
static +attributeNode: Class<NodeType__attributeNode> & NodeType__attributeNode & 2;// 2
static +textNode: Class<NodeType__textNode> & NodeType__textNode & 3;// 3
static +dataSectionNode: Class<NodeType__dataSectionNode> & NodeType__dataSectionNode & 4;// 4
static +entityReferenceNode: Class<NodeType__entityReferenceNode> & NodeType__entityReferenceNode & 5;// 5
static +entityNode: Class<NodeType__entityNode> & NodeType__entityNode & 6;// 6
static +processingInstructionNode: Class<NodeType__processingInstructionNode> & NodeType__processingInstructionNode & 7;// 7
static +commentNode: Class<NodeType__commentNode> & NodeType__commentNode & 8;// 8
static +documentNode: Class<NodeType__documentNode> & NodeType__documentNode & 9;// 9
static +documentTypeNode: Class<NodeType__documentTypeNode> & NodeType__documentTypeNode & 10;// 10
static +documentFragmentNode: Class<NodeType__documentFragmentNode> & NodeType__documentFragmentNode & 11;// 11
static +notationNode: Class<NodeType__notationNode> & NodeType__notationNode & 12;// 12

}

declare class NodeType__invalid mixins NodeType {}
declare class NodeType__elementNode mixins NodeType {}
declare class NodeType__attributeNode mixins NodeType {}
declare class NodeType__textNode mixins NodeType {}
declare class NodeType__dataSectionNode mixins NodeType {}
declare class NodeType__entityReferenceNode mixins NodeType {}
declare class NodeType__entityNode mixins NodeType {}
declare class NodeType__processingInstructionNode mixins NodeType {}
declare class NodeType__commentNode mixins NodeType {}
declare class NodeType__documentNode mixins NodeType {}
declare class NodeType__documentTypeNode mixins NodeType {}
declare class NodeType__documentFragmentNode mixins NodeType {}
declare class NodeType__notationNode mixins NodeType {}

	declare export interface IXmlNodeSelector {
selectSingleNode(xpath: string): Windows$Windows$Data.Xml.Dom.IXmlNode,
selectNodes(xpath: string): Windows$Windows$Data.Xml.Dom.XmlNodeList,
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.IXmlNode,
selectNodesNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.XmlNodeList
} 
	declare export class XmlNodeList mixins undefined.IXmlNodeList, undefined.IVectorView<Windows$Windows$Data.Xml.Dom.IXmlNode>, undefined.IIterable<Windows$Windows$Data.Xml.Dom.IXmlNode> {
length: number;
size: number;
item(index: number): Windows$Windows$Data.Xml.Dom.IXmlNode;
getAt(index: number): Windows$Windows$Data.Xml.Dom.IXmlNode;
indexOf(
value: Windows$Windows$Data.Xml.Dom.IXmlNode): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$Data.Xml.Dom.IXmlNode[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Data.Xml.Dom.IXmlNode>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$Data.Xml.Dom.IXmlNode[][]): Windows$Windows$Data.Xml.Dom.IXmlNode[];
join(seperator: string): string;
pop(): Windows$Windows$Data.Xml.Dom.IXmlNode;
push(...items: Windows$Windows$Data.Xml.Dom.IXmlNode[]): void;
reverse(): Windows$Windows$Data.Xml.Dom.IXmlNode[];
shift(): Windows$Windows$Data.Xml.Dom.IXmlNode;
slice(start: number): Windows$Windows$Data.Xml.Dom.IXmlNode[];
slice(start: number, end: number): Windows$Windows$Data.Xml.Dom.IXmlNode[];
sort(): Windows$Windows$Data.Xml.Dom.IXmlNode[];
sort(
compareFn: (
a: Windows$Windows$Data.Xml.Dom.IXmlNode,
b: Windows$Windows$Data.Xml.Dom.IXmlNode) => number): Windows$Windows$Data.Xml.Dom.IXmlNode[];
splice(start: number): Windows$Windows$Data.Xml.Dom.IXmlNode[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$Data.Xml.Dom.IXmlNode[]): Windows$Windows$Data.Xml.Dom.IXmlNode[];
unshift(...items: Windows$Windows$Data.Xml.Dom.IXmlNode[]): number;
lastIndexOf(searchElement: Windows$Windows$Data.Xml.Dom.IXmlNode): number;
lastIndexOf(
searchElement: Windows$Windows$Data.Xml.Dom.IXmlNode,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => boolean): Windows$Windows$Data.Xml.Dom.IXmlNode[];
filter(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => boolean,
thisArg: any): Windows$Windows$Data.Xml.Dom.IXmlNode[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => any,
initialValue: any): any
}
	declare export class XmlNamedNodeMap mixins undefined.IXmlNamedNodeMap, undefined.IVectorView<Windows$Windows$Data.Xml.Dom.IXmlNode>, undefined.IIterable<Windows$Windows$Data.Xml.Dom.IXmlNode> {
length: number;
size: number;
item(index: number): Windows$Windows$Data.Xml.Dom.IXmlNode;
getNamedItem(name: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
setNamedItem(
node: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
removeNamedItem(name: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
getNamedItemNS(namespaceUri: any, name: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
removeNamedItemNS(namespaceUri: any, name: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
setNamedItemNS(
node: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
getAt(index: number): Windows$Windows$Data.Xml.Dom.IXmlNode;
indexOf(
value: Windows$Windows$Data.Xml.Dom.IXmlNode): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$Data.Xml.Dom.IXmlNode[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Data.Xml.Dom.IXmlNode>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$Data.Xml.Dom.IXmlNode[][]): Windows$Windows$Data.Xml.Dom.IXmlNode[];
join(seperator: string): string;
pop(): Windows$Windows$Data.Xml.Dom.IXmlNode;
push(...items: Windows$Windows$Data.Xml.Dom.IXmlNode[]): void;
reverse(): Windows$Windows$Data.Xml.Dom.IXmlNode[];
shift(): Windows$Windows$Data.Xml.Dom.IXmlNode;
slice(start: number): Windows$Windows$Data.Xml.Dom.IXmlNode[];
slice(start: number, end: number): Windows$Windows$Data.Xml.Dom.IXmlNode[];
sort(): Windows$Windows$Data.Xml.Dom.IXmlNode[];
sort(
compareFn: (
a: Windows$Windows$Data.Xml.Dom.IXmlNode,
b: Windows$Windows$Data.Xml.Dom.IXmlNode) => number): Windows$Windows$Data.Xml.Dom.IXmlNode[];
splice(start: number): Windows$Windows$Data.Xml.Dom.IXmlNode[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$Data.Xml.Dom.IXmlNode[]): Windows$Windows$Data.Xml.Dom.IXmlNode[];
unshift(...items: Windows$Windows$Data.Xml.Dom.IXmlNode[]): number;
lastIndexOf(searchElement: Windows$Windows$Data.Xml.Dom.IXmlNode): number;
lastIndexOf(
searchElement: Windows$Windows$Data.Xml.Dom.IXmlNode,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => boolean): Windows$Windows$Data.Xml.Dom.IXmlNode[];
filter(
callbackfn: (
value: Windows$Windows$Data.Xml.Dom.IXmlNode,
index: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => boolean,
thisArg: any): Windows$Windows$Data.Xml.Dom.IXmlNode[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Data.Xml.Dom.IXmlNode[]) => any,
initialValue: any): any
}
	declare export class XmlDocument mixins undefined.IXmlDocument, undefined.IXmlNode, undefined.IXmlNodeSelector, undefined.IXmlNodeSerializer, undefined.IXmlDocumentIO {
doctype: Windows$Windows$Data.Xml.Dom.XmlDocumentType;
documentElement: Windows$Windows$Data.Xml.Dom.XmlElement;
documentUri: string;
implementation: Windows$Windows$Data.Xml.Dom.XmlDomImplementation;
attributes: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap;
childNodes: Windows$Windows$Data.Xml.Dom.XmlNodeList;
firstChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
lastChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
localName: any;
namespaceUri: any;
nextSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
nodeName: string;
nodeType: Windows$Windows$Data.Xml.Dom.NodeType;
nodeValue: any;
ownerDocument: Windows$Windows$Data.Xml.Dom.XmlDocument;
parentNode: Windows$Windows$Data.Xml.Dom.IXmlNode;
prefix: any;
previousSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
innerText: string;
createElement(tagName: string): Windows$Windows$Data.Xml.Dom.XmlElement;
createDocumentFragment(): Windows$Windows$Data.Xml.Dom.XmlDocumentFragment;
createTextNode(data: string): Windows$Windows$Data.Xml.Dom.XmlText;
createComment(data: string): Windows$Windows$Data.Xml.Dom.XmlComment;
createProcessingInstruction(
target: string,
data: string): Windows$Windows$Data.Xml.Dom.XmlProcessingInstruction;
createAttribute(name: string): Windows$Windows$Data.Xml.Dom.XmlAttribute;
createEntityReference(name: string): Windows$Windows$Data.Xml.Dom.XmlEntityReference;
getElementsByTagName(tagName: string): Windows$Windows$Data.Xml.Dom.XmlNodeList;
createCDataSection(data: string): Windows$Windows$Data.Xml.Dom.XmlCDataSection;
createAttributeNS(
namespaceUri: any,
qualifiedName: string): Windows$Windows$Data.Xml.Dom.XmlAttribute;
createElementNS(
namespaceUri: any,
qualifiedName: string): Windows$Windows$Data.Xml.Dom.XmlElement;
getElementById(elementId: string): Windows$Windows$Data.Xml.Dom.XmlElement;
importNode(
node: Windows$Windows$Data.Xml.Dom.IXmlNode,
deep: boolean): Windows$Windows$Data.Xml.Dom.IXmlNode;
hasChildNodes(): boolean;
insertBefore(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
replaceChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
removeChild(
childNode: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
appendChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
cloneNode(deep: boolean): Windows$Windows$Data.Xml.Dom.IXmlNode;
normalize(): void;
selectSingleNode(xpath: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodes(xpath: string): Windows$Windows$Data.Xml.Dom.XmlNodeList;
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodesNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.XmlNodeList;
getXml(): string;
loadXml(xml: string): void;
loadXml(xml: string, loadSettings: Windows$Windows$Data.Xml.Dom.XmlLoadSettings): void;
saveToFileAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncAction;
static loadFromUriAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Data.Xml.Dom.XmlDocument>;
static loadFromUriAsync(
uri: Windows$Windows$Foundation.Uri,
loadSettings: Windows$Windows$Data.Xml.Dom.XmlLoadSettings): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Data.Xml.Dom.XmlDocument>;
static loadFromFileAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Data.Xml.Dom.XmlDocument>;
static loadFromFileAsync(
file: Windows$Windows$Storage.IStorageFile,
loadSettings: Windows$Windows$Data.Xml.Dom.XmlLoadSettings): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Data.Xml.Dom.XmlDocument>
}
	declare export interface IXmlNodeSerializer {
innerText: string,
getXml(): string
} 
	declare export type IXmlNode = {
attributes: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap,
childNodes: Windows$Windows$Data.Xml.Dom.XmlNodeList,
firstChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
lastChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
localName: any,
namespaceUri: any,
nextSibling: Windows$Windows$Data.Xml.Dom.IXmlNode,
nodeName: string,
nodeType: Windows$Windows$Data.Xml.Dom.NodeType,
nodeValue: any,
ownerDocument: Windows$Windows$Data.Xml.Dom.XmlDocument,
parentNode: Windows$Windows$Data.Xml.Dom.IXmlNode,
prefix: any,
previousSibling: Windows$Windows$Data.Xml.Dom.IXmlNode,
hasChildNodes(): boolean,
insertBefore(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode,
replaceChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode,
removeChild(
childNode: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode,
appendChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode,
cloneNode(deep: boolean): Windows$Windows$Data.Xml.Dom.IXmlNode,
normalize(): void
} & undefined.IXmlNodeSelector & undefined.IXmlNodeSerializer

	declare export interface IXmlDomImplementation {
hasFeature(feature: string, version: any): boolean
} 
	declare export type IXmlDocumentType = {
entities: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap,
name: string,
notations: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap
} & undefined.IXmlNode & undefined.IXmlNodeSelector & undefined.IXmlNodeSerializer

	declare export type IXmlAttribute = {
name: string,
specified: boolean,
value: string
} & undefined.IXmlNode & undefined.IXmlNodeSelector & undefined.IXmlNodeSerializer

	declare export type IXmlDocumentFragment = {} & undefined.IXmlNode & undefined.IXmlNodeSelector & undefined.IXmlNodeSerializer

	declare export type IXmlElement = {
tagName: string,
getAttribute(attributeName: string): string,
setAttribute(attributeName: string, attributeValue: string): void,
removeAttribute(attributeName: string): void,
getAttributeNode(attributeName: string): Windows$Windows$Data.Xml.Dom.XmlAttribute,
setAttributeNode(
newAttribute: Windows$Windows$Data.Xml.Dom.XmlAttribute): Windows$Windows$Data.Xml.Dom.XmlAttribute,
removeAttributeNode(
attributeNode: Windows$Windows$Data.Xml.Dom.XmlAttribute): Windows$Windows$Data.Xml.Dom.XmlAttribute,
getElementsByTagName(tagName: string): Windows$Windows$Data.Xml.Dom.XmlNodeList,
setAttributeNS(namespaceUri: any, qualifiedName: string, value: string): void,
getAttributeNS(namespaceUri: any, localName: string): string,
removeAttributeNS(namespaceUri: any, localName: string): void,
setAttributeNodeNS(
newAttribute: Windows$Windows$Data.Xml.Dom.XmlAttribute): Windows$Windows$Data.Xml.Dom.XmlAttribute,
getAttributeNodeNS(
namespaceUri: any,
localName: string): Windows$Windows$Data.Xml.Dom.XmlAttribute
} & undefined.IXmlNode & undefined.IXmlNodeSelector & undefined.IXmlNodeSerializer

	declare export class XmlAttribute mixins undefined.IXmlAttribute, undefined.IXmlNode, undefined.IXmlNodeSelector, undefined.IXmlNodeSerializer {
name: string;
specified: boolean;
value: string;
attributes: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap;
childNodes: Windows$Windows$Data.Xml.Dom.XmlNodeList;
firstChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
lastChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
localName: any;
namespaceUri: any;
nextSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
nodeName: string;
nodeType: Windows$Windows$Data.Xml.Dom.NodeType;
nodeValue: any;
ownerDocument: Windows$Windows$Data.Xml.Dom.XmlDocument;
parentNode: Windows$Windows$Data.Xml.Dom.IXmlNode;
prefix: any;
previousSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
innerText: string;
hasChildNodes(): boolean;
insertBefore(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
replaceChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
removeChild(
childNode: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
appendChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
cloneNode(deep: boolean): Windows$Windows$Data.Xml.Dom.IXmlNode;
normalize(): void;
selectSingleNode(xpath: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodes(xpath: string): Windows$Windows$Data.Xml.Dom.XmlNodeList;
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodesNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.XmlNodeList;
getXml(): string
}
	declare export type IDtdNotation = {
publicId: any,
systemId: any
} & undefined.IXmlNode & undefined.IXmlNodeSelector & undefined.IXmlNodeSerializer

	declare export type IDtdEntity = {
notationName: any,
publicId: any,
systemId: any
} & undefined.IXmlNode & undefined.IXmlNodeSelector & undefined.IXmlNodeSerializer

	declare export type IXmlEntityReference = {} & undefined.IXmlNode & undefined.IXmlNodeSelector & undefined.IXmlNodeSerializer

	declare export type IXmlProcessingInstruction = {
data: string,
target: string
} & undefined.IXmlNode & undefined.IXmlNodeSelector & undefined.IXmlNodeSerializer

	declare export type IXmlCharacterData = {
data: string,
length: number,
substringData(offset: number, count: number): string,
appendData(data: string): void,
insertData(offset: number, data: string): void,
deleteData(offset: number, count: number): void,
replaceData(offset: number, count: number, data: string): void
} & undefined.IXmlNode & undefined.IXmlNodeSelector & undefined.IXmlNodeSerializer

	declare export type IXmlComment = {} & undefined.IXmlCharacterData & undefined.IXmlNode & undefined.IXmlNodeSelector & undefined.IXmlNodeSerializer

	declare export type IXmlText = {
splitText(offset: number): Windows$Windows$Data.Xml.Dom.IXmlText
} & undefined.IXmlCharacterData & undefined.IXmlNode & undefined.IXmlNodeSelector & undefined.IXmlNodeSerializer

	declare export type IXmlCDataSection = {} & undefined.IXmlText & undefined.IXmlCharacterData & undefined.IXmlNode & undefined.IXmlNodeSelector & undefined.IXmlNodeSerializer

	declare export type IXmlDocument = {
doctype: Windows$Windows$Data.Xml.Dom.XmlDocumentType,
documentElement: Windows$Windows$Data.Xml.Dom.XmlElement,
documentUri: string,
implementation: Windows$Windows$Data.Xml.Dom.XmlDomImplementation,
createElement(tagName: string): Windows$Windows$Data.Xml.Dom.XmlElement,
createDocumentFragment(): Windows$Windows$Data.Xml.Dom.XmlDocumentFragment,
createTextNode(data: string): Windows$Windows$Data.Xml.Dom.XmlText,
createComment(data: string): Windows$Windows$Data.Xml.Dom.XmlComment,
createProcessingInstruction(
target: string,
data: string): Windows$Windows$Data.Xml.Dom.XmlProcessingInstruction,
createAttribute(name: string): Windows$Windows$Data.Xml.Dom.XmlAttribute,
createEntityReference(name: string): Windows$Windows$Data.Xml.Dom.XmlEntityReference,
getElementsByTagName(tagName: string): Windows$Windows$Data.Xml.Dom.XmlNodeList,
createCDataSection(data: string): Windows$Windows$Data.Xml.Dom.XmlCDataSection,
createAttributeNS(
namespaceUri: any,
qualifiedName: string): Windows$Windows$Data.Xml.Dom.XmlAttribute,
createElementNS(
namespaceUri: any,
qualifiedName: string): Windows$Windows$Data.Xml.Dom.XmlElement,
getElementById(elementId: string): Windows$Windows$Data.Xml.Dom.XmlElement,
importNode(
node: Windows$Windows$Data.Xml.Dom.IXmlNode,
deep: boolean): Windows$Windows$Data.Xml.Dom.IXmlNode
} & undefined.IXmlNode & undefined.IXmlNodeSelector & undefined.IXmlNodeSerializer

	declare export class XmlDocumentType mixins undefined.IXmlDocumentType, undefined.IXmlNode, undefined.IXmlNodeSelector, undefined.IXmlNodeSerializer {
entities: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap;
name: string;
notations: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap;
attributes: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap;
childNodes: Windows$Windows$Data.Xml.Dom.XmlNodeList;
firstChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
lastChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
localName: any;
namespaceUri: any;
nextSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
nodeName: string;
nodeType: Windows$Windows$Data.Xml.Dom.NodeType;
nodeValue: any;
ownerDocument: Windows$Windows$Data.Xml.Dom.XmlDocument;
parentNode: Windows$Windows$Data.Xml.Dom.IXmlNode;
prefix: any;
previousSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
innerText: string;
hasChildNodes(): boolean;
insertBefore(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
replaceChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
removeChild(
childNode: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
appendChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
cloneNode(deep: boolean): Windows$Windows$Data.Xml.Dom.IXmlNode;
normalize(): void;
selectSingleNode(xpath: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodes(xpath: string): Windows$Windows$Data.Xml.Dom.XmlNodeList;
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodesNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.XmlNodeList;
getXml(): string
}
	declare export class XmlDomImplementation mixins undefined.IXmlDomImplementation {
hasFeature(feature: string, version: any): boolean
}
	declare export class XmlElement mixins undefined.IXmlElement, undefined.IXmlNode, undefined.IXmlNodeSelector, undefined.IXmlNodeSerializer {
tagName: string;
attributes: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap;
childNodes: Windows$Windows$Data.Xml.Dom.XmlNodeList;
firstChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
lastChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
localName: any;
namespaceUri: any;
nextSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
nodeName: string;
nodeType: Windows$Windows$Data.Xml.Dom.NodeType;
nodeValue: any;
ownerDocument: Windows$Windows$Data.Xml.Dom.XmlDocument;
parentNode: Windows$Windows$Data.Xml.Dom.IXmlNode;
prefix: any;
previousSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
innerText: string;
getAttribute(attributeName: string): string;
setAttribute(attributeName: string, attributeValue: string): void;
removeAttribute(attributeName: string): void;
getAttributeNode(attributeName: string): Windows$Windows$Data.Xml.Dom.XmlAttribute;
setAttributeNode(
newAttribute: Windows$Windows$Data.Xml.Dom.XmlAttribute): Windows$Windows$Data.Xml.Dom.XmlAttribute;
removeAttributeNode(
attributeNode: Windows$Windows$Data.Xml.Dom.XmlAttribute): Windows$Windows$Data.Xml.Dom.XmlAttribute;
getElementsByTagName(tagName: string): Windows$Windows$Data.Xml.Dom.XmlNodeList;
setAttributeNS(namespaceUri: any, qualifiedName: string, value: string): void;
getAttributeNS(namespaceUri: any, localName: string): string;
removeAttributeNS(namespaceUri: any, localName: string): void;
setAttributeNodeNS(
newAttribute: Windows$Windows$Data.Xml.Dom.XmlAttribute): Windows$Windows$Data.Xml.Dom.XmlAttribute;
getAttributeNodeNS(
namespaceUri: any,
localName: string): Windows$Windows$Data.Xml.Dom.XmlAttribute;
hasChildNodes(): boolean;
insertBefore(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
replaceChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
removeChild(
childNode: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
appendChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
cloneNode(deep: boolean): Windows$Windows$Data.Xml.Dom.IXmlNode;
normalize(): void;
selectSingleNode(xpath: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodes(xpath: string): Windows$Windows$Data.Xml.Dom.XmlNodeList;
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodesNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.XmlNodeList;
getXml(): string
}
	declare export class XmlDocumentFragment mixins undefined.IXmlDocumentFragment, undefined.IXmlNode, undefined.IXmlNodeSelector, undefined.IXmlNodeSerializer {
attributes: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap;
childNodes: Windows$Windows$Data.Xml.Dom.XmlNodeList;
firstChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
lastChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
localName: any;
namespaceUri: any;
nextSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
nodeName: string;
nodeType: Windows$Windows$Data.Xml.Dom.NodeType;
nodeValue: any;
ownerDocument: Windows$Windows$Data.Xml.Dom.XmlDocument;
parentNode: Windows$Windows$Data.Xml.Dom.IXmlNode;
prefix: any;
previousSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
innerText: string;
hasChildNodes(): boolean;
insertBefore(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
replaceChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
removeChild(
childNode: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
appendChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
cloneNode(deep: boolean): Windows$Windows$Data.Xml.Dom.IXmlNode;
normalize(): void;
selectSingleNode(xpath: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodes(xpath: string): Windows$Windows$Data.Xml.Dom.XmlNodeList;
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodesNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.XmlNodeList;
getXml(): string
}
	declare export class XmlText mixins undefined.IXmlText, undefined.IXmlCharacterData, undefined.IXmlNode, undefined.IXmlNodeSelector, undefined.IXmlNodeSerializer {
data: string;
length: number;
attributes: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap;
childNodes: Windows$Windows$Data.Xml.Dom.XmlNodeList;
firstChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
lastChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
localName: any;
namespaceUri: any;
nextSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
nodeName: string;
nodeType: Windows$Windows$Data.Xml.Dom.NodeType;
nodeValue: any;
ownerDocument: Windows$Windows$Data.Xml.Dom.XmlDocument;
parentNode: Windows$Windows$Data.Xml.Dom.IXmlNode;
prefix: any;
previousSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
innerText: string;
splitText(offset: number): Windows$Windows$Data.Xml.Dom.IXmlText;
substringData(offset: number, count: number): string;
appendData(data: string): void;
insertData(offset: number, data: string): void;
deleteData(offset: number, count: number): void;
replaceData(offset: number, count: number, data: string): void;
hasChildNodes(): boolean;
insertBefore(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
replaceChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
removeChild(
childNode: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
appendChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
cloneNode(deep: boolean): Windows$Windows$Data.Xml.Dom.IXmlNode;
normalize(): void;
selectSingleNode(xpath: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodes(xpath: string): Windows$Windows$Data.Xml.Dom.XmlNodeList;
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodesNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.XmlNodeList;
getXml(): string
}
	declare export class XmlComment mixins undefined.IXmlComment, undefined.IXmlCharacterData, undefined.IXmlNode, undefined.IXmlNodeSelector, undefined.IXmlNodeSerializer {
data: string;
length: number;
attributes: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap;
childNodes: Windows$Windows$Data.Xml.Dom.XmlNodeList;
firstChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
lastChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
localName: any;
namespaceUri: any;
nextSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
nodeName: string;
nodeType: Windows$Windows$Data.Xml.Dom.NodeType;
nodeValue: any;
ownerDocument: Windows$Windows$Data.Xml.Dom.XmlDocument;
parentNode: Windows$Windows$Data.Xml.Dom.IXmlNode;
prefix: any;
previousSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
innerText: string;
substringData(offset: number, count: number): string;
appendData(data: string): void;
insertData(offset: number, data: string): void;
deleteData(offset: number, count: number): void;
replaceData(offset: number, count: number, data: string): void;
hasChildNodes(): boolean;
insertBefore(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
replaceChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
removeChild(
childNode: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
appendChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
cloneNode(deep: boolean): Windows$Windows$Data.Xml.Dom.IXmlNode;
normalize(): void;
selectSingleNode(xpath: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodes(xpath: string): Windows$Windows$Data.Xml.Dom.XmlNodeList;
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodesNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.XmlNodeList;
getXml(): string
}
	declare export class XmlProcessingInstruction mixins undefined.IXmlProcessingInstruction, undefined.IXmlNode, undefined.IXmlNodeSelector, undefined.IXmlNodeSerializer {
data: string;
target: string;
attributes: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap;
childNodes: Windows$Windows$Data.Xml.Dom.XmlNodeList;
firstChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
lastChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
localName: any;
namespaceUri: any;
nextSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
nodeName: string;
nodeType: Windows$Windows$Data.Xml.Dom.NodeType;
nodeValue: any;
ownerDocument: Windows$Windows$Data.Xml.Dom.XmlDocument;
parentNode: Windows$Windows$Data.Xml.Dom.IXmlNode;
prefix: any;
previousSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
innerText: string;
hasChildNodes(): boolean;
insertBefore(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
replaceChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
removeChild(
childNode: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
appendChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
cloneNode(deep: boolean): Windows$Windows$Data.Xml.Dom.IXmlNode;
normalize(): void;
selectSingleNode(xpath: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodes(xpath: string): Windows$Windows$Data.Xml.Dom.XmlNodeList;
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodesNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.XmlNodeList;
getXml(): string
}
	declare export class XmlEntityReference mixins undefined.IXmlEntityReference, undefined.IXmlNode, undefined.IXmlNodeSelector, undefined.IXmlNodeSerializer {
attributes: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap;
childNodes: Windows$Windows$Data.Xml.Dom.XmlNodeList;
firstChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
lastChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
localName: any;
namespaceUri: any;
nextSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
nodeName: string;
nodeType: Windows$Windows$Data.Xml.Dom.NodeType;
nodeValue: any;
ownerDocument: Windows$Windows$Data.Xml.Dom.XmlDocument;
parentNode: Windows$Windows$Data.Xml.Dom.IXmlNode;
prefix: any;
previousSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
innerText: string;
hasChildNodes(): boolean;
insertBefore(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
replaceChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
removeChild(
childNode: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
appendChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
cloneNode(deep: boolean): Windows$Windows$Data.Xml.Dom.IXmlNode;
normalize(): void;
selectSingleNode(xpath: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodes(xpath: string): Windows$Windows$Data.Xml.Dom.XmlNodeList;
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodesNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.XmlNodeList;
getXml(): string
}
	declare export class XmlCDataSection mixins undefined.IXmlCDataSection, undefined.IXmlText, undefined.IXmlCharacterData, undefined.IXmlNode, undefined.IXmlNodeSelector, undefined.IXmlNodeSerializer {
data: string;
length: number;
attributes: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap;
childNodes: Windows$Windows$Data.Xml.Dom.XmlNodeList;
firstChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
lastChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
localName: any;
namespaceUri: any;
nextSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
nodeName: string;
nodeType: Windows$Windows$Data.Xml.Dom.NodeType;
nodeValue: any;
ownerDocument: Windows$Windows$Data.Xml.Dom.XmlDocument;
parentNode: Windows$Windows$Data.Xml.Dom.IXmlNode;
prefix: any;
previousSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
innerText: string;
splitText(offset: number): Windows$Windows$Data.Xml.Dom.IXmlText;
substringData(offset: number, count: number): string;
appendData(data: string): void;
insertData(offset: number, data: string): void;
deleteData(offset: number, count: number): void;
replaceData(offset: number, count: number, data: string): void;
hasChildNodes(): boolean;
insertBefore(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
replaceChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
removeChild(
childNode: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
appendChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
cloneNode(deep: boolean): Windows$Windows$Data.Xml.Dom.IXmlNode;
normalize(): void;
selectSingleNode(xpath: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodes(xpath: string): Windows$Windows$Data.Xml.Dom.XmlNodeList;
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodesNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.XmlNodeList;
getXml(): string
}
	declare export type IXmlNamedNodeMap = {
length: number,
item(index: number): Windows$Windows$Data.Xml.Dom.IXmlNode,
getNamedItem(name: string): Windows$Windows$Data.Xml.Dom.IXmlNode,
setNamedItem(
node: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode,
removeNamedItem(name: string): Windows$Windows$Data.Xml.Dom.IXmlNode,
getNamedItemNS(namespaceUri: any, name: string): Windows$Windows$Data.Xml.Dom.IXmlNode,
removeNamedItemNS(namespaceUri: any, name: string): Windows$Windows$Data.Xml.Dom.IXmlNode,
setNamedItemNS(
node: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode
} & undefined.IVectorView<Windows$Windows$Data.Xml.Dom.IXmlNode> & undefined.IIterable<Windows$Windows$Data.Xml.Dom.IXmlNode>

	declare export type IXmlNodeList = {
length: number,
item(index: number): Windows$Windows$Data.Xml.Dom.IXmlNode
} & undefined.IVectorView<Windows$Windows$Data.Xml.Dom.IXmlNode> & undefined.IIterable<Windows$Windows$Data.Xml.Dom.IXmlNode>

	declare export interface IXmlLoadSettings {
elementContentWhiteSpace: boolean,
maxElementDepth: number,
prohibitDtd: boolean,
resolveExternals: boolean,
validateOnParse: boolean
} 
	declare export interface IXmlDocumentIO {
loadXml(xml: string): void,
loadXml(xml: string, loadSettings: Windows$Windows$Data.Xml.Dom.XmlLoadSettings): void,
saveToFileAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncAction
} 
	declare export class XmlLoadSettings mixins undefined.IXmlLoadSettings {
elementContentWhiteSpace: boolean;
maxElementDepth: number;
prohibitDtd: boolean;
resolveExternals: boolean;
validateOnParse: boolean
}
	declare export interface IXmlDocumentStatics {
loadFromUriAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Data.Xml.Dom.XmlDocument>,
loadFromUriAsync(
uri: Windows$Windows$Foundation.Uri,
loadSettings: Windows$Windows$Data.Xml.Dom.XmlLoadSettings): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Data.Xml.Dom.XmlDocument>,
loadFromFileAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Data.Xml.Dom.XmlDocument>,
loadFromFileAsync(
file: Windows$Windows$Storage.IStorageFile,
loadSettings: Windows$Windows$Data.Xml.Dom.XmlLoadSettings): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Data.Xml.Dom.XmlDocument>
} 
	declare export class DtdNotation mixins undefined.IDtdNotation, undefined.IXmlNode, undefined.IXmlNodeSelector, undefined.IXmlNodeSerializer {
publicId: any;
systemId: any;
attributes: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap;
childNodes: Windows$Windows$Data.Xml.Dom.XmlNodeList;
firstChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
lastChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
localName: any;
namespaceUri: any;
nextSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
nodeName: string;
nodeType: Windows$Windows$Data.Xml.Dom.NodeType;
nodeValue: any;
ownerDocument: Windows$Windows$Data.Xml.Dom.XmlDocument;
parentNode: Windows$Windows$Data.Xml.Dom.IXmlNode;
prefix: any;
previousSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
innerText: string;
hasChildNodes(): boolean;
insertBefore(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
replaceChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
removeChild(
childNode: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
appendChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
cloneNode(deep: boolean): Windows$Windows$Data.Xml.Dom.IXmlNode;
normalize(): void;
selectSingleNode(xpath: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodes(xpath: string): Windows$Windows$Data.Xml.Dom.XmlNodeList;
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodesNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.XmlNodeList;
getXml(): string
}
	declare export class DtdEntity mixins undefined.IDtdEntity, undefined.IXmlNode, undefined.IXmlNodeSelector, undefined.IXmlNodeSerializer {
notationName: any;
publicId: any;
systemId: any;
attributes: Windows$Windows$Data.Xml.Dom.XmlNamedNodeMap;
childNodes: Windows$Windows$Data.Xml.Dom.XmlNodeList;
firstChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
lastChild: Windows$Windows$Data.Xml.Dom.IXmlNode;
localName: any;
namespaceUri: any;
nextSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
nodeName: string;
nodeType: Windows$Windows$Data.Xml.Dom.NodeType;
nodeValue: any;
ownerDocument: Windows$Windows$Data.Xml.Dom.XmlDocument;
parentNode: Windows$Windows$Data.Xml.Dom.IXmlNode;
prefix: any;
previousSibling: Windows$Windows$Data.Xml.Dom.IXmlNode;
innerText: string;
hasChildNodes(): boolean;
insertBefore(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
replaceChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode,
referenceChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
removeChild(
childNode: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
appendChild(
newChild: Windows$Windows$Data.Xml.Dom.IXmlNode): Windows$Windows$Data.Xml.Dom.IXmlNode;
cloneNode(deep: boolean): Windows$Windows$Data.Xml.Dom.IXmlNode;
normalize(): void;
selectSingleNode(xpath: string): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodes(xpath: string): Windows$Windows$Data.Xml.Dom.XmlNodeList;
selectSingleNodeNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.IXmlNode;
selectNodesNS(xpath: string, namespaces: any): Windows$Windows$Data.Xml.Dom.XmlNodeList;
getXml(): string
}
    }

	declare module 'Xsl' {
        declare export interface IXsltProcessor {
transformToString(inputNode: Windows$Windows$Data.Xml.Dom.IXmlNode): string
} 
	declare export interface IXsltProcessorFactory {
createInstance(
document: Windows$Windows$Data.Xml.Dom.XmlDocument): Windows$Windows$Data.Xml.Xsl.XsltProcessor
} 
	declare export class XsltProcessor mixins undefined.IXsltProcessor {
constructor(document: Windows$Windows$Data.Xml.Dom.XmlDocument): this;
transformToString(inputNode: Windows$Windows$Data.Xml.Dom.IXmlNode): string
}
    }

    }

    }


declare module 'Devices' {
        declare module 'Sms' {
        declare export  class SmsMessageClass {
  constructor(...args: empty): mixed;
static +none: Class<SmsMessageClass__none> & SmsMessageClass__none & 0;// 0
static +class0: Class<SmsMessageClass__class0> & SmsMessageClass__class0 & 1;// 1
static +class1: Class<SmsMessageClass__class1> & SmsMessageClass__class1 & 2;// 2
static +class2: Class<SmsMessageClass__class2> & SmsMessageClass__class2 & 3;// 3
static +class3: Class<SmsMessageClass__class3> & SmsMessageClass__class3 & 4;// 4

}

declare class SmsMessageClass__none mixins SmsMessageClass {}
declare class SmsMessageClass__class0 mixins SmsMessageClass {}
declare class SmsMessageClass__class1 mixins SmsMessageClass {}
declare class SmsMessageClass__class2 mixins SmsMessageClass {}
declare class SmsMessageClass__class3 mixins SmsMessageClass {}

	declare export interface ISmsMessage {
id: number,
messageClass: Windows$Windows$Devices.Sms.SmsMessageClass
} 
	declare export  class SmsDataFormat {
  constructor(...args: empty): mixed;
static +unknown: Class<SmsDataFormat__unknown> & SmsDataFormat__unknown & 0;// 0
static +cdmaSubmit: Class<SmsDataFormat__cdmaSubmit> & SmsDataFormat__cdmaSubmit & 1;// 1
static +gsmSubmit: Class<SmsDataFormat__gsmSubmit> & SmsDataFormat__gsmSubmit & 2;// 2
static +cdmaDeliver: Class<SmsDataFormat__cdmaDeliver> & SmsDataFormat__cdmaDeliver & 3;// 3
static +gsmDeliver: Class<SmsDataFormat__gsmDeliver> & SmsDataFormat__gsmDeliver & 4;// 4

}

declare class SmsDataFormat__unknown mixins SmsDataFormat {}
declare class SmsDataFormat__cdmaSubmit mixins SmsDataFormat {}
declare class SmsDataFormat__gsmSubmit mixins SmsDataFormat {}
declare class SmsDataFormat__cdmaDeliver mixins SmsDataFormat {}
declare class SmsDataFormat__gsmDeliver mixins SmsDataFormat {}

	declare export type ISmsBinaryMessage = {
format: Windows$Windows$Devices.Sms.SmsDataFormat,
getData(): Uint8Array,
setData(value: Uint8Array): void
} & undefined.ISmsMessage

	declare export class SmsBinaryMessage mixins undefined.ISmsBinaryMessage, undefined.ISmsMessage {
format: Windows$Windows$Devices.Sms.SmsDataFormat;
id: number;
messageClass: Windows$Windows$Devices.Sms.SmsMessageClass;
getData(): Uint8Array;
setData(value: Uint8Array): void
}
	declare export  class SmsEncoding {
  constructor(...args: empty): mixed;
static +unknown: Class<SmsEncoding__unknown> & SmsEncoding__unknown & 0;// 0
static +optimal: Class<SmsEncoding__optimal> & SmsEncoding__optimal & 1;// 1
static +sevenBitAscii: Class<SmsEncoding__sevenBitAscii> & SmsEncoding__sevenBitAscii & 2;// 2
static +unicode: Class<SmsEncoding__unicode> & SmsEncoding__unicode & 3;// 3
static +gsmSevenBit: Class<SmsEncoding__gsmSevenBit> & SmsEncoding__gsmSevenBit & 4;// 4

}

declare class SmsEncoding__unknown mixins SmsEncoding {}
declare class SmsEncoding__optimal mixins SmsEncoding {}
declare class SmsEncoding__sevenBitAscii mixins SmsEncoding {}
declare class SmsEncoding__unicode mixins SmsEncoding {}
declare class SmsEncoding__gsmSevenBit mixins SmsEncoding {}

	declare export type ISmsTextMessage = {
body: string,
encoding: Windows$Windows$Devices.Sms.SmsEncoding,
from: string,
partCount: number,
partNumber: number,
partReferenceId: number,
timestamp: Date,
to: string,
toBinaryMessages(
format: Windows$Windows$Devices.Sms.SmsDataFormat): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsBinaryMessage>
} & undefined.ISmsMessage

	declare export interface ISmsTextMessageStatics {
fromBinaryMessage(
binaryMessage: Windows$Windows$Devices.Sms.SmsBinaryMessage): Windows$Windows$Devices.Sms.SmsTextMessage,
fromBinaryData(
format: Windows$Windows$Devices.Sms.SmsDataFormat,
value: Uint8Array): Windows$Windows$Devices.Sms.SmsTextMessage
} 
	declare export class SmsTextMessage mixins undefined.ISmsTextMessage, undefined.ISmsMessage {
body: string;
encoding: Windows$Windows$Devices.Sms.SmsEncoding;
from: string;
partCount: number;
partNumber: number;
partReferenceId: number;
timestamp: Date;
to: string;
id: number;
messageClass: Windows$Windows$Devices.Sms.SmsMessageClass;
toBinaryMessages(
format: Windows$Windows$Devices.Sms.SmsDataFormat): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsBinaryMessage>;
static fromBinaryMessage(
binaryMessage: Windows$Windows$Devices.Sms.SmsBinaryMessage): Windows$Windows$Devices.Sms.SmsTextMessage;
static fromBinaryData(
format: Windows$Windows$Devices.Sms.SmsDataFormat,
value: Uint8Array): Windows$Windows$Devices.Sms.SmsTextMessage
}
	declare export  class SmsMessageFilter {
  constructor(...args: empty): mixed;
static +all: Class<SmsMessageFilter__all> & SmsMessageFilter__all & 0;// 0
static +unread: Class<SmsMessageFilter__unread> & SmsMessageFilter__unread & 1;// 1
static +read: Class<SmsMessageFilter__read> & SmsMessageFilter__read & 2;// 2
static +sent: Class<SmsMessageFilter__sent> & SmsMessageFilter__sent & 3;// 3
static +draft: Class<SmsMessageFilter__draft> & SmsMessageFilter__draft & 4;// 4

}

declare class SmsMessageFilter__all mixins SmsMessageFilter {}
declare class SmsMessageFilter__unread mixins SmsMessageFilter {}
declare class SmsMessageFilter__read mixins SmsMessageFilter {}
declare class SmsMessageFilter__sent mixins SmsMessageFilter {}
declare class SmsMessageFilter__draft mixins SmsMessageFilter {}

	declare export  class SmsMessageType {
  constructor(...args: empty): mixed;
static +binary: Class<SmsMessageType__binary> & SmsMessageType__binary & 0;// 0
static +text: Class<SmsMessageType__text> & SmsMessageType__text & 1;// 1

}

declare class SmsMessageType__binary mixins SmsMessageType {}
declare class SmsMessageType__text mixins SmsMessageType {}

	declare export class DeleteSmsMessageOperation mixins undefined.IAsyncAction, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncActionCompletedHandler;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(): void;
cancel(): void;
close(): void;
then<U>(
success?: (value: any) => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: any) => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: (value: any) => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<any>,
getResults(): any
}
}
	declare export class DeleteSmsMessagesOperation mixins undefined.IAsyncAction, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncActionCompletedHandler;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(): void;
cancel(): void;
close(): void;
then<U>(
success?: (value: any) => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: any) => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: (value: any) => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<any>,
getResults(): any
}
}
	declare export class GetSmsMessageOperation mixins undefined.IAsyncOperation<Windows$Windows$Devices.Sms.ISmsMessage>, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<Windows$Windows$Devices.Sms.ISmsMessage>;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(): Windows$Windows$Devices.Sms.ISmsMessage;
cancel(): void;
close(): void;
then<U>(
success?: (value: Windows$Windows$Devices.Sms.ISmsMessage) => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Devices.Sms.ISmsMessage) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: Windows$Windows$Devices.Sms.ISmsMessage) => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Devices.Sms.ISmsMessage) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: (value: Windows$Windows$Devices.Sms.ISmsMessage) => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<Windows$Windows$Devices.Sms.ISmsMessage>,
getResults(): Windows$Windows$Devices.Sms.ISmsMessage
}
}
	declare export class GetSmsMessagesOperation mixins undefined.IAsyncOperationWithProgress<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>, number>, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncOperationWithProgressCompletedHandler<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>, number>;
progress: Windows$Windows$Foundation.AsyncOperationProgressHandler<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>, number>;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>;
cancel(): void;
close(): void;
then<U>(
success?: (
value: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>) => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>) => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: (
value: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>) => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
progress: Windows$Windows$Foundation.AsyncOperationProgressHandler<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>, number>,
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>>,
getResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>
}
}
	declare export interface ISmsDeviceMessageStore {
maxMessages: number,
deleteMessageAsync(messageId: number): Windows$Windows$Foundation.IAsyncAction,
deleteMessagesAsync(
messageFilter: Windows$Windows$Devices.Sms.SmsMessageFilter): Windows$Windows$Foundation.IAsyncAction,
getMessageAsync(
messageId: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Sms.ISmsMessage>,
getMessagesAsync(
messageFilter: Windows$Windows$Devices.Sms.SmsMessageFilter): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>, number>
} 
	declare export class SmsDeviceMessageStore mixins undefined.ISmsDeviceMessageStore {
maxMessages: number;
deleteMessageAsync(messageId: number): Windows$Windows$Foundation.IAsyncAction;
deleteMessagesAsync(
messageFilter: Windows$Windows$Devices.Sms.SmsMessageFilter): Windows$Windows$Foundation.IAsyncAction;
getMessageAsync(
messageId: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Sms.ISmsMessage>;
getMessagesAsync(
messageFilter: Windows$Windows$Devices.Sms.SmsMessageFilter): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>, number>
}
	declare export interface SmsEncodedLength {
segmentCount: number,
characterCountLastSegment: number,
charactersPerSegment: number,
byteCountLastSegment: number,
bytesPerSegment: number
} 
	declare export  class CellularClass {
  constructor(...args: empty): mixed;
static +none: Class<CellularClass__none> & CellularClass__none & 0;// 0
static +gsm: Class<CellularClass__gsm> & CellularClass__gsm & 1;// 1
static +cdma: Class<CellularClass__cdma> & CellularClass__cdma & 2;// 2

}

declare class CellularClass__none mixins CellularClass {}
declare class CellularClass__gsm mixins CellularClass {}
declare class CellularClass__cdma mixins CellularClass {}

	declare export  class SmsDeviceStatus {
  constructor(...args: empty): mixed;
static +off: Class<SmsDeviceStatus__off> & SmsDeviceStatus__off & 0;// 0
static +ready: Class<SmsDeviceStatus__ready> & SmsDeviceStatus__ready & 1;// 1
static +simNotInserted: Class<SmsDeviceStatus__simNotInserted> & SmsDeviceStatus__simNotInserted & 2;// 2
static +badSim: Class<SmsDeviceStatus__badSim> & SmsDeviceStatus__badSim & 3;// 3
static +deviceFailure: Class<SmsDeviceStatus__deviceFailure> & SmsDeviceStatus__deviceFailure & 4;// 4
static +subscriptionNotActivated: Class<SmsDeviceStatus__subscriptionNotActivated> & SmsDeviceStatus__subscriptionNotActivated & 5;// 5
static +deviceLocked: Class<SmsDeviceStatus__deviceLocked> & SmsDeviceStatus__deviceLocked & 6;// 6
static +deviceBlocked: Class<SmsDeviceStatus__deviceBlocked> & SmsDeviceStatus__deviceBlocked & 7;// 7

}

declare class SmsDeviceStatus__off mixins SmsDeviceStatus {}
declare class SmsDeviceStatus__ready mixins SmsDeviceStatus {}
declare class SmsDeviceStatus__simNotInserted mixins SmsDeviceStatus {}
declare class SmsDeviceStatus__badSim mixins SmsDeviceStatus {}
declare class SmsDeviceStatus__deviceFailure mixins SmsDeviceStatus {}
declare class SmsDeviceStatus__subscriptionNotActivated mixins SmsDeviceStatus {}
declare class SmsDeviceStatus__deviceLocked mixins SmsDeviceStatus {}
declare class SmsDeviceStatus__deviceBlocked mixins SmsDeviceStatus {}

	declare export class SendSmsMessageOperation mixins undefined.IAsyncAction, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncActionCompletedHandler;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(): void;
cancel(): void;
close(): void;
then<U>(
success?: () => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: () => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: () => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: () => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: () => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<any>,
getResults(): any
}
}
	declare export interface ISmsMessageReceivedEventArgs {
binaryMessage: Windows$Windows$Devices.Sms.SmsBinaryMessage,
textMessage: Windows$Windows$Devices.Sms.SmsTextMessage
} 
	declare export class SmsMessageReceivedEventArgs mixins undefined.ISmsMessageReceivedEventArgs {
binaryMessage: Windows$Windows$Devices.Sms.SmsBinaryMessage;
textMessage: Windows$Windows$Devices.Sms.SmsTextMessage
}
	declare export interface SmsMessageReceivedEventHandler {
(sender: Windows$Windows$Devices.Sms.SmsDevice, e: Windows$Windows$Devices.Sms.SmsMessageReceivedEventArgs): void
} 
	declare export class SmsDevice mixins undefined.ISmsDevice {
accountPhoneNumber: string;
cellularClass: Windows$Windows$Devices.Sms.CellularClass;
deviceStatus: Windows$Windows$Devices.Sms.SmsDeviceStatus;
messageStore: Windows$Windows$Devices.Sms.SmsDeviceMessageStore;
sendMessageAsync(
message: Windows$Windows$Devices.Sms.ISmsMessage): Windows$Windows$Devices.Sms.SendSmsMessageOperation;
calculateLength(
message: Windows$Windows$Devices.Sms.SmsTextMessage): Windows$Windows$Devices.Sms.SmsEncodedLength;
onsmsmessagereceived: any;
onsmsdevicestatuschanged: any;
static getDeviceSelector(): string;
static fromIdAsync(
deviceInstanceId: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Sms.SmsDevice>;
static getDefaultAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Sms.SmsDevice>
}
	declare export interface SmsDeviceStatusChangedEventHandler {
(sender: Windows$Windows$Devices.Sms.SmsDevice): void
} 
	declare export class GetSmsDeviceOperation mixins undefined.IAsyncOperation<Windows$Windows$Devices.Sms.SmsDevice>, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<Windows$Windows$Devices.Sms.SmsDevice>;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(): Windows$Windows$Devices.Sms.SmsDevice;
cancel(): void;
close(): void;
then<U>(
success?: (value: Windows$Windows$Devices.Sms.SmsDevice) => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Devices.Sms.SmsDevice) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: Windows$Windows$Devices.Sms.SmsDevice) => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Devices.Sms.SmsDevice) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: (value: Windows$Windows$Devices.Sms.SmsDevice) => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<Windows$Windows$Devices.Sms.SmsDevice>,
getResults(): Windows$Windows$Devices.Sms.SmsDevice
}
}
	declare export interface ISmsDeviceStatics {
getDeviceSelector(): string,
fromIdAsync(
deviceInstanceId: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Sms.SmsDevice>,
getDefaultAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Sms.SmsDevice>
} 
	declare export interface ISmsDevice {
accountPhoneNumber: string,
cellularClass: Windows$Windows$Devices.Sms.CellularClass,
deviceStatus: Windows$Windows$Devices.Sms.SmsDeviceStatus,
messageStore: Windows$Windows$Devices.Sms.SmsDeviceMessageStore,
sendMessageAsync(
message: Windows$Windows$Devices.Sms.ISmsMessage): Windows$Windows$Devices.Sms.SendSmsMessageOperation,
calculateLength(
message: Windows$Windows$Devices.Sms.SmsTextMessage): Windows$Windows$Devices.Sms.SmsEncodedLength,
onsmsmessagereceived: any,
onsmsdevicestatuschanged: any
} 
	declare export interface ISmsReceivedEventDetails {
deviceId: string,
messageIndex: number
} 
	declare export class SmsReceivedEventDetails mixins undefined.ISmsReceivedEventDetails {
deviceId: string;
messageIndex: number
}
    }

	declare module 'Enumeration' {
        declare export  class DeviceClass {
  constructor(...args: empty): mixed;
static +all: Class<DeviceClass__all> & DeviceClass__all & 0;// 0
static +audioCapture: Class<DeviceClass__audioCapture> & DeviceClass__audioCapture & 1;// 1
static +audioRender: Class<DeviceClass__audioRender> & DeviceClass__audioRender & 2;// 2
static +portableStorageDevice: Class<DeviceClass__portableStorageDevice> & DeviceClass__portableStorageDevice & 3;// 3
static +videoCapture: Class<DeviceClass__videoCapture> & DeviceClass__videoCapture & 4;// 4

}

declare class DeviceClass__all mixins DeviceClass {}
declare class DeviceClass__audioCapture mixins DeviceClass {}
declare class DeviceClass__audioRender mixins DeviceClass {}
declare class DeviceClass__portableStorageDevice mixins DeviceClass {}
declare class DeviceClass__videoCapture mixins DeviceClass {}

	declare export  class DeviceWatcherStatus {
  constructor(...args: empty): mixed;
static +created: Class<DeviceWatcherStatus__created> & DeviceWatcherStatus__created & 0;// 0
static +started: Class<DeviceWatcherStatus__started> & DeviceWatcherStatus__started & 1;// 1
static +enumerationCompleted: Class<DeviceWatcherStatus__enumerationCompleted> & DeviceWatcherStatus__enumerationCompleted & 2;// 2
static +stopping: Class<DeviceWatcherStatus__stopping> & DeviceWatcherStatus__stopping & 3;// 3
static +stopped: Class<DeviceWatcherStatus__stopped> & DeviceWatcherStatus__stopped & 4;// 4
static +aborted: Class<DeviceWatcherStatus__aborted> & DeviceWatcherStatus__aborted & 5;// 5

}

declare class DeviceWatcherStatus__created mixins DeviceWatcherStatus {}
declare class DeviceWatcherStatus__started mixins DeviceWatcherStatus {}
declare class DeviceWatcherStatus__enumerationCompleted mixins DeviceWatcherStatus {}
declare class DeviceWatcherStatus__stopping mixins DeviceWatcherStatus {}
declare class DeviceWatcherStatus__stopped mixins DeviceWatcherStatus {}
declare class DeviceWatcherStatus__aborted mixins DeviceWatcherStatus {}

	declare export class DeviceThumbnail mixins undefined.IRandomAccessStreamWithContentType, undefined.IRandomAccessStream, undefined.IClosable, undefined.IInputStream, undefined.IOutputStream, undefined.IContentTypeProvider {
canRead: boolean;
canWrite: boolean;
position: number;
size: number;
contentType: string;
getInputStreamAt(position: number): Windows$Windows$Storage.Streams.IInputStream;
getOutputStreamAt(position: number): Windows$Windows$Storage.Streams.IOutputStream;
seek(position: number): void;
cloneStream(): Windows$Windows$Storage.Streams.IRandomAccessStream;
dispose(): void;
readAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer,
count: number,
options: Windows$Windows$Storage.Streams.InputStreamOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Storage.Streams.IBuffer, number>;
writeAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
flushAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
close(): void
}
	declare export  class Panel {
  constructor(...args: empty): mixed;
static +unknown: Class<Panel__unknown> & Panel__unknown & 0;// 0
static +front: Class<Panel__front> & Panel__front & 1;// 1
static +back: Class<Panel__back> & Panel__back & 2;// 2
static +top: Class<Panel__top> & Panel__top & 3;// 3
static +bottom: Class<Panel__bottom> & Panel__bottom & 4;// 4
static +left: Class<Panel__left> & Panel__left & 5;// 5
static +right: Class<Panel__right> & Panel__right & 6;// 6

}

declare class Panel__unknown mixins Panel {}
declare class Panel__front mixins Panel {}
declare class Panel__back mixins Panel {}
declare class Panel__top mixins Panel {}
declare class Panel__bottom mixins Panel {}
declare class Panel__left mixins Panel {}
declare class Panel__right mixins Panel {}

	declare export interface IEnclosureLocation {
inDock: boolean,
inLid: boolean,
panel: Windows$Windows$Devices.Enumeration.Panel
} 
	declare export class EnclosureLocation mixins undefined.IEnclosureLocation {
inDock: boolean;
inLid: boolean;
panel: Windows$Windows$Devices.Enumeration.Panel
}
	declare export interface IDeviceInformationUpdate {
id: string,
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>
} 
	declare export class DeviceInformationUpdate mixins undefined.IDeviceInformationUpdate {
id: string;
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>
}
	declare export class DeviceInformationCollection mixins undefined.IVectorView<Windows$Windows$Devices.Enumeration.DeviceInformation>, undefined.IIterable<Windows$Windows$Devices.Enumeration.DeviceInformation> {
size: number;
getAt(index: number): Windows$Windows$Devices.Enumeration.DeviceInformation;
indexOf(
value: Windows$Windows$Devices.Enumeration.DeviceInformation): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$Devices.Enumeration.DeviceInformation[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Devices.Enumeration.DeviceInformation>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$Devices.Enumeration.DeviceInformation[][]): Windows$Windows$Devices.Enumeration.DeviceInformation[];
join(seperator: string): string;
pop(): Windows$Windows$Devices.Enumeration.DeviceInformation;
push(...items: Windows$Windows$Devices.Enumeration.DeviceInformation[]): void;
reverse(): Windows$Windows$Devices.Enumeration.DeviceInformation[];
shift(): Windows$Windows$Devices.Enumeration.DeviceInformation;
slice(start: number): Windows$Windows$Devices.Enumeration.DeviceInformation[];
slice(
start: number,
end: number): Windows$Windows$Devices.Enumeration.DeviceInformation[];
sort(): Windows$Windows$Devices.Enumeration.DeviceInformation[];
sort(
compareFn: (
a: Windows$Windows$Devices.Enumeration.DeviceInformation,
b: Windows$Windows$Devices.Enumeration.DeviceInformation) => number): Windows$Windows$Devices.Enumeration.DeviceInformation[];
splice(start: number): Windows$Windows$Devices.Enumeration.DeviceInformation[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$Devices.Enumeration.DeviceInformation[]): Windows$Windows$Devices.Enumeration.DeviceInformation[];
unshift(...items: Windows$Windows$Devices.Enumeration.DeviceInformation[]): number;
lastIndexOf(searchElement: Windows$Windows$Devices.Enumeration.DeviceInformation): number;
lastIndexOf(
searchElement: Windows$Windows$Devices.Enumeration.DeviceInformation,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => boolean): Windows$Windows$Devices.Enumeration.DeviceInformation[];
filter(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => boolean,
thisArg: any): Windows$Windows$Devices.Enumeration.DeviceInformation[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => any,
initialValue: any): any;
length: number
}
	declare export interface IDeviceWatcher {
status: Windows$Windows$Devices.Enumeration.DeviceWatcherStatus,
onadded: any,
onupdated: any,
onremoved: any,
onenumerationcompleted: any,
onstopped: any,
start(): void,
stop(): void
} 
	declare export class DeviceWatcher mixins undefined.IDeviceWatcher {
status: Windows$Windows$Devices.Enumeration.DeviceWatcherStatus;
onadded: any;
onupdated: any;
onremoved: any;
onenumerationcompleted: any;
onstopped: any;
start(): void;
stop(): void
}
	declare export class DeviceInformation mixins undefined.IDeviceInformation {
enclosureLocation: Windows$Windows$Devices.Enumeration.EnclosureLocation;
id: string;
isDefault: boolean;
isEnabled: boolean;
name: string;
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>;
update(updateInfo: Windows$Windows$Devices.Enumeration.DeviceInformationUpdate): void;
getThumbnailAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceThumbnail>;
getGlyphThumbnailAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceThumbnail>;
static createFromIdAsync(
id: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformation>;
static createFromIdAsync(
id: string,
additionalProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformation>;
static findAllAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>;
static findAllAsync(
deviceClass: Windows$Windows$Devices.Enumeration.DeviceClass): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>;
static findAllAsync(
aqsFilter: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>;
static findAllAsync(
aqsFilter: string,
additionalProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>;
static createWatcher(): Windows$Windows$Devices.Enumeration.DeviceWatcher;
static createWatcher(
deviceClass: Windows$Windows$Devices.Enumeration.DeviceClass): Windows$Windows$Devices.Enumeration.DeviceWatcher;
static createWatcher(aqsFilter: string): Windows$Windows$Devices.Enumeration.DeviceWatcher;
static createWatcher(
aqsFilter: string,
additionalProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Devices.Enumeration.DeviceWatcher
}
	declare export interface IDeviceInformationStatics {
createFromIdAsync(
id: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformation>,
createFromIdAsync(
id: string,
additionalProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformation>,
findAllAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>,
findAllAsync(
deviceClass: Windows$Windows$Devices.Enumeration.DeviceClass): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>,
findAllAsync(
aqsFilter: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>,
findAllAsync(
aqsFilter: string,
additionalProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>,
createWatcher(): Windows$Windows$Devices.Enumeration.DeviceWatcher,
createWatcher(
deviceClass: Windows$Windows$Devices.Enumeration.DeviceClass): Windows$Windows$Devices.Enumeration.DeviceWatcher,
createWatcher(aqsFilter: string): Windows$Windows$Devices.Enumeration.DeviceWatcher,
createWatcher(
aqsFilter: string,
additionalProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Devices.Enumeration.DeviceWatcher
} 
	declare export interface IDeviceInformation {
enclosureLocation: Windows$Windows$Devices.Enumeration.EnclosureLocation,
id: string,
isDefault: boolean,
isEnabled: boolean,
name: string,
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>,
update(updateInfo: Windows$Windows$Devices.Enumeration.DeviceInformationUpdate): void,
getThumbnailAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceThumbnail>,
getGlyphThumbnailAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceThumbnail>
} 
	declare module 'Pnp' {
        declare export  class PnpObjectType {
  constructor(...args: empty): mixed;
static +unknown: Class<PnpObjectType__unknown> & PnpObjectType__unknown & 0;// 0
static +deviceInterface: Class<PnpObjectType__deviceInterface> & PnpObjectType__deviceInterface & 1;// 1
static +deviceContainer: Class<PnpObjectType__deviceContainer> & PnpObjectType__deviceContainer & 2;// 2
static +device: Class<PnpObjectType__device> & PnpObjectType__device & 3;// 3
static +deviceInterfaceClass: Class<PnpObjectType__deviceInterfaceClass> & PnpObjectType__deviceInterfaceClass & 4;// 4

}

declare class PnpObjectType__unknown mixins PnpObjectType {}
declare class PnpObjectType__deviceInterface mixins PnpObjectType {}
declare class PnpObjectType__deviceContainer mixins PnpObjectType {}
declare class PnpObjectType__device mixins PnpObjectType {}
declare class PnpObjectType__deviceInterfaceClass mixins PnpObjectType {}

	declare export interface IPnpObjectUpdate {
id: string,
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>,
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType
} 
	declare export class PnpObjectUpdate mixins undefined.IPnpObjectUpdate {
id: string;
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>;
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType
}
	declare export class PnpObjectCollection mixins undefined.IVectorView<Windows$Windows$Devices.Enumeration.Pnp.PnpObject>, undefined.IIterable<Windows$Windows$Devices.Enumeration.Pnp.PnpObject> {
size: number;
getAt(index: number): Windows$Windows$Devices.Enumeration.Pnp.PnpObject;
indexOf(
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Devices.Enumeration.Pnp.PnpObject>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[][]): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
join(seperator: string): string;
pop(): Windows$Windows$Devices.Enumeration.Pnp.PnpObject;
push(...items: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]): void;
reverse(): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
shift(): Windows$Windows$Devices.Enumeration.Pnp.PnpObject;
slice(start: number): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
slice(
start: number,
end: number): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
sort(): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
sort(
compareFn: (
a: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
b: Windows$Windows$Devices.Enumeration.Pnp.PnpObject) => number): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
splice(start: number): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
unshift(...items: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]): number;
lastIndexOf(searchElement: Windows$Windows$Devices.Enumeration.Pnp.PnpObject): number;
lastIndexOf(
searchElement: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => boolean): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
filter(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => boolean,
thisArg: any): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => any,
initialValue: any): any;
length: number
}
	declare export interface IPnpObjectWatcher {
status: Windows$Windows$Devices.Enumeration.DeviceWatcherStatus,
onadded: any,
onupdated: any,
onremoved: any,
onenumerationcompleted: any,
onstopped: any,
start(): void,
stop(): void
} 
	declare export class PnpObjectWatcher mixins undefined.IPnpObjectWatcher {
status: Windows$Windows$Devices.Enumeration.DeviceWatcherStatus;
onadded: any;
onupdated: any;
onremoved: any;
onenumerationcompleted: any;
onstopped: any;
start(): void;
stop(): void
}
	declare export class PnpObject mixins undefined.IPnpObject {
id: string;
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>;
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType;
update(updateInfo: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectUpdate): void;
static createFromIdAsync(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
id: string,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.Pnp.PnpObject>;
static findAllAsync(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.Pnp.PnpObjectCollection>;
static findAllAsync(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>,
aqsFilter: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.Pnp.PnpObjectCollection>;
static createWatcher(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Devices.Enumeration.Pnp.PnpObjectWatcher;
static createWatcher(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>,
aqsFilter: string): Windows$Windows$Devices.Enumeration.Pnp.PnpObjectWatcher
}
	declare export interface IPnpObjectStatics {
createFromIdAsync(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
id: string,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.Pnp.PnpObject>,
findAllAsync(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.Pnp.PnpObjectCollection>,
findAllAsync(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>,
aqsFilter: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.Pnp.PnpObjectCollection>,
createWatcher(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Devices.Enumeration.Pnp.PnpObjectWatcher,
createWatcher(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>,
aqsFilter: string): Windows$Windows$Devices.Enumeration.Pnp.PnpObjectWatcher
} 
	declare export interface IPnpObject {
id: string,
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>,
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
update(updateInfo: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectUpdate): void
} 
    }

    }

	declare module 'Geolocation' {
        declare export  class PositionAccuracy {
  constructor(...args: empty): mixed;
static +default: Class<PositionAccuracy__default> & PositionAccuracy__default & 0;// 0
static +high: Class<PositionAccuracy__high> & PositionAccuracy__high & 1;// 1

}

declare class PositionAccuracy__default mixins PositionAccuracy {}
declare class PositionAccuracy__high mixins PositionAccuracy {}

	declare export  class PositionStatus {
  constructor(...args: empty): mixed;
static +ready: Class<PositionStatus__ready> & PositionStatus__ready & 0;// 0
static +initializing: Class<PositionStatus__initializing> & PositionStatus__initializing & 1;// 1
static +noData: Class<PositionStatus__noData> & PositionStatus__noData & 2;// 2
static +disabled: Class<PositionStatus__disabled> & PositionStatus__disabled & 3;// 3
static +notInitialized: Class<PositionStatus__notInitialized> & PositionStatus__notInitialized & 4;// 4
static +notAvailable: Class<PositionStatus__notAvailable> & PositionStatus__notAvailable & 5;// 5

}

declare class PositionStatus__ready mixins PositionStatus {}
declare class PositionStatus__initializing mixins PositionStatus {}
declare class PositionStatus__noData mixins PositionStatus {}
declare class PositionStatus__disabled mixins PositionStatus {}
declare class PositionStatus__notInitialized mixins PositionStatus {}
declare class PositionStatus__notAvailable mixins PositionStatus {}

	declare export interface IGeocoordinate {
accuracy: number,
altitude: number,
altitudeAccuracy: number,
heading: number,
latitude: number,
longitude: number,
speed: number,
timestamp: Date
} 
	declare export class Geocoordinate mixins undefined.IGeocoordinate {
accuracy: number;
altitude: number;
altitudeAccuracy: number;
heading: number;
latitude: number;
longitude: number;
speed: number;
timestamp: Date
}
	declare export interface ICivicAddress {
city: string,
country: string,
postalCode: string,
state: string,
timestamp: Date
} 
	declare export class CivicAddress mixins undefined.ICivicAddress {
city: string;
country: string;
postalCode: string;
state: string;
timestamp: Date
}
	declare export interface IGeoposition {
civicAddress: Windows$Windows$Devices.Geolocation.CivicAddress,
coordinate: Windows$Windows$Devices.Geolocation.Geocoordinate
} 
	declare export class Geoposition mixins undefined.IGeoposition {
civicAddress: Windows$Windows$Devices.Geolocation.CivicAddress;
coordinate: Windows$Windows$Devices.Geolocation.Geocoordinate
}
	declare export interface IPositionChangedEventArgs {
position: Windows$Windows$Devices.Geolocation.Geoposition
} 
	declare export class PositionChangedEventArgs mixins undefined.IPositionChangedEventArgs {
position: Windows$Windows$Devices.Geolocation.Geoposition
}
	declare export interface IStatusChangedEventArgs {
status: Windows$Windows$Devices.Geolocation.PositionStatus
} 
	declare export class StatusChangedEventArgs mixins undefined.IStatusChangedEventArgs {
status: Windows$Windows$Devices.Geolocation.PositionStatus
}
	declare export interface IGeolocator {
desiredAccuracy: Windows$Windows$Devices.Geolocation.PositionAccuracy,
locationStatus: Windows$Windows$Devices.Geolocation.PositionStatus,
movementThreshold: number,
reportInterval: number,
getGeopositionAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Geolocation.Geoposition>,
getGeopositionAsync(
maximumAge: number,
timeout: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Geolocation.Geoposition>,
onpositionchanged: any,
onstatuschanged: any
} 
	declare export class Geolocator mixins undefined.IGeolocator {
desiredAccuracy: Windows$Windows$Devices.Geolocation.PositionAccuracy;
locationStatus: Windows$Windows$Devices.Geolocation.PositionStatus;
movementThreshold: number;
reportInterval: number;
getGeopositionAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Geolocation.Geoposition>;
getGeopositionAsync(
maximumAge: number,
timeout: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Geolocation.Geoposition>;
onpositionchanged: any;
onstatuschanged: any
}
    }

	declare module 'Input' {
        declare export  class PointerDeviceType {
  constructor(...args: empty): mixed;
static +touch: Class<PointerDeviceType__touch> & PointerDeviceType__touch & 0;// 0
static +pen: Class<PointerDeviceType__pen> & PointerDeviceType__pen & 1;// 1
static +mouse: Class<PointerDeviceType__mouse> & PointerDeviceType__mouse & 2;// 2

}

declare class PointerDeviceType__touch mixins PointerDeviceType {}
declare class PointerDeviceType__pen mixins PointerDeviceType {}
declare class PointerDeviceType__mouse mixins PointerDeviceType {}

	declare export interface PointerDeviceUsage {
usagePage: number,
usage: number,
minLogical: number,
maxLogical: number,
minPhysical: number,
maxPhysical: number,
unit: number,
physicalMultiplier: number
} 
	declare export interface MouseDelta {
x: number,
y: number
} 
	declare export interface IMouseCapabilities {
horizontalWheelPresent: number,
mousePresent: number,
numberOfButtons: number,
swapButtons: number,
verticalWheelPresent: number
} 
	declare export interface IKeyboardCapabilities {
keyboardPresent: number
} 
	declare export interface ITouchCapabilities {
contacts: number,
touchPresent: number
} 
	declare export interface IPointerDeviceStatics {
getPointerDevice(pointerId: number): Windows$Windows$Devices.Input.PointerDevice,
getPointerDevices(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDevice>
} 
	declare export class PointerDevice mixins undefined.IPointerDevice {
isIntegrated: boolean;
maxContacts: number;
physicalDeviceRect: Windows$Windows$Foundation.Rect;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
screenRect: Windows$Windows$Foundation.Rect;
supportedUsages: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDeviceUsage>;
static getPointerDevice(pointerId: number): Windows$Windows$Devices.Input.PointerDevice;
static getPointerDevices(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDevice>
}
	declare export interface IPointerDevice {
isIntegrated: boolean,
maxContacts: number,
physicalDeviceRect: Windows$Windows$Foundation.Rect,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
screenRect: Windows$Windows$Foundation.Rect,
supportedUsages: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDeviceUsage>
} 
	declare export interface IMouseEventArgs {
mouseDelta: Windows$Windows$Devices.Input.MouseDelta
} 
	declare export interface IMouseDevice {
onmousemoved: any
} 
	declare export class MouseDevice mixins undefined.IMouseDevice {
onmousemoved: any;
static getForCurrentView(): Windows$Windows$Devices.Input.MouseDevice
}
	declare export class MouseEventArgs mixins undefined.IMouseEventArgs {
mouseDelta: Windows$Windows$Devices.Input.MouseDelta
}
	declare export interface IMouseDeviceStatics {
getForCurrentView(): Windows$Windows$Devices.Input.MouseDevice
} 
	declare export class MouseCapabilities mixins undefined.IMouseCapabilities {
horizontalWheelPresent: number;
mousePresent: number;
numberOfButtons: number;
swapButtons: number;
verticalWheelPresent: number
}
	declare export class KeyboardCapabilities mixins undefined.IKeyboardCapabilities {
keyboardPresent: number
}
	declare export class TouchCapabilities mixins undefined.ITouchCapabilities {
contacts: number;
touchPresent: number
}
	declare export  class EdgeGestureKind {
  constructor(...args: empty): mixed;
static +touch: Class<EdgeGestureKind__touch> & EdgeGestureKind__touch & 0;// 0
static +keyboard: Class<EdgeGestureKind__keyboard> & EdgeGestureKind__keyboard & 1;// 1
static +mouse: Class<EdgeGestureKind__mouse> & EdgeGestureKind__mouse & 2;// 2

}

declare class EdgeGestureKind__touch mixins EdgeGestureKind {}
declare class EdgeGestureKind__keyboard mixins EdgeGestureKind {}
declare class EdgeGestureKind__mouse mixins EdgeGestureKind {}

	declare export interface IEdgeGestureEventArgs {
kind: Windows$Windows$UI.Input.EdgeGestureKind
} 
	declare export class EdgeGestureEventArgs mixins undefined.IEdgeGestureEventArgs {
kind: Windows$Windows$UI.Input.EdgeGestureKind
}
	declare export interface IEdgeGestureStatics {
getForCurrentView(): Windows$Windows$UI.Input.EdgeGesture
} 
	declare export class EdgeGesture mixins undefined.IEdgeGesture {
onstarting: any;
oncompleted: any;
oncanceled: any;
static getForCurrentView(): Windows$Windows$UI.Input.EdgeGesture
}
	declare export interface IEdgeGesture {
onstarting: any,
oncompleted: any,
oncanceled: any
} 
	declare export  class HoldingState {
  constructor(...args: empty): mixed;
static +started: Class<HoldingState__started> & HoldingState__started & 0;// 0
static +completed: Class<HoldingState__completed> & HoldingState__completed & 1;// 1
static +canceled: Class<HoldingState__canceled> & HoldingState__canceled & 2;// 2

}

declare class HoldingState__started mixins HoldingState {}
declare class HoldingState__completed mixins HoldingState {}
declare class HoldingState__canceled mixins HoldingState {}

	declare export  class DraggingState {
  constructor(...args: empty): mixed;
static +started: Class<DraggingState__started> & DraggingState__started & 0;// 0
static +continuing: Class<DraggingState__continuing> & DraggingState__continuing & 1;// 1
static +completed: Class<DraggingState__completed> & DraggingState__completed & 2;// 2

}

declare class DraggingState__started mixins DraggingState {}
declare class DraggingState__continuing mixins DraggingState {}
declare class DraggingState__completed mixins DraggingState {}

	declare export  class CrossSlidingState {
  constructor(...args: empty): mixed;
static +started: Class<CrossSlidingState__started> & CrossSlidingState__started & 0;// 0
static +dragging: Class<CrossSlidingState__dragging> & CrossSlidingState__dragging & 1;// 1
static +selecting: Class<CrossSlidingState__selecting> & CrossSlidingState__selecting & 2;// 2
static +selectSpeedBumping: Class<CrossSlidingState__selectSpeedBumping> & CrossSlidingState__selectSpeedBumping & 3;// 3
static +speedBumping: Class<CrossSlidingState__speedBumping> & CrossSlidingState__speedBumping & 4;// 4
static +rearranging: Class<CrossSlidingState__rearranging> & CrossSlidingState__rearranging & 5;// 5
static +completed: Class<CrossSlidingState__completed> & CrossSlidingState__completed & 6;// 6

}

declare class CrossSlidingState__started mixins CrossSlidingState {}
declare class CrossSlidingState__dragging mixins CrossSlidingState {}
declare class CrossSlidingState__selecting mixins CrossSlidingState {}
declare class CrossSlidingState__selectSpeedBumping mixins CrossSlidingState {}
declare class CrossSlidingState__speedBumping mixins CrossSlidingState {}
declare class CrossSlidingState__rearranging mixins CrossSlidingState {}
declare class CrossSlidingState__completed mixins CrossSlidingState {}

	declare export  class GestureSettings {
  constructor(...args: empty): mixed;
static +none: Class<GestureSettings__none> & GestureSettings__none & 0;// 0
static +tap: Class<GestureSettings__tap> & GestureSettings__tap & 1;// 1
static +doubleTap: Class<GestureSettings__doubleTap> & GestureSettings__doubleTap & 2;// 2
static +hold: Class<GestureSettings__hold> & GestureSettings__hold & 3;// 3
static +holdWithMouse: Class<GestureSettings__holdWithMouse> & GestureSettings__holdWithMouse & 4;// 4
static +rightTap: Class<GestureSettings__rightTap> & GestureSettings__rightTap & 5;// 5
static +drag: Class<GestureSettings__drag> & GestureSettings__drag & 6;// 6
static +manipulationTranslateX: Class<GestureSettings__manipulationTranslateX> & GestureSettings__manipulationTranslateX & 7;// 7
static +manipulationTranslateY: Class<GestureSettings__manipulationTranslateY> & GestureSettings__manipulationTranslateY & 8;// 8
static +manipulationTranslateRailsX: Class<GestureSettings__manipulationTranslateRailsX> & GestureSettings__manipulationTranslateRailsX & 9;// 9
static +manipulationTranslateRailsY: Class<GestureSettings__manipulationTranslateRailsY> & GestureSettings__manipulationTranslateRailsY & 10;// 10
static +manipulationRotate: Class<GestureSettings__manipulationRotate> & GestureSettings__manipulationRotate & 11;// 11
static +manipulationScale: Class<GestureSettings__manipulationScale> & GestureSettings__manipulationScale & 12;// 12
static +manipulationTranslateInertia: Class<GestureSettings__manipulationTranslateInertia> & GestureSettings__manipulationTranslateInertia & 13;// 13
static +manipulationRotateInertia: Class<GestureSettings__manipulationRotateInertia> & GestureSettings__manipulationRotateInertia & 14;// 14
static +manipulationScaleInertia: Class<GestureSettings__manipulationScaleInertia> & GestureSettings__manipulationScaleInertia & 15;// 15
static +crossSlide: Class<GestureSettings__crossSlide> & GestureSettings__crossSlide & 16;// 16

}

declare class GestureSettings__none mixins GestureSettings {}
declare class GestureSettings__tap mixins GestureSettings {}
declare class GestureSettings__doubleTap mixins GestureSettings {}
declare class GestureSettings__hold mixins GestureSettings {}
declare class GestureSettings__holdWithMouse mixins GestureSettings {}
declare class GestureSettings__rightTap mixins GestureSettings {}
declare class GestureSettings__drag mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateX mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateY mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateRailsX mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateRailsY mixins GestureSettings {}
declare class GestureSettings__manipulationRotate mixins GestureSettings {}
declare class GestureSettings__manipulationScale mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateInertia mixins GestureSettings {}
declare class GestureSettings__manipulationRotateInertia mixins GestureSettings {}
declare class GestureSettings__manipulationScaleInertia mixins GestureSettings {}
declare class GestureSettings__crossSlide mixins GestureSettings {}

	declare export interface ManipulationDelta {
translation: Windows$Windows$Foundation.Point,
scale: number,
rotation: number,
expansion: number
} 
	declare export interface ManipulationVelocities {
linear: Windows$Windows$Foundation.Point,
angular: number,
expansion: number
} 
	declare export interface CrossSlideThresholds {
selectionStart: number,
speedBumpStart: number,
speedBumpEnd: number,
rearrangeStart: number
} 
	declare export interface ITappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
tapCount: number
} 
	declare export interface IRightTappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IHoldingEventArgs {
holdingState: Windows$Windows$UI.Input.HoldingState,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IDraggingEventArgs {
draggingState: Windows$Windows$UI.Input.DraggingState,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IManipulationStartedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IManipulationUpdatedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
delta: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
velocities: Windows$Windows$UI.Input.ManipulationVelocities
} 
	declare export interface IManipulationInertiaStartingEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
delta: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
velocities: Windows$Windows$UI.Input.ManipulationVelocities
} 
	declare export interface IManipulationCompletedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
velocities: Windows$Windows$UI.Input.ManipulationVelocities
} 
	declare export interface ICrossSlidingEventArgs {
crossSlidingState: Windows$Windows$UI.Input.CrossSlidingState,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IMouseWheelParameters {
charTranslation: Windows$Windows$Foundation.Point,
deltaRotationAngle: number,
deltaScale: number,
pageTranslation: Windows$Windows$Foundation.Point
} 
	declare export interface IGestureRecognizer {
autoProcessInertia: boolean,
crossSlideExact: boolean,
crossSlideHorizontally: boolean,
crossSlideThresholds: Windows$Windows$UI.Input.CrossSlideThresholds,
gestureSettings: Windows$Windows$UI.Input.GestureSettings,
inertiaExpansion: number,
inertiaExpansionDeceleration: number,
inertiaRotationAngle: number,
inertiaRotationDeceleration: number,
inertiaTranslationDeceleration: number,
inertiaTranslationDisplacement: number,
isActive: boolean,
isInertial: boolean,
manipulationExact: boolean,
mouseWheelParameters: Windows$Windows$UI.Input.MouseWheelParameters,
pivotCenter: Windows$Windows$Foundation.Point,
pivotRadius: number,
showGestureFeedback: boolean,
canBeDoubleTap(value: Windows$Windows$UI.Input.PointerPoint): boolean,
processDownEvent(value: Windows$Windows$UI.Input.PointerPoint): void,
processMoveEvents(
value: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>): void,
processUpEvent(value: Windows$Windows$UI.Input.PointerPoint): void,
processMouseWheelEvent(
value: Windows$Windows$UI.Input.PointerPoint,
isShiftKeyDown: boolean,
isControlKeyDown: boolean): void,
processInertia(): void,
completeGesture(): void,
ontapped: any,
onrighttapped: any,
onholding: any,
ondragging: any,
onmanipulationstarted: any,
onmanipulationupdated: any,
onmanipulationinertiastarting: any,
onmanipulationcompleted: any,
oncrosssliding: any
} 
	declare export class MouseWheelParameters mixins undefined.IMouseWheelParameters {
charTranslation: Windows$Windows$Foundation.Point;
deltaRotationAngle: number;
deltaScale: number;
pageTranslation: Windows$Windows$Foundation.Point
}
	declare export class GestureRecognizer mixins undefined.IGestureRecognizer {
autoProcessInertia: boolean;
crossSlideExact: boolean;
crossSlideHorizontally: boolean;
crossSlideThresholds: Windows$Windows$UI.Input.CrossSlideThresholds;
gestureSettings: Windows$Windows$UI.Input.GestureSettings;
inertiaExpansion: number;
inertiaExpansionDeceleration: number;
inertiaRotationAngle: number;
inertiaRotationDeceleration: number;
inertiaTranslationDeceleration: number;
inertiaTranslationDisplacement: number;
isActive: boolean;
isInertial: boolean;
manipulationExact: boolean;
mouseWheelParameters: Windows$Windows$UI.Input.MouseWheelParameters;
pivotCenter: Windows$Windows$Foundation.Point;
pivotRadius: number;
showGestureFeedback: boolean;
canBeDoubleTap(value: Windows$Windows$UI.Input.PointerPoint): boolean;
processDownEvent(value: Windows$Windows$UI.Input.PointerPoint): void;
processMoveEvents(
value: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>): void;
processUpEvent(value: Windows$Windows$UI.Input.PointerPoint): void;
processMouseWheelEvent(
value: Windows$Windows$UI.Input.PointerPoint,
isShiftKeyDown: boolean,
isControlKeyDown: boolean): void;
processInertia(): void;
completeGesture(): void;
ontapped: any;
onrighttapped: any;
onholding: any;
ondragging: any;
onmanipulationstarted: any;
onmanipulationupdated: any;
onmanipulationinertiastarting: any;
onmanipulationcompleted: any;
oncrosssliding: any
}
	declare export class TappedEventArgs mixins undefined.ITappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
tapCount: number
}
	declare export class RightTappedEventArgs mixins undefined.IRightTappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class HoldingEventArgs mixins undefined.IHoldingEventArgs {
holdingState: Windows$Windows$UI.Input.HoldingState;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class DraggingEventArgs mixins undefined.IDraggingEventArgs {
draggingState: Windows$Windows$UI.Input.DraggingState;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class ManipulationStartedEventArgs mixins undefined.IManipulationStartedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class ManipulationUpdatedEventArgs mixins undefined.IManipulationUpdatedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
delta: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
velocities: Windows$Windows$UI.Input.ManipulationVelocities
}
	declare export class ManipulationInertiaStartingEventArgs mixins undefined.IManipulationInertiaStartingEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
delta: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
velocities: Windows$Windows$UI.Input.ManipulationVelocities
}
	declare export class ManipulationCompletedEventArgs mixins undefined.IManipulationCompletedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
velocities: Windows$Windows$UI.Input.ManipulationVelocities
}
	declare export class CrossSlidingEventArgs mixins undefined.ICrossSlidingEventArgs {
crossSlidingState: Windows$Windows$UI.Input.CrossSlidingState;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export interface IPointerPointStatics {
getCurrentPoint(pointerId: number): Windows$Windows$UI.Input.PointerPoint,
getIntermediatePoints(
pointerId: number): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>,
getCurrentPoint(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$UI.Input.PointerPoint,
getIntermediatePoints(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
} 
	declare export class PointerPoint mixins undefined.IPointerPoint {
frameId: number;
isInContact: boolean;
pointerDevice: Windows$Windows$Devices.Input.PointerDevice;
pointerId: number;
position: Windows$Windows$Foundation.Point;
properties: Windows$Windows$UI.Input.PointerPointProperties;
rawPosition: Windows$Windows$Foundation.Point;
timestamp: number;
static getCurrentPoint(pointerId: number): Windows$Windows$UI.Input.PointerPoint;
static getIntermediatePoints(
pointerId: number): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>;
static getCurrentPoint(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$UI.Input.PointerPoint;
static getIntermediatePoints(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
}
	declare export interface IPointerPointTransform {
inverse: Windows$Windows$UI.Input.IPointerPointTransform,
tryTransform(
inPoint: Windows$Windows$Foundation.Point): {
outPoint: Windows$Windows$Foundation.Point,
returnValue: boolean
},
transformBounds(rect: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.Rect
} 
	declare export interface IPointerPoint {
frameId: number,
isInContact: boolean,
pointerDevice: Windows$Windows$Devices.Input.PointerDevice,
pointerId: number,
position: Windows$Windows$Foundation.Point,
properties: Windows$Windows$UI.Input.PointerPointProperties,
rawPosition: Windows$Windows$Foundation.Point,
timestamp: number
} 
	declare export class PointerPointProperties mixins undefined.IPointerPointProperties {
contactRect: Windows$Windows$Foundation.Rect;
contactRectRaw: Windows$Windows$Foundation.Rect;
isBarrelButtonPressed: boolean;
isCanceled: boolean;
isEraser: boolean;
isHorizontalMouseWheel: boolean;
isInRange: boolean;
isInverted: boolean;
isLeftButtonPressed: boolean;
isMiddleButtonPressed: boolean;
isPrimary: boolean;
isRightButtonPressed: boolean;
isXButton1Pressed: boolean;
isXButton2Pressed: boolean;
mouseWheelDelta: number;
orientation: number;
pointerUpdateKind: Windows$Windows$UI.Input.PointerUpdateKind;
pressure: number;
touchConfidence: boolean;
twist: number;
xTilt: number;
yTilt: number;
hasUsage(usagePage: number, usageId: number): boolean;
getUsageValue(usagePage: number, usageId: number): number
}
	declare export  class PointerUpdateKind {
  constructor(...args: empty): mixed;
static +other: Class<PointerUpdateKind__other> & PointerUpdateKind__other & 0;// 0
static +leftButtonPressed: Class<PointerUpdateKind__leftButtonPressed> & PointerUpdateKind__leftButtonPressed & 1;// 1
static +leftButtonReleased: Class<PointerUpdateKind__leftButtonReleased> & PointerUpdateKind__leftButtonReleased & 2;// 2
static +rightButtonPressed: Class<PointerUpdateKind__rightButtonPressed> & PointerUpdateKind__rightButtonPressed & 3;// 3
static +rightButtonReleased: Class<PointerUpdateKind__rightButtonReleased> & PointerUpdateKind__rightButtonReleased & 4;// 4
static +middleButtonPressed: Class<PointerUpdateKind__middleButtonPressed> & PointerUpdateKind__middleButtonPressed & 5;// 5
static +middleButtonReleased: Class<PointerUpdateKind__middleButtonReleased> & PointerUpdateKind__middleButtonReleased & 6;// 6
static +xButton1Pressed: Class<PointerUpdateKind__xButton1Pressed> & PointerUpdateKind__xButton1Pressed & 7;// 7
static +xButton1Released: Class<PointerUpdateKind__xButton1Released> & PointerUpdateKind__xButton1Released & 8;// 8
static +xButton2Pressed: Class<PointerUpdateKind__xButton2Pressed> & PointerUpdateKind__xButton2Pressed & 9;// 9
static +xButton2Released: Class<PointerUpdateKind__xButton2Released> & PointerUpdateKind__xButton2Released & 10;// 10

}

declare class PointerUpdateKind__other mixins PointerUpdateKind {}
declare class PointerUpdateKind__leftButtonPressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__leftButtonReleased mixins PointerUpdateKind {}
declare class PointerUpdateKind__rightButtonPressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__rightButtonReleased mixins PointerUpdateKind {}
declare class PointerUpdateKind__middleButtonPressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__middleButtonReleased mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton1Pressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton1Released mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton2Pressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton2Released mixins PointerUpdateKind {}

	declare export interface IPointerPointProperties {
contactRect: Windows$Windows$Foundation.Rect,
contactRectRaw: Windows$Windows$Foundation.Rect,
isBarrelButtonPressed: boolean,
isCanceled: boolean,
isEraser: boolean,
isHorizontalMouseWheel: boolean,
isInRange: boolean,
isInverted: boolean,
isLeftButtonPressed: boolean,
isMiddleButtonPressed: boolean,
isPrimary: boolean,
isRightButtonPressed: boolean,
isXButton1Pressed: boolean,
isXButton2Pressed: boolean,
mouseWheelDelta: number,
orientation: number,
pointerUpdateKind: Windows$Windows$UI.Input.PointerUpdateKind,
pressure: number,
touchConfidence: boolean,
twist: number,
xTilt: number,
yTilt: number,
hasUsage(usagePage: number, usageId: number): boolean,
getUsageValue(usagePage: number, usageId: number): number
} 
	declare export interface IPointerVisualizationSettings {
isBarrelButtonFeedbackEnabled: boolean,
isContactFeedbackEnabled: boolean
} 
	declare export interface IPointerVisualizationSettingsStatics {
getForCurrentView(): Windows$Windows$UI.Input.PointerVisualizationSettings
} 
	declare export class PointerVisualizationSettings mixins undefined.IPointerVisualizationSettings {
isBarrelButtonFeedbackEnabled: boolean;
isContactFeedbackEnabled: boolean;
static getForCurrentView(): Windows$Windows$UI.Input.PointerVisualizationSettings
}
	declare module 'Inking' {
        declare export  class InkManipulationMode {
  constructor(...args: empty): mixed;
static +inking: Class<InkManipulationMode__inking> & InkManipulationMode__inking & 0;// 0
static +erasing: Class<InkManipulationMode__erasing> & InkManipulationMode__erasing & 1;// 1
static +selecting: Class<InkManipulationMode__selecting> & InkManipulationMode__selecting & 2;// 2

}

declare class InkManipulationMode__inking mixins InkManipulationMode {}
declare class InkManipulationMode__erasing mixins InkManipulationMode {}
declare class InkManipulationMode__selecting mixins InkManipulationMode {}

	declare export  class InkRecognitionTarget {
  constructor(...args: empty): mixed;
static +all: Class<InkRecognitionTarget__all> & InkRecognitionTarget__all & 0;// 0
static +selected: Class<InkRecognitionTarget__selected> & InkRecognitionTarget__selected & 1;// 1
static +recent: Class<InkRecognitionTarget__recent> & InkRecognitionTarget__recent & 2;// 2

}

declare class InkRecognitionTarget__all mixins InkRecognitionTarget {}
declare class InkRecognitionTarget__selected mixins InkRecognitionTarget {}
declare class InkRecognitionTarget__recent mixins InkRecognitionTarget {}

	declare export  class PenTipShape {
  constructor(...args: empty): mixed;
static +circle: Class<PenTipShape__circle> & PenTipShape__circle & 0;// 0
static +rectangle: Class<PenTipShape__rectangle> & PenTipShape__rectangle & 1;// 1

}

declare class PenTipShape__circle mixins PenTipShape {}
declare class PenTipShape__rectangle mixins PenTipShape {}

	declare export interface IInkDrawingAttributes {
color: Windows$Windows$UI.Color,
fitToCurve: boolean,
ignorePressure: boolean,
penTip: Windows$Windows$UI.Input.Inking.PenTipShape,
size: Windows$Windows$Foundation.Size
} 
	declare export class InkDrawingAttributes mixins undefined.IInkDrawingAttributes {
color: Windows$Windows$UI.Color;
fitToCurve: boolean;
ignorePressure: boolean;
penTip: Windows$Windows$UI.Input.Inking.PenTipShape;
size: Windows$Windows$Foundation.Size
}
	declare export interface IInkStrokeRenderingSegment {
bezierControlPoint1: Windows$Windows$Foundation.Point,
bezierControlPoint2: Windows$Windows$Foundation.Point,
position: Windows$Windows$Foundation.Point,
pressure: number,
tiltX: number,
tiltY: number,
twist: number
} 
	declare export class InkStrokeRenderingSegment mixins undefined.IInkStrokeRenderingSegment {
bezierControlPoint1: Windows$Windows$Foundation.Point;
bezierControlPoint2: Windows$Windows$Foundation.Point;
position: Windows$Windows$Foundation.Point;
pressure: number;
tiltX: number;
tiltY: number;
twist: number
}
	declare export interface IInkStroke {
boundingRect: Windows$Windows$Foundation.Rect,
drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes,
recognized: boolean,
selected: boolean,
getRenderingSegments(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStrokeRenderingSegment>,
clone(): Windows$Windows$UI.Input.Inking.InkStroke
} 
	declare export class InkStroke mixins undefined.IInkStroke {
boundingRect: Windows$Windows$Foundation.Rect;
drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes;
recognized: boolean;
selected: boolean;
getRenderingSegments(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStrokeRenderingSegment>;
clone(): Windows$Windows$UI.Input.Inking.InkStroke
}
	declare export interface IInkStrokeBuilder {
beginStroke(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void,
appendToStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.PointerPoint,
endStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.Inking.InkStroke,
createStroke(
points: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$UI.Input.Inking.InkStroke,
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void
} 
	declare export class InkStrokeBuilder mixins undefined.IInkStrokeBuilder {
beginStroke(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void;
appendToStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.PointerPoint;
endStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.Inking.InkStroke;
createStroke(
points: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$UI.Input.Inking.InkStroke;
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void
}
	declare export interface IInkRecognitionResult {
boundingRect: Windows$Windows$Foundation.Rect,
getTextCandidates(): Windows$Windows$Foundation.Collections.IVectorView<string>,
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>
} 
	declare export class InkRecognitionResult mixins undefined.IInkRecognitionResult {
boundingRect: Windows$Windows$Foundation.Rect;
getTextCandidates(): Windows$Windows$Foundation.Collections.IVectorView<string>;
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>
}
	declare export interface IInkStrokeContainer {
boundingRect: Windows$Windows$Foundation.Rect,
addStroke(stroke: Windows$Windows$UI.Input.Inking.InkStroke): void,
deleteSelected(): Windows$Windows$Foundation.Rect,
moveSelected(translation: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect,
selectWithPolyLine(
polyline: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$Foundation.Rect,
selectWithLine(
from: Windows$Windows$Foundation.Point,
to: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect,
copySelectedToClipboard(): void,
pasteFromClipboard(position: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect,
canPasteFromClipboard(): boolean,
loadAsync(
inputStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<number>,
saveAsync(
outputStream: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>,
updateRecognitionResults(
recognitionResults: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>): void,
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>,
getRecognitionResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>
} 
	declare export class InkStrokeContainer mixins undefined.IInkStrokeContainer {
boundingRect: Windows$Windows$Foundation.Rect;
addStroke(stroke: Windows$Windows$UI.Input.Inking.InkStroke): void;
deleteSelected(): Windows$Windows$Foundation.Rect;
moveSelected(translation: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
selectWithPolyLine(
polyline: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$Foundation.Rect;
selectWithLine(
from: Windows$Windows$Foundation.Point,
to: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
copySelectedToClipboard(): void;
pasteFromClipboard(position: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
canPasteFromClipboard(): boolean;
loadAsync(
inputStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<number>;
saveAsync(
outputStream: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
updateRecognitionResults(
recognitionResults: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>): void;
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>;
getRecognitionResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>
}
	declare export interface IInkRecognizer {
name: string
} 
	declare export class InkRecognizer mixins undefined.IInkRecognizer {
name: string
}
	declare export interface IInkRecognizerContainer {
setDefaultRecognizer(recognizer: Windows$Windows$UI.Input.Inking.InkRecognizer): void,
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>,
getRecognizers(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognizer>
} 
	declare export class InkRecognizerContainer mixins undefined.IInkRecognizerContainer {
setDefaultRecognizer(recognizer: Windows$Windows$UI.Input.Inking.InkRecognizer): void;
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>;
getRecognizers(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognizer>
}
	declare export type IInkManager = {
mode: Windows$Windows$UI.Input.Inking.InkManipulationMode,
processPointerDown(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void,
processPointerUpdate(pointerPoint: Windows$Windows$UI.Input.PointerPoint): any,
processPointerUp(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$Foundation.Rect,
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void,
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>,
recognizeAsync(
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>
} & undefined.IInkStrokeContainer & undefined.IInkRecognizerContainer

	declare export class InkManager mixins undefined.IInkManager, undefined.IInkStrokeContainer, undefined.IInkRecognizerContainer {
mode: Windows$Windows$UI.Input.Inking.InkManipulationMode;
boundingRect: Windows$Windows$Foundation.Rect;
processPointerDown(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void;
processPointerUpdate(pointerPoint: Windows$Windows$UI.Input.PointerPoint): any;
processPointerUp(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$Foundation.Rect;
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void;
recognizeAsync(
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>;
addStroke(stroke: Windows$Windows$UI.Input.Inking.InkStroke): void;
deleteSelected(): Windows$Windows$Foundation.Rect;
moveSelected(translation: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
selectWithPolyLine(
polyline: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$Foundation.Rect;
selectWithLine(
from: Windows$Windows$Foundation.Point,
to: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
copySelectedToClipboard(): void;
pasteFromClipboard(position: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
canPasteFromClipboard(): boolean;
loadAsync(
inputStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<number>;
saveAsync(
outputStream: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
updateRecognitionResults(
recognitionResults: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>): void;
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>;
getRecognitionResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>;
setDefaultRecognizer(recognizer: Windows$Windows$UI.Input.Inking.InkRecognizer): void;
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>;
getRecognizers(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognizer>
}
    }

    }

	declare module 'Portable' {
        declare export  class ServiceDeviceType {
  constructor(...args: empty): mixed;
static +calendarService: Class<ServiceDeviceType__calendarService> & ServiceDeviceType__calendarService & 0;// 0
static +contactsService: Class<ServiceDeviceType__contactsService> & ServiceDeviceType__contactsService & 1;// 1
static +deviceStatusService: Class<ServiceDeviceType__deviceStatusService> & ServiceDeviceType__deviceStatusService & 2;// 2
static +notesService: Class<ServiceDeviceType__notesService> & ServiceDeviceType__notesService & 3;// 3
static +ringtonesService: Class<ServiceDeviceType__ringtonesService> & ServiceDeviceType__ringtonesService & 4;// 4
static +smsService: Class<ServiceDeviceType__smsService> & ServiceDeviceType__smsService & 5;// 5
static +tasksService: Class<ServiceDeviceType__tasksService> & ServiceDeviceType__tasksService & 6;// 6

}

declare class ServiceDeviceType__calendarService mixins ServiceDeviceType {}
declare class ServiceDeviceType__contactsService mixins ServiceDeviceType {}
declare class ServiceDeviceType__deviceStatusService mixins ServiceDeviceType {}
declare class ServiceDeviceType__notesService mixins ServiceDeviceType {}
declare class ServiceDeviceType__ringtonesService mixins ServiceDeviceType {}
declare class ServiceDeviceType__smsService mixins ServiceDeviceType {}
declare class ServiceDeviceType__tasksService mixins ServiceDeviceType {}

	declare export interface IStorageDeviceStatics {
fromId(interfaceId: string): Windows$Windows$Storage.StorageFolder,
getDeviceSelector(): string
} 
	declare export interface IServiceDeviceStatics {
getDeviceSelector(serviceType: Windows$Windows$Devices.Portable.ServiceDeviceType): string,
getDeviceSelectorFromServiceId(serviceId: string): string
} 
	declare export class StorageDevice  {
static fromId(interfaceId: string): Windows$Windows$Storage.StorageFolder;
static getDeviceSelector(): string
}
	declare export class ServiceDevice  {
static getDeviceSelector(serviceType: Windows$Windows$Devices.Portable.ServiceDeviceType): string;
static getDeviceSelectorFromServiceId(serviceId: string): string
}
    }

	declare module 'Printers' {
        declare module 'Extensions' {
        declare export interface IPrintTaskConfigurationSaveRequestedDeferral {
complete(): void
} 
	declare export class PrintTaskConfigurationSaveRequestedDeferral mixins undefined.IPrintTaskConfigurationSaveRequestedDeferral {
complete(): void
}
	declare export interface IPrintTaskConfigurationSaveRequest {
deadline: Date,
cancel(): void,
save(printerExtensionContext: any): void,
getDeferral(
): Windows$Windows$Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedDeferral
} 
	declare export class PrintTaskConfigurationSaveRequest mixins undefined.IPrintTaskConfigurationSaveRequest {
deadline: Date;
cancel(): void;
save(printerExtensionContext: any): void;
getDeferral(
): Windows$Windows$Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedDeferral
}
	declare export interface IPrintTaskConfigurationSaveRequestedEventArgs {
request: Windows$Windows$Devices.Printers.Extensions.PrintTaskConfigurationSaveRequest
} 
	declare export class PrintTaskConfigurationSaveRequestedEventArgs mixins undefined.IPrintTaskConfigurationSaveRequestedEventArgs {
request: Windows$Windows$Devices.Printers.Extensions.PrintTaskConfigurationSaveRequest
}
	declare export interface IPrintTaskConfiguration {
printerExtensionContext: any,
onsaverequested: any
} 
	declare export class PrintTaskConfiguration mixins undefined.IPrintTaskConfiguration {
printerExtensionContext: any;
onsaverequested: any
}
	declare export interface IPrintNotificationEventDetails {
eventData: string,
printerName: string
} 
	declare export class PrintNotificationEventDetails mixins undefined.IPrintNotificationEventDetails {
eventData: string;
printerName: string
}
	declare export interface IPrintExtensionContextStatic {
fromDeviceId(deviceId: string): any
} 
	declare export class PrintExtensionContext  {
static fromDeviceId(deviceId: string): any
}
    }

    }

	declare module 'Sensors' {
        declare export interface IAccelerometerStatics {
getDefault(): Windows$Windows$Devices.Sensors.Accelerometer
} 
	declare export class Accelerometer mixins undefined.IAccelerometer {
minimumReportInterval: number;
reportInterval: number;
getCurrentReading(): Windows$Windows$Devices.Sensors.AccelerometerReading;
onreadingchanged: any;
onshaken: any;
static getDefault(): Windows$Windows$Devices.Sensors.Accelerometer
}
	declare export interface IAccelerometer {
minimumReportInterval: number,
reportInterval: number,
getCurrentReading(): Windows$Windows$Devices.Sensors.AccelerometerReading,
onreadingchanged: any,
onshaken: any
} 
	declare export class AccelerometerReading mixins undefined.IAccelerometerReading {
accelerationX: number;
accelerationY: number;
accelerationZ: number;
timestamp: Date
}
	declare export class AccelerometerReadingChangedEventArgs mixins undefined.IAccelerometerReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.AccelerometerReading
}
	declare export class AccelerometerShakenEventArgs mixins undefined.IAccelerometerShakenEventArgs {
timestamp: Date
}
	declare export interface IAccelerometerReading {
accelerationX: number,
accelerationY: number,
accelerationZ: number,
timestamp: Date
} 
	declare export interface IAccelerometerReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.AccelerometerReading
} 
	declare export interface IAccelerometerShakenEventArgs {
timestamp: Date
} 
	declare export interface IInclinometerStatics {
getDefault(): Windows$Windows$Devices.Sensors.Inclinometer
} 
	declare export class Inclinometer mixins undefined.IInclinometer {
minimumReportInterval: number;
reportInterval: number;
getCurrentReading(): Windows$Windows$Devices.Sensors.InclinometerReading;
onreadingchanged: any;
static getDefault(): Windows$Windows$Devices.Sensors.Inclinometer
}
	declare export interface IInclinometer {
minimumReportInterval: number,
reportInterval: number,
getCurrentReading(): Windows$Windows$Devices.Sensors.InclinometerReading,
onreadingchanged: any
} 
	declare export class InclinometerReading mixins undefined.IInclinometerReading {
pitchDegrees: number;
rollDegrees: number;
timestamp: Date;
yawDegrees: number
}
	declare export class InclinometerReadingChangedEventArgs mixins undefined.IInclinometerReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.InclinometerReading
}
	declare export interface IInclinometerReading {
pitchDegrees: number,
rollDegrees: number,
timestamp: Date,
yawDegrees: number
} 
	declare export interface IInclinometerReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.InclinometerReading
} 
	declare export interface IGyrometerStatics {
getDefault(): Windows$Windows$Devices.Sensors.Gyrometer
} 
	declare export class Gyrometer mixins undefined.IGyrometer {
minimumReportInterval: number;
reportInterval: number;
getCurrentReading(): Windows$Windows$Devices.Sensors.GyrometerReading;
onreadingchanged: any;
static getDefault(): Windows$Windows$Devices.Sensors.Gyrometer
}
	declare export interface IGyrometer {
minimumReportInterval: number,
reportInterval: number,
getCurrentReading(): Windows$Windows$Devices.Sensors.GyrometerReading,
onreadingchanged: any
} 
	declare export class GyrometerReading mixins undefined.IGyrometerReading {
angularVelocityX: number;
angularVelocityY: number;
angularVelocityZ: number;
timestamp: Date
}
	declare export class GyrometerReadingChangedEventArgs mixins undefined.IGyrometerReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.GyrometerReading
}
	declare export interface IGyrometerReading {
angularVelocityX: number,
angularVelocityY: number,
angularVelocityZ: number,
timestamp: Date
} 
	declare export interface IGyrometerReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.GyrometerReading
} 
	declare export interface ICompassStatics {
getDefault(): Windows$Windows$Devices.Sensors.Compass
} 
	declare export class Compass mixins undefined.ICompass {
minimumReportInterval: number;
reportInterval: number;
getCurrentReading(): Windows$Windows$Devices.Sensors.CompassReading;
onreadingchanged: any;
static getDefault(): Windows$Windows$Devices.Sensors.Compass
}
	declare export interface ICompass {
minimumReportInterval: number,
reportInterval: number,
getCurrentReading(): Windows$Windows$Devices.Sensors.CompassReading,
onreadingchanged: any
} 
	declare export class CompassReading mixins undefined.ICompassReading {
headingMagneticNorth: number;
headingTrueNorth: number;
timestamp: Date
}
	declare export class CompassReadingChangedEventArgs mixins undefined.ICompassReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.CompassReading
}
	declare export interface ICompassReading {
headingMagneticNorth: number,
headingTrueNorth: number,
timestamp: Date
} 
	declare export interface ICompassReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.CompassReading
} 
	declare export interface ILightSensorStatics {
getDefault(): Windows$Windows$Devices.Sensors.LightSensor
} 
	declare export class LightSensor mixins undefined.ILightSensor {
minimumReportInterval: number;
reportInterval: number;
getCurrentReading(): Windows$Windows$Devices.Sensors.LightSensorReading;
onreadingchanged: any;
static getDefault(): Windows$Windows$Devices.Sensors.LightSensor
}
	declare export interface ILightSensor {
minimumReportInterval: number,
reportInterval: number,
getCurrentReading(): Windows$Windows$Devices.Sensors.LightSensorReading,
onreadingchanged: any
} 
	declare export class LightSensorReading mixins undefined.ILightSensorReading {
illuminanceInLux: number;
timestamp: Date
}
	declare export class LightSensorReadingChangedEventArgs mixins undefined.ILightSensorReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.LightSensorReading
}
	declare export interface ILightSensorReading {
illuminanceInLux: number,
timestamp: Date
} 
	declare export interface ILightSensorReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.LightSensorReading
} 
	declare export interface ISensorRotationMatrix {
m11: number,
m12: number,
m13: number,
m21: number,
m22: number,
m23: number,
m31: number,
m32: number,
m33: number
} 
	declare export interface ISensorQuaternion {
w: number,
x: number,
y: number,
z: number
} 
	declare export class SensorRotationMatrix mixins undefined.ISensorRotationMatrix {
m11: number;
m12: number;
m13: number;
m21: number;
m22: number;
m23: number;
m31: number;
m32: number;
m33: number
}
	declare export class SensorQuaternion mixins undefined.ISensorQuaternion {
w: number;
x: number;
y: number;
z: number
}
	declare export interface IOrientationSensorStatics {
getDefault(): Windows$Windows$Devices.Sensors.OrientationSensor
} 
	declare export class OrientationSensor mixins undefined.IOrientationSensor {
minimumReportInterval: number;
reportInterval: number;
getCurrentReading(): Windows$Windows$Devices.Sensors.OrientationSensorReading;
onreadingchanged: any;
static getDefault(): Windows$Windows$Devices.Sensors.OrientationSensor
}
	declare export interface IOrientationSensor {
minimumReportInterval: number,
reportInterval: number,
getCurrentReading(): Windows$Windows$Devices.Sensors.OrientationSensorReading,
onreadingchanged: any
} 
	declare export class OrientationSensorReading mixins undefined.IOrientationSensorReading {
quaternion: Windows$Windows$Devices.Sensors.SensorQuaternion;
rotationMatrix: Windows$Windows$Devices.Sensors.SensorRotationMatrix;
timestamp: Date
}
	declare export class OrientationSensorReadingChangedEventArgs mixins undefined.IOrientationSensorReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.OrientationSensorReading
}
	declare export interface IOrientationSensorReading {
quaternion: Windows$Windows$Devices.Sensors.SensorQuaternion,
rotationMatrix: Windows$Windows$Devices.Sensors.SensorRotationMatrix,
timestamp: Date
} 
	declare export interface IOrientationSensorReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.OrientationSensorReading
} 
	declare export  class SimpleOrientation {
  constructor(...args: empty): mixed;
static +notRotated: Class<SimpleOrientation__notRotated> & SimpleOrientation__notRotated & 0;// 0
static +rotated90DegreesCounterclockwise: Class<SimpleOrientation__rotated90DegreesCounterclockwise> & SimpleOrientation__rotated90DegreesCounterclockwise & 1;// 1
static +rotated180DegreesCounterclockwise: Class<SimpleOrientation__rotated180DegreesCounterclockwise> & SimpleOrientation__rotated180DegreesCounterclockwise & 2;// 2
static +rotated270DegreesCounterclockwise: Class<SimpleOrientation__rotated270DegreesCounterclockwise> & SimpleOrientation__rotated270DegreesCounterclockwise & 3;// 3
static +faceup: Class<SimpleOrientation__faceup> & SimpleOrientation__faceup & 4;// 4
static +facedown: Class<SimpleOrientation__facedown> & SimpleOrientation__facedown & 5;// 5

}

declare class SimpleOrientation__notRotated mixins SimpleOrientation {}
declare class SimpleOrientation__rotated90DegreesCounterclockwise mixins SimpleOrientation {}
declare class SimpleOrientation__rotated180DegreesCounterclockwise mixins SimpleOrientation {}
declare class SimpleOrientation__rotated270DegreesCounterclockwise mixins SimpleOrientation {}
declare class SimpleOrientation__faceup mixins SimpleOrientation {}
declare class SimpleOrientation__facedown mixins SimpleOrientation {}

	declare export interface ISimpleOrientationSensorStatics {
getDefault(): Windows$Windows$Devices.Sensors.SimpleOrientationSensor
} 
	declare export class SimpleOrientationSensor mixins undefined.ISimpleOrientationSensor {
getCurrentOrientation(): Windows$Windows$Devices.Sensors.SimpleOrientation;
onorientationchanged: any;
static getDefault(): Windows$Windows$Devices.Sensors.SimpleOrientationSensor
}
	declare export interface ISimpleOrientationSensor {
getCurrentOrientation(): Windows$Windows$Devices.Sensors.SimpleOrientation,
onorientationchanged: any
} 
	declare export class SimpleOrientationSensorOrientationChangedEventArgs mixins undefined.ISimpleOrientationSensorOrientationChangedEventArgs {
orientation: Windows$Windows$Devices.Sensors.SimpleOrientation;
timestamp: Date
}
	declare export interface ISimpleOrientationSensorOrientationChangedEventArgs {
orientation: Windows$Windows$Devices.Sensors.SimpleOrientation,
timestamp: Date
} 
    }

	declare export  class TelephonyKey {
  constructor(...args: empty): mixed;
static +d0: Class<TelephonyKey__d0> & TelephonyKey__d0 & 0;// 0
static +d1: Class<TelephonyKey__d1> & TelephonyKey__d1 & 1;// 1
static +d2: Class<TelephonyKey__d2> & TelephonyKey__d2 & 2;// 2
static +d3: Class<TelephonyKey__d3> & TelephonyKey__d3 & 3;// 3
static +d4: Class<TelephonyKey__d4> & TelephonyKey__d4 & 4;// 4
static +d5: Class<TelephonyKey__d5> & TelephonyKey__d5 & 5;// 5
static +d6: Class<TelephonyKey__d6> & TelephonyKey__d6 & 6;// 6
static +d7: Class<TelephonyKey__d7> & TelephonyKey__d7 & 7;// 7
static +d8: Class<TelephonyKey__d8> & TelephonyKey__d8 & 8;// 8
static +d9: Class<TelephonyKey__d9> & TelephonyKey__d9 & 9;// 9
static +star: Class<TelephonyKey__star> & TelephonyKey__star & 10;// 10
static +pound: Class<TelephonyKey__pound> & TelephonyKey__pound & 11;// 11
static +a: Class<TelephonyKey__a> & TelephonyKey__a & 12;// 12
static +b: Class<TelephonyKey__b> & TelephonyKey__b & 13;// 13
static +c: Class<TelephonyKey__c> & TelephonyKey__c & 14;// 14
static +d: Class<TelephonyKey__d> & TelephonyKey__d & 15;// 15

}

declare class TelephonyKey__d0 mixins TelephonyKey {}
declare class TelephonyKey__d1 mixins TelephonyKey {}
declare class TelephonyKey__d2 mixins TelephonyKey {}
declare class TelephonyKey__d3 mixins TelephonyKey {}
declare class TelephonyKey__d4 mixins TelephonyKey {}
declare class TelephonyKey__d5 mixins TelephonyKey {}
declare class TelephonyKey__d6 mixins TelephonyKey {}
declare class TelephonyKey__d7 mixins TelephonyKey {}
declare class TelephonyKey__d8 mixins TelephonyKey {}
declare class TelephonyKey__d9 mixins TelephonyKey {}
declare class TelephonyKey__star mixins TelephonyKey {}
declare class TelephonyKey__pound mixins TelephonyKey {}
declare class TelephonyKey__a mixins TelephonyKey {}
declare class TelephonyKey__b mixins TelephonyKey {}
declare class TelephonyKey__c mixins TelephonyKey {}
declare class TelephonyKey__d mixins TelephonyKey {}

	declare export interface IDialRequestedEventArgs {
contact: any,
handled(): void
} 
	declare export class DialRequestedEventArgs mixins undefined.IDialRequestedEventArgs {
contact: any;
handled(): void
}
	declare export interface IRedialRequestedEventArgs {
handled(): void
} 
	declare export class RedialRequestedEventArgs mixins undefined.IRedialRequestedEventArgs {
handled(): void
}
	declare export interface IKeypadPressedEventArgs {
telephonyKey: Windows$Windows$Media.Windows$Devices.TelephonyKey
} 
	declare export class KeypadPressedEventArgs mixins undefined.IKeypadPressedEventArgs {
telephonyKey: Windows$Windows$Media.Windows$Devices.TelephonyKey
}
	declare export interface CallControlEventHandler {
(sender: Windows$Windows$Media.Windows$Devices.CallControl): void
} 
	declare export class CallControl mixins undefined.ICallControl {
hasRinger: boolean;
indicateNewIncomingCall(enableRinger: boolean, callerId: string): number;
indicateNewOutgoingCall(): number;
indicateActiveCall(callToken: number): void;
endCall(callToken: number): void;
onanswerrequested: any;
onhanguprequested: any;
ondialrequested: any;
onredialrequested: any;
onkeypadpressed: any;
onaudiotransferrequested: any;
static getDefault(): Windows$Windows$Media.Windows$Devices.CallControl;
static fromId(deviceInterfaceId: string): Windows$Windows$Media.Windows$Devices.CallControl
}
	declare export interface DialRequestedEventHandler {
(sender: Windows$Windows$Media.Windows$Devices.CallControl, e: Windows$Windows$Media.Windows$Devices.DialRequestedEventArgs): void
} 
	declare export interface RedialRequestedEventHandler {
(sender: Windows$Windows$Media.Windows$Devices.CallControl, e: Windows$Windows$Media.Windows$Devices.RedialRequestedEventArgs): void
} 
	declare export interface KeypadPressedEventHandler {
(sender: Windows$Windows$Media.Windows$Devices.CallControl, e: Windows$Windows$Media.Windows$Devices.KeypadPressedEventArgs): void
} 
	declare export interface ICallControl {
hasRinger: boolean,
indicateNewIncomingCall(enableRinger: boolean, callerId: string): number,
indicateNewOutgoingCall(): number,
indicateActiveCall(callToken: number): void,
endCall(callToken: number): void,
onanswerrequested: any,
onhanguprequested: any,
ondialrequested: any,
onredialrequested: any,
onkeypadpressed: any,
onaudiotransferrequested: any
} 
	declare export interface ICallControlStatics {
getDefault(): Windows$Windows$Media.Windows$Devices.CallControl,
fromId(deviceInterfaceId: string): Windows$Windows$Media.Windows$Devices.CallControl
} 
	declare export  class AudioDeviceRole {
  constructor(...args: empty): mixed;
static +default: Class<AudioDeviceRole__default> & AudioDeviceRole__default & 0;// 0
static +communications: Class<AudioDeviceRole__communications> & AudioDeviceRole__communications & 1;// 1

}

declare class AudioDeviceRole__default mixins AudioDeviceRole {}
declare class AudioDeviceRole__communications mixins AudioDeviceRole {}

	declare export interface IDefaultAudioDeviceChangedEventArgs {
id: string,
role: Windows$Windows$Media.Windows$Devices.AudioDeviceRole
} 
	declare export interface IMediaDeviceStatics {
getAudioCaptureSelector(): string,
getAudioRenderSelector(): string,
getVideoCaptureSelector(): string,
getDefaultAudioCaptureId(role: Windows$Windows$Media.Windows$Devices.AudioDeviceRole): string,
getDefaultAudioRenderId(role: Windows$Windows$Media.Windows$Devices.AudioDeviceRole): string,
ondefaultaudiocapturedevicechanged: any,
ondefaultaudiorenderdevicechanged: any
} 
	declare export class DefaultAudioCaptureDeviceChangedEventArgs mixins undefined.IDefaultAudioDeviceChangedEventArgs {
id: string;
role: Windows$Windows$Media.Windows$Devices.AudioDeviceRole
}
	declare export class DefaultAudioRenderDeviceChangedEventArgs mixins undefined.IDefaultAudioDeviceChangedEventArgs {
id: string;
role: Windows$Windows$Media.Windows$Devices.AudioDeviceRole
}
	declare export class MediaDevice  {
static getAudioCaptureSelector(): string;
static getAudioRenderSelector(): string;
static getVideoCaptureSelector(): string;
static getDefaultAudioCaptureId(role: Windows$Windows$Media.Windows$Devices.AudioDeviceRole): string;
static getDefaultAudioRenderId(role: Windows$Windows$Media.Windows$Devices.AudioDeviceRole): string;
static ondefaultaudiocapturedevicechanged: any;
static ondefaultaudiorenderdevicechanged: any
}
	declare export class AudioDeviceController mixins undefined.IAudioDeviceController, undefined.IMediaDeviceController {
muted: boolean;
volumePercent: number;
getAvailableMediaStreamProperties(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Media.MediaProperties.IMediaEncodingProperties>;
getMediaStreamProperties(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType): Windows$Windows$Media.MediaProperties.IMediaEncodingProperties;
setMediaStreamPropertiesAsync(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType,
mediaEncodingProperties: Windows$Windows$Media.MediaProperties.IMediaEncodingProperties): Windows$Windows$Foundation.IAsyncAction
}
	declare export class VideoDeviceController mixins undefined.IVideoDeviceController, undefined.IMediaDeviceController, undefined.IAdvancedVideoCaptureDeviceController {
backlightCompensation: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
brightness: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
contrast: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
exposure: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
focus: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
hue: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
pan: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
roll: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
tilt: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
whiteBalance: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
zoom: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
trySetPowerlineFrequency(value: Windows$Windows$Media.Capture.PowerlineFrequency): boolean;
tryGetPowerlineFrequency(
): {
value: Windows$Windows$Media.Capture.PowerlineFrequency,
succeeded: boolean
};
getAvailableMediaStreamProperties(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Media.MediaProperties.IMediaEncodingProperties>;
getMediaStreamProperties(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType): Windows$Windows$Media.MediaProperties.IMediaEncodingProperties;
setMediaStreamPropertiesAsync(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType,
mediaEncodingProperties: Windows$Windows$Media.MediaProperties.IMediaEncodingProperties): Windows$Windows$Foundation.IAsyncAction;
setDeviceProperty(propertyId: string, propertyValue: any): void;
getDeviceProperty(propertyId: string): any
}
	declare export interface IMediaDeviceController {
getAvailableMediaStreamProperties(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Media.MediaProperties.IMediaEncodingProperties>,
getMediaStreamProperties(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType): Windows$Windows$Media.MediaProperties.IMediaEncodingProperties,
setMediaStreamPropertiesAsync(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType,
mediaEncodingProperties: Windows$Windows$Media.MediaProperties.IMediaEncodingProperties): Windows$Windows$Foundation.IAsyncAction
} 
	declare export type IAudioDeviceController = {
muted: boolean,
volumePercent: number
} & undefined.IMediaDeviceController

	declare export type IVideoDeviceController = {
backlightCompensation: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
brightness: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
contrast: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
exposure: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
focus: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
hue: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
pan: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
roll: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
tilt: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
whiteBalance: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
zoom: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
trySetPowerlineFrequency(value: Windows$Windows$Media.Capture.PowerlineFrequency): boolean,
tryGetPowerlineFrequency(
): {
value: Windows$Windows$Media.Capture.PowerlineFrequency,
succeeded: boolean
}
} & undefined.IMediaDeviceController

	declare export class MediaDeviceControl mixins undefined.IMediaDeviceControl {
capabilities: Windows$Windows$Media.Windows$Devices.MediaDeviceControlCapabilities;
tryGetValue(): {
value: number,
succeeded: boolean
};
trySetValue(value: number): boolean;
tryGetAuto(): {
value: boolean,
succeeded: boolean
};
trySetAuto(value: boolean): boolean
}
	declare export interface IMediaDeviceControl {
capabilities: Windows$Windows$Media.Windows$Devices.MediaDeviceControlCapabilities,
tryGetValue(): {
value: number,
succeeded: boolean
},
trySetValue(value: number): boolean,
tryGetAuto(): {
value: boolean,
succeeded: boolean
},
trySetAuto(value: boolean): boolean
} 
	declare export class MediaDeviceControlCapabilities mixins undefined.IMediaDeviceControlCapabilities {
autoModeSupported: boolean;
default: number;
max: number;
min: number;
step: number;
supported: boolean
}
	declare export interface IMediaDeviceControlCapabilities {
autoModeSupported: boolean,
default: number,
max: number,
min: number,
step: number,
supported: boolean
} 
	declare export interface IAdvancedVideoCaptureDeviceController {
setDeviceProperty(propertyId: string, propertyValue: any): void,
getDeviceProperty(propertyId: string): any
} 
    }


declare module 'Globalization' {
        declare module 'Fonts' {
        declare export interface ILanguageFontGroup {
documentAlternate1Font: Windows$Windows$Globalization.Fonts.LanguageFont,
documentAlternate2Font: Windows$Windows$Globalization.Fonts.LanguageFont,
documentHeadingFont: Windows$Windows$Globalization.Fonts.LanguageFont,
fixedWidthTextFont: Windows$Windows$Globalization.Fonts.LanguageFont,
modernDocumentFont: Windows$Windows$Globalization.Fonts.LanguageFont,
traditionalDocumentFont: Windows$Windows$Globalization.Fonts.LanguageFont,
uICaptionFont: Windows$Windows$Globalization.Fonts.LanguageFont,
uIHeadingFont: Windows$Windows$Globalization.Fonts.LanguageFont,
uINotificationHeadingFont: Windows$Windows$Globalization.Fonts.LanguageFont,
uITextFont: Windows$Windows$Globalization.Fonts.LanguageFont,
uITitleFont: Windows$Windows$Globalization.Fonts.LanguageFont
} 
	declare export class LanguageFont mixins undefined.ILanguageFont {
fontFamily: string;
fontStretch: Windows$Windows$UI.Text.FontStretch;
fontStyle: Windows$Windows$UI.Text.FontStyle;
fontWeight: Windows$Windows$UI.Text.FontWeight;
scaleFactor: number
}
	declare export interface ILanguageFontGroupFactory {
createLanguageFontGroup(languageTag: string): Windows$Windows$Globalization.Fonts.LanguageFontGroup
} 
	declare export class LanguageFontGroup mixins undefined.ILanguageFontGroup {
constructor(languageTag: string): this;
documentAlternate1Font: Windows$Windows$Globalization.Fonts.LanguageFont;
documentAlternate2Font: Windows$Windows$Globalization.Fonts.LanguageFont;
documentHeadingFont: Windows$Windows$Globalization.Fonts.LanguageFont;
fixedWidthTextFont: Windows$Windows$Globalization.Fonts.LanguageFont;
modernDocumentFont: Windows$Windows$Globalization.Fonts.LanguageFont;
traditionalDocumentFont: Windows$Windows$Globalization.Fonts.LanguageFont;
uICaptionFont: Windows$Windows$Globalization.Fonts.LanguageFont;
uIHeadingFont: Windows$Windows$Globalization.Fonts.LanguageFont;
uINotificationHeadingFont: Windows$Windows$Globalization.Fonts.LanguageFont;
uITextFont: Windows$Windows$Globalization.Fonts.LanguageFont;
uITitleFont: Windows$Windows$Globalization.Fonts.LanguageFont
}
	declare export interface ILanguageFont {
fontFamily: string,
fontStretch: Windows$Windows$UI.Text.FontStretch,
fontStyle: Windows$Windows$UI.Text.FontStyle,
fontWeight: Windows$Windows$UI.Text.FontWeight,
scaleFactor: number
} 
    }

	declare export  class DayOfWeek {
  constructor(...args: empty): mixed;
static +sunday: Class<DayOfWeek__sunday> & DayOfWeek__sunday & 0;// 0
static +monday: Class<DayOfWeek__monday> & DayOfWeek__monday & 1;// 1
static +tuesday: Class<DayOfWeek__tuesday> & DayOfWeek__tuesday & 2;// 2
static +wednesday: Class<DayOfWeek__wednesday> & DayOfWeek__wednesday & 3;// 3
static +thursday: Class<DayOfWeek__thursday> & DayOfWeek__thursday & 4;// 4
static +friday: Class<DayOfWeek__friday> & DayOfWeek__friday & 5;// 5
static +saturday: Class<DayOfWeek__saturday> & DayOfWeek__saturday & 6;// 6

}

declare class DayOfWeek__sunday mixins DayOfWeek {}
declare class DayOfWeek__monday mixins DayOfWeek {}
declare class DayOfWeek__tuesday mixins DayOfWeek {}
declare class DayOfWeek__wednesday mixins DayOfWeek {}
declare class DayOfWeek__thursday mixins DayOfWeek {}
declare class DayOfWeek__friday mixins DayOfWeek {}
declare class DayOfWeek__saturday mixins DayOfWeek {}

	declare export interface ICalendarIdentifiersStatics {
gregorian: string,
hebrew: string,
hijri: string,
japanese: string,
julian: string,
korean: string,
taiwan: string,
thai: string,
umAlQura: string
} 
	declare export class CalendarIdentifiers  {
static gregorian: string;
static hebrew: string;
static hijri: string;
static japanese: string;
static julian: string;
static korean: string;
static taiwan: string;
static thai: string;
static umAlQura: string
}
	declare export interface IClockIdentifiersStatics {
twelveHour: string,
twentyFourHour: string
} 
	declare export class ClockIdentifiers  {
static twelveHour: string;
static twentyFourHour: string
}
	declare export interface IGeographicRegion {
code: string,
codeThreeDigit: string,
codeThreeLetter: string,
codeTwoLetter: string,
currenciesInUse: Windows$Windows$Foundation.Collections.IVectorView<string>,
displayName: string,
nativeName: string
} 
	declare export interface IGeographicRegionFactory {
createGeographicRegion(geographicRegionCode: string): Windows$Windows$Globalization.GeographicRegion
} 
	declare export class GeographicRegion mixins undefined.IGeographicRegion {
constructor(geographicRegionCode: string): this;
constructor(): this;
code: string;
codeThreeDigit: string;
codeThreeLetter: string;
codeTwoLetter: string;
currenciesInUse: Windows$Windows$Foundation.Collections.IVectorView<string>;
displayName: string;
nativeName: string;
static isSupported(geographicRegionCode: string): boolean
}
	declare export interface IGeographicRegionStatics {
isSupported(geographicRegionCode: string): boolean
} 
	declare export interface ILanguage {
displayName: string,
languageTag: string,
nativeName: string,
script: string
} 
	declare export interface ILanguageFactory {
createLanguage(languageTag: string): Windows$Windows$Globalization.Language
} 
	declare export class Language mixins undefined.ILanguage {
constructor(languageTag: string): this;
displayName: string;
languageTag: string;
nativeName: string;
script: string;
static currentInputMethodLanguageTag: string;
static isWellFormed(languageTag: string): boolean
}
	declare export interface ILanguageStatics {
currentInputMethodLanguageTag: string,
isWellFormed(languageTag: string): boolean
} 
	declare export interface ICalendar {
day: number,
dayOfWeek: Windows$Windows$Globalization.DayOfWeek,
era: number,
firstDayInThisMonth: number,
firstEra: number,
firstHourInThisPeriod: number,
firstMinuteInThisHour: number,
firstMonthInThisYear: number,
firstPeriodInThisDay: number,
firstSecondInThisMinute: number,
firstYearInThisEra: number,
hour: number,
isDaylightSavingTime: boolean,
languages: Windows$Windows$Foundation.Collections.IVectorView<string>,
lastDayInThisMonth: number,
lastEra: number,
lastHourInThisPeriod: number,
lastMinuteInThisHour: number,
lastMonthInThisYear: number,
lastPeriodInThisDay: number,
lastSecondInThisMinute: number,
lastYearInThisEra: number,
minute: number,
month: number,
nanosecond: number,
numberOfDaysInThisMonth: number,
numberOfEras: number,
numberOfHoursInThisPeriod: number,
numberOfMinutesInThisHour: number,
numberOfMonthsInThisYear: number,
numberOfPeriodsInThisDay: number,
numberOfSecondsInThisMinute: number,
numberOfYearsInThisEra: number,
numeralSystem: string,
period: number,
resolvedLanguage: string,
second: number,
year: number,
clone(): Windows$Windows$Globalization.Calendar,
setToMin(): void,
setToMax(): void,
getCalendarSystem(): string,
changeCalendarSystem(value: string): void,
getClock(): string,
changeClock(value: string): void,
getDateTime(): Date,
setDateTime(value: Date): void,
setToNow(): void,
addEras(eras: number): void,
eraAsString(): string,
eraAsString(idealLength: number): string,
addYears(years: number): void,
yearAsString(): string,
yearAsTruncatedString(remainingDigits: number): string,
yearAsPaddedString(minDigits: number): string,
addMonths(months: number): void,
monthAsString(): string,
monthAsString(idealLength: number): string,
monthAsSoloString(): string,
monthAsSoloString(idealLength: number): string,
monthAsNumericString(): string,
monthAsPaddedNumericString(minDigits: number): string,
addWeeks(weeks: number): void,
addDays(days: number): void,
dayAsString(): string,
dayAsPaddedString(minDigits: number): string,
dayOfWeekAsString(): string,
dayOfWeekAsString(idealLength: number): string,
dayOfWeekAsSoloString(): string,
dayOfWeekAsSoloString(idealLength: number): string,
addPeriods(periods: number): void,
periodAsString(): string,
periodAsString(idealLength: number): string,
addHours(hours: number): void,
hourAsString(): string,
hourAsPaddedString(minDigits: number): string,
addMinutes(minutes: number): void,
minuteAsString(): string,
minuteAsPaddedString(minDigits: number): string,
addSeconds(seconds: number): void,
secondAsString(): string,
secondAsPaddedString(minDigits: number): string,
addNanoseconds(nanoseconds: number): void,
nanosecondAsString(): string,
nanosecondAsPaddedString(minDigits: number): string,
compare(other: Windows$Windows$Globalization.Calendar): number,
compareDateTime(other: Date): number,
copyTo(other: Windows$Windows$Globalization.Calendar): void
} 
	declare export class Calendar mixins undefined.ICalendar {
constructor(languages: Windows$Windows$Foundation.Collections.IIterable<string>): this;
constructor(languages: Windows$Windows$Foundation.Collections.IIterable<string>, calendar: string, clock: string): this;
constructor(): this;
day: number;
dayOfWeek: Windows$Windows$Globalization.DayOfWeek;
era: number;
firstDayInThisMonth: number;
firstEra: number;
firstHourInThisPeriod: number;
firstMinuteInThisHour: number;
firstMonthInThisYear: number;
firstPeriodInThisDay: number;
firstSecondInThisMinute: number;
firstYearInThisEra: number;
hour: number;
isDaylightSavingTime: boolean;
languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
lastDayInThisMonth: number;
lastEra: number;
lastHourInThisPeriod: number;
lastMinuteInThisHour: number;
lastMonthInThisYear: number;
lastPeriodInThisDay: number;
lastSecondInThisMinute: number;
lastYearInThisEra: number;
minute: number;
month: number;
nanosecond: number;
numberOfDaysInThisMonth: number;
numberOfEras: number;
numberOfHoursInThisPeriod: number;
numberOfMinutesInThisHour: number;
numberOfMonthsInThisYear: number;
numberOfPeriodsInThisDay: number;
numberOfSecondsInThisMinute: number;
numberOfYearsInThisEra: number;
numeralSystem: string;
period: number;
resolvedLanguage: string;
second: number;
year: number;
clone(): Windows$Windows$Globalization.Calendar;
setToMin(): void;
setToMax(): void;
getCalendarSystem(): string;
changeCalendarSystem(value: string): void;
getClock(): string;
changeClock(value: string): void;
getDateTime(): Date;
setDateTime(value: Date): void;
setToNow(): void;
addEras(eras: number): void;
eraAsString(): string;
eraAsString(idealLength: number): string;
addYears(years: number): void;
yearAsString(): string;
yearAsTruncatedString(remainingDigits: number): string;
yearAsPaddedString(minDigits: number): string;
addMonths(months: number): void;
monthAsString(): string;
monthAsString(idealLength: number): string;
monthAsSoloString(): string;
monthAsSoloString(idealLength: number): string;
monthAsNumericString(): string;
monthAsPaddedNumericString(minDigits: number): string;
addWeeks(weeks: number): void;
addDays(days: number): void;
dayAsString(): string;
dayAsPaddedString(minDigits: number): string;
dayOfWeekAsString(): string;
dayOfWeekAsString(idealLength: number): string;
dayOfWeekAsSoloString(): string;
dayOfWeekAsSoloString(idealLength: number): string;
addPeriods(periods: number): void;
periodAsString(): string;
periodAsString(idealLength: number): string;
addHours(hours: number): void;
hourAsString(): string;
hourAsPaddedString(minDigits: number): string;
addMinutes(minutes: number): void;
minuteAsString(): string;
minuteAsPaddedString(minDigits: number): string;
addSeconds(seconds: number): void;
secondAsString(): string;
secondAsPaddedString(minDigits: number): string;
addNanoseconds(nanoseconds: number): void;
nanosecondAsString(): string;
nanosecondAsPaddedString(minDigits: number): string;
compare(other: Windows$Windows$Globalization.Calendar): number;
compareDateTime(other: Date): number;
copyTo(other: Windows$Windows$Globalization.Calendar): void
}
	declare export interface ICalendarFactory {
createCalendarDefaultCalendarAndClock(
languages: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Globalization.Calendar,
createCalendar(
languages: Windows$Windows$Foundation.Collections.IIterable<string>,
calendar: string,
clock: string): Windows$Windows$Globalization.Calendar
} 
	declare export interface IApplicationLanguagesStatics {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>,
manifestLanguages: Windows$Windows$Foundation.Collections.IVectorView<string>,
primaryLanguageOverride: string
} 
	declare export class ApplicationLanguages  {
static languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
static manifestLanguages: Windows$Windows$Foundation.Collections.IVectorView<string>;
static primaryLanguageOverride: string
}
	declare module 'DateTimeFormatting' {
        declare export  class YearFormat {
  constructor(...args: empty): mixed;
static +none: Class<YearFormat__none> & YearFormat__none & 0;// 0
static +default: Class<YearFormat__default> & YearFormat__default & 1;// 1
static +abbreviated: Class<YearFormat__abbreviated> & YearFormat__abbreviated & 2;// 2
static +full: Class<YearFormat__full> & YearFormat__full & 3;// 3

}

declare class YearFormat__none mixins YearFormat {}
declare class YearFormat__default mixins YearFormat {}
declare class YearFormat__abbreviated mixins YearFormat {}
declare class YearFormat__full mixins YearFormat {}

	declare export  class MonthFormat {
  constructor(...args: empty): mixed;
static +none: Class<MonthFormat__none> & MonthFormat__none & 0;// 0
static +default: Class<MonthFormat__default> & MonthFormat__default & 1;// 1
static +abbreviated: Class<MonthFormat__abbreviated> & MonthFormat__abbreviated & 2;// 2
static +full: Class<MonthFormat__full> & MonthFormat__full & 3;// 3
static +numeric: Class<MonthFormat__numeric> & MonthFormat__numeric & 4;// 4

}

declare class MonthFormat__none mixins MonthFormat {}
declare class MonthFormat__default mixins MonthFormat {}
declare class MonthFormat__abbreviated mixins MonthFormat {}
declare class MonthFormat__full mixins MonthFormat {}
declare class MonthFormat__numeric mixins MonthFormat {}

	declare export  class DayOfWeekFormat {
  constructor(...args: empty): mixed;
static +none: Class<DayOfWeekFormat__none> & DayOfWeekFormat__none & 0;// 0
static +default: Class<DayOfWeekFormat__default> & DayOfWeekFormat__default & 1;// 1
static +abbreviated: Class<DayOfWeekFormat__abbreviated> & DayOfWeekFormat__abbreviated & 2;// 2
static +full: Class<DayOfWeekFormat__full> & DayOfWeekFormat__full & 3;// 3

}

declare class DayOfWeekFormat__none mixins DayOfWeekFormat {}
declare class DayOfWeekFormat__default mixins DayOfWeekFormat {}
declare class DayOfWeekFormat__abbreviated mixins DayOfWeekFormat {}
declare class DayOfWeekFormat__full mixins DayOfWeekFormat {}

	declare export  class DayFormat {
  constructor(...args: empty): mixed;
static +none: Class<DayFormat__none> & DayFormat__none & 0;// 0
static +default: Class<DayFormat__default> & DayFormat__default & 1;// 1

}

declare class DayFormat__none mixins DayFormat {}
declare class DayFormat__default mixins DayFormat {}

	declare export  class HourFormat {
  constructor(...args: empty): mixed;
static +none: Class<HourFormat__none> & HourFormat__none & 0;// 0
static +default: Class<HourFormat__default> & HourFormat__default & 1;// 1

}

declare class HourFormat__none mixins HourFormat {}
declare class HourFormat__default mixins HourFormat {}

	declare export  class MinuteFormat {
  constructor(...args: empty): mixed;
static +none: Class<MinuteFormat__none> & MinuteFormat__none & 0;// 0
static +default: Class<MinuteFormat__default> & MinuteFormat__default & 1;// 1

}

declare class MinuteFormat__none mixins MinuteFormat {}
declare class MinuteFormat__default mixins MinuteFormat {}

	declare export  class SecondFormat {
  constructor(...args: empty): mixed;
static +none: Class<SecondFormat__none> & SecondFormat__none & 0;// 0
static +default: Class<SecondFormat__default> & SecondFormat__default & 1;// 1

}

declare class SecondFormat__none mixins SecondFormat {}
declare class SecondFormat__default mixins SecondFormat {}

	declare export interface IDateTimeFormatter {
calendar: string,
clock: string,
geographicRegion: string,
includeDay: Windows$Windows$Globalization.DateTimeFormatting.DayFormat,
includeDayOfWeek: Windows$Windows$Globalization.DateTimeFormatting.DayOfWeekFormat,
includeHour: Windows$Windows$Globalization.DateTimeFormatting.HourFormat,
includeMinute: Windows$Windows$Globalization.DateTimeFormatting.MinuteFormat,
includeMonth: Windows$Windows$Globalization.DateTimeFormatting.MonthFormat,
includeSecond: Windows$Windows$Globalization.DateTimeFormatting.SecondFormat,
includeYear: Windows$Windows$Globalization.DateTimeFormatting.YearFormat,
languages: Windows$Windows$Foundation.Collections.IVectorView<string>,
numeralSystem: string,
patterns: Windows$Windows$Foundation.Collections.IVectorView<string>,
resolvedGeographicRegion: string,
resolvedLanguage: string,
template: string,
format(value: Date): string
} 
	declare export interface IDateTimeFormatterFactory {
createDateTimeFormatter(
formatTemplate: string): Windows$Windows$Globalization.DateTimeFormatting.DateTimeFormatter,
createDateTimeFormatterLanguages(
formatTemplate: string,
languages: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Globalization.DateTimeFormatting.DateTimeFormatter,
createDateTimeFormatterContext(
formatTemplate: string,
languages: Windows$Windows$Foundation.Collections.IIterable<string>,
geographicRegion: string,
calendar: string,
clock: string): Windows$Windows$Globalization.DateTimeFormatting.DateTimeFormatter,
createDateTimeFormatterDate(
yearFormat: Windows$Windows$Globalization.DateTimeFormatting.YearFormat,
monthFormat: Windows$Windows$Globalization.DateTimeFormatting.MonthFormat,
dayFormat: Windows$Windows$Globalization.DateTimeFormatting.DayFormat,
dayOfWeekFormat: Windows$Windows$Globalization.DateTimeFormatting.DayOfWeekFormat): Windows$Windows$Globalization.DateTimeFormatting.DateTimeFormatter,
createDateTimeFormatterTime(
hourFormat: Windows$Windows$Globalization.DateTimeFormatting.HourFormat,
minuteFormat: Windows$Windows$Globalization.DateTimeFormatting.MinuteFormat,
secondFormat: Windows$Windows$Globalization.DateTimeFormatting.SecondFormat): Windows$Windows$Globalization.DateTimeFormatting.DateTimeFormatter,
createDateTimeFormatterDateTimeLanguages(
yearFormat: Windows$Windows$Globalization.DateTimeFormatting.YearFormat,
monthFormat: Windows$Windows$Globalization.DateTimeFormatting.MonthFormat,
dayFormat: Windows$Windows$Globalization.DateTimeFormatting.DayFormat,
dayOfWeekFormat: Windows$Windows$Globalization.DateTimeFormatting.DayOfWeekFormat,
hourFormat: Windows$Windows$Globalization.DateTimeFormatting.HourFormat,
minuteFormat: Windows$Windows$Globalization.DateTimeFormatting.MinuteFormat,
secondFormat: Windows$Windows$Globalization.DateTimeFormatting.SecondFormat,
languages: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Globalization.DateTimeFormatting.DateTimeFormatter,
createDateTimeFormatterDateTimeContext(
yearFormat: Windows$Windows$Globalization.DateTimeFormatting.YearFormat,
monthFormat: Windows$Windows$Globalization.DateTimeFormatting.MonthFormat,
dayFormat: Windows$Windows$Globalization.DateTimeFormatting.DayFormat,
dayOfWeekFormat: Windows$Windows$Globalization.DateTimeFormatting.DayOfWeekFormat,
hourFormat: Windows$Windows$Globalization.DateTimeFormatting.HourFormat,
minuteFormat: Windows$Windows$Globalization.DateTimeFormatting.MinuteFormat,
secondFormat: Windows$Windows$Globalization.DateTimeFormatting.SecondFormat,
languages: Windows$Windows$Foundation.Collections.IIterable<string>,
geographicRegion: string,
calendar: string,
clock: string): Windows$Windows$Globalization.DateTimeFormatting.DateTimeFormatter
} 
	declare export class DateTimeFormatter mixins undefined.IDateTimeFormatter {
constructor(formatTemplate: string): this;
constructor(formatTemplate: string, languages: Windows$Windows$Foundation.Collections.IIterable<string>): this;
constructor(formatTemplate: string, languages: Windows$Windows$Foundation.Collections.IIterable<string>, geographicRegion: string, calendar: string, clock: string): this;
constructor(yearFormat: Windows$Windows$Globalization.DateTimeFormatting.YearFormat, monthFormat: Windows$Windows$Globalization.DateTimeFormatting.MonthFormat, dayFormat: Windows$Windows$Globalization.DateTimeFormatting.DayFormat, dayOfWeekFormat: Windows$Windows$Globalization.DateTimeFormatting.DayOfWeekFormat): this;
constructor(hourFormat: Windows$Windows$Globalization.DateTimeFormatting.HourFormat, minuteFormat: Windows$Windows$Globalization.DateTimeFormatting.MinuteFormat, secondFormat: Windows$Windows$Globalization.DateTimeFormatting.SecondFormat): this;
constructor(yearFormat: Windows$Windows$Globalization.DateTimeFormatting.YearFormat, monthFormat: Windows$Windows$Globalization.DateTimeFormatting.MonthFormat, dayFormat: Windows$Windows$Globalization.DateTimeFormatting.DayFormat, dayOfWeekFormat: Windows$Windows$Globalization.DateTimeFormatting.DayOfWeekFormat, hourFormat: Windows$Windows$Globalization.DateTimeFormatting.HourFormat, minuteFormat: Windows$Windows$Globalization.DateTimeFormatting.MinuteFormat, secondFormat: Windows$Windows$Globalization.DateTimeFormatting.SecondFormat, languages: Windows$Windows$Foundation.Collections.IIterable<string>): this;
constructor(yearFormat: Windows$Windows$Globalization.DateTimeFormatting.YearFormat, monthFormat: Windows$Windows$Globalization.DateTimeFormatting.MonthFormat, dayFormat: Windows$Windows$Globalization.DateTimeFormatting.DayFormat, dayOfWeekFormat: Windows$Windows$Globalization.DateTimeFormatting.DayOfWeekFormat, hourFormat: Windows$Windows$Globalization.DateTimeFormatting.HourFormat, minuteFormat: Windows$Windows$Globalization.DateTimeFormatting.MinuteFormat, secondFormat: Windows$Windows$Globalization.DateTimeFormatting.SecondFormat, languages: Windows$Windows$Foundation.Collections.IIterable<string>, geographicRegion: string, calendar: string, clock: string): this;
calendar: string;
clock: string;
geographicRegion: string;
includeDay: Windows$Windows$Globalization.DateTimeFormatting.DayFormat;
includeDayOfWeek: Windows$Windows$Globalization.DateTimeFormatting.DayOfWeekFormat;
includeHour: Windows$Windows$Globalization.DateTimeFormatting.HourFormat;
includeMinute: Windows$Windows$Globalization.DateTimeFormatting.MinuteFormat;
includeMonth: Windows$Windows$Globalization.DateTimeFormatting.MonthFormat;
includeSecond: Windows$Windows$Globalization.DateTimeFormatting.SecondFormat;
includeYear: Windows$Windows$Globalization.DateTimeFormatting.YearFormat;
languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
numeralSystem: string;
patterns: Windows$Windows$Foundation.Collections.IVectorView<string>;
resolvedGeographicRegion: string;
resolvedLanguage: string;
template: string;
format(value: Date): string;
static longDate: Windows$Windows$Globalization.DateTimeFormatting.DateTimeFormatter;
static longTime: Windows$Windows$Globalization.DateTimeFormatting.DateTimeFormatter;
static shortDate: Windows$Windows$Globalization.DateTimeFormatting.DateTimeFormatter;
static shortTime: Windows$Windows$Globalization.DateTimeFormatting.DateTimeFormatter
}
	declare export interface IDateTimeFormatterStatics {
longDate: Windows$Windows$Globalization.DateTimeFormatting.DateTimeFormatter,
longTime: Windows$Windows$Globalization.DateTimeFormatting.DateTimeFormatter,
shortDate: Windows$Windows$Globalization.DateTimeFormatting.DateTimeFormatter,
shortTime: Windows$Windows$Globalization.DateTimeFormatting.DateTimeFormatter
} 
    }

	declare module 'NumberFormatting' {
        declare export interface INumberFormatter {
format(value: number): string
} 
	declare export interface INumberFormatter2 {
formatInt(value: number): string,
formatUInt(value: number): string,
formatDouble(value: number): string
} 
	declare export interface INumberParser {
parseInt(text: string): number,
parseUInt(text: string): number,
parseDouble(text: string): number
} 
	declare export interface INumberFormatterOptions {
fractionDigits: number,
geographicRegion: string,
integerDigits: number,
isDecimalPointAlwaysDisplayed: boolean,
isGrouped: boolean,
languages: Windows$Windows$Foundation.Collections.IVectorView<string>,
numeralSystem: string,
resolvedGeographicRegion: string,
resolvedLanguage: string
} 
	declare export interface IDecimalFormatterFactory {
createDecimalFormatter(
languages: Windows$Windows$Foundation.Collections.IIterable<string>,
geographicRegion: string): Windows$Windows$Globalization.NumberFormatting.DecimalFormatter
} 
	declare export class DecimalFormatter mixins undefined.INumberFormatterOptions, undefined.INumberFormatter, undefined.INumberFormatter2, undefined.INumberParser {
constructor(languages: Windows$Windows$Foundation.Collections.IIterable<string>, geographicRegion: string): this;
constructor(): this;
fractionDigits: number;
geographicRegion: string;
integerDigits: number;
isDecimalPointAlwaysDisplayed: boolean;
isGrouped: boolean;
languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
numeralSystem: string;
resolvedGeographicRegion: string;
resolvedLanguage: string;
format(value: number): string;
formatInt(value: number): string;
formatUInt(value: number): string;
formatDouble(value: number): string;
parseInt(text: string): number;
parseUInt(text: string): number;
parseDouble(text: string): number
}
	declare export interface IPercentFormatterFactory {
createPercentFormatter(
languages: Windows$Windows$Foundation.Collections.IIterable<string>,
geographicRegion: string): Windows$Windows$Globalization.NumberFormatting.PercentFormatter
} 
	declare export class PercentFormatter mixins undefined.INumberFormatterOptions, undefined.INumberFormatter, undefined.INumberFormatter2, undefined.INumberParser {
constructor(languages: Windows$Windows$Foundation.Collections.IIterable<string>, geographicRegion: string): this;
constructor(): this;
fractionDigits: number;
geographicRegion: string;
integerDigits: number;
isDecimalPointAlwaysDisplayed: boolean;
isGrouped: boolean;
languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
numeralSystem: string;
resolvedGeographicRegion: string;
resolvedLanguage: string;
format(value: number): string;
formatInt(value: number): string;
formatUInt(value: number): string;
formatDouble(value: number): string;
parseInt(text: string): number;
parseUInt(text: string): number;
parseDouble(text: string): number
}
	declare export interface IPermilleFormatterFactory {
createPermilleFormatter(
languages: Windows$Windows$Foundation.Collections.IIterable<string>,
geographicRegion: string): Windows$Windows$Globalization.NumberFormatting.PermilleFormatter
} 
	declare export class PermilleFormatter mixins undefined.INumberFormatterOptions, undefined.INumberFormatter, undefined.INumberFormatter2, undefined.INumberParser {
constructor(languages: Windows$Windows$Foundation.Collections.IIterable<string>, geographicRegion: string): this;
constructor(): this;
fractionDigits: number;
geographicRegion: string;
integerDigits: number;
isDecimalPointAlwaysDisplayed: boolean;
isGrouped: boolean;
languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
numeralSystem: string;
resolvedGeographicRegion: string;
resolvedLanguage: string;
format(value: number): string;
formatInt(value: number): string;
formatUInt(value: number): string;
formatDouble(value: number): string;
parseInt(text: string): number;
parseUInt(text: string): number;
parseDouble(text: string): number
}
	declare export interface ICurrencyFormatterFactory {
createCurrencyFormatterCode(
currencyCode: string): Windows$Windows$Globalization.NumberFormatting.CurrencyFormatter,
createCurrencyFormatterCodeContext(
currencyCode: string,
languages: Windows$Windows$Foundation.Collections.IIterable<string>,
geographicRegion: string): Windows$Windows$Globalization.NumberFormatting.CurrencyFormatter
} 
	declare export class CurrencyFormatter mixins undefined.ICurrencyFormatter, undefined.INumberFormatterOptions, undefined.INumberFormatter, undefined.INumberFormatter2, undefined.INumberParser {
constructor(currencyCode: string): this;
constructor(currencyCode: string, languages: Windows$Windows$Foundation.Collections.IIterable<string>, geographicRegion: string): this;
currency: string;
fractionDigits: number;
geographicRegion: string;
integerDigits: number;
isDecimalPointAlwaysDisplayed: boolean;
isGrouped: boolean;
languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
numeralSystem: string;
resolvedGeographicRegion: string;
resolvedLanguage: string;
format(value: number): string;
formatInt(value: number): string;
formatUInt(value: number): string;
formatDouble(value: number): string;
parseInt(text: string): number;
parseUInt(text: string): number;
parseDouble(text: string): number
}
	declare export type ICurrencyFormatter = {
currency: string
} & undefined.INumberFormatterOptions & undefined.INumberFormatter & undefined.INumberFormatter2 & undefined.INumberParser

    }

	declare module 'Collation' {
        declare export interface ICharacterGrouping {
first: string,
label: string
} 
	declare export class CharacterGrouping mixins undefined.ICharacterGrouping {
first: string;
label: string
}
	declare export type ICharacterGroupings = {
lookup(text: string): string
} & undefined.IVectorView<Windows$Windows$Globalization.Collation.CharacterGrouping> & undefined.IIterable<Windows$Windows$Globalization.Collation.CharacterGrouping>

	declare export class CharacterGroupings mixins undefined.ICharacterGroupings, undefined.IVectorView<Windows$Windows$Globalization.Collation.CharacterGrouping>, undefined.IIterable<Windows$Windows$Globalization.Collation.CharacterGrouping> {
size: number;
lookup(text: string): string;
getAt(index: number): Windows$Windows$Globalization.Collation.CharacterGrouping;
indexOf(
value: Windows$Windows$Globalization.Collation.CharacterGrouping): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$Globalization.Collation.CharacterGrouping[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Globalization.Collation.CharacterGrouping>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$Globalization.Collation.CharacterGrouping[][]): Windows$Windows$Globalization.Collation.CharacterGrouping[];
join(seperator: string): string;
pop(): Windows$Windows$Globalization.Collation.CharacterGrouping;
push(...items: Windows$Windows$Globalization.Collation.CharacterGrouping[]): void;
reverse(): Windows$Windows$Globalization.Collation.CharacterGrouping[];
shift(): Windows$Windows$Globalization.Collation.CharacterGrouping;
slice(start: number): Windows$Windows$Globalization.Collation.CharacterGrouping[];
slice(
start: number,
end: number): Windows$Windows$Globalization.Collation.CharacterGrouping[];
sort(): Windows$Windows$Globalization.Collation.CharacterGrouping[];
sort(
compareFn: (
a: Windows$Windows$Globalization.Collation.CharacterGrouping,
b: Windows$Windows$Globalization.Collation.CharacterGrouping) => number): Windows$Windows$Globalization.Collation.CharacterGrouping[];
splice(start: number): Windows$Windows$Globalization.Collation.CharacterGrouping[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$Globalization.Collation.CharacterGrouping[]): Windows$Windows$Globalization.Collation.CharacterGrouping[];
unshift(...items: Windows$Windows$Globalization.Collation.CharacterGrouping[]): number;
lastIndexOf(
searchElement: Windows$Windows$Globalization.Collation.CharacterGrouping): number;
lastIndexOf(
searchElement: Windows$Windows$Globalization.Collation.CharacterGrouping,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$Globalization.Collation.CharacterGrouping,
index: number,
array: Windows$Windows$Globalization.Collation.CharacterGrouping[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$Globalization.Collation.CharacterGrouping,
index: number,
array: Windows$Windows$Globalization.Collation.CharacterGrouping[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$Globalization.Collation.CharacterGrouping,
index: number,
array: Windows$Windows$Globalization.Collation.CharacterGrouping[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$Globalization.Collation.CharacterGrouping,
index: number,
array: Windows$Windows$Globalization.Collation.CharacterGrouping[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$Globalization.Collation.CharacterGrouping,
index: number,
array: Windows$Windows$Globalization.Collation.CharacterGrouping[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$Globalization.Collation.CharacterGrouping,
index: number,
array: Windows$Windows$Globalization.Collation.CharacterGrouping[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$Globalization.Collation.CharacterGrouping,
index: number,
array: Windows$Windows$Globalization.Collation.CharacterGrouping[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$Globalization.Collation.CharacterGrouping,
index: number,
array: Windows$Windows$Globalization.Collation.CharacterGrouping[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$Globalization.Collation.CharacterGrouping,
index: number,
array: Windows$Windows$Globalization.Collation.CharacterGrouping[]) => boolean): Windows$Windows$Globalization.Collation.CharacterGrouping[];
filter(
callbackfn: (
value: Windows$Windows$Globalization.Collation.CharacterGrouping,
index: number,
array: Windows$Windows$Globalization.Collation.CharacterGrouping[]) => boolean,
thisArg: any): Windows$Windows$Globalization.Collation.CharacterGrouping[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Globalization.Collation.CharacterGrouping[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Globalization.Collation.CharacterGrouping[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Globalization.Collation.CharacterGrouping[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Globalization.Collation.CharacterGrouping[]) => any,
initialValue: any): any;
length: number
}
    }

    }


declare module 'Graphics' {
        declare module 'Display' {
        declare export interface DisplayPropertiesEventHandler {
(sender: any): void
} 
	declare export  class DisplayOrientations {
  constructor(...args: empty): mixed;
static +none: Class<DisplayOrientations__none> & DisplayOrientations__none & 0;// 0
static +landscape: Class<DisplayOrientations__landscape> & DisplayOrientations__landscape & 1;// 1
static +portrait: Class<DisplayOrientations__portrait> & DisplayOrientations__portrait & 2;// 2
static +landscapeFlipped: Class<DisplayOrientations__landscapeFlipped> & DisplayOrientations__landscapeFlipped & 3;// 3
static +portraitFlipped: Class<DisplayOrientations__portraitFlipped> & DisplayOrientations__portraitFlipped & 4;// 4

}

declare class DisplayOrientations__none mixins DisplayOrientations {}
declare class DisplayOrientations__landscape mixins DisplayOrientations {}
declare class DisplayOrientations__portrait mixins DisplayOrientations {}
declare class DisplayOrientations__landscapeFlipped mixins DisplayOrientations {}
declare class DisplayOrientations__portraitFlipped mixins DisplayOrientations {}

	declare export  class ResolutionScale {
  constructor(...args: empty): mixed;
static +invalid: Class<ResolutionScale__invalid> & ResolutionScale__invalid & 0;// 0
static +scale100Percent: Class<ResolutionScale__scale100Percent> & ResolutionScale__scale100Percent & 1;// 1
static +scale140Percent: Class<ResolutionScale__scale140Percent> & ResolutionScale__scale140Percent & 2;// 2
static +scale180Percent: Class<ResolutionScale__scale180Percent> & ResolutionScale__scale180Percent & 3;// 3

}

declare class ResolutionScale__invalid mixins ResolutionScale {}
declare class ResolutionScale__scale100Percent mixins ResolutionScale {}
declare class ResolutionScale__scale140Percent mixins ResolutionScale {}
declare class ResolutionScale__scale180Percent mixins ResolutionScale {}

	declare export interface IDisplayPropertiesStatics {
autoRotationPreferences: Windows$Windows$Graphics.Display.DisplayOrientations,
currentOrientation: Windows$Windows$Graphics.Display.DisplayOrientations,
logicalDpi: number,
nativeOrientation: Windows$Windows$Graphics.Display.DisplayOrientations,
resolutionScale: Windows$Windows$Graphics.Display.ResolutionScale,
stereoEnabled: boolean,
onorientationchanged: any,
onlogicaldpichanged: any,
onstereoenabledchanged: any,
getColorProfileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IRandomAccessStream>,
oncolorprofilechanged: any,
ondisplaycontentsinvalidated: any
} 
	declare export class DisplayProperties  {
static autoRotationPreferences: Windows$Windows$Graphics.Display.DisplayOrientations;
static currentOrientation: Windows$Windows$Graphics.Display.DisplayOrientations;
static logicalDpi: number;
static nativeOrientation: Windows$Windows$Graphics.Display.DisplayOrientations;
static resolutionScale: Windows$Windows$Graphics.Display.ResolutionScale;
static stereoEnabled: boolean;
static onorientationchanged: any;
static onlogicaldpichanged: any;
static onstereoenabledchanged: any;
static getColorProfileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IRandomAccessStream>;
static oncolorprofilechanged: any;
static ondisplaycontentsinvalidated: any
}
	declare export interface IDisplayRequest {
requestActive(): void,
requestRelease(): void
} 
	declare export class DisplayRequest mixins undefined.IDisplayRequest {
requestActive(): void;
requestRelease(): void
}
    }

	declare module 'Imaging' {
        declare export  class BitmapPixelFormat {
  constructor(...args: empty): mixed;
static +unknown: Class<BitmapPixelFormat__unknown> & BitmapPixelFormat__unknown & 0;// 0
static +rgba16: Class<BitmapPixelFormat__rgba16> & BitmapPixelFormat__rgba16 & 1;// 1
static +rgba8: Class<BitmapPixelFormat__rgba8> & BitmapPixelFormat__rgba8 & 2;// 2
static +bgra8: Class<BitmapPixelFormat__bgra8> & BitmapPixelFormat__bgra8 & 3;// 3

}

declare class BitmapPixelFormat__unknown mixins BitmapPixelFormat {}
declare class BitmapPixelFormat__rgba16 mixins BitmapPixelFormat {}
declare class BitmapPixelFormat__rgba8 mixins BitmapPixelFormat {}
declare class BitmapPixelFormat__bgra8 mixins BitmapPixelFormat {}

	declare export  class BitmapAlphaMode {
  constructor(...args: empty): mixed;
static +premultiplied: Class<BitmapAlphaMode__premultiplied> & BitmapAlphaMode__premultiplied & 0;// 0
static +straight: Class<BitmapAlphaMode__straight> & BitmapAlphaMode__straight & 1;// 1
static +ignore: Class<BitmapAlphaMode__ignore> & BitmapAlphaMode__ignore & 2;// 2

}

declare class BitmapAlphaMode__premultiplied mixins BitmapAlphaMode {}
declare class BitmapAlphaMode__straight mixins BitmapAlphaMode {}
declare class BitmapAlphaMode__ignore mixins BitmapAlphaMode {}

	declare export  class BitmapInterpolationMode {
  constructor(...args: empty): mixed;
static +nearestNeighbor: Class<BitmapInterpolationMode__nearestNeighbor> & BitmapInterpolationMode__nearestNeighbor & 0;// 0
static +linear: Class<BitmapInterpolationMode__linear> & BitmapInterpolationMode__linear & 1;// 1
static +cubic: Class<BitmapInterpolationMode__cubic> & BitmapInterpolationMode__cubic & 2;// 2
static +fant: Class<BitmapInterpolationMode__fant> & BitmapInterpolationMode__fant & 3;// 3

}

declare class BitmapInterpolationMode__nearestNeighbor mixins BitmapInterpolationMode {}
declare class BitmapInterpolationMode__linear mixins BitmapInterpolationMode {}
declare class BitmapInterpolationMode__cubic mixins BitmapInterpolationMode {}
declare class BitmapInterpolationMode__fant mixins BitmapInterpolationMode {}

	declare export  class BitmapFlip {
  constructor(...args: empty): mixed;
static +none: Class<BitmapFlip__none> & BitmapFlip__none & 0;// 0
static +horizontal: Class<BitmapFlip__horizontal> & BitmapFlip__horizontal & 1;// 1
static +vertical: Class<BitmapFlip__vertical> & BitmapFlip__vertical & 2;// 2

}

declare class BitmapFlip__none mixins BitmapFlip {}
declare class BitmapFlip__horizontal mixins BitmapFlip {}
declare class BitmapFlip__vertical mixins BitmapFlip {}

	declare export  class BitmapRotation {
  constructor(...args: empty): mixed;
static +none: Class<BitmapRotation__none> & BitmapRotation__none & 0;// 0
static +clockwise90Degrees: Class<BitmapRotation__clockwise90Degrees> & BitmapRotation__clockwise90Degrees & 1;// 1
static +clockwise180Degrees: Class<BitmapRotation__clockwise180Degrees> & BitmapRotation__clockwise180Degrees & 2;// 2
static +clockwise270Degrees: Class<BitmapRotation__clockwise270Degrees> & BitmapRotation__clockwise270Degrees & 3;// 3

}

declare class BitmapRotation__none mixins BitmapRotation {}
declare class BitmapRotation__clockwise90Degrees mixins BitmapRotation {}
declare class BitmapRotation__clockwise180Degrees mixins BitmapRotation {}
declare class BitmapRotation__clockwise270Degrees mixins BitmapRotation {}

	declare export interface BitmapBounds {
x: number,
y: number,
width: number,
height: number
} 
	declare export  class ColorManagementMode {
  constructor(...args: empty): mixed;
static +doNotColorManage: Class<ColorManagementMode__doNotColorManage> & ColorManagementMode__doNotColorManage & 0;// 0
static +colorManageToSRgb: Class<ColorManagementMode__colorManageToSRgb> & ColorManagementMode__colorManageToSRgb & 1;// 1

}

declare class ColorManagementMode__doNotColorManage mixins ColorManagementMode {}
declare class ColorManagementMode__colorManageToSRgb mixins ColorManagementMode {}

	declare export  class ExifOrientationMode {
  constructor(...args: empty): mixed;
static +ignoreExifOrientation: Class<ExifOrientationMode__ignoreExifOrientation> & ExifOrientationMode__ignoreExifOrientation & 0;// 0
static +respectExifOrientation: Class<ExifOrientationMode__respectExifOrientation> & ExifOrientationMode__respectExifOrientation & 1;// 1

}

declare class ExifOrientationMode__ignoreExifOrientation mixins ExifOrientationMode {}
declare class ExifOrientationMode__respectExifOrientation mixins ExifOrientationMode {}

	declare export  class PngFilterMode {
  constructor(...args: empty): mixed;
static +automatic: Class<PngFilterMode__automatic> & PngFilterMode__automatic & 0;// 0
static +none: Class<PngFilterMode__none> & PngFilterMode__none & 1;// 1
static +sub: Class<PngFilterMode__sub> & PngFilterMode__sub & 2;// 2
static +up: Class<PngFilterMode__up> & PngFilterMode__up & 3;// 3
static +average: Class<PngFilterMode__average> & PngFilterMode__average & 4;// 4
static +paeth: Class<PngFilterMode__paeth> & PngFilterMode__paeth & 5;// 5
static +adaptive: Class<PngFilterMode__adaptive> & PngFilterMode__adaptive & 6;// 6

}

declare class PngFilterMode__automatic mixins PngFilterMode {}
declare class PngFilterMode__none mixins PngFilterMode {}
declare class PngFilterMode__sub mixins PngFilterMode {}
declare class PngFilterMode__up mixins PngFilterMode {}
declare class PngFilterMode__average mixins PngFilterMode {}
declare class PngFilterMode__paeth mixins PngFilterMode {}
declare class PngFilterMode__adaptive mixins PngFilterMode {}

	declare export  class TiffCompressionMode {
  constructor(...args: empty): mixed;
static +automatic: Class<TiffCompressionMode__automatic> & TiffCompressionMode__automatic & 0;// 0
static +none: Class<TiffCompressionMode__none> & TiffCompressionMode__none & 1;// 1
static +ccitt3: Class<TiffCompressionMode__ccitt3> & TiffCompressionMode__ccitt3 & 2;// 2
static +ccitt4: Class<TiffCompressionMode__ccitt4> & TiffCompressionMode__ccitt4 & 3;// 3
static +lzw: Class<TiffCompressionMode__lzw> & TiffCompressionMode__lzw & 4;// 4
static +rle: Class<TiffCompressionMode__rle> & TiffCompressionMode__rle & 5;// 5
static +zip: Class<TiffCompressionMode__zip> & TiffCompressionMode__zip & 6;// 6
static +lzwhDifferencing: Class<TiffCompressionMode__lzwhDifferencing> & TiffCompressionMode__lzwhDifferencing & 7;// 7

}

declare class TiffCompressionMode__automatic mixins TiffCompressionMode {}
declare class TiffCompressionMode__none mixins TiffCompressionMode {}
declare class TiffCompressionMode__ccitt3 mixins TiffCompressionMode {}
declare class TiffCompressionMode__ccitt4 mixins TiffCompressionMode {}
declare class TiffCompressionMode__lzw mixins TiffCompressionMode {}
declare class TiffCompressionMode__rle mixins TiffCompressionMode {}
declare class TiffCompressionMode__zip mixins TiffCompressionMode {}
declare class TiffCompressionMode__lzwhDifferencing mixins TiffCompressionMode {}

	declare export  class JpegSubsamplingMode {
  constructor(...args: empty): mixed;
static +default: Class<JpegSubsamplingMode__default> & JpegSubsamplingMode__default & 0;// 0
static +y4Cb2Cr0: Class<JpegSubsamplingMode__y4Cb2Cr0> & JpegSubsamplingMode__y4Cb2Cr0 & 1;// 1
static +y4Cb2Cr2: Class<JpegSubsamplingMode__y4Cb2Cr2> & JpegSubsamplingMode__y4Cb2Cr2 & 2;// 2
static +y4Cb4Cr4: Class<JpegSubsamplingMode__y4Cb4Cr4> & JpegSubsamplingMode__y4Cb4Cr4 & 3;// 3

}

declare class JpegSubsamplingMode__default mixins JpegSubsamplingMode {}
declare class JpegSubsamplingMode__y4Cb2Cr0 mixins JpegSubsamplingMode {}
declare class JpegSubsamplingMode__y4Cb2Cr2 mixins JpegSubsamplingMode {}
declare class JpegSubsamplingMode__y4Cb4Cr4 mixins JpegSubsamplingMode {}

	declare export interface IBitmapTransform {
bounds: Windows$Windows$Graphics.Imaging.BitmapBounds,
flip: Windows$Windows$Graphics.Imaging.BitmapFlip,
interpolationMode: Windows$Windows$Graphics.Imaging.BitmapInterpolationMode,
rotation: Windows$Windows$Graphics.Imaging.BitmapRotation,
scaledHeight: number,
scaledWidth: number
} 
	declare export class BitmapTransform mixins undefined.IBitmapTransform {
bounds: Windows$Windows$Graphics.Imaging.BitmapBounds;
flip: Windows$Windows$Graphics.Imaging.BitmapFlip;
interpolationMode: Windows$Windows$Graphics.Imaging.BitmapInterpolationMode;
rotation: Windows$Windows$Graphics.Imaging.BitmapRotation;
scaledHeight: number;
scaledWidth: number
}
	declare export interface IBitmapTypedValue {
type: Windows$Windows$Foundation.PropertyType,
value: any
} 
	declare export interface IBitmapTypedValueFactory {
create(
value: any,
type: Windows$Windows$Foundation.PropertyType): Windows$Windows$Graphics.Imaging.BitmapTypedValue
} 
	declare export class BitmapTypedValue mixins undefined.IBitmapTypedValue {
constructor(value: any, type: Windows$Windows$Foundation.PropertyType): this;
type: Windows$Windows$Foundation.PropertyType;
value: any
}
	declare export class BitmapPropertySet mixins undefined.IMap<string, Windows$Windows$Graphics.Imaging.BitmapTypedValue>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$Graphics.Imaging.BitmapTypedValue>> {
size: number;
lookup(key: string): Windows$Windows$Graphics.Imaging.BitmapTypedValue;
hasKey(key: string): boolean;
getView(
): Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$Graphics.Imaging.BitmapTypedValue>;
insert(key: string, value: Windows$Windows$Graphics.Imaging.BitmapTypedValue): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$Graphics.Imaging.BitmapTypedValue>>
}
	declare export interface IBitmapPropertiesView {
getPropertiesAsync(
propertiesToRetrieve: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapPropertySet>
} 
	declare export type IBitmapProperties = {
setPropertiesAsync(
propertiesToSet: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$Graphics.Imaging.BitmapTypedValue>>): Windows$Windows$Foundation.IAsyncAction
} & undefined.IBitmapPropertiesView

	declare export class BitmapPropertiesView mixins undefined.IBitmapPropertiesView {
getPropertiesAsync(
propertiesToRetrieve: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapPropertySet>
}
	declare export class BitmapProperties mixins undefined.IBitmapProperties, undefined.IBitmapPropertiesView {
setPropertiesAsync(
propertiesToSet: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$Graphics.Imaging.BitmapTypedValue>>): Windows$Windows$Foundation.IAsyncAction;
getPropertiesAsync(
propertiesToRetrieve: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapPropertySet>
}
	declare export interface IPixelDataProvider {
detachPixelData(): Uint8Array
} 
	declare export class PixelDataProvider mixins undefined.IPixelDataProvider {
detachPixelData(): Uint8Array
}
	declare export class ImageStream mixins undefined.IRandomAccessStreamWithContentType, undefined.IRandomAccessStream, undefined.IClosable, undefined.IInputStream, undefined.IOutputStream, undefined.IContentTypeProvider {
canRead: boolean;
canWrite: boolean;
position: number;
size: number;
contentType: string;
getInputStreamAt(position: number): Windows$Windows$Storage.Streams.IInputStream;
getOutputStreamAt(position: number): Windows$Windows$Storage.Streams.IOutputStream;
seek(position: number): void;
cloneStream(): Windows$Windows$Storage.Streams.IRandomAccessStream;
dispose(): void;
readAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer,
count: number,
options: Windows$Windows$Storage.Streams.InputStreamOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Storage.Streams.IBuffer, number>;
writeAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
flushAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
close(): void
}
	declare export interface IBitmapFrame {
bitmapAlphaMode: Windows$Windows$Graphics.Imaging.BitmapAlphaMode,
bitmapPixelFormat: Windows$Windows$Graphics.Imaging.BitmapPixelFormat,
bitmapProperties: Windows$Windows$Graphics.Imaging.BitmapPropertiesView,
dpiX: number,
dpiY: number,
orientedPixelHeight: number,
orientedPixelWidth: number,
pixelHeight: number,
pixelWidth: number,
getThumbnailAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.ImageStream>,
getPixelDataAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.PixelDataProvider>,
getPixelDataAsync(
pixelFormat: Windows$Windows$Graphics.Imaging.BitmapPixelFormat,
alphaMode: Windows$Windows$Graphics.Imaging.BitmapAlphaMode,
transform: Windows$Windows$Graphics.Imaging.BitmapTransform,
exifOrientationMode: Windows$Windows$Graphics.Imaging.ExifOrientationMode,
colorManagementMode: Windows$Windows$Graphics.Imaging.ColorManagementMode): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.PixelDataProvider>
} 
	declare export class BitmapFrame mixins undefined.IBitmapFrame {
bitmapAlphaMode: Windows$Windows$Graphics.Imaging.BitmapAlphaMode;
bitmapPixelFormat: Windows$Windows$Graphics.Imaging.BitmapPixelFormat;
bitmapProperties: Windows$Windows$Graphics.Imaging.BitmapPropertiesView;
dpiX: number;
dpiY: number;
orientedPixelHeight: number;
orientedPixelWidth: number;
pixelHeight: number;
pixelWidth: number;
getThumbnailAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.ImageStream>;
getPixelDataAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.PixelDataProvider>;
getPixelDataAsync(
pixelFormat: Windows$Windows$Graphics.Imaging.BitmapPixelFormat,
alphaMode: Windows$Windows$Graphics.Imaging.BitmapAlphaMode,
transform: Windows$Windows$Graphics.Imaging.BitmapTransform,
exifOrientationMode: Windows$Windows$Graphics.Imaging.ExifOrientationMode,
colorManagementMode: Windows$Windows$Graphics.Imaging.ColorManagementMode): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.PixelDataProvider>
}
	declare export interface IBitmapCodecInformation {
codecId: string,
fileExtensions: Windows$Windows$Foundation.Collections.IVectorView<string>,
friendlyName: string,
mimeTypes: Windows$Windows$Foundation.Collections.IVectorView<string>
} 
	declare export class BitmapCodecInformation mixins undefined.IBitmapCodecInformation {
codecId: string;
fileExtensions: Windows$Windows$Foundation.Collections.IVectorView<string>;
friendlyName: string;
mimeTypes: Windows$Windows$Foundation.Collections.IVectorView<string>
}
	declare export interface IBitmapDecoderStatics {
bmpDecoderId: string,
gifDecoderId: string,
icoDecoderId: string,
jpegDecoderId: string,
jpegXRDecoderId: string,
pngDecoderId: string,
tiffDecoderId: string,
getDecoderInformationEnumerator(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Graphics.Imaging.BitmapCodecInformation>,
createAsync(
stream: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapDecoder>,
createAsync(
decoderId: string,
stream: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapDecoder>
} 
	declare export class BitmapDecoder mixins undefined.IBitmapDecoder, undefined.IBitmapFrame {
bitmapContainerProperties: Windows$Windows$Graphics.Imaging.BitmapPropertiesView;
decoderInformation: Windows$Windows$Graphics.Imaging.BitmapCodecInformation;
frameCount: number;
bitmapAlphaMode: Windows$Windows$Graphics.Imaging.BitmapAlphaMode;
bitmapPixelFormat: Windows$Windows$Graphics.Imaging.BitmapPixelFormat;
bitmapProperties: Windows$Windows$Graphics.Imaging.BitmapPropertiesView;
dpiX: number;
dpiY: number;
orientedPixelHeight: number;
orientedPixelWidth: number;
pixelHeight: number;
pixelWidth: number;
getPreviewAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.ImageStream>;
getFrameAsync(
frameIndex: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapFrame>;
getThumbnailAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.ImageStream>;
getPixelDataAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.PixelDataProvider>;
getPixelDataAsync(
pixelFormat: Windows$Windows$Graphics.Imaging.BitmapPixelFormat,
alphaMode: Windows$Windows$Graphics.Imaging.BitmapAlphaMode,
transform: Windows$Windows$Graphics.Imaging.BitmapTransform,
exifOrientationMode: Windows$Windows$Graphics.Imaging.ExifOrientationMode,
colorManagementMode: Windows$Windows$Graphics.Imaging.ColorManagementMode): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.PixelDataProvider>;
static bmpDecoderId: string;
static gifDecoderId: string;
static icoDecoderId: string;
static jpegDecoderId: string;
static jpegXRDecoderId: string;
static pngDecoderId: string;
static tiffDecoderId: string;
static getDecoderInformationEnumerator(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Graphics.Imaging.BitmapCodecInformation>;
static createAsync(
stream: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapDecoder>;
static createAsync(
decoderId: string,
stream: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapDecoder>
}
	declare export interface IBitmapDecoder {
bitmapContainerProperties: Windows$Windows$Graphics.Imaging.BitmapPropertiesView,
decoderInformation: Windows$Windows$Graphics.Imaging.BitmapCodecInformation,
frameCount: number,
getPreviewAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.ImageStream>,
getFrameAsync(
frameIndex: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapFrame>
} 
	declare export interface IBitmapEncoderStatics {
bmpEncoderId: string,
gifEncoderId: string,
jpegEncoderId: string,
jpegXREncoderId: string,
pngEncoderId: string,
tiffEncoderId: string,
getEncoderInformationEnumerator(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Graphics.Imaging.BitmapCodecInformation>,
createAsync(
encoderId: string,
stream: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapEncoder>,
createAsync(
encoderId: string,
stream: Windows$Windows$Storage.Streams.IRandomAccessStream,
encodingOptions: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$Graphics.Imaging.BitmapTypedValue>>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapEncoder>,
createForTranscodingAsync(
stream: Windows$Windows$Storage.Streams.IRandomAccessStream,
bitmapDecoder: Windows$Windows$Graphics.Imaging.BitmapDecoder): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapEncoder>,
createForInPlacePropertyEncodingAsync(
bitmapDecoder: Windows$Windows$Graphics.Imaging.BitmapDecoder): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapEncoder>
} 
	declare export class BitmapEncoder mixins undefined.IBitmapEncoder {
bitmapContainerProperties: Windows$Windows$Graphics.Imaging.BitmapProperties;
bitmapProperties: Windows$Windows$Graphics.Imaging.BitmapProperties;
bitmapTransform: Windows$Windows$Graphics.Imaging.BitmapTransform;
encoderInformation: Windows$Windows$Graphics.Imaging.BitmapCodecInformation;
generatedThumbnailHeight: number;
generatedThumbnailWidth: number;
isThumbnailGenerated: boolean;
setPixelData(
pixelFormat: Windows$Windows$Graphics.Imaging.BitmapPixelFormat,
alphaMode: Windows$Windows$Graphics.Imaging.BitmapAlphaMode,
width: number,
height: number,
dpiX: number,
dpiY: number,
pixels: Uint8Array): void;
goToNextFrameAsync(): Windows$Windows$Foundation.IAsyncAction;
goToNextFrameAsync(
encodingOptions: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$Graphics.Imaging.BitmapTypedValue>>): Windows$Windows$Foundation.IAsyncAction;
flushAsync(): Windows$Windows$Foundation.IAsyncAction;
static bmpEncoderId: string;
static gifEncoderId: string;
static jpegEncoderId: string;
static jpegXREncoderId: string;
static pngEncoderId: string;
static tiffEncoderId: string;
static getEncoderInformationEnumerator(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Graphics.Imaging.BitmapCodecInformation>;
static createAsync(
encoderId: string,
stream: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapEncoder>;
static createAsync(
encoderId: string,
stream: Windows$Windows$Storage.Streams.IRandomAccessStream,
encodingOptions: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$Graphics.Imaging.BitmapTypedValue>>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapEncoder>;
static createForTranscodingAsync(
stream: Windows$Windows$Storage.Streams.IRandomAccessStream,
bitmapDecoder: Windows$Windows$Graphics.Imaging.BitmapDecoder): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapEncoder>;
static createForInPlacePropertyEncodingAsync(
bitmapDecoder: Windows$Windows$Graphics.Imaging.BitmapDecoder): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Graphics.Imaging.BitmapEncoder>
}
	declare export interface IBitmapEncoder {
bitmapContainerProperties: Windows$Windows$Graphics.Imaging.BitmapProperties,
bitmapProperties: Windows$Windows$Graphics.Imaging.BitmapProperties,
bitmapTransform: Windows$Windows$Graphics.Imaging.BitmapTransform,
encoderInformation: Windows$Windows$Graphics.Imaging.BitmapCodecInformation,
generatedThumbnailHeight: number,
generatedThumbnailWidth: number,
isThumbnailGenerated: boolean,
setPixelData(
pixelFormat: Windows$Windows$Graphics.Imaging.BitmapPixelFormat,
alphaMode: Windows$Windows$Graphics.Imaging.BitmapAlphaMode,
width: number,
height: number,
dpiX: number,
dpiY: number,
pixels: Uint8Array): void,
goToNextFrameAsync(): Windows$Windows$Foundation.IAsyncAction,
goToNextFrameAsync(
encodingOptions: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$Graphics.Imaging.BitmapTypedValue>>): Windows$Windows$Foundation.IAsyncAction,
flushAsync(): Windows$Windows$Foundation.IAsyncAction
} 
    }

	declare module 'Printing' {
        declare module 'OptionDetails' {
        declare export  class PrintOptionStates {
  constructor(...args: empty): mixed;
static +none: Class<PrintOptionStates__none> & PrintOptionStates__none & 0;// 0
static +enabled: Class<PrintOptionStates__enabled> & PrintOptionStates__enabled & 1;// 1
static +constrained: Class<PrintOptionStates__constrained> & PrintOptionStates__constrained & 2;// 2

}

declare class PrintOptionStates__none mixins PrintOptionStates {}
declare class PrintOptionStates__enabled mixins PrintOptionStates {}
declare class PrintOptionStates__constrained mixins PrintOptionStates {}

	declare export  class PrintOptionType {
  constructor(...args: empty): mixed;
static +unknown: Class<PrintOptionType__unknown> & PrintOptionType__unknown & 0;// 0
static +number: Class<PrintOptionType__number> & PrintOptionType__number & 1;// 1
static +text: Class<PrintOptionType__text> & PrintOptionType__text & 2;// 2
static +itemList: Class<PrintOptionType__itemList> & PrintOptionType__itemList & 3;// 3

}

declare class PrintOptionType__unknown mixins PrintOptionType {}
declare class PrintOptionType__number mixins PrintOptionType {}
declare class PrintOptionType__text mixins PrintOptionType {}
declare class PrintOptionType__itemList mixins PrintOptionType {}

	declare export interface IPrintOptionDetails {
errorText: string,
optionId: string,
optionType: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionType,
state: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionStates,
value: any,
trySetValue(value: any): boolean
} 
	declare export type IPrintNumberOptionDetails = {
maxValue: number,
minValue: number
} & undefined.IPrintOptionDetails

	declare export type IPrintTextOptionDetails = {
maxCharacters: number
} & undefined.IPrintOptionDetails

	declare export type IPrintItemListOptionDetails = {
items: Windows$Windows$Foundation.Collections.IVectorView<any>
} & undefined.IPrintOptionDetails

	declare export class PrintCopiesOptionDetails mixins undefined.IPrintOptionDetails, undefined.IPrintNumberOptionDetails {
errorText: string;
optionId: string;
optionType: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionType;
state: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionStates;
value: any;
maxValue: number;
minValue: number;
trySetValue(value: any): boolean
}
	declare export class PrintMediaSizeOptionDetails mixins undefined.IPrintOptionDetails, undefined.IPrintItemListOptionDetails {
errorText: string;
optionId: string;
optionType: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionType;
state: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionStates;
value: any;
items: Windows$Windows$Foundation.Collections.IVectorView<any>;
trySetValue(value: any): boolean
}
	declare export class PrintMediaTypeOptionDetails mixins undefined.IPrintOptionDetails, undefined.IPrintItemListOptionDetails {
errorText: string;
optionId: string;
optionType: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionType;
state: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionStates;
value: any;
items: Windows$Windows$Foundation.Collections.IVectorView<any>;
trySetValue(value: any): boolean
}
	declare export class PrintOrientationOptionDetails mixins undefined.IPrintOptionDetails, undefined.IPrintItemListOptionDetails {
errorText: string;
optionId: string;
optionType: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionType;
state: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionStates;
value: any;
items: Windows$Windows$Foundation.Collections.IVectorView<any>;
trySetValue(value: any): boolean
}
	declare export class PrintQualityOptionDetails mixins undefined.IPrintOptionDetails, undefined.IPrintItemListOptionDetails {
errorText: string;
optionId: string;
optionType: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionType;
state: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionStates;
value: any;
items: Windows$Windows$Foundation.Collections.IVectorView<any>;
trySetValue(value: any): boolean
}
	declare export class PrintColorModeOptionDetails mixins undefined.IPrintOptionDetails, undefined.IPrintItemListOptionDetails {
errorText: string;
optionId: string;
optionType: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionType;
state: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionStates;
value: any;
items: Windows$Windows$Foundation.Collections.IVectorView<any>;
trySetValue(value: any): boolean
}
	declare export class PrintDuplexOptionDetails mixins undefined.IPrintOptionDetails, undefined.IPrintItemListOptionDetails {
errorText: string;
optionId: string;
optionType: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionType;
state: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionStates;
value: any;
items: Windows$Windows$Foundation.Collections.IVectorView<any>;
trySetValue(value: any): boolean
}
	declare export class PrintCollationOptionDetails mixins undefined.IPrintOptionDetails, undefined.IPrintItemListOptionDetails {
errorText: string;
optionId: string;
optionType: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionType;
state: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionStates;
value: any;
items: Windows$Windows$Foundation.Collections.IVectorView<any>;
trySetValue(value: any): boolean
}
	declare export class PrintStapleOptionDetails mixins undefined.IPrintOptionDetails, undefined.IPrintItemListOptionDetails {
errorText: string;
optionId: string;
optionType: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionType;
state: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionStates;
value: any;
items: Windows$Windows$Foundation.Collections.IVectorView<any>;
trySetValue(value: any): boolean
}
	declare export class PrintHolePunchOptionDetails mixins undefined.IPrintOptionDetails, undefined.IPrintItemListOptionDetails {
errorText: string;
optionId: string;
optionType: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionType;
state: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionStates;
value: any;
items: Windows$Windows$Foundation.Collections.IVectorView<any>;
trySetValue(value: any): boolean
}
	declare export class PrintBindingOptionDetails mixins undefined.IPrintOptionDetails, undefined.IPrintItemListOptionDetails {
errorText: string;
optionId: string;
optionType: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionType;
state: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionStates;
value: any;
items: Windows$Windows$Foundation.Collections.IVectorView<any>;
trySetValue(value: any): boolean
}
	declare export type IPrintCustomOptionDetails = {
displayName: string
} & undefined.IPrintOptionDetails

	declare export type IPrintCustomTextOptionDetails = {
maxCharacters: number
} & undefined.IPrintCustomOptionDetails & undefined.IPrintOptionDetails

	declare export class PrintCustomTextOptionDetails mixins undefined.IPrintOptionDetails, undefined.IPrintCustomOptionDetails, undefined.IPrintCustomTextOptionDetails {
errorText: string;
optionId: string;
optionType: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionType;
state: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionStates;
value: any;
displayName: string;
maxCharacters: number;
trySetValue(value: any): boolean
}
	declare export interface IPrintCustomItemDetails {
itemDisplayName: string,
itemId: string
} 
	declare export class PrintCustomItemDetails mixins undefined.IPrintCustomItemDetails {
itemDisplayName: string;
itemId: string
}
	declare export type IPrintCustomItemListOptionDetails = {
addItem(itemId: string, displayName: string): void
} & undefined.IPrintItemListOptionDetails & undefined.IPrintOptionDetails & undefined.IPrintCustomOptionDetails

	declare export class PrintCustomItemListOptionDetails mixins undefined.IPrintOptionDetails, undefined.IPrintCustomOptionDetails, undefined.IPrintItemListOptionDetails, undefined.IPrintCustomItemListOptionDetails {
errorText: string;
optionId: string;
optionType: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionType;
state: Windows$Windows$Graphics.Printing.OptionDetails.PrintOptionStates;
value: any;
displayName: string;
items: Windows$Windows$Foundation.Collections.IVectorView<any>;
trySetValue(value: any): boolean;
addItem(itemId: string, displayName: string): void
}
	declare export interface IPrintTaskOptionChangedEventArgs {
optionId: any
} 
	declare export class PrintTaskOptionChangedEventArgs mixins undefined.IPrintTaskOptionChangedEventArgs {
optionId: any
}
	declare export interface IPrintTaskOptionDetails {
options: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$Graphics.Printing.OptionDetails.IPrintOptionDetails>,
createItemListOption(
optionId: string,
displayName: string): Windows$Windows$Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails,
createTextOption(
optionId: string,
displayName: string): Windows$Windows$Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails,
onoptionchanged: any,
onbeginvalidation: any
} 
	declare export class PrintTaskOptionDetails mixins undefined.IPrintTaskOptionDetails, undefined.IPrintTaskOptionsCore, undefined.IPrintTaskOptionsCoreUIConfiguration {
options: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$Graphics.Printing.OptionDetails.IPrintOptionDetails>;
displayedOptions: Windows$Windows$Foundation.Collections.IVector<string>;
createItemListOption(
optionId: string,
displayName: string): Windows$Windows$Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails;
createTextOption(
optionId: string,
displayName: string): Windows$Windows$Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails;
onoptionchanged: any;
onbeginvalidation: any;
getPageDescription(jobPageNumber: number): Windows$Windows$Graphics.Printing.PrintPageDescription;
static getFromPrintTaskOptions(
printTaskOptions: Windows$Windows$Graphics.Printing.PrintTaskOptions): Windows$Windows$Graphics.Printing.OptionDetails.PrintTaskOptionDetails
}
	declare export interface IPrintTaskOptionDetailsStatic {
getFromPrintTaskOptions(
printTaskOptions: Windows$Windows$Graphics.Printing.PrintTaskOptions): Windows$Windows$Graphics.Printing.OptionDetails.PrintTaskOptionDetails
} 
    }

	declare export interface PrintPageDescription {
pageSize: Windows$Windows$Foundation.Size,
imageableRect: Windows$Windows$Foundation.Rect,
dpiX: number,
dpiY: number
} 
	declare export  class PrintMediaSize {
  constructor(...args: empty): mixed;
static +default: Class<PrintMediaSize__default> & PrintMediaSize__default & 0;// 0
static +notAvailable: Class<PrintMediaSize__notAvailable> & PrintMediaSize__notAvailable & 1;// 1
static +printerCustom: Class<PrintMediaSize__printerCustom> & PrintMediaSize__printerCustom & 2;// 2
static +businessCard: Class<PrintMediaSize__businessCard> & PrintMediaSize__businessCard & 3;// 3
static +creditCard: Class<PrintMediaSize__creditCard> & PrintMediaSize__creditCard & 4;// 4
static +isoA0: Class<PrintMediaSize__isoA0> & PrintMediaSize__isoA0 & 5;// 5
static +isoA1: Class<PrintMediaSize__isoA1> & PrintMediaSize__isoA1 & 6;// 6
static +isoA10: Class<PrintMediaSize__isoA10> & PrintMediaSize__isoA10 & 7;// 7
static +isoA2: Class<PrintMediaSize__isoA2> & PrintMediaSize__isoA2 & 8;// 8
static +isoA3: Class<PrintMediaSize__isoA3> & PrintMediaSize__isoA3 & 9;// 9
static +isoA3Extra: Class<PrintMediaSize__isoA3Extra> & PrintMediaSize__isoA3Extra & 10;// 10
static +isoA3Rotated: Class<PrintMediaSize__isoA3Rotated> & PrintMediaSize__isoA3Rotated & 11;// 11
static +isoA4: Class<PrintMediaSize__isoA4> & PrintMediaSize__isoA4 & 12;// 12
static +isoA4Extra: Class<PrintMediaSize__isoA4Extra> & PrintMediaSize__isoA4Extra & 13;// 13
static +isoA4Rotated: Class<PrintMediaSize__isoA4Rotated> & PrintMediaSize__isoA4Rotated & 14;// 14
static +isoA5: Class<PrintMediaSize__isoA5> & PrintMediaSize__isoA5 & 15;// 15
static +isoA5Extra: Class<PrintMediaSize__isoA5Extra> & PrintMediaSize__isoA5Extra & 16;// 16
static +isoA5Rotated: Class<PrintMediaSize__isoA5Rotated> & PrintMediaSize__isoA5Rotated & 17;// 17
static +isoA6: Class<PrintMediaSize__isoA6> & PrintMediaSize__isoA6 & 18;// 18
static +isoA6Rotated: Class<PrintMediaSize__isoA6Rotated> & PrintMediaSize__isoA6Rotated & 19;// 19
static +isoA7: Class<PrintMediaSize__isoA7> & PrintMediaSize__isoA7 & 20;// 20
static +isoA8: Class<PrintMediaSize__isoA8> & PrintMediaSize__isoA8 & 21;// 21
static +isoA9: Class<PrintMediaSize__isoA9> & PrintMediaSize__isoA9 & 22;// 22
static +isoB0: Class<PrintMediaSize__isoB0> & PrintMediaSize__isoB0 & 23;// 23
static +isoB1: Class<PrintMediaSize__isoB1> & PrintMediaSize__isoB1 & 24;// 24
static +isoB10: Class<PrintMediaSize__isoB10> & PrintMediaSize__isoB10 & 25;// 25
static +isoB2: Class<PrintMediaSize__isoB2> & PrintMediaSize__isoB2 & 26;// 26
static +isoB3: Class<PrintMediaSize__isoB3> & PrintMediaSize__isoB3 & 27;// 27
static +isoB4: Class<PrintMediaSize__isoB4> & PrintMediaSize__isoB4 & 28;// 28
static +isoB4Envelope: Class<PrintMediaSize__isoB4Envelope> & PrintMediaSize__isoB4Envelope & 29;// 29
static +isoB5Envelope: Class<PrintMediaSize__isoB5Envelope> & PrintMediaSize__isoB5Envelope & 30;// 30
static +isoB5Extra: Class<PrintMediaSize__isoB5Extra> & PrintMediaSize__isoB5Extra & 31;// 31
static +isoB7: Class<PrintMediaSize__isoB7> & PrintMediaSize__isoB7 & 32;// 32
static +isoB8: Class<PrintMediaSize__isoB8> & PrintMediaSize__isoB8 & 33;// 33
static +isoB9: Class<PrintMediaSize__isoB9> & PrintMediaSize__isoB9 & 34;// 34
static +isoC0: Class<PrintMediaSize__isoC0> & PrintMediaSize__isoC0 & 35;// 35
static +isoC1: Class<PrintMediaSize__isoC1> & PrintMediaSize__isoC1 & 36;// 36
static +isoC10: Class<PrintMediaSize__isoC10> & PrintMediaSize__isoC10 & 37;// 37
static +isoC2: Class<PrintMediaSize__isoC2> & PrintMediaSize__isoC2 & 38;// 38
static +isoC3: Class<PrintMediaSize__isoC3> & PrintMediaSize__isoC3 & 39;// 39
static +isoC3Envelope: Class<PrintMediaSize__isoC3Envelope> & PrintMediaSize__isoC3Envelope & 40;// 40
static +isoC4: Class<PrintMediaSize__isoC4> & PrintMediaSize__isoC4 & 41;// 41
static +isoC4Envelope: Class<PrintMediaSize__isoC4Envelope> & PrintMediaSize__isoC4Envelope & 42;// 42
static +isoC5: Class<PrintMediaSize__isoC5> & PrintMediaSize__isoC5 & 43;// 43
static +isoC5Envelope: Class<PrintMediaSize__isoC5Envelope> & PrintMediaSize__isoC5Envelope & 44;// 44
static +isoC6: Class<PrintMediaSize__isoC6> & PrintMediaSize__isoC6 & 45;// 45
static +isoC6C5Envelope: Class<PrintMediaSize__isoC6C5Envelope> & PrintMediaSize__isoC6C5Envelope & 46;// 46
static +isoC6Envelope: Class<PrintMediaSize__isoC6Envelope> & PrintMediaSize__isoC6Envelope & 47;// 47
static +isoC7: Class<PrintMediaSize__isoC7> & PrintMediaSize__isoC7 & 48;// 48
static +isoC8: Class<PrintMediaSize__isoC8> & PrintMediaSize__isoC8 & 49;// 49
static +isoC9: Class<PrintMediaSize__isoC9> & PrintMediaSize__isoC9 & 50;// 50
static +isoDLEnvelope: Class<PrintMediaSize__isoDLEnvelope> & PrintMediaSize__isoDLEnvelope & 51;// 51
static +isoDLEnvelopeRotated: Class<PrintMediaSize__isoDLEnvelopeRotated> & PrintMediaSize__isoDLEnvelopeRotated & 52;// 52
static +isoSRA3: Class<PrintMediaSize__isoSRA3> & PrintMediaSize__isoSRA3 & 53;// 53
static +japan2LPhoto: Class<PrintMediaSize__japan2LPhoto> & PrintMediaSize__japan2LPhoto & 54;// 54
static +japanChou3Envelope: Class<PrintMediaSize__japanChou3Envelope> & PrintMediaSize__japanChou3Envelope & 55;// 55
static +japanChou3EnvelopeRotated: Class<PrintMediaSize__japanChou3EnvelopeRotated> & PrintMediaSize__japanChou3EnvelopeRotated & 56;// 56
static +japanChou4Envelope: Class<PrintMediaSize__japanChou4Envelope> & PrintMediaSize__japanChou4Envelope & 57;// 57
static +japanChou4EnvelopeRotated: Class<PrintMediaSize__japanChou4EnvelopeRotated> & PrintMediaSize__japanChou4EnvelopeRotated & 58;// 58
static +japanDoubleHagakiPostcard: Class<PrintMediaSize__japanDoubleHagakiPostcard> & PrintMediaSize__japanDoubleHagakiPostcard & 59;// 59
static +japanDoubleHagakiPostcardRotated: Class<PrintMediaSize__japanDoubleHagakiPostcardRotated> & PrintMediaSize__japanDoubleHagakiPostcardRotated & 60;// 60
static +japanHagakiPostcard: Class<PrintMediaSize__japanHagakiPostcard> & PrintMediaSize__japanHagakiPostcard & 61;// 61
static +japanHagakiPostcardRotated: Class<PrintMediaSize__japanHagakiPostcardRotated> & PrintMediaSize__japanHagakiPostcardRotated & 62;// 62
static +japanKaku2Envelope: Class<PrintMediaSize__japanKaku2Envelope> & PrintMediaSize__japanKaku2Envelope & 63;// 63
static +japanKaku2EnvelopeRotated: Class<PrintMediaSize__japanKaku2EnvelopeRotated> & PrintMediaSize__japanKaku2EnvelopeRotated & 64;// 64
static +japanKaku3Envelope: Class<PrintMediaSize__japanKaku3Envelope> & PrintMediaSize__japanKaku3Envelope & 65;// 65
static +japanKaku3EnvelopeRotated: Class<PrintMediaSize__japanKaku3EnvelopeRotated> & PrintMediaSize__japanKaku3EnvelopeRotated & 66;// 66
static +japanLPhoto: Class<PrintMediaSize__japanLPhoto> & PrintMediaSize__japanLPhoto & 67;// 67
static +japanQuadrupleHagakiPostcard: Class<PrintMediaSize__japanQuadrupleHagakiPostcard> & PrintMediaSize__japanQuadrupleHagakiPostcard & 68;// 68
static +japanYou1Envelope: Class<PrintMediaSize__japanYou1Envelope> & PrintMediaSize__japanYou1Envelope & 69;// 69
static +japanYou2Envelope: Class<PrintMediaSize__japanYou2Envelope> & PrintMediaSize__japanYou2Envelope & 70;// 70
static +japanYou3Envelope: Class<PrintMediaSize__japanYou3Envelope> & PrintMediaSize__japanYou3Envelope & 71;// 71
static +japanYou4Envelope: Class<PrintMediaSize__japanYou4Envelope> & PrintMediaSize__japanYou4Envelope & 72;// 72
static +japanYou4EnvelopeRotated: Class<PrintMediaSize__japanYou4EnvelopeRotated> & PrintMediaSize__japanYou4EnvelopeRotated & 73;// 73
static +japanYou6Envelope: Class<PrintMediaSize__japanYou6Envelope> & PrintMediaSize__japanYou6Envelope & 74;// 74
static +japanYou6EnvelopeRotated: Class<PrintMediaSize__japanYou6EnvelopeRotated> & PrintMediaSize__japanYou6EnvelopeRotated & 75;// 75
static +jisB0: Class<PrintMediaSize__jisB0> & PrintMediaSize__jisB0 & 76;// 76
static +jisB1: Class<PrintMediaSize__jisB1> & PrintMediaSize__jisB1 & 77;// 77
static +jisB10: Class<PrintMediaSize__jisB10> & PrintMediaSize__jisB10 & 78;// 78
static +jisB2: Class<PrintMediaSize__jisB2> & PrintMediaSize__jisB2 & 79;// 79
static +jisB3: Class<PrintMediaSize__jisB3> & PrintMediaSize__jisB3 & 80;// 80
static +jisB4: Class<PrintMediaSize__jisB4> & PrintMediaSize__jisB4 & 81;// 81
static +jisB4Rotated: Class<PrintMediaSize__jisB4Rotated> & PrintMediaSize__jisB4Rotated & 82;// 82
static +jisB5: Class<PrintMediaSize__jisB5> & PrintMediaSize__jisB5 & 83;// 83
static +jisB5Rotated: Class<PrintMediaSize__jisB5Rotated> & PrintMediaSize__jisB5Rotated & 84;// 84
static +jisB6: Class<PrintMediaSize__jisB6> & PrintMediaSize__jisB6 & 85;// 85
static +jisB6Rotated: Class<PrintMediaSize__jisB6Rotated> & PrintMediaSize__jisB6Rotated & 86;// 86
static +jisB7: Class<PrintMediaSize__jisB7> & PrintMediaSize__jisB7 & 87;// 87
static +jisB8: Class<PrintMediaSize__jisB8> & PrintMediaSize__jisB8 & 88;// 88
static +jisB9: Class<PrintMediaSize__jisB9> & PrintMediaSize__jisB9 & 89;// 89
static +northAmerica10x11: Class<PrintMediaSize__northAmerica10x11> & PrintMediaSize__northAmerica10x11 & 90;// 90
static +northAmerica10x12: Class<PrintMediaSize__northAmerica10x12> & PrintMediaSize__northAmerica10x12 & 91;// 91
static +northAmerica10x14: Class<PrintMediaSize__northAmerica10x14> & PrintMediaSize__northAmerica10x14 & 92;// 92
static +northAmerica11x17: Class<PrintMediaSize__northAmerica11x17> & PrintMediaSize__northAmerica11x17 & 93;// 93
static +northAmerica14x17: Class<PrintMediaSize__northAmerica14x17> & PrintMediaSize__northAmerica14x17 & 94;// 94
static +northAmerica4x6: Class<PrintMediaSize__northAmerica4x6> & PrintMediaSize__northAmerica4x6 & 95;// 95
static +northAmerica4x8: Class<PrintMediaSize__northAmerica4x8> & PrintMediaSize__northAmerica4x8 & 96;// 96
static +northAmerica5x7: Class<PrintMediaSize__northAmerica5x7> & PrintMediaSize__northAmerica5x7 & 97;// 97
static +northAmerica8x10: Class<PrintMediaSize__northAmerica8x10> & PrintMediaSize__northAmerica8x10 & 98;// 98
static +northAmerica9x11: Class<PrintMediaSize__northAmerica9x11> & PrintMediaSize__northAmerica9x11 & 99;// 99
static +northAmericaArchitectureASheet: Class<PrintMediaSize__northAmericaArchitectureASheet> & PrintMediaSize__northAmericaArchitectureASheet & 100;// 100
static +northAmericaArchitectureBSheet: Class<PrintMediaSize__northAmericaArchitectureBSheet> & PrintMediaSize__northAmericaArchitectureBSheet & 101;// 101
static +northAmericaArchitectureCSheet: Class<PrintMediaSize__northAmericaArchitectureCSheet> & PrintMediaSize__northAmericaArchitectureCSheet & 102;// 102
static +northAmericaArchitectureDSheet: Class<PrintMediaSize__northAmericaArchitectureDSheet> & PrintMediaSize__northAmericaArchitectureDSheet & 103;// 103
static +northAmericaArchitectureESheet: Class<PrintMediaSize__northAmericaArchitectureESheet> & PrintMediaSize__northAmericaArchitectureESheet & 104;// 104
static +northAmericaCSheet: Class<PrintMediaSize__northAmericaCSheet> & PrintMediaSize__northAmericaCSheet & 105;// 105
static +northAmericaDSheet: Class<PrintMediaSize__northAmericaDSheet> & PrintMediaSize__northAmericaDSheet & 106;// 106
static +northAmericaESheet: Class<PrintMediaSize__northAmericaESheet> & PrintMediaSize__northAmericaESheet & 107;// 107
static +northAmericaExecutive: Class<PrintMediaSize__northAmericaExecutive> & PrintMediaSize__northAmericaExecutive & 108;// 108
static +northAmericaGermanLegalFanfold: Class<PrintMediaSize__northAmericaGermanLegalFanfold> & PrintMediaSize__northAmericaGermanLegalFanfold & 109;// 109
static +northAmericaGermanStandardFanfold: Class<PrintMediaSize__northAmericaGermanStandardFanfold> & PrintMediaSize__northAmericaGermanStandardFanfold & 110;// 110
static +northAmericaLegal: Class<PrintMediaSize__northAmericaLegal> & PrintMediaSize__northAmericaLegal & 111;// 111
static +northAmericaLegalExtra: Class<PrintMediaSize__northAmericaLegalExtra> & PrintMediaSize__northAmericaLegalExtra & 112;// 112
static +northAmericaLetter: Class<PrintMediaSize__northAmericaLetter> & PrintMediaSize__northAmericaLetter & 113;// 113
static +northAmericaLetterExtra: Class<PrintMediaSize__northAmericaLetterExtra> & PrintMediaSize__northAmericaLetterExtra & 114;// 114
static +northAmericaLetterPlus: Class<PrintMediaSize__northAmericaLetterPlus> & PrintMediaSize__northAmericaLetterPlus & 115;// 115
static +northAmericaLetterRotated: Class<PrintMediaSize__northAmericaLetterRotated> & PrintMediaSize__northAmericaLetterRotated & 116;// 116
static +northAmericaMonarchEnvelope: Class<PrintMediaSize__northAmericaMonarchEnvelope> & PrintMediaSize__northAmericaMonarchEnvelope & 117;// 117
static +northAmericaNote: Class<PrintMediaSize__northAmericaNote> & PrintMediaSize__northAmericaNote & 118;// 118
static +northAmericaNumber10Envelope: Class<PrintMediaSize__northAmericaNumber10Envelope> & PrintMediaSize__northAmericaNumber10Envelope & 119;// 119
static +northAmericaNumber10EnvelopeRotated: Class<PrintMediaSize__northAmericaNumber10EnvelopeRotated> & PrintMediaSize__northAmericaNumber10EnvelopeRotated & 120;// 120
static +northAmericaNumber11Envelope: Class<PrintMediaSize__northAmericaNumber11Envelope> & PrintMediaSize__northAmericaNumber11Envelope & 121;// 121
static +northAmericaNumber12Envelope: Class<PrintMediaSize__northAmericaNumber12Envelope> & PrintMediaSize__northAmericaNumber12Envelope & 122;// 122
static +northAmericaNumber14Envelope: Class<PrintMediaSize__northAmericaNumber14Envelope> & PrintMediaSize__northAmericaNumber14Envelope & 123;// 123
static +northAmericaNumber9Envelope: Class<PrintMediaSize__northAmericaNumber9Envelope> & PrintMediaSize__northAmericaNumber9Envelope & 124;// 124
static +northAmericaPersonalEnvelope: Class<PrintMediaSize__northAmericaPersonalEnvelope> & PrintMediaSize__northAmericaPersonalEnvelope & 125;// 125
static +northAmericaQuarto: Class<PrintMediaSize__northAmericaQuarto> & PrintMediaSize__northAmericaQuarto & 126;// 126
static +northAmericaStatement: Class<PrintMediaSize__northAmericaStatement> & PrintMediaSize__northAmericaStatement & 127;// 127
static +northAmericaSuperA: Class<PrintMediaSize__northAmericaSuperA> & PrintMediaSize__northAmericaSuperA & 128;// 128
static +northAmericaSuperB: Class<PrintMediaSize__northAmericaSuperB> & PrintMediaSize__northAmericaSuperB & 129;// 129
static +northAmericaTabloid: Class<PrintMediaSize__northAmericaTabloid> & PrintMediaSize__northAmericaTabloid & 130;// 130
static +northAmericaTabloidExtra: Class<PrintMediaSize__northAmericaTabloidExtra> & PrintMediaSize__northAmericaTabloidExtra & 131;// 131
static +otherMetricA3Plus: Class<PrintMediaSize__otherMetricA3Plus> & PrintMediaSize__otherMetricA3Plus & 132;// 132
static +otherMetricA4Plus: Class<PrintMediaSize__otherMetricA4Plus> & PrintMediaSize__otherMetricA4Plus & 133;// 133
static +otherMetricFolio: Class<PrintMediaSize__otherMetricFolio> & PrintMediaSize__otherMetricFolio & 134;// 134
static +otherMetricInviteEnvelope: Class<PrintMediaSize__otherMetricInviteEnvelope> & PrintMediaSize__otherMetricInviteEnvelope & 135;// 135
static +otherMetricItalianEnvelope: Class<PrintMediaSize__otherMetricItalianEnvelope> & PrintMediaSize__otherMetricItalianEnvelope & 136;// 136
static +prc10Envelope: Class<PrintMediaSize__prc10Envelope> & PrintMediaSize__prc10Envelope & 137;// 137
static +prc10EnvelopeRotated: Class<PrintMediaSize__prc10EnvelopeRotated> & PrintMediaSize__prc10EnvelopeRotated & 138;// 138
static +prc16K: Class<PrintMediaSize__prc16K> & PrintMediaSize__prc16K & 139;// 139
static +prc16KRotated: Class<PrintMediaSize__prc16KRotated> & PrintMediaSize__prc16KRotated & 140;// 140
static +prc1Envelope: Class<PrintMediaSize__prc1Envelope> & PrintMediaSize__prc1Envelope & 141;// 141
static +prc1EnvelopeRotated: Class<PrintMediaSize__prc1EnvelopeRotated> & PrintMediaSize__prc1EnvelopeRotated & 142;// 142
static +prc2Envelope: Class<PrintMediaSize__prc2Envelope> & PrintMediaSize__prc2Envelope & 143;// 143
static +prc2EnvelopeRotated: Class<PrintMediaSize__prc2EnvelopeRotated> & PrintMediaSize__prc2EnvelopeRotated & 144;// 144
static +prc32K: Class<PrintMediaSize__prc32K> & PrintMediaSize__prc32K & 145;// 145
static +prc32KBig: Class<PrintMediaSize__prc32KBig> & PrintMediaSize__prc32KBig & 146;// 146
static +prc32KRotated: Class<PrintMediaSize__prc32KRotated> & PrintMediaSize__prc32KRotated & 147;// 147
static +prc3Envelope: Class<PrintMediaSize__prc3Envelope> & PrintMediaSize__prc3Envelope & 148;// 148
static +prc3EnvelopeRotated: Class<PrintMediaSize__prc3EnvelopeRotated> & PrintMediaSize__prc3EnvelopeRotated & 149;// 149
static +prc4Envelope: Class<PrintMediaSize__prc4Envelope> & PrintMediaSize__prc4Envelope & 150;// 150
static +prc4EnvelopeRotated: Class<PrintMediaSize__prc4EnvelopeRotated> & PrintMediaSize__prc4EnvelopeRotated & 151;// 151
static +prc5Envelope: Class<PrintMediaSize__prc5Envelope> & PrintMediaSize__prc5Envelope & 152;// 152
static +prc5EnvelopeRotated: Class<PrintMediaSize__prc5EnvelopeRotated> & PrintMediaSize__prc5EnvelopeRotated & 153;// 153
static +prc6Envelope: Class<PrintMediaSize__prc6Envelope> & PrintMediaSize__prc6Envelope & 154;// 154
static +prc6EnvelopeRotated: Class<PrintMediaSize__prc6EnvelopeRotated> & PrintMediaSize__prc6EnvelopeRotated & 155;// 155
static +prc7Envelope: Class<PrintMediaSize__prc7Envelope> & PrintMediaSize__prc7Envelope & 156;// 156
static +prc7EnvelopeRotated: Class<PrintMediaSize__prc7EnvelopeRotated> & PrintMediaSize__prc7EnvelopeRotated & 157;// 157
static +prc8Envelope: Class<PrintMediaSize__prc8Envelope> & PrintMediaSize__prc8Envelope & 158;// 158
static +prc8EnvelopeRotated: Class<PrintMediaSize__prc8EnvelopeRotated> & PrintMediaSize__prc8EnvelopeRotated & 159;// 159
static +prc9Envelope: Class<PrintMediaSize__prc9Envelope> & PrintMediaSize__prc9Envelope & 160;// 160
static +prc9EnvelopeRotated: Class<PrintMediaSize__prc9EnvelopeRotated> & PrintMediaSize__prc9EnvelopeRotated & 161;// 161
static +roll04Inch: Class<PrintMediaSize__roll04Inch> & PrintMediaSize__roll04Inch & 162;// 162
static +roll06Inch: Class<PrintMediaSize__roll06Inch> & PrintMediaSize__roll06Inch & 163;// 163
static +roll08Inch: Class<PrintMediaSize__roll08Inch> & PrintMediaSize__roll08Inch & 164;// 164
static +roll12Inch: Class<PrintMediaSize__roll12Inch> & PrintMediaSize__roll12Inch & 165;// 165
static +roll15Inch: Class<PrintMediaSize__roll15Inch> & PrintMediaSize__roll15Inch & 166;// 166
static +roll18Inch: Class<PrintMediaSize__roll18Inch> & PrintMediaSize__roll18Inch & 167;// 167
static +roll22Inch: Class<PrintMediaSize__roll22Inch> & PrintMediaSize__roll22Inch & 168;// 168
static +roll24Inch: Class<PrintMediaSize__roll24Inch> & PrintMediaSize__roll24Inch & 169;// 169
static +roll30Inch: Class<PrintMediaSize__roll30Inch> & PrintMediaSize__roll30Inch & 170;// 170
static +roll36Inch: Class<PrintMediaSize__roll36Inch> & PrintMediaSize__roll36Inch & 171;// 171
static +roll54Inch: Class<PrintMediaSize__roll54Inch> & PrintMediaSize__roll54Inch & 172;// 172

}

declare class PrintMediaSize__default mixins PrintMediaSize {}
declare class PrintMediaSize__notAvailable mixins PrintMediaSize {}
declare class PrintMediaSize__printerCustom mixins PrintMediaSize {}
declare class PrintMediaSize__businessCard mixins PrintMediaSize {}
declare class PrintMediaSize__creditCard mixins PrintMediaSize {}
declare class PrintMediaSize__isoA0 mixins PrintMediaSize {}
declare class PrintMediaSize__isoA1 mixins PrintMediaSize {}
declare class PrintMediaSize__isoA10 mixins PrintMediaSize {}
declare class PrintMediaSize__isoA2 mixins PrintMediaSize {}
declare class PrintMediaSize__isoA3 mixins PrintMediaSize {}
declare class PrintMediaSize__isoA3Extra mixins PrintMediaSize {}
declare class PrintMediaSize__isoA3Rotated mixins PrintMediaSize {}
declare class PrintMediaSize__isoA4 mixins PrintMediaSize {}
declare class PrintMediaSize__isoA4Extra mixins PrintMediaSize {}
declare class PrintMediaSize__isoA4Rotated mixins PrintMediaSize {}
declare class PrintMediaSize__isoA5 mixins PrintMediaSize {}
declare class PrintMediaSize__isoA5Extra mixins PrintMediaSize {}
declare class PrintMediaSize__isoA5Rotated mixins PrintMediaSize {}
declare class PrintMediaSize__isoA6 mixins PrintMediaSize {}
declare class PrintMediaSize__isoA6Rotated mixins PrintMediaSize {}
declare class PrintMediaSize__isoA7 mixins PrintMediaSize {}
declare class PrintMediaSize__isoA8 mixins PrintMediaSize {}
declare class PrintMediaSize__isoA9 mixins PrintMediaSize {}
declare class PrintMediaSize__isoB0 mixins PrintMediaSize {}
declare class PrintMediaSize__isoB1 mixins PrintMediaSize {}
declare class PrintMediaSize__isoB10 mixins PrintMediaSize {}
declare class PrintMediaSize__isoB2 mixins PrintMediaSize {}
declare class PrintMediaSize__isoB3 mixins PrintMediaSize {}
declare class PrintMediaSize__isoB4 mixins PrintMediaSize {}
declare class PrintMediaSize__isoB4Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__isoB5Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__isoB5Extra mixins PrintMediaSize {}
declare class PrintMediaSize__isoB7 mixins PrintMediaSize {}
declare class PrintMediaSize__isoB8 mixins PrintMediaSize {}
declare class PrintMediaSize__isoB9 mixins PrintMediaSize {}
declare class PrintMediaSize__isoC0 mixins PrintMediaSize {}
declare class PrintMediaSize__isoC1 mixins PrintMediaSize {}
declare class PrintMediaSize__isoC10 mixins PrintMediaSize {}
declare class PrintMediaSize__isoC2 mixins PrintMediaSize {}
declare class PrintMediaSize__isoC3 mixins PrintMediaSize {}
declare class PrintMediaSize__isoC3Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__isoC4 mixins PrintMediaSize {}
declare class PrintMediaSize__isoC4Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__isoC5 mixins PrintMediaSize {}
declare class PrintMediaSize__isoC5Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__isoC6 mixins PrintMediaSize {}
declare class PrintMediaSize__isoC6C5Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__isoC6Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__isoC7 mixins PrintMediaSize {}
declare class PrintMediaSize__isoC8 mixins PrintMediaSize {}
declare class PrintMediaSize__isoC9 mixins PrintMediaSize {}
declare class PrintMediaSize__isoDLEnvelope mixins PrintMediaSize {}
declare class PrintMediaSize__isoDLEnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__isoSRA3 mixins PrintMediaSize {}
declare class PrintMediaSize__japan2LPhoto mixins PrintMediaSize {}
declare class PrintMediaSize__japanChou3Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__japanChou3EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__japanChou4Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__japanChou4EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__japanDoubleHagakiPostcard mixins PrintMediaSize {}
declare class PrintMediaSize__japanDoubleHagakiPostcardRotated mixins PrintMediaSize {}
declare class PrintMediaSize__japanHagakiPostcard mixins PrintMediaSize {}
declare class PrintMediaSize__japanHagakiPostcardRotated mixins PrintMediaSize {}
declare class PrintMediaSize__japanKaku2Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__japanKaku2EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__japanKaku3Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__japanKaku3EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__japanLPhoto mixins PrintMediaSize {}
declare class PrintMediaSize__japanQuadrupleHagakiPostcard mixins PrintMediaSize {}
declare class PrintMediaSize__japanYou1Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__japanYou2Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__japanYou3Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__japanYou4Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__japanYou4EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__japanYou6Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__japanYou6EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__jisB0 mixins PrintMediaSize {}
declare class PrintMediaSize__jisB1 mixins PrintMediaSize {}
declare class PrintMediaSize__jisB10 mixins PrintMediaSize {}
declare class PrintMediaSize__jisB2 mixins PrintMediaSize {}
declare class PrintMediaSize__jisB3 mixins PrintMediaSize {}
declare class PrintMediaSize__jisB4 mixins PrintMediaSize {}
declare class PrintMediaSize__jisB4Rotated mixins PrintMediaSize {}
declare class PrintMediaSize__jisB5 mixins PrintMediaSize {}
declare class PrintMediaSize__jisB5Rotated mixins PrintMediaSize {}
declare class PrintMediaSize__jisB6 mixins PrintMediaSize {}
declare class PrintMediaSize__jisB6Rotated mixins PrintMediaSize {}
declare class PrintMediaSize__jisB7 mixins PrintMediaSize {}
declare class PrintMediaSize__jisB8 mixins PrintMediaSize {}
declare class PrintMediaSize__jisB9 mixins PrintMediaSize {}
declare class PrintMediaSize__northAmerica10x11 mixins PrintMediaSize {}
declare class PrintMediaSize__northAmerica10x12 mixins PrintMediaSize {}
declare class PrintMediaSize__northAmerica10x14 mixins PrintMediaSize {}
declare class PrintMediaSize__northAmerica11x17 mixins PrintMediaSize {}
declare class PrintMediaSize__northAmerica14x17 mixins PrintMediaSize {}
declare class PrintMediaSize__northAmerica4x6 mixins PrintMediaSize {}
declare class PrintMediaSize__northAmerica4x8 mixins PrintMediaSize {}
declare class PrintMediaSize__northAmerica5x7 mixins PrintMediaSize {}
declare class PrintMediaSize__northAmerica8x10 mixins PrintMediaSize {}
declare class PrintMediaSize__northAmerica9x11 mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaArchitectureASheet mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaArchitectureBSheet mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaArchitectureCSheet mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaArchitectureDSheet mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaArchitectureESheet mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaCSheet mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaDSheet mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaESheet mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaExecutive mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaGermanLegalFanfold mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaGermanStandardFanfold mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaLegal mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaLegalExtra mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaLetter mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaLetterExtra mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaLetterPlus mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaLetterRotated mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaMonarchEnvelope mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaNote mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaNumber10Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaNumber10EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaNumber11Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaNumber12Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaNumber14Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaNumber9Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaPersonalEnvelope mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaQuarto mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaStatement mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaSuperA mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaSuperB mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaTabloid mixins PrintMediaSize {}
declare class PrintMediaSize__northAmericaTabloidExtra mixins PrintMediaSize {}
declare class PrintMediaSize__otherMetricA3Plus mixins PrintMediaSize {}
declare class PrintMediaSize__otherMetricA4Plus mixins PrintMediaSize {}
declare class PrintMediaSize__otherMetricFolio mixins PrintMediaSize {}
declare class PrintMediaSize__otherMetricInviteEnvelope mixins PrintMediaSize {}
declare class PrintMediaSize__otherMetricItalianEnvelope mixins PrintMediaSize {}
declare class PrintMediaSize__prc10Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__prc10EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__prc16K mixins PrintMediaSize {}
declare class PrintMediaSize__prc16KRotated mixins PrintMediaSize {}
declare class PrintMediaSize__prc1Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__prc1EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__prc2Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__prc2EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__prc32K mixins PrintMediaSize {}
declare class PrintMediaSize__prc32KBig mixins PrintMediaSize {}
declare class PrintMediaSize__prc32KRotated mixins PrintMediaSize {}
declare class PrintMediaSize__prc3Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__prc3EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__prc4Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__prc4EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__prc5Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__prc5EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__prc6Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__prc6EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__prc7Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__prc7EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__prc8Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__prc8EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__prc9Envelope mixins PrintMediaSize {}
declare class PrintMediaSize__prc9EnvelopeRotated mixins PrintMediaSize {}
declare class PrintMediaSize__roll04Inch mixins PrintMediaSize {}
declare class PrintMediaSize__roll06Inch mixins PrintMediaSize {}
declare class PrintMediaSize__roll08Inch mixins PrintMediaSize {}
declare class PrintMediaSize__roll12Inch mixins PrintMediaSize {}
declare class PrintMediaSize__roll15Inch mixins PrintMediaSize {}
declare class PrintMediaSize__roll18Inch mixins PrintMediaSize {}
declare class PrintMediaSize__roll22Inch mixins PrintMediaSize {}
declare class PrintMediaSize__roll24Inch mixins PrintMediaSize {}
declare class PrintMediaSize__roll30Inch mixins PrintMediaSize {}
declare class PrintMediaSize__roll36Inch mixins PrintMediaSize {}
declare class PrintMediaSize__roll54Inch mixins PrintMediaSize {}

	declare export  class PrintMediaType {
  constructor(...args: empty): mixed;
static +default: Class<PrintMediaType__default> & PrintMediaType__default & 0;// 0
static +notAvailable: Class<PrintMediaType__notAvailable> & PrintMediaType__notAvailable & 1;// 1
static +printerCustom: Class<PrintMediaType__printerCustom> & PrintMediaType__printerCustom & 2;// 2
static +autoSelect: Class<PrintMediaType__autoSelect> & PrintMediaType__autoSelect & 3;// 3
static +archival: Class<PrintMediaType__archival> & PrintMediaType__archival & 4;// 4
static +backPrintFilm: Class<PrintMediaType__backPrintFilm> & PrintMediaType__backPrintFilm & 5;// 5
static +bond: Class<PrintMediaType__bond> & PrintMediaType__bond & 6;// 6
static +cardStock: Class<PrintMediaType__cardStock> & PrintMediaType__cardStock & 7;// 7
static +continuous: Class<PrintMediaType__continuous> & PrintMediaType__continuous & 8;// 8
static +envelopePlain: Class<PrintMediaType__envelopePlain> & PrintMediaType__envelopePlain & 9;// 9
static +envelopeWindow: Class<PrintMediaType__envelopeWindow> & PrintMediaType__envelopeWindow & 10;// 10
static +fabric: Class<PrintMediaType__fabric> & PrintMediaType__fabric & 11;// 11
static +highResolution: Class<PrintMediaType__highResolution> & PrintMediaType__highResolution & 12;// 12
static +label: Class<PrintMediaType__label> & PrintMediaType__label & 13;// 13
static +multiLayerForm: Class<PrintMediaType__multiLayerForm> & PrintMediaType__multiLayerForm & 14;// 14
static +multiPartForm: Class<PrintMediaType__multiPartForm> & PrintMediaType__multiPartForm & 15;// 15
static +photographic: Class<PrintMediaType__photographic> & PrintMediaType__photographic & 16;// 16
static +photographicFilm: Class<PrintMediaType__photographicFilm> & PrintMediaType__photographicFilm & 17;// 17
static +photographicGlossy: Class<PrintMediaType__photographicGlossy> & PrintMediaType__photographicGlossy & 18;// 18
static +photographicHighGloss: Class<PrintMediaType__photographicHighGloss> & PrintMediaType__photographicHighGloss & 19;// 19
static +photographicMatte: Class<PrintMediaType__photographicMatte> & PrintMediaType__photographicMatte & 20;// 20
static +photographicSatin: Class<PrintMediaType__photographicSatin> & PrintMediaType__photographicSatin & 21;// 21
static +photographicSemiGloss: Class<PrintMediaType__photographicSemiGloss> & PrintMediaType__photographicSemiGloss & 22;// 22
static +plain: Class<PrintMediaType__plain> & PrintMediaType__plain & 23;// 23
static +screen: Class<PrintMediaType__screen> & PrintMediaType__screen & 24;// 24
static +screenPaged: Class<PrintMediaType__screenPaged> & PrintMediaType__screenPaged & 25;// 25
static +stationery: Class<PrintMediaType__stationery> & PrintMediaType__stationery & 26;// 26
static +tabStockFull: Class<PrintMediaType__tabStockFull> & PrintMediaType__tabStockFull & 27;// 27
static +tabStockPreCut: Class<PrintMediaType__tabStockPreCut> & PrintMediaType__tabStockPreCut & 28;// 28
static +transparency: Class<PrintMediaType__transparency> & PrintMediaType__transparency & 29;// 29
static +tShirtTransfer: Class<PrintMediaType__tShirtTransfer> & PrintMediaType__tShirtTransfer & 30;// 30
static +none: Class<PrintMediaType__none> & PrintMediaType__none & 31;// 31

}

declare class PrintMediaType__default mixins PrintMediaType {}
declare class PrintMediaType__notAvailable mixins PrintMediaType {}
declare class PrintMediaType__printerCustom mixins PrintMediaType {}
declare class PrintMediaType__autoSelect mixins PrintMediaType {}
declare class PrintMediaType__archival mixins PrintMediaType {}
declare class PrintMediaType__backPrintFilm mixins PrintMediaType {}
declare class PrintMediaType__bond mixins PrintMediaType {}
declare class PrintMediaType__cardStock mixins PrintMediaType {}
declare class PrintMediaType__continuous mixins PrintMediaType {}
declare class PrintMediaType__envelopePlain mixins PrintMediaType {}
declare class PrintMediaType__envelopeWindow mixins PrintMediaType {}
declare class PrintMediaType__fabric mixins PrintMediaType {}
declare class PrintMediaType__highResolution mixins PrintMediaType {}
declare class PrintMediaType__label mixins PrintMediaType {}
declare class PrintMediaType__multiLayerForm mixins PrintMediaType {}
declare class PrintMediaType__multiPartForm mixins PrintMediaType {}
declare class PrintMediaType__photographic mixins PrintMediaType {}
declare class PrintMediaType__photographicFilm mixins PrintMediaType {}
declare class PrintMediaType__photographicGlossy mixins PrintMediaType {}
declare class PrintMediaType__photographicHighGloss mixins PrintMediaType {}
declare class PrintMediaType__photographicMatte mixins PrintMediaType {}
declare class PrintMediaType__photographicSatin mixins PrintMediaType {}
declare class PrintMediaType__photographicSemiGloss mixins PrintMediaType {}
declare class PrintMediaType__plain mixins PrintMediaType {}
declare class PrintMediaType__screen mixins PrintMediaType {}
declare class PrintMediaType__screenPaged mixins PrintMediaType {}
declare class PrintMediaType__stationery mixins PrintMediaType {}
declare class PrintMediaType__tabStockFull mixins PrintMediaType {}
declare class PrintMediaType__tabStockPreCut mixins PrintMediaType {}
declare class PrintMediaType__transparency mixins PrintMediaType {}
declare class PrintMediaType__tShirtTransfer mixins PrintMediaType {}
declare class PrintMediaType__none mixins PrintMediaType {}

	declare export  class PrintOrientation {
  constructor(...args: empty): mixed;
static +default: Class<PrintOrientation__default> & PrintOrientation__default & 0;// 0
static +notAvailable: Class<PrintOrientation__notAvailable> & PrintOrientation__notAvailable & 1;// 1
static +printerCustom: Class<PrintOrientation__printerCustom> & PrintOrientation__printerCustom & 2;// 2
static +portrait: Class<PrintOrientation__portrait> & PrintOrientation__portrait & 3;// 3
static +portraitFlipped: Class<PrintOrientation__portraitFlipped> & PrintOrientation__portraitFlipped & 4;// 4
static +landscape: Class<PrintOrientation__landscape> & PrintOrientation__landscape & 5;// 5
static +landscapeFlipped: Class<PrintOrientation__landscapeFlipped> & PrintOrientation__landscapeFlipped & 6;// 6

}

declare class PrintOrientation__default mixins PrintOrientation {}
declare class PrintOrientation__notAvailable mixins PrintOrientation {}
declare class PrintOrientation__printerCustom mixins PrintOrientation {}
declare class PrintOrientation__portrait mixins PrintOrientation {}
declare class PrintOrientation__portraitFlipped mixins PrintOrientation {}
declare class PrintOrientation__landscape mixins PrintOrientation {}
declare class PrintOrientation__landscapeFlipped mixins PrintOrientation {}

	declare export  class PrintQuality {
  constructor(...args: empty): mixed;
static +default: Class<PrintQuality__default> & PrintQuality__default & 0;// 0
static +notAvailable: Class<PrintQuality__notAvailable> & PrintQuality__notAvailable & 1;// 1
static +printerCustom: Class<PrintQuality__printerCustom> & PrintQuality__printerCustom & 2;// 2
static +automatic: Class<PrintQuality__automatic> & PrintQuality__automatic & 3;// 3
static +draft: Class<PrintQuality__draft> & PrintQuality__draft & 4;// 4
static +fax: Class<PrintQuality__fax> & PrintQuality__fax & 5;// 5
static +high: Class<PrintQuality__high> & PrintQuality__high & 6;// 6
static +normal: Class<PrintQuality__normal> & PrintQuality__normal & 7;// 7
static +photographic: Class<PrintQuality__photographic> & PrintQuality__photographic & 8;// 8
static +text: Class<PrintQuality__text> & PrintQuality__text & 9;// 9

}

declare class PrintQuality__default mixins PrintQuality {}
declare class PrintQuality__notAvailable mixins PrintQuality {}
declare class PrintQuality__printerCustom mixins PrintQuality {}
declare class PrintQuality__automatic mixins PrintQuality {}
declare class PrintQuality__draft mixins PrintQuality {}
declare class PrintQuality__fax mixins PrintQuality {}
declare class PrintQuality__high mixins PrintQuality {}
declare class PrintQuality__normal mixins PrintQuality {}
declare class PrintQuality__photographic mixins PrintQuality {}
declare class PrintQuality__text mixins PrintQuality {}

	declare export  class PrintColorMode {
  constructor(...args: empty): mixed;
static +default: Class<PrintColorMode__default> & PrintColorMode__default & 0;// 0
static +notAvailable: Class<PrintColorMode__notAvailable> & PrintColorMode__notAvailable & 1;// 1
static +printerCustom: Class<PrintColorMode__printerCustom> & PrintColorMode__printerCustom & 2;// 2
static +color: Class<PrintColorMode__color> & PrintColorMode__color & 3;// 3
static +grayscale: Class<PrintColorMode__grayscale> & PrintColorMode__grayscale & 4;// 4
static +monochrome: Class<PrintColorMode__monochrome> & PrintColorMode__monochrome & 5;// 5

}

declare class PrintColorMode__default mixins PrintColorMode {}
declare class PrintColorMode__notAvailable mixins PrintColorMode {}
declare class PrintColorMode__printerCustom mixins PrintColorMode {}
declare class PrintColorMode__color mixins PrintColorMode {}
declare class PrintColorMode__grayscale mixins PrintColorMode {}
declare class PrintColorMode__monochrome mixins PrintColorMode {}

	declare export  class PrintDuplex {
  constructor(...args: empty): mixed;
static +default: Class<PrintDuplex__default> & PrintDuplex__default & 0;// 0
static +notAvailable: Class<PrintDuplex__notAvailable> & PrintDuplex__notAvailable & 1;// 1
static +printerCustom: Class<PrintDuplex__printerCustom> & PrintDuplex__printerCustom & 2;// 2
static +oneSided: Class<PrintDuplex__oneSided> & PrintDuplex__oneSided & 3;// 3
static +twoSidedShortEdge: Class<PrintDuplex__twoSidedShortEdge> & PrintDuplex__twoSidedShortEdge & 4;// 4
static +twoSidedLongEdge: Class<PrintDuplex__twoSidedLongEdge> & PrintDuplex__twoSidedLongEdge & 5;// 5

}

declare class PrintDuplex__default mixins PrintDuplex {}
declare class PrintDuplex__notAvailable mixins PrintDuplex {}
declare class PrintDuplex__printerCustom mixins PrintDuplex {}
declare class PrintDuplex__oneSided mixins PrintDuplex {}
declare class PrintDuplex__twoSidedShortEdge mixins PrintDuplex {}
declare class PrintDuplex__twoSidedLongEdge mixins PrintDuplex {}

	declare export  class PrintCollation {
  constructor(...args: empty): mixed;
static +default: Class<PrintCollation__default> & PrintCollation__default & 0;// 0
static +notAvailable: Class<PrintCollation__notAvailable> & PrintCollation__notAvailable & 1;// 1
static +printerCustom: Class<PrintCollation__printerCustom> & PrintCollation__printerCustom & 2;// 2
static +collated: Class<PrintCollation__collated> & PrintCollation__collated & 3;// 3
static +uncollated: Class<PrintCollation__uncollated> & PrintCollation__uncollated & 4;// 4

}

declare class PrintCollation__default mixins PrintCollation {}
declare class PrintCollation__notAvailable mixins PrintCollation {}
declare class PrintCollation__printerCustom mixins PrintCollation {}
declare class PrintCollation__collated mixins PrintCollation {}
declare class PrintCollation__uncollated mixins PrintCollation {}

	declare export  class PrintStaple {
  constructor(...args: empty): mixed;
static +default: Class<PrintStaple__default> & PrintStaple__default & 0;// 0
static +notAvailable: Class<PrintStaple__notAvailable> & PrintStaple__notAvailable & 1;// 1
static +printerCustom: Class<PrintStaple__printerCustom> & PrintStaple__printerCustom & 2;// 2
static +none: Class<PrintStaple__none> & PrintStaple__none & 3;// 3
static +stapleTopLeft: Class<PrintStaple__stapleTopLeft> & PrintStaple__stapleTopLeft & 4;// 4
static +stapleTopRight: Class<PrintStaple__stapleTopRight> & PrintStaple__stapleTopRight & 5;// 5
static +stapleBottomLeft: Class<PrintStaple__stapleBottomLeft> & PrintStaple__stapleBottomLeft & 6;// 6
static +stapleBottomRight: Class<PrintStaple__stapleBottomRight> & PrintStaple__stapleBottomRight & 7;// 7
static +stapleDualLeft: Class<PrintStaple__stapleDualLeft> & PrintStaple__stapleDualLeft & 8;// 8
static +stapleDualRight: Class<PrintStaple__stapleDualRight> & PrintStaple__stapleDualRight & 9;// 9
static +stapleDualTop: Class<PrintStaple__stapleDualTop> & PrintStaple__stapleDualTop & 10;// 10
static +stapleDualBottom: Class<PrintStaple__stapleDualBottom> & PrintStaple__stapleDualBottom & 11;// 11
static +saddleStitch: Class<PrintStaple__saddleStitch> & PrintStaple__saddleStitch & 12;// 12

}

declare class PrintStaple__default mixins PrintStaple {}
declare class PrintStaple__notAvailable mixins PrintStaple {}
declare class PrintStaple__printerCustom mixins PrintStaple {}
declare class PrintStaple__none mixins PrintStaple {}
declare class PrintStaple__stapleTopLeft mixins PrintStaple {}
declare class PrintStaple__stapleTopRight mixins PrintStaple {}
declare class PrintStaple__stapleBottomLeft mixins PrintStaple {}
declare class PrintStaple__stapleBottomRight mixins PrintStaple {}
declare class PrintStaple__stapleDualLeft mixins PrintStaple {}
declare class PrintStaple__stapleDualRight mixins PrintStaple {}
declare class PrintStaple__stapleDualTop mixins PrintStaple {}
declare class PrintStaple__stapleDualBottom mixins PrintStaple {}
declare class PrintStaple__saddleStitch mixins PrintStaple {}

	declare export  class PrintHolePunch {
  constructor(...args: empty): mixed;
static +default: Class<PrintHolePunch__default> & PrintHolePunch__default & 0;// 0
static +notAvailable: Class<PrintHolePunch__notAvailable> & PrintHolePunch__notAvailable & 1;// 1
static +printerCustom: Class<PrintHolePunch__printerCustom> & PrintHolePunch__printerCustom & 2;// 2
static +none: Class<PrintHolePunch__none> & PrintHolePunch__none & 3;// 3
static +leftEdge: Class<PrintHolePunch__leftEdge> & PrintHolePunch__leftEdge & 4;// 4
static +rightEdge: Class<PrintHolePunch__rightEdge> & PrintHolePunch__rightEdge & 5;// 5
static +topEdge: Class<PrintHolePunch__topEdge> & PrintHolePunch__topEdge & 6;// 6
static +bottomEdge: Class<PrintHolePunch__bottomEdge> & PrintHolePunch__bottomEdge & 7;// 7

}

declare class PrintHolePunch__default mixins PrintHolePunch {}
declare class PrintHolePunch__notAvailable mixins PrintHolePunch {}
declare class PrintHolePunch__printerCustom mixins PrintHolePunch {}
declare class PrintHolePunch__none mixins PrintHolePunch {}
declare class PrintHolePunch__leftEdge mixins PrintHolePunch {}
declare class PrintHolePunch__rightEdge mixins PrintHolePunch {}
declare class PrintHolePunch__topEdge mixins PrintHolePunch {}
declare class PrintHolePunch__bottomEdge mixins PrintHolePunch {}

	declare export  class PrintBinding {
  constructor(...args: empty): mixed;
static +default: Class<PrintBinding__default> & PrintBinding__default & 0;// 0
static +notAvailable: Class<PrintBinding__notAvailable> & PrintBinding__notAvailable & 1;// 1
static +printerCustom: Class<PrintBinding__printerCustom> & PrintBinding__printerCustom & 2;// 2
static +none: Class<PrintBinding__none> & PrintBinding__none & 3;// 3
static +bale: Class<PrintBinding__bale> & PrintBinding__bale & 4;// 4
static +bindBottom: Class<PrintBinding__bindBottom> & PrintBinding__bindBottom & 5;// 5
static +bindLeft: Class<PrintBinding__bindLeft> & PrintBinding__bindLeft & 6;// 6
static +bindRight: Class<PrintBinding__bindRight> & PrintBinding__bindRight & 7;// 7
static +bindTop: Class<PrintBinding__bindTop> & PrintBinding__bindTop & 8;// 8
static +booklet: Class<PrintBinding__booklet> & PrintBinding__booklet & 9;// 9
static +edgeStitchBottom: Class<PrintBinding__edgeStitchBottom> & PrintBinding__edgeStitchBottom & 10;// 10
static +edgeStitchLeft: Class<PrintBinding__edgeStitchLeft> & PrintBinding__edgeStitchLeft & 11;// 11
static +edgeStitchRight: Class<PrintBinding__edgeStitchRight> & PrintBinding__edgeStitchRight & 12;// 12
static +edgeStitchTop: Class<PrintBinding__edgeStitchTop> & PrintBinding__edgeStitchTop & 13;// 13
static +fold: Class<PrintBinding__fold> & PrintBinding__fold & 14;// 14
static +jogOffset: Class<PrintBinding__jogOffset> & PrintBinding__jogOffset & 15;// 15
static +trim: Class<PrintBinding__trim> & PrintBinding__trim & 16;// 16

}

declare class PrintBinding__default mixins PrintBinding {}
declare class PrintBinding__notAvailable mixins PrintBinding {}
declare class PrintBinding__printerCustom mixins PrintBinding {}
declare class PrintBinding__none mixins PrintBinding {}
declare class PrintBinding__bale mixins PrintBinding {}
declare class PrintBinding__bindBottom mixins PrintBinding {}
declare class PrintBinding__bindLeft mixins PrintBinding {}
declare class PrintBinding__bindRight mixins PrintBinding {}
declare class PrintBinding__bindTop mixins PrintBinding {}
declare class PrintBinding__booklet mixins PrintBinding {}
declare class PrintBinding__edgeStitchBottom mixins PrintBinding {}
declare class PrintBinding__edgeStitchLeft mixins PrintBinding {}
declare class PrintBinding__edgeStitchRight mixins PrintBinding {}
declare class PrintBinding__edgeStitchTop mixins PrintBinding {}
declare class PrintBinding__fold mixins PrintBinding {}
declare class PrintBinding__jogOffset mixins PrintBinding {}
declare class PrintBinding__trim mixins PrintBinding {}

	declare export interface IPrintTaskOptionsCoreProperties {
binding: Windows$Windows$Graphics.Printing.PrintBinding,
collation: Windows$Windows$Graphics.Printing.PrintCollation,
colorMode: Windows$Windows$Graphics.Printing.PrintColorMode,
duplex: Windows$Windows$Graphics.Printing.PrintDuplex,
holePunch: Windows$Windows$Graphics.Printing.PrintHolePunch,
maxCopies: number,
mediaSize: Windows$Windows$Graphics.Printing.PrintMediaSize,
mediaType: Windows$Windows$Graphics.Printing.PrintMediaType,
minCopies: number,
numberOfCopies: number,
orientation: Windows$Windows$Graphics.Printing.PrintOrientation,
printQuality: Windows$Windows$Graphics.Printing.PrintQuality,
staple: Windows$Windows$Graphics.Printing.PrintStaple
} 
	declare export interface IPrintTaskOptionsCoreUIConfiguration {
displayedOptions: Windows$Windows$Foundation.Collections.IVector<string>
} 
	declare export interface IPrintTaskOptionsCore {
getPageDescription(jobPageNumber: number): Windows$Windows$Graphics.Printing.PrintPageDescription
} 
	declare export class PrintTaskOptions mixins undefined.IPrintTaskOptionsCore, undefined.IPrintTaskOptionsCoreProperties, undefined.IPrintTaskOptionsCoreUIConfiguration {
binding: Windows$Windows$Graphics.Printing.PrintBinding;
collation: Windows$Windows$Graphics.Printing.PrintCollation;
colorMode: Windows$Windows$Graphics.Printing.PrintColorMode;
duplex: Windows$Windows$Graphics.Printing.PrintDuplex;
holePunch: Windows$Windows$Graphics.Printing.PrintHolePunch;
maxCopies: number;
mediaSize: Windows$Windows$Graphics.Printing.PrintMediaSize;
mediaType: Windows$Windows$Graphics.Printing.PrintMediaType;
minCopies: number;
numberOfCopies: number;
orientation: Windows$Windows$Graphics.Printing.PrintOrientation;
printQuality: Windows$Windows$Graphics.Printing.PrintQuality;
staple: Windows$Windows$Graphics.Printing.PrintStaple;
displayedOptions: Windows$Windows$Foundation.Collections.IVector<string>;
getPageDescription(jobPageNumber: number): Windows$Windows$Graphics.Printing.PrintPageDescription
}
	declare export interface IStandardPrintTaskOptionsStatic {
binding: string,
collation: string,
colorMode: string,
copies: string,
duplex: string,
holePunch: string,
inputBin: string,
mediaSize: string,
mediaType: string,
nUp: string,
orientation: string,
printQuality: string,
staple: string
} 
	declare export class StandardPrintTaskOptions  {
static binding: string;
static collation: string;
static colorMode: string;
static copies: string;
static duplex: string;
static holePunch: string;
static inputBin: string;
static mediaSize: string;
static mediaType: string;
static nUp: string;
static orientation: string;
static printQuality: string;
static staple: string
}
	declare export interface IPrintDocumentSource {} 
	declare export interface IPrintTaskProgressingEventArgs {
documentPageCount: number
} 
	declare export class PrintTaskProgressingEventArgs mixins undefined.IPrintTaskProgressingEventArgs {
documentPageCount: number
}
	declare export  class PrintTaskCompletion {
  constructor(...args: empty): mixed;
static +abandoned: Class<PrintTaskCompletion__abandoned> & PrintTaskCompletion__abandoned & 0;// 0
static +canceled: Class<PrintTaskCompletion__canceled> & PrintTaskCompletion__canceled & 1;// 1
static +failed: Class<PrintTaskCompletion__failed> & PrintTaskCompletion__failed & 2;// 2
static +submitted: Class<PrintTaskCompletion__submitted> & PrintTaskCompletion__submitted & 3;// 3

}

declare class PrintTaskCompletion__abandoned mixins PrintTaskCompletion {}
declare class PrintTaskCompletion__canceled mixins PrintTaskCompletion {}
declare class PrintTaskCompletion__failed mixins PrintTaskCompletion {}
declare class PrintTaskCompletion__submitted mixins PrintTaskCompletion {}

	declare export interface IPrintTaskCompletedEventArgs {
completion: Windows$Windows$Graphics.Printing.PrintTaskCompletion
} 
	declare export class PrintTaskCompletedEventArgs mixins undefined.IPrintTaskCompletedEventArgs {
completion: Windows$Windows$Graphics.Printing.PrintTaskCompletion
}
	declare export interface IPrintTask {
options: Windows$Windows$Graphics.Printing.PrintTaskOptions,
properties: Windows$Windows$ApplicationModel.DataTransfer.DataPackagePropertySet,
source: Windows$Windows$Graphics.Printing.IPrintDocumentSource,
onpreviewing: any,
onsubmitting: any,
onprogressing: any,
oncompleted: any
} 
	declare export class PrintTask mixins undefined.IPrintTask {
options: Windows$Windows$Graphics.Printing.PrintTaskOptions;
properties: Windows$Windows$ApplicationModel.DataTransfer.DataPackagePropertySet;
source: Windows$Windows$Graphics.Printing.IPrintDocumentSource;
onpreviewing: any;
onsubmitting: any;
onprogressing: any;
oncompleted: any
}
	declare export interface IPrintTaskSourceRequestedDeferral {
complete(): void
} 
	declare export class PrintTaskSourceRequestedDeferral mixins undefined.IPrintTaskSourceRequestedDeferral {
complete(): void
}
	declare export interface IPrintTaskSourceRequestedArgs {
deadline: Date,
setSource(source: Windows$Windows$Graphics.Printing.IPrintDocumentSource): void,
getDeferral(): Windows$Windows$Graphics.Printing.PrintTaskSourceRequestedDeferral
} 
	declare export class PrintTaskSourceRequestedArgs mixins undefined.IPrintTaskSourceRequestedArgs {
deadline: Date;
setSource(source: Windows$Windows$Graphics.Printing.IPrintDocumentSource): void;
getDeferral(): Windows$Windows$Graphics.Printing.PrintTaskSourceRequestedDeferral
}
	declare export interface PrintTaskSourceRequestedHandler {
(args: Windows$Windows$Graphics.Printing.PrintTaskSourceRequestedArgs): void
} 
	declare export interface IPrintTaskRequestedDeferral {
complete(): void
} 
	declare export class PrintTaskRequestedDeferral mixins undefined.IPrintTaskRequestedDeferral {
complete(): void
}
	declare export interface IPrintTaskRequest {
deadline: Date,
createPrintTask(
title: string,
handler: Windows$Windows$Graphics.Printing.PrintTaskSourceRequestedHandler): Windows$Windows$Graphics.Printing.PrintTask,
getDeferral(): Windows$Windows$Graphics.Printing.PrintTaskRequestedDeferral
} 
	declare export class PrintTaskRequest mixins undefined.IPrintTaskRequest {
deadline: Date;
createPrintTask(
title: string,
handler: Windows$Windows$Graphics.Printing.PrintTaskSourceRequestedHandler): Windows$Windows$Graphics.Printing.PrintTask;
getDeferral(): Windows$Windows$Graphics.Printing.PrintTaskRequestedDeferral
}
	declare export interface IPrintTaskRequestedEventArgs {
request: Windows$Windows$Graphics.Printing.PrintTaskRequest
} 
	declare export class PrintTaskRequestedEventArgs mixins undefined.IPrintTaskRequestedEventArgs {
request: Windows$Windows$Graphics.Printing.PrintTaskRequest
}
	declare export interface IPrintManagerStatic {
getForCurrentView(): Windows$Windows$Graphics.Printing.PrintManager,
showPrintUIAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>
} 
	declare export class PrintManager mixins undefined.IPrintManager {
onprinttaskrequested: any;
static getForCurrentView(): Windows$Windows$Graphics.Printing.PrintManager;
static showPrintUIAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>
}
	declare export interface IPrintManager {
onprinttaskrequested: any
} 
    }

    }


declare module 'Management' {
        declare export  class IndexedResourceType {
  constructor(...args: empty): mixed;
static +string: Class<IndexedResourceType__string> & IndexedResourceType__string & 0;// 0
static +path: Class<IndexedResourceType__path> & IndexedResourceType__path & 1;// 1

}

declare class IndexedResourceType__string mixins IndexedResourceType {}
declare class IndexedResourceType__path mixins IndexedResourceType {}

	declare export interface IResourceIndexer {
indexFilePath(
filePath: Windows$Windows$Foundation.Uri): Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceCandidate,
indexFileContentsAsync(
file: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceCandidate>>
} 
	declare export class IndexedResourceCandidate mixins undefined.IIndexedResourceCandidate {
metadata: Windows$Windows$Foundation.Collections.IMapView<string, string>;
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceQualifier>;
type: Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceType;
uri: Windows$Windows$Foundation.Uri;
valueAsString: string;
getQualifierValue(qualifierName: string): string
}
	declare export interface IResourceIndexerFactory {
createResourceIndexer(
projectRoot: Windows$Windows$Foundation.Uri): Windows$Windows$ApplicationModel.Resources.Windows$Management.ResourceIndexer
} 
	declare export class ResourceIndexer mixins undefined.IResourceIndexer {
constructor(projectRoot: Windows$Windows$Foundation.Uri): this;
indexFilePath(
filePath: Windows$Windows$Foundation.Uri): Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceCandidate;
indexFileContentsAsync(
file: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceCandidate>>
}
	declare export interface IIndexedResourceQualifier {
qualifierName: string,
qualifierValue: string
} 
	declare export interface IIndexedResourceCandidate {
metadata: Windows$Windows$Foundation.Collections.IMapView<string, string>,
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceQualifier>,
type: Windows$Windows$ApplicationModel.Resources.Windows$Management.IndexedResourceType,
uri: Windows$Windows$Foundation.Uri,
valueAsString: string,
getQualifierValue(qualifierName: string): string
} 
	declare export class IndexedResourceQualifier mixins undefined.IIndexedResourceQualifier {
qualifierName: string;
qualifierValue: string
}
	declare module 'Deployment' {
        declare export  class DeploymentProgressState {
  constructor(...args: empty): mixed;
static +queued: Class<DeploymentProgressState__queued> & DeploymentProgressState__queued & 0;// 0
static +processing: Class<DeploymentProgressState__processing> & DeploymentProgressState__processing & 1;// 1

}

declare class DeploymentProgressState__queued mixins DeploymentProgressState {}
declare class DeploymentProgressState__processing mixins DeploymentProgressState {}

	declare export interface DeploymentProgress {
state: Windows$Windows$Management.Deployment.DeploymentProgressState,
percentage: number
} 
	declare export  class DeploymentOptions {
  constructor(...args: empty): mixed;
static +none: Class<DeploymentOptions__none> & DeploymentOptions__none & 0;// 0
static +forceApplicationShutdown: Class<DeploymentOptions__forceApplicationShutdown> & DeploymentOptions__forceApplicationShutdown & 1;// 1
static +developmentMode: Class<DeploymentOptions__developmentMode> & DeploymentOptions__developmentMode & 2;// 2

}

declare class DeploymentOptions__none mixins DeploymentOptions {}
declare class DeploymentOptions__forceApplicationShutdown mixins DeploymentOptions {}
declare class DeploymentOptions__developmentMode mixins DeploymentOptions {}

	declare export interface IDeploymentResult {
activityId: string,
errorText: string,
extendedErrorCode: number
} 
	declare export class DeploymentResult mixins undefined.IDeploymentResult {
activityId: string;
errorText: string;
extendedErrorCode: number
}
	declare export  class PackageInstallState {
  constructor(...args: empty): mixed;
static +notInstalled: Class<PackageInstallState__notInstalled> & PackageInstallState__notInstalled & 0;// 0
static +staged: Class<PackageInstallState__staged> & PackageInstallState__staged & 1;// 1
static +installed: Class<PackageInstallState__installed> & PackageInstallState__installed & 2;// 2

}

declare class PackageInstallState__notInstalled mixins PackageInstallState {}
declare class PackageInstallState__staged mixins PackageInstallState {}
declare class PackageInstallState__installed mixins PackageInstallState {}

	declare export interface IPackageUserInformation {
installState: Windows$Windows$Management.Deployment.PackageInstallState,
userSecurityId: string
} 
	declare export class PackageUserInformation mixins undefined.IPackageUserInformation {
installState: Windows$Windows$Management.Deployment.PackageInstallState;
userSecurityId: string
}
	declare export  class PackageState {
  constructor(...args: empty): mixed;
static +normal: Class<PackageState__normal> & PackageState__normal & 0;// 0
static +licenseInvalid: Class<PackageState__licenseInvalid> & PackageState__licenseInvalid & 1;// 1
static +modified: Class<PackageState__modified> & PackageState__modified & 2;// 2
static +tampered: Class<PackageState__tampered> & PackageState__tampered & 3;// 3

}

declare class PackageState__normal mixins PackageState {}
declare class PackageState__licenseInvalid mixins PackageState {}
declare class PackageState__modified mixins PackageState {}
declare class PackageState__tampered mixins PackageState {}

	declare export interface IPackageManager {
addPackageAsync(
packageUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
deploymentOptions: Windows$Windows$Management.Deployment.DeploymentOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>,
updatePackageAsync(
packageUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
deploymentOptions: Windows$Windows$Management.Deployment.DeploymentOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>,
removePackageAsync(
packageFullName: string): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>,
stagePackageAsync(
packageUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>,
registerPackageAsync(
manifestUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
deploymentOptions: Windows$Windows$Management.Deployment.DeploymentOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>,
findPackages(
): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>,
findPackagesForUser(
userSecurityId: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>,
findPackages(
packageName: string,
packagePublisher: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>,
findPackagesForUser(
userSecurityId: string,
packageName: string,
packagePublisher: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>,
findUsers(
packageFullName: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Management.Deployment.PackageUserInformation>,
setPackageState(
packageFullName: string,
packageState: Windows$Windows$Management.Deployment.PackageState): void,
findPackage(packageFullName: string): Windows$Windows$ApplicationModel.Package,
cleanupPackageForUserAsync(
packageName: string,
userSecurityId: string): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>,
findPackages(
packageFamilyName: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>,
findPackagesForUser(
userSecurityId: string,
packageFamilyName: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>,
findPackageForUser(
userSecurityId: string,
packageFullName: string): Windows$Windows$ApplicationModel.Package
} 
	declare export class PackageManager mixins undefined.IPackageManager {
addPackageAsync(
packageUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
deploymentOptions: Windows$Windows$Management.Deployment.DeploymentOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>;
updatePackageAsync(
packageUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
deploymentOptions: Windows$Windows$Management.Deployment.DeploymentOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>;
removePackageAsync(
packageFullName: string): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>;
stagePackageAsync(
packageUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>;
registerPackageAsync(
manifestUri: Windows$Windows$Foundation.Uri,
dependencyPackageUris: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
deploymentOptions: Windows$Windows$Management.Deployment.DeploymentOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>;
findPackages(
): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>;
findPackagesForUser(
userSecurityId: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>;
findPackages(
packageName: string,
packagePublisher: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>;
findPackagesForUser(
userSecurityId: string,
packageName: string,
packagePublisher: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>;
findUsers(
packageFullName: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Management.Deployment.PackageUserInformation>;
setPackageState(
packageFullName: string,
packageState: Windows$Windows$Management.Deployment.PackageState): void;
findPackage(packageFullName: string): Windows$Windows$ApplicationModel.Package;
cleanupPackageForUserAsync(
packageName: string,
userSecurityId: string): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Management.Deployment.DeploymentResult, Windows$Windows$Management.Deployment.DeploymentProgress>;
findPackages(
packageFamilyName: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>;
findPackagesForUser(
userSecurityId: string,
packageFamilyName: string): Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Package>;
findPackageForUser(
userSecurityId: string,
packageFullName: string): Windows$Windows$ApplicationModel.Package
}
    }

	declare module 'Core' {
        declare export class CoreApplication  {
static mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>;
static id: string;
static properties: Windows$Windows$Foundation.Collections.IPropertySet;
static incrementApplicationUseCount(): void;
static decrementApplicationUseCount(): void;
static createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static exit(): void;
static onexiting: any;
static onsuspending: any;
static onresuming: any;
static getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void;
static runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
}
	declare export class CoreApplicationView mixins undefined.ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow;
isHosted: boolean;
isMain: boolean;
onactivated: any
}
	declare export interface IFrameworkView {
initialize(
applicationView: Windows$Windows$ApplicationModel.Core.CoreApplicationView): void,
setWindow(window: Windows$Windows$UI.Core.CoreWindow): void,
load(entryPoint: string): void,
run(): void,
uninitialize(): void
} 
	declare export interface IFrameworkViewSource {
createView(): Windows$Windows$ApplicationModel.Core.IFrameworkView
} 
	declare export interface ICoreApplication {
id: string,
properties: Windows$Windows$Foundation.Collections.IPropertySet,
onsuspending: any,
onresuming: any,
getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView,
run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void,
runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
} 
	declare export interface ICoreApplicationUseCount {
incrementApplicationUseCount(): void,
decrementApplicationUseCount(): void
} 
	declare export interface ICoreApplicationExit {
exit(): void,
onexiting: any
} 
	declare export interface ICoreImmersiveApplication {
mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView,
views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>,
createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView
} 
	declare export interface ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow,
isHosted: boolean,
isMain: boolean,
onactivated: any
} 
	declare export interface IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext,
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap,
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void,
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void
} 
	declare export class ResourceMap mixins undefined.IResourceMap, undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
uri: Windows$Windows$Foundation.Uri;
size: number;
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.NamedResource;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>
}
	declare export class ResourceContext mixins undefined.IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>;
reset(): void;
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void;
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void;
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
static createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
}
	declare export interface IResourceManagerStatics {
current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager,
isResourceReference(resourceReference: string): boolean
} 
	declare export class ResourceManager mixins undefined.IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
static current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager;
static isResourceReference(resourceReference: string): boolean
}
	declare export interface IResourceQualifier {
isDefault: boolean,
isMatch: boolean,
qualifierName: string,
qualifierValue: string,
score: number
} 
	declare export class ResourceQualifier mixins undefined.IResourceQualifier {
isDefault: boolean;
isMatch: boolean;
qualifierName: string;
qualifierValue: string;
score: number
}
	declare export interface IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>,
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>,
reset(): void,
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void,
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void,
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceContextStatics {
createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceCandidate {
isDefault: boolean,
isMatch: boolean,
isMatchAsDefault: boolean,
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>,
valueAsString: string,
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
getQualifierValue(qualifierName: string): string
} 
	declare export class ResourceCandidate mixins undefined.IResourceCandidate {
isDefault: boolean;
isMatch: boolean;
isMatchAsDefault: boolean;
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
valueAsString: string;
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
getQualifierValue(qualifierName: string): string
}
	declare export interface INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
uri: Windows$Windows$Foundation.Uri,
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
} 
	declare export class NamedResource mixins undefined.INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
uri: Windows$Windows$Foundation.Uri;
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
}
	declare export type IResourceMap = {
uri: Windows$Windows$Foundation.Uri,
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap
} & undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource> & undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>

	declare export class ResourceMapIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>[],
returnValue: number
}
}
	declare export class ResourceMapMapView mixins undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
size: number;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>>
}
	declare export class ResourceMapMapViewIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>[],
returnValue: number
}
}
	declare export class ResourceQualifierObservableMap mixins undefined.IObservableMap<string, string>, undefined.IMap<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
onmapchanged: any;
lookup(key: string): string;
hasKey(key: string): boolean;
getView(): Windows$Windows$Foundation.Collections.IMapView<string, string>;
insert(key: string, value: string): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierMapView mixins undefined.IMapView<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
lookup(key: string): string;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, string>,
second: Windows$Windows$Foundation.Collections.IMapView<string, string>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceCandidateVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceContextLanguagesVectorView mixins undefined.IVectorView<string>, undefined.IIterable<string> {
size: number;
getAt(index: number): string;
indexOf(value: string): {
index: number,
returnValue: boolean
};
getMany(startIndex: number): {
items: string[],
returnValue: number
};
first(): Windows$Windows$Foundation.Collections.IIterator<string>;
toString(): string;
toLocaleString(): string;
concat(...items: string[][]): string[];
join(seperator: string): string;
pop(): string;
push(...items: string[]): void;
reverse(): string[];
shift(): string;
slice(start: number): string[];
slice(start: number, end: number): string[];
sort(): string[];
sort(compareFn: (a: string, b: string) => number): string[];
splice(start: number): string[];
splice(start: number, deleteCount: number, ...items: string[]): string[];
unshift(...items: string[]): number;
lastIndexOf(searchElement: string): number;
lastIndexOf(searchElement: string, fromIndex: number): number;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
forEach(callbackfn: (value: string, index: number, array: string[]) => void): void;
forEach(
callbackfn: (value: string, index: number, array: string[]) => void,
thisArg: any): void;
map(callbackfn: (value: string, index: number, array: string[]) => any): any[];
map(
callbackfn: (value: string, index: number, array: string[]) => any,
thisArg: any): any[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean): string[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): string[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
length: number
}
	declare export interface IApplicationDataManagerStatics {
createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
} 
	declare export interface IApplicationDataManager {} 
	declare export class ApplicationDataManager mixins undefined.IApplicationDataManager {
static createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
}
	declare export  class CryptographicPrivateKeyBlobType {
  constructor(...args: empty): mixed;
static +pkcs8RawPrivateKeyInfo: Class<CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo> & CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo & 0;// 0
static +pkcs1RsaPrivateKey: Class<CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey> & CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey & 1;// 1
static +bCryptPrivateKey: Class<CryptographicPrivateKeyBlobType__bCryptPrivateKey> & CryptographicPrivateKeyBlobType__bCryptPrivateKey & 2;// 2
static +capi1PrivateKey: Class<CryptographicPrivateKeyBlobType__capi1PrivateKey> & CryptographicPrivateKeyBlobType__capi1PrivateKey & 3;// 3

}

declare class CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__bCryptPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__capi1PrivateKey mixins CryptographicPrivateKeyBlobType {}

	declare export  class CryptographicPublicKeyBlobType {
  constructor(...args: empty): mixed;
static +x509SubjectPublicKeyInfo: Class<CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo> & CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo & 0;// 0
static +pkcs1RsaPublicKey: Class<CryptographicPublicKeyBlobType__pkcs1RsaPublicKey> & CryptographicPublicKeyBlobType__pkcs1RsaPublicKey & 1;// 1
static +bCryptPublicKey: Class<CryptographicPublicKeyBlobType__bCryptPublicKey> & CryptographicPublicKeyBlobType__bCryptPublicKey & 2;// 2
static +capi1PublicKey: Class<CryptographicPublicKeyBlobType__capi1PublicKey> & CryptographicPublicKeyBlobType__capi1PublicKey & 3;// 3

}

declare class CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__pkcs1RsaPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__bCryptPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__capi1PublicKey mixins CryptographicPublicKeyBlobType {}

	declare export interface IKeyDerivationParameters {
iterationCount: number,
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export interface IKeyDerivationParametersStatics {
buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
} 
	declare export class KeyDerivationParameters mixins undefined.IKeyDerivationParameters {
iterationCount: number;
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer;
static buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
}
	declare export interface ICryptographicKey {
keySize: number,
export(): Windows$Windows$Storage.Streams.IBuffer,
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicKey mixins undefined.ICryptographicKey {
keySize: number;
export(): Windows$Windows$Storage.Streams.IBuffer;
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void,
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicHash mixins undefined.IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void;
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProvider {
algorithmName: string,
hashLength: number,
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash
} 
	declare export interface IMacAlgorithmProvider {
algorithmName: string,
macLength: number,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IKeyDerivationAlgorithmProvider {
algorithmName: string,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface ISymmetricKeyAlgorithmProvider {
algorithmName: string,
blockLength: number,
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IAsymmetricKeyAlgorithmProvider {
algorithmName: string,
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
encryptedData: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class EncryptedAndAuthenticatedData mixins undefined.IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer;
encryptedData: Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface ICryptographicEngineStatics {
encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData,
decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean,
deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicEngine  {
static encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData;
static decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean;
static deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
} 
	declare export class HashAlgorithmProvider mixins undefined.IHashAlgorithmProvider {
algorithmName: string;
hashLength: number;
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
}
	declare export interface IMacAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
} 
	declare export class MacAlgorithmProvider mixins undefined.IMacAlgorithmProvider {
algorithmName: string;
macLength: number;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
}
	declare export interface IKeyDerivationAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
} 
	declare export class KeyDerivationAlgorithmProvider mixins undefined.IKeyDerivationAlgorithmProvider {
algorithmName: string;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
}
	declare export interface ISymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
} 
	declare export class SymmetricKeyAlgorithmProvider mixins undefined.ISymmetricKeyAlgorithmProvider {
algorithmName: string;
blockLength: number;
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
}
	declare export interface IAsymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
} 
	declare export class AsymmetricKeyAlgorithmProvider mixins undefined.IAsymmetricKeyAlgorithmProvider {
algorithmName: string;
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
}
	declare export interface IHashAlgorithmNamesStatics {
md5: string,
sha1: string,
sha256: string,
sha384: string,
sha512: string
} 
	declare export class HashAlgorithmNames  {
static md5: string;
static sha1: string;
static sha256: string;
static sha384: string;
static sha512: string
}
	declare export interface IMacAlgorithmNamesStatics {
aesCmac: string,
hmacMd5: string,
hmacSha1: string,
hmacSha256: string,
hmacSha384: string,
hmacSha512: string
} 
	declare export class MacAlgorithmNames  {
static aesCmac: string;
static hmacMd5: string;
static hmacSha1: string;
static hmacSha256: string;
static hmacSha384: string;
static hmacSha512: string
}
	declare export interface ISymmetricAlgorithmNamesStatics {
aesCbc: string,
aesCbcPkcs7: string,
aesCcm: string,
aesEcb: string,
aesEcbPkcs7: string,
aesGcm: string,
desCbc: string,
desCbcPkcs7: string,
desEcb: string,
desEcbPkcs7: string,
rc2Cbc: string,
rc2CbcPkcs7: string,
rc2Ecb: string,
rc2EcbPkcs7: string,
rc4: string,
tripleDesCbc: string,
tripleDesCbcPkcs7: string,
tripleDesEcb: string,
tripleDesEcbPkcs7: string
} 
	declare export class SymmetricAlgorithmNames  {
static aesCbc: string;
static aesCbcPkcs7: string;
static aesCcm: string;
static aesEcb: string;
static aesEcbPkcs7: string;
static aesGcm: string;
static desCbc: string;
static desCbcPkcs7: string;
static desEcb: string;
static desEcbPkcs7: string;
static rc2Cbc: string;
static rc2CbcPkcs7: string;
static rc2Ecb: string;
static rc2EcbPkcs7: string;
static rc4: string;
static tripleDesCbc: string;
static tripleDesCbcPkcs7: string;
static tripleDesEcb: string;
static tripleDesEcbPkcs7: string
}
	declare export interface IAsymmetricAlgorithmNamesStatics {
dsaSha1: string,
dsaSha256: string,
ecdsaP256Sha256: string,
ecdsaP384Sha384: string,
ecdsaP521Sha512: string,
rsaOaepSha1: string,
rsaOaepSha256: string,
rsaOaepSha384: string,
rsaOaepSha512: string,
rsaPkcs1: string,
rsaSignPkcs1Sha1: string,
rsaSignPkcs1Sha256: string,
rsaSignPkcs1Sha384: string,
rsaSignPkcs1Sha512: string,
rsaSignPssSha1: string,
rsaSignPssSha256: string,
rsaSignPssSha384: string,
rsaSignPssSha512: string
} 
	declare export class AsymmetricAlgorithmNames  {
static dsaSha1: string;
static dsaSha256: string;
static ecdsaP256Sha256: string;
static ecdsaP384Sha384: string;
static ecdsaP521Sha512: string;
static rsaOaepSha1: string;
static rsaOaepSha256: string;
static rsaOaepSha384: string;
static rsaOaepSha512: string;
static rsaPkcs1: string;
static rsaSignPkcs1Sha1: string;
static rsaSignPkcs1Sha256: string;
static rsaSignPkcs1Sha384: string;
static rsaSignPkcs1Sha512: string;
static rsaSignPssSha1: string;
static rsaSignPssSha256: string;
static rsaSignPssSha384: string;
static rsaSignPssSha512: string
}
	declare export interface IKeyDerivationAlgorithmNamesStatics {
pbkdf2Md5: string,
pbkdf2Sha1: string,
pbkdf2Sha256: string,
pbkdf2Sha384: string,
pbkdf2Sha512: string,
sp800108CtrHmacMd5: string,
sp800108CtrHmacSha1: string,
sp800108CtrHmacSha256: string,
sp800108CtrHmacSha384: string,
sp800108CtrHmacSha512: string,
sp80056aConcatMd5: string,
sp80056aConcatSha1: string,
sp80056aConcatSha256: string,
sp80056aConcatSha384: string,
sp80056aConcatSha512: string
} 
	declare export class KeyDerivationAlgorithmNames  {
static pbkdf2Md5: string;
static pbkdf2Sha1: string;
static pbkdf2Sha256: string;
static pbkdf2Sha384: string;
static pbkdf2Sha512: string;
static sp800108CtrHmacMd5: string;
static sp800108CtrHmacSha1: string;
static sp800108CtrHmacSha256: string;
static sp800108CtrHmacSha384: string;
static sp800108CtrHmacSha512: string;
static sp80056aConcatMd5: string;
static sp80056aConcatSha1: string;
static sp80056aConcatSha256: string;
static sp80056aConcatSha384: string;
static sp80056aConcatSha512: string
}
	declare export interface SignalHandler {
(signalNotifier: Windows$Windows$System.Threading.Core.SignalNotifier, timedOut: boolean): void
} 
	declare export class SignalNotifier mixins undefined.ISignalNotifier {
enable(): void;
terminate(): void;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
}
	declare export interface ISignalNotifierStatics {
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
} 
	declare export interface IPreallocatedWorkItemFactory {
createWorkItem(
handler: Windows$Windows$System.Threading.WorkItemHandler): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriority(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriorityAndOptions(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority,
options: Windows$Windows$System.Threading.WorkItemOptions): Windows$Windows$System.Threading.Core.PreallocatedWorkItem
} 
	declare export class PreallocatedWorkItem mixins undefined.IPreallocatedWorkItem {
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority, options: Windows$Windows$System.Threading.WorkItemOptions): this;
runAsync(): Windows$Windows$Foundation.IAsyncAction
}
	declare export interface IPreallocatedWorkItem {
runAsync(): Windows$Windows$Foundation.IAsyncAction
} 
	declare export interface ISignalNotifier {
enable(): void,
terminate(): void
} 
	declare module 'AnimationMetrics' {
        declare export  class PropertyAnimationType {
  constructor(...args: empty): mixed;
static +scale: Class<PropertyAnimationType__scale> & PropertyAnimationType__scale & 0;// 0
static +translation: Class<PropertyAnimationType__translation> & PropertyAnimationType__translation & 1;// 1
static +opacity: Class<PropertyAnimationType__opacity> & PropertyAnimationType__opacity & 2;// 2

}

declare class PropertyAnimationType__scale mixins PropertyAnimationType {}
declare class PropertyAnimationType__translation mixins PropertyAnimationType {}
declare class PropertyAnimationType__opacity mixins PropertyAnimationType {}

	declare export interface IPropertyAnimation {
control1: Windows$Windows$Foundation.Point,
control2: Windows$Windows$Foundation.Point,
delay: number,
duration: number,
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
} 
	declare export type IScaleAnimation = {
finalScaleX: number,
finalScaleY: number,
initialScaleX: number,
initialScaleY: number,
normalizedOrigin: Windows$Windows$Foundation.Point
} & undefined.IPropertyAnimation

	declare export type IOpacityAnimation = {
finalOpacity: number,
initialOpacity: number
} & undefined.IPropertyAnimation

	declare export  class AnimationEffect {
  constructor(...args: empty): mixed;
static +expand: Class<AnimationEffect__expand> & AnimationEffect__expand & 0;// 0
static +collapse: Class<AnimationEffect__collapse> & AnimationEffect__collapse & 1;// 1
static +reposition: Class<AnimationEffect__reposition> & AnimationEffect__reposition & 2;// 2
static +fadeIn: Class<AnimationEffect__fadeIn> & AnimationEffect__fadeIn & 3;// 3
static +fadeOut: Class<AnimationEffect__fadeOut> & AnimationEffect__fadeOut & 4;// 4
static +addToList: Class<AnimationEffect__addToList> & AnimationEffect__addToList & 5;// 5
static +deleteFromList: Class<AnimationEffect__deleteFromList> & AnimationEffect__deleteFromList & 6;// 6
static +addToGrid: Class<AnimationEffect__addToGrid> & AnimationEffect__addToGrid & 7;// 7
static +deleteFromGrid: Class<AnimationEffect__deleteFromGrid> & AnimationEffect__deleteFromGrid & 8;// 8
static +addToSearchGrid: Class<AnimationEffect__addToSearchGrid> & AnimationEffect__addToSearchGrid & 9;// 9
static +deleteFromSearchGrid: Class<AnimationEffect__deleteFromSearchGrid> & AnimationEffect__deleteFromSearchGrid & 10;// 10
static +addToSearchList: Class<AnimationEffect__addToSearchList> & AnimationEffect__addToSearchList & 11;// 11
static +deleteFromSearchList: Class<AnimationEffect__deleteFromSearchList> & AnimationEffect__deleteFromSearchList & 12;// 12
static +showEdgeUI: Class<AnimationEffect__showEdgeUI> & AnimationEffect__showEdgeUI & 13;// 13
static +showPanel: Class<AnimationEffect__showPanel> & AnimationEffect__showPanel & 14;// 14
static +hideEdgeUI: Class<AnimationEffect__hideEdgeUI> & AnimationEffect__hideEdgeUI & 15;// 15
static +hidePanel: Class<AnimationEffect__hidePanel> & AnimationEffect__hidePanel & 16;// 16
static +showPopup: Class<AnimationEffect__showPopup> & AnimationEffect__showPopup & 17;// 17
static +hidePopup: Class<AnimationEffect__hidePopup> & AnimationEffect__hidePopup & 18;// 18
static +pointerDown: Class<AnimationEffect__pointerDown> & AnimationEffect__pointerDown & 19;// 19
static +pointerUp: Class<AnimationEffect__pointerUp> & AnimationEffect__pointerUp & 20;// 20
static +dragSourceStart: Class<AnimationEffect__dragSourceStart> & AnimationEffect__dragSourceStart & 21;// 21
static +dragSourceEnd: Class<AnimationEffect__dragSourceEnd> & AnimationEffect__dragSourceEnd & 22;// 22
static +transitionContent: Class<AnimationEffect__transitionContent> & AnimationEffect__transitionContent & 23;// 23
static +reveal: Class<AnimationEffect__reveal> & AnimationEffect__reveal & 24;// 24
static +hide: Class<AnimationEffect__hide> & AnimationEffect__hide & 25;// 25
static +dragBetweenEnter: Class<AnimationEffect__dragBetweenEnter> & AnimationEffect__dragBetweenEnter & 26;// 26
static +dragBetweenLeave: Class<AnimationEffect__dragBetweenLeave> & AnimationEffect__dragBetweenLeave & 27;// 27
static +swipeSelect: Class<AnimationEffect__swipeSelect> & AnimationEffect__swipeSelect & 28;// 28
static +swipeDeselect: Class<AnimationEffect__swipeDeselect> & AnimationEffect__swipeDeselect & 29;// 29
static +swipeReveal: Class<AnimationEffect__swipeReveal> & AnimationEffect__swipeReveal & 30;// 30
static +enterPage: Class<AnimationEffect__enterPage> & AnimationEffect__enterPage & 31;// 31
static +transitionPage: Class<AnimationEffect__transitionPage> & AnimationEffect__transitionPage & 32;// 32
static +crossFade: Class<AnimationEffect__crossFade> & AnimationEffect__crossFade & 33;// 33
static +peek: Class<AnimationEffect__peek> & AnimationEffect__peek & 34;// 34
static +updateBadge: Class<AnimationEffect__updateBadge> & AnimationEffect__updateBadge & 35;// 35

}

declare class AnimationEffect__expand mixins AnimationEffect {}
declare class AnimationEffect__collapse mixins AnimationEffect {}
declare class AnimationEffect__reposition mixins AnimationEffect {}
declare class AnimationEffect__fadeIn mixins AnimationEffect {}
declare class AnimationEffect__fadeOut mixins AnimationEffect {}
declare class AnimationEffect__addToList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromList mixins AnimationEffect {}
declare class AnimationEffect__addToGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchList mixins AnimationEffect {}
declare class AnimationEffect__showEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__showPanel mixins AnimationEffect {}
declare class AnimationEffect__hideEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__hidePanel mixins AnimationEffect {}
declare class AnimationEffect__showPopup mixins AnimationEffect {}
declare class AnimationEffect__hidePopup mixins AnimationEffect {}
declare class AnimationEffect__pointerDown mixins AnimationEffect {}
declare class AnimationEffect__pointerUp mixins AnimationEffect {}
declare class AnimationEffect__dragSourceStart mixins AnimationEffect {}
declare class AnimationEffect__dragSourceEnd mixins AnimationEffect {}
declare class AnimationEffect__transitionContent mixins AnimationEffect {}
declare class AnimationEffect__reveal mixins AnimationEffect {}
declare class AnimationEffect__hide mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenEnter mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenLeave mixins AnimationEffect {}
declare class AnimationEffect__swipeSelect mixins AnimationEffect {}
declare class AnimationEffect__swipeDeselect mixins AnimationEffect {}
declare class AnimationEffect__swipeReveal mixins AnimationEffect {}
declare class AnimationEffect__enterPage mixins AnimationEffect {}
declare class AnimationEffect__transitionPage mixins AnimationEffect {}
declare class AnimationEffect__crossFade mixins AnimationEffect {}
declare class AnimationEffect__peek mixins AnimationEffect {}
declare class AnimationEffect__updateBadge mixins AnimationEffect {}

	declare export  class AnimationEffectTarget {
  constructor(...args: empty): mixed;
static +primary: Class<AnimationEffectTarget__primary> & AnimationEffectTarget__primary & 0;// 0
static +added: Class<AnimationEffectTarget__added> & AnimationEffectTarget__added & 1;// 1
static +affected: Class<AnimationEffectTarget__affected> & AnimationEffectTarget__affected & 2;// 2
static +background: Class<AnimationEffectTarget__background> & AnimationEffectTarget__background & 3;// 3
static +content: Class<AnimationEffectTarget__content> & AnimationEffectTarget__content & 4;// 4
static +deleted: Class<AnimationEffectTarget__deleted> & AnimationEffectTarget__deleted & 5;// 5
static +deselected: Class<AnimationEffectTarget__deselected> & AnimationEffectTarget__deselected & 6;// 6
static +dragSource: Class<AnimationEffectTarget__dragSource> & AnimationEffectTarget__dragSource & 7;// 7
static +hidden: Class<AnimationEffectTarget__hidden> & AnimationEffectTarget__hidden & 8;// 8
static +incoming: Class<AnimationEffectTarget__incoming> & AnimationEffectTarget__incoming & 9;// 9
static +outgoing: Class<AnimationEffectTarget__outgoing> & AnimationEffectTarget__outgoing & 10;// 10
static +outline: Class<AnimationEffectTarget__outline> & AnimationEffectTarget__outline & 11;// 11
static +remaining: Class<AnimationEffectTarget__remaining> & AnimationEffectTarget__remaining & 12;// 12
static +revealed: Class<AnimationEffectTarget__revealed> & AnimationEffectTarget__revealed & 13;// 13
static +rowIn: Class<AnimationEffectTarget__rowIn> & AnimationEffectTarget__rowIn & 14;// 14
static +rowOut: Class<AnimationEffectTarget__rowOut> & AnimationEffectTarget__rowOut & 15;// 15
static +selected: Class<AnimationEffectTarget__selected> & AnimationEffectTarget__selected & 16;// 16
static +selection: Class<AnimationEffectTarget__selection> & AnimationEffectTarget__selection & 17;// 17
static +shown: Class<AnimationEffectTarget__shown> & AnimationEffectTarget__shown & 18;// 18
static +tapped: Class<AnimationEffectTarget__tapped> & AnimationEffectTarget__tapped & 19;// 19

}

declare class AnimationEffectTarget__primary mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__added mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__affected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__background mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__content mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deleted mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deselected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__dragSource mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__hidden mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__incoming mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outgoing mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outline mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__remaining mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__revealed mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowIn mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowOut mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selection mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__shown mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__tapped mixins AnimationEffectTarget {}

	declare export interface IAnimationDescription {
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>,
delayLimit: number,
staggerDelay: number,
staggerDelayFactor: number,
zOrder: number
} 
	declare export interface IAnimationDescriptionFactory {
createInstance(
effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect,
target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): Windows$Windows$UI.Core.AnimationMetrics.AnimationDescription
} 
	declare export class AnimationDescription mixins undefined.IAnimationDescription {
constructor(effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect, target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): this;
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>;
delayLimit: number;
staggerDelay: number;
staggerDelayFactor: number;
zOrder: number
}
	declare export class PropertyAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class ScaleAnimation mixins undefined.IScaleAnimation, undefined.IPropertyAnimation {
finalScaleX: number;
finalScaleY: number;
initialScaleX: number;
initialScaleY: number;
normalizedOrigin: Windows$Windows$Foundation.Point;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class TranslationAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class OpacityAnimation mixins undefined.IOpacityAnimation, undefined.IPropertyAnimation {
finalOpacity: number;
initialOpacity: number;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
    }

	declare export  class CoreWindowActivationState {
  constructor(...args: empty): mixed;
static +codeActivated: Class<CoreWindowActivationState__codeActivated> & CoreWindowActivationState__codeActivated & 0;// 0
static +deactivated: Class<CoreWindowActivationState__deactivated> & CoreWindowActivationState__deactivated & 1;// 1
static +pointerActivated: Class<CoreWindowActivationState__pointerActivated> & CoreWindowActivationState__pointerActivated & 2;// 2

}

declare class CoreWindowActivationState__codeActivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__deactivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__pointerActivated mixins CoreWindowActivationState {}

	declare export  class CoreCursorType {
  constructor(...args: empty): mixed;
static +arrow: Class<CoreCursorType__arrow> & CoreCursorType__arrow & 0;// 0
static +cross: Class<CoreCursorType__cross> & CoreCursorType__cross & 1;// 1
static +custom: Class<CoreCursorType__custom> & CoreCursorType__custom & 2;// 2
static +hand: Class<CoreCursorType__hand> & CoreCursorType__hand & 3;// 3
static +help: Class<CoreCursorType__help> & CoreCursorType__help & 4;// 4
static +iBeam: Class<CoreCursorType__iBeam> & CoreCursorType__iBeam & 5;// 5
static +sizeAll: Class<CoreCursorType__sizeAll> & CoreCursorType__sizeAll & 6;// 6
static +sizeNortheastSouthwest: Class<CoreCursorType__sizeNortheastSouthwest> & CoreCursorType__sizeNortheastSouthwest & 7;// 7
static +sizeNorthSouth: Class<CoreCursorType__sizeNorthSouth> & CoreCursorType__sizeNorthSouth & 8;// 8
static +sizeNorthwestSoutheast: Class<CoreCursorType__sizeNorthwestSoutheast> & CoreCursorType__sizeNorthwestSoutheast & 9;// 9
static +sizeWestEast: Class<CoreCursorType__sizeWestEast> & CoreCursorType__sizeWestEast & 10;// 10
static +universalNo: Class<CoreCursorType__universalNo> & CoreCursorType__universalNo & 11;// 11
static +upArrow: Class<CoreCursorType__upArrow> & CoreCursorType__upArrow & 12;// 12
static +wait: Class<CoreCursorType__wait> & CoreCursorType__wait & 13;// 13

}

declare class CoreCursorType__arrow mixins CoreCursorType {}
declare class CoreCursorType__cross mixins CoreCursorType {}
declare class CoreCursorType__custom mixins CoreCursorType {}
declare class CoreCursorType__hand mixins CoreCursorType {}
declare class CoreCursorType__help mixins CoreCursorType {}
declare class CoreCursorType__iBeam mixins CoreCursorType {}
declare class CoreCursorType__sizeAll mixins CoreCursorType {}
declare class CoreCursorType__sizeNortheastSouthwest mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthSouth mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthwestSoutheast mixins CoreCursorType {}
declare class CoreCursorType__sizeWestEast mixins CoreCursorType {}
declare class CoreCursorType__universalNo mixins CoreCursorType {}
declare class CoreCursorType__upArrow mixins CoreCursorType {}
declare class CoreCursorType__wait mixins CoreCursorType {}

	declare export  class CoreDispatcherPriority {
  constructor(...args: empty): mixed;
static +low: Class<CoreDispatcherPriority__low> & CoreDispatcherPriority__low & 0;// 0
static +normal: Class<CoreDispatcherPriority__normal> & CoreDispatcherPriority__normal & 1;// 1
static +high: Class<CoreDispatcherPriority__high> & CoreDispatcherPriority__high & 2;// 2

}

declare class CoreDispatcherPriority__low mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__normal mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__high mixins CoreDispatcherPriority {}

	declare export  class CoreProcessEventsOption {
  constructor(...args: empty): mixed;
static +processOneAndAllPending: Class<CoreProcessEventsOption__processOneAndAllPending> & CoreProcessEventsOption__processOneAndAllPending & 0;// 0
static +processOneIfPresent: Class<CoreProcessEventsOption__processOneIfPresent> & CoreProcessEventsOption__processOneIfPresent & 1;// 1
static +processUntilQuit: Class<CoreProcessEventsOption__processUntilQuit> & CoreProcessEventsOption__processUntilQuit & 2;// 2
static +processAllIfPresent: Class<CoreProcessEventsOption__processAllIfPresent> & CoreProcessEventsOption__processAllIfPresent & 3;// 3

}

declare class CoreProcessEventsOption__processOneAndAllPending mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processOneIfPresent mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processUntilQuit mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processAllIfPresent mixins CoreProcessEventsOption {}

	declare export  class CoreWindowFlowDirection {
  constructor(...args: empty): mixed;
static +leftToRight: Class<CoreWindowFlowDirection__leftToRight> & CoreWindowFlowDirection__leftToRight & 0;// 0
static +rightToLeft: Class<CoreWindowFlowDirection__rightToLeft> & CoreWindowFlowDirection__rightToLeft & 1;// 1

}

declare class CoreWindowFlowDirection__leftToRight mixins CoreWindowFlowDirection {}
declare class CoreWindowFlowDirection__rightToLeft mixins CoreWindowFlowDirection {}

	declare export  class CoreVirtualKeyStates {
  constructor(...args: empty): mixed;
static +none: Class<CoreVirtualKeyStates__none> & CoreVirtualKeyStates__none & 0;// 0
static +down: Class<CoreVirtualKeyStates__down> & CoreVirtualKeyStates__down & 1;// 1
static +locked: Class<CoreVirtualKeyStates__locked> & CoreVirtualKeyStates__locked & 2;// 2

}

declare class CoreVirtualKeyStates__none mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__down mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__locked mixins CoreVirtualKeyStates {}

	declare export  class CoreAcceleratorKeyEventType {
  constructor(...args: empty): mixed;
static +character: Class<CoreAcceleratorKeyEventType__character> & CoreAcceleratorKeyEventType__character & 0;// 0
static +deadCharacter: Class<CoreAcceleratorKeyEventType__deadCharacter> & CoreAcceleratorKeyEventType__deadCharacter & 1;// 1
static +keyDown: Class<CoreAcceleratorKeyEventType__keyDown> & CoreAcceleratorKeyEventType__keyDown & 2;// 2
static +keyUp: Class<CoreAcceleratorKeyEventType__keyUp> & CoreAcceleratorKeyEventType__keyUp & 3;// 3
static +systemCharacter: Class<CoreAcceleratorKeyEventType__systemCharacter> & CoreAcceleratorKeyEventType__systemCharacter & 4;// 4
static +systemDeadCharacter: Class<CoreAcceleratorKeyEventType__systemDeadCharacter> & CoreAcceleratorKeyEventType__systemDeadCharacter & 5;// 5
static +systemKeyDown: Class<CoreAcceleratorKeyEventType__systemKeyDown> & CoreAcceleratorKeyEventType__systemKeyDown & 6;// 6
static +systemKeyUp: Class<CoreAcceleratorKeyEventType__systemKeyUp> & CoreAcceleratorKeyEventType__systemKeyUp & 7;// 7
static +unicodeCharacter: Class<CoreAcceleratorKeyEventType__unicodeCharacter> & CoreAcceleratorKeyEventType__unicodeCharacter & 8;// 8

}

declare class CoreAcceleratorKeyEventType__character mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__deadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemDeadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__unicodeCharacter mixins CoreAcceleratorKeyEventType {}

	declare export  class CoreProximityEvaluationScore {
  constructor(...args: empty): mixed;
static +closest: Class<CoreProximityEvaluationScore__closest> & CoreProximityEvaluationScore__closest & 0;// 0
static +farthest: Class<CoreProximityEvaluationScore__farthest> & CoreProximityEvaluationScore__farthest & 1;// 1

}

declare class CoreProximityEvaluationScore__closest mixins CoreProximityEvaluationScore {}
declare class CoreProximityEvaluationScore__farthest mixins CoreProximityEvaluationScore {}

	declare export interface CorePhysicalKeyStatus {
repeatCount: number,
scanCode: number,
isExtendedKey: boolean,
isMenuKeyDown: boolean,
wasKeyDown: boolean,
isKeyReleased: boolean
} 
	declare export interface CoreProximityEvaluation {
score: number,
adjustedPoint: Windows$Windows$Foundation.Point
} 
	declare export interface ICoreWindowEventArgs {
handled: boolean
} 
	declare export type IAutomationProviderRequestedEventArgs = {
automationProvider: any
} & undefined.ICoreWindowEventArgs

	declare export type ICharacterReceivedEventArgs = {
keyCode: number,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus
} & undefined.ICoreWindowEventArgs

	declare export type IInputEnabledEventArgs = {
inputEnabled: boolean
} & undefined.ICoreWindowEventArgs

	declare export type IKeyEventArgs = {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export type IPointerEventArgs = {
currentPoint: Windows$Windows$UI.Input.PointerPoint,
keyModifiers: Windows$Windows$System.VirtualKeyModifiers,
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
} & undefined.ICoreWindowEventArgs

	declare export type ITouchHitTestingEventArgs = {
boundingBox: Windows$Windows$Foundation.Rect,
point: Windows$Windows$Foundation.Point,
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
} & undefined.ICoreWindowEventArgs

	declare export type IWindowActivatedEventArgs = {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState
} & undefined.ICoreWindowEventArgs

	declare export type IWindowSizeChangedEventArgs = {
size: Windows$Windows$Foundation.Size
} & undefined.ICoreWindowEventArgs

	declare export type IVisibilityChangedEventArgs = {
visible: boolean
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreWindow {
automationHostProvider: any,
bounds: Windows$Windows$Foundation.Rect,
customProperties: Windows$Windows$Foundation.Collections.IPropertySet,
dispatcher: Windows$Windows$UI.Core.CoreDispatcher,
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection,
isInputEnabled: boolean,
pointerCursor: Windows$Windows$UI.Core.CoreCursor,
pointerPosition: Windows$Windows$Foundation.Point,
visible: boolean,
activate(): void,
close(): void,
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
releasePointerCapture(): void,
setPointerCapture(): void,
onactivated: any,
onautomationproviderrequested: any,
oncharacterreceived: any,
onclosed: any,
oninputenabled: any,
onkeydown: any,
onkeyup: any,
onpointercapturelost: any,
onpointerentered: any,
onpointerexited: any,
onpointermoved: any,
onpointerpressed: any,
onpointerreleased: any,
ontouchhittesting: any,
onpointerwheelchanged: any,
onsizechanged: any,
onvisibilitychanged: any
} 
	declare export class CoreDispatcher mixins undefined.ICoreDispatcher, undefined.ICoreAcceleratorKeys {
hasThreadAccess: boolean;
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void;
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
onacceleratorkeyactivated: any
}
	declare export class CoreCursor mixins undefined.ICoreCursor {
constructor(type: Windows$Windows$UI.Core.CoreCursorType, id: number): this;
id: number;
type: Windows$Windows$UI.Core.CoreCursorType
}
	declare export class CoreWindow mixins undefined.ICoreWindow {
automationHostProvider: any;
bounds: Windows$Windows$Foundation.Rect;
customProperties: Windows$Windows$Foundation.Collections.IPropertySet;
dispatcher: Windows$Windows$UI.Core.CoreDispatcher;
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection;
isInputEnabled: boolean;
pointerCursor: Windows$Windows$UI.Core.CoreCursor;
pointerPosition: Windows$Windows$Foundation.Point;
visible: boolean;
activate(): void;
close(): void;
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
releasePointerCapture(): void;
setPointerCapture(): void;
onactivated: any;
onautomationproviderrequested: any;
oncharacterreceived: any;
onclosed: any;
oninputenabled: any;
onkeydown: any;
onkeyup: any;
onpointercapturelost: any;
onpointerentered: any;
onpointerexited: any;
onpointermoved: any;
onpointerpressed: any;
onpointerreleased: any;
ontouchhittesting: any;
onpointerwheelchanged: any;
onsizechanged: any;
onvisibilitychanged: any;
static getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
}
	declare export class WindowActivatedEventArgs mixins undefined.IWindowActivatedEventArgs, undefined.ICoreWindowEventArgs {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState;
handled: boolean
}
	declare export class AutomationProviderRequestedEventArgs mixins undefined.IAutomationProviderRequestedEventArgs, undefined.ICoreWindowEventArgs {
automationProvider: any;
handled: boolean
}
	declare export class CharacterReceivedEventArgs mixins undefined.ICharacterReceivedEventArgs, undefined.ICoreWindowEventArgs {
keyCode: number;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
handled: boolean
}
	declare export class CoreWindowEventArgs mixins undefined.ICoreWindowEventArgs {
handled: boolean
}
	declare export class InputEnabledEventArgs mixins undefined.IInputEnabledEventArgs, undefined.ICoreWindowEventArgs {
inputEnabled: boolean;
handled: boolean
}
	declare export class KeyEventArgs mixins undefined.IKeyEventArgs, undefined.ICoreWindowEventArgs {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export class PointerEventArgs mixins undefined.IPointerEventArgs, undefined.ICoreWindowEventArgs {
currentPoint: Windows$Windows$UI.Input.PointerPoint;
keyModifiers: Windows$Windows$System.VirtualKeyModifiers;
handled: boolean;
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
}
	declare export class TouchHitTestingEventArgs mixins undefined.ITouchHitTestingEventArgs, undefined.ICoreWindowEventArgs {
boundingBox: Windows$Windows$Foundation.Rect;
point: Windows$Windows$Foundation.Point;
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation;
handled: boolean;
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation;
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
}
	declare export class WindowSizeChangedEventArgs mixins undefined.IWindowSizeChangedEventArgs, undefined.ICoreWindowEventArgs {
size: Windows$Windows$Foundation.Size;
handled: boolean
}
	declare export class VisibilityChangedEventArgs mixins undefined.IVisibilityChangedEventArgs, undefined.ICoreWindowEventArgs {
visible: boolean;
handled: boolean
}
	declare export interface ICoreWindowStatic {
getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
} 
	declare export interface DispatchedHandler {
(): void
} 
	declare export interface IdleDispatchedHandler {
(e: Windows$Windows$UI.Core.IdleDispatchedHandlerArgs): void
} 
	declare export class IdleDispatchedHandlerArgs mixins undefined.IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
}
	declare export type IAcceleratorKeyEventArgs = {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
} 
	declare export class AcceleratorKeyEventArgs mixins undefined.IAcceleratorKeyEventArgs, undefined.ICoreWindowEventArgs {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export type ICoreDispatcher = {
hasThreadAccess: boolean,
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void,
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction,
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction
} & undefined.ICoreAcceleratorKeys

	declare export interface IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
} 
	declare export class CoreAcceleratorKeys mixins undefined.ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
}
	declare export interface ICoreCursor {
id: number,
type: Windows$Windows$UI.Core.CoreCursorType
} 
	declare export interface ICoreCursorFactory {
createCursor(
type: Windows$Windows$UI.Core.CoreCursorType,
id: number): Windows$Windows$UI.Core.CoreCursor
} 
	declare export interface IInitializeWithCoreWindow {
initialize(window: Windows$Windows$UI.Core.CoreWindow): void
} 
	declare export interface ICoreWindowResizeManager {
notifyLayoutCompleted(): void
} 
	declare export interface ICoreWindowResizeManagerStatics {
getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
} 
	declare export class CoreWindowResizeManager mixins undefined.ICoreWindowResizeManager {
notifyLayoutCompleted(): void;
static getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
}
	declare export interface ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
} 
	declare export class CoreWindowPopupShowingEventArgs mixins undefined.ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
}
	declare export interface ICoreWindowDialog {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
cancelCommandIndex: number,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowDialogFactory {
createWithTitle(title: string): Windows$Windows$UI.Core.CoreWindowDialog
} 
	declare export class CoreWindowDialog mixins undefined.ICoreWindowDialog {
constructor(title: string): this;
constructor(): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
cancelCommandIndex: number;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
	declare export interface ICoreWindowFlyout {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowFlyoutFactory {
create(
position: Windows$Windows$Foundation.Point): Windows$Windows$UI.Core.CoreWindowFlyout,
createWithTitle(
position: Windows$Windows$Foundation.Point,
title: string): Windows$Windows$UI.Core.CoreWindowFlyout
} 
	declare export class CoreWindowFlyout mixins undefined.ICoreWindowFlyout {
constructor(position: Windows$Windows$Foundation.Point): this;
constructor(position: Windows$Windows$Foundation.Point, title: string): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
    }

    }


declare module 'Media' {
        declare module 'Capture' {
        declare export  class CameraCaptureUIMode {
  constructor(...args: empty): mixed;
static +photoOrVideo: Class<CameraCaptureUIMode__photoOrVideo> & CameraCaptureUIMode__photoOrVideo & 0;// 0
static +photo: Class<CameraCaptureUIMode__photo> & CameraCaptureUIMode__photo & 1;// 1
static +video: Class<CameraCaptureUIMode__video> & CameraCaptureUIMode__video & 2;// 2

}

declare class CameraCaptureUIMode__photoOrVideo mixins CameraCaptureUIMode {}
declare class CameraCaptureUIMode__photo mixins CameraCaptureUIMode {}
declare class CameraCaptureUIMode__video mixins CameraCaptureUIMode {}

	declare export  class CameraCaptureUIPhotoFormat {
  constructor(...args: empty): mixed;
static +jpeg: Class<CameraCaptureUIPhotoFormat__jpeg> & CameraCaptureUIPhotoFormat__jpeg & 0;// 0
static +png: Class<CameraCaptureUIPhotoFormat__png> & CameraCaptureUIPhotoFormat__png & 1;// 1
static +jpegXR: Class<CameraCaptureUIPhotoFormat__jpegXR> & CameraCaptureUIPhotoFormat__jpegXR & 2;// 2

}

declare class CameraCaptureUIPhotoFormat__jpeg mixins CameraCaptureUIPhotoFormat {}
declare class CameraCaptureUIPhotoFormat__png mixins CameraCaptureUIPhotoFormat {}
declare class CameraCaptureUIPhotoFormat__jpegXR mixins CameraCaptureUIPhotoFormat {}

	declare export  class CameraCaptureUIVideoFormat {
  constructor(...args: empty): mixed;
static +mp4: Class<CameraCaptureUIVideoFormat__mp4> & CameraCaptureUIVideoFormat__mp4 & 0;// 0
static +wmv: Class<CameraCaptureUIVideoFormat__wmv> & CameraCaptureUIVideoFormat__wmv & 1;// 1

}

declare class CameraCaptureUIVideoFormat__mp4 mixins CameraCaptureUIVideoFormat {}
declare class CameraCaptureUIVideoFormat__wmv mixins CameraCaptureUIVideoFormat {}

	declare export  class CameraCaptureUIMaxVideoResolution {
  constructor(...args: empty): mixed;
static +highestAvailable: Class<CameraCaptureUIMaxVideoResolution__highestAvailable> & CameraCaptureUIMaxVideoResolution__highestAvailable & 0;// 0
static +lowDefinition: Class<CameraCaptureUIMaxVideoResolution__lowDefinition> & CameraCaptureUIMaxVideoResolution__lowDefinition & 1;// 1
static +standardDefinition: Class<CameraCaptureUIMaxVideoResolution__standardDefinition> & CameraCaptureUIMaxVideoResolution__standardDefinition & 2;// 2
static +highDefinition: Class<CameraCaptureUIMaxVideoResolution__highDefinition> & CameraCaptureUIMaxVideoResolution__highDefinition & 3;// 3

}

declare class CameraCaptureUIMaxVideoResolution__highestAvailable mixins CameraCaptureUIMaxVideoResolution {}
declare class CameraCaptureUIMaxVideoResolution__lowDefinition mixins CameraCaptureUIMaxVideoResolution {}
declare class CameraCaptureUIMaxVideoResolution__standardDefinition mixins CameraCaptureUIMaxVideoResolution {}
declare class CameraCaptureUIMaxVideoResolution__highDefinition mixins CameraCaptureUIMaxVideoResolution {}

	declare export  class CameraCaptureUIMaxPhotoResolution {
  constructor(...args: empty): mixed;
static +highestAvailable: Class<CameraCaptureUIMaxPhotoResolution__highestAvailable> & CameraCaptureUIMaxPhotoResolution__highestAvailable & 0;// 0
static +verySmallQvga: Class<CameraCaptureUIMaxPhotoResolution__verySmallQvga> & CameraCaptureUIMaxPhotoResolution__verySmallQvga & 1;// 1
static +smallVga: Class<CameraCaptureUIMaxPhotoResolution__smallVga> & CameraCaptureUIMaxPhotoResolution__smallVga & 2;// 2
static +mediumXga: Class<CameraCaptureUIMaxPhotoResolution__mediumXga> & CameraCaptureUIMaxPhotoResolution__mediumXga & 3;// 3
static +large3M: Class<CameraCaptureUIMaxPhotoResolution__large3M> & CameraCaptureUIMaxPhotoResolution__large3M & 4;// 4
static +veryLarge5M: Class<CameraCaptureUIMaxPhotoResolution__veryLarge5M> & CameraCaptureUIMaxPhotoResolution__veryLarge5M & 5;// 5

}

declare class CameraCaptureUIMaxPhotoResolution__highestAvailable mixins CameraCaptureUIMaxPhotoResolution {}
declare class CameraCaptureUIMaxPhotoResolution__verySmallQvga mixins CameraCaptureUIMaxPhotoResolution {}
declare class CameraCaptureUIMaxPhotoResolution__smallVga mixins CameraCaptureUIMaxPhotoResolution {}
declare class CameraCaptureUIMaxPhotoResolution__mediumXga mixins CameraCaptureUIMaxPhotoResolution {}
declare class CameraCaptureUIMaxPhotoResolution__large3M mixins CameraCaptureUIMaxPhotoResolution {}
declare class CameraCaptureUIMaxPhotoResolution__veryLarge5M mixins CameraCaptureUIMaxPhotoResolution {}

	declare export interface ICameraCaptureUIPhotoCaptureSettings {
allowCropping: boolean,
croppedAspectRatio: Windows$Windows$Foundation.Size,
croppedSizeInPixels: Windows$Windows$Foundation.Size,
format: Windows$Windows$Media.Capture.CameraCaptureUIPhotoFormat,
maxResolution: Windows$Windows$Media.Capture.CameraCaptureUIMaxPhotoResolution
} 
	declare export class CameraCaptureUIPhotoCaptureSettings mixins undefined.ICameraCaptureUIPhotoCaptureSettings {
allowCropping: boolean;
croppedAspectRatio: Windows$Windows$Foundation.Size;
croppedSizeInPixels: Windows$Windows$Foundation.Size;
format: Windows$Windows$Media.Capture.CameraCaptureUIPhotoFormat;
maxResolution: Windows$Windows$Media.Capture.CameraCaptureUIMaxPhotoResolution
}
	declare export interface ICameraCaptureUIVideoCaptureSettings {
allowTrimming: boolean,
format: Windows$Windows$Media.Capture.CameraCaptureUIVideoFormat,
maxDurationInSeconds: number,
maxResolution: Windows$Windows$Media.Capture.CameraCaptureUIMaxVideoResolution
} 
	declare export class CameraCaptureUIVideoCaptureSettings mixins undefined.ICameraCaptureUIVideoCaptureSettings {
allowTrimming: boolean;
format: Windows$Windows$Media.Capture.CameraCaptureUIVideoFormat;
maxDurationInSeconds: number;
maxResolution: Windows$Windows$Media.Capture.CameraCaptureUIMaxVideoResolution
}
	declare export interface ICameraCaptureUI {
photoSettings: Windows$Windows$Media.Capture.CameraCaptureUIPhotoCaptureSettings,
videoSettings: Windows$Windows$Media.Capture.CameraCaptureUIVideoCaptureSettings,
captureFileAsync(
mode: Windows$Windows$Media.Capture.CameraCaptureUIMode): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>
} 
	declare export class CameraCaptureUI mixins undefined.ICameraCaptureUI {
photoSettings: Windows$Windows$Media.Capture.CameraCaptureUIPhotoCaptureSettings;
videoSettings: Windows$Windows$Media.Capture.CameraCaptureUIVideoCaptureSettings;
captureFileAsync(
mode: Windows$Windows$Media.Capture.CameraCaptureUIMode): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>
}
	declare export interface ICameraOptionsUIStatics {
show(mediaCapture: Windows$Windows$Media.Capture.MediaCapture): void
} 
	declare export class CameraOptionsUI  {
static show(mediaCapture: Windows$Windows$Media.Capture.MediaCapture): void
}
	declare export  class MediaStreamType {
  constructor(...args: empty): mixed;
static +videoPreview: Class<MediaStreamType__videoPreview> & MediaStreamType__videoPreview & 0;// 0
static +videoRecord: Class<MediaStreamType__videoRecord> & MediaStreamType__videoRecord & 1;// 1
static +audio: Class<MediaStreamType__audio> & MediaStreamType__audio & 2;// 2
static +photo: Class<MediaStreamType__photo> & MediaStreamType__photo & 3;// 3

}

declare class MediaStreamType__videoPreview mixins MediaStreamType {}
declare class MediaStreamType__videoRecord mixins MediaStreamType {}
declare class MediaStreamType__audio mixins MediaStreamType {}
declare class MediaStreamType__photo mixins MediaStreamType {}

	declare export  class StreamingCaptureMode {
  constructor(...args: empty): mixed;
static +audioAndVideo: Class<StreamingCaptureMode__audioAndVideo> & StreamingCaptureMode__audioAndVideo & 0;// 0
static +audio: Class<StreamingCaptureMode__audio> & StreamingCaptureMode__audio & 1;// 1
static +video: Class<StreamingCaptureMode__video> & StreamingCaptureMode__video & 2;// 2

}

declare class StreamingCaptureMode__audioAndVideo mixins StreamingCaptureMode {}
declare class StreamingCaptureMode__audio mixins StreamingCaptureMode {}
declare class StreamingCaptureMode__video mixins StreamingCaptureMode {}

	declare export  class VideoRotation {
  constructor(...args: empty): mixed;
static +none: Class<VideoRotation__none> & VideoRotation__none & 0;// 0
static +clockwise90Degrees: Class<VideoRotation__clockwise90Degrees> & VideoRotation__clockwise90Degrees & 1;// 1
static +clockwise180Degrees: Class<VideoRotation__clockwise180Degrees> & VideoRotation__clockwise180Degrees & 2;// 2
static +clockwise270Degrees: Class<VideoRotation__clockwise270Degrees> & VideoRotation__clockwise270Degrees & 3;// 3

}

declare class VideoRotation__none mixins VideoRotation {}
declare class VideoRotation__clockwise90Degrees mixins VideoRotation {}
declare class VideoRotation__clockwise180Degrees mixins VideoRotation {}
declare class VideoRotation__clockwise270Degrees mixins VideoRotation {}

	declare export  class PhotoCaptureSource {
  constructor(...args: empty): mixed;
static +auto: Class<PhotoCaptureSource__auto> & PhotoCaptureSource__auto & 0;// 0
static +videoPreview: Class<PhotoCaptureSource__videoPreview> & PhotoCaptureSource__videoPreview & 1;// 1
static +photo: Class<PhotoCaptureSource__photo> & PhotoCaptureSource__photo & 2;// 2

}

declare class PhotoCaptureSource__auto mixins PhotoCaptureSource {}
declare class PhotoCaptureSource__videoPreview mixins PhotoCaptureSource {}
declare class PhotoCaptureSource__photo mixins PhotoCaptureSource {}

	declare export  class VideoDeviceCharacteristic {
  constructor(...args: empty): mixed;
static +allStreamsIndependent: Class<VideoDeviceCharacteristic__allStreamsIndependent> & VideoDeviceCharacteristic__allStreamsIndependent & 0;// 0
static +previewRecordStreamsIdentical: Class<VideoDeviceCharacteristic__previewRecordStreamsIdentical> & VideoDeviceCharacteristic__previewRecordStreamsIdentical & 1;// 1
static +previewPhotoStreamsIdentical: Class<VideoDeviceCharacteristic__previewPhotoStreamsIdentical> & VideoDeviceCharacteristic__previewPhotoStreamsIdentical & 2;// 2
static +recordPhotoStreamsIdentical: Class<VideoDeviceCharacteristic__recordPhotoStreamsIdentical> & VideoDeviceCharacteristic__recordPhotoStreamsIdentical & 3;// 3
static +allStreamsIdentical: Class<VideoDeviceCharacteristic__allStreamsIdentical> & VideoDeviceCharacteristic__allStreamsIdentical & 4;// 4

}

declare class VideoDeviceCharacteristic__allStreamsIndependent mixins VideoDeviceCharacteristic {}
declare class VideoDeviceCharacteristic__previewRecordStreamsIdentical mixins VideoDeviceCharacteristic {}
declare class VideoDeviceCharacteristic__previewPhotoStreamsIdentical mixins VideoDeviceCharacteristic {}
declare class VideoDeviceCharacteristic__recordPhotoStreamsIdentical mixins VideoDeviceCharacteristic {}
declare class VideoDeviceCharacteristic__allStreamsIdentical mixins VideoDeviceCharacteristic {}

	declare export  class PowerlineFrequency {
  constructor(...args: empty): mixed;
static +disabled: Class<PowerlineFrequency__disabled> & PowerlineFrequency__disabled & 0;// 0
static +fiftyHertz: Class<PowerlineFrequency__fiftyHertz> & PowerlineFrequency__fiftyHertz & 1;// 1
static +sixtyHertz: Class<PowerlineFrequency__sixtyHertz> & PowerlineFrequency__sixtyHertz & 2;// 2

}

declare class PowerlineFrequency__disabled mixins PowerlineFrequency {}
declare class PowerlineFrequency__fiftyHertz mixins PowerlineFrequency {}
declare class PowerlineFrequency__sixtyHertz mixins PowerlineFrequency {}

	declare export interface IMediaCaptureFailedEventArgs {
code: number,
message: string
} 
	declare export class MediaCaptureFailedEventArgs mixins undefined.IMediaCaptureFailedEventArgs {
code: number;
message: string
}
	declare export interface MediaCaptureFailedEventHandler {
(sender: Windows$Windows$Media.Capture.MediaCapture, errorEventArgs: Windows$Windows$Media.Capture.MediaCaptureFailedEventArgs): void
} 
	declare export class MediaCapture mixins undefined.IMediaCapture, undefined.IMediaCaptureVideoPreview {
audioDeviceController: Windows$Windows$Media.Windows$Devices.AudioDeviceController;
mediaCaptureSettings: Windows$Windows$Media.Capture.MediaCaptureSettings;
videoDeviceController: Windows$Windows$Media.Windows$Devices.VideoDeviceController;
initializeAsync(): Windows$Windows$Foundation.IAsyncAction;
initializeAsync(
mediaCaptureInitializationSettings: Windows$Windows$Media.Capture.MediaCaptureInitializationSettings): Windows$Windows$Foundation.IAsyncAction;
startRecordToStorageFileAsync(
encodingProfile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncAction;
startRecordToStreamAsync(
encodingProfile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
stream: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncAction;
startRecordToCustomSinkAsync(
encodingProfile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
customMediaSink: Windows$Windows$Media.IMediaExtension): Windows$Windows$Foundation.IAsyncAction;
startRecordToCustomSinkAsync(
encodingProfile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
customSinkActivationId: string,
customSinkSettings: Windows$Windows$Foundation.Collections.IPropertySet): Windows$Windows$Foundation.IAsyncAction;
stopRecordAsync(): Windows$Windows$Foundation.IAsyncAction;
capturePhotoToStorageFileAsync(
type: Windows$Windows$Media.MediaProperties.ImageEncodingProperties,
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncAction;
capturePhotoToStreamAsync(
type: Windows$Windows$Media.MediaProperties.ImageEncodingProperties,
stream: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncAction;
addEffectAsync(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType,
effectActivationID: string,
effectSettings: Windows$Windows$Foundation.Collections.IPropertySet): Windows$Windows$Foundation.IAsyncAction;
clearEffectsAsync(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType): Windows$Windows$Foundation.IAsyncAction;
setEncoderProperty(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType,
propertyId: string,
propertyValue: any): void;
getEncoderProperty(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType,
propertyId: string): any;
onfailed: any;
onrecordlimitationexceeded: any;
setPreviewMirroring(value: boolean): void;
getPreviewMirroring(): boolean;
setPreviewRotation(value: Windows$Windows$Media.Capture.VideoRotation): void;
getPreviewRotation(): Windows$Windows$Media.Capture.VideoRotation;
setRecordRotation(value: Windows$Windows$Media.Capture.VideoRotation): void;
getRecordRotation(): Windows$Windows$Media.Capture.VideoRotation;
startPreviewAsync(): Windows$Windows$Foundation.IAsyncAction;
startPreviewToCustomSinkAsync(
encodingProfile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
customMediaSink: Windows$Windows$Media.IMediaExtension): Windows$Windows$Foundation.IAsyncAction;
startPreviewToCustomSinkAsync(
encodingProfile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
customSinkActivationId: string,
customSinkSettings: Windows$Windows$Foundation.Collections.IPropertySet): Windows$Windows$Foundation.IAsyncAction;
stopPreviewAsync(): Windows$Windows$Foundation.IAsyncAction
}
	declare export interface RecordLimitationExceededEventHandler {
(sender: Windows$Windows$Media.Capture.MediaCapture): void
} 
	declare export interface IMediaCaptureInitializationSettings {
audioDeviceId: string,
photoCaptureSource: Windows$Windows$Media.Capture.PhotoCaptureSource,
streamingCaptureMode: Windows$Windows$Media.Capture.StreamingCaptureMode,
videoDeviceId: string
} 
	declare export class MediaCaptureInitializationSettings mixins undefined.IMediaCaptureInitializationSettings {
audioDeviceId: string;
photoCaptureSource: Windows$Windows$Media.Capture.PhotoCaptureSource;
streamingCaptureMode: Windows$Windows$Media.Capture.StreamingCaptureMode;
videoDeviceId: string
}
	declare export interface IMediaCapture {
audioDeviceController: Windows$Windows$Media.Windows$Devices.AudioDeviceController,
mediaCaptureSettings: Windows$Windows$Media.Capture.MediaCaptureSettings,
videoDeviceController: Windows$Windows$Media.Windows$Devices.VideoDeviceController,
initializeAsync(): Windows$Windows$Foundation.IAsyncAction,
initializeAsync(
mediaCaptureInitializationSettings: Windows$Windows$Media.Capture.MediaCaptureInitializationSettings): Windows$Windows$Foundation.IAsyncAction,
startRecordToStorageFileAsync(
encodingProfile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncAction,
startRecordToStreamAsync(
encodingProfile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
stream: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncAction,
startRecordToCustomSinkAsync(
encodingProfile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
customMediaSink: Windows$Windows$Media.IMediaExtension): Windows$Windows$Foundation.IAsyncAction,
startRecordToCustomSinkAsync(
encodingProfile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
customSinkActivationId: string,
customSinkSettings: Windows$Windows$Foundation.Collections.IPropertySet): Windows$Windows$Foundation.IAsyncAction,
stopRecordAsync(): Windows$Windows$Foundation.IAsyncAction,
capturePhotoToStorageFileAsync(
type: Windows$Windows$Media.MediaProperties.ImageEncodingProperties,
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncAction,
capturePhotoToStreamAsync(
type: Windows$Windows$Media.MediaProperties.ImageEncodingProperties,
stream: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncAction,
addEffectAsync(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType,
effectActivationID: string,
effectSettings: Windows$Windows$Foundation.Collections.IPropertySet): Windows$Windows$Foundation.IAsyncAction,
clearEffectsAsync(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType): Windows$Windows$Foundation.IAsyncAction,
setEncoderProperty(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType,
propertyId: string,
propertyValue: any): void,
getEncoderProperty(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType,
propertyId: string): any,
onfailed: any,
onrecordlimitationexceeded: any,
setPreviewMirroring(value: boolean): void,
getPreviewMirroring(): boolean,
setPreviewRotation(value: Windows$Windows$Media.Capture.VideoRotation): void,
getPreviewRotation(): Windows$Windows$Media.Capture.VideoRotation,
setRecordRotation(value: Windows$Windows$Media.Capture.VideoRotation): void,
getRecordRotation(): Windows$Windows$Media.Capture.VideoRotation
} 
	declare export class MediaCaptureSettings mixins undefined.IMediaCaptureSettings {
audioDeviceId: string;
photoCaptureSource: Windows$Windows$Media.Capture.PhotoCaptureSource;
streamingCaptureMode: Windows$Windows$Media.Capture.StreamingCaptureMode;
videoDeviceCharacteristic: Windows$Windows$Media.Capture.VideoDeviceCharacteristic;
videoDeviceId: string
}
	declare export interface IMediaCaptureVideoPreview {
startPreviewAsync(): Windows$Windows$Foundation.IAsyncAction,
startPreviewToCustomSinkAsync(
encodingProfile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
customMediaSink: Windows$Windows$Media.IMediaExtension): Windows$Windows$Foundation.IAsyncAction,
startPreviewToCustomSinkAsync(
encodingProfile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
customSinkActivationId: string,
customSinkSettings: Windows$Windows$Foundation.Collections.IPropertySet): Windows$Windows$Foundation.IAsyncAction,
stopPreviewAsync(): Windows$Windows$Foundation.IAsyncAction
} 
	declare export interface IMediaCaptureSettings {
audioDeviceId: string,
photoCaptureSource: Windows$Windows$Media.Capture.PhotoCaptureSource,
streamingCaptureMode: Windows$Windows$Media.Capture.StreamingCaptureMode,
videoDeviceCharacteristic: Windows$Windows$Media.Capture.VideoDeviceCharacteristic,
videoDeviceId: string
} 
    }

	declare module 'Devices' {
        declare module 'Sms' {
        declare export  class SmsMessageClass {
  constructor(...args: empty): mixed;
static +none: Class<SmsMessageClass__none> & SmsMessageClass__none & 0;// 0
static +class0: Class<SmsMessageClass__class0> & SmsMessageClass__class0 & 1;// 1
static +class1: Class<SmsMessageClass__class1> & SmsMessageClass__class1 & 2;// 2
static +class2: Class<SmsMessageClass__class2> & SmsMessageClass__class2 & 3;// 3
static +class3: Class<SmsMessageClass__class3> & SmsMessageClass__class3 & 4;// 4

}

declare class SmsMessageClass__none mixins SmsMessageClass {}
declare class SmsMessageClass__class0 mixins SmsMessageClass {}
declare class SmsMessageClass__class1 mixins SmsMessageClass {}
declare class SmsMessageClass__class2 mixins SmsMessageClass {}
declare class SmsMessageClass__class3 mixins SmsMessageClass {}

	declare export interface ISmsMessage {
id: number,
messageClass: Windows$Windows$Devices.Sms.SmsMessageClass
} 
	declare export  class SmsDataFormat {
  constructor(...args: empty): mixed;
static +unknown: Class<SmsDataFormat__unknown> & SmsDataFormat__unknown & 0;// 0
static +cdmaSubmit: Class<SmsDataFormat__cdmaSubmit> & SmsDataFormat__cdmaSubmit & 1;// 1
static +gsmSubmit: Class<SmsDataFormat__gsmSubmit> & SmsDataFormat__gsmSubmit & 2;// 2
static +cdmaDeliver: Class<SmsDataFormat__cdmaDeliver> & SmsDataFormat__cdmaDeliver & 3;// 3
static +gsmDeliver: Class<SmsDataFormat__gsmDeliver> & SmsDataFormat__gsmDeliver & 4;// 4

}

declare class SmsDataFormat__unknown mixins SmsDataFormat {}
declare class SmsDataFormat__cdmaSubmit mixins SmsDataFormat {}
declare class SmsDataFormat__gsmSubmit mixins SmsDataFormat {}
declare class SmsDataFormat__cdmaDeliver mixins SmsDataFormat {}
declare class SmsDataFormat__gsmDeliver mixins SmsDataFormat {}

	declare export type ISmsBinaryMessage = {
format: Windows$Windows$Devices.Sms.SmsDataFormat,
getData(): Uint8Array,
setData(value: Uint8Array): void
} & undefined.ISmsMessage

	declare export class SmsBinaryMessage mixins undefined.ISmsBinaryMessage, undefined.ISmsMessage {
format: Windows$Windows$Devices.Sms.SmsDataFormat;
id: number;
messageClass: Windows$Windows$Devices.Sms.SmsMessageClass;
getData(): Uint8Array;
setData(value: Uint8Array): void
}
	declare export  class SmsEncoding {
  constructor(...args: empty): mixed;
static +unknown: Class<SmsEncoding__unknown> & SmsEncoding__unknown & 0;// 0
static +optimal: Class<SmsEncoding__optimal> & SmsEncoding__optimal & 1;// 1
static +sevenBitAscii: Class<SmsEncoding__sevenBitAscii> & SmsEncoding__sevenBitAscii & 2;// 2
static +unicode: Class<SmsEncoding__unicode> & SmsEncoding__unicode & 3;// 3
static +gsmSevenBit: Class<SmsEncoding__gsmSevenBit> & SmsEncoding__gsmSevenBit & 4;// 4

}

declare class SmsEncoding__unknown mixins SmsEncoding {}
declare class SmsEncoding__optimal mixins SmsEncoding {}
declare class SmsEncoding__sevenBitAscii mixins SmsEncoding {}
declare class SmsEncoding__unicode mixins SmsEncoding {}
declare class SmsEncoding__gsmSevenBit mixins SmsEncoding {}

	declare export type ISmsTextMessage = {
body: string,
encoding: Windows$Windows$Devices.Sms.SmsEncoding,
from: string,
partCount: number,
partNumber: number,
partReferenceId: number,
timestamp: Date,
to: string,
toBinaryMessages(
format: Windows$Windows$Devices.Sms.SmsDataFormat): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsBinaryMessage>
} & undefined.ISmsMessage

	declare export interface ISmsTextMessageStatics {
fromBinaryMessage(
binaryMessage: Windows$Windows$Devices.Sms.SmsBinaryMessage): Windows$Windows$Devices.Sms.SmsTextMessage,
fromBinaryData(
format: Windows$Windows$Devices.Sms.SmsDataFormat,
value: Uint8Array): Windows$Windows$Devices.Sms.SmsTextMessage
} 
	declare export class SmsTextMessage mixins undefined.ISmsTextMessage, undefined.ISmsMessage {
body: string;
encoding: Windows$Windows$Devices.Sms.SmsEncoding;
from: string;
partCount: number;
partNumber: number;
partReferenceId: number;
timestamp: Date;
to: string;
id: number;
messageClass: Windows$Windows$Devices.Sms.SmsMessageClass;
toBinaryMessages(
format: Windows$Windows$Devices.Sms.SmsDataFormat): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsBinaryMessage>;
static fromBinaryMessage(
binaryMessage: Windows$Windows$Devices.Sms.SmsBinaryMessage): Windows$Windows$Devices.Sms.SmsTextMessage;
static fromBinaryData(
format: Windows$Windows$Devices.Sms.SmsDataFormat,
value: Uint8Array): Windows$Windows$Devices.Sms.SmsTextMessage
}
	declare export  class SmsMessageFilter {
  constructor(...args: empty): mixed;
static +all: Class<SmsMessageFilter__all> & SmsMessageFilter__all & 0;// 0
static +unread: Class<SmsMessageFilter__unread> & SmsMessageFilter__unread & 1;// 1
static +read: Class<SmsMessageFilter__read> & SmsMessageFilter__read & 2;// 2
static +sent: Class<SmsMessageFilter__sent> & SmsMessageFilter__sent & 3;// 3
static +draft: Class<SmsMessageFilter__draft> & SmsMessageFilter__draft & 4;// 4

}

declare class SmsMessageFilter__all mixins SmsMessageFilter {}
declare class SmsMessageFilter__unread mixins SmsMessageFilter {}
declare class SmsMessageFilter__read mixins SmsMessageFilter {}
declare class SmsMessageFilter__sent mixins SmsMessageFilter {}
declare class SmsMessageFilter__draft mixins SmsMessageFilter {}

	declare export  class SmsMessageType {
  constructor(...args: empty): mixed;
static +binary: Class<SmsMessageType__binary> & SmsMessageType__binary & 0;// 0
static +text: Class<SmsMessageType__text> & SmsMessageType__text & 1;// 1

}

declare class SmsMessageType__binary mixins SmsMessageType {}
declare class SmsMessageType__text mixins SmsMessageType {}

	declare export class DeleteSmsMessageOperation mixins undefined.IAsyncAction, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncActionCompletedHandler;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(): void;
cancel(): void;
close(): void;
then<U>(
success?: (value: any) => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: any) => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: (value: any) => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<any>,
getResults(): any
}
}
	declare export class DeleteSmsMessagesOperation mixins undefined.IAsyncAction, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncActionCompletedHandler;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(): void;
cancel(): void;
close(): void;
then<U>(
success?: (value: any) => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: any) => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: (value: any) => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<any>,
getResults(): any
}
}
	declare export class GetSmsMessageOperation mixins undefined.IAsyncOperation<Windows$Windows$Devices.Sms.ISmsMessage>, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<Windows$Windows$Devices.Sms.ISmsMessage>;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(): Windows$Windows$Devices.Sms.ISmsMessage;
cancel(): void;
close(): void;
then<U>(
success?: (value: Windows$Windows$Devices.Sms.ISmsMessage) => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Devices.Sms.ISmsMessage) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: Windows$Windows$Devices.Sms.ISmsMessage) => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Devices.Sms.ISmsMessage) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: (value: Windows$Windows$Devices.Sms.ISmsMessage) => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<Windows$Windows$Devices.Sms.ISmsMessage>,
getResults(): Windows$Windows$Devices.Sms.ISmsMessage
}
}
	declare export class GetSmsMessagesOperation mixins undefined.IAsyncOperationWithProgress<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>, number>, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncOperationWithProgressCompletedHandler<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>, number>;
progress: Windows$Windows$Foundation.AsyncOperationProgressHandler<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>, number>;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>;
cancel(): void;
close(): void;
then<U>(
success?: (
value: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>) => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>) => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: (
value: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>) => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
progress: Windows$Windows$Foundation.AsyncOperationProgressHandler<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>, number>,
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>>,
getResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>
}
}
	declare export interface ISmsDeviceMessageStore {
maxMessages: number,
deleteMessageAsync(messageId: number): Windows$Windows$Foundation.IAsyncAction,
deleteMessagesAsync(
messageFilter: Windows$Windows$Devices.Sms.SmsMessageFilter): Windows$Windows$Foundation.IAsyncAction,
getMessageAsync(
messageId: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Sms.ISmsMessage>,
getMessagesAsync(
messageFilter: Windows$Windows$Devices.Sms.SmsMessageFilter): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>, number>
} 
	declare export class SmsDeviceMessageStore mixins undefined.ISmsDeviceMessageStore {
maxMessages: number;
deleteMessageAsync(messageId: number): Windows$Windows$Foundation.IAsyncAction;
deleteMessagesAsync(
messageFilter: Windows$Windows$Devices.Sms.SmsMessageFilter): Windows$Windows$Foundation.IAsyncAction;
getMessageAsync(
messageId: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Sms.ISmsMessage>;
getMessagesAsync(
messageFilter: Windows$Windows$Devices.Sms.SmsMessageFilter): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Sms.ISmsMessage>, number>
}
	declare export interface SmsEncodedLength {
segmentCount: number,
characterCountLastSegment: number,
charactersPerSegment: number,
byteCountLastSegment: number,
bytesPerSegment: number
} 
	declare export  class CellularClass {
  constructor(...args: empty): mixed;
static +none: Class<CellularClass__none> & CellularClass__none & 0;// 0
static +gsm: Class<CellularClass__gsm> & CellularClass__gsm & 1;// 1
static +cdma: Class<CellularClass__cdma> & CellularClass__cdma & 2;// 2

}

declare class CellularClass__none mixins CellularClass {}
declare class CellularClass__gsm mixins CellularClass {}
declare class CellularClass__cdma mixins CellularClass {}

	declare export  class SmsDeviceStatus {
  constructor(...args: empty): mixed;
static +off: Class<SmsDeviceStatus__off> & SmsDeviceStatus__off & 0;// 0
static +ready: Class<SmsDeviceStatus__ready> & SmsDeviceStatus__ready & 1;// 1
static +simNotInserted: Class<SmsDeviceStatus__simNotInserted> & SmsDeviceStatus__simNotInserted & 2;// 2
static +badSim: Class<SmsDeviceStatus__badSim> & SmsDeviceStatus__badSim & 3;// 3
static +deviceFailure: Class<SmsDeviceStatus__deviceFailure> & SmsDeviceStatus__deviceFailure & 4;// 4
static +subscriptionNotActivated: Class<SmsDeviceStatus__subscriptionNotActivated> & SmsDeviceStatus__subscriptionNotActivated & 5;// 5
static +deviceLocked: Class<SmsDeviceStatus__deviceLocked> & SmsDeviceStatus__deviceLocked & 6;// 6
static +deviceBlocked: Class<SmsDeviceStatus__deviceBlocked> & SmsDeviceStatus__deviceBlocked & 7;// 7

}

declare class SmsDeviceStatus__off mixins SmsDeviceStatus {}
declare class SmsDeviceStatus__ready mixins SmsDeviceStatus {}
declare class SmsDeviceStatus__simNotInserted mixins SmsDeviceStatus {}
declare class SmsDeviceStatus__badSim mixins SmsDeviceStatus {}
declare class SmsDeviceStatus__deviceFailure mixins SmsDeviceStatus {}
declare class SmsDeviceStatus__subscriptionNotActivated mixins SmsDeviceStatus {}
declare class SmsDeviceStatus__deviceLocked mixins SmsDeviceStatus {}
declare class SmsDeviceStatus__deviceBlocked mixins SmsDeviceStatus {}

	declare export class SendSmsMessageOperation mixins undefined.IAsyncAction, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncActionCompletedHandler;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(): void;
cancel(): void;
close(): void;
then<U>(
success?: () => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: () => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: () => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: () => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: () => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<any>,
getResults(): any
}
}
	declare export interface ISmsMessageReceivedEventArgs {
binaryMessage: Windows$Windows$Devices.Sms.SmsBinaryMessage,
textMessage: Windows$Windows$Devices.Sms.SmsTextMessage
} 
	declare export class SmsMessageReceivedEventArgs mixins undefined.ISmsMessageReceivedEventArgs {
binaryMessage: Windows$Windows$Devices.Sms.SmsBinaryMessage;
textMessage: Windows$Windows$Devices.Sms.SmsTextMessage
}
	declare export interface SmsMessageReceivedEventHandler {
(sender: Windows$Windows$Devices.Sms.SmsDevice, e: Windows$Windows$Devices.Sms.SmsMessageReceivedEventArgs): void
} 
	declare export class SmsDevice mixins undefined.ISmsDevice {
accountPhoneNumber: string;
cellularClass: Windows$Windows$Devices.Sms.CellularClass;
deviceStatus: Windows$Windows$Devices.Sms.SmsDeviceStatus;
messageStore: Windows$Windows$Devices.Sms.SmsDeviceMessageStore;
sendMessageAsync(
message: Windows$Windows$Devices.Sms.ISmsMessage): Windows$Windows$Devices.Sms.SendSmsMessageOperation;
calculateLength(
message: Windows$Windows$Devices.Sms.SmsTextMessage): Windows$Windows$Devices.Sms.SmsEncodedLength;
onsmsmessagereceived: any;
onsmsdevicestatuschanged: any;
static getDeviceSelector(): string;
static fromIdAsync(
deviceInstanceId: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Sms.SmsDevice>;
static getDefaultAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Sms.SmsDevice>
}
	declare export interface SmsDeviceStatusChangedEventHandler {
(sender: Windows$Windows$Devices.Sms.SmsDevice): void
} 
	declare export class GetSmsDeviceOperation mixins undefined.IAsyncOperation<Windows$Windows$Devices.Sms.SmsDevice>, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<Windows$Windows$Devices.Sms.SmsDevice>;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(): Windows$Windows$Devices.Sms.SmsDevice;
cancel(): void;
close(): void;
then<U>(
success?: (value: Windows$Windows$Devices.Sms.SmsDevice) => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Devices.Sms.SmsDevice) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: Windows$Windows$Devices.Sms.SmsDevice) => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Devices.Sms.SmsDevice) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: (value: Windows$Windows$Devices.Sms.SmsDevice) => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<Windows$Windows$Devices.Sms.SmsDevice>,
getResults(): Windows$Windows$Devices.Sms.SmsDevice
}
}
	declare export interface ISmsDeviceStatics {
getDeviceSelector(): string,
fromIdAsync(
deviceInstanceId: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Sms.SmsDevice>,
getDefaultAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Sms.SmsDevice>
} 
	declare export interface ISmsDevice {
accountPhoneNumber: string,
cellularClass: Windows$Windows$Devices.Sms.CellularClass,
deviceStatus: Windows$Windows$Devices.Sms.SmsDeviceStatus,
messageStore: Windows$Windows$Devices.Sms.SmsDeviceMessageStore,
sendMessageAsync(
message: Windows$Windows$Devices.Sms.ISmsMessage): Windows$Windows$Devices.Sms.SendSmsMessageOperation,
calculateLength(
message: Windows$Windows$Devices.Sms.SmsTextMessage): Windows$Windows$Devices.Sms.SmsEncodedLength,
onsmsmessagereceived: any,
onsmsdevicestatuschanged: any
} 
	declare export interface ISmsReceivedEventDetails {
deviceId: string,
messageIndex: number
} 
	declare export class SmsReceivedEventDetails mixins undefined.ISmsReceivedEventDetails {
deviceId: string;
messageIndex: number
}
    }

	declare module 'Enumeration' {
        declare export  class DeviceClass {
  constructor(...args: empty): mixed;
static +all: Class<DeviceClass__all> & DeviceClass__all & 0;// 0
static +audioCapture: Class<DeviceClass__audioCapture> & DeviceClass__audioCapture & 1;// 1
static +audioRender: Class<DeviceClass__audioRender> & DeviceClass__audioRender & 2;// 2
static +portableStorageDevice: Class<DeviceClass__portableStorageDevice> & DeviceClass__portableStorageDevice & 3;// 3
static +videoCapture: Class<DeviceClass__videoCapture> & DeviceClass__videoCapture & 4;// 4

}

declare class DeviceClass__all mixins DeviceClass {}
declare class DeviceClass__audioCapture mixins DeviceClass {}
declare class DeviceClass__audioRender mixins DeviceClass {}
declare class DeviceClass__portableStorageDevice mixins DeviceClass {}
declare class DeviceClass__videoCapture mixins DeviceClass {}

	declare export  class DeviceWatcherStatus {
  constructor(...args: empty): mixed;
static +created: Class<DeviceWatcherStatus__created> & DeviceWatcherStatus__created & 0;// 0
static +started: Class<DeviceWatcherStatus__started> & DeviceWatcherStatus__started & 1;// 1
static +enumerationCompleted: Class<DeviceWatcherStatus__enumerationCompleted> & DeviceWatcherStatus__enumerationCompleted & 2;// 2
static +stopping: Class<DeviceWatcherStatus__stopping> & DeviceWatcherStatus__stopping & 3;// 3
static +stopped: Class<DeviceWatcherStatus__stopped> & DeviceWatcherStatus__stopped & 4;// 4
static +aborted: Class<DeviceWatcherStatus__aborted> & DeviceWatcherStatus__aborted & 5;// 5

}

declare class DeviceWatcherStatus__created mixins DeviceWatcherStatus {}
declare class DeviceWatcherStatus__started mixins DeviceWatcherStatus {}
declare class DeviceWatcherStatus__enumerationCompleted mixins DeviceWatcherStatus {}
declare class DeviceWatcherStatus__stopping mixins DeviceWatcherStatus {}
declare class DeviceWatcherStatus__stopped mixins DeviceWatcherStatus {}
declare class DeviceWatcherStatus__aborted mixins DeviceWatcherStatus {}

	declare export class DeviceThumbnail mixins undefined.IRandomAccessStreamWithContentType, undefined.IRandomAccessStream, undefined.IClosable, undefined.IInputStream, undefined.IOutputStream, undefined.IContentTypeProvider {
canRead: boolean;
canWrite: boolean;
position: number;
size: number;
contentType: string;
getInputStreamAt(position: number): Windows$Windows$Storage.Streams.IInputStream;
getOutputStreamAt(position: number): Windows$Windows$Storage.Streams.IOutputStream;
seek(position: number): void;
cloneStream(): Windows$Windows$Storage.Streams.IRandomAccessStream;
dispose(): void;
readAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer,
count: number,
options: Windows$Windows$Storage.Streams.InputStreamOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Storage.Streams.IBuffer, number>;
writeAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
flushAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
close(): void
}
	declare export  class Panel {
  constructor(...args: empty): mixed;
static +unknown: Class<Panel__unknown> & Panel__unknown & 0;// 0
static +front: Class<Panel__front> & Panel__front & 1;// 1
static +back: Class<Panel__back> & Panel__back & 2;// 2
static +top: Class<Panel__top> & Panel__top & 3;// 3
static +bottom: Class<Panel__bottom> & Panel__bottom & 4;// 4
static +left: Class<Panel__left> & Panel__left & 5;// 5
static +right: Class<Panel__right> & Panel__right & 6;// 6

}

declare class Panel__unknown mixins Panel {}
declare class Panel__front mixins Panel {}
declare class Panel__back mixins Panel {}
declare class Panel__top mixins Panel {}
declare class Panel__bottom mixins Panel {}
declare class Panel__left mixins Panel {}
declare class Panel__right mixins Panel {}

	declare export interface IEnclosureLocation {
inDock: boolean,
inLid: boolean,
panel: Windows$Windows$Devices.Enumeration.Panel
} 
	declare export class EnclosureLocation mixins undefined.IEnclosureLocation {
inDock: boolean;
inLid: boolean;
panel: Windows$Windows$Devices.Enumeration.Panel
}
	declare export interface IDeviceInformationUpdate {
id: string,
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>
} 
	declare export class DeviceInformationUpdate mixins undefined.IDeviceInformationUpdate {
id: string;
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>
}
	declare export class DeviceInformationCollection mixins undefined.IVectorView<Windows$Windows$Devices.Enumeration.DeviceInformation>, undefined.IIterable<Windows$Windows$Devices.Enumeration.DeviceInformation> {
size: number;
getAt(index: number): Windows$Windows$Devices.Enumeration.DeviceInformation;
indexOf(
value: Windows$Windows$Devices.Enumeration.DeviceInformation): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$Devices.Enumeration.DeviceInformation[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Devices.Enumeration.DeviceInformation>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$Devices.Enumeration.DeviceInformation[][]): Windows$Windows$Devices.Enumeration.DeviceInformation[];
join(seperator: string): string;
pop(): Windows$Windows$Devices.Enumeration.DeviceInformation;
push(...items: Windows$Windows$Devices.Enumeration.DeviceInformation[]): void;
reverse(): Windows$Windows$Devices.Enumeration.DeviceInformation[];
shift(): Windows$Windows$Devices.Enumeration.DeviceInformation;
slice(start: number): Windows$Windows$Devices.Enumeration.DeviceInformation[];
slice(
start: number,
end: number): Windows$Windows$Devices.Enumeration.DeviceInformation[];
sort(): Windows$Windows$Devices.Enumeration.DeviceInformation[];
sort(
compareFn: (
a: Windows$Windows$Devices.Enumeration.DeviceInformation,
b: Windows$Windows$Devices.Enumeration.DeviceInformation) => number): Windows$Windows$Devices.Enumeration.DeviceInformation[];
splice(start: number): Windows$Windows$Devices.Enumeration.DeviceInformation[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$Devices.Enumeration.DeviceInformation[]): Windows$Windows$Devices.Enumeration.DeviceInformation[];
unshift(...items: Windows$Windows$Devices.Enumeration.DeviceInformation[]): number;
lastIndexOf(searchElement: Windows$Windows$Devices.Enumeration.DeviceInformation): number;
lastIndexOf(
searchElement: Windows$Windows$Devices.Enumeration.DeviceInformation,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => boolean): Windows$Windows$Devices.Enumeration.DeviceInformation[];
filter(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.DeviceInformation,
index: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => boolean,
thisArg: any): Windows$Windows$Devices.Enumeration.DeviceInformation[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.DeviceInformation[]) => any,
initialValue: any): any;
length: number
}
	declare export interface IDeviceWatcher {
status: Windows$Windows$Devices.Enumeration.DeviceWatcherStatus,
onadded: any,
onupdated: any,
onremoved: any,
onenumerationcompleted: any,
onstopped: any,
start(): void,
stop(): void
} 
	declare export class DeviceWatcher mixins undefined.IDeviceWatcher {
status: Windows$Windows$Devices.Enumeration.DeviceWatcherStatus;
onadded: any;
onupdated: any;
onremoved: any;
onenumerationcompleted: any;
onstopped: any;
start(): void;
stop(): void
}
	declare export class DeviceInformation mixins undefined.IDeviceInformation {
enclosureLocation: Windows$Windows$Devices.Enumeration.EnclosureLocation;
id: string;
isDefault: boolean;
isEnabled: boolean;
name: string;
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>;
update(updateInfo: Windows$Windows$Devices.Enumeration.DeviceInformationUpdate): void;
getThumbnailAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceThumbnail>;
getGlyphThumbnailAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceThumbnail>;
static createFromIdAsync(
id: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformation>;
static createFromIdAsync(
id: string,
additionalProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformation>;
static findAllAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>;
static findAllAsync(
deviceClass: Windows$Windows$Devices.Enumeration.DeviceClass): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>;
static findAllAsync(
aqsFilter: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>;
static findAllAsync(
aqsFilter: string,
additionalProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>;
static createWatcher(): Windows$Windows$Devices.Enumeration.DeviceWatcher;
static createWatcher(
deviceClass: Windows$Windows$Devices.Enumeration.DeviceClass): Windows$Windows$Devices.Enumeration.DeviceWatcher;
static createWatcher(aqsFilter: string): Windows$Windows$Devices.Enumeration.DeviceWatcher;
static createWatcher(
aqsFilter: string,
additionalProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Devices.Enumeration.DeviceWatcher
}
	declare export interface IDeviceInformationStatics {
createFromIdAsync(
id: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformation>,
createFromIdAsync(
id: string,
additionalProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformation>,
findAllAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>,
findAllAsync(
deviceClass: Windows$Windows$Devices.Enumeration.DeviceClass): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>,
findAllAsync(
aqsFilter: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>,
findAllAsync(
aqsFilter: string,
additionalProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceInformationCollection>,
createWatcher(): Windows$Windows$Devices.Enumeration.DeviceWatcher,
createWatcher(
deviceClass: Windows$Windows$Devices.Enumeration.DeviceClass): Windows$Windows$Devices.Enumeration.DeviceWatcher,
createWatcher(aqsFilter: string): Windows$Windows$Devices.Enumeration.DeviceWatcher,
createWatcher(
aqsFilter: string,
additionalProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Devices.Enumeration.DeviceWatcher
} 
	declare export interface IDeviceInformation {
enclosureLocation: Windows$Windows$Devices.Enumeration.EnclosureLocation,
id: string,
isDefault: boolean,
isEnabled: boolean,
name: string,
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>,
update(updateInfo: Windows$Windows$Devices.Enumeration.DeviceInformationUpdate): void,
getThumbnailAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceThumbnail>,
getGlyphThumbnailAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.DeviceThumbnail>
} 
	declare module 'Pnp' {
        declare export  class PnpObjectType {
  constructor(...args: empty): mixed;
static +unknown: Class<PnpObjectType__unknown> & PnpObjectType__unknown & 0;// 0
static +deviceInterface: Class<PnpObjectType__deviceInterface> & PnpObjectType__deviceInterface & 1;// 1
static +deviceContainer: Class<PnpObjectType__deviceContainer> & PnpObjectType__deviceContainer & 2;// 2
static +device: Class<PnpObjectType__device> & PnpObjectType__device & 3;// 3
static +deviceInterfaceClass: Class<PnpObjectType__deviceInterfaceClass> & PnpObjectType__deviceInterfaceClass & 4;// 4

}

declare class PnpObjectType__unknown mixins PnpObjectType {}
declare class PnpObjectType__deviceInterface mixins PnpObjectType {}
declare class PnpObjectType__deviceContainer mixins PnpObjectType {}
declare class PnpObjectType__device mixins PnpObjectType {}
declare class PnpObjectType__deviceInterfaceClass mixins PnpObjectType {}

	declare export interface IPnpObjectUpdate {
id: string,
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>,
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType
} 
	declare export class PnpObjectUpdate mixins undefined.IPnpObjectUpdate {
id: string;
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>;
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType
}
	declare export class PnpObjectCollection mixins undefined.IVectorView<Windows$Windows$Devices.Enumeration.Pnp.PnpObject>, undefined.IIterable<Windows$Windows$Devices.Enumeration.Pnp.PnpObject> {
size: number;
getAt(index: number): Windows$Windows$Devices.Enumeration.Pnp.PnpObject;
indexOf(
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Devices.Enumeration.Pnp.PnpObject>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[][]): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
join(seperator: string): string;
pop(): Windows$Windows$Devices.Enumeration.Pnp.PnpObject;
push(...items: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]): void;
reverse(): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
shift(): Windows$Windows$Devices.Enumeration.Pnp.PnpObject;
slice(start: number): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
slice(
start: number,
end: number): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
sort(): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
sort(
compareFn: (
a: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
b: Windows$Windows$Devices.Enumeration.Pnp.PnpObject) => number): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
splice(start: number): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
unshift(...items: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]): number;
lastIndexOf(searchElement: Windows$Windows$Devices.Enumeration.Pnp.PnpObject): number;
lastIndexOf(
searchElement: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => boolean): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
filter(
callbackfn: (
value: Windows$Windows$Devices.Enumeration.Pnp.PnpObject,
index: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => boolean,
thisArg: any): Windows$Windows$Devices.Enumeration.Pnp.PnpObject[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Devices.Enumeration.Pnp.PnpObject[]) => any,
initialValue: any): any;
length: number
}
	declare export interface IPnpObjectWatcher {
status: Windows$Windows$Devices.Enumeration.DeviceWatcherStatus,
onadded: any,
onupdated: any,
onremoved: any,
onenumerationcompleted: any,
onstopped: any,
start(): void,
stop(): void
} 
	declare export class PnpObjectWatcher mixins undefined.IPnpObjectWatcher {
status: Windows$Windows$Devices.Enumeration.DeviceWatcherStatus;
onadded: any;
onupdated: any;
onremoved: any;
onenumerationcompleted: any;
onstopped: any;
start(): void;
stop(): void
}
	declare export class PnpObject mixins undefined.IPnpObject {
id: string;
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>;
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType;
update(updateInfo: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectUpdate): void;
static createFromIdAsync(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
id: string,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.Pnp.PnpObject>;
static findAllAsync(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.Pnp.PnpObjectCollection>;
static findAllAsync(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>,
aqsFilter: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.Pnp.PnpObjectCollection>;
static createWatcher(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Devices.Enumeration.Pnp.PnpObjectWatcher;
static createWatcher(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>,
aqsFilter: string): Windows$Windows$Devices.Enumeration.Pnp.PnpObjectWatcher
}
	declare export interface IPnpObjectStatics {
createFromIdAsync(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
id: string,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.Pnp.PnpObject>,
findAllAsync(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.Pnp.PnpObjectCollection>,
findAllAsync(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>,
aqsFilter: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Enumeration.Pnp.PnpObjectCollection>,
createWatcher(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Devices.Enumeration.Pnp.PnpObjectWatcher,
createWatcher(
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
requestedProperties: Windows$Windows$Foundation.Collections.IIterable<string>,
aqsFilter: string): Windows$Windows$Devices.Enumeration.Pnp.PnpObjectWatcher
} 
	declare export interface IPnpObject {
id: string,
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>,
type: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectType,
update(updateInfo: Windows$Windows$Devices.Enumeration.Pnp.PnpObjectUpdate): void
} 
    }

    }

	declare module 'Geolocation' {
        declare export  class PositionAccuracy {
  constructor(...args: empty): mixed;
static +default: Class<PositionAccuracy__default> & PositionAccuracy__default & 0;// 0
static +high: Class<PositionAccuracy__high> & PositionAccuracy__high & 1;// 1

}

declare class PositionAccuracy__default mixins PositionAccuracy {}
declare class PositionAccuracy__high mixins PositionAccuracy {}

	declare export  class PositionStatus {
  constructor(...args: empty): mixed;
static +ready: Class<PositionStatus__ready> & PositionStatus__ready & 0;// 0
static +initializing: Class<PositionStatus__initializing> & PositionStatus__initializing & 1;// 1
static +noData: Class<PositionStatus__noData> & PositionStatus__noData & 2;// 2
static +disabled: Class<PositionStatus__disabled> & PositionStatus__disabled & 3;// 3
static +notInitialized: Class<PositionStatus__notInitialized> & PositionStatus__notInitialized & 4;// 4
static +notAvailable: Class<PositionStatus__notAvailable> & PositionStatus__notAvailable & 5;// 5

}

declare class PositionStatus__ready mixins PositionStatus {}
declare class PositionStatus__initializing mixins PositionStatus {}
declare class PositionStatus__noData mixins PositionStatus {}
declare class PositionStatus__disabled mixins PositionStatus {}
declare class PositionStatus__notInitialized mixins PositionStatus {}
declare class PositionStatus__notAvailable mixins PositionStatus {}

	declare export interface IGeocoordinate {
accuracy: number,
altitude: number,
altitudeAccuracy: number,
heading: number,
latitude: number,
longitude: number,
speed: number,
timestamp: Date
} 
	declare export class Geocoordinate mixins undefined.IGeocoordinate {
accuracy: number;
altitude: number;
altitudeAccuracy: number;
heading: number;
latitude: number;
longitude: number;
speed: number;
timestamp: Date
}
	declare export interface ICivicAddress {
city: string,
country: string,
postalCode: string,
state: string,
timestamp: Date
} 
	declare export class CivicAddress mixins undefined.ICivicAddress {
city: string;
country: string;
postalCode: string;
state: string;
timestamp: Date
}
	declare export interface IGeoposition {
civicAddress: Windows$Windows$Devices.Geolocation.CivicAddress,
coordinate: Windows$Windows$Devices.Geolocation.Geocoordinate
} 
	declare export class Geoposition mixins undefined.IGeoposition {
civicAddress: Windows$Windows$Devices.Geolocation.CivicAddress;
coordinate: Windows$Windows$Devices.Geolocation.Geocoordinate
}
	declare export interface IPositionChangedEventArgs {
position: Windows$Windows$Devices.Geolocation.Geoposition
} 
	declare export class PositionChangedEventArgs mixins undefined.IPositionChangedEventArgs {
position: Windows$Windows$Devices.Geolocation.Geoposition
}
	declare export interface IStatusChangedEventArgs {
status: Windows$Windows$Devices.Geolocation.PositionStatus
} 
	declare export class StatusChangedEventArgs mixins undefined.IStatusChangedEventArgs {
status: Windows$Windows$Devices.Geolocation.PositionStatus
}
	declare export interface IGeolocator {
desiredAccuracy: Windows$Windows$Devices.Geolocation.PositionAccuracy,
locationStatus: Windows$Windows$Devices.Geolocation.PositionStatus,
movementThreshold: number,
reportInterval: number,
getGeopositionAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Geolocation.Geoposition>,
getGeopositionAsync(
maximumAge: number,
timeout: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Geolocation.Geoposition>,
onpositionchanged: any,
onstatuschanged: any
} 
	declare export class Geolocator mixins undefined.IGeolocator {
desiredAccuracy: Windows$Windows$Devices.Geolocation.PositionAccuracy;
locationStatus: Windows$Windows$Devices.Geolocation.PositionStatus;
movementThreshold: number;
reportInterval: number;
getGeopositionAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Geolocation.Geoposition>;
getGeopositionAsync(
maximumAge: number,
timeout: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Devices.Geolocation.Geoposition>;
onpositionchanged: any;
onstatuschanged: any
}
    }

	declare module 'Input' {
        declare export  class PointerDeviceType {
  constructor(...args: empty): mixed;
static +touch: Class<PointerDeviceType__touch> & PointerDeviceType__touch & 0;// 0
static +pen: Class<PointerDeviceType__pen> & PointerDeviceType__pen & 1;// 1
static +mouse: Class<PointerDeviceType__mouse> & PointerDeviceType__mouse & 2;// 2

}

declare class PointerDeviceType__touch mixins PointerDeviceType {}
declare class PointerDeviceType__pen mixins PointerDeviceType {}
declare class PointerDeviceType__mouse mixins PointerDeviceType {}

	declare export interface PointerDeviceUsage {
usagePage: number,
usage: number,
minLogical: number,
maxLogical: number,
minPhysical: number,
maxPhysical: number,
unit: number,
physicalMultiplier: number
} 
	declare export interface MouseDelta {
x: number,
y: number
} 
	declare export interface IMouseCapabilities {
horizontalWheelPresent: number,
mousePresent: number,
numberOfButtons: number,
swapButtons: number,
verticalWheelPresent: number
} 
	declare export interface IKeyboardCapabilities {
keyboardPresent: number
} 
	declare export interface ITouchCapabilities {
contacts: number,
touchPresent: number
} 
	declare export interface IPointerDeviceStatics {
getPointerDevice(pointerId: number): Windows$Windows$Devices.Input.PointerDevice,
getPointerDevices(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDevice>
} 
	declare export class PointerDevice mixins undefined.IPointerDevice {
isIntegrated: boolean;
maxContacts: number;
physicalDeviceRect: Windows$Windows$Foundation.Rect;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
screenRect: Windows$Windows$Foundation.Rect;
supportedUsages: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDeviceUsage>;
static getPointerDevice(pointerId: number): Windows$Windows$Devices.Input.PointerDevice;
static getPointerDevices(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDevice>
}
	declare export interface IPointerDevice {
isIntegrated: boolean,
maxContacts: number,
physicalDeviceRect: Windows$Windows$Foundation.Rect,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
screenRect: Windows$Windows$Foundation.Rect,
supportedUsages: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDeviceUsage>
} 
	declare export interface IMouseEventArgs {
mouseDelta: Windows$Windows$Devices.Input.MouseDelta
} 
	declare export interface IMouseDevice {
onmousemoved: any
} 
	declare export class MouseDevice mixins undefined.IMouseDevice {
onmousemoved: any;
static getForCurrentView(): Windows$Windows$Devices.Input.MouseDevice
}
	declare export class MouseEventArgs mixins undefined.IMouseEventArgs {
mouseDelta: Windows$Windows$Devices.Input.MouseDelta
}
	declare export interface IMouseDeviceStatics {
getForCurrentView(): Windows$Windows$Devices.Input.MouseDevice
} 
	declare export class MouseCapabilities mixins undefined.IMouseCapabilities {
horizontalWheelPresent: number;
mousePresent: number;
numberOfButtons: number;
swapButtons: number;
verticalWheelPresent: number
}
	declare export class KeyboardCapabilities mixins undefined.IKeyboardCapabilities {
keyboardPresent: number
}
	declare export class TouchCapabilities mixins undefined.ITouchCapabilities {
contacts: number;
touchPresent: number
}
	declare export  class EdgeGestureKind {
  constructor(...args: empty): mixed;
static +touch: Class<EdgeGestureKind__touch> & EdgeGestureKind__touch & 0;// 0
static +keyboard: Class<EdgeGestureKind__keyboard> & EdgeGestureKind__keyboard & 1;// 1
static +mouse: Class<EdgeGestureKind__mouse> & EdgeGestureKind__mouse & 2;// 2

}

declare class EdgeGestureKind__touch mixins EdgeGestureKind {}
declare class EdgeGestureKind__keyboard mixins EdgeGestureKind {}
declare class EdgeGestureKind__mouse mixins EdgeGestureKind {}

	declare export interface IEdgeGestureEventArgs {
kind: Windows$Windows$UI.Input.EdgeGestureKind
} 
	declare export class EdgeGestureEventArgs mixins undefined.IEdgeGestureEventArgs {
kind: Windows$Windows$UI.Input.EdgeGestureKind
}
	declare export interface IEdgeGestureStatics {
getForCurrentView(): Windows$Windows$UI.Input.EdgeGesture
} 
	declare export class EdgeGesture mixins undefined.IEdgeGesture {
onstarting: any;
oncompleted: any;
oncanceled: any;
static getForCurrentView(): Windows$Windows$UI.Input.EdgeGesture
}
	declare export interface IEdgeGesture {
onstarting: any,
oncompleted: any,
oncanceled: any
} 
	declare export  class HoldingState {
  constructor(...args: empty): mixed;
static +started: Class<HoldingState__started> & HoldingState__started & 0;// 0
static +completed: Class<HoldingState__completed> & HoldingState__completed & 1;// 1
static +canceled: Class<HoldingState__canceled> & HoldingState__canceled & 2;// 2

}

declare class HoldingState__started mixins HoldingState {}
declare class HoldingState__completed mixins HoldingState {}
declare class HoldingState__canceled mixins HoldingState {}

	declare export  class DraggingState {
  constructor(...args: empty): mixed;
static +started: Class<DraggingState__started> & DraggingState__started & 0;// 0
static +continuing: Class<DraggingState__continuing> & DraggingState__continuing & 1;// 1
static +completed: Class<DraggingState__completed> & DraggingState__completed & 2;// 2

}

declare class DraggingState__started mixins DraggingState {}
declare class DraggingState__continuing mixins DraggingState {}
declare class DraggingState__completed mixins DraggingState {}

	declare export  class CrossSlidingState {
  constructor(...args: empty): mixed;
static +started: Class<CrossSlidingState__started> & CrossSlidingState__started & 0;// 0
static +dragging: Class<CrossSlidingState__dragging> & CrossSlidingState__dragging & 1;// 1
static +selecting: Class<CrossSlidingState__selecting> & CrossSlidingState__selecting & 2;// 2
static +selectSpeedBumping: Class<CrossSlidingState__selectSpeedBumping> & CrossSlidingState__selectSpeedBumping & 3;// 3
static +speedBumping: Class<CrossSlidingState__speedBumping> & CrossSlidingState__speedBumping & 4;// 4
static +rearranging: Class<CrossSlidingState__rearranging> & CrossSlidingState__rearranging & 5;// 5
static +completed: Class<CrossSlidingState__completed> & CrossSlidingState__completed & 6;// 6

}

declare class CrossSlidingState__started mixins CrossSlidingState {}
declare class CrossSlidingState__dragging mixins CrossSlidingState {}
declare class CrossSlidingState__selecting mixins CrossSlidingState {}
declare class CrossSlidingState__selectSpeedBumping mixins CrossSlidingState {}
declare class CrossSlidingState__speedBumping mixins CrossSlidingState {}
declare class CrossSlidingState__rearranging mixins CrossSlidingState {}
declare class CrossSlidingState__completed mixins CrossSlidingState {}

	declare export  class GestureSettings {
  constructor(...args: empty): mixed;
static +none: Class<GestureSettings__none> & GestureSettings__none & 0;// 0
static +tap: Class<GestureSettings__tap> & GestureSettings__tap & 1;// 1
static +doubleTap: Class<GestureSettings__doubleTap> & GestureSettings__doubleTap & 2;// 2
static +hold: Class<GestureSettings__hold> & GestureSettings__hold & 3;// 3
static +holdWithMouse: Class<GestureSettings__holdWithMouse> & GestureSettings__holdWithMouse & 4;// 4
static +rightTap: Class<GestureSettings__rightTap> & GestureSettings__rightTap & 5;// 5
static +drag: Class<GestureSettings__drag> & GestureSettings__drag & 6;// 6
static +manipulationTranslateX: Class<GestureSettings__manipulationTranslateX> & GestureSettings__manipulationTranslateX & 7;// 7
static +manipulationTranslateY: Class<GestureSettings__manipulationTranslateY> & GestureSettings__manipulationTranslateY & 8;// 8
static +manipulationTranslateRailsX: Class<GestureSettings__manipulationTranslateRailsX> & GestureSettings__manipulationTranslateRailsX & 9;// 9
static +manipulationTranslateRailsY: Class<GestureSettings__manipulationTranslateRailsY> & GestureSettings__manipulationTranslateRailsY & 10;// 10
static +manipulationRotate: Class<GestureSettings__manipulationRotate> & GestureSettings__manipulationRotate & 11;// 11
static +manipulationScale: Class<GestureSettings__manipulationScale> & GestureSettings__manipulationScale & 12;// 12
static +manipulationTranslateInertia: Class<GestureSettings__manipulationTranslateInertia> & GestureSettings__manipulationTranslateInertia & 13;// 13
static +manipulationRotateInertia: Class<GestureSettings__manipulationRotateInertia> & GestureSettings__manipulationRotateInertia & 14;// 14
static +manipulationScaleInertia: Class<GestureSettings__manipulationScaleInertia> & GestureSettings__manipulationScaleInertia & 15;// 15
static +crossSlide: Class<GestureSettings__crossSlide> & GestureSettings__crossSlide & 16;// 16

}

declare class GestureSettings__none mixins GestureSettings {}
declare class GestureSettings__tap mixins GestureSettings {}
declare class GestureSettings__doubleTap mixins GestureSettings {}
declare class GestureSettings__hold mixins GestureSettings {}
declare class GestureSettings__holdWithMouse mixins GestureSettings {}
declare class GestureSettings__rightTap mixins GestureSettings {}
declare class GestureSettings__drag mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateX mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateY mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateRailsX mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateRailsY mixins GestureSettings {}
declare class GestureSettings__manipulationRotate mixins GestureSettings {}
declare class GestureSettings__manipulationScale mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateInertia mixins GestureSettings {}
declare class GestureSettings__manipulationRotateInertia mixins GestureSettings {}
declare class GestureSettings__manipulationScaleInertia mixins GestureSettings {}
declare class GestureSettings__crossSlide mixins GestureSettings {}

	declare export interface ManipulationDelta {
translation: Windows$Windows$Foundation.Point,
scale: number,
rotation: number,
expansion: number
} 
	declare export interface ManipulationVelocities {
linear: Windows$Windows$Foundation.Point,
angular: number,
expansion: number
} 
	declare export interface CrossSlideThresholds {
selectionStart: number,
speedBumpStart: number,
speedBumpEnd: number,
rearrangeStart: number
} 
	declare export interface ITappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
tapCount: number
} 
	declare export interface IRightTappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IHoldingEventArgs {
holdingState: Windows$Windows$UI.Input.HoldingState,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IDraggingEventArgs {
draggingState: Windows$Windows$UI.Input.DraggingState,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IManipulationStartedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IManipulationUpdatedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
delta: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
velocities: Windows$Windows$UI.Input.ManipulationVelocities
} 
	declare export interface IManipulationInertiaStartingEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
delta: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
velocities: Windows$Windows$UI.Input.ManipulationVelocities
} 
	declare export interface IManipulationCompletedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
velocities: Windows$Windows$UI.Input.ManipulationVelocities
} 
	declare export interface ICrossSlidingEventArgs {
crossSlidingState: Windows$Windows$UI.Input.CrossSlidingState,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IMouseWheelParameters {
charTranslation: Windows$Windows$Foundation.Point,
deltaRotationAngle: number,
deltaScale: number,
pageTranslation: Windows$Windows$Foundation.Point
} 
	declare export interface IGestureRecognizer {
autoProcessInertia: boolean,
crossSlideExact: boolean,
crossSlideHorizontally: boolean,
crossSlideThresholds: Windows$Windows$UI.Input.CrossSlideThresholds,
gestureSettings: Windows$Windows$UI.Input.GestureSettings,
inertiaExpansion: number,
inertiaExpansionDeceleration: number,
inertiaRotationAngle: number,
inertiaRotationDeceleration: number,
inertiaTranslationDeceleration: number,
inertiaTranslationDisplacement: number,
isActive: boolean,
isInertial: boolean,
manipulationExact: boolean,
mouseWheelParameters: Windows$Windows$UI.Input.MouseWheelParameters,
pivotCenter: Windows$Windows$Foundation.Point,
pivotRadius: number,
showGestureFeedback: boolean,
canBeDoubleTap(value: Windows$Windows$UI.Input.PointerPoint): boolean,
processDownEvent(value: Windows$Windows$UI.Input.PointerPoint): void,
processMoveEvents(
value: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>): void,
processUpEvent(value: Windows$Windows$UI.Input.PointerPoint): void,
processMouseWheelEvent(
value: Windows$Windows$UI.Input.PointerPoint,
isShiftKeyDown: boolean,
isControlKeyDown: boolean): void,
processInertia(): void,
completeGesture(): void,
ontapped: any,
onrighttapped: any,
onholding: any,
ondragging: any,
onmanipulationstarted: any,
onmanipulationupdated: any,
onmanipulationinertiastarting: any,
onmanipulationcompleted: any,
oncrosssliding: any
} 
	declare export class MouseWheelParameters mixins undefined.IMouseWheelParameters {
charTranslation: Windows$Windows$Foundation.Point;
deltaRotationAngle: number;
deltaScale: number;
pageTranslation: Windows$Windows$Foundation.Point
}
	declare export class GestureRecognizer mixins undefined.IGestureRecognizer {
autoProcessInertia: boolean;
crossSlideExact: boolean;
crossSlideHorizontally: boolean;
crossSlideThresholds: Windows$Windows$UI.Input.CrossSlideThresholds;
gestureSettings: Windows$Windows$UI.Input.GestureSettings;
inertiaExpansion: number;
inertiaExpansionDeceleration: number;
inertiaRotationAngle: number;
inertiaRotationDeceleration: number;
inertiaTranslationDeceleration: number;
inertiaTranslationDisplacement: number;
isActive: boolean;
isInertial: boolean;
manipulationExact: boolean;
mouseWheelParameters: Windows$Windows$UI.Input.MouseWheelParameters;
pivotCenter: Windows$Windows$Foundation.Point;
pivotRadius: number;
showGestureFeedback: boolean;
canBeDoubleTap(value: Windows$Windows$UI.Input.PointerPoint): boolean;
processDownEvent(value: Windows$Windows$UI.Input.PointerPoint): void;
processMoveEvents(
value: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>): void;
processUpEvent(value: Windows$Windows$UI.Input.PointerPoint): void;
processMouseWheelEvent(
value: Windows$Windows$UI.Input.PointerPoint,
isShiftKeyDown: boolean,
isControlKeyDown: boolean): void;
processInertia(): void;
completeGesture(): void;
ontapped: any;
onrighttapped: any;
onholding: any;
ondragging: any;
onmanipulationstarted: any;
onmanipulationupdated: any;
onmanipulationinertiastarting: any;
onmanipulationcompleted: any;
oncrosssliding: any
}
	declare export class TappedEventArgs mixins undefined.ITappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
tapCount: number
}
	declare export class RightTappedEventArgs mixins undefined.IRightTappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class HoldingEventArgs mixins undefined.IHoldingEventArgs {
holdingState: Windows$Windows$UI.Input.HoldingState;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class DraggingEventArgs mixins undefined.IDraggingEventArgs {
draggingState: Windows$Windows$UI.Input.DraggingState;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class ManipulationStartedEventArgs mixins undefined.IManipulationStartedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class ManipulationUpdatedEventArgs mixins undefined.IManipulationUpdatedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
delta: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
velocities: Windows$Windows$UI.Input.ManipulationVelocities
}
	declare export class ManipulationInertiaStartingEventArgs mixins undefined.IManipulationInertiaStartingEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
delta: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
velocities: Windows$Windows$UI.Input.ManipulationVelocities
}
	declare export class ManipulationCompletedEventArgs mixins undefined.IManipulationCompletedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
velocities: Windows$Windows$UI.Input.ManipulationVelocities
}
	declare export class CrossSlidingEventArgs mixins undefined.ICrossSlidingEventArgs {
crossSlidingState: Windows$Windows$UI.Input.CrossSlidingState;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export interface IPointerPointStatics {
getCurrentPoint(pointerId: number): Windows$Windows$UI.Input.PointerPoint,
getIntermediatePoints(
pointerId: number): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>,
getCurrentPoint(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$UI.Input.PointerPoint,
getIntermediatePoints(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
} 
	declare export class PointerPoint mixins undefined.IPointerPoint {
frameId: number;
isInContact: boolean;
pointerDevice: Windows$Windows$Devices.Input.PointerDevice;
pointerId: number;
position: Windows$Windows$Foundation.Point;
properties: Windows$Windows$UI.Input.PointerPointProperties;
rawPosition: Windows$Windows$Foundation.Point;
timestamp: number;
static getCurrentPoint(pointerId: number): Windows$Windows$UI.Input.PointerPoint;
static getIntermediatePoints(
pointerId: number): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>;
static getCurrentPoint(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$UI.Input.PointerPoint;
static getIntermediatePoints(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
}
	declare export interface IPointerPointTransform {
inverse: Windows$Windows$UI.Input.IPointerPointTransform,
tryTransform(
inPoint: Windows$Windows$Foundation.Point): {
outPoint: Windows$Windows$Foundation.Point,
returnValue: boolean
},
transformBounds(rect: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.Rect
} 
	declare export interface IPointerPoint {
frameId: number,
isInContact: boolean,
pointerDevice: Windows$Windows$Devices.Input.PointerDevice,
pointerId: number,
position: Windows$Windows$Foundation.Point,
properties: Windows$Windows$UI.Input.PointerPointProperties,
rawPosition: Windows$Windows$Foundation.Point,
timestamp: number
} 
	declare export class PointerPointProperties mixins undefined.IPointerPointProperties {
contactRect: Windows$Windows$Foundation.Rect;
contactRectRaw: Windows$Windows$Foundation.Rect;
isBarrelButtonPressed: boolean;
isCanceled: boolean;
isEraser: boolean;
isHorizontalMouseWheel: boolean;
isInRange: boolean;
isInverted: boolean;
isLeftButtonPressed: boolean;
isMiddleButtonPressed: boolean;
isPrimary: boolean;
isRightButtonPressed: boolean;
isXButton1Pressed: boolean;
isXButton2Pressed: boolean;
mouseWheelDelta: number;
orientation: number;
pointerUpdateKind: Windows$Windows$UI.Input.PointerUpdateKind;
pressure: number;
touchConfidence: boolean;
twist: number;
xTilt: number;
yTilt: number;
hasUsage(usagePage: number, usageId: number): boolean;
getUsageValue(usagePage: number, usageId: number): number
}
	declare export  class PointerUpdateKind {
  constructor(...args: empty): mixed;
static +other: Class<PointerUpdateKind__other> & PointerUpdateKind__other & 0;// 0
static +leftButtonPressed: Class<PointerUpdateKind__leftButtonPressed> & PointerUpdateKind__leftButtonPressed & 1;// 1
static +leftButtonReleased: Class<PointerUpdateKind__leftButtonReleased> & PointerUpdateKind__leftButtonReleased & 2;// 2
static +rightButtonPressed: Class<PointerUpdateKind__rightButtonPressed> & PointerUpdateKind__rightButtonPressed & 3;// 3
static +rightButtonReleased: Class<PointerUpdateKind__rightButtonReleased> & PointerUpdateKind__rightButtonReleased & 4;// 4
static +middleButtonPressed: Class<PointerUpdateKind__middleButtonPressed> & PointerUpdateKind__middleButtonPressed & 5;// 5
static +middleButtonReleased: Class<PointerUpdateKind__middleButtonReleased> & PointerUpdateKind__middleButtonReleased & 6;// 6
static +xButton1Pressed: Class<PointerUpdateKind__xButton1Pressed> & PointerUpdateKind__xButton1Pressed & 7;// 7
static +xButton1Released: Class<PointerUpdateKind__xButton1Released> & PointerUpdateKind__xButton1Released & 8;// 8
static +xButton2Pressed: Class<PointerUpdateKind__xButton2Pressed> & PointerUpdateKind__xButton2Pressed & 9;// 9
static +xButton2Released: Class<PointerUpdateKind__xButton2Released> & PointerUpdateKind__xButton2Released & 10;// 10

}

declare class PointerUpdateKind__other mixins PointerUpdateKind {}
declare class PointerUpdateKind__leftButtonPressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__leftButtonReleased mixins PointerUpdateKind {}
declare class PointerUpdateKind__rightButtonPressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__rightButtonReleased mixins PointerUpdateKind {}
declare class PointerUpdateKind__middleButtonPressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__middleButtonReleased mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton1Pressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton1Released mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton2Pressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton2Released mixins PointerUpdateKind {}

	declare export interface IPointerPointProperties {
contactRect: Windows$Windows$Foundation.Rect,
contactRectRaw: Windows$Windows$Foundation.Rect,
isBarrelButtonPressed: boolean,
isCanceled: boolean,
isEraser: boolean,
isHorizontalMouseWheel: boolean,
isInRange: boolean,
isInverted: boolean,
isLeftButtonPressed: boolean,
isMiddleButtonPressed: boolean,
isPrimary: boolean,
isRightButtonPressed: boolean,
isXButton1Pressed: boolean,
isXButton2Pressed: boolean,
mouseWheelDelta: number,
orientation: number,
pointerUpdateKind: Windows$Windows$UI.Input.PointerUpdateKind,
pressure: number,
touchConfidence: boolean,
twist: number,
xTilt: number,
yTilt: number,
hasUsage(usagePage: number, usageId: number): boolean,
getUsageValue(usagePage: number, usageId: number): number
} 
	declare export interface IPointerVisualizationSettings {
isBarrelButtonFeedbackEnabled: boolean,
isContactFeedbackEnabled: boolean
} 
	declare export interface IPointerVisualizationSettingsStatics {
getForCurrentView(): Windows$Windows$UI.Input.PointerVisualizationSettings
} 
	declare export class PointerVisualizationSettings mixins undefined.IPointerVisualizationSettings {
isBarrelButtonFeedbackEnabled: boolean;
isContactFeedbackEnabled: boolean;
static getForCurrentView(): Windows$Windows$UI.Input.PointerVisualizationSettings
}
	declare module 'Inking' {
        declare export  class InkManipulationMode {
  constructor(...args: empty): mixed;
static +inking: Class<InkManipulationMode__inking> & InkManipulationMode__inking & 0;// 0
static +erasing: Class<InkManipulationMode__erasing> & InkManipulationMode__erasing & 1;// 1
static +selecting: Class<InkManipulationMode__selecting> & InkManipulationMode__selecting & 2;// 2

}

declare class InkManipulationMode__inking mixins InkManipulationMode {}
declare class InkManipulationMode__erasing mixins InkManipulationMode {}
declare class InkManipulationMode__selecting mixins InkManipulationMode {}

	declare export  class InkRecognitionTarget {
  constructor(...args: empty): mixed;
static +all: Class<InkRecognitionTarget__all> & InkRecognitionTarget__all & 0;// 0
static +selected: Class<InkRecognitionTarget__selected> & InkRecognitionTarget__selected & 1;// 1
static +recent: Class<InkRecognitionTarget__recent> & InkRecognitionTarget__recent & 2;// 2

}

declare class InkRecognitionTarget__all mixins InkRecognitionTarget {}
declare class InkRecognitionTarget__selected mixins InkRecognitionTarget {}
declare class InkRecognitionTarget__recent mixins InkRecognitionTarget {}

	declare export  class PenTipShape {
  constructor(...args: empty): mixed;
static +circle: Class<PenTipShape__circle> & PenTipShape__circle & 0;// 0
static +rectangle: Class<PenTipShape__rectangle> & PenTipShape__rectangle & 1;// 1

}

declare class PenTipShape__circle mixins PenTipShape {}
declare class PenTipShape__rectangle mixins PenTipShape {}

	declare export interface IInkDrawingAttributes {
color: Windows$Windows$UI.Color,
fitToCurve: boolean,
ignorePressure: boolean,
penTip: Windows$Windows$UI.Input.Inking.PenTipShape,
size: Windows$Windows$Foundation.Size
} 
	declare export class InkDrawingAttributes mixins undefined.IInkDrawingAttributes {
color: Windows$Windows$UI.Color;
fitToCurve: boolean;
ignorePressure: boolean;
penTip: Windows$Windows$UI.Input.Inking.PenTipShape;
size: Windows$Windows$Foundation.Size
}
	declare export interface IInkStrokeRenderingSegment {
bezierControlPoint1: Windows$Windows$Foundation.Point,
bezierControlPoint2: Windows$Windows$Foundation.Point,
position: Windows$Windows$Foundation.Point,
pressure: number,
tiltX: number,
tiltY: number,
twist: number
} 
	declare export class InkStrokeRenderingSegment mixins undefined.IInkStrokeRenderingSegment {
bezierControlPoint1: Windows$Windows$Foundation.Point;
bezierControlPoint2: Windows$Windows$Foundation.Point;
position: Windows$Windows$Foundation.Point;
pressure: number;
tiltX: number;
tiltY: number;
twist: number
}
	declare export interface IInkStroke {
boundingRect: Windows$Windows$Foundation.Rect,
drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes,
recognized: boolean,
selected: boolean,
getRenderingSegments(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStrokeRenderingSegment>,
clone(): Windows$Windows$UI.Input.Inking.InkStroke
} 
	declare export class InkStroke mixins undefined.IInkStroke {
boundingRect: Windows$Windows$Foundation.Rect;
drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes;
recognized: boolean;
selected: boolean;
getRenderingSegments(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStrokeRenderingSegment>;
clone(): Windows$Windows$UI.Input.Inking.InkStroke
}
	declare export interface IInkStrokeBuilder {
beginStroke(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void,
appendToStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.PointerPoint,
endStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.Inking.InkStroke,
createStroke(
points: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$UI.Input.Inking.InkStroke,
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void
} 
	declare export class InkStrokeBuilder mixins undefined.IInkStrokeBuilder {
beginStroke(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void;
appendToStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.PointerPoint;
endStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.Inking.InkStroke;
createStroke(
points: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$UI.Input.Inking.InkStroke;
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void
}
	declare export interface IInkRecognitionResult {
boundingRect: Windows$Windows$Foundation.Rect,
getTextCandidates(): Windows$Windows$Foundation.Collections.IVectorView<string>,
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>
} 
	declare export class InkRecognitionResult mixins undefined.IInkRecognitionResult {
boundingRect: Windows$Windows$Foundation.Rect;
getTextCandidates(): Windows$Windows$Foundation.Collections.IVectorView<string>;
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>
}
	declare export interface IInkStrokeContainer {
boundingRect: Windows$Windows$Foundation.Rect,
addStroke(stroke: Windows$Windows$UI.Input.Inking.InkStroke): void,
deleteSelected(): Windows$Windows$Foundation.Rect,
moveSelected(translation: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect,
selectWithPolyLine(
polyline: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$Foundation.Rect,
selectWithLine(
from: Windows$Windows$Foundation.Point,
to: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect,
copySelectedToClipboard(): void,
pasteFromClipboard(position: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect,
canPasteFromClipboard(): boolean,
loadAsync(
inputStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<number>,
saveAsync(
outputStream: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>,
updateRecognitionResults(
recognitionResults: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>): void,
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>,
getRecognitionResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>
} 
	declare export class InkStrokeContainer mixins undefined.IInkStrokeContainer {
boundingRect: Windows$Windows$Foundation.Rect;
addStroke(stroke: Windows$Windows$UI.Input.Inking.InkStroke): void;
deleteSelected(): Windows$Windows$Foundation.Rect;
moveSelected(translation: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
selectWithPolyLine(
polyline: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$Foundation.Rect;
selectWithLine(
from: Windows$Windows$Foundation.Point,
to: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
copySelectedToClipboard(): void;
pasteFromClipboard(position: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
canPasteFromClipboard(): boolean;
loadAsync(
inputStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<number>;
saveAsync(
outputStream: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
updateRecognitionResults(
recognitionResults: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>): void;
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>;
getRecognitionResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>
}
	declare export interface IInkRecognizer {
name: string
} 
	declare export class InkRecognizer mixins undefined.IInkRecognizer {
name: string
}
	declare export interface IInkRecognizerContainer {
setDefaultRecognizer(recognizer: Windows$Windows$UI.Input.Inking.InkRecognizer): void,
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>,
getRecognizers(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognizer>
} 
	declare export class InkRecognizerContainer mixins undefined.IInkRecognizerContainer {
setDefaultRecognizer(recognizer: Windows$Windows$UI.Input.Inking.InkRecognizer): void;
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>;
getRecognizers(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognizer>
}
	declare export type IInkManager = {
mode: Windows$Windows$UI.Input.Inking.InkManipulationMode,
processPointerDown(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void,
processPointerUpdate(pointerPoint: Windows$Windows$UI.Input.PointerPoint): any,
processPointerUp(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$Foundation.Rect,
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void,
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>,
recognizeAsync(
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>
} & undefined.IInkStrokeContainer & undefined.IInkRecognizerContainer

	declare export class InkManager mixins undefined.IInkManager, undefined.IInkStrokeContainer, undefined.IInkRecognizerContainer {
mode: Windows$Windows$UI.Input.Inking.InkManipulationMode;
boundingRect: Windows$Windows$Foundation.Rect;
processPointerDown(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void;
processPointerUpdate(pointerPoint: Windows$Windows$UI.Input.PointerPoint): any;
processPointerUp(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$Foundation.Rect;
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void;
recognizeAsync(
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>;
addStroke(stroke: Windows$Windows$UI.Input.Inking.InkStroke): void;
deleteSelected(): Windows$Windows$Foundation.Rect;
moveSelected(translation: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
selectWithPolyLine(
polyline: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$Foundation.Rect;
selectWithLine(
from: Windows$Windows$Foundation.Point,
to: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
copySelectedToClipboard(): void;
pasteFromClipboard(position: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
canPasteFromClipboard(): boolean;
loadAsync(
inputStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<number>;
saveAsync(
outputStream: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
updateRecognitionResults(
recognitionResults: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>): void;
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>;
getRecognitionResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>;
setDefaultRecognizer(recognizer: Windows$Windows$UI.Input.Inking.InkRecognizer): void;
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>;
getRecognizers(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognizer>
}
    }

    }

	declare module 'Portable' {
        declare export  class ServiceDeviceType {
  constructor(...args: empty): mixed;
static +calendarService: Class<ServiceDeviceType__calendarService> & ServiceDeviceType__calendarService & 0;// 0
static +contactsService: Class<ServiceDeviceType__contactsService> & ServiceDeviceType__contactsService & 1;// 1
static +deviceStatusService: Class<ServiceDeviceType__deviceStatusService> & ServiceDeviceType__deviceStatusService & 2;// 2
static +notesService: Class<ServiceDeviceType__notesService> & ServiceDeviceType__notesService & 3;// 3
static +ringtonesService: Class<ServiceDeviceType__ringtonesService> & ServiceDeviceType__ringtonesService & 4;// 4
static +smsService: Class<ServiceDeviceType__smsService> & ServiceDeviceType__smsService & 5;// 5
static +tasksService: Class<ServiceDeviceType__tasksService> & ServiceDeviceType__tasksService & 6;// 6

}

declare class ServiceDeviceType__calendarService mixins ServiceDeviceType {}
declare class ServiceDeviceType__contactsService mixins ServiceDeviceType {}
declare class ServiceDeviceType__deviceStatusService mixins ServiceDeviceType {}
declare class ServiceDeviceType__notesService mixins ServiceDeviceType {}
declare class ServiceDeviceType__ringtonesService mixins ServiceDeviceType {}
declare class ServiceDeviceType__smsService mixins ServiceDeviceType {}
declare class ServiceDeviceType__tasksService mixins ServiceDeviceType {}

	declare export interface IStorageDeviceStatics {
fromId(interfaceId: string): Windows$Windows$Storage.StorageFolder,
getDeviceSelector(): string
} 
	declare export interface IServiceDeviceStatics {
getDeviceSelector(serviceType: Windows$Windows$Devices.Portable.ServiceDeviceType): string,
getDeviceSelectorFromServiceId(serviceId: string): string
} 
	declare export class StorageDevice  {
static fromId(interfaceId: string): Windows$Windows$Storage.StorageFolder;
static getDeviceSelector(): string
}
	declare export class ServiceDevice  {
static getDeviceSelector(serviceType: Windows$Windows$Devices.Portable.ServiceDeviceType): string;
static getDeviceSelectorFromServiceId(serviceId: string): string
}
    }

	declare module 'Printers' {
        declare module 'Extensions' {
        declare export interface IPrintTaskConfigurationSaveRequestedDeferral {
complete(): void
} 
	declare export class PrintTaskConfigurationSaveRequestedDeferral mixins undefined.IPrintTaskConfigurationSaveRequestedDeferral {
complete(): void
}
	declare export interface IPrintTaskConfigurationSaveRequest {
deadline: Date,
cancel(): void,
save(printerExtensionContext: any): void,
getDeferral(
): Windows$Windows$Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedDeferral
} 
	declare export class PrintTaskConfigurationSaveRequest mixins undefined.IPrintTaskConfigurationSaveRequest {
deadline: Date;
cancel(): void;
save(printerExtensionContext: any): void;
getDeferral(
): Windows$Windows$Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedDeferral
}
	declare export interface IPrintTaskConfigurationSaveRequestedEventArgs {
request: Windows$Windows$Devices.Printers.Extensions.PrintTaskConfigurationSaveRequest
} 
	declare export class PrintTaskConfigurationSaveRequestedEventArgs mixins undefined.IPrintTaskConfigurationSaveRequestedEventArgs {
request: Windows$Windows$Devices.Printers.Extensions.PrintTaskConfigurationSaveRequest
}
	declare export interface IPrintTaskConfiguration {
printerExtensionContext: any,
onsaverequested: any
} 
	declare export class PrintTaskConfiguration mixins undefined.IPrintTaskConfiguration {
printerExtensionContext: any;
onsaverequested: any
}
	declare export interface IPrintNotificationEventDetails {
eventData: string,
printerName: string
} 
	declare export class PrintNotificationEventDetails mixins undefined.IPrintNotificationEventDetails {
eventData: string;
printerName: string
}
	declare export interface IPrintExtensionContextStatic {
fromDeviceId(deviceId: string): any
} 
	declare export class PrintExtensionContext  {
static fromDeviceId(deviceId: string): any
}
    }

    }

	declare module 'Sensors' {
        declare export interface IAccelerometerStatics {
getDefault(): Windows$Windows$Devices.Sensors.Accelerometer
} 
	declare export class Accelerometer mixins undefined.IAccelerometer {
minimumReportInterval: number;
reportInterval: number;
getCurrentReading(): Windows$Windows$Devices.Sensors.AccelerometerReading;
onreadingchanged: any;
onshaken: any;
static getDefault(): Windows$Windows$Devices.Sensors.Accelerometer
}
	declare export interface IAccelerometer {
minimumReportInterval: number,
reportInterval: number,
getCurrentReading(): Windows$Windows$Devices.Sensors.AccelerometerReading,
onreadingchanged: any,
onshaken: any
} 
	declare export class AccelerometerReading mixins undefined.IAccelerometerReading {
accelerationX: number;
accelerationY: number;
accelerationZ: number;
timestamp: Date
}
	declare export class AccelerometerReadingChangedEventArgs mixins undefined.IAccelerometerReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.AccelerometerReading
}
	declare export class AccelerometerShakenEventArgs mixins undefined.IAccelerometerShakenEventArgs {
timestamp: Date
}
	declare export interface IAccelerometerReading {
accelerationX: number,
accelerationY: number,
accelerationZ: number,
timestamp: Date
} 
	declare export interface IAccelerometerReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.AccelerometerReading
} 
	declare export interface IAccelerometerShakenEventArgs {
timestamp: Date
} 
	declare export interface IInclinometerStatics {
getDefault(): Windows$Windows$Devices.Sensors.Inclinometer
} 
	declare export class Inclinometer mixins undefined.IInclinometer {
minimumReportInterval: number;
reportInterval: number;
getCurrentReading(): Windows$Windows$Devices.Sensors.InclinometerReading;
onreadingchanged: any;
static getDefault(): Windows$Windows$Devices.Sensors.Inclinometer
}
	declare export interface IInclinometer {
minimumReportInterval: number,
reportInterval: number,
getCurrentReading(): Windows$Windows$Devices.Sensors.InclinometerReading,
onreadingchanged: any
} 
	declare export class InclinometerReading mixins undefined.IInclinometerReading {
pitchDegrees: number;
rollDegrees: number;
timestamp: Date;
yawDegrees: number
}
	declare export class InclinometerReadingChangedEventArgs mixins undefined.IInclinometerReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.InclinometerReading
}
	declare export interface IInclinometerReading {
pitchDegrees: number,
rollDegrees: number,
timestamp: Date,
yawDegrees: number
} 
	declare export interface IInclinometerReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.InclinometerReading
} 
	declare export interface IGyrometerStatics {
getDefault(): Windows$Windows$Devices.Sensors.Gyrometer
} 
	declare export class Gyrometer mixins undefined.IGyrometer {
minimumReportInterval: number;
reportInterval: number;
getCurrentReading(): Windows$Windows$Devices.Sensors.GyrometerReading;
onreadingchanged: any;
static getDefault(): Windows$Windows$Devices.Sensors.Gyrometer
}
	declare export interface IGyrometer {
minimumReportInterval: number,
reportInterval: number,
getCurrentReading(): Windows$Windows$Devices.Sensors.GyrometerReading,
onreadingchanged: any
} 
	declare export class GyrometerReading mixins undefined.IGyrometerReading {
angularVelocityX: number;
angularVelocityY: number;
angularVelocityZ: number;
timestamp: Date
}
	declare export class GyrometerReadingChangedEventArgs mixins undefined.IGyrometerReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.GyrometerReading
}
	declare export interface IGyrometerReading {
angularVelocityX: number,
angularVelocityY: number,
angularVelocityZ: number,
timestamp: Date
} 
	declare export interface IGyrometerReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.GyrometerReading
} 
	declare export interface ICompassStatics {
getDefault(): Windows$Windows$Devices.Sensors.Compass
} 
	declare export class Compass mixins undefined.ICompass {
minimumReportInterval: number;
reportInterval: number;
getCurrentReading(): Windows$Windows$Devices.Sensors.CompassReading;
onreadingchanged: any;
static getDefault(): Windows$Windows$Devices.Sensors.Compass
}
	declare export interface ICompass {
minimumReportInterval: number,
reportInterval: number,
getCurrentReading(): Windows$Windows$Devices.Sensors.CompassReading,
onreadingchanged: any
} 
	declare export class CompassReading mixins undefined.ICompassReading {
headingMagneticNorth: number;
headingTrueNorth: number;
timestamp: Date
}
	declare export class CompassReadingChangedEventArgs mixins undefined.ICompassReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.CompassReading
}
	declare export interface ICompassReading {
headingMagneticNorth: number,
headingTrueNorth: number,
timestamp: Date
} 
	declare export interface ICompassReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.CompassReading
} 
	declare export interface ILightSensorStatics {
getDefault(): Windows$Windows$Devices.Sensors.LightSensor
} 
	declare export class LightSensor mixins undefined.ILightSensor {
minimumReportInterval: number;
reportInterval: number;
getCurrentReading(): Windows$Windows$Devices.Sensors.LightSensorReading;
onreadingchanged: any;
static getDefault(): Windows$Windows$Devices.Sensors.LightSensor
}
	declare export interface ILightSensor {
minimumReportInterval: number,
reportInterval: number,
getCurrentReading(): Windows$Windows$Devices.Sensors.LightSensorReading,
onreadingchanged: any
} 
	declare export class LightSensorReading mixins undefined.ILightSensorReading {
illuminanceInLux: number;
timestamp: Date
}
	declare export class LightSensorReadingChangedEventArgs mixins undefined.ILightSensorReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.LightSensorReading
}
	declare export interface ILightSensorReading {
illuminanceInLux: number,
timestamp: Date
} 
	declare export interface ILightSensorReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.LightSensorReading
} 
	declare export interface ISensorRotationMatrix {
m11: number,
m12: number,
m13: number,
m21: number,
m22: number,
m23: number,
m31: number,
m32: number,
m33: number
} 
	declare export interface ISensorQuaternion {
w: number,
x: number,
y: number,
z: number
} 
	declare export class SensorRotationMatrix mixins undefined.ISensorRotationMatrix {
m11: number;
m12: number;
m13: number;
m21: number;
m22: number;
m23: number;
m31: number;
m32: number;
m33: number
}
	declare export class SensorQuaternion mixins undefined.ISensorQuaternion {
w: number;
x: number;
y: number;
z: number
}
	declare export interface IOrientationSensorStatics {
getDefault(): Windows$Windows$Devices.Sensors.OrientationSensor
} 
	declare export class OrientationSensor mixins undefined.IOrientationSensor {
minimumReportInterval: number;
reportInterval: number;
getCurrentReading(): Windows$Windows$Devices.Sensors.OrientationSensorReading;
onreadingchanged: any;
static getDefault(): Windows$Windows$Devices.Sensors.OrientationSensor
}
	declare export interface IOrientationSensor {
minimumReportInterval: number,
reportInterval: number,
getCurrentReading(): Windows$Windows$Devices.Sensors.OrientationSensorReading,
onreadingchanged: any
} 
	declare export class OrientationSensorReading mixins undefined.IOrientationSensorReading {
quaternion: Windows$Windows$Devices.Sensors.SensorQuaternion;
rotationMatrix: Windows$Windows$Devices.Sensors.SensorRotationMatrix;
timestamp: Date
}
	declare export class OrientationSensorReadingChangedEventArgs mixins undefined.IOrientationSensorReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.OrientationSensorReading
}
	declare export interface IOrientationSensorReading {
quaternion: Windows$Windows$Devices.Sensors.SensorQuaternion,
rotationMatrix: Windows$Windows$Devices.Sensors.SensorRotationMatrix,
timestamp: Date
} 
	declare export interface IOrientationSensorReadingChangedEventArgs {
reading: Windows$Windows$Devices.Sensors.OrientationSensorReading
} 
	declare export  class SimpleOrientation {
  constructor(...args: empty): mixed;
static +notRotated: Class<SimpleOrientation__notRotated> & SimpleOrientation__notRotated & 0;// 0
static +rotated90DegreesCounterclockwise: Class<SimpleOrientation__rotated90DegreesCounterclockwise> & SimpleOrientation__rotated90DegreesCounterclockwise & 1;// 1
static +rotated180DegreesCounterclockwise: Class<SimpleOrientation__rotated180DegreesCounterclockwise> & SimpleOrientation__rotated180DegreesCounterclockwise & 2;// 2
static +rotated270DegreesCounterclockwise: Class<SimpleOrientation__rotated270DegreesCounterclockwise> & SimpleOrientation__rotated270DegreesCounterclockwise & 3;// 3
static +faceup: Class<SimpleOrientation__faceup> & SimpleOrientation__faceup & 4;// 4
static +facedown: Class<SimpleOrientation__facedown> & SimpleOrientation__facedown & 5;// 5

}

declare class SimpleOrientation__notRotated mixins SimpleOrientation {}
declare class SimpleOrientation__rotated90DegreesCounterclockwise mixins SimpleOrientation {}
declare class SimpleOrientation__rotated180DegreesCounterclockwise mixins SimpleOrientation {}
declare class SimpleOrientation__rotated270DegreesCounterclockwise mixins SimpleOrientation {}
declare class SimpleOrientation__faceup mixins SimpleOrientation {}
declare class SimpleOrientation__facedown mixins SimpleOrientation {}

	declare export interface ISimpleOrientationSensorStatics {
getDefault(): Windows$Windows$Devices.Sensors.SimpleOrientationSensor
} 
	declare export class SimpleOrientationSensor mixins undefined.ISimpleOrientationSensor {
getCurrentOrientation(): Windows$Windows$Devices.Sensors.SimpleOrientation;
onorientationchanged: any;
static getDefault(): Windows$Windows$Devices.Sensors.SimpleOrientationSensor
}
	declare export interface ISimpleOrientationSensor {
getCurrentOrientation(): Windows$Windows$Devices.Sensors.SimpleOrientation,
onorientationchanged: any
} 
	declare export class SimpleOrientationSensorOrientationChangedEventArgs mixins undefined.ISimpleOrientationSensorOrientationChangedEventArgs {
orientation: Windows$Windows$Devices.Sensors.SimpleOrientation;
timestamp: Date
}
	declare export interface ISimpleOrientationSensorOrientationChangedEventArgs {
orientation: Windows$Windows$Devices.Sensors.SimpleOrientation,
timestamp: Date
} 
    }

	declare export  class TelephonyKey {
  constructor(...args: empty): mixed;
static +d0: Class<TelephonyKey__d0> & TelephonyKey__d0 & 0;// 0
static +d1: Class<TelephonyKey__d1> & TelephonyKey__d1 & 1;// 1
static +d2: Class<TelephonyKey__d2> & TelephonyKey__d2 & 2;// 2
static +d3: Class<TelephonyKey__d3> & TelephonyKey__d3 & 3;// 3
static +d4: Class<TelephonyKey__d4> & TelephonyKey__d4 & 4;// 4
static +d5: Class<TelephonyKey__d5> & TelephonyKey__d5 & 5;// 5
static +d6: Class<TelephonyKey__d6> & TelephonyKey__d6 & 6;// 6
static +d7: Class<TelephonyKey__d7> & TelephonyKey__d7 & 7;// 7
static +d8: Class<TelephonyKey__d8> & TelephonyKey__d8 & 8;// 8
static +d9: Class<TelephonyKey__d9> & TelephonyKey__d9 & 9;// 9
static +star: Class<TelephonyKey__star> & TelephonyKey__star & 10;// 10
static +pound: Class<TelephonyKey__pound> & TelephonyKey__pound & 11;// 11
static +a: Class<TelephonyKey__a> & TelephonyKey__a & 12;// 12
static +b: Class<TelephonyKey__b> & TelephonyKey__b & 13;// 13
static +c: Class<TelephonyKey__c> & TelephonyKey__c & 14;// 14
static +d: Class<TelephonyKey__d> & TelephonyKey__d & 15;// 15

}

declare class TelephonyKey__d0 mixins TelephonyKey {}
declare class TelephonyKey__d1 mixins TelephonyKey {}
declare class TelephonyKey__d2 mixins TelephonyKey {}
declare class TelephonyKey__d3 mixins TelephonyKey {}
declare class TelephonyKey__d4 mixins TelephonyKey {}
declare class TelephonyKey__d5 mixins TelephonyKey {}
declare class TelephonyKey__d6 mixins TelephonyKey {}
declare class TelephonyKey__d7 mixins TelephonyKey {}
declare class TelephonyKey__d8 mixins TelephonyKey {}
declare class TelephonyKey__d9 mixins TelephonyKey {}
declare class TelephonyKey__star mixins TelephonyKey {}
declare class TelephonyKey__pound mixins TelephonyKey {}
declare class TelephonyKey__a mixins TelephonyKey {}
declare class TelephonyKey__b mixins TelephonyKey {}
declare class TelephonyKey__c mixins TelephonyKey {}
declare class TelephonyKey__d mixins TelephonyKey {}

	declare export interface IDialRequestedEventArgs {
contact: any,
handled(): void
} 
	declare export class DialRequestedEventArgs mixins undefined.IDialRequestedEventArgs {
contact: any;
handled(): void
}
	declare export interface IRedialRequestedEventArgs {
handled(): void
} 
	declare export class RedialRequestedEventArgs mixins undefined.IRedialRequestedEventArgs {
handled(): void
}
	declare export interface IKeypadPressedEventArgs {
telephonyKey: Windows$Windows$Media.Windows$Devices.TelephonyKey
} 
	declare export class KeypadPressedEventArgs mixins undefined.IKeypadPressedEventArgs {
telephonyKey: Windows$Windows$Media.Windows$Devices.TelephonyKey
}
	declare export interface CallControlEventHandler {
(sender: Windows$Windows$Media.Windows$Devices.CallControl): void
} 
	declare export class CallControl mixins undefined.ICallControl {
hasRinger: boolean;
indicateNewIncomingCall(enableRinger: boolean, callerId: string): number;
indicateNewOutgoingCall(): number;
indicateActiveCall(callToken: number): void;
endCall(callToken: number): void;
onanswerrequested: any;
onhanguprequested: any;
ondialrequested: any;
onredialrequested: any;
onkeypadpressed: any;
onaudiotransferrequested: any;
static getDefault(): Windows$Windows$Media.Windows$Devices.CallControl;
static fromId(deviceInterfaceId: string): Windows$Windows$Media.Windows$Devices.CallControl
}
	declare export interface DialRequestedEventHandler {
(sender: Windows$Windows$Media.Windows$Devices.CallControl, e: Windows$Windows$Media.Windows$Devices.DialRequestedEventArgs): void
} 
	declare export interface RedialRequestedEventHandler {
(sender: Windows$Windows$Media.Windows$Devices.CallControl, e: Windows$Windows$Media.Windows$Devices.RedialRequestedEventArgs): void
} 
	declare export interface KeypadPressedEventHandler {
(sender: Windows$Windows$Media.Windows$Devices.CallControl, e: Windows$Windows$Media.Windows$Devices.KeypadPressedEventArgs): void
} 
	declare export interface ICallControl {
hasRinger: boolean,
indicateNewIncomingCall(enableRinger: boolean, callerId: string): number,
indicateNewOutgoingCall(): number,
indicateActiveCall(callToken: number): void,
endCall(callToken: number): void,
onanswerrequested: any,
onhanguprequested: any,
ondialrequested: any,
onredialrequested: any,
onkeypadpressed: any,
onaudiotransferrequested: any
} 
	declare export interface ICallControlStatics {
getDefault(): Windows$Windows$Media.Windows$Devices.CallControl,
fromId(deviceInterfaceId: string): Windows$Windows$Media.Windows$Devices.CallControl
} 
	declare export  class AudioDeviceRole {
  constructor(...args: empty): mixed;
static +default: Class<AudioDeviceRole__default> & AudioDeviceRole__default & 0;// 0
static +communications: Class<AudioDeviceRole__communications> & AudioDeviceRole__communications & 1;// 1

}

declare class AudioDeviceRole__default mixins AudioDeviceRole {}
declare class AudioDeviceRole__communications mixins AudioDeviceRole {}

	declare export interface IDefaultAudioDeviceChangedEventArgs {
id: string,
role: Windows$Windows$Media.Windows$Devices.AudioDeviceRole
} 
	declare export interface IMediaDeviceStatics {
getAudioCaptureSelector(): string,
getAudioRenderSelector(): string,
getVideoCaptureSelector(): string,
getDefaultAudioCaptureId(role: Windows$Windows$Media.Windows$Devices.AudioDeviceRole): string,
getDefaultAudioRenderId(role: Windows$Windows$Media.Windows$Devices.AudioDeviceRole): string,
ondefaultaudiocapturedevicechanged: any,
ondefaultaudiorenderdevicechanged: any
} 
	declare export class DefaultAudioCaptureDeviceChangedEventArgs mixins undefined.IDefaultAudioDeviceChangedEventArgs {
id: string;
role: Windows$Windows$Media.Windows$Devices.AudioDeviceRole
}
	declare export class DefaultAudioRenderDeviceChangedEventArgs mixins undefined.IDefaultAudioDeviceChangedEventArgs {
id: string;
role: Windows$Windows$Media.Windows$Devices.AudioDeviceRole
}
	declare export class MediaDevice  {
static getAudioCaptureSelector(): string;
static getAudioRenderSelector(): string;
static getVideoCaptureSelector(): string;
static getDefaultAudioCaptureId(role: Windows$Windows$Media.Windows$Devices.AudioDeviceRole): string;
static getDefaultAudioRenderId(role: Windows$Windows$Media.Windows$Devices.AudioDeviceRole): string;
static ondefaultaudiocapturedevicechanged: any;
static ondefaultaudiorenderdevicechanged: any
}
	declare export class AudioDeviceController mixins undefined.IAudioDeviceController, undefined.IMediaDeviceController {
muted: boolean;
volumePercent: number;
getAvailableMediaStreamProperties(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Media.MediaProperties.IMediaEncodingProperties>;
getMediaStreamProperties(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType): Windows$Windows$Media.MediaProperties.IMediaEncodingProperties;
setMediaStreamPropertiesAsync(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType,
mediaEncodingProperties: Windows$Windows$Media.MediaProperties.IMediaEncodingProperties): Windows$Windows$Foundation.IAsyncAction
}
	declare export class VideoDeviceController mixins undefined.IVideoDeviceController, undefined.IMediaDeviceController, undefined.IAdvancedVideoCaptureDeviceController {
backlightCompensation: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
brightness: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
contrast: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
exposure: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
focus: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
hue: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
pan: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
roll: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
tilt: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
whiteBalance: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
zoom: Windows$Windows$Media.Windows$Devices.MediaDeviceControl;
trySetPowerlineFrequency(value: Windows$Windows$Media.Capture.PowerlineFrequency): boolean;
tryGetPowerlineFrequency(
): {
value: Windows$Windows$Media.Capture.PowerlineFrequency,
succeeded: boolean
};
getAvailableMediaStreamProperties(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Media.MediaProperties.IMediaEncodingProperties>;
getMediaStreamProperties(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType): Windows$Windows$Media.MediaProperties.IMediaEncodingProperties;
setMediaStreamPropertiesAsync(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType,
mediaEncodingProperties: Windows$Windows$Media.MediaProperties.IMediaEncodingProperties): Windows$Windows$Foundation.IAsyncAction;
setDeviceProperty(propertyId: string, propertyValue: any): void;
getDeviceProperty(propertyId: string): any
}
	declare export interface IMediaDeviceController {
getAvailableMediaStreamProperties(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Media.MediaProperties.IMediaEncodingProperties>,
getMediaStreamProperties(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType): Windows$Windows$Media.MediaProperties.IMediaEncodingProperties,
setMediaStreamPropertiesAsync(
mediaStreamType: Windows$Windows$Media.Capture.MediaStreamType,
mediaEncodingProperties: Windows$Windows$Media.MediaProperties.IMediaEncodingProperties): Windows$Windows$Foundation.IAsyncAction
} 
	declare export type IAudioDeviceController = {
muted: boolean,
volumePercent: number
} & undefined.IMediaDeviceController

	declare export type IVideoDeviceController = {
backlightCompensation: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
brightness: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
contrast: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
exposure: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
focus: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
hue: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
pan: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
roll: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
tilt: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
whiteBalance: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
zoom: Windows$Windows$Media.Windows$Devices.MediaDeviceControl,
trySetPowerlineFrequency(value: Windows$Windows$Media.Capture.PowerlineFrequency): boolean,
tryGetPowerlineFrequency(
): {
value: Windows$Windows$Media.Capture.PowerlineFrequency,
succeeded: boolean
}
} & undefined.IMediaDeviceController

	declare export class MediaDeviceControl mixins undefined.IMediaDeviceControl {
capabilities: Windows$Windows$Media.Windows$Devices.MediaDeviceControlCapabilities;
tryGetValue(): {
value: number,
succeeded: boolean
};
trySetValue(value: number): boolean;
tryGetAuto(): {
value: boolean,
succeeded: boolean
};
trySetAuto(value: boolean): boolean
}
	declare export interface IMediaDeviceControl {
capabilities: Windows$Windows$Media.Windows$Devices.MediaDeviceControlCapabilities,
tryGetValue(): {
value: number,
succeeded: boolean
},
trySetValue(value: number): boolean,
tryGetAuto(): {
value: boolean,
succeeded: boolean
},
trySetAuto(value: boolean): boolean
} 
	declare export class MediaDeviceControlCapabilities mixins undefined.IMediaDeviceControlCapabilities {
autoModeSupported: boolean;
default: number;
max: number;
min: number;
step: number;
supported: boolean
}
	declare export interface IMediaDeviceControlCapabilities {
autoModeSupported: boolean,
default: number,
max: number,
min: number,
step: number,
supported: boolean
} 
	declare export interface IAdvancedVideoCaptureDeviceController {
setDeviceProperty(propertyId: string, propertyValue: any): void,
getDeviceProperty(propertyId: string): any
} 
    }

	declare export  class SoundLevel {
  constructor(...args: empty): mixed;
static +muted: Class<SoundLevel__muted> & SoundLevel__muted & 0;// 0
static +low: Class<SoundLevel__low> & SoundLevel__low & 1;// 1
static +full: Class<SoundLevel__full> & SoundLevel__full & 2;// 2

}

declare class SoundLevel__muted mixins SoundLevel {}
declare class SoundLevel__low mixins SoundLevel {}
declare class SoundLevel__full mixins SoundLevel {}

	declare export interface IMediaControl {
albumArt: Windows$Windows$Foundation.Uri,
artistName: string,
isPlaying: boolean,
soundLevel: Windows$Windows$Media.SoundLevel,
trackName: string,
onsoundlevelchanged: any,
onplaypressed: any,
onpausepressed: any,
onstoppressed: any,
onplaypausetogglepressed: any,
onrecordpressed: any,
onnexttrackpressed: any,
onprevioustrackpressed: any,
onfastforwardpressed: any,
onrewindpressed: any,
onchanneluppressed: any,
onchanneldownpressed: any
} 
	declare export class MediaControl  {
static albumArt: Windows$Windows$Foundation.Uri;
static artistName: string;
static isPlaying: boolean;
static soundLevel: Windows$Windows$Media.SoundLevel;
static trackName: string;
static onsoundlevelchanged: any;
static onplaypressed: any;
static onpausepressed: any;
static onstoppressed: any;
static onplaypausetogglepressed: any;
static onrecordpressed: any;
static onnexttrackpressed: any;
static onprevioustrackpressed: any;
static onfastforwardpressed: any;
static onrewindpressed: any;
static onchanneluppressed: any;
static onchanneldownpressed: any
}
	declare export interface IMediaExtension {
setProperties(configuration: Windows$Windows$Foundation.Collections.IPropertySet): void
} 
	declare export interface IMediaExtensionManager {
registerSchemeHandler(activatableClassId: string, scheme: string): void,
registerSchemeHandler(
activatableClassId: string,
scheme: string,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void,
registerByteStreamHandler(activatableClassId: string, fileExtension: string, mimeType: string): void,
registerByteStreamHandler(
activatableClassId: string,
fileExtension: string,
mimeType: string,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void,
registerAudioDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void,
registerAudioDecoder(
activatableClassId: string,
inputSubtype: string,
outputSubtype: string,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void,
registerAudioEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void,
registerAudioEncoder(
activatableClassId: string,
inputSubtype: string,
outputSubtype: string,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void,
registerVideoDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void,
registerVideoDecoder(
activatableClassId: string,
inputSubtype: string,
outputSubtype: string,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void,
registerVideoEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void,
registerVideoEncoder(
activatableClassId: string,
inputSubtype: string,
outputSubtype: string,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void
} 
	declare export class MediaExtensionManager mixins undefined.IMediaExtensionManager {
registerSchemeHandler(activatableClassId: string, scheme: string): void;
registerSchemeHandler(
activatableClassId: string,
scheme: string,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void;
registerByteStreamHandler(activatableClassId: string, fileExtension: string, mimeType: string): void;
registerByteStreamHandler(
activatableClassId: string,
fileExtension: string,
mimeType: string,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void;
registerAudioDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
registerAudioDecoder(
activatableClassId: string,
inputSubtype: string,
outputSubtype: string,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void;
registerAudioEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
registerAudioEncoder(
activatableClassId: string,
inputSubtype: string,
outputSubtype: string,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void;
registerVideoDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
registerVideoDecoder(
activatableClassId: string,
inputSubtype: string,
outputSubtype: string,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void;
registerVideoEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
registerVideoEncoder(
activatableClassId: string,
inputSubtype: string,
outputSubtype: string,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void
}
	declare export interface IVideoEffectsStatics {
videoStabilization: string
} 
	declare export class VideoEffects  {
static videoStabilization: string
}
	declare module 'Playlists' {
        declare export  class PlaylistFormat {
  constructor(...args: empty): mixed;
static +windowsMedia: Class<PlaylistFormat__windowsMedia> & PlaylistFormat__windowsMedia & 0;// 0
static +zune: Class<PlaylistFormat__zune> & PlaylistFormat__zune & 1;// 1
static +m3u: Class<PlaylistFormat__m3u> & PlaylistFormat__m3u & 2;// 2

}

declare class PlaylistFormat__windowsMedia mixins PlaylistFormat {}
declare class PlaylistFormat__zune mixins PlaylistFormat {}
declare class PlaylistFormat__m3u mixins PlaylistFormat {}

	declare export interface IPlaylist {
files: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Storage.StorageFile>,
saveAsync(): Windows$Windows$Foundation.IAsyncAction,
saveAsAsync(
saveLocation: Windows$Windows$Storage.IStorageFolder,
desiredName: string,
option: Windows$Windows$Storage.NameCollisionOption): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
saveAsAsync(
saveLocation: Windows$Windows$Storage.IStorageFolder,
desiredName: string,
option: Windows$Windows$Storage.NameCollisionOption,
playlistFormat: Windows$Windows$Media.Playlists.PlaylistFormat): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>
} 
	declare export interface IPlaylistStatics {
loadAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Media.Playlists.Playlist>
} 
	declare export class Playlist mixins undefined.IPlaylist {
files: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Storage.StorageFile>;
saveAsync(): Windows$Windows$Foundation.IAsyncAction;
saveAsAsync(
saveLocation: Windows$Windows$Storage.IStorageFolder,
desiredName: string,
option: Windows$Windows$Storage.NameCollisionOption): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
saveAsAsync(
saveLocation: Windows$Windows$Storage.IStorageFolder,
desiredName: string,
option: Windows$Windows$Storage.NameCollisionOption,
playlistFormat: Windows$Windows$Media.Playlists.PlaylistFormat): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
static loadAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Media.Playlists.Playlist>
}
    }

	declare module 'PlayTo' {
        declare export interface IPlayToSource {
connection: Windows$Windows$Media.PlayTo.PlayToConnection,
next: Windows$Windows$Media.PlayTo.PlayToSource,
playNext(): void
} 
	declare export class PlayToConnection mixins undefined.IPlayToConnection {
state: Windows$Windows$Media.PlayTo.PlayToConnectionState;
onstatechanged: any;
ontransferred: any;
onerror: any
}
	declare export class PlayToSource mixins undefined.IPlayToSource {
connection: Windows$Windows$Media.PlayTo.PlayToConnection;
next: Windows$Windows$Media.PlayTo.PlayToSource;
playNext(): void
}
	declare export  class PlayToConnectionState {
  constructor(...args: empty): mixed;
static +disconnected: Class<PlayToConnectionState__disconnected> & PlayToConnectionState__disconnected & 0;// 0
static +connected: Class<PlayToConnectionState__connected> & PlayToConnectionState__connected & 1;// 1
static +rendering: Class<PlayToConnectionState__rendering> & PlayToConnectionState__rendering & 2;// 2

}

declare class PlayToConnectionState__disconnected mixins PlayToConnectionState {}
declare class PlayToConnectionState__connected mixins PlayToConnectionState {}
declare class PlayToConnectionState__rendering mixins PlayToConnectionState {}

	declare export interface IPlayToConnectionStateChangedEventArgs {
currentState: Windows$Windows$Media.PlayTo.PlayToConnectionState,
previousState: Windows$Windows$Media.PlayTo.PlayToConnectionState
} 
	declare export class PlayToConnectionStateChangedEventArgs mixins undefined.IPlayToConnectionStateChangedEventArgs {
currentState: Windows$Windows$Media.PlayTo.PlayToConnectionState;
previousState: Windows$Windows$Media.PlayTo.PlayToConnectionState
}
	declare export interface IPlayToConnectionTransferredEventArgs {
currentSource: Windows$Windows$Media.PlayTo.PlayToSource,
previousSource: Windows$Windows$Media.PlayTo.PlayToSource
} 
	declare export class PlayToConnectionTransferredEventArgs mixins undefined.IPlayToConnectionTransferredEventArgs {
currentSource: Windows$Windows$Media.PlayTo.PlayToSource;
previousSource: Windows$Windows$Media.PlayTo.PlayToSource
}
	declare export  class PlayToConnectionError {
  constructor(...args: empty): mixed;
static +none: Class<PlayToConnectionError__none> & PlayToConnectionError__none & 0;// 0
static +deviceNotResponding: Class<PlayToConnectionError__deviceNotResponding> & PlayToConnectionError__deviceNotResponding & 1;// 1
static +deviceError: Class<PlayToConnectionError__deviceError> & PlayToConnectionError__deviceError & 2;// 2
static +deviceLocked: Class<PlayToConnectionError__deviceLocked> & PlayToConnectionError__deviceLocked & 3;// 3

}

declare class PlayToConnectionError__none mixins PlayToConnectionError {}
declare class PlayToConnectionError__deviceNotResponding mixins PlayToConnectionError {}
declare class PlayToConnectionError__deviceError mixins PlayToConnectionError {}
declare class PlayToConnectionError__deviceLocked mixins PlayToConnectionError {}

	declare export interface IPlayToConnectionErrorEventArgs {
code: Windows$Windows$Media.PlayTo.PlayToConnectionError,
message: string
} 
	declare export class PlayToConnectionErrorEventArgs mixins undefined.IPlayToConnectionErrorEventArgs {
code: Windows$Windows$Media.PlayTo.PlayToConnectionError;
message: string
}
	declare export interface IPlayToConnection {
state: Windows$Windows$Media.PlayTo.PlayToConnectionState,
onstatechanged: any,
ontransferred: any,
onerror: any
} 
	declare export interface ISourceChangeRequestedEventArgs {
album: string,
author: string,
date: Date,
description: string,
genre: string,
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>,
rating: number,
stream: Windows$Windows$Storage.Streams.IRandomAccessStreamWithContentType,
thumbnail: Windows$Windows$Storage.Streams.IRandomAccessStreamReference,
title: string
} 
	declare export class SourceChangeRequestedEventArgs mixins undefined.ISourceChangeRequestedEventArgs {
album: string;
author: string;
date: Date;
description: string;
genre: string;
properties: Windows$Windows$Foundation.Collections.IMapView<string, any>;
rating: number;
stream: Windows$Windows$Storage.Streams.IRandomAccessStreamWithContentType;
thumbnail: Windows$Windows$Storage.Streams.IRandomAccessStreamReference;
title: string
}
	declare export interface IPlaybackRateChangeRequestedEventArgs {
rate: number
} 
	declare export class PlaybackRateChangeRequestedEventArgs mixins undefined.IPlaybackRateChangeRequestedEventArgs {
rate: number
}
	declare export interface ICurrentTimeChangeRequestedEventArgs {
time: number
} 
	declare export class CurrentTimeChangeRequestedEventArgs mixins undefined.ICurrentTimeChangeRequestedEventArgs {
time: number
}
	declare export interface IMuteChangeRequestedEventArgs {
mute: boolean
} 
	declare export class MuteChangeRequestedEventArgs mixins undefined.IMuteChangeRequestedEventArgs {
mute: boolean
}
	declare export interface IVolumeChangeRequestedEventArgs {
volume: number
} 
	declare export class VolumeChangeRequestedEventArgs mixins undefined.IVolumeChangeRequestedEventArgs {
volume: number
}
	declare export interface IPlayToReceiver {
friendlyName: string,
properties: Windows$Windows$Foundation.Collections.IPropertySet,
supportsAudio: boolean,
supportsImage: boolean,
supportsVideo: boolean,
onplayrequested: any,
onpauserequested: any,
onsourcechangerequested: any,
onplaybackratechangerequested: any,
oncurrenttimechangerequested: any,
onmutechangerequested: any,
onvolumechangerequested: any,
ontimeupdaterequested: any,
onstoprequested: any,
notifyVolumeChange(volume: number, mute: boolean): void,
notifyRateChange(rate: number): void,
notifyLoadedMetadata(): void,
notifyTimeUpdate(currentTime: number): void,
notifyDurationChange(duration: number): void,
notifySeeking(): void,
notifySeeked(): void,
notifyPaused(): void,
notifyPlaying(): void,
notifyEnded(): void,
notifyError(): void,
notifyStopped(): void,
startAsync(): Windows$Windows$Foundation.IAsyncAction,
stopAsync(): Windows$Windows$Foundation.IAsyncAction
} 
	declare export class PlayToReceiver mixins undefined.IPlayToReceiver {
friendlyName: string;
properties: Windows$Windows$Foundation.Collections.IPropertySet;
supportsAudio: boolean;
supportsImage: boolean;
supportsVideo: boolean;
onplayrequested: any;
onpauserequested: any;
onsourcechangerequested: any;
onplaybackratechangerequested: any;
oncurrenttimechangerequested: any;
onmutechangerequested: any;
onvolumechangerequested: any;
ontimeupdaterequested: any;
onstoprequested: any;
notifyVolumeChange(volume: number, mute: boolean): void;
notifyRateChange(rate: number): void;
notifyLoadedMetadata(): void;
notifyTimeUpdate(currentTime: number): void;
notifyDurationChange(duration: number): void;
notifySeeking(): void;
notifySeeked(): void;
notifyPaused(): void;
notifyPlaying(): void;
notifyEnded(): void;
notifyError(): void;
notifyStopped(): void;
startAsync(): Windows$Windows$Foundation.IAsyncAction;
stopAsync(): Windows$Windows$Foundation.IAsyncAction
}
	declare export interface IPlayToSourceSelectedEventArgs {
friendlyName: string,
icon: Windows$Windows$Storage.Streams.IRandomAccessStreamWithContentType,
supportsAudio: boolean,
supportsImage: boolean,
supportsVideo: boolean
} 
	declare export class PlayToSourceSelectedEventArgs mixins undefined.IPlayToSourceSelectedEventArgs {
friendlyName: string;
icon: Windows$Windows$Storage.Streams.IRandomAccessStreamWithContentType;
supportsAudio: boolean;
supportsImage: boolean;
supportsVideo: boolean
}
	declare export interface IPlayToSourceDeferral {
complete(): void
} 
	declare export class PlayToSourceDeferral mixins undefined.IPlayToSourceDeferral {
complete(): void
}
	declare export interface IPlayToSourceRequest {
deadline: Date,
displayErrorString(errorString: string): void,
getDeferral(): Windows$Windows$Media.PlayTo.PlayToSourceDeferral,
setSource(value: Windows$Windows$Media.PlayTo.PlayToSource): void
} 
	declare export class PlayToSourceRequest mixins undefined.IPlayToSourceRequest {
deadline: Date;
displayErrorString(errorString: string): void;
getDeferral(): Windows$Windows$Media.PlayTo.PlayToSourceDeferral;
setSource(value: Windows$Windows$Media.PlayTo.PlayToSource): void
}
	declare export interface IPlayToSourceRequestedEventArgs {
sourceRequest: Windows$Windows$Media.PlayTo.PlayToSourceRequest
} 
	declare export class PlayToSourceRequestedEventArgs mixins undefined.IPlayToSourceRequestedEventArgs {
sourceRequest: Windows$Windows$Media.PlayTo.PlayToSourceRequest
}
	declare export interface IPlayToManager {
defaultSourceSelection: boolean,
onsourcerequested: any,
onsourceselected: any
} 
	declare export class PlayToManager mixins undefined.IPlayToManager {
defaultSourceSelection: boolean;
onsourcerequested: any;
onsourceselected: any;
static getForCurrentView(): Windows$Windows$Media.PlayTo.PlayToManager;
static showPlayToUI(): void
}
	declare export interface IPlayToManagerStatics {
getForCurrentView(): Windows$Windows$Media.PlayTo.PlayToManager,
showPlayToUI(): void
} 
    }

	declare module 'MediaProperties' {
        declare export interface IMediaRatio {
denominator: number,
numerator: number
} 
	declare export class MediaRatio mixins undefined.IMediaRatio {
denominator: number;
numerator: number
}
	declare export class MediaPropertySet mixins undefined.IMap<string, any>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>> {
size: number;
lookup(key: string): any;
hasKey(key: string): boolean;
getView(): Windows$Windows$Foundation.Collections.IMapView<string, any>;
insert(key: string, value: any): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>
}
	declare export interface IMediaEncodingProperties {
properties: Windows$Windows$Media.MediaProperties.MediaPropertySet,
subtype: string,
type: string
} 
	declare export type IAudioEncodingProperties = {
bitrate: number,
bitsPerSample: number,
channelCount: number,
sampleRate: number
} & undefined.IMediaEncodingProperties

	declare export class AudioEncodingProperties mixins undefined.IAudioEncodingProperties, undefined.IMediaEncodingProperties {
bitrate: number;
bitsPerSample: number;
channelCount: number;
sampleRate: number;
properties: Windows$Windows$Media.MediaProperties.MediaPropertySet;
subtype: string;
type: string
}
	declare export type IVideoEncodingProperties = {
bitrate: number,
frameRate: Windows$Windows$Media.MediaProperties.MediaRatio,
height: number,
pixelAspectRatio: Windows$Windows$Media.MediaProperties.MediaRatio,
width: number
} & undefined.IMediaEncodingProperties

	declare export class VideoEncodingProperties mixins undefined.IVideoEncodingProperties, undefined.IMediaEncodingProperties {
bitrate: number;
frameRate: Windows$Windows$Media.MediaProperties.MediaRatio;
height: number;
pixelAspectRatio: Windows$Windows$Media.MediaProperties.MediaRatio;
width: number;
properties: Windows$Windows$Media.MediaProperties.MediaPropertySet;
subtype: string;
type: string
}
	declare export type IImageEncodingProperties = {
height: number,
width: number
} & undefined.IMediaEncodingProperties

	declare export interface IImageEncodingPropertiesStatics {
createJpeg(): Windows$Windows$Media.MediaProperties.ImageEncodingProperties,
createPng(): Windows$Windows$Media.MediaProperties.ImageEncodingProperties,
createJpegXR(): Windows$Windows$Media.MediaProperties.ImageEncodingProperties
} 
	declare export class ImageEncodingProperties mixins undefined.IImageEncodingProperties, undefined.IMediaEncodingProperties {
height: number;
width: number;
properties: Windows$Windows$Media.MediaProperties.MediaPropertySet;
subtype: string;
type: string;
static createJpeg(): Windows$Windows$Media.MediaProperties.ImageEncodingProperties;
static createPng(): Windows$Windows$Media.MediaProperties.ImageEncodingProperties;
static createJpegXR(): Windows$Windows$Media.MediaProperties.ImageEncodingProperties
}
	declare export type IContainerEncodingProperties = {} & undefined.IMediaEncodingProperties

	declare export class ContainerEncodingProperties mixins undefined.IContainerEncodingProperties, undefined.IMediaEncodingProperties {
properties: Windows$Windows$Media.MediaProperties.MediaPropertySet;
subtype: string;
type: string
}
	declare export  class AudioEncodingQuality {
  constructor(...args: empty): mixed;
static +auto: Class<AudioEncodingQuality__auto> & AudioEncodingQuality__auto & 0;// 0
static +high: Class<AudioEncodingQuality__high> & AudioEncodingQuality__high & 1;// 1
static +medium: Class<AudioEncodingQuality__medium> & AudioEncodingQuality__medium & 2;// 2
static +low: Class<AudioEncodingQuality__low> & AudioEncodingQuality__low & 3;// 3

}

declare class AudioEncodingQuality__auto mixins AudioEncodingQuality {}
declare class AudioEncodingQuality__high mixins AudioEncodingQuality {}
declare class AudioEncodingQuality__medium mixins AudioEncodingQuality {}
declare class AudioEncodingQuality__low mixins AudioEncodingQuality {}

	declare export  class VideoEncodingQuality {
  constructor(...args: empty): mixed;
static +auto: Class<VideoEncodingQuality__auto> & VideoEncodingQuality__auto & 0;// 0
static +hD1080p: Class<VideoEncodingQuality__hD1080p> & VideoEncodingQuality__hD1080p & 1;// 1
static +hD720p: Class<VideoEncodingQuality__hD720p> & VideoEncodingQuality__hD720p & 2;// 2
static +wvga: Class<VideoEncodingQuality__wvga> & VideoEncodingQuality__wvga & 3;// 3
static +ntsc: Class<VideoEncodingQuality__ntsc> & VideoEncodingQuality__ntsc & 4;// 4
static +pal: Class<VideoEncodingQuality__pal> & VideoEncodingQuality__pal & 5;// 5
static +vga: Class<VideoEncodingQuality__vga> & VideoEncodingQuality__vga & 6;// 6
static +qvga: Class<VideoEncodingQuality__qvga> & VideoEncodingQuality__qvga & 7;// 7

}

declare class VideoEncodingQuality__auto mixins VideoEncodingQuality {}
declare class VideoEncodingQuality__hD1080p mixins VideoEncodingQuality {}
declare class VideoEncodingQuality__hD720p mixins VideoEncodingQuality {}
declare class VideoEncodingQuality__wvga mixins VideoEncodingQuality {}
declare class VideoEncodingQuality__ntsc mixins VideoEncodingQuality {}
declare class VideoEncodingQuality__pal mixins VideoEncodingQuality {}
declare class VideoEncodingQuality__vga mixins VideoEncodingQuality {}
declare class VideoEncodingQuality__qvga mixins VideoEncodingQuality {}

	declare export interface IMediaEncodingProfileStatics {
createM4a(
quality: Windows$Windows$Media.MediaProperties.AudioEncodingQuality): Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
createMp3(
quality: Windows$Windows$Media.MediaProperties.AudioEncodingQuality): Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
createWma(
quality: Windows$Windows$Media.MediaProperties.AudioEncodingQuality): Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
createMp4(
quality: Windows$Windows$Media.MediaProperties.VideoEncodingQuality): Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
createWmv(
quality: Windows$Windows$Media.MediaProperties.VideoEncodingQuality): Windows$Windows$Media.MediaProperties.MediaEncodingProfile,
createFromFileAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Media.MediaProperties.MediaEncodingProfile>,
createFromStreamAsync(
stream: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Media.MediaProperties.MediaEncodingProfile>
} 
	declare export class MediaEncodingProfile mixins undefined.IMediaEncodingProfile {
audio: Windows$Windows$Media.MediaProperties.AudioEncodingProperties;
container: Windows$Windows$Media.MediaProperties.ContainerEncodingProperties;
video: Windows$Windows$Media.MediaProperties.VideoEncodingProperties;
static createM4a(
quality: Windows$Windows$Media.MediaProperties.AudioEncodingQuality): Windows$Windows$Media.MediaProperties.MediaEncodingProfile;
static createMp3(
quality: Windows$Windows$Media.MediaProperties.AudioEncodingQuality): Windows$Windows$Media.MediaProperties.MediaEncodingProfile;
static createWma(
quality: Windows$Windows$Media.MediaProperties.AudioEncodingQuality): Windows$Windows$Media.MediaProperties.MediaEncodingProfile;
static createMp4(
quality: Windows$Windows$Media.MediaProperties.VideoEncodingQuality): Windows$Windows$Media.MediaProperties.MediaEncodingProfile;
static createWmv(
quality: Windows$Windows$Media.MediaProperties.VideoEncodingQuality): Windows$Windows$Media.MediaProperties.MediaEncodingProfile;
static createFromFileAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Media.MediaProperties.MediaEncodingProfile>;
static createFromStreamAsync(
stream: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Media.MediaProperties.MediaEncodingProfile>
}
	declare export interface IMediaEncodingProfile {
audio: Windows$Windows$Media.MediaProperties.AudioEncodingProperties,
container: Windows$Windows$Media.MediaProperties.ContainerEncodingProperties,
video: Windows$Windows$Media.MediaProperties.VideoEncodingProperties
} 
    }

	declare module 'Protection' {
        declare export class MediaProtectionManager mixins undefined.IMediaProtectionManager {
properties: Windows$Windows$Foundation.Collections.IPropertySet;
onservicerequested: any;
onrebootneeded: any;
oncomponentloadfailed: any
}
	declare export class ServiceRequestedEventArgs mixins undefined.IServiceRequestedEventArgs {
completion: Windows$Windows$Media.Protection.MediaProtectionServiceCompletion;
request: Windows$Windows$Media.Protection.IMediaProtectionServiceRequest
}
	declare export class ComponentLoadFailedEventArgs mixins undefined.IComponentLoadFailedEventArgs {
completion: Windows$Windows$Media.Protection.MediaProtectionServiceCompletion;
information: Windows$Windows$Media.Protection.RevocationAndRenewalInformation
}
	declare export class MediaProtectionServiceCompletion mixins undefined.IMediaProtectionServiceCompletion {
complete(success: boolean): void
}
	declare export class RevocationAndRenewalInformation mixins undefined.IRevocationAndRenewalInformation {
items: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Media.Protection.RevocationAndRenewalItem>
}
	declare export class RevocationAndRenewalItem mixins undefined.IRevocationAndRenewalItem {
headerHash: string;
name: string;
publicKeyHash: string;
reasons: Windows$Windows$Media.Protection.RevocationAndRenewalReasons;
renewalId: string
}
	declare export interface ServiceRequestedEventHandler {
(sender: Windows$Windows$Media.Protection.MediaProtectionManager, e: Windows$Windows$Media.Protection.ServiceRequestedEventArgs): void
} 
	declare export interface RebootNeededEventHandler {
(sender: Windows$Windows$Media.Protection.MediaProtectionManager): void
} 
	declare export interface ComponentLoadFailedEventHandler {
(sender: Windows$Windows$Media.Protection.MediaProtectionManager, e: Windows$Windows$Media.Protection.ComponentLoadFailedEventArgs): void
} 
	declare export interface IMediaProtectionManager {
properties: Windows$Windows$Foundation.Collections.IPropertySet,
onservicerequested: any,
onrebootneeded: any,
oncomponentloadfailed: any
} 
	declare export interface IMediaProtectionServiceCompletion {
complete(success: boolean): void
} 
	declare export interface IServiceRequestedEventArgs {
completion: Windows$Windows$Media.Protection.MediaProtectionServiceCompletion,
request: Windows$Windows$Media.Protection.IMediaProtectionServiceRequest
} 
	declare export interface IMediaProtectionServiceRequest {
protectionSystem: string,
type: string
} 
	declare export interface IComponentLoadFailedEventArgs {
completion: Windows$Windows$Media.Protection.MediaProtectionServiceCompletion,
information: Windows$Windows$Media.Protection.RevocationAndRenewalInformation
} 
	declare export interface IRevocationAndRenewalInformation {
items: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Media.Protection.RevocationAndRenewalItem>
} 
	declare export  class RevocationAndRenewalReasons {
  constructor(...args: empty): mixed;
static +userModeComponentLoad: Class<RevocationAndRenewalReasons__userModeComponentLoad> & RevocationAndRenewalReasons__userModeComponentLoad & 0;// 0
static +kernelModeComponentLoad: Class<RevocationAndRenewalReasons__kernelModeComponentLoad> & RevocationAndRenewalReasons__kernelModeComponentLoad & 1;// 1
static +appComponent: Class<RevocationAndRenewalReasons__appComponent> & RevocationAndRenewalReasons__appComponent & 2;// 2
static +globalRevocationListLoadFailed: Class<RevocationAndRenewalReasons__globalRevocationListLoadFailed> & RevocationAndRenewalReasons__globalRevocationListLoadFailed & 3;// 3
static +invalidGlobalRevocationListSignature: Class<RevocationAndRenewalReasons__invalidGlobalRevocationListSignature> & RevocationAndRenewalReasons__invalidGlobalRevocationListSignature & 4;// 4
static +globalRevocationListAbsent: Class<RevocationAndRenewalReasons__globalRevocationListAbsent> & RevocationAndRenewalReasons__globalRevocationListAbsent & 5;// 5
static +componentRevoked: Class<RevocationAndRenewalReasons__componentRevoked> & RevocationAndRenewalReasons__componentRevoked & 6;// 6
static +invalidComponentCertificateExtendedKeyUse: Class<RevocationAndRenewalReasons__invalidComponentCertificateExtendedKeyUse> & RevocationAndRenewalReasons__invalidComponentCertificateExtendedKeyUse & 7;// 7
static +componentCertificateRevoked: Class<RevocationAndRenewalReasons__componentCertificateRevoked> & RevocationAndRenewalReasons__componentCertificateRevoked & 8;// 8
static +invalidComponentCertificateRoot: Class<RevocationAndRenewalReasons__invalidComponentCertificateRoot> & RevocationAndRenewalReasons__invalidComponentCertificateRoot & 9;// 9
static +componentHighSecurityCertificateRevoked: Class<RevocationAndRenewalReasons__componentHighSecurityCertificateRevoked> & RevocationAndRenewalReasons__componentHighSecurityCertificateRevoked & 10;// 10
static +componentLowSecurityCertificateRevoked: Class<RevocationAndRenewalReasons__componentLowSecurityCertificateRevoked> & RevocationAndRenewalReasons__componentLowSecurityCertificateRevoked & 11;// 11
static +bootDriverVerificationFailed: Class<RevocationAndRenewalReasons__bootDriverVerificationFailed> & RevocationAndRenewalReasons__bootDriverVerificationFailed & 12;// 12
static +componentSignedWithTestCertificate: Class<RevocationAndRenewalReasons__componentSignedWithTestCertificate> & RevocationAndRenewalReasons__componentSignedWithTestCertificate & 13;// 13
static +encryptionFailure: Class<RevocationAndRenewalReasons__encryptionFailure> & RevocationAndRenewalReasons__encryptionFailure & 14;// 14

}

declare class RevocationAndRenewalReasons__userModeComponentLoad mixins RevocationAndRenewalReasons {}
declare class RevocationAndRenewalReasons__kernelModeComponentLoad mixins RevocationAndRenewalReasons {}
declare class RevocationAndRenewalReasons__appComponent mixins RevocationAndRenewalReasons {}
declare class RevocationAndRenewalReasons__globalRevocationListLoadFailed mixins RevocationAndRenewalReasons {}
declare class RevocationAndRenewalReasons__invalidGlobalRevocationListSignature mixins RevocationAndRenewalReasons {}
declare class RevocationAndRenewalReasons__globalRevocationListAbsent mixins RevocationAndRenewalReasons {}
declare class RevocationAndRenewalReasons__componentRevoked mixins RevocationAndRenewalReasons {}
declare class RevocationAndRenewalReasons__invalidComponentCertificateExtendedKeyUse mixins RevocationAndRenewalReasons {}
declare class RevocationAndRenewalReasons__componentCertificateRevoked mixins RevocationAndRenewalReasons {}
declare class RevocationAndRenewalReasons__invalidComponentCertificateRoot mixins RevocationAndRenewalReasons {}
declare class RevocationAndRenewalReasons__componentHighSecurityCertificateRevoked mixins RevocationAndRenewalReasons {}
declare class RevocationAndRenewalReasons__componentLowSecurityCertificateRevoked mixins RevocationAndRenewalReasons {}
declare class RevocationAndRenewalReasons__bootDriverVerificationFailed mixins RevocationAndRenewalReasons {}
declare class RevocationAndRenewalReasons__componentSignedWithTestCertificate mixins RevocationAndRenewalReasons {}
declare class RevocationAndRenewalReasons__encryptionFailure mixins RevocationAndRenewalReasons {}

	declare export interface IRevocationAndRenewalItem {
headerHash: string,
name: string,
publicKeyHash: string,
reasons: Windows$Windows$Media.Protection.RevocationAndRenewalReasons,
renewalId: string
} 
	declare export class ComponentRenewal  {
static renewSystemComponentsAsync(
information: Windows$Windows$Media.Protection.RevocationAndRenewalInformation): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Media.Protection.RenewalStatus, number>
}
	declare export  class RenewalStatus {
  constructor(...args: empty): mixed;
static +notStarted: Class<RenewalStatus__notStarted> & RenewalStatus__notStarted & 0;// 0
static +updatesInProgress: Class<RenewalStatus__updatesInProgress> & RenewalStatus__updatesInProgress & 1;// 1
static +userCancelled: Class<RenewalStatus__userCancelled> & RenewalStatus__userCancelled & 2;// 2
static +appComponentsMayNeedUpdating: Class<RenewalStatus__appComponentsMayNeedUpdating> & RenewalStatus__appComponentsMayNeedUpdating & 3;// 3
static +noComponentsFound: Class<RenewalStatus__noComponentsFound> & RenewalStatus__noComponentsFound & 4;// 4

}

declare class RenewalStatus__notStarted mixins RenewalStatus {}
declare class RenewalStatus__updatesInProgress mixins RenewalStatus {}
declare class RenewalStatus__userCancelled mixins RenewalStatus {}
declare class RenewalStatus__appComponentsMayNeedUpdating mixins RenewalStatus {}
declare class RenewalStatus__noComponentsFound mixins RenewalStatus {}

	declare export interface IComponentRenewalStatics {
renewSystemComponentsAsync(
information: Windows$Windows$Media.Protection.RevocationAndRenewalInformation): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Media.Protection.RenewalStatus, number>
} 
    }

	declare module 'Transcoding' {
        declare export  class TranscodeFailureReason {
  constructor(...args: empty): mixed;
static +none: Class<TranscodeFailureReason__none> & TranscodeFailureReason__none & 0;// 0
static +unknown: Class<TranscodeFailureReason__unknown> & TranscodeFailureReason__unknown & 1;// 1
static +invalidProfile: Class<TranscodeFailureReason__invalidProfile> & TranscodeFailureReason__invalidProfile & 2;// 2
static +codecNotFound: Class<TranscodeFailureReason__codecNotFound> & TranscodeFailureReason__codecNotFound & 3;// 3

}

declare class TranscodeFailureReason__none mixins TranscodeFailureReason {}
declare class TranscodeFailureReason__unknown mixins TranscodeFailureReason {}
declare class TranscodeFailureReason__invalidProfile mixins TranscodeFailureReason {}
declare class TranscodeFailureReason__codecNotFound mixins TranscodeFailureReason {}

	declare export interface IMediaTranscoder {
alwaysReencode: boolean,
hardwareAccelerationEnabled: boolean,
trimStartTime: number,
trimStopTime: number,
addAudioEffect(activatableClassId: string): void,
addAudioEffect(
activatableClassId: string,
effectRequired: boolean,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void,
addVideoEffect(activatableClassId: string): void,
addVideoEffect(
activatableClassId: string,
effectRequired: boolean,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void,
clearEffects(): void,
prepareFileTranscodeAsync(
source: Windows$Windows$Storage.IStorageFile,
destination: Windows$Windows$Storage.IStorageFile,
profile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Media.Transcoding.PrepareTranscodeResult>,
prepareStreamTranscodeAsync(
source: Windows$Windows$Storage.Streams.IRandomAccessStream,
destination: Windows$Windows$Storage.Streams.IRandomAccessStream,
profile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Media.Transcoding.PrepareTranscodeResult>
} 
	declare export class PrepareTranscodeResult mixins undefined.IPrepareTranscodeResult {
canTranscode: boolean;
failureReason: Windows$Windows$Media.Transcoding.TranscodeFailureReason;
transcodeAsync(): Windows$Windows$Foundation.IAsyncActionWithProgress<number>
}
	declare export interface IPrepareTranscodeResult {
canTranscode: boolean,
failureReason: Windows$Windows$Media.Transcoding.TranscodeFailureReason,
transcodeAsync(): Windows$Windows$Foundation.IAsyncActionWithProgress<number>
} 
	declare export class MediaTranscoder mixins undefined.IMediaTranscoder {
alwaysReencode: boolean;
hardwareAccelerationEnabled: boolean;
trimStartTime: number;
trimStopTime: number;
addAudioEffect(activatableClassId: string): void;
addAudioEffect(
activatableClassId: string,
effectRequired: boolean,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void;
addVideoEffect(activatableClassId: string): void;
addVideoEffect(
activatableClassId: string,
effectRequired: boolean,
configuration: Windows$Windows$Foundation.Collections.IPropertySet): void;
clearEffects(): void;
prepareFileTranscodeAsync(
source: Windows$Windows$Storage.IStorageFile,
destination: Windows$Windows$Storage.IStorageFile,
profile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Media.Transcoding.PrepareTranscodeResult>;
prepareStreamTranscodeAsync(
source: Windows$Windows$Storage.Streams.IRandomAccessStream,
destination: Windows$Windows$Storage.Streams.IRandomAccessStream,
profile: Windows$Windows$Media.MediaProperties.MediaEncodingProfile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Media.Transcoding.PrepareTranscodeResult>
}
    }

    }


declare module 'Networking' {
        declare module 'NetworkOperators' {
        declare export  class DataClasses {
  constructor(...args: empty): mixed;
static +none: Class<DataClasses__none> & DataClasses__none & 0;// 0
static +gprs: Class<DataClasses__gprs> & DataClasses__gprs & 1;// 1
static +edge: Class<DataClasses__edge> & DataClasses__edge & 2;// 2
static +umts: Class<DataClasses__umts> & DataClasses__umts & 3;// 3
static +hsdpa: Class<DataClasses__hsdpa> & DataClasses__hsdpa & 4;// 4
static +hsupa: Class<DataClasses__hsupa> & DataClasses__hsupa & 5;// 5
static +lteAdvanced: Class<DataClasses__lteAdvanced> & DataClasses__lteAdvanced & 6;// 6
static +cdma1xRtt: Class<DataClasses__cdma1xRtt> & DataClasses__cdma1xRtt & 7;// 7
static +cdma1xEvdo: Class<DataClasses__cdma1xEvdo> & DataClasses__cdma1xEvdo & 8;// 8
static +cdma1xEvdoRevA: Class<DataClasses__cdma1xEvdoRevA> & DataClasses__cdma1xEvdoRevA & 9;// 9
static +cdma1xEvdv: Class<DataClasses__cdma1xEvdv> & DataClasses__cdma1xEvdv & 10;// 10
static +cdma3xRtt: Class<DataClasses__cdma3xRtt> & DataClasses__cdma3xRtt & 11;// 11
static +cdma1xEvdoRevB: Class<DataClasses__cdma1xEvdoRevB> & DataClasses__cdma1xEvdoRevB & 12;// 12
static +cdmaUmb: Class<DataClasses__cdmaUmb> & DataClasses__cdmaUmb & 13;// 13
static +custom: Class<DataClasses__custom> & DataClasses__custom & 14;// 14

}

declare class DataClasses__none mixins DataClasses {}
declare class DataClasses__gprs mixins DataClasses {}
declare class DataClasses__edge mixins DataClasses {}
declare class DataClasses__umts mixins DataClasses {}
declare class DataClasses__hsdpa mixins DataClasses {}
declare class DataClasses__hsupa mixins DataClasses {}
declare class DataClasses__lteAdvanced mixins DataClasses {}
declare class DataClasses__cdma1xRtt mixins DataClasses {}
declare class DataClasses__cdma1xEvdo mixins DataClasses {}
declare class DataClasses__cdma1xEvdoRevA mixins DataClasses {}
declare class DataClasses__cdma1xEvdv mixins DataClasses {}
declare class DataClasses__cdma3xRtt mixins DataClasses {}
declare class DataClasses__cdma1xEvdoRevB mixins DataClasses {}
declare class DataClasses__cdmaUmb mixins DataClasses {}
declare class DataClasses__custom mixins DataClasses {}

	declare export  class MobileBroadbandDeviceType {
  constructor(...args: empty): mixed;
static +unknown: Class<MobileBroadbandDeviceType__unknown> & MobileBroadbandDeviceType__unknown & 0;// 0
static +embedded: Class<MobileBroadbandDeviceType__embedded> & MobileBroadbandDeviceType__embedded & 1;// 1
static +removable: Class<MobileBroadbandDeviceType__removable> & MobileBroadbandDeviceType__removable & 2;// 2
static +remote: Class<MobileBroadbandDeviceType__remote> & MobileBroadbandDeviceType__remote & 3;// 3

}

declare class MobileBroadbandDeviceType__unknown mixins MobileBroadbandDeviceType {}
declare class MobileBroadbandDeviceType__embedded mixins MobileBroadbandDeviceType {}
declare class MobileBroadbandDeviceType__removable mixins MobileBroadbandDeviceType {}
declare class MobileBroadbandDeviceType__remote mixins MobileBroadbandDeviceType {}

	declare export  class NetworkDeviceStatus {
  constructor(...args: empty): mixed;
static +deviceNotReady: Class<NetworkDeviceStatus__deviceNotReady> & NetworkDeviceStatus__deviceNotReady & 0;// 0
static +deviceReady: Class<NetworkDeviceStatus__deviceReady> & NetworkDeviceStatus__deviceReady & 1;// 1
static +simNotInserted: Class<NetworkDeviceStatus__simNotInserted> & NetworkDeviceStatus__simNotInserted & 2;// 2
static +badSim: Class<NetworkDeviceStatus__badSim> & NetworkDeviceStatus__badSim & 3;// 3
static +deviceHardwareFailure: Class<NetworkDeviceStatus__deviceHardwareFailure> & NetworkDeviceStatus__deviceHardwareFailure & 4;// 4
static +accountNotActivated: Class<NetworkDeviceStatus__accountNotActivated> & NetworkDeviceStatus__accountNotActivated & 5;// 5
static +deviceLocked: Class<NetworkDeviceStatus__deviceLocked> & NetworkDeviceStatus__deviceLocked & 6;// 6
static +deviceBlocked: Class<NetworkDeviceStatus__deviceBlocked> & NetworkDeviceStatus__deviceBlocked & 7;// 7

}

declare class NetworkDeviceStatus__deviceNotReady mixins NetworkDeviceStatus {}
declare class NetworkDeviceStatus__deviceReady mixins NetworkDeviceStatus {}
declare class NetworkDeviceStatus__simNotInserted mixins NetworkDeviceStatus {}
declare class NetworkDeviceStatus__badSim mixins NetworkDeviceStatus {}
declare class NetworkDeviceStatus__deviceHardwareFailure mixins NetworkDeviceStatus {}
declare class NetworkDeviceStatus__accountNotActivated mixins NetworkDeviceStatus {}
declare class NetworkDeviceStatus__deviceLocked mixins NetworkDeviceStatus {}
declare class NetworkDeviceStatus__deviceBlocked mixins NetworkDeviceStatus {}

	declare export  class NetworkRegistrationState {
  constructor(...args: empty): mixed;
static +none: Class<NetworkRegistrationState__none> & NetworkRegistrationState__none & 0;// 0
static +deregistered: Class<NetworkRegistrationState__deregistered> & NetworkRegistrationState__deregistered & 1;// 1
static +searching: Class<NetworkRegistrationState__searching> & NetworkRegistrationState__searching & 2;// 2
static +home: Class<NetworkRegistrationState__home> & NetworkRegistrationState__home & 3;// 3
static +roaming: Class<NetworkRegistrationState__roaming> & NetworkRegistrationState__roaming & 4;// 4
static +partner: Class<NetworkRegistrationState__partner> & NetworkRegistrationState__partner & 5;// 5
static +denied: Class<NetworkRegistrationState__denied> & NetworkRegistrationState__denied & 6;// 6

}

declare class NetworkRegistrationState__none mixins NetworkRegistrationState {}
declare class NetworkRegistrationState__deregistered mixins NetworkRegistrationState {}
declare class NetworkRegistrationState__searching mixins NetworkRegistrationState {}
declare class NetworkRegistrationState__home mixins NetworkRegistrationState {}
declare class NetworkRegistrationState__roaming mixins NetworkRegistrationState {}
declare class NetworkRegistrationState__partner mixins NetworkRegistrationState {}
declare class NetworkRegistrationState__denied mixins NetworkRegistrationState {}

	declare export  class MobileBroadbandRadioState {
  constructor(...args: empty): mixed;
static +off: Class<MobileBroadbandRadioState__off> & MobileBroadbandRadioState__off & 0;// 0
static +on: Class<MobileBroadbandRadioState__on> & MobileBroadbandRadioState__on & 1;// 1

}

declare class MobileBroadbandRadioState__off mixins MobileBroadbandRadioState {}
declare class MobileBroadbandRadioState__on mixins MobileBroadbandRadioState {}

	declare export  class NetworkOperatorEventMessageType {
  constructor(...args: empty): mixed;
static +gsm: Class<NetworkOperatorEventMessageType__gsm> & NetworkOperatorEventMessageType__gsm & 0;// 0
static +cdma: Class<NetworkOperatorEventMessageType__cdma> & NetworkOperatorEventMessageType__cdma & 1;// 1
static +ussd: Class<NetworkOperatorEventMessageType__ussd> & NetworkOperatorEventMessageType__ussd & 2;// 2
static +dataPlanThresholdReached: Class<NetworkOperatorEventMessageType__dataPlanThresholdReached> & NetworkOperatorEventMessageType__dataPlanThresholdReached & 3;// 3
static +dataPlanReset: Class<NetworkOperatorEventMessageType__dataPlanReset> & NetworkOperatorEventMessageType__dataPlanReset & 4;// 4
static +dataPlanDeleted: Class<NetworkOperatorEventMessageType__dataPlanDeleted> & NetworkOperatorEventMessageType__dataPlanDeleted & 5;// 5
static +profileConnected: Class<NetworkOperatorEventMessageType__profileConnected> & NetworkOperatorEventMessageType__profileConnected & 6;// 6
static +profileDisconnected: Class<NetworkOperatorEventMessageType__profileDisconnected> & NetworkOperatorEventMessageType__profileDisconnected & 7;// 7
static +registeredRoaming: Class<NetworkOperatorEventMessageType__registeredRoaming> & NetworkOperatorEventMessageType__registeredRoaming & 8;// 8
static +registeredHome: Class<NetworkOperatorEventMessageType__registeredHome> & NetworkOperatorEventMessageType__registeredHome & 9;// 9

}

declare class NetworkOperatorEventMessageType__gsm mixins NetworkOperatorEventMessageType {}
declare class NetworkOperatorEventMessageType__cdma mixins NetworkOperatorEventMessageType {}
declare class NetworkOperatorEventMessageType__ussd mixins NetworkOperatorEventMessageType {}
declare class NetworkOperatorEventMessageType__dataPlanThresholdReached mixins NetworkOperatorEventMessageType {}
declare class NetworkOperatorEventMessageType__dataPlanReset mixins NetworkOperatorEventMessageType {}
declare class NetworkOperatorEventMessageType__dataPlanDeleted mixins NetworkOperatorEventMessageType {}
declare class NetworkOperatorEventMessageType__profileConnected mixins NetworkOperatorEventMessageType {}
declare class NetworkOperatorEventMessageType__profileDisconnected mixins NetworkOperatorEventMessageType {}
declare class NetworkOperatorEventMessageType__registeredRoaming mixins NetworkOperatorEventMessageType {}
declare class NetworkOperatorEventMessageType__registeredHome mixins NetworkOperatorEventMessageType {}

	declare export  class MobileBroadbandAccountWatcherStatus {
  constructor(...args: empty): mixed;
static +created: Class<MobileBroadbandAccountWatcherStatus__created> & MobileBroadbandAccountWatcherStatus__created & 0;// 0
static +started: Class<MobileBroadbandAccountWatcherStatus__started> & MobileBroadbandAccountWatcherStatus__started & 1;// 1
static +enumerationCompleted: Class<MobileBroadbandAccountWatcherStatus__enumerationCompleted> & MobileBroadbandAccountWatcherStatus__enumerationCompleted & 2;// 2
static +stopped: Class<MobileBroadbandAccountWatcherStatus__stopped> & MobileBroadbandAccountWatcherStatus__stopped & 3;// 3
static +aborted: Class<MobileBroadbandAccountWatcherStatus__aborted> & MobileBroadbandAccountWatcherStatus__aborted & 4;// 4

}

declare class MobileBroadbandAccountWatcherStatus__created mixins MobileBroadbandAccountWatcherStatus {}
declare class MobileBroadbandAccountWatcherStatus__started mixins MobileBroadbandAccountWatcherStatus {}
declare class MobileBroadbandAccountWatcherStatus__enumerationCompleted mixins MobileBroadbandAccountWatcherStatus {}
declare class MobileBroadbandAccountWatcherStatus__stopped mixins MobileBroadbandAccountWatcherStatus {}
declare class MobileBroadbandAccountWatcherStatus__aborted mixins MobileBroadbandAccountWatcherStatus {}

	declare export interface IMobileBroadbandAccountStatics {
availableNetworkAccountIds: Windows$Windows$Foundation.Collections.IVectorView<string>,
createFromNetworkAccountId(
networkAccountId: string): Windows$Windows$Networking.NetworkOperators.MobileBroadbandAccount
} 
	declare export class MobileBroadbandAccount mixins undefined.IMobileBroadbandAccount {
currentDeviceInformation: Windows$Windows$Networking.NetworkOperators.MobileBroadbandDeviceInformation;
currentNetwork: Windows$Windows$Networking.NetworkOperators.MobileBroadbandNetwork;
networkAccountId: string;
serviceProviderGuid: string;
serviceProviderName: string;
static availableNetworkAccountIds: Windows$Windows$Foundation.Collections.IVectorView<string>;
static createFromNetworkAccountId(
networkAccountId: string): Windows$Windows$Networking.NetworkOperators.MobileBroadbandAccount
}
	declare export interface IMobileBroadbandAccount {
currentDeviceInformation: Windows$Windows$Networking.NetworkOperators.MobileBroadbandDeviceInformation,
currentNetwork: Windows$Windows$Networking.NetworkOperators.MobileBroadbandNetwork,
networkAccountId: string,
serviceProviderGuid: string,
serviceProviderName: string
} 
	declare export class MobileBroadbandNetwork mixins undefined.IMobileBroadbandNetwork {
accessPointName: string;
activationNetworkError: number;
networkAdapter: Windows$Windows$Networking.Connectivity.NetworkAdapter;
networkRegistrationState: Windows$Windows$Networking.NetworkOperators.NetworkRegistrationState;
packetAttachNetworkError: number;
registeredDataClass: Windows$Windows$Networking.NetworkOperators.DataClasses;
registeredProviderId: string;
registeredProviderName: string;
registrationNetworkError: number;
showConnectionUI(): void
}
	declare export class MobileBroadbandDeviceInformation mixins undefined.IMobileBroadbandDeviceInformation {
cellularClass: Windows$Windows$Devices.Sms.CellularClass;
currentRadioState: Windows$Windows$Networking.NetworkOperators.MobileBroadbandRadioState;
customDataClass: string;
dataClasses: Windows$Windows$Networking.NetworkOperators.DataClasses;
deviceId: string;
deviceType: Windows$Windows$Networking.NetworkOperators.MobileBroadbandDeviceType;
firmwareInformation: string;
manufacturer: string;
mobileEquipmentId: string;
model: string;
networkDeviceStatus: Windows$Windows$Networking.NetworkOperators.NetworkDeviceStatus;
simIccId: string;
subscriberId: string;
telephoneNumbers: Windows$Windows$Foundation.Collections.IVectorView<string>
}
	declare export interface IMobileBroadbandDeviceInformation {
cellularClass: Windows$Windows$Devices.Sms.CellularClass,
currentRadioState: Windows$Windows$Networking.NetworkOperators.MobileBroadbandRadioState,
customDataClass: string,
dataClasses: Windows$Windows$Networking.NetworkOperators.DataClasses,
deviceId: string,
deviceType: Windows$Windows$Networking.NetworkOperators.MobileBroadbandDeviceType,
firmwareInformation: string,
manufacturer: string,
mobileEquipmentId: string,
model: string,
networkDeviceStatus: Windows$Windows$Networking.NetworkOperators.NetworkDeviceStatus,
simIccId: string,
subscriberId: string,
telephoneNumbers: Windows$Windows$Foundation.Collections.IVectorView<string>
} 
	declare export interface IMobileBroadbandNetwork {
accessPointName: string,
activationNetworkError: number,
networkAdapter: Windows$Windows$Networking.Connectivity.NetworkAdapter,
networkRegistrationState: Windows$Windows$Networking.NetworkOperators.NetworkRegistrationState,
packetAttachNetworkError: number,
registeredDataClass: Windows$Windows$Networking.NetworkOperators.DataClasses,
registeredProviderId: string,
registeredProviderName: string,
registrationNetworkError: number,
showConnectionUI(): void
} 
	declare export interface INetworkOperatorNotificationEventDetails {
encodingType: number,
message: string,
networkAccountId: string,
notificationType: Windows$Windows$Networking.NetworkOperators.NetworkOperatorEventMessageType,
ruleId: string,
smsMessage: Windows$Windows$Devices.Sms.ISmsMessage
} 
	declare export class NetworkOperatorNotificationEventDetails mixins undefined.INetworkOperatorNotificationEventDetails {
encodingType: number;
message: string;
networkAccountId: string;
notificationType: Windows$Windows$Networking.NetworkOperators.NetworkOperatorEventMessageType;
ruleId: string;
smsMessage: Windows$Windows$Devices.Sms.ISmsMessage
}
	declare export interface IMobileBroadbandAccountEventArgs {
networkAccountId: string
} 
	declare export class MobileBroadbandAccountEventArgs mixins undefined.IMobileBroadbandAccountEventArgs {
networkAccountId: string
}
	declare export interface IMobileBroadbandAccountUpdatedEventArgs {
hasDeviceInformationChanged: boolean,
hasNetworkChanged: boolean,
networkAccountId: string
} 
	declare export class MobileBroadbandAccountUpdatedEventArgs mixins undefined.IMobileBroadbandAccountUpdatedEventArgs {
hasDeviceInformationChanged: boolean;
hasNetworkChanged: boolean;
networkAccountId: string
}
	declare export interface IMobileBroadbandAccountWatcher {
status: Windows$Windows$Networking.NetworkOperators.MobileBroadbandAccountWatcherStatus,
onaccountadded: any,
onaccountupdated: any,
onaccountremoved: any,
onenumerationcompleted: any,
onstopped: any,
start(): void,
stop(): void
} 
	declare export class MobileBroadbandAccountWatcher mixins undefined.IMobileBroadbandAccountWatcher {
status: Windows$Windows$Networking.NetworkOperators.MobileBroadbandAccountWatcherStatus;
onaccountadded: any;
onaccountupdated: any;
onaccountremoved: any;
onenumerationcompleted: any;
onstopped: any;
start(): void;
stop(): void
}
	declare export interface IHotspotAuthenticationEventDetails {
eventToken: string
} 
	declare export class HotspotAuthenticationEventDetails mixins undefined.IHotspotAuthenticationEventDetails {
eventToken: string
}
	declare export interface IHotspotAuthenticationContextStatics {
tryGetAuthenticationContext(
evenToken: string): {
context: Windows$Windows$Networking.NetworkOperators.HotspotAuthenticationContext,
isValid: boolean
}
} 
	declare export class HotspotAuthenticationContext mixins undefined.IHotspotAuthenticationContext {
authenticationUrl: Windows$Windows$Foundation.Uri;
networkAdapter: Windows$Windows$Networking.Connectivity.NetworkAdapter;
redirectMessageUrl: Windows$Windows$Foundation.Uri;
redirectMessageXml: Windows$Windows$Data.Xml.Dom.XmlDocument;
wirelessNetworkId: Uint8Array;
issueCredentials(
userName: string,
password: string,
extraParameters: string,
markAsManualConnectOnFailure: boolean): void;
abortAuthentication(markAsManual: boolean): void;
skipAuthentication(): void;
triggerAttentionRequired(packageRelativeApplicationId: string, applicationParameters: string): void;
static tryGetAuthenticationContext(
evenToken: string): {
context: Windows$Windows$Networking.NetworkOperators.HotspotAuthenticationContext,
isValid: boolean
}
}
	declare export interface IHotspotAuthenticationContext {
authenticationUrl: Windows$Windows$Foundation.Uri,
networkAdapter: Windows$Windows$Networking.Connectivity.NetworkAdapter,
redirectMessageUrl: Windows$Windows$Foundation.Uri,
redirectMessageXml: Windows$Windows$Data.Xml.Dom.XmlDocument,
wirelessNetworkId: Uint8Array,
issueCredentials(
userName: string,
password: string,
extraParameters: string,
markAsManualConnectOnFailure: boolean): void,
abortAuthentication(markAsManual: boolean): void,
skipAuthentication(): void,
triggerAttentionRequired(packageRelativeApplicationId: string, applicationParameters: string): void
} 
	declare export  class ProfileMediaType {
  constructor(...args: empty): mixed;
static +wlan: Class<ProfileMediaType__wlan> & ProfileMediaType__wlan & 0;// 0
static +wwan: Class<ProfileMediaType__wwan> & ProfileMediaType__wwan & 1;// 1

}

declare class ProfileMediaType__wlan mixins ProfileMediaType {}
declare class ProfileMediaType__wwan mixins ProfileMediaType {}

	declare export interface IProvisionFromXmlDocumentResults {
allElementsProvisioned: boolean,
provisionResultsXml: string
} 
	declare export class ProvisionFromXmlDocumentResults mixins undefined.IProvisionFromXmlDocumentResults {
allElementsProvisioned: boolean;
provisionResultsXml: string
}
	declare export interface ProfileUsage {
usageInMegabytes: number,
lastSyncTime: Date
} 
	declare export interface IProvisionedProfile {
updateCost(value: Windows$Windows$Networking.Connectivity.NetworkCostType): void,
updateUsage(value: Windows$Windows$Networking.NetworkOperators.ProfileUsage): void
} 
	declare export class ProvisionedProfile mixins undefined.IProvisionedProfile {
updateCost(value: Windows$Windows$Networking.Connectivity.NetworkCostType): void;
updateUsage(value: Windows$Windows$Networking.NetworkOperators.ProfileUsage): void
}
	declare export interface IProvisioningAgent {
provisionFromXmlDocumentAsync(
provisioningXmlDocument: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.NetworkOperators.ProvisionFromXmlDocumentResults>,
getProvisionedProfile(
mediaType: Windows$Windows$Networking.NetworkOperators.ProfileMediaType,
profileName: string): Windows$Windows$Networking.NetworkOperators.ProvisionedProfile
} 
	declare export interface IProvisioningAgentStaticMethods {
createFromNetworkAccountId(
networkAccountId: string): Windows$Windows$Networking.NetworkOperators.ProvisioningAgent
} 
	declare export class ProvisioningAgent mixins undefined.IProvisioningAgent {
provisionFromXmlDocumentAsync(
provisioningXmlDocument: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.NetworkOperators.ProvisionFromXmlDocumentResults>;
getProvisionedProfile(
mediaType: Windows$Windows$Networking.NetworkOperators.ProfileMediaType,
profileName: string): Windows$Windows$Networking.NetworkOperators.ProvisionedProfile;
static createFromNetworkAccountId(
networkAccountId: string): Windows$Windows$Networking.NetworkOperators.ProvisioningAgent
}
	declare export  class UssdResultCode {
  constructor(...args: empty): mixed;
static +noActionRequired: Class<UssdResultCode__noActionRequired> & UssdResultCode__noActionRequired & 0;// 0
static +actionRequired: Class<UssdResultCode__actionRequired> & UssdResultCode__actionRequired & 1;// 1
static +terminated: Class<UssdResultCode__terminated> & UssdResultCode__terminated & 2;// 2
static +otherLocalClient: Class<UssdResultCode__otherLocalClient> & UssdResultCode__otherLocalClient & 3;// 3
static +operationNotSupported: Class<UssdResultCode__operationNotSupported> & UssdResultCode__operationNotSupported & 4;// 4
static +networkTimeout: Class<UssdResultCode__networkTimeout> & UssdResultCode__networkTimeout & 5;// 5

}

declare class UssdResultCode__noActionRequired mixins UssdResultCode {}
declare class UssdResultCode__actionRequired mixins UssdResultCode {}
declare class UssdResultCode__terminated mixins UssdResultCode {}
declare class UssdResultCode__otherLocalClient mixins UssdResultCode {}
declare class UssdResultCode__operationNotSupported mixins UssdResultCode {}
declare class UssdResultCode__networkTimeout mixins UssdResultCode {}

	declare export interface IUssdMessage {
dataCodingScheme: number,
payloadAsText: string,
getPayload(): Uint8Array,
setPayload(value: Uint8Array): void
} 
	declare export interface IUssdMessageFactory {
createMessage(messageText: string): Windows$Windows$Networking.NetworkOperators.UssdMessage
} 
	declare export class UssdMessage mixins undefined.IUssdMessage {
constructor(messageText: string): this;
dataCodingScheme: number;
payloadAsText: string;
getPayload(): Uint8Array;
setPayload(value: Uint8Array): void
}
	declare export interface IUssdReply {
message: Windows$Windows$Networking.NetworkOperators.UssdMessage,
resultCode: Windows$Windows$Networking.NetworkOperators.UssdResultCode
} 
	declare export class UssdReply mixins undefined.IUssdReply {
message: Windows$Windows$Networking.NetworkOperators.UssdMessage;
resultCode: Windows$Windows$Networking.NetworkOperators.UssdResultCode
}
	declare export interface IUssdSession {
sendMessageAndGetReplyAsync(
message: Windows$Windows$Networking.NetworkOperators.UssdMessage): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.NetworkOperators.UssdReply>,
close(): void
} 
	declare export interface IUssdSessionStatics {
createFromNetworkAccountId(
networkAccountId: string): Windows$Windows$Networking.NetworkOperators.UssdSession,
createFromNetworkInterfaceId(
networkInterfaceId: string): Windows$Windows$Networking.NetworkOperators.UssdSession
} 
	declare export class UssdSession mixins undefined.IUssdSession {
sendMessageAndGetReplyAsync(
message: Windows$Windows$Networking.NetworkOperators.UssdMessage): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.NetworkOperators.UssdReply>;
close(): void;
static createFromNetworkAccountId(
networkAccountId: string): Windows$Windows$Networking.NetworkOperators.UssdSession;
static createFromNetworkInterfaceId(
networkInterfaceId: string): Windows$Windows$Networking.NetworkOperators.UssdSession
}
    }

	declare module 'BackgroundTransfer' {
        declare export  class BackgroundTransferStatus {
  constructor(...args: empty): mixed;
static +idle: Class<BackgroundTransferStatus__idle> & BackgroundTransferStatus__idle & 0;// 0
static +running: Class<BackgroundTransferStatus__running> & BackgroundTransferStatus__running & 1;// 1
static +pausedByApplication: Class<BackgroundTransferStatus__pausedByApplication> & BackgroundTransferStatus__pausedByApplication & 2;// 2
static +pausedCostedNetwork: Class<BackgroundTransferStatus__pausedCostedNetwork> & BackgroundTransferStatus__pausedCostedNetwork & 3;// 3
static +pausedNoNetwork: Class<BackgroundTransferStatus__pausedNoNetwork> & BackgroundTransferStatus__pausedNoNetwork & 4;// 4
static +completed: Class<BackgroundTransferStatus__completed> & BackgroundTransferStatus__completed & 5;// 5
static +canceled: Class<BackgroundTransferStatus__canceled> & BackgroundTransferStatus__canceled & 6;// 6
static +error: Class<BackgroundTransferStatus__error> & BackgroundTransferStatus__error & 7;// 7

}

declare class BackgroundTransferStatus__idle mixins BackgroundTransferStatus {}
declare class BackgroundTransferStatus__running mixins BackgroundTransferStatus {}
declare class BackgroundTransferStatus__pausedByApplication mixins BackgroundTransferStatus {}
declare class BackgroundTransferStatus__pausedCostedNetwork mixins BackgroundTransferStatus {}
declare class BackgroundTransferStatus__pausedNoNetwork mixins BackgroundTransferStatus {}
declare class BackgroundTransferStatus__completed mixins BackgroundTransferStatus {}
declare class BackgroundTransferStatus__canceled mixins BackgroundTransferStatus {}
declare class BackgroundTransferStatus__error mixins BackgroundTransferStatus {}

	declare export  class BackgroundTransferCostPolicy {
  constructor(...args: empty): mixed;
static +default: Class<BackgroundTransferCostPolicy__default> & BackgroundTransferCostPolicy__default & 0;// 0
static +unrestrictedOnly: Class<BackgroundTransferCostPolicy__unrestrictedOnly> & BackgroundTransferCostPolicy__unrestrictedOnly & 1;// 1
static +always: Class<BackgroundTransferCostPolicy__always> & BackgroundTransferCostPolicy__always & 2;// 2

}

declare class BackgroundTransferCostPolicy__default mixins BackgroundTransferCostPolicy {}
declare class BackgroundTransferCostPolicy__unrestrictedOnly mixins BackgroundTransferCostPolicy {}
declare class BackgroundTransferCostPolicy__always mixins BackgroundTransferCostPolicy {}

	declare export interface BackgroundDownloadProgress {
bytesReceived: number,
totalBytesToReceive: number,
status: Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferStatus,
hasResponseChanged: boolean,
hasRestarted: boolean
} 
	declare export interface BackgroundUploadProgress {
bytesReceived: number,
bytesSent: number,
totalBytesToReceive: number,
totalBytesToSend: number,
status: Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferStatus,
hasResponseChanged: boolean,
hasRestarted: boolean
} 
	declare export interface IBackgroundTransferBase {
costPolicy: Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferCostPolicy,
group: string,
method: string,
proxyCredential: Windows$Windows$Security.Credentials.PasswordCredential,
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential,
setRequestHeader(headerName: string, headerValue: string): void
} 
	declare export type IBackgroundDownloader = {
createDownload(
uri: Windows$Windows$Foundation.Uri,
resultFile: Windows$Windows$Storage.IStorageFile): Windows$Windows$Networking.BackgroundTransfer.DownloadOperation,
createDownload(
uri: Windows$Windows$Foundation.Uri,
resultFile: Windows$Windows$Storage.IStorageFile,
requestBodyFile: Windows$Windows$Storage.IStorageFile): Windows$Windows$Networking.BackgroundTransfer.DownloadOperation,
createDownloadAsync(
uri: Windows$Windows$Foundation.Uri,
resultFile: Windows$Windows$Storage.IStorageFile,
requestBodyStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.BackgroundTransfer.DownloadOperation>
} & undefined.IBackgroundTransferBase

	declare export class DownloadOperation mixins undefined.IDownloadOperation, undefined.IBackgroundTransferOperation {
progress: Windows$Windows$Networking.BackgroundTransfer.BackgroundDownloadProgress;
resultFile: Windows$Windows$Storage.IStorageFile;
costPolicy: Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
group: string;
guid: string;
method: string;
requestedUri: Windows$Windows$Foundation.Uri;
startAsync(
): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Networking.BackgroundTransfer.DownloadOperation, Windows$Windows$Networking.BackgroundTransfer.DownloadOperation>;
attachAsync(
): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Networking.BackgroundTransfer.DownloadOperation, Windows$Windows$Networking.BackgroundTransfer.DownloadOperation>;
pause(): void;
resume(): void;
getResultStreamAt(position: number): Windows$Windows$Storage.Streams.IInputStream;
getResponseInformation(): Windows$Windows$Networking.BackgroundTransfer.ResponseInformation
}
	declare export type IBackgroundUploader = {
createUpload(
uri: Windows$Windows$Foundation.Uri,
sourceFile: Windows$Windows$Storage.IStorageFile): Windows$Windows$Networking.BackgroundTransfer.UploadOperation,
createUploadFromStreamAsync(
uri: Windows$Windows$Foundation.Uri,
sourceStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.BackgroundTransfer.UploadOperation>,
createUploadAsync(
uri: Windows$Windows$Foundation.Uri,
parts: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferContentPart>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.BackgroundTransfer.UploadOperation>,
createUploadAsync(
uri: Windows$Windows$Foundation.Uri,
parts: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferContentPart>,
subType: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.BackgroundTransfer.UploadOperation>,
createUploadAsync(
uri: Windows$Windows$Foundation.Uri,
parts: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferContentPart>,
subType: string,
boundary: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.BackgroundTransfer.UploadOperation>
} & undefined.IBackgroundTransferBase

	declare export class UploadOperation mixins undefined.IUploadOperation, undefined.IBackgroundTransferOperation {
progress: Windows$Windows$Networking.BackgroundTransfer.BackgroundUploadProgress;
sourceFile: Windows$Windows$Storage.IStorageFile;
costPolicy: Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
group: string;
guid: string;
method: string;
requestedUri: Windows$Windows$Foundation.Uri;
startAsync(
): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Networking.BackgroundTransfer.UploadOperation, Windows$Windows$Networking.BackgroundTransfer.UploadOperation>;
attachAsync(
): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Networking.BackgroundTransfer.UploadOperation, Windows$Windows$Networking.BackgroundTransfer.UploadOperation>;
getResultStreamAt(position: number): Windows$Windows$Storage.Streams.IInputStream;
getResponseInformation(): Windows$Windows$Networking.BackgroundTransfer.ResponseInformation
}
	declare export class BackgroundTransferContentPart mixins undefined.IBackgroundTransferContentPart {
constructor(name: string): this;
constructor(name: string, fileName: string): this;
constructor(): this;
setHeader(headerName: string, headerValue: string): void;
setText(value: string): void;
setFile(value: Windows$Windows$Storage.IStorageFile): void
}
	declare export interface IBackgroundTransferOperation {
costPolicy: Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferCostPolicy,
group: string,
guid: string,
method: string,
requestedUri: Windows$Windows$Foundation.Uri,
getResultStreamAt(position: number): Windows$Windows$Storage.Streams.IInputStream,
getResponseInformation(): Windows$Windows$Networking.BackgroundTransfer.ResponseInformation
} 
	declare export class ResponseInformation mixins undefined.IResponseInformation {
actualUri: Windows$Windows$Foundation.Uri;
headers: Windows$Windows$Foundation.Collections.IMapView<string, string>;
isResumable: boolean;
statusCode: number
}
	declare export type IDownloadOperation = {
progress: Windows$Windows$Networking.BackgroundTransfer.BackgroundDownloadProgress,
resultFile: Windows$Windows$Storage.IStorageFile,
startAsync(
): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Networking.BackgroundTransfer.DownloadOperation, Windows$Windows$Networking.BackgroundTransfer.DownloadOperation>,
attachAsync(
): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Networking.BackgroundTransfer.DownloadOperation, Windows$Windows$Networking.BackgroundTransfer.DownloadOperation>,
pause(): void,
resume(): void
} & undefined.IBackgroundTransferOperation

	declare export type IUploadOperation = {
progress: Windows$Windows$Networking.BackgroundTransfer.BackgroundUploadProgress,
sourceFile: Windows$Windows$Storage.IStorageFile,
startAsync(
): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Networking.BackgroundTransfer.UploadOperation, Windows$Windows$Networking.BackgroundTransfer.UploadOperation>,
attachAsync(
): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Networking.BackgroundTransfer.UploadOperation, Windows$Windows$Networking.BackgroundTransfer.UploadOperation>
} & undefined.IBackgroundTransferOperation

	declare export interface IBackgroundDownloaderStaticMethods {
getCurrentDownloadsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.BackgroundTransfer.DownloadOperation>>,
getCurrentDownloadsAsync(
group: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.BackgroundTransfer.DownloadOperation>>
} 
	declare export interface IBackgroundUploaderStaticMethods {
getCurrentUploadsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.BackgroundTransfer.UploadOperation>>,
getCurrentUploadsAsync(
group: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.BackgroundTransfer.UploadOperation>>
} 
	declare export interface IResponseInformation {
actualUri: Windows$Windows$Foundation.Uri,
headers: Windows$Windows$Foundation.Collections.IMapView<string, string>,
isResumable: boolean,
statusCode: number
} 
	declare export interface IBackgroundTransferErrorStaticMethods {
getStatus(hresult: number): Windows$Windows$Web.WebErrorStatus
} 
	declare export interface IBackgroundTransferContentPart {
setHeader(headerName: string, headerValue: string): void,
setText(value: string): void,
setFile(value: Windows$Windows$Storage.IStorageFile): void
} 
	declare export interface IBackgroundTransferContentPartFactory {
createWithName(
name: string): Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferContentPart,
createWithNameAndFileName(
name: string,
fileName: string): Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferContentPart
} 
	declare export class BackgroundDownloader mixins undefined.IBackgroundDownloader, undefined.IBackgroundTransferBase {
costPolicy: Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
group: string;
method: string;
proxyCredential: Windows$Windows$Security.Credentials.PasswordCredential;
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential;
createDownload(
uri: Windows$Windows$Foundation.Uri,
resultFile: Windows$Windows$Storage.IStorageFile): Windows$Windows$Networking.BackgroundTransfer.DownloadOperation;
createDownload(
uri: Windows$Windows$Foundation.Uri,
resultFile: Windows$Windows$Storage.IStorageFile,
requestBodyFile: Windows$Windows$Storage.IStorageFile): Windows$Windows$Networking.BackgroundTransfer.DownloadOperation;
createDownloadAsync(
uri: Windows$Windows$Foundation.Uri,
resultFile: Windows$Windows$Storage.IStorageFile,
requestBodyStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.BackgroundTransfer.DownloadOperation>;
setRequestHeader(headerName: string, headerValue: string): void;
static getCurrentDownloadsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.BackgroundTransfer.DownloadOperation>>;
static getCurrentDownloadsAsync(
group: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.BackgroundTransfer.DownloadOperation>>
}
	declare export class BackgroundUploader mixins undefined.IBackgroundUploader, undefined.IBackgroundTransferBase {
costPolicy: Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
group: string;
method: string;
proxyCredential: Windows$Windows$Security.Credentials.PasswordCredential;
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential;
createUpload(
uri: Windows$Windows$Foundation.Uri,
sourceFile: Windows$Windows$Storage.IStorageFile): Windows$Windows$Networking.BackgroundTransfer.UploadOperation;
createUploadFromStreamAsync(
uri: Windows$Windows$Foundation.Uri,
sourceStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.BackgroundTransfer.UploadOperation>;
createUploadAsync(
uri: Windows$Windows$Foundation.Uri,
parts: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferContentPart>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.BackgroundTransfer.UploadOperation>;
createUploadAsync(
uri: Windows$Windows$Foundation.Uri,
parts: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferContentPart>,
subType: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.BackgroundTransfer.UploadOperation>;
createUploadAsync(
uri: Windows$Windows$Foundation.Uri,
parts: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Networking.BackgroundTransfer.BackgroundTransferContentPart>,
subType: string,
boundary: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.BackgroundTransfer.UploadOperation>;
setRequestHeader(headerName: string, headerValue: string): void;
static getCurrentUploadsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.BackgroundTransfer.UploadOperation>>;
static getCurrentUploadsAsync(
group: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.BackgroundTransfer.UploadOperation>>
}
	declare export class BackgroundTransferError  {
static getStatus(hresult: number): Windows$Windows$Web.WebErrorStatus
}
    }

	declare module 'Proximity' {
        declare export interface IProximityMessage {
data: Windows$Windows$Storage.Streams.IBuffer,
dataAsString: string,
messageType: string,
subscriptionId: number
} 
	declare export class ProximityMessage mixins undefined.IProximityMessage {
data: Windows$Windows$Storage.Streams.IBuffer;
dataAsString: string;
messageType: string;
subscriptionId: number
}
	declare export interface MessageReceivedHandler {
(sender: Windows$Windows$Networking.Proximity.ProximityDevice, message: Windows$Windows$Networking.Proximity.ProximityMessage): void
} 
	declare export class ProximityDevice mixins undefined.IProximityDevice {
bitsPerSecond: number;
deviceId: string;
maxMessageBytes: number;
subscribeForMessage(
messageType: string,
messageReceivedHandler: Windows$Windows$Networking.Proximity.MessageReceivedHandler): number;
publishMessage(messageType: string, message: string): number;
publishMessage(
messageType: string,
message: string,
messageTransmittedHandler: Windows$Windows$Networking.Proximity.MessageTransmittedHandler): number;
publishBinaryMessage(messageType: string, message: Windows$Windows$Storage.Streams.IBuffer): number;
publishBinaryMessage(
messageType: string,
message: Windows$Windows$Storage.Streams.IBuffer,
messageTransmittedHandler: Windows$Windows$Networking.Proximity.MessageTransmittedHandler): number;
publishUriMessage(message: Windows$Windows$Foundation.Uri): number;
publishUriMessage(
message: Windows$Windows$Foundation.Uri,
messageTransmittedHandler: Windows$Windows$Networking.Proximity.MessageTransmittedHandler): number;
stopSubscribingForMessage(subscriptionId: number): void;
stopPublishingMessage(messageId: number): void;
ondevicearrived: any;
ondevicedeparted: any;
static getDeviceSelector(): string;
static getDefault(): Windows$Windows$Networking.Proximity.ProximityDevice;
static fromId(
deviceInterfaceId: string): Windows$Windows$Networking.Proximity.ProximityDevice
}
	declare export interface MessageTransmittedHandler {
(sender: Windows$Windows$Networking.Proximity.ProximityDevice, messageId: number): void
} 
	declare export interface DeviceArrivedEventHandler {
(sender: Windows$Windows$Networking.Proximity.ProximityDevice): void
} 
	declare export interface DeviceDepartedEventHandler {
(sender: Windows$Windows$Networking.Proximity.ProximityDevice): void
} 
	declare export interface IProximityDevice {
bitsPerSecond: number,
deviceId: string,
maxMessageBytes: number,
subscribeForMessage(
messageType: string,
messageReceivedHandler: Windows$Windows$Networking.Proximity.MessageReceivedHandler): number,
publishMessage(messageType: string, message: string): number,
publishMessage(
messageType: string,
message: string,
messageTransmittedHandler: Windows$Windows$Networking.Proximity.MessageTransmittedHandler): number,
publishBinaryMessage(messageType: string, message: Windows$Windows$Storage.Streams.IBuffer): number,
publishBinaryMessage(
messageType: string,
message: Windows$Windows$Storage.Streams.IBuffer,
messageTransmittedHandler: Windows$Windows$Networking.Proximity.MessageTransmittedHandler): number,
publishUriMessage(message: Windows$Windows$Foundation.Uri): number,
publishUriMessage(
message: Windows$Windows$Foundation.Uri,
messageTransmittedHandler: Windows$Windows$Networking.Proximity.MessageTransmittedHandler): number,
stopSubscribingForMessage(subscriptionId: number): void,
stopPublishingMessage(messageId: number): void,
ondevicearrived: any,
ondevicedeparted: any
} 
	declare export interface IProximityDeviceStatics {
getDeviceSelector(): string,
getDefault(): Windows$Windows$Networking.Proximity.ProximityDevice,
fromId(
deviceInterfaceId: string): Windows$Windows$Networking.Proximity.ProximityDevice
} 
	declare export  class TriggeredConnectState {
  constructor(...args: empty): mixed;
static +peerFound: Class<TriggeredConnectState__peerFound> & TriggeredConnectState__peerFound & 0;// 0
static +listening: Class<TriggeredConnectState__listening> & TriggeredConnectState__listening & 1;// 1
static +connecting: Class<TriggeredConnectState__connecting> & TriggeredConnectState__connecting & 2;// 2
static +completed: Class<TriggeredConnectState__completed> & TriggeredConnectState__completed & 3;// 3
static +canceled: Class<TriggeredConnectState__canceled> & TriggeredConnectState__canceled & 4;// 4
static +failed: Class<TriggeredConnectState__failed> & TriggeredConnectState__failed & 5;// 5

}

declare class TriggeredConnectState__peerFound mixins TriggeredConnectState {}
declare class TriggeredConnectState__listening mixins TriggeredConnectState {}
declare class TriggeredConnectState__connecting mixins TriggeredConnectState {}
declare class TriggeredConnectState__completed mixins TriggeredConnectState {}
declare class TriggeredConnectState__canceled mixins TriggeredConnectState {}
declare class TriggeredConnectState__failed mixins TriggeredConnectState {}

	declare export interface ITriggeredConnectionStateChangedEventArgs {
id: number,
socket: Windows$Windows$Networking.Sockets.StreamSocket,
state: Windows$Windows$Networking.Proximity.TriggeredConnectState
} 
	declare export class TriggeredConnectionStateChangedEventArgs mixins undefined.ITriggeredConnectionStateChangedEventArgs {
id: number;
socket: Windows$Windows$Networking.Sockets.StreamSocket;
state: Windows$Windows$Networking.Proximity.TriggeredConnectState
}
	declare export interface IPeerInformation {
displayName: string
} 
	declare export class PeerInformation mixins undefined.IPeerInformation {
displayName: string
}
	declare export interface IConnectionRequestedEventArgs {
peerInformation: Windows$Windows$Networking.Proximity.PeerInformation
} 
	declare export class ConnectionRequestedEventArgs mixins undefined.IConnectionRequestedEventArgs {
peerInformation: Windows$Windows$Networking.Proximity.PeerInformation
}
	declare export  class PeerDiscoveryTypes {
  constructor(...args: empty): mixed;
static +none: Class<PeerDiscoveryTypes__none> & PeerDiscoveryTypes__none & 0;// 0
static +browse: Class<PeerDiscoveryTypes__browse> & PeerDiscoveryTypes__browse & 1;// 1
static +triggered: Class<PeerDiscoveryTypes__triggered> & PeerDiscoveryTypes__triggered & 2;// 2

}

declare class PeerDiscoveryTypes__none mixins PeerDiscoveryTypes {}
declare class PeerDiscoveryTypes__browse mixins PeerDiscoveryTypes {}
declare class PeerDiscoveryTypes__triggered mixins PeerDiscoveryTypes {}

	declare export interface IPeerFinderStatics {
allowBluetooth: boolean,
allowInfrastructure: boolean,
allowWiFiDirect: boolean,
alternateIdentities: Windows$Windows$Foundation.Collections.IMap<string, string>,
displayName: string,
supportedDiscoveryTypes: Windows$Windows$Networking.Proximity.PeerDiscoveryTypes,
start(): void,
start(peerMessage: string): void,
stop(): void,
ontriggeredconnectionstatechanged: any,
onconnectionrequested: any,
findAllPeersAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.Proximity.PeerInformation>>,
connectAsync(
peerInformation: Windows$Windows$Networking.Proximity.PeerInformation): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.Sockets.StreamSocket>
} 
	declare export class PeerFinder  {
static allowBluetooth: boolean;
static allowInfrastructure: boolean;
static allowWiFiDirect: boolean;
static alternateIdentities: Windows$Windows$Foundation.Collections.IMap<string, string>;
static displayName: string;
static supportedDiscoveryTypes: Windows$Windows$Networking.Proximity.PeerDiscoveryTypes;
static start(): void;
static start(peerMessage: string): void;
static stop(): void;
static ontriggeredconnectionstatechanged: any;
static onconnectionrequested: any;
static findAllPeersAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.Proximity.PeerInformation>>;
static connectAsync(
peerInformation: Windows$Windows$Networking.Proximity.PeerInformation): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.Sockets.StreamSocket>
}
    }

	declare module 'Sockets' {
        declare export  class ControlChannelTriggerStatus {
  constructor(...args: empty): mixed;
static +hardwareSlotRequested: Class<ControlChannelTriggerStatus__hardwareSlotRequested> & ControlChannelTriggerStatus__hardwareSlotRequested & 0;// 0
static +softwareSlotAllocated: Class<ControlChannelTriggerStatus__softwareSlotAllocated> & ControlChannelTriggerStatus__softwareSlotAllocated & 1;// 1
static +hardwareSlotAllocated: Class<ControlChannelTriggerStatus__hardwareSlotAllocated> & ControlChannelTriggerStatus__hardwareSlotAllocated & 2;// 2
static +policyError: Class<ControlChannelTriggerStatus__policyError> & ControlChannelTriggerStatus__policyError & 3;// 3
static +systemError: Class<ControlChannelTriggerStatus__systemError> & ControlChannelTriggerStatus__systemError & 4;// 4
static +transportDisconnected: Class<ControlChannelTriggerStatus__transportDisconnected> & ControlChannelTriggerStatus__transportDisconnected & 5;// 5
static +serviceUnavailable: Class<ControlChannelTriggerStatus__serviceUnavailable> & ControlChannelTriggerStatus__serviceUnavailable & 6;// 6

}

declare class ControlChannelTriggerStatus__hardwareSlotRequested mixins ControlChannelTriggerStatus {}
declare class ControlChannelTriggerStatus__softwareSlotAllocated mixins ControlChannelTriggerStatus {}
declare class ControlChannelTriggerStatus__hardwareSlotAllocated mixins ControlChannelTriggerStatus {}
declare class ControlChannelTriggerStatus__policyError mixins ControlChannelTriggerStatus {}
declare class ControlChannelTriggerStatus__systemError mixins ControlChannelTriggerStatus {}
declare class ControlChannelTriggerStatus__transportDisconnected mixins ControlChannelTriggerStatus {}
declare class ControlChannelTriggerStatus__serviceUnavailable mixins ControlChannelTriggerStatus {}

	declare export  class ControlChannelTriggerResourceType {
  constructor(...args: empty): mixed;
static +requestSoftwareSlot: Class<ControlChannelTriggerResourceType__requestSoftwareSlot> & ControlChannelTriggerResourceType__requestSoftwareSlot & 0;// 0
static +requestHardwareSlot: Class<ControlChannelTriggerResourceType__requestHardwareSlot> & ControlChannelTriggerResourceType__requestHardwareSlot & 1;// 1

}

declare class ControlChannelTriggerResourceType__requestSoftwareSlot mixins ControlChannelTriggerResourceType {}
declare class ControlChannelTriggerResourceType__requestHardwareSlot mixins ControlChannelTriggerResourceType {}

	declare export  class ControlChannelTriggerResetReason {
  constructor(...args: empty): mixed;
static +fastUserSwitched: Class<ControlChannelTriggerResetReason__fastUserSwitched> & ControlChannelTriggerResetReason__fastUserSwitched & 0;// 0
static +lowPowerExit: Class<ControlChannelTriggerResetReason__lowPowerExit> & ControlChannelTriggerResetReason__lowPowerExit & 1;// 1

}

declare class ControlChannelTriggerResetReason__fastUserSwitched mixins ControlChannelTriggerResetReason {}
declare class ControlChannelTriggerResetReason__lowPowerExit mixins ControlChannelTriggerResetReason {}

	declare export type IControlChannelTrigger = {
controlChannelTriggerId: string,
currentKeepAliveIntervalInMinutes: number,
keepAliveTrigger: Windows$Windows$ApplicationModel.Background.IBackgroundTrigger,
pushNotificationTrigger: Windows$Windows$ApplicationModel.Background.IBackgroundTrigger,
serverKeepAliveIntervalInMinutes: number,
transportObject: any,
usingTransport(transport: any): void,
waitForPushEnabled(): Windows$Windows$Networking.Sockets.ControlChannelTriggerStatus,
decreaseNetworkKeepAliveInterval(): void,
flushTransport(): void
} & undefined.IClosable

	declare export interface IControlChannelTriggerFactory {
createControlChannelTrigger(
channelId: string,
serverKeepAliveIntervalInMinutes: number): Windows$Windows$Networking.Sockets.ControlChannelTrigger,
createControlChannelTrigger(
channelId: string,
serverKeepAliveIntervalInMinutes: number,
resourceRequestType: Windows$Windows$Networking.Sockets.ControlChannelTriggerResourceType): Windows$Windows$Networking.Sockets.ControlChannelTrigger
} 
	declare export class ControlChannelTrigger mixins undefined.IControlChannelTrigger, undefined.IClosable {
constructor(channelId: string, serverKeepAliveIntervalInMinutes: number): this;
constructor(channelId: string, serverKeepAliveIntervalInMinutes: number, resourceRequestType: Windows$Windows$Networking.Sockets.ControlChannelTriggerResourceType): this;
controlChannelTriggerId: string;
currentKeepAliveIntervalInMinutes: number;
keepAliveTrigger: Windows$Windows$ApplicationModel.Background.IBackgroundTrigger;
pushNotificationTrigger: Windows$Windows$ApplicationModel.Background.IBackgroundTrigger;
serverKeepAliveIntervalInMinutes: number;
transportObject: any;
usingTransport(transport: any): void;
waitForPushEnabled(): Windows$Windows$Networking.Sockets.ControlChannelTriggerStatus;
decreaseNetworkKeepAliveInterval(): void;
flushTransport(): void;
dispose(): void;
close(): void
}
	declare export interface IControlChannelTriggerEventDetails {
controlChannelTrigger: Windows$Windows$Networking.Sockets.ControlChannelTrigger
} 
	declare export interface IControlChannelTriggerResetEventDetails {
hardwareSlotReset: boolean,
resetReason: Windows$Windows$Networking.Sockets.ControlChannelTriggerResetReason,
softwareSlotReset: boolean
} 
	declare export  class SocketMessageType {
  constructor(...args: empty): mixed;
static +binary: Class<SocketMessageType__binary> & SocketMessageType__binary & 0;// 0
static +utf8: Class<SocketMessageType__utf8> & SocketMessageType__utf8 & 1;// 1

}

declare class SocketMessageType__binary mixins SocketMessageType {}
declare class SocketMessageType__utf8 mixins SocketMessageType {}

	declare export  class SocketProtectionLevel {
  constructor(...args: empty): mixed;
static +plainSocket: Class<SocketProtectionLevel__plainSocket> & SocketProtectionLevel__plainSocket & 0;// 0
static +ssl: Class<SocketProtectionLevel__ssl> & SocketProtectionLevel__ssl & 1;// 1
static +sslAllowNullEncryption: Class<SocketProtectionLevel__sslAllowNullEncryption> & SocketProtectionLevel__sslAllowNullEncryption & 2;// 2

}

declare class SocketProtectionLevel__plainSocket mixins SocketProtectionLevel {}
declare class SocketProtectionLevel__ssl mixins SocketProtectionLevel {}
declare class SocketProtectionLevel__sslAllowNullEncryption mixins SocketProtectionLevel {}

	declare export  class SocketQualityOfService {
  constructor(...args: empty): mixed;
static +normal: Class<SocketQualityOfService__normal> & SocketQualityOfService__normal & 0;// 0
static +lowLatency: Class<SocketQualityOfService__lowLatency> & SocketQualityOfService__lowLatency & 1;// 1

}

declare class SocketQualityOfService__normal mixins SocketQualityOfService {}
declare class SocketQualityOfService__lowLatency mixins SocketQualityOfService {}

	declare export  class SocketErrorStatus {
  constructor(...args: empty): mixed;
static +unknown: Class<SocketErrorStatus__unknown> & SocketErrorStatus__unknown & 0;// 0
static +operationAborted: Class<SocketErrorStatus__operationAborted> & SocketErrorStatus__operationAborted & 1;// 1
static +httpInvalidServerResponse: Class<SocketErrorStatus__httpInvalidServerResponse> & SocketErrorStatus__httpInvalidServerResponse & 2;// 2
static +connectionTimedOut: Class<SocketErrorStatus__connectionTimedOut> & SocketErrorStatus__connectionTimedOut & 3;// 3
static +addressFamilyNotSupported: Class<SocketErrorStatus__addressFamilyNotSupported> & SocketErrorStatus__addressFamilyNotSupported & 4;// 4
static +socketTypeNotSupported: Class<SocketErrorStatus__socketTypeNotSupported> & SocketErrorStatus__socketTypeNotSupported & 5;// 5
static +hostNotFound: Class<SocketErrorStatus__hostNotFound> & SocketErrorStatus__hostNotFound & 6;// 6
static +noDataRecordOfRequestedType: Class<SocketErrorStatus__noDataRecordOfRequestedType> & SocketErrorStatus__noDataRecordOfRequestedType & 7;// 7
static +nonAuthoritativeHostNotFound: Class<SocketErrorStatus__nonAuthoritativeHostNotFound> & SocketErrorStatus__nonAuthoritativeHostNotFound & 8;// 8
static +classTypeNotFound: Class<SocketErrorStatus__classTypeNotFound> & SocketErrorStatus__classTypeNotFound & 9;// 9
static +addressAlreadyInUse: Class<SocketErrorStatus__addressAlreadyInUse> & SocketErrorStatus__addressAlreadyInUse & 10;// 10
static +cannotAssignRequestedAddress: Class<SocketErrorStatus__cannotAssignRequestedAddress> & SocketErrorStatus__cannotAssignRequestedAddress & 11;// 11
static +connectionRefused: Class<SocketErrorStatus__connectionRefused> & SocketErrorStatus__connectionRefused & 12;// 12
static +networkIsUnreachable: Class<SocketErrorStatus__networkIsUnreachable> & SocketErrorStatus__networkIsUnreachable & 13;// 13
static +unreachableHost: Class<SocketErrorStatus__unreachableHost> & SocketErrorStatus__unreachableHost & 14;// 14
static +networkIsDown: Class<SocketErrorStatus__networkIsDown> & SocketErrorStatus__networkIsDown & 15;// 15
static +networkDroppedConnectionOnReset: Class<SocketErrorStatus__networkDroppedConnectionOnReset> & SocketErrorStatus__networkDroppedConnectionOnReset & 16;// 16
static +softwareCausedConnectionAbort: Class<SocketErrorStatus__softwareCausedConnectionAbort> & SocketErrorStatus__softwareCausedConnectionAbort & 17;// 17
static +connectionResetByPeer: Class<SocketErrorStatus__connectionResetByPeer> & SocketErrorStatus__connectionResetByPeer & 18;// 18
static +hostIsDown: Class<SocketErrorStatus__hostIsDown> & SocketErrorStatus__hostIsDown & 19;// 19
static +noAddressesFound: Class<SocketErrorStatus__noAddressesFound> & SocketErrorStatus__noAddressesFound & 20;// 20
static +tooManyOpenFiles: Class<SocketErrorStatus__tooManyOpenFiles> & SocketErrorStatus__tooManyOpenFiles & 21;// 21
static +messageTooLong: Class<SocketErrorStatus__messageTooLong> & SocketErrorStatus__messageTooLong & 22;// 22
static +certificateExpired: Class<SocketErrorStatus__certificateExpired> & SocketErrorStatus__certificateExpired & 23;// 23
static +certificateUntrustedRoot: Class<SocketErrorStatus__certificateUntrustedRoot> & SocketErrorStatus__certificateUntrustedRoot & 24;// 24
static +certificateCommonNameIsIncorrect: Class<SocketErrorStatus__certificateCommonNameIsIncorrect> & SocketErrorStatus__certificateCommonNameIsIncorrect & 25;// 25
static +certificateWrongUsage: Class<SocketErrorStatus__certificateWrongUsage> & SocketErrorStatus__certificateWrongUsage & 26;// 26
static +certificateRevoked: Class<SocketErrorStatus__certificateRevoked> & SocketErrorStatus__certificateRevoked & 27;// 27
static +certificateNoRevocationCheck: Class<SocketErrorStatus__certificateNoRevocationCheck> & SocketErrorStatus__certificateNoRevocationCheck & 28;// 28
static +certificateRevocationServerOffline: Class<SocketErrorStatus__certificateRevocationServerOffline> & SocketErrorStatus__certificateRevocationServerOffline & 29;// 29
static +certificateIsInvalid: Class<SocketErrorStatus__certificateIsInvalid> & SocketErrorStatus__certificateIsInvalid & 30;// 30

}

declare class SocketErrorStatus__unknown mixins SocketErrorStatus {}
declare class SocketErrorStatus__operationAborted mixins SocketErrorStatus {}
declare class SocketErrorStatus__httpInvalidServerResponse mixins SocketErrorStatus {}
declare class SocketErrorStatus__connectionTimedOut mixins SocketErrorStatus {}
declare class SocketErrorStatus__addressFamilyNotSupported mixins SocketErrorStatus {}
declare class SocketErrorStatus__socketTypeNotSupported mixins SocketErrorStatus {}
declare class SocketErrorStatus__hostNotFound mixins SocketErrorStatus {}
declare class SocketErrorStatus__noDataRecordOfRequestedType mixins SocketErrorStatus {}
declare class SocketErrorStatus__nonAuthoritativeHostNotFound mixins SocketErrorStatus {}
declare class SocketErrorStatus__classTypeNotFound mixins SocketErrorStatus {}
declare class SocketErrorStatus__addressAlreadyInUse mixins SocketErrorStatus {}
declare class SocketErrorStatus__cannotAssignRequestedAddress mixins SocketErrorStatus {}
declare class SocketErrorStatus__connectionRefused mixins SocketErrorStatus {}
declare class SocketErrorStatus__networkIsUnreachable mixins SocketErrorStatus {}
declare class SocketErrorStatus__unreachableHost mixins SocketErrorStatus {}
declare class SocketErrorStatus__networkIsDown mixins SocketErrorStatus {}
declare class SocketErrorStatus__networkDroppedConnectionOnReset mixins SocketErrorStatus {}
declare class SocketErrorStatus__softwareCausedConnectionAbort mixins SocketErrorStatus {}
declare class SocketErrorStatus__connectionResetByPeer mixins SocketErrorStatus {}
declare class SocketErrorStatus__hostIsDown mixins SocketErrorStatus {}
declare class SocketErrorStatus__noAddressesFound mixins SocketErrorStatus {}
declare class SocketErrorStatus__tooManyOpenFiles mixins SocketErrorStatus {}
declare class SocketErrorStatus__messageTooLong mixins SocketErrorStatus {}
declare class SocketErrorStatus__certificateExpired mixins SocketErrorStatus {}
declare class SocketErrorStatus__certificateUntrustedRoot mixins SocketErrorStatus {}
declare class SocketErrorStatus__certificateCommonNameIsIncorrect mixins SocketErrorStatus {}
declare class SocketErrorStatus__certificateWrongUsage mixins SocketErrorStatus {}
declare class SocketErrorStatus__certificateRevoked mixins SocketErrorStatus {}
declare class SocketErrorStatus__certificateNoRevocationCheck mixins SocketErrorStatus {}
declare class SocketErrorStatus__certificateRevocationServerOffline mixins SocketErrorStatus {}
declare class SocketErrorStatus__certificateIsInvalid mixins SocketErrorStatus {}

	declare export interface RoundTripTimeStatistics {
variance: number,
max: number,
min: number,
sum: number
} 
	declare export interface BandwidthStatistics {
outboundBitsPerSecond: number,
inboundBitsPerSecond: number,
outboundBitsPerSecondInstability: number,
inboundBitsPerSecondInstability: number,
outboundBandwidthPeaked: boolean,
inboundBandwidthPeaked: boolean
} 
	declare export interface IDatagramSocketMessageReceivedEventArgs {
localAddress: Windows$Windows$Networking.HostName,
remoteAddress: Windows$Windows$Networking.HostName,
remotePort: string,
getDataReader(): Windows$Windows$Storage.Streams.DataReader,
getDataStream(): Windows$Windows$Storage.Streams.IInputStream
} 
	declare export interface IMessageWebSocketMessageReceivedEventArgs {
messageType: Windows$Windows$Networking.Sockets.SocketMessageType,
getDataReader(): Windows$Windows$Storage.Streams.DataReader,
getDataStream(): Windows$Windows$Storage.Streams.IInputStream
} 
	declare export interface IWebSocketClosedEventArgs {
code: number,
reason: string
} 
	declare export interface IDatagramSocketInformation {
localAddress: Windows$Windows$Networking.HostName,
localPort: string,
remoteAddress: Windows$Windows$Networking.HostName,
remotePort: string
} 
	declare export interface IDatagramSocketControl {
outboundUnicastHopLimit: number,
qualityOfService: Windows$Windows$Networking.Sockets.SocketQualityOfService
} 
	declare export interface IDatagramSocketStatics {
getEndpointPairsAsync(
remoteHostName: Windows$Windows$Networking.HostName,
remoteServiceName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.EndpointPair>>,
getEndpointPairsAsync(
remoteHostName: Windows$Windows$Networking.HostName,
remoteServiceName: string,
sortOptions: Windows$Windows$Networking.HostNameSortOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.EndpointPair>>
} 
	declare export type IDatagramSocket = {
control: Windows$Windows$Networking.Sockets.DatagramSocketControl,
information: Windows$Windows$Networking.Sockets.DatagramSocketInformation,
outputStream: Windows$Windows$Storage.Streams.IOutputStream,
connectAsync(
remoteHostName: Windows$Windows$Networking.HostName,
remoteServiceName: string): Windows$Windows$Foundation.IAsyncAction,
connectAsync(
endpointPair: Windows$Windows$Networking.EndpointPair): Windows$Windows$Foundation.IAsyncAction,
bindServiceNameAsync(localServiceName: string): Windows$Windows$Foundation.IAsyncAction,
bindEndpointAsync(
localHostName: Windows$Windows$Networking.HostName,
localServiceName: string): Windows$Windows$Foundation.IAsyncAction,
joinMulticastGroup(host: Windows$Windows$Networking.HostName): void,
getOutputStreamAsync(
remoteHostName: Windows$Windows$Networking.HostName,
remoteServiceName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IOutputStream>,
getOutputStreamAsync(
endpointPair: Windows$Windows$Networking.EndpointPair): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IOutputStream>,
onmessagereceived: any
} & undefined.IClosable

	declare export class DatagramSocketControl mixins undefined.IDatagramSocketControl {
outboundUnicastHopLimit: number;
qualityOfService: Windows$Windows$Networking.Sockets.SocketQualityOfService
}
	declare export class DatagramSocketInformation mixins undefined.IDatagramSocketInformation {
localAddress: Windows$Windows$Networking.HostName;
localPort: string;
remoteAddress: Windows$Windows$Networking.HostName;
remotePort: string
}
	declare export class DatagramSocket mixins undefined.IDatagramSocket, undefined.IClosable {
control: Windows$Windows$Networking.Sockets.DatagramSocketControl;
information: Windows$Windows$Networking.Sockets.DatagramSocketInformation;
outputStream: Windows$Windows$Storage.Streams.IOutputStream;
connectAsync(
remoteHostName: Windows$Windows$Networking.HostName,
remoteServiceName: string): Windows$Windows$Foundation.IAsyncAction;
connectAsync(
endpointPair: Windows$Windows$Networking.EndpointPair): Windows$Windows$Foundation.IAsyncAction;
bindServiceNameAsync(localServiceName: string): Windows$Windows$Foundation.IAsyncAction;
bindEndpointAsync(
localHostName: Windows$Windows$Networking.HostName,
localServiceName: string): Windows$Windows$Foundation.IAsyncAction;
joinMulticastGroup(host: Windows$Windows$Networking.HostName): void;
getOutputStreamAsync(
remoteHostName: Windows$Windows$Networking.HostName,
remoteServiceName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IOutputStream>;
getOutputStreamAsync(
endpointPair: Windows$Windows$Networking.EndpointPair): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IOutputStream>;
onmessagereceived: any;
dispose(): void;
static getEndpointPairsAsync(
remoteHostName: Windows$Windows$Networking.HostName,
remoteServiceName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.EndpointPair>>;
static getEndpointPairsAsync(
remoteHostName: Windows$Windows$Networking.HostName,
remoteServiceName: string,
sortOptions: Windows$Windows$Networking.HostNameSortOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.EndpointPair>>;
close(): void
}
	declare export class DatagramSocketMessageReceivedEventArgs mixins undefined.IDatagramSocketMessageReceivedEventArgs {
localAddress: Windows$Windows$Networking.HostName;
remoteAddress: Windows$Windows$Networking.HostName;
remotePort: string;
getDataReader(): Windows$Windows$Storage.Streams.DataReader;
getDataStream(): Windows$Windows$Storage.Streams.IInputStream
}
	declare export interface IStreamSocketInformation {
bandwidthStatistics: Windows$Windows$Networking.Sockets.BandwidthStatistics,
localAddress: Windows$Windows$Networking.HostName,
localPort: string,
protectionLevel: Windows$Windows$Networking.Sockets.SocketProtectionLevel,
remoteAddress: Windows$Windows$Networking.HostName,
remoteHostName: Windows$Windows$Networking.HostName,
remotePort: string,
remoteServiceName: string,
roundTripTimeStatistics: Windows$Windows$Networking.Sockets.RoundTripTimeStatistics,
sessionKey: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export interface IStreamSocketControl {
keepAlive: boolean,
noDelay: boolean,
outboundBufferSizeInBytes: number,
outboundUnicastHopLimit: number,
qualityOfService: Windows$Windows$Networking.Sockets.SocketQualityOfService
} 
	declare export type IStreamSocket = {
control: Windows$Windows$Networking.Sockets.StreamSocketControl,
information: Windows$Windows$Networking.Sockets.StreamSocketInformation,
inputStream: Windows$Windows$Storage.Streams.IInputStream,
outputStream: Windows$Windows$Storage.Streams.IOutputStream,
connectAsync(
endpointPair: Windows$Windows$Networking.EndpointPair): Windows$Windows$Foundation.IAsyncAction,
connectAsync(
remoteHostName: Windows$Windows$Networking.HostName,
remoteServiceName: string): Windows$Windows$Foundation.IAsyncAction,
connectAsync(
endpointPair: Windows$Windows$Networking.EndpointPair,
protectionLevel: Windows$Windows$Networking.Sockets.SocketProtectionLevel): Windows$Windows$Foundation.IAsyncAction,
connectAsync(
remoteHostName: Windows$Windows$Networking.HostName,
remoteServiceName: string,
protectionLevel: Windows$Windows$Networking.Sockets.SocketProtectionLevel): Windows$Windows$Foundation.IAsyncAction,
upgradeToSslAsync(
protectionLevel: Windows$Windows$Networking.Sockets.SocketProtectionLevel,
validationHostName: Windows$Windows$Networking.HostName): Windows$Windows$Foundation.IAsyncAction
} & undefined.IClosable

	declare export class StreamSocketControl mixins undefined.IStreamSocketControl {
keepAlive: boolean;
noDelay: boolean;
outboundBufferSizeInBytes: number;
outboundUnicastHopLimit: number;
qualityOfService: Windows$Windows$Networking.Sockets.SocketQualityOfService
}
	declare export class StreamSocketInformation mixins undefined.IStreamSocketInformation {
bandwidthStatistics: Windows$Windows$Networking.Sockets.BandwidthStatistics;
localAddress: Windows$Windows$Networking.HostName;
localPort: string;
protectionLevel: Windows$Windows$Networking.Sockets.SocketProtectionLevel;
remoteAddress: Windows$Windows$Networking.HostName;
remoteHostName: Windows$Windows$Networking.HostName;
remotePort: string;
remoteServiceName: string;
roundTripTimeStatistics: Windows$Windows$Networking.Sockets.RoundTripTimeStatistics;
sessionKey: Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IStreamSocketListenerControl {
qualityOfService: Windows$Windows$Networking.Sockets.SocketQualityOfService
} 
	declare export interface IStreamSocketListenerInformation {
localPort: string
} 
	declare export interface IStreamSocketListenerConnectionReceivedEventArgs {
socket: Windows$Windows$Networking.Sockets.StreamSocket
} 
	declare export class StreamSocket mixins undefined.IStreamSocket, undefined.IClosable {
control: Windows$Windows$Networking.Sockets.StreamSocketControl;
information: Windows$Windows$Networking.Sockets.StreamSocketInformation;
inputStream: Windows$Windows$Storage.Streams.IInputStream;
outputStream: Windows$Windows$Storage.Streams.IOutputStream;
connectAsync(
endpointPair: Windows$Windows$Networking.EndpointPair): Windows$Windows$Foundation.IAsyncAction;
connectAsync(
remoteHostName: Windows$Windows$Networking.HostName,
remoteServiceName: string): Windows$Windows$Foundation.IAsyncAction;
connectAsync(
endpointPair: Windows$Windows$Networking.EndpointPair,
protectionLevel: Windows$Windows$Networking.Sockets.SocketProtectionLevel): Windows$Windows$Foundation.IAsyncAction;
connectAsync(
remoteHostName: Windows$Windows$Networking.HostName,
remoteServiceName: string,
protectionLevel: Windows$Windows$Networking.Sockets.SocketProtectionLevel): Windows$Windows$Foundation.IAsyncAction;
upgradeToSslAsync(
protectionLevel: Windows$Windows$Networking.Sockets.SocketProtectionLevel,
validationHostName: Windows$Windows$Networking.HostName): Windows$Windows$Foundation.IAsyncAction;
dispose(): void;
close(): void
}
	declare export type IStreamSocketListener = {
control: Windows$Windows$Networking.Sockets.StreamSocketListenerControl,
information: Windows$Windows$Networking.Sockets.StreamSocketListenerInformation,
bindServiceNameAsync(localServiceName: string): Windows$Windows$Foundation.IAsyncAction,
bindEndpointAsync(
localHostName: Windows$Windows$Networking.HostName,
localServiceName: string): Windows$Windows$Foundation.IAsyncAction,
onconnectionreceived: any
} & undefined.IClosable

	declare export class StreamSocketListenerControl mixins undefined.IStreamSocketListenerControl {
qualityOfService: Windows$Windows$Networking.Sockets.SocketQualityOfService
}
	declare export class StreamSocketListenerInformation mixins undefined.IStreamSocketListenerInformation {
localPort: string
}
	declare export class StreamSocketListener mixins undefined.IStreamSocketListener, undefined.IClosable {
control: Windows$Windows$Networking.Sockets.StreamSocketListenerControl;
information: Windows$Windows$Networking.Sockets.StreamSocketListenerInformation;
bindServiceNameAsync(localServiceName: string): Windows$Windows$Foundation.IAsyncAction;
bindEndpointAsync(
localHostName: Windows$Windows$Networking.HostName,
localServiceName: string): Windows$Windows$Foundation.IAsyncAction;
onconnectionreceived: any;
dispose(): void;
close(): void
}
	declare export class StreamSocketListenerConnectionReceivedEventArgs mixins undefined.IStreamSocketListenerConnectionReceivedEventArgs {
socket: Windows$Windows$Networking.Sockets.StreamSocket
}
	declare export interface IWebSocketControl {
outboundBufferSizeInBytes: number,
proxyCredential: Windows$Windows$Security.Credentials.PasswordCredential,
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential,
supportedProtocols: Windows$Windows$Foundation.Collections.IVector<string>
} 
	declare export interface IWebSocketInformation {
bandwidthStatistics: Windows$Windows$Networking.Sockets.BandwidthStatistics,
localAddress: Windows$Windows$Networking.HostName,
protocol: string
} 
	declare export type IWebSocket = {
outputStream: Windows$Windows$Storage.Streams.IOutputStream,
connectAsync(uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncAction,
setRequestHeader(headerName: string, headerValue: string): void,
onclosed: any,
close(): void,
close(code: number, reason: string): void
} & undefined.IClosable

	declare export class WebSocketClosedEventArgs mixins undefined.IWebSocketClosedEventArgs {
code: number;
reason: string
}
	declare export type IMessageWebSocketControl = {
maxMessageSize: number,
messageType: Windows$Windows$Networking.Sockets.SocketMessageType
} & undefined.IWebSocketControl

	declare export type IMessageWebSocket = {
control: Windows$Windows$Networking.Sockets.MessageWebSocketControl,
information: Windows$Windows$Networking.Sockets.MessageWebSocketInformation,
onmessagereceived: any,
close(): void,
close(code: number, reason: string): void
} & undefined.IWebSocket & undefined.IClosable

	declare export class MessageWebSocketControl mixins undefined.IMessageWebSocketControl, undefined.IWebSocketControl {
maxMessageSize: number;
messageType: Windows$Windows$Networking.Sockets.SocketMessageType;
outboundBufferSizeInBytes: number;
proxyCredential: Windows$Windows$Security.Credentials.PasswordCredential;
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential;
supportedProtocols: Windows$Windows$Foundation.Collections.IVector<string>
}
	declare export class MessageWebSocketInformation mixins undefined.IWebSocketInformation {
bandwidthStatistics: Windows$Windows$Networking.Sockets.BandwidthStatistics;
localAddress: Windows$Windows$Networking.HostName;
protocol: string
}
	declare export class MessageWebSocket mixins undefined.IMessageWebSocket, undefined.IWebSocket, undefined.IClosable {
control: Windows$Windows$Networking.Sockets.MessageWebSocketControl;
information: Windows$Windows$Networking.Sockets.MessageWebSocketInformation;
outputStream: Windows$Windows$Storage.Streams.IOutputStream;
onmessagereceived: any;
connectAsync(uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncAction;
setRequestHeader(headerName: string, headerValue: string): void;
onclosed: any;
close(code: number, reason: string): void;
dispose(): void;
close(): void
}
	declare export class MessageWebSocketMessageReceivedEventArgs mixins undefined.IMessageWebSocketMessageReceivedEventArgs {
messageType: Windows$Windows$Networking.Sockets.SocketMessageType;
getDataReader(): Windows$Windows$Storage.Streams.DataReader;
getDataStream(): Windows$Windows$Storage.Streams.IInputStream
}
	declare export type IStreamWebSocketControl = {
noDelay: boolean
} & undefined.IWebSocketControl

	declare export type IStreamWebSocket = {
control: Windows$Windows$Networking.Sockets.StreamWebSocketControl,
information: Windows$Windows$Networking.Sockets.StreamWebSocketInformation,
inputStream: Windows$Windows$Storage.Streams.IInputStream,
close(): void,
close(code: number, reason: string): void
} & undefined.IWebSocket & undefined.IClosable

	declare export class StreamWebSocketControl mixins undefined.IStreamWebSocketControl, undefined.IWebSocketControl {
noDelay: boolean;
outboundBufferSizeInBytes: number;
proxyCredential: Windows$Windows$Security.Credentials.PasswordCredential;
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential;
supportedProtocols: Windows$Windows$Foundation.Collections.IVector<string>
}
	declare export class StreamWebSocketInformation mixins undefined.IWebSocketInformation {
bandwidthStatistics: Windows$Windows$Networking.Sockets.BandwidthStatistics;
localAddress: Windows$Windows$Networking.HostName;
protocol: string
}
	declare export interface ISocketErrorStatics {
getStatus(hresult: number): Windows$Windows$Networking.Sockets.SocketErrorStatus
} 
	declare export interface IWebSocketErrorStatics {
getStatus(hresult: number): Windows$Windows$Web.WebErrorStatus
} 
	declare export class StreamWebSocket mixins undefined.IStreamWebSocket, undefined.IWebSocket, undefined.IClosable {
control: Windows$Windows$Networking.Sockets.StreamWebSocketControl;
information: Windows$Windows$Networking.Sockets.StreamWebSocketInformation;
inputStream: Windows$Windows$Storage.Streams.IInputStream;
outputStream: Windows$Windows$Storage.Streams.IOutputStream;
connectAsync(uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncAction;
setRequestHeader(headerName: string, headerValue: string): void;
onclosed: any;
close(code: number, reason: string): void;
dispose(): void;
close(): void
}
	declare export class WebSocketKeepAlive mixins undefined.IBackgroundTask {
run(
taskInstance: Windows$Windows$ApplicationModel.Background.IBackgroundTaskInstance): void
}
	declare export class SocketError  {
static getStatus(hresult: number): Windows$Windows$Networking.Sockets.SocketErrorStatus
}
	declare export class WebSocketError  {
static getStatus(hresult: number): Windows$Windows$Web.WebErrorStatus
}
    }

	declare export  class HostNameSortOptions {
  constructor(...args: empty): mixed;
static +none: Class<HostNameSortOptions__none> & HostNameSortOptions__none & 0;// 0
static +optimizeForLongConnections: Class<HostNameSortOptions__optimizeForLongConnections> & HostNameSortOptions__optimizeForLongConnections & 1;// 1

}

declare class HostNameSortOptions__none mixins HostNameSortOptions {}
declare class HostNameSortOptions__optimizeForLongConnections mixins HostNameSortOptions {}

	declare export  class HostNameType {
  constructor(...args: empty): mixed;
static +domainName: Class<HostNameType__domainName> & HostNameType__domainName & 0;// 0
static +ipv4: Class<HostNameType__ipv4> & HostNameType__ipv4 & 1;// 1
static +ipv6: Class<HostNameType__ipv6> & HostNameType__ipv6 & 2;// 2
static +bluetooth: Class<HostNameType__bluetooth> & HostNameType__bluetooth & 3;// 3

}

declare class HostNameType__domainName mixins HostNameType {}
declare class HostNameType__ipv4 mixins HostNameType {}
declare class HostNameType__ipv6 mixins HostNameType {}
declare class HostNameType__bluetooth mixins HostNameType {}

	declare export interface IHostNameStatics {
compare(value1: string, value2: string): number
} 
	declare export interface IHostName {
canonicalName: string,
displayName: string,
iPInformation: Windows$Windows$Networking.Connectivity.IPInformation,
rawName: string,
type: Windows$Windows$Networking.HostNameType,
isEqual(hostName: Windows$Windows$Networking.HostName): boolean
} 
	declare export class HostName mixins undefined.IHostName {
constructor(hostName: string): this;
canonicalName: string;
displayName: string;
iPInformation: Windows$Windows$Networking.Connectivity.IPInformation;
rawName: string;
type: Windows$Windows$Networking.HostNameType;
isEqual(hostName: Windows$Windows$Networking.HostName): boolean;
static compare(value1: string, value2: string): number
}
	declare export interface IHostNameFactory {
createHostName(hostName: string): Windows$Windows$Networking.HostName
} 
	declare export interface IEndpointPair {
localHostName: Windows$Windows$Networking.HostName,
localServiceName: string,
remoteHostName: Windows$Windows$Networking.HostName,
remoteServiceName: string
} 
	declare export interface IEndpointPairFactory {
createEndpointPair(
localHostName: Windows$Windows$Networking.HostName,
localServiceName: string,
remoteHostName: Windows$Windows$Networking.HostName,
remoteServiceName: string): Windows$Windows$Networking.EndpointPair
} 
	declare export class EndpointPair mixins undefined.IEndpointPair {
constructor(localHostName: Windows$Windows$Networking.HostName, localServiceName: string, remoteHostName: Windows$Windows$Networking.HostName, remoteServiceName: string): this;
localHostName: Windows$Windows$Networking.HostName;
localServiceName: string;
remoteHostName: Windows$Windows$Networking.HostName;
remoteServiceName: string
}
	declare module 'Connectivity' {
        declare export class IPInformation mixins undefined.IIPInformation {
networkAdapter: Windows$Windows$Networking.Connectivity.NetworkAdapter;
prefixLength: number
}
	declare export  class NetworkCostType {
  constructor(...args: empty): mixed;
static +unknown: Class<NetworkCostType__unknown> & NetworkCostType__unknown & 0;// 0
static +unrestricted: Class<NetworkCostType__unrestricted> & NetworkCostType__unrestricted & 1;// 1
static +fixed: Class<NetworkCostType__fixed> & NetworkCostType__fixed & 2;// 2
static +variable: Class<NetworkCostType__variable> & NetworkCostType__variable & 3;// 3

}

declare class NetworkCostType__unknown mixins NetworkCostType {}
declare class NetworkCostType__unrestricted mixins NetworkCostType {}
declare class NetworkCostType__fixed mixins NetworkCostType {}
declare class NetworkCostType__variable mixins NetworkCostType {}

	declare export  class NetworkConnectivityLevel {
  constructor(...args: empty): mixed;
static +none: Class<NetworkConnectivityLevel__none> & NetworkConnectivityLevel__none & 0;// 0
static +localAccess: Class<NetworkConnectivityLevel__localAccess> & NetworkConnectivityLevel__localAccess & 1;// 1
static +constrainedInternetAccess: Class<NetworkConnectivityLevel__constrainedInternetAccess> & NetworkConnectivityLevel__constrainedInternetAccess & 2;// 2
static +internetAccess: Class<NetworkConnectivityLevel__internetAccess> & NetworkConnectivityLevel__internetAccess & 3;// 3

}

declare class NetworkConnectivityLevel__none mixins NetworkConnectivityLevel {}
declare class NetworkConnectivityLevel__localAccess mixins NetworkConnectivityLevel {}
declare class NetworkConnectivityLevel__constrainedInternetAccess mixins NetworkConnectivityLevel {}
declare class NetworkConnectivityLevel__internetAccess mixins NetworkConnectivityLevel {}

	declare export  class NetworkTypes {
  constructor(...args: empty): mixed;
static +none: Class<NetworkTypes__none> & NetworkTypes__none & 0;// 0
static +internet: Class<NetworkTypes__internet> & NetworkTypes__internet & 1;// 1
static +privateNetwork: Class<NetworkTypes__privateNetwork> & NetworkTypes__privateNetwork & 2;// 2

}

declare class NetworkTypes__none mixins NetworkTypes {}
declare class NetworkTypes__internet mixins NetworkTypes {}
declare class NetworkTypes__privateNetwork mixins NetworkTypes {}

	declare export  class RoamingStates {
  constructor(...args: empty): mixed;
static +none: Class<RoamingStates__none> & RoamingStates__none & 0;// 0
static +notRoaming: Class<RoamingStates__notRoaming> & RoamingStates__notRoaming & 1;// 1
static +roaming: Class<RoamingStates__roaming> & RoamingStates__roaming & 2;// 2

}

declare class RoamingStates__none mixins RoamingStates {}
declare class RoamingStates__notRoaming mixins RoamingStates {}
declare class RoamingStates__roaming mixins RoamingStates {}

	declare export  class NetworkAuthenticationType {
  constructor(...args: empty): mixed;
static +none: Class<NetworkAuthenticationType__none> & NetworkAuthenticationType__none & 0;// 0
static +unknown: Class<NetworkAuthenticationType__unknown> & NetworkAuthenticationType__unknown & 1;// 1
static +open80211: Class<NetworkAuthenticationType__open80211> & NetworkAuthenticationType__open80211 & 2;// 2
static +sharedKey80211: Class<NetworkAuthenticationType__sharedKey80211> & NetworkAuthenticationType__sharedKey80211 & 3;// 3
static +wpa: Class<NetworkAuthenticationType__wpa> & NetworkAuthenticationType__wpa & 4;// 4
static +wpaPsk: Class<NetworkAuthenticationType__wpaPsk> & NetworkAuthenticationType__wpaPsk & 5;// 5
static +wpaNone: Class<NetworkAuthenticationType__wpaNone> & NetworkAuthenticationType__wpaNone & 6;// 6
static +rsna: Class<NetworkAuthenticationType__rsna> & NetworkAuthenticationType__rsna & 7;// 7
static +rsnaPsk: Class<NetworkAuthenticationType__rsnaPsk> & NetworkAuthenticationType__rsnaPsk & 8;// 8
static +ihv: Class<NetworkAuthenticationType__ihv> & NetworkAuthenticationType__ihv & 9;// 9

}

declare class NetworkAuthenticationType__none mixins NetworkAuthenticationType {}
declare class NetworkAuthenticationType__unknown mixins NetworkAuthenticationType {}
declare class NetworkAuthenticationType__open80211 mixins NetworkAuthenticationType {}
declare class NetworkAuthenticationType__sharedKey80211 mixins NetworkAuthenticationType {}
declare class NetworkAuthenticationType__wpa mixins NetworkAuthenticationType {}
declare class NetworkAuthenticationType__wpaPsk mixins NetworkAuthenticationType {}
declare class NetworkAuthenticationType__wpaNone mixins NetworkAuthenticationType {}
declare class NetworkAuthenticationType__rsna mixins NetworkAuthenticationType {}
declare class NetworkAuthenticationType__rsnaPsk mixins NetworkAuthenticationType {}
declare class NetworkAuthenticationType__ihv mixins NetworkAuthenticationType {}

	declare export  class NetworkEncryptionType {
  constructor(...args: empty): mixed;
static +none: Class<NetworkEncryptionType__none> & NetworkEncryptionType__none & 0;// 0
static +unknown: Class<NetworkEncryptionType__unknown> & NetworkEncryptionType__unknown & 1;// 1
static +wep: Class<NetworkEncryptionType__wep> & NetworkEncryptionType__wep & 2;// 2
static +wep40: Class<NetworkEncryptionType__wep40> & NetworkEncryptionType__wep40 & 3;// 3
static +wep104: Class<NetworkEncryptionType__wep104> & NetworkEncryptionType__wep104 & 4;// 4
static +tkip: Class<NetworkEncryptionType__tkip> & NetworkEncryptionType__tkip & 5;// 5
static +ccmp: Class<NetworkEncryptionType__ccmp> & NetworkEncryptionType__ccmp & 6;// 6
static +wpaUseGroup: Class<NetworkEncryptionType__wpaUseGroup> & NetworkEncryptionType__wpaUseGroup & 7;// 7
static +rsnUseGroup: Class<NetworkEncryptionType__rsnUseGroup> & NetworkEncryptionType__rsnUseGroup & 8;// 8
static +ihv: Class<NetworkEncryptionType__ihv> & NetworkEncryptionType__ihv & 9;// 9

}

declare class NetworkEncryptionType__none mixins NetworkEncryptionType {}
declare class NetworkEncryptionType__unknown mixins NetworkEncryptionType {}
declare class NetworkEncryptionType__wep mixins NetworkEncryptionType {}
declare class NetworkEncryptionType__wep40 mixins NetworkEncryptionType {}
declare class NetworkEncryptionType__wep104 mixins NetworkEncryptionType {}
declare class NetworkEncryptionType__tkip mixins NetworkEncryptionType {}
declare class NetworkEncryptionType__ccmp mixins NetworkEncryptionType {}
declare class NetworkEncryptionType__wpaUseGroup mixins NetworkEncryptionType {}
declare class NetworkEncryptionType__rsnUseGroup mixins NetworkEncryptionType {}
declare class NetworkEncryptionType__ihv mixins NetworkEncryptionType {}

	declare export interface IDataUsage {
bytesReceived: number,
bytesSent: number
} 
	declare export interface IDataPlanUsage {
lastSyncTime: Date,
megabytesUsed: number
} 
	declare export interface IDataPlanStatus {
dataLimitInMegabytes: number,
dataPlanUsage: Windows$Windows$Networking.Connectivity.DataPlanUsage,
inboundBitsPerSecond: number,
maxTransferSizeInMegabytes: number,
nextBillingCycle: Date,
outboundBitsPerSecond: number
} 
	declare export class DataPlanUsage mixins undefined.IDataPlanUsage {
lastSyncTime: Date;
megabytesUsed: number
}
	declare export interface IConnectionCost {
approachingDataLimit: boolean,
networkCostType: Windows$Windows$Networking.Connectivity.NetworkCostType,
overDataLimit: boolean,
roaming: boolean
} 
	declare export interface INetworkSecuritySettings {
networkAuthenticationType: Windows$Windows$Networking.Connectivity.NetworkAuthenticationType,
networkEncryptionType: Windows$Windows$Networking.Connectivity.NetworkEncryptionType
} 
	declare export interface IConnectionProfile {
networkAdapter: Windows$Windows$Networking.Connectivity.NetworkAdapter,
networkSecuritySettings: Windows$Windows$Networking.Connectivity.NetworkSecuritySettings,
profileName: string,
getNetworkConnectivityLevel(): Windows$Windows$Networking.Connectivity.NetworkConnectivityLevel,
getNetworkNames(): Windows$Windows$Foundation.Collections.IVectorView<string>,
getConnectionCost(): Windows$Windows$Networking.Connectivity.ConnectionCost,
getDataPlanStatus(): Windows$Windows$Networking.Connectivity.DataPlanStatus,
getLocalUsage(
StartTime: Date,
EndTime: Date): Windows$Windows$Networking.Connectivity.DataUsage,
getLocalUsage(
StartTime: Date,
EndTime: Date,
States: Windows$Windows$Networking.Connectivity.RoamingStates): Windows$Windows$Networking.Connectivity.DataUsage,
getSignalBars(): Windows$Windows$Foundation.IReference<number>
} 
	declare export class ConnectionCost mixins undefined.IConnectionCost {
approachingDataLimit: boolean;
networkCostType: Windows$Windows$Networking.Connectivity.NetworkCostType;
overDataLimit: boolean;
roaming: boolean
}
	declare export class DataPlanStatus mixins undefined.IDataPlanStatus {
dataLimitInMegabytes: number;
dataPlanUsage: Windows$Windows$Networking.Connectivity.DataPlanUsage;
inboundBitsPerSecond: number;
maxTransferSizeInMegabytes: number;
nextBillingCycle: Date;
outboundBitsPerSecond: number
}
	declare export class NetworkAdapter mixins undefined.INetworkAdapter {
ianaInterfaceType: number;
inboundMaxBitsPerSecond: number;
networkAdapterId: string;
networkItem: Windows$Windows$Networking.Connectivity.NetworkItem;
outboundMaxBitsPerSecond: number;
getConnectedProfileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.Connectivity.ConnectionProfile>
}
	declare export class DataUsage mixins undefined.IDataUsage {
bytesReceived: number;
bytesSent: number
}
	declare export class NetworkSecuritySettings mixins undefined.INetworkSecuritySettings {
networkAuthenticationType: Windows$Windows$Networking.Connectivity.NetworkAuthenticationType;
networkEncryptionType: Windows$Windows$Networking.Connectivity.NetworkEncryptionType
}
	declare export interface ILanIdentifierData {
type: number,
value: Windows$Windows$Foundation.Collections.IVectorView<number>
} 
	declare export interface ILanIdentifier {
infrastructureId: Windows$Windows$Networking.Connectivity.LanIdentifierData,
networkAdapterId: string,
portId: Windows$Windows$Networking.Connectivity.LanIdentifierData
} 
	declare export class LanIdentifierData mixins undefined.ILanIdentifierData {
type: number;
value: Windows$Windows$Foundation.Collections.IVectorView<number>
}
	declare export interface NetworkStatusChangedEventHandler {
(sender: any): void
} 
	declare export interface INetworkInformationStatics {
getConnectionProfiles(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.Connectivity.ConnectionProfile>,
getInternetConnectionProfile(): Windows$Windows$Networking.Connectivity.ConnectionProfile,
getLanIdentifiers(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.Connectivity.LanIdentifier>,
getHostNames(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.HostName>,
getProxyConfigurationAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.Connectivity.ProxyConfiguration>,
getSortedEndpointPairs(
destinationList: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Networking.EndpointPair>,
sortOptions: Windows$Windows$Networking.HostNameSortOptions): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.EndpointPair>,
onnetworkstatuschanged: any
} 
	declare export class ConnectionProfile mixins undefined.IConnectionProfile {
networkAdapter: Windows$Windows$Networking.Connectivity.NetworkAdapter;
networkSecuritySettings: Windows$Windows$Networking.Connectivity.NetworkSecuritySettings;
profileName: string;
getNetworkConnectivityLevel(): Windows$Windows$Networking.Connectivity.NetworkConnectivityLevel;
getNetworkNames(): Windows$Windows$Foundation.Collections.IVectorView<string>;
getConnectionCost(): Windows$Windows$Networking.Connectivity.ConnectionCost;
getDataPlanStatus(): Windows$Windows$Networking.Connectivity.DataPlanStatus;
getLocalUsage(
StartTime: Date,
EndTime: Date): Windows$Windows$Networking.Connectivity.DataUsage;
getLocalUsage(
StartTime: Date,
EndTime: Date,
States: Windows$Windows$Networking.Connectivity.RoamingStates): Windows$Windows$Networking.Connectivity.DataUsage;
getSignalBars(): Windows$Windows$Foundation.IReference<number>
}
	declare export class LanIdentifier mixins undefined.ILanIdentifier {
infrastructureId: Windows$Windows$Networking.Connectivity.LanIdentifierData;
networkAdapterId: string;
portId: Windows$Windows$Networking.Connectivity.LanIdentifierData
}
	declare export class ProxyConfiguration mixins undefined.IProxyConfiguration {
canConnectDirectly: boolean;
proxyUris: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Foundation.Uri>
}
	declare export interface INetworkItem {
networkId: string,
getNetworkTypes(): Windows$Windows$Networking.Connectivity.NetworkTypes
} 
	declare export interface INetworkAdapter {
ianaInterfaceType: number,
inboundMaxBitsPerSecond: number,
networkAdapterId: string,
networkItem: Windows$Windows$Networking.Connectivity.NetworkItem,
outboundMaxBitsPerSecond: number,
getConnectedProfileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.Connectivity.ConnectionProfile>
} 
	declare export class NetworkItem mixins undefined.INetworkItem {
networkId: string;
getNetworkTypes(): Windows$Windows$Networking.Connectivity.NetworkTypes
}
	declare export interface IIPInformation {
networkAdapter: Windows$Windows$Networking.Connectivity.NetworkAdapter,
prefixLength: number
} 
	declare export interface IProxyConfiguration {
canConnectDirectly: boolean,
proxyUris: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Foundation.Uri>
} 
	declare export class NetworkInformation  {
static getConnectionProfiles(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.Connectivity.ConnectionProfile>;
static getInternetConnectionProfile(): Windows$Windows$Networking.Connectivity.ConnectionProfile;
static getLanIdentifiers(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.Connectivity.LanIdentifier>;
static getHostNames(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.HostName>;
static getProxyConfigurationAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.Connectivity.ProxyConfiguration>;
static getSortedEndpointPairs(
destinationList: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Networking.EndpointPair>,
sortOptions: Windows$Windows$Networking.HostNameSortOptions): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Networking.EndpointPair>;
static onnetworkstatuschanged: any
}
    }

	declare module 'PushNotifications' {
        declare export  class PushNotificationType {
  constructor(...args: empty): mixed;
static +toast: Class<PushNotificationType__toast> & PushNotificationType__toast & 0;// 0
static +tile: Class<PushNotificationType__tile> & PushNotificationType__tile & 1;// 1
static +badge: Class<PushNotificationType__badge> & PushNotificationType__badge & 2;// 2
static +raw: Class<PushNotificationType__raw> & PushNotificationType__raw & 3;// 3

}

declare class PushNotificationType__toast mixins PushNotificationType {}
declare class PushNotificationType__tile mixins PushNotificationType {}
declare class PushNotificationType__badge mixins PushNotificationType {}
declare class PushNotificationType__raw mixins PushNotificationType {}

	declare export interface IPushNotificationChannelManagerStatics {
createPushNotificationChannelForApplicationAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.PushNotifications.PushNotificationChannel>,
createPushNotificationChannelForApplicationAsync(
applicationId: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.PushNotifications.PushNotificationChannel>,
createPushNotificationChannelForSecondaryTileAsync(
tileId: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.PushNotifications.PushNotificationChannel>
} 
	declare export class PushNotificationChannel mixins undefined.IPushNotificationChannel {
expirationTime: Date;
uri: string;
close(): void;
onpushnotificationreceived: any
}
	declare export interface IPushNotificationChannel {
expirationTime: Date,
uri: string,
close(): void,
onpushnotificationreceived: any
} 
	declare export class PushNotificationReceivedEventArgs mixins undefined.IPushNotificationReceivedEventArgs {
badgeNotification: Windows$Windows$UI.Notifications.BadgeNotification;
cancel: boolean;
notificationType: Windows$Windows$Networking.PushNotifications.PushNotificationType;
rawNotification: Windows$Windows$Networking.PushNotifications.RawNotification;
tileNotification: Windows$Windows$UI.Notifications.TileNotification;
toastNotification: Windows$Windows$UI.Notifications.ToastNotification
}
	declare export interface IPushNotificationReceivedEventArgs {
badgeNotification: Windows$Windows$UI.Notifications.BadgeNotification,
cancel: boolean,
notificationType: Windows$Windows$Networking.PushNotifications.PushNotificationType,
rawNotification: Windows$Windows$Networking.PushNotifications.RawNotification,
tileNotification: Windows$Windows$UI.Notifications.TileNotification,
toastNotification: Windows$Windows$UI.Notifications.ToastNotification
} 
	declare export class RawNotification mixins undefined.IRawNotification {
content: string
}
	declare export interface IRawNotification {
content: string
} 
	declare export class PushNotificationChannelManager  {
static createPushNotificationChannelForApplicationAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.PushNotifications.PushNotificationChannel>;
static createPushNotificationChannelForApplicationAsync(
applicationId: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.PushNotifications.PushNotificationChannel>;
static createPushNotificationChannelForSecondaryTileAsync(
tileId: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Networking.PushNotifications.PushNotificationChannel>
}
    }

    }


declare module 'Security' {
        declare module 'Authentication' {
        declare module 'OnlineId' {
        declare export  class CredentialPromptType {
  constructor(...args: empty): mixed;
static +promptIfNeeded: Class<CredentialPromptType__promptIfNeeded> & CredentialPromptType__promptIfNeeded & 0;// 0
static +retypeCredentials: Class<CredentialPromptType__retypeCredentials> & CredentialPromptType__retypeCredentials & 1;// 1
static +doNotPrompt: Class<CredentialPromptType__doNotPrompt> & CredentialPromptType__doNotPrompt & 2;// 2

}

declare class CredentialPromptType__promptIfNeeded mixins CredentialPromptType {}
declare class CredentialPromptType__retypeCredentials mixins CredentialPromptType {}
declare class CredentialPromptType__doNotPrompt mixins CredentialPromptType {}

	declare export interface IOnlineIdServiceTicketRequest {
policy: string,
service: string
} 
	declare export interface IOnlineIdServiceTicketRequestFactory {
createOnlineIdServiceTicketRequest(
service: string,
policy: string): Windows$Windows$Security.Authentication.OnlineId.OnlineIdServiceTicketRequest,
createOnlineIdServiceTicketRequest(
service: string): Windows$Windows$Security.Authentication.OnlineId.OnlineIdServiceTicketRequest
} 
	declare export class OnlineIdServiceTicketRequest mixins undefined.IOnlineIdServiceTicketRequest {
constructor(service: string, policy: string): this;
constructor(service: string): this;
policy: string;
service: string
}
	declare export interface IOnlineIdServiceTicket {
errorCode: number,
request: Windows$Windows$Security.Authentication.OnlineId.OnlineIdServiceTicketRequest,
value: string
} 
	declare export interface IUserIdentity {
firstName: string,
id: string,
isBetaAccount: boolean,
isConfirmedPC: boolean,
lastName: string,
safeCustomerId: string,
signInName: string,
tickets: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Security.Authentication.OnlineId.OnlineIdServiceTicket>
} 
	declare export class OnlineIdServiceTicket mixins undefined.IOnlineIdServiceTicket {
errorCode: number;
request: Windows$Windows$Security.Authentication.OnlineId.OnlineIdServiceTicketRequest;
value: string
}
	declare export interface IOnlineIdAuthenticator {
applicationId: string,
authenticatedSafeCustomerId: string,
canSignOut: boolean,
authenticateUserAsync(
request: Windows$Windows$Security.Authentication.OnlineId.OnlineIdServiceTicketRequest): Windows$Windows$Security.Authentication.OnlineId.UserAuthenticationOperation,
authenticateUserAsync(
requests: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Security.Authentication.OnlineId.OnlineIdServiceTicketRequest>,
credentialPromptType: Windows$Windows$Security.Authentication.OnlineId.CredentialPromptType): Windows$Windows$Security.Authentication.OnlineId.UserAuthenticationOperation,
signOutUserAsync(): Windows$Windows$Security.Authentication.OnlineId.SignOutUserOperation
} 
	declare export class UserAuthenticationOperation mixins undefined.IAsyncOperation<Windows$Windows$Security.Authentication.OnlineId.UserIdentity>, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<Windows$Windows$Security.Authentication.OnlineId.UserIdentity>;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(): Windows$Windows$Security.Authentication.OnlineId.UserIdentity;
cancel(): void;
close(): void;
then<U>(
success?: (value: Windows$Windows$Security.Authentication.OnlineId.UserIdentity) => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Security.Authentication.OnlineId.UserIdentity) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: Windows$Windows$Security.Authentication.OnlineId.UserIdentity) => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (
value: Windows$Windows$Security.Authentication.OnlineId.UserIdentity) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: (value: Windows$Windows$Security.Authentication.OnlineId.UserIdentity) => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<Windows$Windows$Security.Authentication.OnlineId.UserIdentity>,
getResults(): Windows$Windows$Security.Authentication.OnlineId.UserIdentity
}
}
	declare export class SignOutUserOperation mixins undefined.IAsyncAction, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncActionCompletedHandler;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(): void;
cancel(): void;
close(): void;
then<U>(
success?: () => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: () => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: () => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: () => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: () => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<any>,
getResults(): any
}
}
	declare export class UserIdentity mixins undefined.IUserIdentity {
firstName: string;
id: string;
isBetaAccount: boolean;
isConfirmedPC: boolean;
lastName: string;
safeCustomerId: string;
signInName: string;
tickets: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Security.Authentication.OnlineId.OnlineIdServiceTicket>
}
	declare export class OnlineIdAuthenticator mixins undefined.IOnlineIdAuthenticator {
applicationId: string;
authenticatedSafeCustomerId: string;
canSignOut: boolean;
authenticateUserAsync(
request: Windows$Windows$Security.Authentication.OnlineId.OnlineIdServiceTicketRequest): Windows$Windows$Security.Authentication.OnlineId.UserAuthenticationOperation;
authenticateUserAsync(
requests: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Security.Authentication.OnlineId.OnlineIdServiceTicketRequest>,
credentialPromptType: Windows$Windows$Security.Authentication.OnlineId.CredentialPromptType): Windows$Windows$Security.Authentication.OnlineId.UserAuthenticationOperation;
signOutUserAsync(): Windows$Windows$Security.Authentication.OnlineId.SignOutUserOperation
}
    }

	declare module 'Web' {
        declare export  class WebAuthenticationStatus {
  constructor(...args: empty): mixed;
static +success: Class<WebAuthenticationStatus__success> & WebAuthenticationStatus__success & 0;// 0
static +userCancel: Class<WebAuthenticationStatus__userCancel> & WebAuthenticationStatus__userCancel & 1;// 1
static +errorHttp: Class<WebAuthenticationStatus__errorHttp> & WebAuthenticationStatus__errorHttp & 2;// 2

}

declare class WebAuthenticationStatus__success mixins WebAuthenticationStatus {}
declare class WebAuthenticationStatus__userCancel mixins WebAuthenticationStatus {}
declare class WebAuthenticationStatus__errorHttp mixins WebAuthenticationStatus {}

	declare export  class WebAuthenticationOptions {
  constructor(...args: empty): mixed;
static +none: Class<WebAuthenticationOptions__none> & WebAuthenticationOptions__none & 0;// 0
static +silentMode: Class<WebAuthenticationOptions__silentMode> & WebAuthenticationOptions__silentMode & 1;// 1
static +useTitle: Class<WebAuthenticationOptions__useTitle> & WebAuthenticationOptions__useTitle & 2;// 2
static +useHttpPost: Class<WebAuthenticationOptions__useHttpPost> & WebAuthenticationOptions__useHttpPost & 3;// 3
static +useCorporateNetwork: Class<WebAuthenticationOptions__useCorporateNetwork> & WebAuthenticationOptions__useCorporateNetwork & 4;// 4

}

declare class WebAuthenticationOptions__none mixins WebAuthenticationOptions {}
declare class WebAuthenticationOptions__silentMode mixins WebAuthenticationOptions {}
declare class WebAuthenticationOptions__useTitle mixins WebAuthenticationOptions {}
declare class WebAuthenticationOptions__useHttpPost mixins WebAuthenticationOptions {}
declare class WebAuthenticationOptions__useCorporateNetwork mixins WebAuthenticationOptions {}

	declare export interface IWebAuthenticationResult {
responseData: string,
responseErrorDetail: number,
responseStatus: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationStatus
} 
	declare export class WebAuthenticationResult mixins undefined.IWebAuthenticationResult {
responseData: string;
responseErrorDetail: number;
responseStatus: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationStatus
}
	declare export interface IWebAuthenticationBrokerStatics {
authenticateAsync(
options: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationOptions,
requestUri: Windows$Windows$Foundation.Uri,
callbackUri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationResult>,
authenticateAsync(
options: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationOptions,
requestUri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationResult>,
authenticateAndContinue(requestUri: Windows$Windows$Foundation.Uri): void,
authenticateAndContinue(
requestUri: Windows$Windows$Foundation.Uri,
callbackUri: Windows$Windows$Foundation.Uri): void,
authenticateAndContinue(
requestUri: Windows$Windows$Foundation.Uri,
callbackUri: Windows$Windows$Foundation.Uri,
continuationData: Windows$Windows$Foundation.Collections.ValueSet,
options: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationOptions): void,
getCurrentApplicationCallbackUri(): Windows$Windows$Foundation.Uri
} 
	declare export class WebAuthenticationBroker  {
static authenticateAsync(
options: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationOptions,
requestUri: Windows$Windows$Foundation.Uri,
callbackUri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationResult>;
static authenticateAsync(
options: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationOptions,
requestUri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationResult>;
static authenticateAndContinue(requestUri: Windows$Windows$Foundation.Uri): void;
static authenticateAndContinue(
requestUri: Windows$Windows$Foundation.Uri,
callbackUri: Windows$Windows$Foundation.Uri): void;
static authenticateAndContinue(
requestUri: Windows$Windows$Foundation.Uri,
callbackUri: Windows$Windows$Foundation.Uri,
continuationData: Windows$Windows$Foundation.Collections.ValueSet,
options: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationOptions): void;
static getCurrentApplicationCallbackUri(): Windows$Windows$Foundation.Uri
}
	declare export  class WebErrorStatus {
  constructor(...args: empty): mixed;
static +unknown: Class<WebErrorStatus__unknown> & WebErrorStatus__unknown & 0;// 0
static +certificateCommonNameIsIncorrect: Class<WebErrorStatus__certificateCommonNameIsIncorrect> & WebErrorStatus__certificateCommonNameIsIncorrect & 1;// 1
static +certificateExpired: Class<WebErrorStatus__certificateExpired> & WebErrorStatus__certificateExpired & 2;// 2
static +certificateContainsErrors: Class<WebErrorStatus__certificateContainsErrors> & WebErrorStatus__certificateContainsErrors & 3;// 3
static +certificateRevoked: Class<WebErrorStatus__certificateRevoked> & WebErrorStatus__certificateRevoked & 4;// 4
static +certificateIsInvalid: Class<WebErrorStatus__certificateIsInvalid> & WebErrorStatus__certificateIsInvalid & 5;// 5
static +serverUnreachable: Class<WebErrorStatus__serverUnreachable> & WebErrorStatus__serverUnreachable & 6;// 6
static +timeout: Class<WebErrorStatus__timeout> & WebErrorStatus__timeout & 7;// 7
static +errorHttpInvalidServerResponse: Class<WebErrorStatus__errorHttpInvalidServerResponse> & WebErrorStatus__errorHttpInvalidServerResponse & 8;// 8
static +connectionAborted: Class<WebErrorStatus__connectionAborted> & WebErrorStatus__connectionAborted & 9;// 9
static +connectionReset: Class<WebErrorStatus__connectionReset> & WebErrorStatus__connectionReset & 10;// 10
static +disconnected: Class<WebErrorStatus__disconnected> & WebErrorStatus__disconnected & 11;// 11
static +httpToHttpsOnRedirection: Class<WebErrorStatus__httpToHttpsOnRedirection> & WebErrorStatus__httpToHttpsOnRedirection & 12;// 12
static +httpsToHttpOnRedirection: Class<WebErrorStatus__httpsToHttpOnRedirection> & WebErrorStatus__httpsToHttpOnRedirection & 13;// 13
static +cannotConnect: Class<WebErrorStatus__cannotConnect> & WebErrorStatus__cannotConnect & 14;// 14
static +hostNameNotResolved: Class<WebErrorStatus__hostNameNotResolved> & WebErrorStatus__hostNameNotResolved & 15;// 15
static +operationCanceled: Class<WebErrorStatus__operationCanceled> & WebErrorStatus__operationCanceled & 16;// 16
static +redirectFailed: Class<WebErrorStatus__redirectFailed> & WebErrorStatus__redirectFailed & 17;// 17
static +unexpectedStatusCode: Class<WebErrorStatus__unexpectedStatusCode> & WebErrorStatus__unexpectedStatusCode & 18;// 18
static +unexpectedRedirection: Class<WebErrorStatus__unexpectedRedirection> & WebErrorStatus__unexpectedRedirection & 19;// 19
static +unexpectedClientError: Class<WebErrorStatus__unexpectedClientError> & WebErrorStatus__unexpectedClientError & 20;// 20
static +unexpectedServerError: Class<WebErrorStatus__unexpectedServerError> & WebErrorStatus__unexpectedServerError & 21;// 21
static +multipleChoices: Class<WebErrorStatus__multipleChoices> & WebErrorStatus__multipleChoices & 22;// 22
static +movedPermanently: Class<WebErrorStatus__movedPermanently> & WebErrorStatus__movedPermanently & 23;// 23
static +found: Class<WebErrorStatus__found> & WebErrorStatus__found & 24;// 24
static +seeOther: Class<WebErrorStatus__seeOther> & WebErrorStatus__seeOther & 25;// 25
static +notModified: Class<WebErrorStatus__notModified> & WebErrorStatus__notModified & 26;// 26
static +useProxy: Class<WebErrorStatus__useProxy> & WebErrorStatus__useProxy & 27;// 27
static +temporaryRedirect: Class<WebErrorStatus__temporaryRedirect> & WebErrorStatus__temporaryRedirect & 28;// 28
static +badRequest: Class<WebErrorStatus__badRequest> & WebErrorStatus__badRequest & 29;// 29
static +unauthorized: Class<WebErrorStatus__unauthorized> & WebErrorStatus__unauthorized & 30;// 30
static +paymentRequired: Class<WebErrorStatus__paymentRequired> & WebErrorStatus__paymentRequired & 31;// 31
static +forbidden: Class<WebErrorStatus__forbidden> & WebErrorStatus__forbidden & 32;// 32
static +notFound: Class<WebErrorStatus__notFound> & WebErrorStatus__notFound & 33;// 33
static +methodNotAllowed: Class<WebErrorStatus__methodNotAllowed> & WebErrorStatus__methodNotAllowed & 34;// 34
static +notAcceptable: Class<WebErrorStatus__notAcceptable> & WebErrorStatus__notAcceptable & 35;// 35
static +proxyAuthenticationRequired: Class<WebErrorStatus__proxyAuthenticationRequired> & WebErrorStatus__proxyAuthenticationRequired & 36;// 36
static +requestTimeout: Class<WebErrorStatus__requestTimeout> & WebErrorStatus__requestTimeout & 37;// 37
static +conflict: Class<WebErrorStatus__conflict> & WebErrorStatus__conflict & 38;// 38
static +gone: Class<WebErrorStatus__gone> & WebErrorStatus__gone & 39;// 39
static +lengthRequired: Class<WebErrorStatus__lengthRequired> & WebErrorStatus__lengthRequired & 40;// 40
static +preconditionFailed: Class<WebErrorStatus__preconditionFailed> & WebErrorStatus__preconditionFailed & 41;// 41
static +requestEntityTooLarge: Class<WebErrorStatus__requestEntityTooLarge> & WebErrorStatus__requestEntityTooLarge & 42;// 42
static +requestUriTooLong: Class<WebErrorStatus__requestUriTooLong> & WebErrorStatus__requestUriTooLong & 43;// 43
static +unsupportedMediaType: Class<WebErrorStatus__unsupportedMediaType> & WebErrorStatus__unsupportedMediaType & 44;// 44
static +requestedRangeNotSatisfiable: Class<WebErrorStatus__requestedRangeNotSatisfiable> & WebErrorStatus__requestedRangeNotSatisfiable & 45;// 45
static +expectationFailed: Class<WebErrorStatus__expectationFailed> & WebErrorStatus__expectationFailed & 46;// 46
static +internalServerError: Class<WebErrorStatus__internalServerError> & WebErrorStatus__internalServerError & 47;// 47
static +notImplemented: Class<WebErrorStatus__notImplemented> & WebErrorStatus__notImplemented & 48;// 48
static +badGateway: Class<WebErrorStatus__badGateway> & WebErrorStatus__badGateway & 49;// 49
static +serviceUnavailable: Class<WebErrorStatus__serviceUnavailable> & WebErrorStatus__serviceUnavailable & 50;// 50
static +gatewayTimeout: Class<WebErrorStatus__gatewayTimeout> & WebErrorStatus__gatewayTimeout & 51;// 51
static +httpVersionNotSupported: Class<WebErrorStatus__httpVersionNotSupported> & WebErrorStatus__httpVersionNotSupported & 52;// 52

}

declare class WebErrorStatus__unknown mixins WebErrorStatus {}
declare class WebErrorStatus__certificateCommonNameIsIncorrect mixins WebErrorStatus {}
declare class WebErrorStatus__certificateExpired mixins WebErrorStatus {}
declare class WebErrorStatus__certificateContainsErrors mixins WebErrorStatus {}
declare class WebErrorStatus__certificateRevoked mixins WebErrorStatus {}
declare class WebErrorStatus__certificateIsInvalid mixins WebErrorStatus {}
declare class WebErrorStatus__serverUnreachable mixins WebErrorStatus {}
declare class WebErrorStatus__timeout mixins WebErrorStatus {}
declare class WebErrorStatus__errorHttpInvalidServerResponse mixins WebErrorStatus {}
declare class WebErrorStatus__connectionAborted mixins WebErrorStatus {}
declare class WebErrorStatus__connectionReset mixins WebErrorStatus {}
declare class WebErrorStatus__disconnected mixins WebErrorStatus {}
declare class WebErrorStatus__httpToHttpsOnRedirection mixins WebErrorStatus {}
declare class WebErrorStatus__httpsToHttpOnRedirection mixins WebErrorStatus {}
declare class WebErrorStatus__cannotConnect mixins WebErrorStatus {}
declare class WebErrorStatus__hostNameNotResolved mixins WebErrorStatus {}
declare class WebErrorStatus__operationCanceled mixins WebErrorStatus {}
declare class WebErrorStatus__redirectFailed mixins WebErrorStatus {}
declare class WebErrorStatus__unexpectedStatusCode mixins WebErrorStatus {}
declare class WebErrorStatus__unexpectedRedirection mixins WebErrorStatus {}
declare class WebErrorStatus__unexpectedClientError mixins WebErrorStatus {}
declare class WebErrorStatus__unexpectedServerError mixins WebErrorStatus {}
declare class WebErrorStatus__multipleChoices mixins WebErrorStatus {}
declare class WebErrorStatus__movedPermanently mixins WebErrorStatus {}
declare class WebErrorStatus__found mixins WebErrorStatus {}
declare class WebErrorStatus__seeOther mixins WebErrorStatus {}
declare class WebErrorStatus__notModified mixins WebErrorStatus {}
declare class WebErrorStatus__useProxy mixins WebErrorStatus {}
declare class WebErrorStatus__temporaryRedirect mixins WebErrorStatus {}
declare class WebErrorStatus__badRequest mixins WebErrorStatus {}
declare class WebErrorStatus__unauthorized mixins WebErrorStatus {}
declare class WebErrorStatus__paymentRequired mixins WebErrorStatus {}
declare class WebErrorStatus__forbidden mixins WebErrorStatus {}
declare class WebErrorStatus__notFound mixins WebErrorStatus {}
declare class WebErrorStatus__methodNotAllowed mixins WebErrorStatus {}
declare class WebErrorStatus__notAcceptable mixins WebErrorStatus {}
declare class WebErrorStatus__proxyAuthenticationRequired mixins WebErrorStatus {}
declare class WebErrorStatus__requestTimeout mixins WebErrorStatus {}
declare class WebErrorStatus__conflict mixins WebErrorStatus {}
declare class WebErrorStatus__gone mixins WebErrorStatus {}
declare class WebErrorStatus__lengthRequired mixins WebErrorStatus {}
declare class WebErrorStatus__preconditionFailed mixins WebErrorStatus {}
declare class WebErrorStatus__requestEntityTooLarge mixins WebErrorStatus {}
declare class WebErrorStatus__requestUriTooLong mixins WebErrorStatus {}
declare class WebErrorStatus__unsupportedMediaType mixins WebErrorStatus {}
declare class WebErrorStatus__requestedRangeNotSatisfiable mixins WebErrorStatus {}
declare class WebErrorStatus__expectationFailed mixins WebErrorStatus {}
declare class WebErrorStatus__internalServerError mixins WebErrorStatus {}
declare class WebErrorStatus__notImplemented mixins WebErrorStatus {}
declare class WebErrorStatus__badGateway mixins WebErrorStatus {}
declare class WebErrorStatus__serviceUnavailable mixins WebErrorStatus {}
declare class WebErrorStatus__gatewayTimeout mixins WebErrorStatus {}
declare class WebErrorStatus__httpVersionNotSupported mixins WebErrorStatus {}

	declare export interface IWebErrorStatics {
getStatus(hresult: number): Windows$Windows$Web.WebErrorStatus
} 
	declare export class WebError  {
static getStatus(hresult: number): Windows$Windows$Web.WebErrorStatus
}
	declare module 'Syndication' {
        declare export interface RetrievalProgress {
bytesRetrieved: number,
totalBytesToRetrieve: number
} 
	declare export interface TransferProgress {
bytesSent: number,
totalBytesToSend: number,
bytesRetrieved: number,
totalBytesToRetrieve: number
} 
	declare export  class SyndicationFormat {
  constructor(...args: empty): mixed;
static +atom10: Class<SyndicationFormat__atom10> & SyndicationFormat__atom10 & 0;// 0
static +rss20: Class<SyndicationFormat__rss20> & SyndicationFormat__rss20 & 1;// 1
static +rss10: Class<SyndicationFormat__rss10> & SyndicationFormat__rss10 & 2;// 2
static +rss092: Class<SyndicationFormat__rss092> & SyndicationFormat__rss092 & 3;// 3
static +rss091: Class<SyndicationFormat__rss091> & SyndicationFormat__rss091 & 4;// 4
static +atom03: Class<SyndicationFormat__atom03> & SyndicationFormat__atom03 & 5;// 5

}

declare class SyndicationFormat__atom10 mixins SyndicationFormat {}
declare class SyndicationFormat__rss20 mixins SyndicationFormat {}
declare class SyndicationFormat__rss10 mixins SyndicationFormat {}
declare class SyndicationFormat__rss092 mixins SyndicationFormat {}
declare class SyndicationFormat__rss091 mixins SyndicationFormat {}
declare class SyndicationFormat__atom03 mixins SyndicationFormat {}

	declare export  class SyndicationErrorStatus {
  constructor(...args: empty): mixed;
static +unknown: Class<SyndicationErrorStatus__unknown> & SyndicationErrorStatus__unknown & 0;// 0
static +missingRequiredElement: Class<SyndicationErrorStatus__missingRequiredElement> & SyndicationErrorStatus__missingRequiredElement & 1;// 1
static +missingRequiredAttribute: Class<SyndicationErrorStatus__missingRequiredAttribute> & SyndicationErrorStatus__missingRequiredAttribute & 2;// 2
static +invalidXml: Class<SyndicationErrorStatus__invalidXml> & SyndicationErrorStatus__invalidXml & 3;// 3
static +unexpectedContent: Class<SyndicationErrorStatus__unexpectedContent> & SyndicationErrorStatus__unexpectedContent & 4;// 4
static +unsupportedFormat: Class<SyndicationErrorStatus__unsupportedFormat> & SyndicationErrorStatus__unsupportedFormat & 5;// 5

}

declare class SyndicationErrorStatus__unknown mixins SyndicationErrorStatus {}
declare class SyndicationErrorStatus__missingRequiredElement mixins SyndicationErrorStatus {}
declare class SyndicationErrorStatus__missingRequiredAttribute mixins SyndicationErrorStatus {}
declare class SyndicationErrorStatus__invalidXml mixins SyndicationErrorStatus {}
declare class SyndicationErrorStatus__unexpectedContent mixins SyndicationErrorStatus {}
declare class SyndicationErrorStatus__unsupportedFormat mixins SyndicationErrorStatus {}

	declare export interface ISyndicationAttribute {
name: string,
namespace: string,
value: string
} 
	declare export class SyndicationAttribute mixins undefined.ISyndicationAttribute {
constructor(attributeName: string, attributeNamespace: string, attributeValue: string): this;
constructor(): this;
name: string;
namespace: string;
value: string
}
	declare export interface ISyndicationAttributeFactory {
createSyndicationAttribute(
attributeName: string,
attributeNamespace: string,
attributeValue: string): Windows$Windows$Web.Syndication.SyndicationAttribute
} 
	declare export interface ISyndicationNode {
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>,
baseUri: Windows$Windows$Foundation.Uri,
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>,
language: string,
nodeName: string,
nodeNamespace: string,
nodeValue: string,
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
} 
	declare export class SyndicationNode mixins undefined.ISyndicationNode {
constructor(nodeName: string, nodeNamespace: string, nodeValue: string): this;
constructor(): this;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export interface ISyndicationNodeFactory {
createSyndicationNode(
nodeName: string,
nodeNamespace: string,
nodeValue: string): Windows$Windows$Web.Syndication.SyndicationNode
} 
	declare export interface ISyndicationGenerator {
text: string,
uri: Windows$Windows$Foundation.Uri,
version: string
} 
	declare export class SyndicationGenerator mixins undefined.ISyndicationGenerator, undefined.ISyndicationNode {
constructor(text: string): this;
constructor(): this;
text: string;
uri: Windows$Windows$Foundation.Uri;
version: string;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export interface ISyndicationGeneratorFactory {
createSyndicationGenerator(text: string): Windows$Windows$Web.Syndication.SyndicationGenerator
} 
	declare export type ISyndicationText = {
text: string,
type: string,
xml: Windows$Windows$Data.Xml.Dom.XmlDocument
} & undefined.ISyndicationNode

	declare export class SyndicationText mixins undefined.ISyndicationText, undefined.ISyndicationNode {
constructor(text: string): this;
constructor(text: string, type: Windows$Windows$Web.Syndication.SyndicationTextType): this;
constructor(): this;
text: string;
type: string;
xml: Windows$Windows$Data.Xml.Dom.XmlDocument;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export  class SyndicationTextType {
  constructor(...args: empty): mixed;
static +text: Class<SyndicationTextType__text> & SyndicationTextType__text & 0;// 0
static +html: Class<SyndicationTextType__html> & SyndicationTextType__html & 1;// 1
static +xhtml: Class<SyndicationTextType__xhtml> & SyndicationTextType__xhtml & 2;// 2

}

declare class SyndicationTextType__text mixins SyndicationTextType {}
declare class SyndicationTextType__html mixins SyndicationTextType {}
declare class SyndicationTextType__xhtml mixins SyndicationTextType {}

	declare export interface ISyndicationTextFactory {
createSyndicationText(text: string): Windows$Windows$Web.Syndication.SyndicationText,
createSyndicationText(
text: string,
type: Windows$Windows$Web.Syndication.SyndicationTextType): Windows$Windows$Web.Syndication.SyndicationText
} 
	declare export type ISyndicationContent = {
sourceUri: Windows$Windows$Foundation.Uri
} & undefined.ISyndicationText & undefined.ISyndicationNode

	declare export class SyndicationContent mixins undefined.ISyndicationText, undefined.ISyndicationNode, undefined.ISyndicationContent {
constructor(text: string, type: Windows$Windows$Web.Syndication.SyndicationTextType): this;
constructor(sourceUri: Windows$Windows$Foundation.Uri): this;
constructor(): this;
text: string;
type: string;
xml: Windows$Windows$Data.Xml.Dom.XmlDocument;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
sourceUri: Windows$Windows$Foundation.Uri;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export interface ISyndicationContentFactory {
createSyndicationContent(
text: string,
type: Windows$Windows$Web.Syndication.SyndicationTextType): Windows$Windows$Web.Syndication.SyndicationContent,
createSyndicationContent(
sourceUri: Windows$Windows$Foundation.Uri): Windows$Windows$Web.Syndication.SyndicationContent
} 
	declare export type ISyndicationLink = {
length: number,
mediaType: string,
relationship: string,
resourceLanguage: string,
title: string,
uri: Windows$Windows$Foundation.Uri
} & undefined.ISyndicationNode

	declare export class SyndicationLink mixins undefined.ISyndicationLink, undefined.ISyndicationNode {
constructor(uri: Windows$Windows$Foundation.Uri): this;
constructor(uri: Windows$Windows$Foundation.Uri, relationship: string, title: string, mediaType: string, length: number): this;
constructor(): this;
length: number;
mediaType: string;
relationship: string;
resourceLanguage: string;
title: string;
uri: Windows$Windows$Foundation.Uri;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export interface ISyndicationLinkFactory {
createSyndicationLink(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Web.Syndication.SyndicationLink,
createSyndicationLink(
uri: Windows$Windows$Foundation.Uri,
relationship: string,
title: string,
mediaType: string,
length: number): Windows$Windows$Web.Syndication.SyndicationLink
} 
	declare export type ISyndicationPerson = {
email: string,
name: string,
uri: Windows$Windows$Foundation.Uri
} & undefined.ISyndicationNode

	declare export class SyndicationPerson mixins undefined.ISyndicationPerson, undefined.ISyndicationNode {
constructor(name: string): this;
constructor(name: string, email: string, uri: Windows$Windows$Foundation.Uri): this;
constructor(): this;
email: string;
name: string;
uri: Windows$Windows$Foundation.Uri;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export interface ISyndicationPersonFactory {
createSyndicationPerson(name: string): Windows$Windows$Web.Syndication.SyndicationPerson,
createSyndicationPerson(
name: string,
email: string,
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Web.Syndication.SyndicationPerson
} 
	declare export type ISyndicationCategory = {
label: string,
scheme: string,
term: string
} & undefined.ISyndicationNode

	declare export class SyndicationCategory mixins undefined.ISyndicationCategory, undefined.ISyndicationNode {
constructor(term: string): this;
constructor(term: string, scheme: string, label: string): this;
constructor(): this;
label: string;
scheme: string;
term: string;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export interface ISyndicationCategoryFactory {
createSyndicationCategory(term: string): Windows$Windows$Web.Syndication.SyndicationCategory,
createSyndicationCategory(
term: string,
scheme: string,
label: string): Windows$Windows$Web.Syndication.SyndicationCategory
} 
	declare export type ISyndicationItem = {
authors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>,
categories: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationCategory>,
commentsUri: Windows$Windows$Foundation.Uri,
content: Windows$Windows$Web.Syndication.SyndicationContent,
contributors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>,
eTag: string,
editMediaUri: Windows$Windows$Foundation.Uri,
editUri: Windows$Windows$Foundation.Uri,
id: string,
itemUri: Windows$Windows$Foundation.Uri,
lastUpdatedTime: Date,
links: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationLink>,
publishedDate: Date,
rights: Windows$Windows$Web.Syndication.ISyndicationText,
source: Windows$Windows$Web.Syndication.SyndicationFeed,
summary: Windows$Windows$Web.Syndication.ISyndicationText,
title: Windows$Windows$Web.Syndication.ISyndicationText,
load(item: string): void,
loadFromXml(itemDocument: Windows$Windows$Data.Xml.Dom.XmlDocument): void
} & undefined.ISyndicationNode

	declare export class SyndicationFeed mixins undefined.ISyndicationFeed, undefined.ISyndicationNode {
constructor(title: string, subtitle: string, uri: Windows$Windows$Foundation.Uri): this;
constructor(): this;
authors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>;
categories: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationCategory>;
contributors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>;
firstUri: Windows$Windows$Foundation.Uri;
generator: Windows$Windows$Web.Syndication.SyndicationGenerator;
iconUri: Windows$Windows$Foundation.Uri;
id: string;
imageUri: Windows$Windows$Foundation.Uri;
items: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationItem>;
lastUpdatedTime: Date;
lastUri: Windows$Windows$Foundation.Uri;
links: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationLink>;
nextUri: Windows$Windows$Foundation.Uri;
previousUri: Windows$Windows$Foundation.Uri;
rights: Windows$Windows$Web.Syndication.ISyndicationText;
sourceFormat: Windows$Windows$Web.Syndication.SyndicationFormat;
subtitle: Windows$Windows$Web.Syndication.ISyndicationText;
title: Windows$Windows$Web.Syndication.ISyndicationText;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
load(feed: string): void;
loadFromXml(feedDocument: Windows$Windows$Data.Xml.Dom.XmlDocument): void;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export class SyndicationItem mixins undefined.ISyndicationItem, undefined.ISyndicationNode {
constructor(title: string, content: Windows$Windows$Web.Syndication.SyndicationContent, uri: Windows$Windows$Foundation.Uri): this;
constructor(): this;
authors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>;
categories: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationCategory>;
commentsUri: Windows$Windows$Foundation.Uri;
content: Windows$Windows$Web.Syndication.SyndicationContent;
contributors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>;
eTag: string;
editMediaUri: Windows$Windows$Foundation.Uri;
editUri: Windows$Windows$Foundation.Uri;
id: string;
itemUri: Windows$Windows$Foundation.Uri;
lastUpdatedTime: Date;
links: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationLink>;
publishedDate: Date;
rights: Windows$Windows$Web.Syndication.ISyndicationText;
source: Windows$Windows$Web.Syndication.SyndicationFeed;
summary: Windows$Windows$Web.Syndication.ISyndicationText;
title: Windows$Windows$Web.Syndication.ISyndicationText;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
load(item: string): void;
loadFromXml(itemDocument: Windows$Windows$Data.Xml.Dom.XmlDocument): void;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export interface ISyndicationItemFactory {
createSyndicationItem(
title: string,
content: Windows$Windows$Web.Syndication.SyndicationContent,
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Web.Syndication.SyndicationItem
} 
	declare export type ISyndicationFeed = {
authors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>,
categories: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationCategory>,
contributors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>,
firstUri: Windows$Windows$Foundation.Uri,
generator: Windows$Windows$Web.Syndication.SyndicationGenerator,
iconUri: Windows$Windows$Foundation.Uri,
id: string,
imageUri: Windows$Windows$Foundation.Uri,
items: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationItem>,
lastUpdatedTime: Date,
lastUri: Windows$Windows$Foundation.Uri,
links: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationLink>,
nextUri: Windows$Windows$Foundation.Uri,
previousUri: Windows$Windows$Foundation.Uri,
rights: Windows$Windows$Web.Syndication.ISyndicationText,
sourceFormat: Windows$Windows$Web.Syndication.SyndicationFormat,
subtitle: Windows$Windows$Web.Syndication.ISyndicationText,
title: Windows$Windows$Web.Syndication.ISyndicationText,
load(feed: string): void,
loadFromXml(feedDocument: Windows$Windows$Data.Xml.Dom.XmlDocument): void
} & undefined.ISyndicationNode

	declare export interface ISyndicationFeedFactory {
createSyndicationFeed(
title: string,
subtitle: string,
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Web.Syndication.SyndicationFeed
} 
	declare export interface ISyndicationClient {
bypassCacheOnRetrieve: boolean,
maxResponseBufferSize: number,
proxyCredential: Windows$Windows$Security.Credentials.PasswordCredential,
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential,
timeout: number,
setRequestHeader(name: string, value: string): void,
retrieveFeedAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationFeed, Windows$Windows$Web.Syndication.RetrievalProgress>
} 
	declare export class SyndicationClient mixins undefined.ISyndicationClient {
constructor(serverCredential: Windows$Windows$Security.Credentials.PasswordCredential): this;
constructor(): this;
bypassCacheOnRetrieve: boolean;
maxResponseBufferSize: number;
proxyCredential: Windows$Windows$Security.Credentials.PasswordCredential;
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential;
timeout: number;
setRequestHeader(name: string, value: string): void;
retrieveFeedAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationFeed, Windows$Windows$Web.Syndication.RetrievalProgress>
}
	declare export interface ISyndicationClientFactory {
createSyndicationClient(
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential): Windows$Windows$Web.Syndication.SyndicationClient
} 
	declare export interface ISyndicationErrorStatics {
getStatus(hresult: number): Windows$Windows$Web.Syndication.SyndicationErrorStatus
} 
	declare export class SyndicationError  {
static getStatus(hresult: number): Windows$Windows$Web.Syndication.SyndicationErrorStatus
}
    }

	declare module 'AtomPub' {
        declare export type IResourceCollection = {
accepts: Windows$Windows$Foundation.Collections.IVectorView<string>,
categories: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Web.Syndication.SyndicationCategory>,
title: Windows$Windows$Web.Syndication.ISyndicationText,
uri: Windows$Windows$Foundation.Uri
} & undefined.ISyndicationNode

	declare export class ResourceCollection mixins undefined.IResourceCollection, undefined.ISyndicationNode {
accepts: Windows$Windows$Foundation.Collections.IVectorView<string>;
categories: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Web.Syndication.SyndicationCategory>;
title: Windows$Windows$Web.Syndication.ISyndicationText;
uri: Windows$Windows$Foundation.Uri;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export type IWorkspace = {
collections: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Web.AtomPub.ResourceCollection>,
title: Windows$Windows$Web.Syndication.ISyndicationText
} & undefined.ISyndicationNode

	declare export class Workspace mixins undefined.IWorkspace, undefined.ISyndicationNode {
collections: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Web.AtomPub.ResourceCollection>;
title: Windows$Windows$Web.Syndication.ISyndicationText;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export type IServiceDocument = {
workspaces: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Web.AtomPub.Workspace>
} & undefined.ISyndicationNode

	declare export class ServiceDocument mixins undefined.IServiceDocument, undefined.ISyndicationNode {
workspaces: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Web.AtomPub.Workspace>;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export type IAtomPubClient = {
retrieveServiceDocumentAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.AtomPub.ServiceDocument, Windows$Windows$Web.Syndication.RetrievalProgress>,
retrieveMediaResourceAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Storage.Streams.IInputStream, Windows$Windows$Web.Syndication.RetrievalProgress>,
retrieveResourceAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationItem, Windows$Windows$Web.Syndication.RetrievalProgress>,
createResourceAsync(
uri: Windows$Windows$Foundation.Uri,
description: string,
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationItem, Windows$Windows$Web.Syndication.TransferProgress>,
createMediaResourceAsync(
uri: Windows$Windows$Foundation.Uri,
mediaType: string,
description: string,
mediaStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationItem, Windows$Windows$Web.Syndication.TransferProgress>,
updateMediaResourceAsync(
uri: Windows$Windows$Foundation.Uri,
mediaType: string,
mediaStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>,
updateResourceAsync(
uri: Windows$Windows$Foundation.Uri,
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>,
updateResourceItemAsync(
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>,
deleteResourceAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>,
deleteResourceItemAsync(
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>,
cancelAsyncOperations(): void
} & undefined.ISyndicationClient

	declare export class AtomPubClient mixins undefined.IAtomPubClient, undefined.ISyndicationClient {
constructor(serverCredential: Windows$Windows$Security.Credentials.PasswordCredential): this;
constructor(): this;
bypassCacheOnRetrieve: boolean;
maxResponseBufferSize: number;
proxyCredential: Windows$Windows$Security.Credentials.PasswordCredential;
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential;
timeout: number;
retrieveServiceDocumentAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.AtomPub.ServiceDocument, Windows$Windows$Web.Syndication.RetrievalProgress>;
retrieveMediaResourceAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Storage.Streams.IInputStream, Windows$Windows$Web.Syndication.RetrievalProgress>;
retrieveResourceAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationItem, Windows$Windows$Web.Syndication.RetrievalProgress>;
createResourceAsync(
uri: Windows$Windows$Foundation.Uri,
description: string,
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationItem, Windows$Windows$Web.Syndication.TransferProgress>;
createMediaResourceAsync(
uri: Windows$Windows$Foundation.Uri,
mediaType: string,
description: string,
mediaStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationItem, Windows$Windows$Web.Syndication.TransferProgress>;
updateMediaResourceAsync(
uri: Windows$Windows$Foundation.Uri,
mediaType: string,
mediaStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>;
updateResourceAsync(
uri: Windows$Windows$Foundation.Uri,
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>;
updateResourceItemAsync(
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>;
deleteResourceAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>;
deleteResourceItemAsync(
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>;
cancelAsyncOperations(): void;
setRequestHeader(name: string, value: string): void;
retrieveFeedAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationFeed, Windows$Windows$Web.Syndication.RetrievalProgress>
}
	declare export interface IAtomPubClientFactory {
createAtomPubClientWithCredentials(
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential): Windows$Windows$Web.AtomPub.AtomPubClient
} 
    }

    }

    }

	declare module 'Credentials' {
        declare module 'UI' {
        declare export  class AuthenticationProtocol {
  constructor(...args: empty): mixed;
static +basic: Class<AuthenticationProtocol__basic> & AuthenticationProtocol__basic & 0;// 0
static +digest: Class<AuthenticationProtocol__digest> & AuthenticationProtocol__digest & 1;// 1
static +ntlm: Class<AuthenticationProtocol__ntlm> & AuthenticationProtocol__ntlm & 2;// 2
static +kerberos: Class<AuthenticationProtocol__kerberos> & AuthenticationProtocol__kerberos & 3;// 3
static +negotiate: Class<AuthenticationProtocol__negotiate> & AuthenticationProtocol__negotiate & 4;// 4
static +credSsp: Class<AuthenticationProtocol__credSsp> & AuthenticationProtocol__credSsp & 5;// 5
static +custom: Class<AuthenticationProtocol__custom> & AuthenticationProtocol__custom & 6;// 6

}

declare class AuthenticationProtocol__basic mixins AuthenticationProtocol {}
declare class AuthenticationProtocol__digest mixins AuthenticationProtocol {}
declare class AuthenticationProtocol__ntlm mixins AuthenticationProtocol {}
declare class AuthenticationProtocol__kerberos mixins AuthenticationProtocol {}
declare class AuthenticationProtocol__negotiate mixins AuthenticationProtocol {}
declare class AuthenticationProtocol__credSsp mixins AuthenticationProtocol {}
declare class AuthenticationProtocol__custom mixins AuthenticationProtocol {}

	declare export  class CredentialSaveOption {
  constructor(...args: empty): mixed;
static +unselected: Class<CredentialSaveOption__unselected> & CredentialSaveOption__unselected & 0;// 0
static +selected: Class<CredentialSaveOption__selected> & CredentialSaveOption__selected & 1;// 1
static +hidden: Class<CredentialSaveOption__hidden> & CredentialSaveOption__hidden & 2;// 2

}

declare class CredentialSaveOption__unselected mixins CredentialSaveOption {}
declare class CredentialSaveOption__selected mixins CredentialSaveOption {}
declare class CredentialSaveOption__hidden mixins CredentialSaveOption {}

	declare export interface ICredentialPickerOptions {
alwaysDisplayDialog: boolean,
authenticationProtocol: Windows$Windows$Security.Credentials.Windows$UI.AuthenticationProtocol,
callerSavesCredential: boolean,
caption: string,
credentialSaveOption: Windows$Windows$Security.Credentials.Windows$UI.CredentialSaveOption,
customAuthenticationProtocol: string,
errorCode: number,
message: string,
previousCredential: Windows$Windows$Storage.Streams.IBuffer,
targetName: string
} 
	declare export class CredentialPickerOptions mixins undefined.ICredentialPickerOptions {
alwaysDisplayDialog: boolean;
authenticationProtocol: Windows$Windows$Security.Credentials.Windows$UI.AuthenticationProtocol;
callerSavesCredential: boolean;
caption: string;
credentialSaveOption: Windows$Windows$Security.Credentials.Windows$UI.CredentialSaveOption;
customAuthenticationProtocol: string;
errorCode: number;
message: string;
previousCredential: Windows$Windows$Storage.Streams.IBuffer;
targetName: string
}
	declare export interface ICredentialPickerStatics {
pickAsync(
options: Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerResults>,
pickAsync(
targetName: string,
message: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerResults>,
pickAsync(
targetName: string,
message: string,
caption: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerResults>
} 
	declare export class CredentialPickerResults mixins undefined.ICredentialPickerResults {
credential: Windows$Windows$Storage.Streams.IBuffer;
credentialDomainName: string;
credentialPassword: string;
credentialSaveOption: Windows$Windows$Security.Credentials.Windows$UI.CredentialSaveOption;
credentialSaved: boolean;
credentialUserName: string;
errorCode: number
}
	declare export class CredentialPicker  {
static pickAsync(
options: Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerResults>;
static pickAsync(
targetName: string,
message: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerResults>;
static pickAsync(
targetName: string,
message: string,
caption: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerResults>
}
	declare export interface ICredentialPickerResults {
credential: Windows$Windows$Storage.Streams.IBuffer,
credentialDomainName: string,
credentialPassword: string,
credentialSaveOption: Windows$Windows$Security.Credentials.Windows$UI.CredentialSaveOption,
credentialSaved: boolean,
credentialUserName: string,
errorCode: number
} 
	declare module 'ApplicationSettings' {
        declare export interface ISettingsCommandFactory {
create(
settingsCommandId: any,
label: string,
handler: Windows$Windows$UI.Popups.UICommandInvokedHandler): Windows$Windows$UI.ApplicationSettings.SettingsCommand
} 
	declare export class SettingsCommand mixins undefined.IUICommand {
constructor(settingsCommandId: any, label: string, handler: Windows$Windows$UI.Popups.UICommandInvokedHandler): this;
id: any;
invoked: Windows$Windows$UI.Popups.UICommandInvokedHandler;
label: string
}
	declare export interface ISettingsPaneCommandsRequest {
applicationCommands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.ApplicationSettings.SettingsCommand>
} 
	declare export class SettingsPaneCommandsRequest mixins undefined.ISettingsPaneCommandsRequest {
applicationCommands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.ApplicationSettings.SettingsCommand>
}
	declare export interface ISettingsPaneCommandsRequestedEventArgs {
request: Windows$Windows$UI.ApplicationSettings.SettingsPaneCommandsRequest
} 
	declare export class SettingsPaneCommandsRequestedEventArgs mixins undefined.ISettingsPaneCommandsRequestedEventArgs {
request: Windows$Windows$UI.ApplicationSettings.SettingsPaneCommandsRequest
}
	declare export  class SettingsEdgeLocation {
  constructor(...args: empty): mixed;
static +right: Class<SettingsEdgeLocation__right> & SettingsEdgeLocation__right & 0;// 0
static +left: Class<SettingsEdgeLocation__left> & SettingsEdgeLocation__left & 1;// 1

}

declare class SettingsEdgeLocation__right mixins SettingsEdgeLocation {}
declare class SettingsEdgeLocation__left mixins SettingsEdgeLocation {}

	declare export interface ISettingsPaneStatics {
edge: Windows$Windows$UI.ApplicationSettings.SettingsEdgeLocation,
getForCurrentView(): Windows$Windows$UI.ApplicationSettings.SettingsPane,
show(): void
} 
	declare export class SettingsPane mixins undefined.ISettingsPane {
oncommandsrequested: any;
static edge: Windows$Windows$UI.ApplicationSettings.SettingsEdgeLocation;
static getForCurrentView(): Windows$Windows$UI.ApplicationSettings.SettingsPane;
static show(): void
}
	declare export interface ISettingsPane {
oncommandsrequested: any
} 
    }

	declare module 'ViewManagement' {
        declare export  class ViewSizePreference {
  constructor(...args: empty): mixed;
static +default: Class<ViewSizePreference__default> & ViewSizePreference__default & 0;// 0
static +useLess: Class<ViewSizePreference__useLess> & ViewSizePreference__useLess & 1;// 1
static +useHalf: Class<ViewSizePreference__useHalf> & ViewSizePreference__useHalf & 2;// 2
static +useMore: Class<ViewSizePreference__useMore> & ViewSizePreference__useMore & 3;// 3
static +useMinimum: Class<ViewSizePreference__useMinimum> & ViewSizePreference__useMinimum & 4;// 4
static +useNone: Class<ViewSizePreference__useNone> & ViewSizePreference__useNone & 5;// 5

}

declare class ViewSizePreference__default mixins ViewSizePreference {}
declare class ViewSizePreference__useLess mixins ViewSizePreference {}
declare class ViewSizePreference__useHalf mixins ViewSizePreference {}
declare class ViewSizePreference__useMore mixins ViewSizePreference {}
declare class ViewSizePreference__useMinimum mixins ViewSizePreference {}
declare class ViewSizePreference__useNone mixins ViewSizePreference {}

	declare export  class ApplicationViewState {
  constructor(...args: empty): mixed;
static +fullScreenLandscape: Class<ApplicationViewState__fullScreenLandscape> & ApplicationViewState__fullScreenLandscape & 0;// 0
static +filled: Class<ApplicationViewState__filled> & ApplicationViewState__filled & 1;// 1
static +snapped: Class<ApplicationViewState__snapped> & ApplicationViewState__snapped & 2;// 2
static +fullScreenPortrait: Class<ApplicationViewState__fullScreenPortrait> & ApplicationViewState__fullScreenPortrait & 3;// 3

}

declare class ApplicationViewState__fullScreenLandscape mixins ApplicationViewState {}
declare class ApplicationViewState__filled mixins ApplicationViewState {}
declare class ApplicationViewState__snapped mixins ApplicationViewState {}
declare class ApplicationViewState__fullScreenPortrait mixins ApplicationViewState {}

	
/**
 * Defines an instance of a window (app view) and the information that describes it.
 */
declare export class ApplicationView  {

/**
 * Gets the window (app view) for the current app.
 */
static getForCurrentView(): ApplicationView;

/**
 * Attempts to unsnap a previously snapped app. This call will only succeed when the app is running in the foreground.
 */
static tryUnsnap(): boolean;

/**
 * Gets the state of the current app view.
 */
static value: Windows$Windows$UI.ViewManagement.ApplicationViewState;

/**
 * Indicates whether the app terminates when the last window is closed.
 */
static terminateAppOnFinalViewClose: boolean;

/**
 * Gets the current orientation of the window (app view) with respect to the display.
 */
orientation: ApplicationViewOrientation;

/**
 * Gets or sets the displayed title of the window.
 */
title: string;

/**
 * Gets or sets whether screen capture is enabled for the window (app view).
 */
isScreenCaptureEnabled: boolean;

/**
 * Gets whether the window (app view) is on the Windows lock screen.
 */
isOnLockScreen: boolean;

/**
 * Gets whether the window(app view) is full screen or not.
 */
isFullScreen: boolean;

/**
 * Gets the current ID of the window (app view) .
 */
id: number;

/**
 * Gets whether the current window (app view) is adjacent to the right edge of the screen.
 */
adjacentToRightDisplayEdge: boolean;

/**
 * Gets whether the current window (app view) is adjacent to the left edge of the screen.
 */
adjacentToLeftDisplayEdge: number;

/**
 * Gets the title bar of the app.
 */
titleBar: ViewManagement$ApplicationViewTitleBar
}
	
/**
 * Defines the set of display orientation modes for a window (app view).
 */
declare export  class ApplicationViewOrientation {
  constructor(...args: empty): mixed;
static +landscape: Class<ApplicationViewOrientation__landscape> & ApplicationViewOrientation__landscape & 0;// 0
static +portrait: Class<ApplicationViewOrientation__portrait> & ApplicationViewOrientation__portrait & 1;// 1

}

declare class ApplicationViewOrientation__landscape mixins ApplicationViewOrientation {}
declare class ApplicationViewOrientation__portrait mixins ApplicationViewOrientation {}

	declare export interface IInputPaneVisibilityEventArgs {
ensuredFocusedElementInView: boolean,
occludedRect: Windows$Windows$Foundation.Rect
} 
	declare export class InputPaneVisibilityEventArgs mixins undefined.IInputPaneVisibilityEventArgs {
ensuredFocusedElementInView: boolean;
occludedRect: Windows$Windows$Foundation.Rect
}
	declare export interface IInputPane {
occludedRect: Windows$Windows$Foundation.Rect,
onshowing: any,
onhiding: any
} 
	declare export class InputPane mixins undefined.IInputPane {
occludedRect: Windows$Windows$Foundation.Rect;
onshowing: any;
onhiding: any;
static getForCurrentView(): Windows$Windows$UI.ViewManagement.InputPane
}
	declare export interface IInputPaneStatics {
getForCurrentView(): Windows$Windows$UI.ViewManagement.InputPane
} 
	declare export  class HandPreference {
  constructor(...args: empty): mixed;
static +leftHanded: Class<HandPreference__leftHanded> & HandPreference__leftHanded & 0;// 0
static +rightHanded: Class<HandPreference__rightHanded> & HandPreference__rightHanded & 1;// 1

}

declare class HandPreference__leftHanded mixins HandPreference {}
declare class HandPreference__rightHanded mixins HandPreference {}

	declare export  class UIElementType {
  constructor(...args: empty): mixed;
static +activeCaption: Class<UIElementType__activeCaption> & UIElementType__activeCaption & 0;// 0
static +background: Class<UIElementType__background> & UIElementType__background & 1;// 1
static +buttonFace: Class<UIElementType__buttonFace> & UIElementType__buttonFace & 2;// 2
static +buttonText: Class<UIElementType__buttonText> & UIElementType__buttonText & 3;// 3
static +captionText: Class<UIElementType__captionText> & UIElementType__captionText & 4;// 4
static +grayText: Class<UIElementType__grayText> & UIElementType__grayText & 5;// 5
static +highlight: Class<UIElementType__highlight> & UIElementType__highlight & 6;// 6
static +highlightText: Class<UIElementType__highlightText> & UIElementType__highlightText & 7;// 7
static +hotlight: Class<UIElementType__hotlight> & UIElementType__hotlight & 8;// 8
static +inactiveCaption: Class<UIElementType__inactiveCaption> & UIElementType__inactiveCaption & 9;// 9
static +inactiveCaptionText: Class<UIElementType__inactiveCaptionText> & UIElementType__inactiveCaptionText & 10;// 10
static +window: Class<UIElementType__window> & UIElementType__window & 11;// 11
static +windowText: Class<UIElementType__windowText> & UIElementType__windowText & 12;// 12

}

declare class UIElementType__activeCaption mixins UIElementType {}
declare class UIElementType__background mixins UIElementType {}
declare class UIElementType__buttonFace mixins UIElementType {}
declare class UIElementType__buttonText mixins UIElementType {}
declare class UIElementType__captionText mixins UIElementType {}
declare class UIElementType__grayText mixins UIElementType {}
declare class UIElementType__highlight mixins UIElementType {}
declare class UIElementType__highlightText mixins UIElementType {}
declare class UIElementType__hotlight mixins UIElementType {}
declare class UIElementType__inactiveCaption mixins UIElementType {}
declare class UIElementType__inactiveCaptionText mixins UIElementType {}
declare class UIElementType__window mixins UIElementType {}
declare class UIElementType__windowText mixins UIElementType {}

	declare export interface IAccessibilitySettings {
highContrast: boolean,
highContrastScheme: string,
onhighcontrastchanged: any
} 
	declare export class AccessibilitySettings mixins undefined.IAccessibilitySettings {
highContrast: boolean;
highContrastScheme: string;
onhighcontrastchanged: any
}
	declare export interface IUISettings {
animationsEnabled: boolean,
caretBlinkRate: number,
caretBrowsingEnabled: boolean,
caretWidth: number,
cursorSize: Windows$Windows$Foundation.Size,
doubleClickTime: number,
handPreference: Windows$Windows$UI.ViewManagement.HandPreference,
messageDuration: number,
mouseHoverTime: number,
scrollBarArrowSize: Windows$Windows$Foundation.Size,
scrollBarSize: Windows$Windows$Foundation.Size,
scrollBarThumbBoxSize: Windows$Windows$Foundation.Size,
uIElementColor(
desiredElement: Windows$Windows$UI.ViewManagement.UIElementType): Windows$Windows$UI.Color
} 
	declare export class UISettings mixins undefined.IUISettings {
animationsEnabled: boolean;
caretBlinkRate: number;
caretBrowsingEnabled: boolean;
caretWidth: number;
cursorSize: Windows$Windows$Foundation.Size;
doubleClickTime: number;
handPreference: Windows$Windows$UI.ViewManagement.HandPreference;
messageDuration: number;
mouseHoverTime: number;
scrollBarArrowSize: Windows$Windows$Foundation.Size;
scrollBarSize: Windows$Windows$Foundation.Size;
scrollBarThumbBoxSize: Windows$Windows$Foundation.Size;
uIElementColor(
desiredElement: Windows$Windows$UI.ViewManagement.UIElementType): Windows$Windows$UI.Color
}
    }

	declare module 'Input' {
        declare export  class PointerDeviceType {
  constructor(...args: empty): mixed;
static +touch: Class<PointerDeviceType__touch> & PointerDeviceType__touch & 0;// 0
static +pen: Class<PointerDeviceType__pen> & PointerDeviceType__pen & 1;// 1
static +mouse: Class<PointerDeviceType__mouse> & PointerDeviceType__mouse & 2;// 2

}

declare class PointerDeviceType__touch mixins PointerDeviceType {}
declare class PointerDeviceType__pen mixins PointerDeviceType {}
declare class PointerDeviceType__mouse mixins PointerDeviceType {}

	declare export interface PointerDeviceUsage {
usagePage: number,
usage: number,
minLogical: number,
maxLogical: number,
minPhysical: number,
maxPhysical: number,
unit: number,
physicalMultiplier: number
} 
	declare export interface MouseDelta {
x: number,
y: number
} 
	declare export interface IMouseCapabilities {
horizontalWheelPresent: number,
mousePresent: number,
numberOfButtons: number,
swapButtons: number,
verticalWheelPresent: number
} 
	declare export interface IKeyboardCapabilities {
keyboardPresent: number
} 
	declare export interface ITouchCapabilities {
contacts: number,
touchPresent: number
} 
	declare export interface IPointerDeviceStatics {
getPointerDevice(pointerId: number): Windows$Windows$Devices.Input.PointerDevice,
getPointerDevices(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDevice>
} 
	declare export class PointerDevice mixins undefined.IPointerDevice {
isIntegrated: boolean;
maxContacts: number;
physicalDeviceRect: Windows$Windows$Foundation.Rect;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
screenRect: Windows$Windows$Foundation.Rect;
supportedUsages: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDeviceUsage>;
static getPointerDevice(pointerId: number): Windows$Windows$Devices.Input.PointerDevice;
static getPointerDevices(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDevice>
}
	declare export interface IPointerDevice {
isIntegrated: boolean,
maxContacts: number,
physicalDeviceRect: Windows$Windows$Foundation.Rect,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
screenRect: Windows$Windows$Foundation.Rect,
supportedUsages: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDeviceUsage>
} 
	declare export interface IMouseEventArgs {
mouseDelta: Windows$Windows$Devices.Input.MouseDelta
} 
	declare export interface IMouseDevice {
onmousemoved: any
} 
	declare export class MouseDevice mixins undefined.IMouseDevice {
onmousemoved: any;
static getForCurrentView(): Windows$Windows$Devices.Input.MouseDevice
}
	declare export class MouseEventArgs mixins undefined.IMouseEventArgs {
mouseDelta: Windows$Windows$Devices.Input.MouseDelta
}
	declare export interface IMouseDeviceStatics {
getForCurrentView(): Windows$Windows$Devices.Input.MouseDevice
} 
	declare export class MouseCapabilities mixins undefined.IMouseCapabilities {
horizontalWheelPresent: number;
mousePresent: number;
numberOfButtons: number;
swapButtons: number;
verticalWheelPresent: number
}
	declare export class KeyboardCapabilities mixins undefined.IKeyboardCapabilities {
keyboardPresent: number
}
	declare export class TouchCapabilities mixins undefined.ITouchCapabilities {
contacts: number;
touchPresent: number
}
	declare export  class EdgeGestureKind {
  constructor(...args: empty): mixed;
static +touch: Class<EdgeGestureKind__touch> & EdgeGestureKind__touch & 0;// 0
static +keyboard: Class<EdgeGestureKind__keyboard> & EdgeGestureKind__keyboard & 1;// 1
static +mouse: Class<EdgeGestureKind__mouse> & EdgeGestureKind__mouse & 2;// 2

}

declare class EdgeGestureKind__touch mixins EdgeGestureKind {}
declare class EdgeGestureKind__keyboard mixins EdgeGestureKind {}
declare class EdgeGestureKind__mouse mixins EdgeGestureKind {}

	declare export interface IEdgeGestureEventArgs {
kind: Windows$Windows$UI.Input.EdgeGestureKind
} 
	declare export class EdgeGestureEventArgs mixins undefined.IEdgeGestureEventArgs {
kind: Windows$Windows$UI.Input.EdgeGestureKind
}
	declare export interface IEdgeGestureStatics {
getForCurrentView(): Windows$Windows$UI.Input.EdgeGesture
} 
	declare export class EdgeGesture mixins undefined.IEdgeGesture {
onstarting: any;
oncompleted: any;
oncanceled: any;
static getForCurrentView(): Windows$Windows$UI.Input.EdgeGesture
}
	declare export interface IEdgeGesture {
onstarting: any,
oncompleted: any,
oncanceled: any
} 
	declare export  class HoldingState {
  constructor(...args: empty): mixed;
static +started: Class<HoldingState__started> & HoldingState__started & 0;// 0
static +completed: Class<HoldingState__completed> & HoldingState__completed & 1;// 1
static +canceled: Class<HoldingState__canceled> & HoldingState__canceled & 2;// 2

}

declare class HoldingState__started mixins HoldingState {}
declare class HoldingState__completed mixins HoldingState {}
declare class HoldingState__canceled mixins HoldingState {}

	declare export  class DraggingState {
  constructor(...args: empty): mixed;
static +started: Class<DraggingState__started> & DraggingState__started & 0;// 0
static +continuing: Class<DraggingState__continuing> & DraggingState__continuing & 1;// 1
static +completed: Class<DraggingState__completed> & DraggingState__completed & 2;// 2

}

declare class DraggingState__started mixins DraggingState {}
declare class DraggingState__continuing mixins DraggingState {}
declare class DraggingState__completed mixins DraggingState {}

	declare export  class CrossSlidingState {
  constructor(...args: empty): mixed;
static +started: Class<CrossSlidingState__started> & CrossSlidingState__started & 0;// 0
static +dragging: Class<CrossSlidingState__dragging> & CrossSlidingState__dragging & 1;// 1
static +selecting: Class<CrossSlidingState__selecting> & CrossSlidingState__selecting & 2;// 2
static +selectSpeedBumping: Class<CrossSlidingState__selectSpeedBumping> & CrossSlidingState__selectSpeedBumping & 3;// 3
static +speedBumping: Class<CrossSlidingState__speedBumping> & CrossSlidingState__speedBumping & 4;// 4
static +rearranging: Class<CrossSlidingState__rearranging> & CrossSlidingState__rearranging & 5;// 5
static +completed: Class<CrossSlidingState__completed> & CrossSlidingState__completed & 6;// 6

}

declare class CrossSlidingState__started mixins CrossSlidingState {}
declare class CrossSlidingState__dragging mixins CrossSlidingState {}
declare class CrossSlidingState__selecting mixins CrossSlidingState {}
declare class CrossSlidingState__selectSpeedBumping mixins CrossSlidingState {}
declare class CrossSlidingState__speedBumping mixins CrossSlidingState {}
declare class CrossSlidingState__rearranging mixins CrossSlidingState {}
declare class CrossSlidingState__completed mixins CrossSlidingState {}

	declare export  class GestureSettings {
  constructor(...args: empty): mixed;
static +none: Class<GestureSettings__none> & GestureSettings__none & 0;// 0
static +tap: Class<GestureSettings__tap> & GestureSettings__tap & 1;// 1
static +doubleTap: Class<GestureSettings__doubleTap> & GestureSettings__doubleTap & 2;// 2
static +hold: Class<GestureSettings__hold> & GestureSettings__hold & 3;// 3
static +holdWithMouse: Class<GestureSettings__holdWithMouse> & GestureSettings__holdWithMouse & 4;// 4
static +rightTap: Class<GestureSettings__rightTap> & GestureSettings__rightTap & 5;// 5
static +drag: Class<GestureSettings__drag> & GestureSettings__drag & 6;// 6
static +manipulationTranslateX: Class<GestureSettings__manipulationTranslateX> & GestureSettings__manipulationTranslateX & 7;// 7
static +manipulationTranslateY: Class<GestureSettings__manipulationTranslateY> & GestureSettings__manipulationTranslateY & 8;// 8
static +manipulationTranslateRailsX: Class<GestureSettings__manipulationTranslateRailsX> & GestureSettings__manipulationTranslateRailsX & 9;// 9
static +manipulationTranslateRailsY: Class<GestureSettings__manipulationTranslateRailsY> & GestureSettings__manipulationTranslateRailsY & 10;// 10
static +manipulationRotate: Class<GestureSettings__manipulationRotate> & GestureSettings__manipulationRotate & 11;// 11
static +manipulationScale: Class<GestureSettings__manipulationScale> & GestureSettings__manipulationScale & 12;// 12
static +manipulationTranslateInertia: Class<GestureSettings__manipulationTranslateInertia> & GestureSettings__manipulationTranslateInertia & 13;// 13
static +manipulationRotateInertia: Class<GestureSettings__manipulationRotateInertia> & GestureSettings__manipulationRotateInertia & 14;// 14
static +manipulationScaleInertia: Class<GestureSettings__manipulationScaleInertia> & GestureSettings__manipulationScaleInertia & 15;// 15
static +crossSlide: Class<GestureSettings__crossSlide> & GestureSettings__crossSlide & 16;// 16

}

declare class GestureSettings__none mixins GestureSettings {}
declare class GestureSettings__tap mixins GestureSettings {}
declare class GestureSettings__doubleTap mixins GestureSettings {}
declare class GestureSettings__hold mixins GestureSettings {}
declare class GestureSettings__holdWithMouse mixins GestureSettings {}
declare class GestureSettings__rightTap mixins GestureSettings {}
declare class GestureSettings__drag mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateX mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateY mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateRailsX mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateRailsY mixins GestureSettings {}
declare class GestureSettings__manipulationRotate mixins GestureSettings {}
declare class GestureSettings__manipulationScale mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateInertia mixins GestureSettings {}
declare class GestureSettings__manipulationRotateInertia mixins GestureSettings {}
declare class GestureSettings__manipulationScaleInertia mixins GestureSettings {}
declare class GestureSettings__crossSlide mixins GestureSettings {}

	declare export interface ManipulationDelta {
translation: Windows$Windows$Foundation.Point,
scale: number,
rotation: number,
expansion: number
} 
	declare export interface ManipulationVelocities {
linear: Windows$Windows$Foundation.Point,
angular: number,
expansion: number
} 
	declare export interface CrossSlideThresholds {
selectionStart: number,
speedBumpStart: number,
speedBumpEnd: number,
rearrangeStart: number
} 
	declare export interface ITappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
tapCount: number
} 
	declare export interface IRightTappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IHoldingEventArgs {
holdingState: Windows$Windows$UI.Input.HoldingState,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IDraggingEventArgs {
draggingState: Windows$Windows$UI.Input.DraggingState,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IManipulationStartedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IManipulationUpdatedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
delta: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
velocities: Windows$Windows$UI.Input.ManipulationVelocities
} 
	declare export interface IManipulationInertiaStartingEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
delta: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
velocities: Windows$Windows$UI.Input.ManipulationVelocities
} 
	declare export interface IManipulationCompletedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
velocities: Windows$Windows$UI.Input.ManipulationVelocities
} 
	declare export interface ICrossSlidingEventArgs {
crossSlidingState: Windows$Windows$UI.Input.CrossSlidingState,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IMouseWheelParameters {
charTranslation: Windows$Windows$Foundation.Point,
deltaRotationAngle: number,
deltaScale: number,
pageTranslation: Windows$Windows$Foundation.Point
} 
	declare export interface IGestureRecognizer {
autoProcessInertia: boolean,
crossSlideExact: boolean,
crossSlideHorizontally: boolean,
crossSlideThresholds: Windows$Windows$UI.Input.CrossSlideThresholds,
gestureSettings: Windows$Windows$UI.Input.GestureSettings,
inertiaExpansion: number,
inertiaExpansionDeceleration: number,
inertiaRotationAngle: number,
inertiaRotationDeceleration: number,
inertiaTranslationDeceleration: number,
inertiaTranslationDisplacement: number,
isActive: boolean,
isInertial: boolean,
manipulationExact: boolean,
mouseWheelParameters: Windows$Windows$UI.Input.MouseWheelParameters,
pivotCenter: Windows$Windows$Foundation.Point,
pivotRadius: number,
showGestureFeedback: boolean,
canBeDoubleTap(value: Windows$Windows$UI.Input.PointerPoint): boolean,
processDownEvent(value: Windows$Windows$UI.Input.PointerPoint): void,
processMoveEvents(
value: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>): void,
processUpEvent(value: Windows$Windows$UI.Input.PointerPoint): void,
processMouseWheelEvent(
value: Windows$Windows$UI.Input.PointerPoint,
isShiftKeyDown: boolean,
isControlKeyDown: boolean): void,
processInertia(): void,
completeGesture(): void,
ontapped: any,
onrighttapped: any,
onholding: any,
ondragging: any,
onmanipulationstarted: any,
onmanipulationupdated: any,
onmanipulationinertiastarting: any,
onmanipulationcompleted: any,
oncrosssliding: any
} 
	declare export class MouseWheelParameters mixins undefined.IMouseWheelParameters {
charTranslation: Windows$Windows$Foundation.Point;
deltaRotationAngle: number;
deltaScale: number;
pageTranslation: Windows$Windows$Foundation.Point
}
	declare export class GestureRecognizer mixins undefined.IGestureRecognizer {
autoProcessInertia: boolean;
crossSlideExact: boolean;
crossSlideHorizontally: boolean;
crossSlideThresholds: Windows$Windows$UI.Input.CrossSlideThresholds;
gestureSettings: Windows$Windows$UI.Input.GestureSettings;
inertiaExpansion: number;
inertiaExpansionDeceleration: number;
inertiaRotationAngle: number;
inertiaRotationDeceleration: number;
inertiaTranslationDeceleration: number;
inertiaTranslationDisplacement: number;
isActive: boolean;
isInertial: boolean;
manipulationExact: boolean;
mouseWheelParameters: Windows$Windows$UI.Input.MouseWheelParameters;
pivotCenter: Windows$Windows$Foundation.Point;
pivotRadius: number;
showGestureFeedback: boolean;
canBeDoubleTap(value: Windows$Windows$UI.Input.PointerPoint): boolean;
processDownEvent(value: Windows$Windows$UI.Input.PointerPoint): void;
processMoveEvents(
value: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>): void;
processUpEvent(value: Windows$Windows$UI.Input.PointerPoint): void;
processMouseWheelEvent(
value: Windows$Windows$UI.Input.PointerPoint,
isShiftKeyDown: boolean,
isControlKeyDown: boolean): void;
processInertia(): void;
completeGesture(): void;
ontapped: any;
onrighttapped: any;
onholding: any;
ondragging: any;
onmanipulationstarted: any;
onmanipulationupdated: any;
onmanipulationinertiastarting: any;
onmanipulationcompleted: any;
oncrosssliding: any
}
	declare export class TappedEventArgs mixins undefined.ITappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
tapCount: number
}
	declare export class RightTappedEventArgs mixins undefined.IRightTappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class HoldingEventArgs mixins undefined.IHoldingEventArgs {
holdingState: Windows$Windows$UI.Input.HoldingState;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class DraggingEventArgs mixins undefined.IDraggingEventArgs {
draggingState: Windows$Windows$UI.Input.DraggingState;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class ManipulationStartedEventArgs mixins undefined.IManipulationStartedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class ManipulationUpdatedEventArgs mixins undefined.IManipulationUpdatedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
delta: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
velocities: Windows$Windows$UI.Input.ManipulationVelocities
}
	declare export class ManipulationInertiaStartingEventArgs mixins undefined.IManipulationInertiaStartingEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
delta: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
velocities: Windows$Windows$UI.Input.ManipulationVelocities
}
	declare export class ManipulationCompletedEventArgs mixins undefined.IManipulationCompletedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
velocities: Windows$Windows$UI.Input.ManipulationVelocities
}
	declare export class CrossSlidingEventArgs mixins undefined.ICrossSlidingEventArgs {
crossSlidingState: Windows$Windows$UI.Input.CrossSlidingState;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export interface IPointerPointStatics {
getCurrentPoint(pointerId: number): Windows$Windows$UI.Input.PointerPoint,
getIntermediatePoints(
pointerId: number): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>,
getCurrentPoint(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$UI.Input.PointerPoint,
getIntermediatePoints(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
} 
	declare export class PointerPoint mixins undefined.IPointerPoint {
frameId: number;
isInContact: boolean;
pointerDevice: Windows$Windows$Devices.Input.PointerDevice;
pointerId: number;
position: Windows$Windows$Foundation.Point;
properties: Windows$Windows$UI.Input.PointerPointProperties;
rawPosition: Windows$Windows$Foundation.Point;
timestamp: number;
static getCurrentPoint(pointerId: number): Windows$Windows$UI.Input.PointerPoint;
static getIntermediatePoints(
pointerId: number): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>;
static getCurrentPoint(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$UI.Input.PointerPoint;
static getIntermediatePoints(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
}
	declare export interface IPointerPointTransform {
inverse: Windows$Windows$UI.Input.IPointerPointTransform,
tryTransform(
inPoint: Windows$Windows$Foundation.Point): {
outPoint: Windows$Windows$Foundation.Point,
returnValue: boolean
},
transformBounds(rect: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.Rect
} 
	declare export interface IPointerPoint {
frameId: number,
isInContact: boolean,
pointerDevice: Windows$Windows$Devices.Input.PointerDevice,
pointerId: number,
position: Windows$Windows$Foundation.Point,
properties: Windows$Windows$UI.Input.PointerPointProperties,
rawPosition: Windows$Windows$Foundation.Point,
timestamp: number
} 
	declare export class PointerPointProperties mixins undefined.IPointerPointProperties {
contactRect: Windows$Windows$Foundation.Rect;
contactRectRaw: Windows$Windows$Foundation.Rect;
isBarrelButtonPressed: boolean;
isCanceled: boolean;
isEraser: boolean;
isHorizontalMouseWheel: boolean;
isInRange: boolean;
isInverted: boolean;
isLeftButtonPressed: boolean;
isMiddleButtonPressed: boolean;
isPrimary: boolean;
isRightButtonPressed: boolean;
isXButton1Pressed: boolean;
isXButton2Pressed: boolean;
mouseWheelDelta: number;
orientation: number;
pointerUpdateKind: Windows$Windows$UI.Input.PointerUpdateKind;
pressure: number;
touchConfidence: boolean;
twist: number;
xTilt: number;
yTilt: number;
hasUsage(usagePage: number, usageId: number): boolean;
getUsageValue(usagePage: number, usageId: number): number
}
	declare export  class PointerUpdateKind {
  constructor(...args: empty): mixed;
static +other: Class<PointerUpdateKind__other> & PointerUpdateKind__other & 0;// 0
static +leftButtonPressed: Class<PointerUpdateKind__leftButtonPressed> & PointerUpdateKind__leftButtonPressed & 1;// 1
static +leftButtonReleased: Class<PointerUpdateKind__leftButtonReleased> & PointerUpdateKind__leftButtonReleased & 2;// 2
static +rightButtonPressed: Class<PointerUpdateKind__rightButtonPressed> & PointerUpdateKind__rightButtonPressed & 3;// 3
static +rightButtonReleased: Class<PointerUpdateKind__rightButtonReleased> & PointerUpdateKind__rightButtonReleased & 4;// 4
static +middleButtonPressed: Class<PointerUpdateKind__middleButtonPressed> & PointerUpdateKind__middleButtonPressed & 5;// 5
static +middleButtonReleased: Class<PointerUpdateKind__middleButtonReleased> & PointerUpdateKind__middleButtonReleased & 6;// 6
static +xButton1Pressed: Class<PointerUpdateKind__xButton1Pressed> & PointerUpdateKind__xButton1Pressed & 7;// 7
static +xButton1Released: Class<PointerUpdateKind__xButton1Released> & PointerUpdateKind__xButton1Released & 8;// 8
static +xButton2Pressed: Class<PointerUpdateKind__xButton2Pressed> & PointerUpdateKind__xButton2Pressed & 9;// 9
static +xButton2Released: Class<PointerUpdateKind__xButton2Released> & PointerUpdateKind__xButton2Released & 10;// 10

}

declare class PointerUpdateKind__other mixins PointerUpdateKind {}
declare class PointerUpdateKind__leftButtonPressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__leftButtonReleased mixins PointerUpdateKind {}
declare class PointerUpdateKind__rightButtonPressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__rightButtonReleased mixins PointerUpdateKind {}
declare class PointerUpdateKind__middleButtonPressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__middleButtonReleased mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton1Pressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton1Released mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton2Pressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton2Released mixins PointerUpdateKind {}

	declare export interface IPointerPointProperties {
contactRect: Windows$Windows$Foundation.Rect,
contactRectRaw: Windows$Windows$Foundation.Rect,
isBarrelButtonPressed: boolean,
isCanceled: boolean,
isEraser: boolean,
isHorizontalMouseWheel: boolean,
isInRange: boolean,
isInverted: boolean,
isLeftButtonPressed: boolean,
isMiddleButtonPressed: boolean,
isPrimary: boolean,
isRightButtonPressed: boolean,
isXButton1Pressed: boolean,
isXButton2Pressed: boolean,
mouseWheelDelta: number,
orientation: number,
pointerUpdateKind: Windows$Windows$UI.Input.PointerUpdateKind,
pressure: number,
touchConfidence: boolean,
twist: number,
xTilt: number,
yTilt: number,
hasUsage(usagePage: number, usageId: number): boolean,
getUsageValue(usagePage: number, usageId: number): number
} 
	declare export interface IPointerVisualizationSettings {
isBarrelButtonFeedbackEnabled: boolean,
isContactFeedbackEnabled: boolean
} 
	declare export interface IPointerVisualizationSettingsStatics {
getForCurrentView(): Windows$Windows$UI.Input.PointerVisualizationSettings
} 
	declare export class PointerVisualizationSettings mixins undefined.IPointerVisualizationSettings {
isBarrelButtonFeedbackEnabled: boolean;
isContactFeedbackEnabled: boolean;
static getForCurrentView(): Windows$Windows$UI.Input.PointerVisualizationSettings
}
	declare module 'Inking' {
        declare export  class InkManipulationMode {
  constructor(...args: empty): mixed;
static +inking: Class<InkManipulationMode__inking> & InkManipulationMode__inking & 0;// 0
static +erasing: Class<InkManipulationMode__erasing> & InkManipulationMode__erasing & 1;// 1
static +selecting: Class<InkManipulationMode__selecting> & InkManipulationMode__selecting & 2;// 2

}

declare class InkManipulationMode__inking mixins InkManipulationMode {}
declare class InkManipulationMode__erasing mixins InkManipulationMode {}
declare class InkManipulationMode__selecting mixins InkManipulationMode {}

	declare export  class InkRecognitionTarget {
  constructor(...args: empty): mixed;
static +all: Class<InkRecognitionTarget__all> & InkRecognitionTarget__all & 0;// 0
static +selected: Class<InkRecognitionTarget__selected> & InkRecognitionTarget__selected & 1;// 1
static +recent: Class<InkRecognitionTarget__recent> & InkRecognitionTarget__recent & 2;// 2

}

declare class InkRecognitionTarget__all mixins InkRecognitionTarget {}
declare class InkRecognitionTarget__selected mixins InkRecognitionTarget {}
declare class InkRecognitionTarget__recent mixins InkRecognitionTarget {}

	declare export  class PenTipShape {
  constructor(...args: empty): mixed;
static +circle: Class<PenTipShape__circle> & PenTipShape__circle & 0;// 0
static +rectangle: Class<PenTipShape__rectangle> & PenTipShape__rectangle & 1;// 1

}

declare class PenTipShape__circle mixins PenTipShape {}
declare class PenTipShape__rectangle mixins PenTipShape {}

	declare export interface IInkDrawingAttributes {
color: Windows$Windows$UI.Color,
fitToCurve: boolean,
ignorePressure: boolean,
penTip: Windows$Windows$UI.Input.Inking.PenTipShape,
size: Windows$Windows$Foundation.Size
} 
	declare export class InkDrawingAttributes mixins undefined.IInkDrawingAttributes {
color: Windows$Windows$UI.Color;
fitToCurve: boolean;
ignorePressure: boolean;
penTip: Windows$Windows$UI.Input.Inking.PenTipShape;
size: Windows$Windows$Foundation.Size
}
	declare export interface IInkStrokeRenderingSegment {
bezierControlPoint1: Windows$Windows$Foundation.Point,
bezierControlPoint2: Windows$Windows$Foundation.Point,
position: Windows$Windows$Foundation.Point,
pressure: number,
tiltX: number,
tiltY: number,
twist: number
} 
	declare export class InkStrokeRenderingSegment mixins undefined.IInkStrokeRenderingSegment {
bezierControlPoint1: Windows$Windows$Foundation.Point;
bezierControlPoint2: Windows$Windows$Foundation.Point;
position: Windows$Windows$Foundation.Point;
pressure: number;
tiltX: number;
tiltY: number;
twist: number
}
	declare export interface IInkStroke {
boundingRect: Windows$Windows$Foundation.Rect,
drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes,
recognized: boolean,
selected: boolean,
getRenderingSegments(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStrokeRenderingSegment>,
clone(): Windows$Windows$UI.Input.Inking.InkStroke
} 
	declare export class InkStroke mixins undefined.IInkStroke {
boundingRect: Windows$Windows$Foundation.Rect;
drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes;
recognized: boolean;
selected: boolean;
getRenderingSegments(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStrokeRenderingSegment>;
clone(): Windows$Windows$UI.Input.Inking.InkStroke
}
	declare export interface IInkStrokeBuilder {
beginStroke(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void,
appendToStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.PointerPoint,
endStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.Inking.InkStroke,
createStroke(
points: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$UI.Input.Inking.InkStroke,
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void
} 
	declare export class InkStrokeBuilder mixins undefined.IInkStrokeBuilder {
beginStroke(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void;
appendToStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.PointerPoint;
endStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.Inking.InkStroke;
createStroke(
points: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$UI.Input.Inking.InkStroke;
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void
}
	declare export interface IInkRecognitionResult {
boundingRect: Windows$Windows$Foundation.Rect,
getTextCandidates(): Windows$Windows$Foundation.Collections.IVectorView<string>,
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>
} 
	declare export class InkRecognitionResult mixins undefined.IInkRecognitionResult {
boundingRect: Windows$Windows$Foundation.Rect;
getTextCandidates(): Windows$Windows$Foundation.Collections.IVectorView<string>;
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>
}
	declare export interface IInkStrokeContainer {
boundingRect: Windows$Windows$Foundation.Rect,
addStroke(stroke: Windows$Windows$UI.Input.Inking.InkStroke): void,
deleteSelected(): Windows$Windows$Foundation.Rect,
moveSelected(translation: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect,
selectWithPolyLine(
polyline: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$Foundation.Rect,
selectWithLine(
from: Windows$Windows$Foundation.Point,
to: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect,
copySelectedToClipboard(): void,
pasteFromClipboard(position: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect,
canPasteFromClipboard(): boolean,
loadAsync(
inputStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<number>,
saveAsync(
outputStream: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>,
updateRecognitionResults(
recognitionResults: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>): void,
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>,
getRecognitionResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>
} 
	declare export class InkStrokeContainer mixins undefined.IInkStrokeContainer {
boundingRect: Windows$Windows$Foundation.Rect;
addStroke(stroke: Windows$Windows$UI.Input.Inking.InkStroke): void;
deleteSelected(): Windows$Windows$Foundation.Rect;
moveSelected(translation: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
selectWithPolyLine(
polyline: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$Foundation.Rect;
selectWithLine(
from: Windows$Windows$Foundation.Point,
to: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
copySelectedToClipboard(): void;
pasteFromClipboard(position: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
canPasteFromClipboard(): boolean;
loadAsync(
inputStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<number>;
saveAsync(
outputStream: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
updateRecognitionResults(
recognitionResults: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>): void;
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>;
getRecognitionResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>
}
	declare export interface IInkRecognizer {
name: string
} 
	declare export class InkRecognizer mixins undefined.IInkRecognizer {
name: string
}
	declare export interface IInkRecognizerContainer {
setDefaultRecognizer(recognizer: Windows$Windows$UI.Input.Inking.InkRecognizer): void,
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>,
getRecognizers(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognizer>
} 
	declare export class InkRecognizerContainer mixins undefined.IInkRecognizerContainer {
setDefaultRecognizer(recognizer: Windows$Windows$UI.Input.Inking.InkRecognizer): void;
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>;
getRecognizers(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognizer>
}
	declare export type IInkManager = {
mode: Windows$Windows$UI.Input.Inking.InkManipulationMode,
processPointerDown(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void,
processPointerUpdate(pointerPoint: Windows$Windows$UI.Input.PointerPoint): any,
processPointerUp(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$Foundation.Rect,
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void,
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>,
recognizeAsync(
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>
} & undefined.IInkStrokeContainer & undefined.IInkRecognizerContainer

	declare export class InkManager mixins undefined.IInkManager, undefined.IInkStrokeContainer, undefined.IInkRecognizerContainer {
mode: Windows$Windows$UI.Input.Inking.InkManipulationMode;
boundingRect: Windows$Windows$Foundation.Rect;
processPointerDown(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void;
processPointerUpdate(pointerPoint: Windows$Windows$UI.Input.PointerPoint): any;
processPointerUp(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$Foundation.Rect;
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void;
recognizeAsync(
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>;
addStroke(stroke: Windows$Windows$UI.Input.Inking.InkStroke): void;
deleteSelected(): Windows$Windows$Foundation.Rect;
moveSelected(translation: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
selectWithPolyLine(
polyline: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$Foundation.Rect;
selectWithLine(
from: Windows$Windows$Foundation.Point,
to: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
copySelectedToClipboard(): void;
pasteFromClipboard(position: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
canPasteFromClipboard(): boolean;
loadAsync(
inputStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<number>;
saveAsync(
outputStream: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
updateRecognitionResults(
recognitionResults: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>): void;
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>;
getRecognitionResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>;
setDefaultRecognizer(recognizer: Windows$Windows$UI.Input.Inking.InkRecognizer): void;
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>;
getRecognizers(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognizer>
}
    }

    }

	declare module 'Popups' {
        declare export  class MessageDialogOptions {
  constructor(...args: empty): mixed;
static +none: Class<MessageDialogOptions__none> & MessageDialogOptions__none & 0;// 0
static +acceptUserInputAfterDelay: Class<MessageDialogOptions__acceptUserInputAfterDelay> & MessageDialogOptions__acceptUserInputAfterDelay & 1;// 1

}

declare class MessageDialogOptions__none mixins MessageDialogOptions {}
declare class MessageDialogOptions__acceptUserInputAfterDelay mixins MessageDialogOptions {}

	declare export interface IMessageDialog {
cancelCommandIndex: number,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
content: string,
defaultCommandIndex: number,
options: Windows$Windows$UI.Popups.MessageDialogOptions,
title: string,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface IMessageDialogFactory {
create(content: string): Windows$Windows$UI.Popups.MessageDialog,
createWithTitle(content: string, title: string): Windows$Windows$UI.Popups.MessageDialog
} 
	declare export class MessageDialog mixins undefined.IMessageDialog {
constructor(content: string): this;
constructor(content: string, title: string): this;
cancelCommandIndex: number;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
content: string;
defaultCommandIndex: number;
options: Windows$Windows$UI.Popups.MessageDialogOptions;
title: string;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
	declare export  class Placement {
  constructor(...args: empty): mixed;
static +default: Class<Placement__default> & Placement__default & 0;// 0
static +above: Class<Placement__above> & Placement__above & 1;// 1
static +below: Class<Placement__below> & Placement__below & 2;// 2
static +left: Class<Placement__left> & Placement__left & 3;// 3
static +right: Class<Placement__right> & Placement__right & 4;// 4

}

declare class Placement__default mixins Placement {}
declare class Placement__above mixins Placement {}
declare class Placement__below mixins Placement {}
declare class Placement__left mixins Placement {}
declare class Placement__right mixins Placement {}

	declare export interface UICommandInvokedHandler {
(command: Windows$Windows$UI.Popups.IUICommand): void
} 
	declare export interface IUICommand {
id: any,
invoked: Windows$Windows$UI.Popups.UICommandInvokedHandler,
label: string
} 
	declare export interface IUICommandFactory {
create(label: string): Windows$Windows$UI.Popups.UICommand,
createWithHandler(
label: string,
action: Windows$Windows$UI.Popups.UICommandInvokedHandler): Windows$Windows$UI.Popups.UICommand,
createWithHandlerAndId(
label: string,
action: Windows$Windows$UI.Popups.UICommandInvokedHandler,
commandId: any): Windows$Windows$UI.Popups.UICommand
} 
	declare export class UICommand mixins undefined.IUICommand {
constructor(label: string): this;
constructor(label: string, action: Windows$Windows$UI.Popups.UICommandInvokedHandler): this;
constructor(label: string, action: Windows$Windows$UI.Popups.UICommandInvokedHandler, commandId: any): this;
constructor(): this;
id: any;
invoked: Windows$Windows$UI.Popups.UICommandInvokedHandler;
label: string
}
	declare export class UICommandSeparator mixins undefined.IUICommand {
id: any;
invoked: Windows$Windows$UI.Popups.UICommandInvokedHandler;
label: string
}
	declare export interface IPopupMenu {
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
showAsync(
invocationPoint: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>,
showForSelectionAsync(
selection: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>,
showForSelectionAsync(
selection: Windows$Windows$Foundation.Rect,
preferredPlacement: Windows$Windows$UI.Popups.Placement): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export class PopupMenu mixins undefined.IPopupMenu {
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
showAsync(
invocationPoint: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>;
showForSelectionAsync(
selection: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>;
showForSelectionAsync(
selection: Windows$Windows$Foundation.Rect,
preferredPlacement: Windows$Windows$UI.Popups.Placement): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
    }

	declare module 'StartScreen' {
        declare export  class TileOptions {
  constructor(...args: empty): mixed;
static +none: Class<TileOptions__none> & TileOptions__none & 0;// 0
static +showNameOnLogo: Class<TileOptions__showNameOnLogo> & TileOptions__showNameOnLogo & 1;// 1
static +showNameOnWideLogo: Class<TileOptions__showNameOnWideLogo> & TileOptions__showNameOnWideLogo & 2;// 2
static +copyOnDeployment: Class<TileOptions__copyOnDeployment> & TileOptions__copyOnDeployment & 3;// 3

}

declare class TileOptions__none mixins TileOptions {}
declare class TileOptions__showNameOnLogo mixins TileOptions {}
declare class TileOptions__showNameOnWideLogo mixins TileOptions {}
declare class TileOptions__copyOnDeployment mixins TileOptions {}

	declare export  class ForegroundText {
  constructor(...args: empty): mixed;
static +dark: Class<ForegroundText__dark> & ForegroundText__dark & 0;// 0
static +light: Class<ForegroundText__light> & ForegroundText__light & 1;// 1

}

declare class ForegroundText__dark mixins ForegroundText {}
declare class ForegroundText__light mixins ForegroundText {}

	declare export interface ISecondaryTile {
arguments: string,
backgroundColor: Windows$Windows$UI.Color,
displayName: string,
foregroundText: Windows$Windows$UI.StartScreen.ForegroundText,
lockScreenBadgeLogo: Windows$Windows$Foundation.Uri,
lockScreenDisplayBadgeAndTileText: boolean,
logo: Windows$Windows$Foundation.Uri,
shortName: string,
smallLogo: Windows$Windows$Foundation.Uri,
tileId: string,
tileOptions: Windows$Windows$UI.StartScreen.TileOptions,
wideLogo: Windows$Windows$Foundation.Uri,
requestCreateAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>,
requestCreateAsync(
invocationPoint: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.IAsyncOperation<boolean>,
requestCreateForSelectionAsync(
selection: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.IAsyncOperation<boolean>,
requestCreateForSelectionAsync(
selection: Windows$Windows$Foundation.Rect,
preferredPlacement: Windows$Windows$UI.Popups.Placement): Windows$Windows$Foundation.IAsyncOperation<boolean>,
requestDeleteAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>,
requestDeleteAsync(
invocationPoint: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.IAsyncOperation<boolean>,
requestDeleteForSelectionAsync(
selection: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.IAsyncOperation<boolean>,
requestDeleteForSelectionAsync(
selection: Windows$Windows$Foundation.Rect,
preferredPlacement: Windows$Windows$UI.Popups.Placement): Windows$Windows$Foundation.IAsyncOperation<boolean>,
updateAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>
} 
	declare export interface ISecondaryTileFactory {
createTile(
tileId: string,
shortName: string,
displayName: string,
arguments: string,
tileOptions: Windows$Windows$UI.StartScreen.TileOptions,
logoReference: Windows$Windows$Foundation.Uri): Windows$Windows$UI.StartScreen.SecondaryTile,
createWideTile(
tileId: string,
shortName: string,
displayName: string,
arguments: string,
tileOptions: Windows$Windows$UI.StartScreen.TileOptions,
logoReference: Windows$Windows$Foundation.Uri,
wideLogoReference: Windows$Windows$Foundation.Uri): Windows$Windows$UI.StartScreen.SecondaryTile,
createWithId(tileId: string): Windows$Windows$UI.StartScreen.SecondaryTile
} 
	declare export class SecondaryTile mixins undefined.ISecondaryTile {
constructor(tileId: string, shortName: string, displayName: string, args: string, tileOptions: Windows$Windows$UI.StartScreen.TileOptions, logoReference: Windows$Windows$Foundation.Uri): this;
constructor(tileId: string, shortName: string, displayName: string, args: string, tileOptions: Windows$Windows$UI.StartScreen.TileOptions, logoReference: Windows$Windows$Foundation.Uri, wideLogoReference: Windows$Windows$Foundation.Uri): this;
constructor(tileId: string): this;
constructor(): this;
arguments: string;
backgroundColor: Windows$Windows$UI.Color;
displayName: string;
foregroundText: Windows$Windows$UI.StartScreen.ForegroundText;
lockScreenBadgeLogo: Windows$Windows$Foundation.Uri;
lockScreenDisplayBadgeAndTileText: boolean;
logo: Windows$Windows$Foundation.Uri;
shortName: string;
smallLogo: Windows$Windows$Foundation.Uri;
tileId: string;
tileOptions: Windows$Windows$UI.StartScreen.TileOptions;
wideLogo: Windows$Windows$Foundation.Uri;
requestCreateAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
requestCreateAsync(
invocationPoint: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.IAsyncOperation<boolean>;
requestCreateForSelectionAsync(
selection: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.IAsyncOperation<boolean>;
requestCreateForSelectionAsync(
selection: Windows$Windows$Foundation.Rect,
preferredPlacement: Windows$Windows$UI.Popups.Placement): Windows$Windows$Foundation.IAsyncOperation<boolean>;
requestDeleteAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
requestDeleteAsync(
invocationPoint: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.IAsyncOperation<boolean>;
requestDeleteForSelectionAsync(
selection: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.IAsyncOperation<boolean>;
requestDeleteForSelectionAsync(
selection: Windows$Windows$Foundation.Rect,
preferredPlacement: Windows$Windows$UI.Popups.Placement): Windows$Windows$Foundation.IAsyncOperation<boolean>;
updateAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
static exists(tileId: string): boolean;
static findAllAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.StartScreen.SecondaryTile>>;
static findAllAsync(
applicationId: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.StartScreen.SecondaryTile>>;
static findAllForPackageAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.StartScreen.SecondaryTile>>
}
	declare export interface ISecondaryTileStatics {
exists(tileId: string): boolean,
findAllAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.StartScreen.SecondaryTile>>,
findAllAsync(
applicationId: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.StartScreen.SecondaryTile>>,
findAllForPackageAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.StartScreen.SecondaryTile>>
} 
    }

	declare module 'Text' {
        declare export  class CaretType {
  constructor(...args: empty): mixed;
static +normal: Class<CaretType__normal> & CaretType__normal & 0;// 0
static +null_: Class<CaretType__null_> & CaretType__null_ & 1;// 1

}

declare class CaretType__normal mixins CaretType {}
declare class CaretType__null_ mixins CaretType {}

	declare export  class FindOptions {
  constructor(...args: empty): mixed;
static +none: Class<FindOptions__none> & FindOptions__none & 0;// 0
static +word: Class<FindOptions__word> & FindOptions__word & 1;// 1
static +case_: Class<FindOptions__case_> & FindOptions__case_ & 2;// 2

}

declare class FindOptions__none mixins FindOptions {}
declare class FindOptions__word mixins FindOptions {}
declare class FindOptions__case_ mixins FindOptions {}

	declare export  class FormatEffect {
  constructor(...args: empty): mixed;
static +off: Class<FormatEffect__off> & FormatEffect__off & 0;// 0
static +on: Class<FormatEffect__on> & FormatEffect__on & 1;// 1
static +toggle: Class<FormatEffect__toggle> & FormatEffect__toggle & 2;// 2
static +undefined: Class<FormatEffect__undefined> & FormatEffect__undefined & 3;// 3

}

declare class FormatEffect__off mixins FormatEffect {}
declare class FormatEffect__on mixins FormatEffect {}
declare class FormatEffect__toggle mixins FormatEffect {}
declare class FormatEffect__undefined mixins FormatEffect {}

	declare export  class HorizontalCharacterAlignment {
  constructor(...args: empty): mixed;
static +left: Class<HorizontalCharacterAlignment__left> & HorizontalCharacterAlignment__left & 0;// 0
static +right: Class<HorizontalCharacterAlignment__right> & HorizontalCharacterAlignment__right & 1;// 1
static +center: Class<HorizontalCharacterAlignment__center> & HorizontalCharacterAlignment__center & 2;// 2

}

declare class HorizontalCharacterAlignment__left mixins HorizontalCharacterAlignment {}
declare class HorizontalCharacterAlignment__right mixins HorizontalCharacterAlignment {}
declare class HorizontalCharacterAlignment__center mixins HorizontalCharacterAlignment {}

	declare export  class LetterCase {
  constructor(...args: empty): mixed;
static +lower: Class<LetterCase__lower> & LetterCase__lower & 0;// 0
static +upper: Class<LetterCase__upper> & LetterCase__upper & 1;// 1

}

declare class LetterCase__lower mixins LetterCase {}
declare class LetterCase__upper mixins LetterCase {}

	declare export  class LineSpacingRule {
  constructor(...args: empty): mixed;
static +undefined: Class<LineSpacingRule__undefined> & LineSpacingRule__undefined & 0;// 0
static +single: Class<LineSpacingRule__single> & LineSpacingRule__single & 1;// 1
static +oneAndHalf: Class<LineSpacingRule__oneAndHalf> & LineSpacingRule__oneAndHalf & 2;// 2
static +double: Class<LineSpacingRule__double> & LineSpacingRule__double & 3;// 3
static +atLeast: Class<LineSpacingRule__atLeast> & LineSpacingRule__atLeast & 4;// 4
static +exactly: Class<LineSpacingRule__exactly> & LineSpacingRule__exactly & 5;// 5
static +multiple: Class<LineSpacingRule__multiple> & LineSpacingRule__multiple & 6;// 6
static +percent: Class<LineSpacingRule__percent> & LineSpacingRule__percent & 7;// 7

}

declare class LineSpacingRule__undefined mixins LineSpacingRule {}
declare class LineSpacingRule__single mixins LineSpacingRule {}
declare class LineSpacingRule__oneAndHalf mixins LineSpacingRule {}
declare class LineSpacingRule__double mixins LineSpacingRule {}
declare class LineSpacingRule__atLeast mixins LineSpacingRule {}
declare class LineSpacingRule__exactly mixins LineSpacingRule {}
declare class LineSpacingRule__multiple mixins LineSpacingRule {}
declare class LineSpacingRule__percent mixins LineSpacingRule {}

	declare export  class LinkType {
  constructor(...args: empty): mixed;
static +undefined: Class<LinkType__undefined> & LinkType__undefined & 0;// 0
static +notALink: Class<LinkType__notALink> & LinkType__notALink & 1;// 1
static +clientLink: Class<LinkType__clientLink> & LinkType__clientLink & 2;// 2
static +friendlyLinkName: Class<LinkType__friendlyLinkName> & LinkType__friendlyLinkName & 3;// 3
static +friendlyLinkAddress: Class<LinkType__friendlyLinkAddress> & LinkType__friendlyLinkAddress & 4;// 4
static +autoLink: Class<LinkType__autoLink> & LinkType__autoLink & 5;// 5
static +autoLinkEmail: Class<LinkType__autoLinkEmail> & LinkType__autoLinkEmail & 6;// 6
static +autoLinkPhone: Class<LinkType__autoLinkPhone> & LinkType__autoLinkPhone & 7;// 7
static +autoLinkPath: Class<LinkType__autoLinkPath> & LinkType__autoLinkPath & 8;// 8

}

declare class LinkType__undefined mixins LinkType {}
declare class LinkType__notALink mixins LinkType {}
declare class LinkType__clientLink mixins LinkType {}
declare class LinkType__friendlyLinkName mixins LinkType {}
declare class LinkType__friendlyLinkAddress mixins LinkType {}
declare class LinkType__autoLink mixins LinkType {}
declare class LinkType__autoLinkEmail mixins LinkType {}
declare class LinkType__autoLinkPhone mixins LinkType {}
declare class LinkType__autoLinkPath mixins LinkType {}

	declare export  class MarkerAlignment {
  constructor(...args: empty): mixed;
static +undefined: Class<MarkerAlignment__undefined> & MarkerAlignment__undefined & 0;// 0
static +left: Class<MarkerAlignment__left> & MarkerAlignment__left & 1;// 1
static +center: Class<MarkerAlignment__center> & MarkerAlignment__center & 2;// 2
static +right: Class<MarkerAlignment__right> & MarkerAlignment__right & 3;// 3

}

declare class MarkerAlignment__undefined mixins MarkerAlignment {}
declare class MarkerAlignment__left mixins MarkerAlignment {}
declare class MarkerAlignment__center mixins MarkerAlignment {}
declare class MarkerAlignment__right mixins MarkerAlignment {}

	declare export  class MarkerStyle {
  constructor(...args: empty): mixed;
static +undefined: Class<MarkerStyle__undefined> & MarkerStyle__undefined & 0;// 0
static +parenthesis: Class<MarkerStyle__parenthesis> & MarkerStyle__parenthesis & 1;// 1
static +parentheses: Class<MarkerStyle__parentheses> & MarkerStyle__parentheses & 2;// 2
static +period: Class<MarkerStyle__period> & MarkerStyle__period & 3;// 3
static +plain: Class<MarkerStyle__plain> & MarkerStyle__plain & 4;// 4
static +minus: Class<MarkerStyle__minus> & MarkerStyle__minus & 5;// 5
static +noNumber: Class<MarkerStyle__noNumber> & MarkerStyle__noNumber & 6;// 6

}

declare class MarkerStyle__undefined mixins MarkerStyle {}
declare class MarkerStyle__parenthesis mixins MarkerStyle {}
declare class MarkerStyle__parentheses mixins MarkerStyle {}
declare class MarkerStyle__period mixins MarkerStyle {}
declare class MarkerStyle__plain mixins MarkerStyle {}
declare class MarkerStyle__minus mixins MarkerStyle {}
declare class MarkerStyle__noNumber mixins MarkerStyle {}

	declare export  class MarkerType {
  constructor(...args: empty): mixed;
static +undefined: Class<MarkerType__undefined> & MarkerType__undefined & 0;// 0
static +none: Class<MarkerType__none> & MarkerType__none & 1;// 1
static +bullet: Class<MarkerType__bullet> & MarkerType__bullet & 2;// 2
static +arabic: Class<MarkerType__arabic> & MarkerType__arabic & 3;// 3
static +lowercaseEnglishLetter: Class<MarkerType__lowercaseEnglishLetter> & MarkerType__lowercaseEnglishLetter & 4;// 4
static +uppercaseEnglishLetter: Class<MarkerType__uppercaseEnglishLetter> & MarkerType__uppercaseEnglishLetter & 5;// 5
static +lowercaseRoman: Class<MarkerType__lowercaseRoman> & MarkerType__lowercaseRoman & 6;// 6
static +uppercaseRoman: Class<MarkerType__uppercaseRoman> & MarkerType__uppercaseRoman & 7;// 7
static +unicodeSequence: Class<MarkerType__unicodeSequence> & MarkerType__unicodeSequence & 8;// 8
static +circledNumber: Class<MarkerType__circledNumber> & MarkerType__circledNumber & 9;// 9
static +blackCircleWingding: Class<MarkerType__blackCircleWingding> & MarkerType__blackCircleWingding & 10;// 10
static +whiteCircleWingding: Class<MarkerType__whiteCircleWingding> & MarkerType__whiteCircleWingding & 11;// 11
static +arabicWide: Class<MarkerType__arabicWide> & MarkerType__arabicWide & 12;// 12
static +simplifiedChinese: Class<MarkerType__simplifiedChinese> & MarkerType__simplifiedChinese & 13;// 13
static +traditionalChinese: Class<MarkerType__traditionalChinese> & MarkerType__traditionalChinese & 14;// 14
static +japanSimplifiedChinese: Class<MarkerType__japanSimplifiedChinese> & MarkerType__japanSimplifiedChinese & 15;// 15
static +japanKorea: Class<MarkerType__japanKorea> & MarkerType__japanKorea & 16;// 16
static +arabicDictionary: Class<MarkerType__arabicDictionary> & MarkerType__arabicDictionary & 17;// 17
static +arabicAbjad: Class<MarkerType__arabicAbjad> & MarkerType__arabicAbjad & 18;// 18
static +hebrew: Class<MarkerType__hebrew> & MarkerType__hebrew & 19;// 19
static +thaiAlphabetic: Class<MarkerType__thaiAlphabetic> & MarkerType__thaiAlphabetic & 20;// 20
static +thaiNumeric: Class<MarkerType__thaiNumeric> & MarkerType__thaiNumeric & 21;// 21
static +devanagariVowel: Class<MarkerType__devanagariVowel> & MarkerType__devanagariVowel & 22;// 22
static +devanagariConsonant: Class<MarkerType__devanagariConsonant> & MarkerType__devanagariConsonant & 23;// 23
static +devanagariNumeric: Class<MarkerType__devanagariNumeric> & MarkerType__devanagariNumeric & 24;// 24

}

declare class MarkerType__undefined mixins MarkerType {}
declare class MarkerType__none mixins MarkerType {}
declare class MarkerType__bullet mixins MarkerType {}
declare class MarkerType__arabic mixins MarkerType {}
declare class MarkerType__lowercaseEnglishLetter mixins MarkerType {}
declare class MarkerType__uppercaseEnglishLetter mixins MarkerType {}
declare class MarkerType__lowercaseRoman mixins MarkerType {}
declare class MarkerType__uppercaseRoman mixins MarkerType {}
declare class MarkerType__unicodeSequence mixins MarkerType {}
declare class MarkerType__circledNumber mixins MarkerType {}
declare class MarkerType__blackCircleWingding mixins MarkerType {}
declare class MarkerType__whiteCircleWingding mixins MarkerType {}
declare class MarkerType__arabicWide mixins MarkerType {}
declare class MarkerType__simplifiedChinese mixins MarkerType {}
declare class MarkerType__traditionalChinese mixins MarkerType {}
declare class MarkerType__japanSimplifiedChinese mixins MarkerType {}
declare class MarkerType__japanKorea mixins MarkerType {}
declare class MarkerType__arabicDictionary mixins MarkerType {}
declare class MarkerType__arabicAbjad mixins MarkerType {}
declare class MarkerType__hebrew mixins MarkerType {}
declare class MarkerType__thaiAlphabetic mixins MarkerType {}
declare class MarkerType__thaiNumeric mixins MarkerType {}
declare class MarkerType__devanagariVowel mixins MarkerType {}
declare class MarkerType__devanagariConsonant mixins MarkerType {}
declare class MarkerType__devanagariNumeric mixins MarkerType {}

	declare export  class ParagraphAlignment {
  constructor(...args: empty): mixed;
static +undefined: Class<ParagraphAlignment__undefined> & ParagraphAlignment__undefined & 0;// 0
static +left: Class<ParagraphAlignment__left> & ParagraphAlignment__left & 1;// 1
static +center: Class<ParagraphAlignment__center> & ParagraphAlignment__center & 2;// 2
static +right: Class<ParagraphAlignment__right> & ParagraphAlignment__right & 3;// 3
static +justify: Class<ParagraphAlignment__justify> & ParagraphAlignment__justify & 4;// 4

}

declare class ParagraphAlignment__undefined mixins ParagraphAlignment {}
declare class ParagraphAlignment__left mixins ParagraphAlignment {}
declare class ParagraphAlignment__center mixins ParagraphAlignment {}
declare class ParagraphAlignment__right mixins ParagraphAlignment {}
declare class ParagraphAlignment__justify mixins ParagraphAlignment {}

	declare export  class ParagraphStyle {
  constructor(...args: empty): mixed;
static +undefined: Class<ParagraphStyle__undefined> & ParagraphStyle__undefined & 0;// 0
static +none: Class<ParagraphStyle__none> & ParagraphStyle__none & 1;// 1
static +normal: Class<ParagraphStyle__normal> & ParagraphStyle__normal & 2;// 2
static +heading1: Class<ParagraphStyle__heading1> & ParagraphStyle__heading1 & 3;// 3
static +heading2: Class<ParagraphStyle__heading2> & ParagraphStyle__heading2 & 4;// 4
static +heading3: Class<ParagraphStyle__heading3> & ParagraphStyle__heading3 & 5;// 5
static +heading4: Class<ParagraphStyle__heading4> & ParagraphStyle__heading4 & 6;// 6
static +heading5: Class<ParagraphStyle__heading5> & ParagraphStyle__heading5 & 7;// 7
static +heading6: Class<ParagraphStyle__heading6> & ParagraphStyle__heading6 & 8;// 8
static +heading7: Class<ParagraphStyle__heading7> & ParagraphStyle__heading7 & 9;// 9
static +heading8: Class<ParagraphStyle__heading8> & ParagraphStyle__heading8 & 10;// 10
static +heading9: Class<ParagraphStyle__heading9> & ParagraphStyle__heading9 & 11;// 11

}

declare class ParagraphStyle__undefined mixins ParagraphStyle {}
declare class ParagraphStyle__none mixins ParagraphStyle {}
declare class ParagraphStyle__normal mixins ParagraphStyle {}
declare class ParagraphStyle__heading1 mixins ParagraphStyle {}
declare class ParagraphStyle__heading2 mixins ParagraphStyle {}
declare class ParagraphStyle__heading3 mixins ParagraphStyle {}
declare class ParagraphStyle__heading4 mixins ParagraphStyle {}
declare class ParagraphStyle__heading5 mixins ParagraphStyle {}
declare class ParagraphStyle__heading6 mixins ParagraphStyle {}
declare class ParagraphStyle__heading7 mixins ParagraphStyle {}
declare class ParagraphStyle__heading8 mixins ParagraphStyle {}
declare class ParagraphStyle__heading9 mixins ParagraphStyle {}

	declare export  class PointOptions {
  constructor(...args: empty): mixed;
static +none: Class<PointOptions__none> & PointOptions__none & 0;// 0
static +includeInset: Class<PointOptions__includeInset> & PointOptions__includeInset & 1;// 1
static +start: Class<PointOptions__start> & PointOptions__start & 2;// 2
static +clientCoordinates: Class<PointOptions__clientCoordinates> & PointOptions__clientCoordinates & 3;// 3
static +allowOffClient: Class<PointOptions__allowOffClient> & PointOptions__allowOffClient & 4;// 4
static +transform: Class<PointOptions__transform> & PointOptions__transform & 5;// 5
static +noHorizontalScroll: Class<PointOptions__noHorizontalScroll> & PointOptions__noHorizontalScroll & 6;// 6
static +noVerticalScroll: Class<PointOptions__noVerticalScroll> & PointOptions__noVerticalScroll & 7;// 7

}

declare class PointOptions__none mixins PointOptions {}
declare class PointOptions__includeInset mixins PointOptions {}
declare class PointOptions__start mixins PointOptions {}
declare class PointOptions__clientCoordinates mixins PointOptions {}
declare class PointOptions__allowOffClient mixins PointOptions {}
declare class PointOptions__transform mixins PointOptions {}
declare class PointOptions__noHorizontalScroll mixins PointOptions {}
declare class PointOptions__noVerticalScroll mixins PointOptions {}

	declare export  class RangeGravity {
  constructor(...args: empty): mixed;
static +uIBehavior: Class<RangeGravity__uIBehavior> & RangeGravity__uIBehavior & 0;// 0
static +backward: Class<RangeGravity__backward> & RangeGravity__backward & 1;// 1
static +forward: Class<RangeGravity__forward> & RangeGravity__forward & 2;// 2
static +inward: Class<RangeGravity__inward> & RangeGravity__inward & 3;// 3
static +outward: Class<RangeGravity__outward> & RangeGravity__outward & 4;// 4

}

declare class RangeGravity__uIBehavior mixins RangeGravity {}
declare class RangeGravity__backward mixins RangeGravity {}
declare class RangeGravity__forward mixins RangeGravity {}
declare class RangeGravity__inward mixins RangeGravity {}
declare class RangeGravity__outward mixins RangeGravity {}

	declare export  class SelectionOptions {
  constructor(...args: empty): mixed;
static +startActive: Class<SelectionOptions__startActive> & SelectionOptions__startActive & 0;// 0
static +atEndOfLine: Class<SelectionOptions__atEndOfLine> & SelectionOptions__atEndOfLine & 1;// 1
static +overtype: Class<SelectionOptions__overtype> & SelectionOptions__overtype & 2;// 2
static +active: Class<SelectionOptions__active> & SelectionOptions__active & 3;// 3
static +replace: Class<SelectionOptions__replace> & SelectionOptions__replace & 4;// 4

}

declare class SelectionOptions__startActive mixins SelectionOptions {}
declare class SelectionOptions__atEndOfLine mixins SelectionOptions {}
declare class SelectionOptions__overtype mixins SelectionOptions {}
declare class SelectionOptions__active mixins SelectionOptions {}
declare class SelectionOptions__replace mixins SelectionOptions {}

	declare export  class SelectionType {
  constructor(...args: empty): mixed;
static +none: Class<SelectionType__none> & SelectionType__none & 0;// 0
static +insertionPoint: Class<SelectionType__insertionPoint> & SelectionType__insertionPoint & 1;// 1
static +normal: Class<SelectionType__normal> & SelectionType__normal & 2;// 2
static +inlineShape: Class<SelectionType__inlineShape> & SelectionType__inlineShape & 3;// 3
static +shape: Class<SelectionType__shape> & SelectionType__shape & 4;// 4

}

declare class SelectionType__none mixins SelectionType {}
declare class SelectionType__insertionPoint mixins SelectionType {}
declare class SelectionType__normal mixins SelectionType {}
declare class SelectionType__inlineShape mixins SelectionType {}
declare class SelectionType__shape mixins SelectionType {}

	declare export  class TabAlignment {
  constructor(...args: empty): mixed;
static +left: Class<TabAlignment__left> & TabAlignment__left & 0;// 0
static +center: Class<TabAlignment__center> & TabAlignment__center & 1;// 1
static +right: Class<TabAlignment__right> & TabAlignment__right & 2;// 2
static +decimal: Class<TabAlignment__decimal> & TabAlignment__decimal & 3;// 3
static +bar: Class<TabAlignment__bar> & TabAlignment__bar & 4;// 4

}

declare class TabAlignment__left mixins TabAlignment {}
declare class TabAlignment__center mixins TabAlignment {}
declare class TabAlignment__right mixins TabAlignment {}
declare class TabAlignment__decimal mixins TabAlignment {}
declare class TabAlignment__bar mixins TabAlignment {}

	declare export  class TabLeader {
  constructor(...args: empty): mixed;
static +spaces: Class<TabLeader__spaces> & TabLeader__spaces & 0;// 0
static +dots: Class<TabLeader__dots> & TabLeader__dots & 1;// 1
static +dashes: Class<TabLeader__dashes> & TabLeader__dashes & 2;// 2
static +lines: Class<TabLeader__lines> & TabLeader__lines & 3;// 3
static +thickLines: Class<TabLeader__thickLines> & TabLeader__thickLines & 4;// 4
static +equals: Class<TabLeader__equals> & TabLeader__equals & 5;// 5

}

declare class TabLeader__spaces mixins TabLeader {}
declare class TabLeader__dots mixins TabLeader {}
declare class TabLeader__dashes mixins TabLeader {}
declare class TabLeader__lines mixins TabLeader {}
declare class TabLeader__thickLines mixins TabLeader {}
declare class TabLeader__equals mixins TabLeader {}

	declare export  class TextGetOptions {
  constructor(...args: empty): mixed;
static +none: Class<TextGetOptions__none> & TextGetOptions__none & 0;// 0
static +adjustCrlf: Class<TextGetOptions__adjustCrlf> & TextGetOptions__adjustCrlf & 1;// 1
static +useCrlf: Class<TextGetOptions__useCrlf> & TextGetOptions__useCrlf & 2;// 2
static +useObjectText: Class<TextGetOptions__useObjectText> & TextGetOptions__useObjectText & 3;// 3
static +allowFinalEop: Class<TextGetOptions__allowFinalEop> & TextGetOptions__allowFinalEop & 4;// 4
static +noHidden: Class<TextGetOptions__noHidden> & TextGetOptions__noHidden & 5;// 5
static +includeNumbering: Class<TextGetOptions__includeNumbering> & TextGetOptions__includeNumbering & 6;// 6
static +formatRtf: Class<TextGetOptions__formatRtf> & TextGetOptions__formatRtf & 7;// 7

}

declare class TextGetOptions__none mixins TextGetOptions {}
declare class TextGetOptions__adjustCrlf mixins TextGetOptions {}
declare class TextGetOptions__useCrlf mixins TextGetOptions {}
declare class TextGetOptions__useObjectText mixins TextGetOptions {}
declare class TextGetOptions__allowFinalEop mixins TextGetOptions {}
declare class TextGetOptions__noHidden mixins TextGetOptions {}
declare class TextGetOptions__includeNumbering mixins TextGetOptions {}
declare class TextGetOptions__formatRtf mixins TextGetOptions {}

	declare export  class TextSetOptions {
  constructor(...args: empty): mixed;
static +none: Class<TextSetOptions__none> & TextSetOptions__none & 0;// 0
static +unicodeBidi: Class<TextSetOptions__unicodeBidi> & TextSetOptions__unicodeBidi & 1;// 1
static +unlink: Class<TextSetOptions__unlink> & TextSetOptions__unlink & 2;// 2
static +unhide: Class<TextSetOptions__unhide> & TextSetOptions__unhide & 3;// 3
static +checkTextLimit: Class<TextSetOptions__checkTextLimit> & TextSetOptions__checkTextLimit & 4;// 4
static +formatRtf: Class<TextSetOptions__formatRtf> & TextSetOptions__formatRtf & 5;// 5
static +applyRtfDocumentDefaults: Class<TextSetOptions__applyRtfDocumentDefaults> & TextSetOptions__applyRtfDocumentDefaults & 6;// 6

}

declare class TextSetOptions__none mixins TextSetOptions {}
declare class TextSetOptions__unicodeBidi mixins TextSetOptions {}
declare class TextSetOptions__unlink mixins TextSetOptions {}
declare class TextSetOptions__unhide mixins TextSetOptions {}
declare class TextSetOptions__checkTextLimit mixins TextSetOptions {}
declare class TextSetOptions__formatRtf mixins TextSetOptions {}
declare class TextSetOptions__applyRtfDocumentDefaults mixins TextSetOptions {}

	declare export  class TextRangeUnit {
  constructor(...args: empty): mixed;
static +character: Class<TextRangeUnit__character> & TextRangeUnit__character & 0;// 0
static +word: Class<TextRangeUnit__word> & TextRangeUnit__word & 1;// 1
static +sentence: Class<TextRangeUnit__sentence> & TextRangeUnit__sentence & 2;// 2
static +paragraph: Class<TextRangeUnit__paragraph> & TextRangeUnit__paragraph & 3;// 3
static +line: Class<TextRangeUnit__line> & TextRangeUnit__line & 4;// 4
static +story: Class<TextRangeUnit__story> & TextRangeUnit__story & 5;// 5
static +screen: Class<TextRangeUnit__screen> & TextRangeUnit__screen & 6;// 6
static +section: Class<TextRangeUnit__section> & TextRangeUnit__section & 7;// 7
static +window: Class<TextRangeUnit__window> & TextRangeUnit__window & 8;// 8
static +characterFormat: Class<TextRangeUnit__characterFormat> & TextRangeUnit__characterFormat & 9;// 9
static +paragraphFormat: Class<TextRangeUnit__paragraphFormat> & TextRangeUnit__paragraphFormat & 10;// 10
static +object: Class<TextRangeUnit__object> & TextRangeUnit__object & 11;// 11
static +hardParagraph: Class<TextRangeUnit__hardParagraph> & TextRangeUnit__hardParagraph & 12;// 12
static +cluster: Class<TextRangeUnit__cluster> & TextRangeUnit__cluster & 13;// 13
static +bold: Class<TextRangeUnit__bold> & TextRangeUnit__bold & 14;// 14
static +italic: Class<TextRangeUnit__italic> & TextRangeUnit__italic & 15;// 15
static +underline: Class<TextRangeUnit__underline> & TextRangeUnit__underline & 16;// 16
static +strikethrough: Class<TextRangeUnit__strikethrough> & TextRangeUnit__strikethrough & 17;// 17
static +protectedText: Class<TextRangeUnit__protectedText> & TextRangeUnit__protectedText & 18;// 18
static +link: Class<TextRangeUnit__link> & TextRangeUnit__link & 19;// 19
static +smallCaps: Class<TextRangeUnit__smallCaps> & TextRangeUnit__smallCaps & 20;// 20
static +allCaps: Class<TextRangeUnit__allCaps> & TextRangeUnit__allCaps & 21;// 21
static +hidden: Class<TextRangeUnit__hidden> & TextRangeUnit__hidden & 22;// 22
static +outline: Class<TextRangeUnit__outline> & TextRangeUnit__outline & 23;// 23
static +shadow: Class<TextRangeUnit__shadow> & TextRangeUnit__shadow & 24;// 24
static +imprint: Class<TextRangeUnit__imprint> & TextRangeUnit__imprint & 25;// 25
static +disabled: Class<TextRangeUnit__disabled> & TextRangeUnit__disabled & 26;// 26
static +revised: Class<TextRangeUnit__revised> & TextRangeUnit__revised & 27;// 27
static +subscript: Class<TextRangeUnit__subscript> & TextRangeUnit__subscript & 28;// 28
static +superscript: Class<TextRangeUnit__superscript> & TextRangeUnit__superscript & 29;// 29
static +fontBound: Class<TextRangeUnit__fontBound> & TextRangeUnit__fontBound & 30;// 30
static +linkProtected: Class<TextRangeUnit__linkProtected> & TextRangeUnit__linkProtected & 31;// 31

}

declare class TextRangeUnit__character mixins TextRangeUnit {}
declare class TextRangeUnit__word mixins TextRangeUnit {}
declare class TextRangeUnit__sentence mixins TextRangeUnit {}
declare class TextRangeUnit__paragraph mixins TextRangeUnit {}
declare class TextRangeUnit__line mixins TextRangeUnit {}
declare class TextRangeUnit__story mixins TextRangeUnit {}
declare class TextRangeUnit__screen mixins TextRangeUnit {}
declare class TextRangeUnit__section mixins TextRangeUnit {}
declare class TextRangeUnit__window mixins TextRangeUnit {}
declare class TextRangeUnit__characterFormat mixins TextRangeUnit {}
declare class TextRangeUnit__paragraphFormat mixins TextRangeUnit {}
declare class TextRangeUnit__object mixins TextRangeUnit {}
declare class TextRangeUnit__hardParagraph mixins TextRangeUnit {}
declare class TextRangeUnit__cluster mixins TextRangeUnit {}
declare class TextRangeUnit__bold mixins TextRangeUnit {}
declare class TextRangeUnit__italic mixins TextRangeUnit {}
declare class TextRangeUnit__underline mixins TextRangeUnit {}
declare class TextRangeUnit__strikethrough mixins TextRangeUnit {}
declare class TextRangeUnit__protectedText mixins TextRangeUnit {}
declare class TextRangeUnit__link mixins TextRangeUnit {}
declare class TextRangeUnit__smallCaps mixins TextRangeUnit {}
declare class TextRangeUnit__allCaps mixins TextRangeUnit {}
declare class TextRangeUnit__hidden mixins TextRangeUnit {}
declare class TextRangeUnit__outline mixins TextRangeUnit {}
declare class TextRangeUnit__shadow mixins TextRangeUnit {}
declare class TextRangeUnit__imprint mixins TextRangeUnit {}
declare class TextRangeUnit__disabled mixins TextRangeUnit {}
declare class TextRangeUnit__revised mixins TextRangeUnit {}
declare class TextRangeUnit__subscript mixins TextRangeUnit {}
declare class TextRangeUnit__superscript mixins TextRangeUnit {}
declare class TextRangeUnit__fontBound mixins TextRangeUnit {}
declare class TextRangeUnit__linkProtected mixins TextRangeUnit {}

	declare export  class TextScript {
  constructor(...args: empty): mixed;
static +undefined: Class<TextScript__undefined> & TextScript__undefined & 0;// 0
static +ansi: Class<TextScript__ansi> & TextScript__ansi & 1;// 1
static +eastEurope: Class<TextScript__eastEurope> & TextScript__eastEurope & 2;// 2
static +cyrillic: Class<TextScript__cyrillic> & TextScript__cyrillic & 3;// 3
static +greek: Class<TextScript__greek> & TextScript__greek & 4;// 4
static +turkish: Class<TextScript__turkish> & TextScript__turkish & 5;// 5
static +hebrew: Class<TextScript__hebrew> & TextScript__hebrew & 6;// 6
static +arabic: Class<TextScript__arabic> & TextScript__arabic & 7;// 7
static +baltic: Class<TextScript__baltic> & TextScript__baltic & 8;// 8
static +vietnamese: Class<TextScript__vietnamese> & TextScript__vietnamese & 9;// 9
static +default: Class<TextScript__default> & TextScript__default & 10;// 10
static +symbol: Class<TextScript__symbol> & TextScript__symbol & 11;// 11
static +thai: Class<TextScript__thai> & TextScript__thai & 12;// 12
static +shiftJis: Class<TextScript__shiftJis> & TextScript__shiftJis & 13;// 13
static +gB2312: Class<TextScript__gB2312> & TextScript__gB2312 & 14;// 14
static +hangul: Class<TextScript__hangul> & TextScript__hangul & 15;// 15
static +big5: Class<TextScript__big5> & TextScript__big5 & 16;// 16
static +pC437: Class<TextScript__pC437> & TextScript__pC437 & 17;// 17
static +oem: Class<TextScript__oem> & TextScript__oem & 18;// 18
static +mac: Class<TextScript__mac> & TextScript__mac & 19;// 19
static +armenian: Class<TextScript__armenian> & TextScript__armenian & 20;// 20
static +syriac: Class<TextScript__syriac> & TextScript__syriac & 21;// 21
static +thaana: Class<TextScript__thaana> & TextScript__thaana & 22;// 22
static +devanagari: Class<TextScript__devanagari> & TextScript__devanagari & 23;// 23
static +bengali: Class<TextScript__bengali> & TextScript__bengali & 24;// 24
static +gurmukhi: Class<TextScript__gurmukhi> & TextScript__gurmukhi & 25;// 25
static +gujarati: Class<TextScript__gujarati> & TextScript__gujarati & 26;// 26
static +oriya: Class<TextScript__oriya> & TextScript__oriya & 27;// 27
static +tamil: Class<TextScript__tamil> & TextScript__tamil & 28;// 28
static +telugu: Class<TextScript__telugu> & TextScript__telugu & 29;// 29
static +kannada: Class<TextScript__kannada> & TextScript__kannada & 30;// 30
static +malayalam: Class<TextScript__malayalam> & TextScript__malayalam & 31;// 31
static +sinhala: Class<TextScript__sinhala> & TextScript__sinhala & 32;// 32
static +lao: Class<TextScript__lao> & TextScript__lao & 33;// 33
static +tibetan: Class<TextScript__tibetan> & TextScript__tibetan & 34;// 34
static +myanmar: Class<TextScript__myanmar> & TextScript__myanmar & 35;// 35
static +georgian: Class<TextScript__georgian> & TextScript__georgian & 36;// 36
static +jamo: Class<TextScript__jamo> & TextScript__jamo & 37;// 37
static +ethiopic: Class<TextScript__ethiopic> & TextScript__ethiopic & 38;// 38
static +cherokee: Class<TextScript__cherokee> & TextScript__cherokee & 39;// 39
static +aboriginal: Class<TextScript__aboriginal> & TextScript__aboriginal & 40;// 40
static +ogham: Class<TextScript__ogham> & TextScript__ogham & 41;// 41
static +runic: Class<TextScript__runic> & TextScript__runic & 42;// 42
static +khmer: Class<TextScript__khmer> & TextScript__khmer & 43;// 43
static +mongolian: Class<TextScript__mongolian> & TextScript__mongolian & 44;// 44
static +braille: Class<TextScript__braille> & TextScript__braille & 45;// 45
static +yi: Class<TextScript__yi> & TextScript__yi & 46;// 46
static +limbu: Class<TextScript__limbu> & TextScript__limbu & 47;// 47
static +taiLe: Class<TextScript__taiLe> & TextScript__taiLe & 48;// 48
static +newTaiLue: Class<TextScript__newTaiLue> & TextScript__newTaiLue & 49;// 49
static +sylotiNagri: Class<TextScript__sylotiNagri> & TextScript__sylotiNagri & 50;// 50
static +kharoshthi: Class<TextScript__kharoshthi> & TextScript__kharoshthi & 51;// 51
static +kayahli: Class<TextScript__kayahli> & TextScript__kayahli & 52;// 52
static +unicodeSymbol: Class<TextScript__unicodeSymbol> & TextScript__unicodeSymbol & 53;// 53
static +emoji: Class<TextScript__emoji> & TextScript__emoji & 54;// 54
static +glagolitic: Class<TextScript__glagolitic> & TextScript__glagolitic & 55;// 55
static +lisu: Class<TextScript__lisu> & TextScript__lisu & 56;// 56
static +vai: Class<TextScript__vai> & TextScript__vai & 57;// 57
static +nKo: Class<TextScript__nKo> & TextScript__nKo & 58;// 58
static +osmanya: Class<TextScript__osmanya> & TextScript__osmanya & 59;// 59
static +phagsPa: Class<TextScript__phagsPa> & TextScript__phagsPa & 60;// 60
static +gothic: Class<TextScript__gothic> & TextScript__gothic & 61;// 61
static +deseret: Class<TextScript__deseret> & TextScript__deseret & 62;// 62
static +tifinagh: Class<TextScript__tifinagh> & TextScript__tifinagh & 63;// 63

}

declare class TextScript__undefined mixins TextScript {}
declare class TextScript__ansi mixins TextScript {}
declare class TextScript__eastEurope mixins TextScript {}
declare class TextScript__cyrillic mixins TextScript {}
declare class TextScript__greek mixins TextScript {}
declare class TextScript__turkish mixins TextScript {}
declare class TextScript__hebrew mixins TextScript {}
declare class TextScript__arabic mixins TextScript {}
declare class TextScript__baltic mixins TextScript {}
declare class TextScript__vietnamese mixins TextScript {}
declare class TextScript__default mixins TextScript {}
declare class TextScript__symbol mixins TextScript {}
declare class TextScript__thai mixins TextScript {}
declare class TextScript__shiftJis mixins TextScript {}
declare class TextScript__gB2312 mixins TextScript {}
declare class TextScript__hangul mixins TextScript {}
declare class TextScript__big5 mixins TextScript {}
declare class TextScript__pC437 mixins TextScript {}
declare class TextScript__oem mixins TextScript {}
declare class TextScript__mac mixins TextScript {}
declare class TextScript__armenian mixins TextScript {}
declare class TextScript__syriac mixins TextScript {}
declare class TextScript__thaana mixins TextScript {}
declare class TextScript__devanagari mixins TextScript {}
declare class TextScript__bengali mixins TextScript {}
declare class TextScript__gurmukhi mixins TextScript {}
declare class TextScript__gujarati mixins TextScript {}
declare class TextScript__oriya mixins TextScript {}
declare class TextScript__tamil mixins TextScript {}
declare class TextScript__telugu mixins TextScript {}
declare class TextScript__kannada mixins TextScript {}
declare class TextScript__malayalam mixins TextScript {}
declare class TextScript__sinhala mixins TextScript {}
declare class TextScript__lao mixins TextScript {}
declare class TextScript__tibetan mixins TextScript {}
declare class TextScript__myanmar mixins TextScript {}
declare class TextScript__georgian mixins TextScript {}
declare class TextScript__jamo mixins TextScript {}
declare class TextScript__ethiopic mixins TextScript {}
declare class TextScript__cherokee mixins TextScript {}
declare class TextScript__aboriginal mixins TextScript {}
declare class TextScript__ogham mixins TextScript {}
declare class TextScript__runic mixins TextScript {}
declare class TextScript__khmer mixins TextScript {}
declare class TextScript__mongolian mixins TextScript {}
declare class TextScript__braille mixins TextScript {}
declare class TextScript__yi mixins TextScript {}
declare class TextScript__limbu mixins TextScript {}
declare class TextScript__taiLe mixins TextScript {}
declare class TextScript__newTaiLue mixins TextScript {}
declare class TextScript__sylotiNagri mixins TextScript {}
declare class TextScript__kharoshthi mixins TextScript {}
declare class TextScript__kayahli mixins TextScript {}
declare class TextScript__unicodeSymbol mixins TextScript {}
declare class TextScript__emoji mixins TextScript {}
declare class TextScript__glagolitic mixins TextScript {}
declare class TextScript__lisu mixins TextScript {}
declare class TextScript__vai mixins TextScript {}
declare class TextScript__nKo mixins TextScript {}
declare class TextScript__osmanya mixins TextScript {}
declare class TextScript__phagsPa mixins TextScript {}
declare class TextScript__gothic mixins TextScript {}
declare class TextScript__deseret mixins TextScript {}
declare class TextScript__tifinagh mixins TextScript {}

	declare export  class UnderlineType {
  constructor(...args: empty): mixed;
static +undefined: Class<UnderlineType__undefined> & UnderlineType__undefined & 0;// 0
static +none: Class<UnderlineType__none> & UnderlineType__none & 1;// 1
static +single: Class<UnderlineType__single> & UnderlineType__single & 2;// 2
static +words: Class<UnderlineType__words> & UnderlineType__words & 3;// 3
static +double: Class<UnderlineType__double> & UnderlineType__double & 4;// 4
static +dotted: Class<UnderlineType__dotted> & UnderlineType__dotted & 5;// 5
static +dash: Class<UnderlineType__dash> & UnderlineType__dash & 6;// 6
static +dashDot: Class<UnderlineType__dashDot> & UnderlineType__dashDot & 7;// 7
static +dashDotDot: Class<UnderlineType__dashDotDot> & UnderlineType__dashDotDot & 8;// 8
static +wave: Class<UnderlineType__wave> & UnderlineType__wave & 9;// 9
static +thick: Class<UnderlineType__thick> & UnderlineType__thick & 10;// 10
static +thin: Class<UnderlineType__thin> & UnderlineType__thin & 11;// 11
static +doubleWave: Class<UnderlineType__doubleWave> & UnderlineType__doubleWave & 12;// 12
static +heavyWave: Class<UnderlineType__heavyWave> & UnderlineType__heavyWave & 13;// 13
static +longDash: Class<UnderlineType__longDash> & UnderlineType__longDash & 14;// 14
static +thickDash: Class<UnderlineType__thickDash> & UnderlineType__thickDash & 15;// 15
static +thickDashDot: Class<UnderlineType__thickDashDot> & UnderlineType__thickDashDot & 16;// 16
static +thickDashDotDot: Class<UnderlineType__thickDashDotDot> & UnderlineType__thickDashDotDot & 17;// 17
static +thickDotted: Class<UnderlineType__thickDotted> & UnderlineType__thickDotted & 18;// 18
static +thickLongDash: Class<UnderlineType__thickLongDash> & UnderlineType__thickLongDash & 19;// 19

}

declare class UnderlineType__undefined mixins UnderlineType {}
declare class UnderlineType__none mixins UnderlineType {}
declare class UnderlineType__single mixins UnderlineType {}
declare class UnderlineType__words mixins UnderlineType {}
declare class UnderlineType__double mixins UnderlineType {}
declare class UnderlineType__dotted mixins UnderlineType {}
declare class UnderlineType__dash mixins UnderlineType {}
declare class UnderlineType__dashDot mixins UnderlineType {}
declare class UnderlineType__dashDotDot mixins UnderlineType {}
declare class UnderlineType__wave mixins UnderlineType {}
declare class UnderlineType__thick mixins UnderlineType {}
declare class UnderlineType__thin mixins UnderlineType {}
declare class UnderlineType__doubleWave mixins UnderlineType {}
declare class UnderlineType__heavyWave mixins UnderlineType {}
declare class UnderlineType__longDash mixins UnderlineType {}
declare class UnderlineType__thickDash mixins UnderlineType {}
declare class UnderlineType__thickDashDot mixins UnderlineType {}
declare class UnderlineType__thickDashDotDot mixins UnderlineType {}
declare class UnderlineType__thickDotted mixins UnderlineType {}
declare class UnderlineType__thickLongDash mixins UnderlineType {}

	declare export  class VerticalCharacterAlignment {
  constructor(...args: empty): mixed;
static +top: Class<VerticalCharacterAlignment__top> & VerticalCharacterAlignment__top & 0;// 0
static +baseline: Class<VerticalCharacterAlignment__baseline> & VerticalCharacterAlignment__baseline & 1;// 1
static +bottom: Class<VerticalCharacterAlignment__bottom> & VerticalCharacterAlignment__bottom & 2;// 2

}

declare class VerticalCharacterAlignment__top mixins VerticalCharacterAlignment {}
declare class VerticalCharacterAlignment__baseline mixins VerticalCharacterAlignment {}
declare class VerticalCharacterAlignment__bottom mixins VerticalCharacterAlignment {}

	declare export class TextConstants  {
static autoColor: Windows$Windows$UI.Color;
static maxUnitCount: number;
static minUnitCount: number;
static undefinedColor: Windows$Windows$UI.Color;
static undefinedFloatValue: number;
static undefinedFontStretch: Windows$Windows$UI.Text.FontStretch;
static undefinedFontStyle: Windows$Windows$UI.Text.FontStyle;
static undefinedInt32Value: number
}
	declare export interface ITextConstantsStatics {
autoColor: Windows$Windows$UI.Color,
maxUnitCount: number,
minUnitCount: number,
undefinedColor: Windows$Windows$UI.Color,
undefinedFloatValue: number,
undefinedFontStretch: Windows$Windows$UI.Text.FontStretch,
undefinedFontStyle: Windows$Windows$UI.Text.FontStyle,
undefinedInt32Value: number
} 
	declare export interface ITextDocument {
caretType: Windows$Windows$UI.Text.CaretType,
defaultTabStop: number,
selection: Windows$Windows$UI.Text.ITextSelection,
undoLimit: number,
canCopy(): boolean,
canPaste(): boolean,
canRedo(): boolean,
canUndo(): boolean,
applyDisplayUpdates(): number,
batchDisplayUpdates(): number,
beginUndoGroup(): void,
endUndoGroup(): void,
getDefaultCharacterFormat(): Windows$Windows$UI.Text.ITextCharacterFormat,
getDefaultParagraphFormat(): Windows$Windows$UI.Text.ITextParagraphFormat,
getRange(startPosition: number, endPosition: number): Windows$Windows$UI.Text.ITextRange,
getRangeFromPoint(
point: Windows$Windows$Foundation.Point,
options: Windows$Windows$UI.Text.PointOptions): Windows$Windows$UI.Text.ITextRange,
getText(options: Windows$Windows$UI.Text.TextGetOptions): string,
loadFromStream(
options: Windows$Windows$UI.Text.TextSetOptions,
value: Windows$Windows$Storage.Streams.IRandomAccessStream): void,
redo(): void,
saveToStream(
options: Windows$Windows$UI.Text.TextGetOptions,
value: Windows$Windows$Storage.Streams.IRandomAccessStream): void,
setDefaultCharacterFormat(value: Windows$Windows$UI.Text.ITextCharacterFormat): void,
setDefaultParagraphFormat(value: Windows$Windows$UI.Text.ITextParagraphFormat): void,
setText(options: Windows$Windows$UI.Text.TextSetOptions, value: string): void,
undo(): void
} 
	declare export interface ITextRange {
character: string,
characterFormat: Windows$Windows$UI.Text.ITextCharacterFormat,
endPosition: number,
formattedText: Windows$Windows$UI.Text.ITextRange,
gravity: Windows$Windows$UI.Text.RangeGravity,
length: number,
link: string,
paragraphFormat: Windows$Windows$UI.Text.ITextParagraphFormat,
startPosition: number,
storyLength: number,
text: string,
canPaste(format: number): boolean,
changeCase(value: Windows$Windows$UI.Text.LetterCase): void,
collapse(value: boolean): void,
copy(): void,
cut(): void,
delete_(unit: Windows$Windows$UI.Text.TextRangeUnit, count: number): number,
endOf(unit: Windows$Windows$UI.Text.TextRangeUnit, extend: boolean): number,
expand(unit: Windows$Windows$UI.Text.TextRangeUnit): number,
findText(
value: string,
scanLength: number,
options: Windows$Windows$UI.Text.FindOptions): number,
getCharacterUtf32(offset: number): number,
getClone(): Windows$Windows$UI.Text.ITextRange,
getIndex(unit: Windows$Windows$UI.Text.TextRangeUnit): number,
getPoint(
horizontalAlign: Windows$Windows$UI.Text.HorizontalCharacterAlignment,
verticalAlign: Windows$Windows$UI.Text.VerticalCharacterAlignment,
options: Windows$Windows$UI.Text.PointOptions): Windows$Windows$Foundation.Point,
getRect(
options: Windows$Windows$UI.Text.PointOptions): {
rect: Windows$Windows$Foundation.Rect,
hit: number
},
getText(options: Windows$Windows$UI.Text.TextGetOptions): string,
getTextViaStream(
options: Windows$Windows$UI.Text.TextGetOptions,
value: Windows$Windows$Storage.Streams.IRandomAccessStream): void,
inRange(range: Windows$Windows$UI.Text.ITextRange): boolean,
insertImage(
width: number,
height: number,
ascent: number,
verticalAlign: Windows$Windows$UI.Text.VerticalCharacterAlignment,
alternateText: string,
value: Windows$Windows$Storage.Streams.IRandomAccessStream): void,
inStory(range: Windows$Windows$UI.Text.ITextRange): boolean,
isEqual(range: Windows$Windows$UI.Text.ITextRange): boolean,
move(unit: Windows$Windows$UI.Text.TextRangeUnit, count: number): number,
moveEnd(unit: Windows$Windows$UI.Text.TextRangeUnit, count: number): number,
moveStart(unit: Windows$Windows$UI.Text.TextRangeUnit, count: number): number,
paste(format: number): void,
scrollIntoView(value: Windows$Windows$UI.Text.PointOptions): void,
matchSelection(): void,
setIndex(
unit: Windows$Windows$UI.Text.TextRangeUnit,
index: number,
extend: boolean): void,
setPoint(
point: Windows$Windows$Foundation.Point,
options: Windows$Windows$UI.Text.PointOptions,
extend: boolean): void,
setRange(startPosition: number, endPosition: number): void,
setText(options: Windows$Windows$UI.Text.TextSetOptions, value: string): void,
setTextViaStream(
options: Windows$Windows$UI.Text.TextSetOptions,
value: Windows$Windows$Storage.Streams.IRandomAccessStream): void,
startOf(unit: Windows$Windows$UI.Text.TextRangeUnit, extend: boolean): number
} 
	declare export type ITextSelection = {
options: Windows$Windows$UI.Text.SelectionOptions,
type: Windows$Windows$UI.Text.SelectionType,
endKey(unit: Windows$Windows$UI.Text.TextRangeUnit, extend: boolean): number,
homeKey(unit: Windows$Windows$UI.Text.TextRangeUnit, extend: boolean): number,
moveDown(
unit: Windows$Windows$UI.Text.TextRangeUnit,
count: number,
extend: boolean): number,
moveLeft(
unit: Windows$Windows$UI.Text.TextRangeUnit,
count: number,
extend: boolean): number,
moveRight(
unit: Windows$Windows$UI.Text.TextRangeUnit,
count: number,
extend: boolean): number,
moveUp(
unit: Windows$Windows$UI.Text.TextRangeUnit,
count: number,
extend: boolean): number,
typeText(value: string): void
} & undefined.ITextRange

	declare export interface ITextCharacterFormat {
allCaps: Windows$Windows$UI.Text.FormatEffect,
backgroundColor: Windows$Windows$UI.Color,
bold: Windows$Windows$UI.Text.FormatEffect,
fontStretch: Windows$Windows$UI.Text.FontStretch,
fontStyle: Windows$Windows$UI.Text.FontStyle,
foregroundColor: Windows$Windows$UI.Color,
hidden: Windows$Windows$UI.Text.FormatEffect,
italic: Windows$Windows$UI.Text.FormatEffect,
kerning: number,
languageTag: string,
linkType: Windows$Windows$UI.Text.LinkType,
name: string,
outline: Windows$Windows$UI.Text.FormatEffect,
position: number,
protectedText: Windows$Windows$UI.Text.FormatEffect,
size: number,
smallCaps: Windows$Windows$UI.Text.FormatEffect,
spacing: number,
strikethrough: Windows$Windows$UI.Text.FormatEffect,
subscript: Windows$Windows$UI.Text.FormatEffect,
superscript: Windows$Windows$UI.Text.FormatEffect,
textScript: Windows$Windows$UI.Text.TextScript,
underline: Windows$Windows$UI.Text.UnderlineType,
weight: number,
setClone(value: Windows$Windows$UI.Text.ITextCharacterFormat): void,
getClone(): Windows$Windows$UI.Text.ITextCharacterFormat,
isEqual(format: Windows$Windows$UI.Text.ITextCharacterFormat): boolean
} 
	declare export interface ITextParagraphFormat {
alignment: Windows$Windows$UI.Text.ParagraphAlignment,
firstLineIndent: number,
keepTogether: Windows$Windows$UI.Text.FormatEffect,
keepWithNext: Windows$Windows$UI.Text.FormatEffect,
leftIndent: number,
lineSpacing: number,
lineSpacingRule: Windows$Windows$UI.Text.LineSpacingRule,
listAlignment: Windows$Windows$UI.Text.MarkerAlignment,
listLevelIndex: number,
listStart: number,
listStyle: Windows$Windows$UI.Text.MarkerStyle,
listTab: number,
listType: Windows$Windows$UI.Text.MarkerType,
noLineNumber: Windows$Windows$UI.Text.FormatEffect,
pageBreakBefore: Windows$Windows$UI.Text.FormatEffect,
rightIndent: number,
rightToLeft: Windows$Windows$UI.Text.FormatEffect,
spaceAfter: number,
spaceBefore: number,
style: Windows$Windows$UI.Text.ParagraphStyle,
tabCount: number,
widowControl: Windows$Windows$UI.Text.FormatEffect,
addTab(
position: number,
align: Windows$Windows$UI.Text.TabAlignment,
leader: Windows$Windows$UI.Text.TabLeader): void,
clearAllTabs(): void,
deleteTab(position: number): void,
getClone(): Windows$Windows$UI.Text.ITextParagraphFormat,
getTab(
index: number): {
position: number,
align: Windows$Windows$UI.Text.TabAlignment,
leader: Windows$Windows$UI.Text.TabLeader
},
isEqual(format: Windows$Windows$UI.Text.ITextParagraphFormat): boolean,
setClone(format: Windows$Windows$UI.Text.ITextParagraphFormat): void,
setIndents(start: number, left: number, right: number): void,
setLineSpacing(rule: Windows$Windows$UI.Text.LineSpacingRule, spacing: number): void
} 
	declare export  class FontStyle {
  constructor(...args: empty): mixed;
static +normal: Class<FontStyle__normal> & FontStyle__normal & 0;// 0
static +oblique: Class<FontStyle__oblique> & FontStyle__oblique & 1;// 1
static +italic: Class<FontStyle__italic> & FontStyle__italic & 2;// 2

}

declare class FontStyle__normal mixins FontStyle {}
declare class FontStyle__oblique mixins FontStyle {}
declare class FontStyle__italic mixins FontStyle {}

	declare export  class FontStretch {
  constructor(...args: empty): mixed;
static +undefined: Class<FontStretch__undefined> & FontStretch__undefined & 0;// 0
static +ultraCondensed: Class<FontStretch__ultraCondensed> & FontStretch__ultraCondensed & 1;// 1
static +extraCondensed: Class<FontStretch__extraCondensed> & FontStretch__extraCondensed & 2;// 2
static +condensed: Class<FontStretch__condensed> & FontStretch__condensed & 3;// 3
static +semiCondensed: Class<FontStretch__semiCondensed> & FontStretch__semiCondensed & 4;// 4
static +normal: Class<FontStretch__normal> & FontStretch__normal & 5;// 5
static +semiExpanded: Class<FontStretch__semiExpanded> & FontStretch__semiExpanded & 6;// 6
static +expanded: Class<FontStretch__expanded> & FontStretch__expanded & 7;// 7
static +extraExpanded: Class<FontStretch__extraExpanded> & FontStretch__extraExpanded & 8;// 8
static +ultraExpanded: Class<FontStretch__ultraExpanded> & FontStretch__ultraExpanded & 9;// 9

}

declare class FontStretch__undefined mixins FontStretch {}
declare class FontStretch__ultraCondensed mixins FontStretch {}
declare class FontStretch__extraCondensed mixins FontStretch {}
declare class FontStretch__condensed mixins FontStretch {}
declare class FontStretch__semiCondensed mixins FontStretch {}
declare class FontStretch__normal mixins FontStretch {}
declare class FontStretch__semiExpanded mixins FontStretch {}
declare class FontStretch__expanded mixins FontStretch {}
declare class FontStretch__extraExpanded mixins FontStretch {}
declare class FontStretch__ultraExpanded mixins FontStretch {}

	declare export interface FontWeight {
weight: number
} 
	declare export interface IFontWeights {} 
	declare export interface IFontWeightsStatics {
black: Windows$Windows$UI.Text.FontWeight,
bold: Windows$Windows$UI.Text.FontWeight,
extraBlack: Windows$Windows$UI.Text.FontWeight,
extraBold: Windows$Windows$UI.Text.FontWeight,
extraLight: Windows$Windows$UI.Text.FontWeight,
light: Windows$Windows$UI.Text.FontWeight,
medium: Windows$Windows$UI.Text.FontWeight,
normal: Windows$Windows$UI.Text.FontWeight,
semiBold: Windows$Windows$UI.Text.FontWeight,
semiLight: Windows$Windows$UI.Text.FontWeight,
thin: Windows$Windows$UI.Text.FontWeight
} 
	declare export class FontWeights mixins undefined.IFontWeights {
static black: Windows$Windows$UI.Text.FontWeight;
static bold: Windows$Windows$UI.Text.FontWeight;
static extraBlack: Windows$Windows$UI.Text.FontWeight;
static extraBold: Windows$Windows$UI.Text.FontWeight;
static extraLight: Windows$Windows$UI.Text.FontWeight;
static light: Windows$Windows$UI.Text.FontWeight;
static medium: Windows$Windows$UI.Text.FontWeight;
static normal: Windows$Windows$UI.Text.FontWeight;
static semiBold: Windows$Windows$UI.Text.FontWeight;
static semiLight: Windows$Windows$UI.Text.FontWeight;
static thin: Windows$Windows$UI.Text.FontWeight
}
    }

	declare module 'Core' {
        declare export class CoreApplication  {
static mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>;
static id: string;
static properties: Windows$Windows$Foundation.Collections.IPropertySet;
static incrementApplicationUseCount(): void;
static decrementApplicationUseCount(): void;
static createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static exit(): void;
static onexiting: any;
static onsuspending: any;
static onresuming: any;
static getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void;
static runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
}
	declare export class CoreApplicationView mixins undefined.ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow;
isHosted: boolean;
isMain: boolean;
onactivated: any
}
	declare export interface IFrameworkView {
initialize(
applicationView: Windows$Windows$ApplicationModel.Core.CoreApplicationView): void,
setWindow(window: Windows$Windows$UI.Core.CoreWindow): void,
load(entryPoint: string): void,
run(): void,
uninitialize(): void
} 
	declare export interface IFrameworkViewSource {
createView(): Windows$Windows$ApplicationModel.Core.IFrameworkView
} 
	declare export interface ICoreApplication {
id: string,
properties: Windows$Windows$Foundation.Collections.IPropertySet,
onsuspending: any,
onresuming: any,
getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView,
run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void,
runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
} 
	declare export interface ICoreApplicationUseCount {
incrementApplicationUseCount(): void,
decrementApplicationUseCount(): void
} 
	declare export interface ICoreApplicationExit {
exit(): void,
onexiting: any
} 
	declare export interface ICoreImmersiveApplication {
mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView,
views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>,
createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView
} 
	declare export interface ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow,
isHosted: boolean,
isMain: boolean,
onactivated: any
} 
	declare export interface IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext,
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap,
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void,
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void
} 
	declare export class ResourceMap mixins undefined.IResourceMap, undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
uri: Windows$Windows$Foundation.Uri;
size: number;
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.NamedResource;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>
}
	declare export class ResourceContext mixins undefined.IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>;
reset(): void;
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void;
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void;
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
static createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
}
	declare export interface IResourceManagerStatics {
current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager,
isResourceReference(resourceReference: string): boolean
} 
	declare export class ResourceManager mixins undefined.IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
static current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager;
static isResourceReference(resourceReference: string): boolean
}
	declare export interface IResourceQualifier {
isDefault: boolean,
isMatch: boolean,
qualifierName: string,
qualifierValue: string,
score: number
} 
	declare export class ResourceQualifier mixins undefined.IResourceQualifier {
isDefault: boolean;
isMatch: boolean;
qualifierName: string;
qualifierValue: string;
score: number
}
	declare export interface IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>,
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>,
reset(): void,
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void,
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void,
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceContextStatics {
createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceCandidate {
isDefault: boolean,
isMatch: boolean,
isMatchAsDefault: boolean,
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>,
valueAsString: string,
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
getQualifierValue(qualifierName: string): string
} 
	declare export class ResourceCandidate mixins undefined.IResourceCandidate {
isDefault: boolean;
isMatch: boolean;
isMatchAsDefault: boolean;
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
valueAsString: string;
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
getQualifierValue(qualifierName: string): string
}
	declare export interface INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
uri: Windows$Windows$Foundation.Uri,
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
} 
	declare export class NamedResource mixins undefined.INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
uri: Windows$Windows$Foundation.Uri;
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
}
	declare export type IResourceMap = {
uri: Windows$Windows$Foundation.Uri,
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap
} & undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource> & undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>

	declare export class ResourceMapIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>[],
returnValue: number
}
}
	declare export class ResourceMapMapView mixins undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
size: number;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>>
}
	declare export class ResourceMapMapViewIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>[],
returnValue: number
}
}
	declare export class ResourceQualifierObservableMap mixins undefined.IObservableMap<string, string>, undefined.IMap<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
onmapchanged: any;
lookup(key: string): string;
hasKey(key: string): boolean;
getView(): Windows$Windows$Foundation.Collections.IMapView<string, string>;
insert(key: string, value: string): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierMapView mixins undefined.IMapView<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
lookup(key: string): string;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, string>,
second: Windows$Windows$Foundation.Collections.IMapView<string, string>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceCandidateVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceContextLanguagesVectorView mixins undefined.IVectorView<string>, undefined.IIterable<string> {
size: number;
getAt(index: number): string;
indexOf(value: string): {
index: number,
returnValue: boolean
};
getMany(startIndex: number): {
items: string[],
returnValue: number
};
first(): Windows$Windows$Foundation.Collections.IIterator<string>;
toString(): string;
toLocaleString(): string;
concat(...items: string[][]): string[];
join(seperator: string): string;
pop(): string;
push(...items: string[]): void;
reverse(): string[];
shift(): string;
slice(start: number): string[];
slice(start: number, end: number): string[];
sort(): string[];
sort(compareFn: (a: string, b: string) => number): string[];
splice(start: number): string[];
splice(start: number, deleteCount: number, ...items: string[]): string[];
unshift(...items: string[]): number;
lastIndexOf(searchElement: string): number;
lastIndexOf(searchElement: string, fromIndex: number): number;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
forEach(callbackfn: (value: string, index: number, array: string[]) => void): void;
forEach(
callbackfn: (value: string, index: number, array: string[]) => void,
thisArg: any): void;
map(callbackfn: (value: string, index: number, array: string[]) => any): any[];
map(
callbackfn: (value: string, index: number, array: string[]) => any,
thisArg: any): any[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean): string[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): string[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
length: number
}
	declare export interface IApplicationDataManagerStatics {
createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
} 
	declare export interface IApplicationDataManager {} 
	declare export class ApplicationDataManager mixins undefined.IApplicationDataManager {
static createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
}
	declare export  class CryptographicPrivateKeyBlobType {
  constructor(...args: empty): mixed;
static +pkcs8RawPrivateKeyInfo: Class<CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo> & CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo & 0;// 0
static +pkcs1RsaPrivateKey: Class<CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey> & CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey & 1;// 1
static +bCryptPrivateKey: Class<CryptographicPrivateKeyBlobType__bCryptPrivateKey> & CryptographicPrivateKeyBlobType__bCryptPrivateKey & 2;// 2
static +capi1PrivateKey: Class<CryptographicPrivateKeyBlobType__capi1PrivateKey> & CryptographicPrivateKeyBlobType__capi1PrivateKey & 3;// 3

}

declare class CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__bCryptPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__capi1PrivateKey mixins CryptographicPrivateKeyBlobType {}

	declare export  class CryptographicPublicKeyBlobType {
  constructor(...args: empty): mixed;
static +x509SubjectPublicKeyInfo: Class<CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo> & CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo & 0;// 0
static +pkcs1RsaPublicKey: Class<CryptographicPublicKeyBlobType__pkcs1RsaPublicKey> & CryptographicPublicKeyBlobType__pkcs1RsaPublicKey & 1;// 1
static +bCryptPublicKey: Class<CryptographicPublicKeyBlobType__bCryptPublicKey> & CryptographicPublicKeyBlobType__bCryptPublicKey & 2;// 2
static +capi1PublicKey: Class<CryptographicPublicKeyBlobType__capi1PublicKey> & CryptographicPublicKeyBlobType__capi1PublicKey & 3;// 3

}

declare class CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__pkcs1RsaPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__bCryptPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__capi1PublicKey mixins CryptographicPublicKeyBlobType {}

	declare export interface IKeyDerivationParameters {
iterationCount: number,
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export interface IKeyDerivationParametersStatics {
buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
} 
	declare export class KeyDerivationParameters mixins undefined.IKeyDerivationParameters {
iterationCount: number;
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer;
static buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
}
	declare export interface ICryptographicKey {
keySize: number,
export(): Windows$Windows$Storage.Streams.IBuffer,
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicKey mixins undefined.ICryptographicKey {
keySize: number;
export(): Windows$Windows$Storage.Streams.IBuffer;
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void,
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicHash mixins undefined.IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void;
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProvider {
algorithmName: string,
hashLength: number,
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash
} 
	declare export interface IMacAlgorithmProvider {
algorithmName: string,
macLength: number,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IKeyDerivationAlgorithmProvider {
algorithmName: string,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface ISymmetricKeyAlgorithmProvider {
algorithmName: string,
blockLength: number,
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IAsymmetricKeyAlgorithmProvider {
algorithmName: string,
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
encryptedData: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class EncryptedAndAuthenticatedData mixins undefined.IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer;
encryptedData: Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface ICryptographicEngineStatics {
encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData,
decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean,
deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicEngine  {
static encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData;
static decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean;
static deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
} 
	declare export class HashAlgorithmProvider mixins undefined.IHashAlgorithmProvider {
algorithmName: string;
hashLength: number;
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
}
	declare export interface IMacAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
} 
	declare export class MacAlgorithmProvider mixins undefined.IMacAlgorithmProvider {
algorithmName: string;
macLength: number;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
}
	declare export interface IKeyDerivationAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
} 
	declare export class KeyDerivationAlgorithmProvider mixins undefined.IKeyDerivationAlgorithmProvider {
algorithmName: string;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
}
	declare export interface ISymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
} 
	declare export class SymmetricKeyAlgorithmProvider mixins undefined.ISymmetricKeyAlgorithmProvider {
algorithmName: string;
blockLength: number;
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
}
	declare export interface IAsymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
} 
	declare export class AsymmetricKeyAlgorithmProvider mixins undefined.IAsymmetricKeyAlgorithmProvider {
algorithmName: string;
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
}
	declare export interface IHashAlgorithmNamesStatics {
md5: string,
sha1: string,
sha256: string,
sha384: string,
sha512: string
} 
	declare export class HashAlgorithmNames  {
static md5: string;
static sha1: string;
static sha256: string;
static sha384: string;
static sha512: string
}
	declare export interface IMacAlgorithmNamesStatics {
aesCmac: string,
hmacMd5: string,
hmacSha1: string,
hmacSha256: string,
hmacSha384: string,
hmacSha512: string
} 
	declare export class MacAlgorithmNames  {
static aesCmac: string;
static hmacMd5: string;
static hmacSha1: string;
static hmacSha256: string;
static hmacSha384: string;
static hmacSha512: string
}
	declare export interface ISymmetricAlgorithmNamesStatics {
aesCbc: string,
aesCbcPkcs7: string,
aesCcm: string,
aesEcb: string,
aesEcbPkcs7: string,
aesGcm: string,
desCbc: string,
desCbcPkcs7: string,
desEcb: string,
desEcbPkcs7: string,
rc2Cbc: string,
rc2CbcPkcs7: string,
rc2Ecb: string,
rc2EcbPkcs7: string,
rc4: string,
tripleDesCbc: string,
tripleDesCbcPkcs7: string,
tripleDesEcb: string,
tripleDesEcbPkcs7: string
} 
	declare export class SymmetricAlgorithmNames  {
static aesCbc: string;
static aesCbcPkcs7: string;
static aesCcm: string;
static aesEcb: string;
static aesEcbPkcs7: string;
static aesGcm: string;
static desCbc: string;
static desCbcPkcs7: string;
static desEcb: string;
static desEcbPkcs7: string;
static rc2Cbc: string;
static rc2CbcPkcs7: string;
static rc2Ecb: string;
static rc2EcbPkcs7: string;
static rc4: string;
static tripleDesCbc: string;
static tripleDesCbcPkcs7: string;
static tripleDesEcb: string;
static tripleDesEcbPkcs7: string
}
	declare export interface IAsymmetricAlgorithmNamesStatics {
dsaSha1: string,
dsaSha256: string,
ecdsaP256Sha256: string,
ecdsaP384Sha384: string,
ecdsaP521Sha512: string,
rsaOaepSha1: string,
rsaOaepSha256: string,
rsaOaepSha384: string,
rsaOaepSha512: string,
rsaPkcs1: string,
rsaSignPkcs1Sha1: string,
rsaSignPkcs1Sha256: string,
rsaSignPkcs1Sha384: string,
rsaSignPkcs1Sha512: string,
rsaSignPssSha1: string,
rsaSignPssSha256: string,
rsaSignPssSha384: string,
rsaSignPssSha512: string
} 
	declare export class AsymmetricAlgorithmNames  {
static dsaSha1: string;
static dsaSha256: string;
static ecdsaP256Sha256: string;
static ecdsaP384Sha384: string;
static ecdsaP521Sha512: string;
static rsaOaepSha1: string;
static rsaOaepSha256: string;
static rsaOaepSha384: string;
static rsaOaepSha512: string;
static rsaPkcs1: string;
static rsaSignPkcs1Sha1: string;
static rsaSignPkcs1Sha256: string;
static rsaSignPkcs1Sha384: string;
static rsaSignPkcs1Sha512: string;
static rsaSignPssSha1: string;
static rsaSignPssSha256: string;
static rsaSignPssSha384: string;
static rsaSignPssSha512: string
}
	declare export interface IKeyDerivationAlgorithmNamesStatics {
pbkdf2Md5: string,
pbkdf2Sha1: string,
pbkdf2Sha256: string,
pbkdf2Sha384: string,
pbkdf2Sha512: string,
sp800108CtrHmacMd5: string,
sp800108CtrHmacSha1: string,
sp800108CtrHmacSha256: string,
sp800108CtrHmacSha384: string,
sp800108CtrHmacSha512: string,
sp80056aConcatMd5: string,
sp80056aConcatSha1: string,
sp80056aConcatSha256: string,
sp80056aConcatSha384: string,
sp80056aConcatSha512: string
} 
	declare export class KeyDerivationAlgorithmNames  {
static pbkdf2Md5: string;
static pbkdf2Sha1: string;
static pbkdf2Sha256: string;
static pbkdf2Sha384: string;
static pbkdf2Sha512: string;
static sp800108CtrHmacMd5: string;
static sp800108CtrHmacSha1: string;
static sp800108CtrHmacSha256: string;
static sp800108CtrHmacSha384: string;
static sp800108CtrHmacSha512: string;
static sp80056aConcatMd5: string;
static sp80056aConcatSha1: string;
static sp80056aConcatSha256: string;
static sp80056aConcatSha384: string;
static sp80056aConcatSha512: string
}
	declare export interface SignalHandler {
(signalNotifier: Windows$Windows$System.Threading.Core.SignalNotifier, timedOut: boolean): void
} 
	declare export class SignalNotifier mixins undefined.ISignalNotifier {
enable(): void;
terminate(): void;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
}
	declare export interface ISignalNotifierStatics {
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
} 
	declare export interface IPreallocatedWorkItemFactory {
createWorkItem(
handler: Windows$Windows$System.Threading.WorkItemHandler): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriority(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriorityAndOptions(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority,
options: Windows$Windows$System.Threading.WorkItemOptions): Windows$Windows$System.Threading.Core.PreallocatedWorkItem
} 
	declare export class PreallocatedWorkItem mixins undefined.IPreallocatedWorkItem {
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority, options: Windows$Windows$System.Threading.WorkItemOptions): this;
runAsync(): Windows$Windows$Foundation.IAsyncAction
}
	declare export interface IPreallocatedWorkItem {
runAsync(): Windows$Windows$Foundation.IAsyncAction
} 
	declare export interface ISignalNotifier {
enable(): void,
terminate(): void
} 
	declare module 'AnimationMetrics' {
        declare export  class PropertyAnimationType {
  constructor(...args: empty): mixed;
static +scale: Class<PropertyAnimationType__scale> & PropertyAnimationType__scale & 0;// 0
static +translation: Class<PropertyAnimationType__translation> & PropertyAnimationType__translation & 1;// 1
static +opacity: Class<PropertyAnimationType__opacity> & PropertyAnimationType__opacity & 2;// 2

}

declare class PropertyAnimationType__scale mixins PropertyAnimationType {}
declare class PropertyAnimationType__translation mixins PropertyAnimationType {}
declare class PropertyAnimationType__opacity mixins PropertyAnimationType {}

	declare export interface IPropertyAnimation {
control1: Windows$Windows$Foundation.Point,
control2: Windows$Windows$Foundation.Point,
delay: number,
duration: number,
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
} 
	declare export type IScaleAnimation = {
finalScaleX: number,
finalScaleY: number,
initialScaleX: number,
initialScaleY: number,
normalizedOrigin: Windows$Windows$Foundation.Point
} & undefined.IPropertyAnimation

	declare export type IOpacityAnimation = {
finalOpacity: number,
initialOpacity: number
} & undefined.IPropertyAnimation

	declare export  class AnimationEffect {
  constructor(...args: empty): mixed;
static +expand: Class<AnimationEffect__expand> & AnimationEffect__expand & 0;// 0
static +collapse: Class<AnimationEffect__collapse> & AnimationEffect__collapse & 1;// 1
static +reposition: Class<AnimationEffect__reposition> & AnimationEffect__reposition & 2;// 2
static +fadeIn: Class<AnimationEffect__fadeIn> & AnimationEffect__fadeIn & 3;// 3
static +fadeOut: Class<AnimationEffect__fadeOut> & AnimationEffect__fadeOut & 4;// 4
static +addToList: Class<AnimationEffect__addToList> & AnimationEffect__addToList & 5;// 5
static +deleteFromList: Class<AnimationEffect__deleteFromList> & AnimationEffect__deleteFromList & 6;// 6
static +addToGrid: Class<AnimationEffect__addToGrid> & AnimationEffect__addToGrid & 7;// 7
static +deleteFromGrid: Class<AnimationEffect__deleteFromGrid> & AnimationEffect__deleteFromGrid & 8;// 8
static +addToSearchGrid: Class<AnimationEffect__addToSearchGrid> & AnimationEffect__addToSearchGrid & 9;// 9
static +deleteFromSearchGrid: Class<AnimationEffect__deleteFromSearchGrid> & AnimationEffect__deleteFromSearchGrid & 10;// 10
static +addToSearchList: Class<AnimationEffect__addToSearchList> & AnimationEffect__addToSearchList & 11;// 11
static +deleteFromSearchList: Class<AnimationEffect__deleteFromSearchList> & AnimationEffect__deleteFromSearchList & 12;// 12
static +showEdgeUI: Class<AnimationEffect__showEdgeUI> & AnimationEffect__showEdgeUI & 13;// 13
static +showPanel: Class<AnimationEffect__showPanel> & AnimationEffect__showPanel & 14;// 14
static +hideEdgeUI: Class<AnimationEffect__hideEdgeUI> & AnimationEffect__hideEdgeUI & 15;// 15
static +hidePanel: Class<AnimationEffect__hidePanel> & AnimationEffect__hidePanel & 16;// 16
static +showPopup: Class<AnimationEffect__showPopup> & AnimationEffect__showPopup & 17;// 17
static +hidePopup: Class<AnimationEffect__hidePopup> & AnimationEffect__hidePopup & 18;// 18
static +pointerDown: Class<AnimationEffect__pointerDown> & AnimationEffect__pointerDown & 19;// 19
static +pointerUp: Class<AnimationEffect__pointerUp> & AnimationEffect__pointerUp & 20;// 20
static +dragSourceStart: Class<AnimationEffect__dragSourceStart> & AnimationEffect__dragSourceStart & 21;// 21
static +dragSourceEnd: Class<AnimationEffect__dragSourceEnd> & AnimationEffect__dragSourceEnd & 22;// 22
static +transitionContent: Class<AnimationEffect__transitionContent> & AnimationEffect__transitionContent & 23;// 23
static +reveal: Class<AnimationEffect__reveal> & AnimationEffect__reveal & 24;// 24
static +hide: Class<AnimationEffect__hide> & AnimationEffect__hide & 25;// 25
static +dragBetweenEnter: Class<AnimationEffect__dragBetweenEnter> & AnimationEffect__dragBetweenEnter & 26;// 26
static +dragBetweenLeave: Class<AnimationEffect__dragBetweenLeave> & AnimationEffect__dragBetweenLeave & 27;// 27
static +swipeSelect: Class<AnimationEffect__swipeSelect> & AnimationEffect__swipeSelect & 28;// 28
static +swipeDeselect: Class<AnimationEffect__swipeDeselect> & AnimationEffect__swipeDeselect & 29;// 29
static +swipeReveal: Class<AnimationEffect__swipeReveal> & AnimationEffect__swipeReveal & 30;// 30
static +enterPage: Class<AnimationEffect__enterPage> & AnimationEffect__enterPage & 31;// 31
static +transitionPage: Class<AnimationEffect__transitionPage> & AnimationEffect__transitionPage & 32;// 32
static +crossFade: Class<AnimationEffect__crossFade> & AnimationEffect__crossFade & 33;// 33
static +peek: Class<AnimationEffect__peek> & AnimationEffect__peek & 34;// 34
static +updateBadge: Class<AnimationEffect__updateBadge> & AnimationEffect__updateBadge & 35;// 35

}

declare class AnimationEffect__expand mixins AnimationEffect {}
declare class AnimationEffect__collapse mixins AnimationEffect {}
declare class AnimationEffect__reposition mixins AnimationEffect {}
declare class AnimationEffect__fadeIn mixins AnimationEffect {}
declare class AnimationEffect__fadeOut mixins AnimationEffect {}
declare class AnimationEffect__addToList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromList mixins AnimationEffect {}
declare class AnimationEffect__addToGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchList mixins AnimationEffect {}
declare class AnimationEffect__showEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__showPanel mixins AnimationEffect {}
declare class AnimationEffect__hideEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__hidePanel mixins AnimationEffect {}
declare class AnimationEffect__showPopup mixins AnimationEffect {}
declare class AnimationEffect__hidePopup mixins AnimationEffect {}
declare class AnimationEffect__pointerDown mixins AnimationEffect {}
declare class AnimationEffect__pointerUp mixins AnimationEffect {}
declare class AnimationEffect__dragSourceStart mixins AnimationEffect {}
declare class AnimationEffect__dragSourceEnd mixins AnimationEffect {}
declare class AnimationEffect__transitionContent mixins AnimationEffect {}
declare class AnimationEffect__reveal mixins AnimationEffect {}
declare class AnimationEffect__hide mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenEnter mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenLeave mixins AnimationEffect {}
declare class AnimationEffect__swipeSelect mixins AnimationEffect {}
declare class AnimationEffect__swipeDeselect mixins AnimationEffect {}
declare class AnimationEffect__swipeReveal mixins AnimationEffect {}
declare class AnimationEffect__enterPage mixins AnimationEffect {}
declare class AnimationEffect__transitionPage mixins AnimationEffect {}
declare class AnimationEffect__crossFade mixins AnimationEffect {}
declare class AnimationEffect__peek mixins AnimationEffect {}
declare class AnimationEffect__updateBadge mixins AnimationEffect {}

	declare export  class AnimationEffectTarget {
  constructor(...args: empty): mixed;
static +primary: Class<AnimationEffectTarget__primary> & AnimationEffectTarget__primary & 0;// 0
static +added: Class<AnimationEffectTarget__added> & AnimationEffectTarget__added & 1;// 1
static +affected: Class<AnimationEffectTarget__affected> & AnimationEffectTarget__affected & 2;// 2
static +background: Class<AnimationEffectTarget__background> & AnimationEffectTarget__background & 3;// 3
static +content: Class<AnimationEffectTarget__content> & AnimationEffectTarget__content & 4;// 4
static +deleted: Class<AnimationEffectTarget__deleted> & AnimationEffectTarget__deleted & 5;// 5
static +deselected: Class<AnimationEffectTarget__deselected> & AnimationEffectTarget__deselected & 6;// 6
static +dragSource: Class<AnimationEffectTarget__dragSource> & AnimationEffectTarget__dragSource & 7;// 7
static +hidden: Class<AnimationEffectTarget__hidden> & AnimationEffectTarget__hidden & 8;// 8
static +incoming: Class<AnimationEffectTarget__incoming> & AnimationEffectTarget__incoming & 9;// 9
static +outgoing: Class<AnimationEffectTarget__outgoing> & AnimationEffectTarget__outgoing & 10;// 10
static +outline: Class<AnimationEffectTarget__outline> & AnimationEffectTarget__outline & 11;// 11
static +remaining: Class<AnimationEffectTarget__remaining> & AnimationEffectTarget__remaining & 12;// 12
static +revealed: Class<AnimationEffectTarget__revealed> & AnimationEffectTarget__revealed & 13;// 13
static +rowIn: Class<AnimationEffectTarget__rowIn> & AnimationEffectTarget__rowIn & 14;// 14
static +rowOut: Class<AnimationEffectTarget__rowOut> & AnimationEffectTarget__rowOut & 15;// 15
static +selected: Class<AnimationEffectTarget__selected> & AnimationEffectTarget__selected & 16;// 16
static +selection: Class<AnimationEffectTarget__selection> & AnimationEffectTarget__selection & 17;// 17
static +shown: Class<AnimationEffectTarget__shown> & AnimationEffectTarget__shown & 18;// 18
static +tapped: Class<AnimationEffectTarget__tapped> & AnimationEffectTarget__tapped & 19;// 19

}

declare class AnimationEffectTarget__primary mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__added mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__affected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__background mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__content mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deleted mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deselected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__dragSource mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__hidden mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__incoming mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outgoing mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outline mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__remaining mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__revealed mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowIn mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowOut mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selection mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__shown mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__tapped mixins AnimationEffectTarget {}

	declare export interface IAnimationDescription {
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>,
delayLimit: number,
staggerDelay: number,
staggerDelayFactor: number,
zOrder: number
} 
	declare export interface IAnimationDescriptionFactory {
createInstance(
effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect,
target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): Windows$Windows$UI.Core.AnimationMetrics.AnimationDescription
} 
	declare export class AnimationDescription mixins undefined.IAnimationDescription {
constructor(effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect, target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): this;
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>;
delayLimit: number;
staggerDelay: number;
staggerDelayFactor: number;
zOrder: number
}
	declare export class PropertyAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class ScaleAnimation mixins undefined.IScaleAnimation, undefined.IPropertyAnimation {
finalScaleX: number;
finalScaleY: number;
initialScaleX: number;
initialScaleY: number;
normalizedOrigin: Windows$Windows$Foundation.Point;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class TranslationAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class OpacityAnimation mixins undefined.IOpacityAnimation, undefined.IPropertyAnimation {
finalOpacity: number;
initialOpacity: number;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
    }

	declare export  class CoreWindowActivationState {
  constructor(...args: empty): mixed;
static +codeActivated: Class<CoreWindowActivationState__codeActivated> & CoreWindowActivationState__codeActivated & 0;// 0
static +deactivated: Class<CoreWindowActivationState__deactivated> & CoreWindowActivationState__deactivated & 1;// 1
static +pointerActivated: Class<CoreWindowActivationState__pointerActivated> & CoreWindowActivationState__pointerActivated & 2;// 2

}

declare class CoreWindowActivationState__codeActivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__deactivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__pointerActivated mixins CoreWindowActivationState {}

	declare export  class CoreCursorType {
  constructor(...args: empty): mixed;
static +arrow: Class<CoreCursorType__arrow> & CoreCursorType__arrow & 0;// 0
static +cross: Class<CoreCursorType__cross> & CoreCursorType__cross & 1;// 1
static +custom: Class<CoreCursorType__custom> & CoreCursorType__custom & 2;// 2
static +hand: Class<CoreCursorType__hand> & CoreCursorType__hand & 3;// 3
static +help: Class<CoreCursorType__help> & CoreCursorType__help & 4;// 4
static +iBeam: Class<CoreCursorType__iBeam> & CoreCursorType__iBeam & 5;// 5
static +sizeAll: Class<CoreCursorType__sizeAll> & CoreCursorType__sizeAll & 6;// 6
static +sizeNortheastSouthwest: Class<CoreCursorType__sizeNortheastSouthwest> & CoreCursorType__sizeNortheastSouthwest & 7;// 7
static +sizeNorthSouth: Class<CoreCursorType__sizeNorthSouth> & CoreCursorType__sizeNorthSouth & 8;// 8
static +sizeNorthwestSoutheast: Class<CoreCursorType__sizeNorthwestSoutheast> & CoreCursorType__sizeNorthwestSoutheast & 9;// 9
static +sizeWestEast: Class<CoreCursorType__sizeWestEast> & CoreCursorType__sizeWestEast & 10;// 10
static +universalNo: Class<CoreCursorType__universalNo> & CoreCursorType__universalNo & 11;// 11
static +upArrow: Class<CoreCursorType__upArrow> & CoreCursorType__upArrow & 12;// 12
static +wait: Class<CoreCursorType__wait> & CoreCursorType__wait & 13;// 13

}

declare class CoreCursorType__arrow mixins CoreCursorType {}
declare class CoreCursorType__cross mixins CoreCursorType {}
declare class CoreCursorType__custom mixins CoreCursorType {}
declare class CoreCursorType__hand mixins CoreCursorType {}
declare class CoreCursorType__help mixins CoreCursorType {}
declare class CoreCursorType__iBeam mixins CoreCursorType {}
declare class CoreCursorType__sizeAll mixins CoreCursorType {}
declare class CoreCursorType__sizeNortheastSouthwest mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthSouth mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthwestSoutheast mixins CoreCursorType {}
declare class CoreCursorType__sizeWestEast mixins CoreCursorType {}
declare class CoreCursorType__universalNo mixins CoreCursorType {}
declare class CoreCursorType__upArrow mixins CoreCursorType {}
declare class CoreCursorType__wait mixins CoreCursorType {}

	declare export  class CoreDispatcherPriority {
  constructor(...args: empty): mixed;
static +low: Class<CoreDispatcherPriority__low> & CoreDispatcherPriority__low & 0;// 0
static +normal: Class<CoreDispatcherPriority__normal> & CoreDispatcherPriority__normal & 1;// 1
static +high: Class<CoreDispatcherPriority__high> & CoreDispatcherPriority__high & 2;// 2

}

declare class CoreDispatcherPriority__low mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__normal mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__high mixins CoreDispatcherPriority {}

	declare export  class CoreProcessEventsOption {
  constructor(...args: empty): mixed;
static +processOneAndAllPending: Class<CoreProcessEventsOption__processOneAndAllPending> & CoreProcessEventsOption__processOneAndAllPending & 0;// 0
static +processOneIfPresent: Class<CoreProcessEventsOption__processOneIfPresent> & CoreProcessEventsOption__processOneIfPresent & 1;// 1
static +processUntilQuit: Class<CoreProcessEventsOption__processUntilQuit> & CoreProcessEventsOption__processUntilQuit & 2;// 2
static +processAllIfPresent: Class<CoreProcessEventsOption__processAllIfPresent> & CoreProcessEventsOption__processAllIfPresent & 3;// 3

}

declare class CoreProcessEventsOption__processOneAndAllPending mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processOneIfPresent mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processUntilQuit mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processAllIfPresent mixins CoreProcessEventsOption {}

	declare export  class CoreWindowFlowDirection {
  constructor(...args: empty): mixed;
static +leftToRight: Class<CoreWindowFlowDirection__leftToRight> & CoreWindowFlowDirection__leftToRight & 0;// 0
static +rightToLeft: Class<CoreWindowFlowDirection__rightToLeft> & CoreWindowFlowDirection__rightToLeft & 1;// 1

}

declare class CoreWindowFlowDirection__leftToRight mixins CoreWindowFlowDirection {}
declare class CoreWindowFlowDirection__rightToLeft mixins CoreWindowFlowDirection {}

	declare export  class CoreVirtualKeyStates {
  constructor(...args: empty): mixed;
static +none: Class<CoreVirtualKeyStates__none> & CoreVirtualKeyStates__none & 0;// 0
static +down: Class<CoreVirtualKeyStates__down> & CoreVirtualKeyStates__down & 1;// 1
static +locked: Class<CoreVirtualKeyStates__locked> & CoreVirtualKeyStates__locked & 2;// 2

}

declare class CoreVirtualKeyStates__none mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__down mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__locked mixins CoreVirtualKeyStates {}

	declare export  class CoreAcceleratorKeyEventType {
  constructor(...args: empty): mixed;
static +character: Class<CoreAcceleratorKeyEventType__character> & CoreAcceleratorKeyEventType__character & 0;// 0
static +deadCharacter: Class<CoreAcceleratorKeyEventType__deadCharacter> & CoreAcceleratorKeyEventType__deadCharacter & 1;// 1
static +keyDown: Class<CoreAcceleratorKeyEventType__keyDown> & CoreAcceleratorKeyEventType__keyDown & 2;// 2
static +keyUp: Class<CoreAcceleratorKeyEventType__keyUp> & CoreAcceleratorKeyEventType__keyUp & 3;// 3
static +systemCharacter: Class<CoreAcceleratorKeyEventType__systemCharacter> & CoreAcceleratorKeyEventType__systemCharacter & 4;// 4
static +systemDeadCharacter: Class<CoreAcceleratorKeyEventType__systemDeadCharacter> & CoreAcceleratorKeyEventType__systemDeadCharacter & 5;// 5
static +systemKeyDown: Class<CoreAcceleratorKeyEventType__systemKeyDown> & CoreAcceleratorKeyEventType__systemKeyDown & 6;// 6
static +systemKeyUp: Class<CoreAcceleratorKeyEventType__systemKeyUp> & CoreAcceleratorKeyEventType__systemKeyUp & 7;// 7
static +unicodeCharacter: Class<CoreAcceleratorKeyEventType__unicodeCharacter> & CoreAcceleratorKeyEventType__unicodeCharacter & 8;// 8

}

declare class CoreAcceleratorKeyEventType__character mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__deadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemDeadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__unicodeCharacter mixins CoreAcceleratorKeyEventType {}

	declare export  class CoreProximityEvaluationScore {
  constructor(...args: empty): mixed;
static +closest: Class<CoreProximityEvaluationScore__closest> & CoreProximityEvaluationScore__closest & 0;// 0
static +farthest: Class<CoreProximityEvaluationScore__farthest> & CoreProximityEvaluationScore__farthest & 1;// 1

}

declare class CoreProximityEvaluationScore__closest mixins CoreProximityEvaluationScore {}
declare class CoreProximityEvaluationScore__farthest mixins CoreProximityEvaluationScore {}

	declare export interface CorePhysicalKeyStatus {
repeatCount: number,
scanCode: number,
isExtendedKey: boolean,
isMenuKeyDown: boolean,
wasKeyDown: boolean,
isKeyReleased: boolean
} 
	declare export interface CoreProximityEvaluation {
score: number,
adjustedPoint: Windows$Windows$Foundation.Point
} 
	declare export interface ICoreWindowEventArgs {
handled: boolean
} 
	declare export type IAutomationProviderRequestedEventArgs = {
automationProvider: any
} & undefined.ICoreWindowEventArgs

	declare export type ICharacterReceivedEventArgs = {
keyCode: number,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus
} & undefined.ICoreWindowEventArgs

	declare export type IInputEnabledEventArgs = {
inputEnabled: boolean
} & undefined.ICoreWindowEventArgs

	declare export type IKeyEventArgs = {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export type IPointerEventArgs = {
currentPoint: Windows$Windows$UI.Input.PointerPoint,
keyModifiers: Windows$Windows$System.VirtualKeyModifiers,
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
} & undefined.ICoreWindowEventArgs

	declare export type ITouchHitTestingEventArgs = {
boundingBox: Windows$Windows$Foundation.Rect,
point: Windows$Windows$Foundation.Point,
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
} & undefined.ICoreWindowEventArgs

	declare export type IWindowActivatedEventArgs = {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState
} & undefined.ICoreWindowEventArgs

	declare export type IWindowSizeChangedEventArgs = {
size: Windows$Windows$Foundation.Size
} & undefined.ICoreWindowEventArgs

	declare export type IVisibilityChangedEventArgs = {
visible: boolean
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreWindow {
automationHostProvider: any,
bounds: Windows$Windows$Foundation.Rect,
customProperties: Windows$Windows$Foundation.Collections.IPropertySet,
dispatcher: Windows$Windows$UI.Core.CoreDispatcher,
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection,
isInputEnabled: boolean,
pointerCursor: Windows$Windows$UI.Core.CoreCursor,
pointerPosition: Windows$Windows$Foundation.Point,
visible: boolean,
activate(): void,
close(): void,
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
releasePointerCapture(): void,
setPointerCapture(): void,
onactivated: any,
onautomationproviderrequested: any,
oncharacterreceived: any,
onclosed: any,
oninputenabled: any,
onkeydown: any,
onkeyup: any,
onpointercapturelost: any,
onpointerentered: any,
onpointerexited: any,
onpointermoved: any,
onpointerpressed: any,
onpointerreleased: any,
ontouchhittesting: any,
onpointerwheelchanged: any,
onsizechanged: any,
onvisibilitychanged: any
} 
	declare export class CoreDispatcher mixins undefined.ICoreDispatcher, undefined.ICoreAcceleratorKeys {
hasThreadAccess: boolean;
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void;
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
onacceleratorkeyactivated: any
}
	declare export class CoreCursor mixins undefined.ICoreCursor {
constructor(type: Windows$Windows$UI.Core.CoreCursorType, id: number): this;
id: number;
type: Windows$Windows$UI.Core.CoreCursorType
}
	declare export class CoreWindow mixins undefined.ICoreWindow {
automationHostProvider: any;
bounds: Windows$Windows$Foundation.Rect;
customProperties: Windows$Windows$Foundation.Collections.IPropertySet;
dispatcher: Windows$Windows$UI.Core.CoreDispatcher;
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection;
isInputEnabled: boolean;
pointerCursor: Windows$Windows$UI.Core.CoreCursor;
pointerPosition: Windows$Windows$Foundation.Point;
visible: boolean;
activate(): void;
close(): void;
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
releasePointerCapture(): void;
setPointerCapture(): void;
onactivated: any;
onautomationproviderrequested: any;
oncharacterreceived: any;
onclosed: any;
oninputenabled: any;
onkeydown: any;
onkeyup: any;
onpointercapturelost: any;
onpointerentered: any;
onpointerexited: any;
onpointermoved: any;
onpointerpressed: any;
onpointerreleased: any;
ontouchhittesting: any;
onpointerwheelchanged: any;
onsizechanged: any;
onvisibilitychanged: any;
static getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
}
	declare export class WindowActivatedEventArgs mixins undefined.IWindowActivatedEventArgs, undefined.ICoreWindowEventArgs {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState;
handled: boolean
}
	declare export class AutomationProviderRequestedEventArgs mixins undefined.IAutomationProviderRequestedEventArgs, undefined.ICoreWindowEventArgs {
automationProvider: any;
handled: boolean
}
	declare export class CharacterReceivedEventArgs mixins undefined.ICharacterReceivedEventArgs, undefined.ICoreWindowEventArgs {
keyCode: number;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
handled: boolean
}
	declare export class CoreWindowEventArgs mixins undefined.ICoreWindowEventArgs {
handled: boolean
}
	declare export class InputEnabledEventArgs mixins undefined.IInputEnabledEventArgs, undefined.ICoreWindowEventArgs {
inputEnabled: boolean;
handled: boolean
}
	declare export class KeyEventArgs mixins undefined.IKeyEventArgs, undefined.ICoreWindowEventArgs {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export class PointerEventArgs mixins undefined.IPointerEventArgs, undefined.ICoreWindowEventArgs {
currentPoint: Windows$Windows$UI.Input.PointerPoint;
keyModifiers: Windows$Windows$System.VirtualKeyModifiers;
handled: boolean;
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
}
	declare export class TouchHitTestingEventArgs mixins undefined.ITouchHitTestingEventArgs, undefined.ICoreWindowEventArgs {
boundingBox: Windows$Windows$Foundation.Rect;
point: Windows$Windows$Foundation.Point;
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation;
handled: boolean;
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation;
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
}
	declare export class WindowSizeChangedEventArgs mixins undefined.IWindowSizeChangedEventArgs, undefined.ICoreWindowEventArgs {
size: Windows$Windows$Foundation.Size;
handled: boolean
}
	declare export class VisibilityChangedEventArgs mixins undefined.IVisibilityChangedEventArgs, undefined.ICoreWindowEventArgs {
visible: boolean;
handled: boolean
}
	declare export interface ICoreWindowStatic {
getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
} 
	declare export interface DispatchedHandler {
(): void
} 
	declare export interface IdleDispatchedHandler {
(e: Windows$Windows$UI.Core.IdleDispatchedHandlerArgs): void
} 
	declare export class IdleDispatchedHandlerArgs mixins undefined.IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
}
	declare export type IAcceleratorKeyEventArgs = {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
} 
	declare export class AcceleratorKeyEventArgs mixins undefined.IAcceleratorKeyEventArgs, undefined.ICoreWindowEventArgs {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export type ICoreDispatcher = {
hasThreadAccess: boolean,
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void,
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction,
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction
} & undefined.ICoreAcceleratorKeys

	declare export interface IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
} 
	declare export class CoreAcceleratorKeys mixins undefined.ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
}
	declare export interface ICoreCursor {
id: number,
type: Windows$Windows$UI.Core.CoreCursorType
} 
	declare export interface ICoreCursorFactory {
createCursor(
type: Windows$Windows$UI.Core.CoreCursorType,
id: number): Windows$Windows$UI.Core.CoreCursor
} 
	declare export interface IInitializeWithCoreWindow {
initialize(window: Windows$Windows$UI.Core.CoreWindow): void
} 
	declare export interface ICoreWindowResizeManager {
notifyLayoutCompleted(): void
} 
	declare export interface ICoreWindowResizeManagerStatics {
getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
} 
	declare export class CoreWindowResizeManager mixins undefined.ICoreWindowResizeManager {
notifyLayoutCompleted(): void;
static getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
}
	declare export interface ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
} 
	declare export class CoreWindowPopupShowingEventArgs mixins undefined.ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
}
	declare export interface ICoreWindowDialog {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
cancelCommandIndex: number,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowDialogFactory {
createWithTitle(title: string): Windows$Windows$UI.Core.CoreWindowDialog
} 
	declare export class CoreWindowDialog mixins undefined.ICoreWindowDialog {
constructor(title: string): this;
constructor(): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
cancelCommandIndex: number;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
	declare export interface ICoreWindowFlyout {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowFlyoutFactory {
create(
position: Windows$Windows$Foundation.Point): Windows$Windows$UI.Core.CoreWindowFlyout,
createWithTitle(
position: Windows$Windows$Foundation.Point,
title: string): Windows$Windows$UI.Core.CoreWindowFlyout
} 
	declare export class CoreWindowFlyout mixins undefined.ICoreWindowFlyout {
constructor(position: Windows$Windows$Foundation.Point): this;
constructor(position: Windows$Windows$Foundation.Point, title: string): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
    }

	declare module 'WebUI' {
        declare export interface IActivatedDeferral {
complete(): void
} 
	declare export class ActivatedDeferral mixins undefined.IActivatedDeferral {
complete(): void
}
	declare export interface IActivatedOperation {
getDeferral(): Windows$Windows$UI.WebUI.ActivatedDeferral
} 
	declare export class ActivatedOperation mixins undefined.IActivatedOperation {
getDeferral(): Windows$Windows$UI.WebUI.ActivatedDeferral
}
	declare export interface IActivatedEventArgsDeferral {
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
} 
	declare export class WebUILaunchActivatedEventArgs mixins undefined.ILaunchActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
arguments: string;
tileId: string;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUISearchActivatedEventArgs mixins undefined.ISearchActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
language: string;
queryText: string;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIShareTargetActivatedEventArgs mixins undefined.IShareTargetActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
shareOperation: Windows$Windows$ApplicationModel.DataTransfer.ShareTarget.ShareOperation;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIFileActivatedEventArgs mixins undefined.IFileActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
files: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>;
verb: string;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIProtocolActivatedEventArgs mixins undefined.IProtocolActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
uri: Windows$Windows$Foundation.Uri;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIFileOpenPickerActivatedEventArgs mixins undefined.IFileOpenPickerActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
fileOpenPickerUI: Windows$Windows$Storage.Pickers.Provider.FileOpenPickerUI;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIFileSavePickerActivatedEventArgs mixins undefined.IFileSavePickerActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
fileSavePickerUI: Windows$Windows$Storage.Pickers.Provider.FileSavePickerUI;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUICachedFileUpdaterActivatedEventArgs mixins undefined.ICachedFileUpdaterActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
cachedFileUpdaterUI: Windows$Windows$Storage.Provider.CachedFileUpdaterUI;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIContactPickerActivatedEventArgs mixins undefined.IContactPickerActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
contactPickerUI: Windows$Windows$ApplicationModel.Contacts.Provider.ContactPickerUI;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIDeviceActivatedEventArgs mixins undefined.IDeviceActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
deviceInformationId: string;
verb: string;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIPrintTaskSettingsActivatedEventArgs mixins undefined.IPrintTaskSettingsActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
configuration: Windows$Windows$Devices.Printers.Extensions.PrintTaskConfiguration;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUICameraSettingsActivatedEventArgs mixins undefined.ICameraSettingsActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
videoDeviceController: any;
videoDeviceExtension: any;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export interface ActivatedEventHandler {
(sender: any, eventArgs: Windows$Windows$ApplicationModel.Activation.IActivatedEventArgs): void
} 
	declare export interface ResumingEventHandler {
(sender: any): void
} 
	declare export interface SuspendingEventHandler {
(sender: any, e: Windows$Windows$ApplicationModel.ISuspendingEventArgs): void
} 
	declare export interface NavigatedEventHandler {
(sender: any, e: Windows$Windows$UI.WebUI.IWebUINavigatedEventArgs): void
} 
	declare export interface IWebUINavigatedEventArgs {
navigatedOperation: Windows$Windows$UI.WebUI.WebUINavigatedOperation
} 
	declare export class WebUINavigatedOperation mixins undefined.IWebUINavigatedOperation {
getDeferral(): Windows$Windows$UI.WebUI.WebUINavigatedDeferral
}
	declare export class SuspendingDeferral mixins undefined.ISuspendingDeferral {
complete(): void
}
	declare export class SuspendingOperation mixins undefined.ISuspendingOperation {
deadline: Date;
getDeferral(): Windows$Windows$ApplicationModel.SuspendingDeferral
}
	declare export class SuspendingEventArgs mixins undefined.ISuspendingEventArgs {
suspendingOperation: Windows$Windows$ApplicationModel.SuspendingOperation
}
	declare export interface IWebUIBackgroundTaskInstance {
succeeded: boolean
} 
	declare export interface IWebUIBackgroundTaskInstanceStatics {
current: Windows$Windows$UI.WebUI.IWebUIBackgroundTaskInstance
} 
	declare export class WebUIBackgroundTaskInstanceRuntimeClass mixins undefined.IWebUIBackgroundTaskInstance, undefined.IBackgroundTaskInstance {
succeeded: boolean;
instanceId: string;
progress: number;
suspendedCount: number;
task: Windows$Windows$ApplicationModel.Background.BackgroundTaskRegistration;
triggerDetails: any;
oncanceled: any;
getDeferral(): Windows$Windows$ApplicationModel.Background.BackgroundTaskDeferral
}
	declare export class WebUIBackgroundTaskInstance  {
static current: Windows$Windows$UI.WebUI.IWebUIBackgroundTaskInstance
}
	declare export interface IWebUINavigatedDeferral {
complete(): void
} 
	declare export class WebUINavigatedDeferral mixins undefined.IWebUINavigatedDeferral {
complete(): void
}
	declare export interface IWebUINavigatedOperation {
getDeferral(): Windows$Windows$UI.WebUI.WebUINavigatedDeferral
} 
	declare export class WebUINavigatedEventArgs mixins undefined.IWebUINavigatedEventArgs {
navigatedOperation: Windows$Windows$UI.WebUI.WebUINavigatedOperation
}
	declare export interface IWebUIActivationStatics {
onactivated: any,
onsuspending: any,
onresuming: any,
onnavigated: any
} 
	declare export class WebUIApplication  {
static onactivated: any;
static onsuspending: any;
static onresuming: any;
static onnavigated: any
}
    }

	declare export interface IColors {} 
	declare export interface IColorsStatics {
aliceBlue: Windows$Windows$UI.Color,
antiqueWhite: Windows$Windows$UI.Color,
aqua: Windows$Windows$UI.Color,
aquamarine: Windows$Windows$UI.Color,
azure: Windows$Windows$UI.Color,
beige: Windows$Windows$UI.Color,
bisque: Windows$Windows$UI.Color,
black: Windows$Windows$UI.Color,
blanchedAlmond: Windows$Windows$UI.Color,
blue: Windows$Windows$UI.Color,
blueViolet: Windows$Windows$UI.Color,
brown: Windows$Windows$UI.Color,
burlyWood: Windows$Windows$UI.Color,
cadetBlue: Windows$Windows$UI.Color,
chartreuse: Windows$Windows$UI.Color,
chocolate: Windows$Windows$UI.Color,
coral: Windows$Windows$UI.Color,
cornflowerBlue: Windows$Windows$UI.Color,
cornsilk: Windows$Windows$UI.Color,
crimson: Windows$Windows$UI.Color,
cyan: Windows$Windows$UI.Color,
darkBlue: Windows$Windows$UI.Color,
darkCyan: Windows$Windows$UI.Color,
darkGoldenrod: Windows$Windows$UI.Color,
darkGray: Windows$Windows$UI.Color,
darkGreen: Windows$Windows$UI.Color,
darkKhaki: Windows$Windows$UI.Color,
darkMagenta: Windows$Windows$UI.Color,
darkOliveGreen: Windows$Windows$UI.Color,
darkOrange: Windows$Windows$UI.Color,
darkOrchid: Windows$Windows$UI.Color,
darkRed: Windows$Windows$UI.Color,
darkSalmon: Windows$Windows$UI.Color,
darkSeaGreen: Windows$Windows$UI.Color,
darkSlateBlue: Windows$Windows$UI.Color,
darkSlateGray: Windows$Windows$UI.Color,
darkTurquoise: Windows$Windows$UI.Color,
darkViolet: Windows$Windows$UI.Color,
deepPink: Windows$Windows$UI.Color,
deepSkyBlue: Windows$Windows$UI.Color,
dimGray: Windows$Windows$UI.Color,
dodgerBlue: Windows$Windows$UI.Color,
firebrick: Windows$Windows$UI.Color,
floralWhite: Windows$Windows$UI.Color,
forestGreen: Windows$Windows$UI.Color,
fuchsia: Windows$Windows$UI.Color,
gainsboro: Windows$Windows$UI.Color,
ghostWhite: Windows$Windows$UI.Color,
gold: Windows$Windows$UI.Color,
goldenrod: Windows$Windows$UI.Color,
gray: Windows$Windows$UI.Color,
green: Windows$Windows$UI.Color,
greenYellow: Windows$Windows$UI.Color,
honeydew: Windows$Windows$UI.Color,
hotPink: Windows$Windows$UI.Color,
indianRed: Windows$Windows$UI.Color,
indigo: Windows$Windows$UI.Color,
ivory: Windows$Windows$UI.Color,
khaki: Windows$Windows$UI.Color,
lavender: Windows$Windows$UI.Color,
lavenderBlush: Windows$Windows$UI.Color,
lawnGreen: Windows$Windows$UI.Color,
lemonChiffon: Windows$Windows$UI.Color,
lightBlue: Windows$Windows$UI.Color,
lightCoral: Windows$Windows$UI.Color,
lightCyan: Windows$Windows$UI.Color,
lightGoldenrodYellow: Windows$Windows$UI.Color,
lightGray: Windows$Windows$UI.Color,
lightGreen: Windows$Windows$UI.Color,
lightPink: Windows$Windows$UI.Color,
lightSalmon: Windows$Windows$UI.Color,
lightSeaGreen: Windows$Windows$UI.Color,
lightSkyBlue: Windows$Windows$UI.Color,
lightSlateGray: Windows$Windows$UI.Color,
lightSteelBlue: Windows$Windows$UI.Color,
lightYellow: Windows$Windows$UI.Color,
lime: Windows$Windows$UI.Color,
limeGreen: Windows$Windows$UI.Color,
linen: Windows$Windows$UI.Color,
magenta: Windows$Windows$UI.Color,
maroon: Windows$Windows$UI.Color,
mediumAquamarine: Windows$Windows$UI.Color,
mediumBlue: Windows$Windows$UI.Color,
mediumOrchid: Windows$Windows$UI.Color,
mediumPurple: Windows$Windows$UI.Color,
mediumSeaGreen: Windows$Windows$UI.Color,
mediumSlateBlue: Windows$Windows$UI.Color,
mediumSpringGreen: Windows$Windows$UI.Color,
mediumTurquoise: Windows$Windows$UI.Color,
mediumVioletRed: Windows$Windows$UI.Color,
midnightBlue: Windows$Windows$UI.Color,
mintCream: Windows$Windows$UI.Color,
mistyRose: Windows$Windows$UI.Color,
moccasin: Windows$Windows$UI.Color,
navajoWhite: Windows$Windows$UI.Color,
navy: Windows$Windows$UI.Color,
oldLace: Windows$Windows$UI.Color,
olive: Windows$Windows$UI.Color,
oliveDrab: Windows$Windows$UI.Color,
orange: Windows$Windows$UI.Color,
orangeRed: Windows$Windows$UI.Color,
orchid: Windows$Windows$UI.Color,
paleGoldenrod: Windows$Windows$UI.Color,
paleGreen: Windows$Windows$UI.Color,
paleTurquoise: Windows$Windows$UI.Color,
paleVioletRed: Windows$Windows$UI.Color,
papayaWhip: Windows$Windows$UI.Color,
peachPuff: Windows$Windows$UI.Color,
peru: Windows$Windows$UI.Color,
pink: Windows$Windows$UI.Color,
plum: Windows$Windows$UI.Color,
powderBlue: Windows$Windows$UI.Color,
purple: Windows$Windows$UI.Color,
red: Windows$Windows$UI.Color,
rosyBrown: Windows$Windows$UI.Color,
royalBlue: Windows$Windows$UI.Color,
saddleBrown: Windows$Windows$UI.Color,
salmon: Windows$Windows$UI.Color,
sandyBrown: Windows$Windows$UI.Color,
seaGreen: Windows$Windows$UI.Color,
seaShell: Windows$Windows$UI.Color,
sienna: Windows$Windows$UI.Color,
silver: Windows$Windows$UI.Color,
skyBlue: Windows$Windows$UI.Color,
slateBlue: Windows$Windows$UI.Color,
slateGray: Windows$Windows$UI.Color,
snow: Windows$Windows$UI.Color,
springGreen: Windows$Windows$UI.Color,
steelBlue: Windows$Windows$UI.Color,
tan: Windows$Windows$UI.Color,
teal: Windows$Windows$UI.Color,
thistle: Windows$Windows$UI.Color,
tomato: Windows$Windows$UI.Color,
transparent: Windows$Windows$UI.Color,
turquoise: Windows$Windows$UI.Color,
violet: Windows$Windows$UI.Color,
wheat: Windows$Windows$UI.Color,
white: Windows$Windows$UI.Color,
whiteSmoke: Windows$Windows$UI.Color,
yellow: Windows$Windows$UI.Color,
yellowGreen: Windows$Windows$UI.Color
} 
	declare export class Colors mixins undefined.IColors {
static aliceBlue: Windows$Windows$UI.Color;
static antiqueWhite: Windows$Windows$UI.Color;
static aqua: Windows$Windows$UI.Color;
static aquamarine: Windows$Windows$UI.Color;
static azure: Windows$Windows$UI.Color;
static beige: Windows$Windows$UI.Color;
static bisque: Windows$Windows$UI.Color;
static black: Windows$Windows$UI.Color;
static blanchedAlmond: Windows$Windows$UI.Color;
static blue: Windows$Windows$UI.Color;
static blueViolet: Windows$Windows$UI.Color;
static brown: Windows$Windows$UI.Color;
static burlyWood: Windows$Windows$UI.Color;
static cadetBlue: Windows$Windows$UI.Color;
static chartreuse: Windows$Windows$UI.Color;
static chocolate: Windows$Windows$UI.Color;
static coral: Windows$Windows$UI.Color;
static cornflowerBlue: Windows$Windows$UI.Color;
static cornsilk: Windows$Windows$UI.Color;
static crimson: Windows$Windows$UI.Color;
static cyan: Windows$Windows$UI.Color;
static darkBlue: Windows$Windows$UI.Color;
static darkCyan: Windows$Windows$UI.Color;
static darkGoldenrod: Windows$Windows$UI.Color;
static darkGray: Windows$Windows$UI.Color;
static darkGreen: Windows$Windows$UI.Color;
static darkKhaki: Windows$Windows$UI.Color;
static darkMagenta: Windows$Windows$UI.Color;
static darkOliveGreen: Windows$Windows$UI.Color;
static darkOrange: Windows$Windows$UI.Color;
static darkOrchid: Windows$Windows$UI.Color;
static darkRed: Windows$Windows$UI.Color;
static darkSalmon: Windows$Windows$UI.Color;
static darkSeaGreen: Windows$Windows$UI.Color;
static darkSlateBlue: Windows$Windows$UI.Color;
static darkSlateGray: Windows$Windows$UI.Color;
static darkTurquoise: Windows$Windows$UI.Color;
static darkViolet: Windows$Windows$UI.Color;
static deepPink: Windows$Windows$UI.Color;
static deepSkyBlue: Windows$Windows$UI.Color;
static dimGray: Windows$Windows$UI.Color;
static dodgerBlue: Windows$Windows$UI.Color;
static firebrick: Windows$Windows$UI.Color;
static floralWhite: Windows$Windows$UI.Color;
static forestGreen: Windows$Windows$UI.Color;
static fuchsia: Windows$Windows$UI.Color;
static gainsboro: Windows$Windows$UI.Color;
static ghostWhite: Windows$Windows$UI.Color;
static gold: Windows$Windows$UI.Color;
static goldenrod: Windows$Windows$UI.Color;
static gray: Windows$Windows$UI.Color;
static green: Windows$Windows$UI.Color;
static greenYellow: Windows$Windows$UI.Color;
static honeydew: Windows$Windows$UI.Color;
static hotPink: Windows$Windows$UI.Color;
static indianRed: Windows$Windows$UI.Color;
static indigo: Windows$Windows$UI.Color;
static ivory: Windows$Windows$UI.Color;
static khaki: Windows$Windows$UI.Color;
static lavender: Windows$Windows$UI.Color;
static lavenderBlush: Windows$Windows$UI.Color;
static lawnGreen: Windows$Windows$UI.Color;
static lemonChiffon: Windows$Windows$UI.Color;
static lightBlue: Windows$Windows$UI.Color;
static lightCoral: Windows$Windows$UI.Color;
static lightCyan: Windows$Windows$UI.Color;
static lightGoldenrodYellow: Windows$Windows$UI.Color;
static lightGray: Windows$Windows$UI.Color;
static lightGreen: Windows$Windows$UI.Color;
static lightPink: Windows$Windows$UI.Color;
static lightSalmon: Windows$Windows$UI.Color;
static lightSeaGreen: Windows$Windows$UI.Color;
static lightSkyBlue: Windows$Windows$UI.Color;
static lightSlateGray: Windows$Windows$UI.Color;
static lightSteelBlue: Windows$Windows$UI.Color;
static lightYellow: Windows$Windows$UI.Color;
static lime: Windows$Windows$UI.Color;
static limeGreen: Windows$Windows$UI.Color;
static linen: Windows$Windows$UI.Color;
static magenta: Windows$Windows$UI.Color;
static maroon: Windows$Windows$UI.Color;
static mediumAquamarine: Windows$Windows$UI.Color;
static mediumBlue: Windows$Windows$UI.Color;
static mediumOrchid: Windows$Windows$UI.Color;
static mediumPurple: Windows$Windows$UI.Color;
static mediumSeaGreen: Windows$Windows$UI.Color;
static mediumSlateBlue: Windows$Windows$UI.Color;
static mediumSpringGreen: Windows$Windows$UI.Color;
static mediumTurquoise: Windows$Windows$UI.Color;
static mediumVioletRed: Windows$Windows$UI.Color;
static midnightBlue: Windows$Windows$UI.Color;
static mintCream: Windows$Windows$UI.Color;
static mistyRose: Windows$Windows$UI.Color;
static moccasin: Windows$Windows$UI.Color;
static navajoWhite: Windows$Windows$UI.Color;
static navy: Windows$Windows$UI.Color;
static oldLace: Windows$Windows$UI.Color;
static olive: Windows$Windows$UI.Color;
static oliveDrab: Windows$Windows$UI.Color;
static orange: Windows$Windows$UI.Color;
static orangeRed: Windows$Windows$UI.Color;
static orchid: Windows$Windows$UI.Color;
static paleGoldenrod: Windows$Windows$UI.Color;
static paleGreen: Windows$Windows$UI.Color;
static paleTurquoise: Windows$Windows$UI.Color;
static paleVioletRed: Windows$Windows$UI.Color;
static papayaWhip: Windows$Windows$UI.Color;
static peachPuff: Windows$Windows$UI.Color;
static peru: Windows$Windows$UI.Color;
static pink: Windows$Windows$UI.Color;
static plum: Windows$Windows$UI.Color;
static powderBlue: Windows$Windows$UI.Color;
static purple: Windows$Windows$UI.Color;
static red: Windows$Windows$UI.Color;
static rosyBrown: Windows$Windows$UI.Color;
static royalBlue: Windows$Windows$UI.Color;
static saddleBrown: Windows$Windows$UI.Color;
static salmon: Windows$Windows$UI.Color;
static sandyBrown: Windows$Windows$UI.Color;
static seaGreen: Windows$Windows$UI.Color;
static seaShell: Windows$Windows$UI.Color;
static sienna: Windows$Windows$UI.Color;
static silver: Windows$Windows$UI.Color;
static skyBlue: Windows$Windows$UI.Color;
static slateBlue: Windows$Windows$UI.Color;
static slateGray: Windows$Windows$UI.Color;
static snow: Windows$Windows$UI.Color;
static springGreen: Windows$Windows$UI.Color;
static steelBlue: Windows$Windows$UI.Color;
static tan: Windows$Windows$UI.Color;
static teal: Windows$Windows$UI.Color;
static thistle: Windows$Windows$UI.Color;
static tomato: Windows$Windows$UI.Color;
static transparent: Windows$Windows$UI.Color;
static turquoise: Windows$Windows$UI.Color;
static violet: Windows$Windows$UI.Color;
static wheat: Windows$Windows$UI.Color;
static white: Windows$Windows$UI.Color;
static whiteSmoke: Windows$Windows$UI.Color;
static yellow: Windows$Windows$UI.Color;
static yellowGreen: Windows$Windows$UI.Color
}
	declare export interface Color {
a: number,
r: number,
g: number,
b: number
} 
	declare export interface IColorHelper {} 
	declare export interface IColorHelperStatics {
fromArgb(a: number, r: number, g: number, b: number): Windows$Windows$UI.Color
} 
	declare export class ColorHelper mixins undefined.IColorHelper {
static fromArgb(a: number, r: number, g: number, b: number): Windows$Windows$UI.Color
}
	declare module 'Notifications' {
        declare export  class NotificationSetting {
  constructor(...args: empty): mixed;
static +enabled: Class<NotificationSetting__enabled> & NotificationSetting__enabled & 0;// 0
static +disabledForApplication: Class<NotificationSetting__disabledForApplication> & NotificationSetting__disabledForApplication & 1;// 1
static +disabledForUser: Class<NotificationSetting__disabledForUser> & NotificationSetting__disabledForUser & 2;// 2
static +disabledByGroupPolicy: Class<NotificationSetting__disabledByGroupPolicy> & NotificationSetting__disabledByGroupPolicy & 3;// 3
static +disabledByManifest: Class<NotificationSetting__disabledByManifest> & NotificationSetting__disabledByManifest & 4;// 4

}

declare class NotificationSetting__enabled mixins NotificationSetting {}
declare class NotificationSetting__disabledForApplication mixins NotificationSetting {}
declare class NotificationSetting__disabledForUser mixins NotificationSetting {}
declare class NotificationSetting__disabledByGroupPolicy mixins NotificationSetting {}
declare class NotificationSetting__disabledByManifest mixins NotificationSetting {}

	declare export  class ToastDismissalReason {
  constructor(...args: empty): mixed;
static +userCanceled: Class<ToastDismissalReason__userCanceled> & ToastDismissalReason__userCanceled & 0;// 0
static +applicationHidden: Class<ToastDismissalReason__applicationHidden> & ToastDismissalReason__applicationHidden & 1;// 1
static +timedOut: Class<ToastDismissalReason__timedOut> & ToastDismissalReason__timedOut & 2;// 2

}

declare class ToastDismissalReason__userCanceled mixins ToastDismissalReason {}
declare class ToastDismissalReason__applicationHidden mixins ToastDismissalReason {}
declare class ToastDismissalReason__timedOut mixins ToastDismissalReason {}

	declare export  class BadgeTemplateType {
  constructor(...args: empty): mixed;
static +badgeGlyph: Class<BadgeTemplateType__badgeGlyph> & BadgeTemplateType__badgeGlyph & 0;// 0
static +badgeNumber: Class<BadgeTemplateType__badgeNumber> & BadgeTemplateType__badgeNumber & 1;// 1

}

declare class BadgeTemplateType__badgeGlyph mixins BadgeTemplateType {}
declare class BadgeTemplateType__badgeNumber mixins BadgeTemplateType {}

	declare export  class TileTemplateType {
  constructor(...args: empty): mixed;
static +tileSquareImage: Class<TileTemplateType__tileSquareImage> & TileTemplateType__tileSquareImage & 0;// 0
static +tileSquareBlock: Class<TileTemplateType__tileSquareBlock> & TileTemplateType__tileSquareBlock & 1;// 1
static +tileSquareText01: Class<TileTemplateType__tileSquareText01> & TileTemplateType__tileSquareText01 & 2;// 2
static +tileSquareText02: Class<TileTemplateType__tileSquareText02> & TileTemplateType__tileSquareText02 & 3;// 3
static +tileSquareText03: Class<TileTemplateType__tileSquareText03> & TileTemplateType__tileSquareText03 & 4;// 4
static +tileSquareText04: Class<TileTemplateType__tileSquareText04> & TileTemplateType__tileSquareText04 & 5;// 5
static +tileSquarePeekImageAndText01: Class<TileTemplateType__tileSquarePeekImageAndText01> & TileTemplateType__tileSquarePeekImageAndText01 & 6;// 6
static +tileSquarePeekImageAndText02: Class<TileTemplateType__tileSquarePeekImageAndText02> & TileTemplateType__tileSquarePeekImageAndText02 & 7;// 7
static +tileSquarePeekImageAndText03: Class<TileTemplateType__tileSquarePeekImageAndText03> & TileTemplateType__tileSquarePeekImageAndText03 & 8;// 8
static +tileSquarePeekImageAndText04: Class<TileTemplateType__tileSquarePeekImageAndText04> & TileTemplateType__tileSquarePeekImageAndText04 & 9;// 9
static +tileWideImage: Class<TileTemplateType__tileWideImage> & TileTemplateType__tileWideImage & 10;// 10
static +tileWideImageCollection: Class<TileTemplateType__tileWideImageCollection> & TileTemplateType__tileWideImageCollection & 11;// 11
static +tileWideImageAndText01: Class<TileTemplateType__tileWideImageAndText01> & TileTemplateType__tileWideImageAndText01 & 12;// 12
static +tileWideImageAndText02: Class<TileTemplateType__tileWideImageAndText02> & TileTemplateType__tileWideImageAndText02 & 13;// 13
static +tileWideBlockAndText01: Class<TileTemplateType__tileWideBlockAndText01> & TileTemplateType__tileWideBlockAndText01 & 14;// 14
static +tileWideBlockAndText02: Class<TileTemplateType__tileWideBlockAndText02> & TileTemplateType__tileWideBlockAndText02 & 15;// 15
static +tileWidePeekImageCollection01: Class<TileTemplateType__tileWidePeekImageCollection01> & TileTemplateType__tileWidePeekImageCollection01 & 16;// 16
static +tileWidePeekImageCollection02: Class<TileTemplateType__tileWidePeekImageCollection02> & TileTemplateType__tileWidePeekImageCollection02 & 17;// 17
static +tileWidePeekImageCollection03: Class<TileTemplateType__tileWidePeekImageCollection03> & TileTemplateType__tileWidePeekImageCollection03 & 18;// 18
static +tileWidePeekImageCollection04: Class<TileTemplateType__tileWidePeekImageCollection04> & TileTemplateType__tileWidePeekImageCollection04 & 19;// 19
static +tileWidePeekImageCollection05: Class<TileTemplateType__tileWidePeekImageCollection05> & TileTemplateType__tileWidePeekImageCollection05 & 20;// 20
static +tileWidePeekImageCollection06: Class<TileTemplateType__tileWidePeekImageCollection06> & TileTemplateType__tileWidePeekImageCollection06 & 21;// 21
static +tileWidePeekImageAndText01: Class<TileTemplateType__tileWidePeekImageAndText01> & TileTemplateType__tileWidePeekImageAndText01 & 22;// 22
static +tileWidePeekImageAndText02: Class<TileTemplateType__tileWidePeekImageAndText02> & TileTemplateType__tileWidePeekImageAndText02 & 23;// 23
static +tileWidePeekImage01: Class<TileTemplateType__tileWidePeekImage01> & TileTemplateType__tileWidePeekImage01 & 24;// 24
static +tileWidePeekImage02: Class<TileTemplateType__tileWidePeekImage02> & TileTemplateType__tileWidePeekImage02 & 25;// 25
static +tileWidePeekImage03: Class<TileTemplateType__tileWidePeekImage03> & TileTemplateType__tileWidePeekImage03 & 26;// 26
static +tileWidePeekImage04: Class<TileTemplateType__tileWidePeekImage04> & TileTemplateType__tileWidePeekImage04 & 27;// 27
static +tileWidePeekImage05: Class<TileTemplateType__tileWidePeekImage05> & TileTemplateType__tileWidePeekImage05 & 28;// 28
static +tileWidePeekImage06: Class<TileTemplateType__tileWidePeekImage06> & TileTemplateType__tileWidePeekImage06 & 29;// 29
static +tileWideSmallImageAndText01: Class<TileTemplateType__tileWideSmallImageAndText01> & TileTemplateType__tileWideSmallImageAndText01 & 30;// 30
static +tileWideSmallImageAndText02: Class<TileTemplateType__tileWideSmallImageAndText02> & TileTemplateType__tileWideSmallImageAndText02 & 31;// 31
static +tileWideSmallImageAndText03: Class<TileTemplateType__tileWideSmallImageAndText03> & TileTemplateType__tileWideSmallImageAndText03 & 32;// 32
static +tileWideSmallImageAndText04: Class<TileTemplateType__tileWideSmallImageAndText04> & TileTemplateType__tileWideSmallImageAndText04 & 33;// 33
static +tileWideSmallImageAndText05: Class<TileTemplateType__tileWideSmallImageAndText05> & TileTemplateType__tileWideSmallImageAndText05 & 34;// 34
static +tileWideText01: Class<TileTemplateType__tileWideText01> & TileTemplateType__tileWideText01 & 35;// 35
static +tileWideText02: Class<TileTemplateType__tileWideText02> & TileTemplateType__tileWideText02 & 36;// 36
static +tileWideText03: Class<TileTemplateType__tileWideText03> & TileTemplateType__tileWideText03 & 37;// 37
static +tileWideText04: Class<TileTemplateType__tileWideText04> & TileTemplateType__tileWideText04 & 38;// 38
static +tileWideText05: Class<TileTemplateType__tileWideText05> & TileTemplateType__tileWideText05 & 39;// 39
static +tileWideText06: Class<TileTemplateType__tileWideText06> & TileTemplateType__tileWideText06 & 40;// 40
static +tileWideText07: Class<TileTemplateType__tileWideText07> & TileTemplateType__tileWideText07 & 41;// 41
static +tileWideText08: Class<TileTemplateType__tileWideText08> & TileTemplateType__tileWideText08 & 42;// 42
static +tileWideText09: Class<TileTemplateType__tileWideText09> & TileTemplateType__tileWideText09 & 43;// 43
static +tileWideText10: Class<TileTemplateType__tileWideText10> & TileTemplateType__tileWideText10 & 44;// 44
static +tileWideText11: Class<TileTemplateType__tileWideText11> & TileTemplateType__tileWideText11 & 45;// 45

}

declare class TileTemplateType__tileSquareImage mixins TileTemplateType {}
declare class TileTemplateType__tileSquareBlock mixins TileTemplateType {}
declare class TileTemplateType__tileSquareText01 mixins TileTemplateType {}
declare class TileTemplateType__tileSquareText02 mixins TileTemplateType {}
declare class TileTemplateType__tileSquareText03 mixins TileTemplateType {}
declare class TileTemplateType__tileSquareText04 mixins TileTemplateType {}
declare class TileTemplateType__tileSquarePeekImageAndText01 mixins TileTemplateType {}
declare class TileTemplateType__tileSquarePeekImageAndText02 mixins TileTemplateType {}
declare class TileTemplateType__tileSquarePeekImageAndText03 mixins TileTemplateType {}
declare class TileTemplateType__tileSquarePeekImageAndText04 mixins TileTemplateType {}
declare class TileTemplateType__tileWideImage mixins TileTemplateType {}
declare class TileTemplateType__tileWideImageCollection mixins TileTemplateType {}
declare class TileTemplateType__tileWideImageAndText01 mixins TileTemplateType {}
declare class TileTemplateType__tileWideImageAndText02 mixins TileTemplateType {}
declare class TileTemplateType__tileWideBlockAndText01 mixins TileTemplateType {}
declare class TileTemplateType__tileWideBlockAndText02 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageCollection01 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageCollection02 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageCollection03 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageCollection04 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageCollection05 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageCollection06 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageAndText01 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageAndText02 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImage01 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImage02 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImage03 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImage04 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImage05 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImage06 mixins TileTemplateType {}
declare class TileTemplateType__tileWideSmallImageAndText01 mixins TileTemplateType {}
declare class TileTemplateType__tileWideSmallImageAndText02 mixins TileTemplateType {}
declare class TileTemplateType__tileWideSmallImageAndText03 mixins TileTemplateType {}
declare class TileTemplateType__tileWideSmallImageAndText04 mixins TileTemplateType {}
declare class TileTemplateType__tileWideSmallImageAndText05 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText01 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText02 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText03 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText04 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText05 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText06 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText07 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText08 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText09 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText10 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText11 mixins TileTemplateType {}

	declare export  class ToastTemplateType {
  constructor(...args: empty): mixed;
static +toastImageAndText01: Class<ToastTemplateType__toastImageAndText01> & ToastTemplateType__toastImageAndText01 & 0;// 0
static +toastImageAndText02: Class<ToastTemplateType__toastImageAndText02> & ToastTemplateType__toastImageAndText02 & 1;// 1
static +toastImageAndText03: Class<ToastTemplateType__toastImageAndText03> & ToastTemplateType__toastImageAndText03 & 2;// 2
static +toastImageAndText04: Class<ToastTemplateType__toastImageAndText04> & ToastTemplateType__toastImageAndText04 & 3;// 3
static +toastText01: Class<ToastTemplateType__toastText01> & ToastTemplateType__toastText01 & 4;// 4
static +toastText02: Class<ToastTemplateType__toastText02> & ToastTemplateType__toastText02 & 5;// 5
static +toastText03: Class<ToastTemplateType__toastText03> & ToastTemplateType__toastText03 & 6;// 6
static +toastText04: Class<ToastTemplateType__toastText04> & ToastTemplateType__toastText04 & 7;// 7

}

declare class ToastTemplateType__toastImageAndText01 mixins ToastTemplateType {}
declare class ToastTemplateType__toastImageAndText02 mixins ToastTemplateType {}
declare class ToastTemplateType__toastImageAndText03 mixins ToastTemplateType {}
declare class ToastTemplateType__toastImageAndText04 mixins ToastTemplateType {}
declare class ToastTemplateType__toastText01 mixins ToastTemplateType {}
declare class ToastTemplateType__toastText02 mixins ToastTemplateType {}
declare class ToastTemplateType__toastText03 mixins ToastTemplateType {}
declare class ToastTemplateType__toastText04 mixins ToastTemplateType {}

	declare export  class PeriodicUpdateRecurrence {
  constructor(...args: empty): mixed;
static +halfHour: Class<PeriodicUpdateRecurrence__halfHour> & PeriodicUpdateRecurrence__halfHour & 0;// 0
static +hour: Class<PeriodicUpdateRecurrence__hour> & PeriodicUpdateRecurrence__hour & 1;// 1
static +sixHours: Class<PeriodicUpdateRecurrence__sixHours> & PeriodicUpdateRecurrence__sixHours & 2;// 2
static +twelveHours: Class<PeriodicUpdateRecurrence__twelveHours> & PeriodicUpdateRecurrence__twelveHours & 3;// 3
static +daily: Class<PeriodicUpdateRecurrence__daily> & PeriodicUpdateRecurrence__daily & 4;// 4

}

declare class PeriodicUpdateRecurrence__halfHour mixins PeriodicUpdateRecurrence {}
declare class PeriodicUpdateRecurrence__hour mixins PeriodicUpdateRecurrence {}
declare class PeriodicUpdateRecurrence__sixHours mixins PeriodicUpdateRecurrence {}
declare class PeriodicUpdateRecurrence__twelveHours mixins PeriodicUpdateRecurrence {}
declare class PeriodicUpdateRecurrence__daily mixins PeriodicUpdateRecurrence {}

	declare export interface IToastDismissedEventArgs {
reason: Windows$Windows$UI.Notifications.ToastDismissalReason
} 
	declare export interface IToastFailedEventArgs {
errorCode: number
} 
	declare export interface ITileUpdateManagerStatics {
createTileUpdaterForApplication(): Windows$Windows$UI.Notifications.TileUpdater,
createTileUpdaterForApplication(applicationId: string): Windows$Windows$UI.Notifications.TileUpdater,
createTileUpdaterForSecondaryTile(tileId: string): Windows$Windows$UI.Notifications.TileUpdater,
getTemplateContent(
type: Windows$Windows$UI.Notifications.TileTemplateType): Windows$Windows$Data.Xml.Dom.XmlDocument
} 
	declare export class TileUpdater mixins undefined.ITileUpdater {
setting: Windows$Windows$UI.Notifications.NotificationSetting;
update(notification: Windows$Windows$UI.Notifications.TileNotification): void;
clear(): void;
enableNotificationQueue(enable: boolean): void;
addToSchedule(
scheduledTile: Windows$Windows$UI.Notifications.ScheduledTileNotification): void;
removeFromSchedule(
scheduledTile: Windows$Windows$UI.Notifications.ScheduledTileNotification): void;
getScheduledTileNotifications(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Notifications.ScheduledTileNotification>;
startPeriodicUpdate(
tileContent: Windows$Windows$Foundation.Uri,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void;
startPeriodicUpdate(
tileContent: Windows$Windows$Foundation.Uri,
startTime: Date,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void;
stopPeriodicUpdate(): void;
startPeriodicUpdateBatch(
tileContents: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void;
startPeriodicUpdateBatch(
tileContents: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
startTime: Date,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void
}
	declare export interface ITileUpdater {
setting: Windows$Windows$UI.Notifications.NotificationSetting,
update(notification: Windows$Windows$UI.Notifications.TileNotification): void,
clear(): void,
enableNotificationQueue(enable: boolean): void,
addToSchedule(
scheduledTile: Windows$Windows$UI.Notifications.ScheduledTileNotification): void,
removeFromSchedule(
scheduledTile: Windows$Windows$UI.Notifications.ScheduledTileNotification): void,
getScheduledTileNotifications(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Notifications.ScheduledTileNotification>,
startPeriodicUpdate(
tileContent: Windows$Windows$Foundation.Uri,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void,
startPeriodicUpdate(
tileContent: Windows$Windows$Foundation.Uri,
startTime: Date,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void,
stopPeriodicUpdate(): void,
startPeriodicUpdateBatch(
tileContents: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void,
startPeriodicUpdateBatch(
tileContents: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
startTime: Date,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void
} 
	declare export class TileNotification mixins undefined.ITileNotification {
constructor(content: Windows$Windows$Data.Xml.Dom.XmlDocument): this;
content: Windows$Windows$Data.Xml.Dom.XmlDocument;
expirationTime: Date;
tag: string
}
	declare export class ScheduledTileNotification mixins undefined.IScheduledTileNotification {
constructor(content: Windows$Windows$Data.Xml.Dom.XmlDocument, deliveryTime: Date): this;
content: Windows$Windows$Data.Xml.Dom.XmlDocument;
deliveryTime: Date;
expirationTime: Date;
id: string;
tag: string
}
	declare export interface IBadgeUpdateManagerStatics {
createBadgeUpdaterForApplication(): Windows$Windows$UI.Notifications.BadgeUpdater,
createBadgeUpdaterForApplication(applicationId: string): Windows$Windows$UI.Notifications.BadgeUpdater,
createBadgeUpdaterForSecondaryTile(tileId: string): Windows$Windows$UI.Notifications.BadgeUpdater,
getTemplateContent(
type: Windows$Windows$UI.Notifications.BadgeTemplateType): Windows$Windows$Data.Xml.Dom.XmlDocument
} 
	declare export class BadgeUpdater mixins undefined.IBadgeUpdater {
update(notification: Windows$Windows$UI.Notifications.BadgeNotification): void;
clear(): void;
startPeriodicUpdate(
badgeContent: Windows$Windows$Foundation.Uri,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void;
startPeriodicUpdate(
badgeContent: Windows$Windows$Foundation.Uri,
startTime: Date,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void;
stopPeriodicUpdate(): void
}
	declare export interface IBadgeUpdater {
update(notification: Windows$Windows$UI.Notifications.BadgeNotification): void,
clear(): void,
startPeriodicUpdate(
badgeContent: Windows$Windows$Foundation.Uri,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void,
startPeriodicUpdate(
badgeContent: Windows$Windows$Foundation.Uri,
startTime: Date,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void,
stopPeriodicUpdate(): void
} 
	declare export class BadgeNotification mixins undefined.IBadgeNotification {
constructor(content: Windows$Windows$Data.Xml.Dom.XmlDocument): this;
content: Windows$Windows$Data.Xml.Dom.XmlDocument;
expirationTime: Date
}
	declare export interface IToastNotificationManagerStatics {
createToastNotifier(): Windows$Windows$UI.Notifications.ToastNotifier,
createToastNotifier(applicationId: string): Windows$Windows$UI.Notifications.ToastNotifier,
getTemplateContent(
type: Windows$Windows$UI.Notifications.ToastTemplateType): Windows$Windows$Data.Xml.Dom.XmlDocument
} 
	declare export class ToastNotifier mixins undefined.IToastNotifier {
setting: Windows$Windows$UI.Notifications.NotificationSetting;
show(notification: Windows$Windows$UI.Notifications.ToastNotification): void;
hide(notification: Windows$Windows$UI.Notifications.ToastNotification): void;
addToSchedule(
scheduledToast: Windows$Windows$UI.Notifications.ScheduledToastNotification): void;
removeFromSchedule(
scheduledToast: Windows$Windows$UI.Notifications.ScheduledToastNotification): void;
getScheduledToastNotifications(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Notifications.ScheduledToastNotification>
}
	declare export interface IToastNotifier {
setting: Windows$Windows$UI.Notifications.NotificationSetting,
show(notification: Windows$Windows$UI.Notifications.ToastNotification): void,
hide(notification: Windows$Windows$UI.Notifications.ToastNotification): void,
addToSchedule(
scheduledToast: Windows$Windows$UI.Notifications.ScheduledToastNotification): void,
removeFromSchedule(
scheduledToast: Windows$Windows$UI.Notifications.ScheduledToastNotification): void,
getScheduledToastNotifications(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Notifications.ScheduledToastNotification>
} 
	declare export class ToastNotification mixins undefined.IToastNotification {
constructor(content: Windows$Windows$Data.Xml.Dom.XmlDocument): this;
content: Windows$Windows$Data.Xml.Dom.XmlDocument;
expirationTime: Date;
ondismissed: any;
onactivated: any;
onfailed: any
}
	declare export class ScheduledToastNotification mixins undefined.IScheduledToastNotification {
constructor(content: Windows$Windows$Data.Xml.Dom.XmlDocument, deliveryTime: Date): this;
constructor(content: Windows$Windows$Data.Xml.Dom.XmlDocument, deliveryTime: Date, snoozeInterval: number, maximumSnoozeCount: number): this;
content: Windows$Windows$Data.Xml.Dom.XmlDocument;
deliveryTime: Date;
id: string;
maximumSnoozeCount: number;
snoozeInterval: number
}
	declare export interface ITileNotificationFactory {
createTileNotification(
content: Windows$Windows$Data.Xml.Dom.XmlDocument): Windows$Windows$UI.Notifications.TileNotification
} 
	declare export interface ITileNotification {
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
expirationTime: Date,
tag: string
} 
	declare export interface IBadgeNotificationFactory {
createBadgeNotification(
content: Windows$Windows$Data.Xml.Dom.XmlDocument): Windows$Windows$UI.Notifications.BadgeNotification
} 
	declare export interface IBadgeNotification {
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
expirationTime: Date
} 
	declare export interface IToastNotificationFactory {
createToastNotification(
content: Windows$Windows$Data.Xml.Dom.XmlDocument): Windows$Windows$UI.Notifications.ToastNotification
} 
	declare export interface IToastNotification {
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
expirationTime: Date,
ondismissed: any,
onactivated: any,
onfailed: any
} 
	declare export class ToastDismissedEventArgs mixins undefined.IToastDismissedEventArgs {
reason: Windows$Windows$UI.Notifications.ToastDismissalReason
}
	declare export class ToastFailedEventArgs mixins undefined.IToastFailedEventArgs {
errorCode: number
}
	declare export interface IScheduledToastNotificationFactory {
createScheduledToastNotification(
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
deliveryTime: Date): Windows$Windows$UI.Notifications.ScheduledToastNotification,
createScheduledToastNotification(
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
deliveryTime: Date,
snoozeInterval: number,
maximumSnoozeCount: number): Windows$Windows$UI.Notifications.ScheduledToastNotification
} 
	declare export interface IScheduledToastNotification {
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
deliveryTime: Date,
id: string,
maximumSnoozeCount: number,
snoozeInterval: number
} 
	declare export interface IScheduledTileNotificationFactory {
createScheduledTileNotification(
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
deliveryTime: Date): Windows$Windows$UI.Notifications.ScheduledTileNotification
} 
	declare export interface IScheduledTileNotification {
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
deliveryTime: Date,
expirationTime: Date,
id: string,
tag: string
} 
	declare export class TileUpdateManager  {
static createTileUpdaterForApplication(): Windows$Windows$UI.Notifications.TileUpdater;
static createTileUpdaterForApplication(applicationId: string): Windows$Windows$UI.Notifications.TileUpdater;
static createTileUpdaterForSecondaryTile(tileId: string): Windows$Windows$UI.Notifications.TileUpdater;
static getTemplateContent(
type: Windows$Windows$UI.Notifications.TileTemplateType): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export class BadgeUpdateManager  {
static createBadgeUpdaterForApplication(): Windows$Windows$UI.Notifications.BadgeUpdater;
static createBadgeUpdaterForApplication(applicationId: string): Windows$Windows$UI.Notifications.BadgeUpdater;
static createBadgeUpdaterForSecondaryTile(tileId: string): Windows$Windows$UI.Notifications.BadgeUpdater;
static getTemplateContent(
type: Windows$Windows$UI.Notifications.BadgeTemplateType): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export class ToastNotificationManager  {
static createToastNotifier(): Windows$Windows$UI.Notifications.ToastNotifier;
static createToastNotifier(applicationId: string): Windows$Windows$UI.Notifications.ToastNotifier;
static getTemplateContent(
type: Windows$Windows$UI.Notifications.ToastTemplateType): Windows$Windows$Data.Xml.Dom.XmlDocument
}
    }

    }

	declare export interface IPasswordCredential {
password: string,
properties: Windows$Windows$Foundation.Collections.IPropertySet,
resource: string,
userName: string,
retrievePassword(): void
} 
	declare export class PasswordCredential mixins undefined.IPasswordCredential {
constructor(resource: string, userName: string, password: string): this;
constructor(): this;
password: string;
properties: Windows$Windows$Foundation.Collections.IPropertySet;
resource: string;
userName: string;
retrievePassword(): void
}
	declare export interface ICredentialFactory {
createPasswordCredential(
resource: string,
userName: string,
password: string): Windows$Windows$Security.Credentials.PasswordCredential
} 
	declare export interface IPasswordVault {
add(credential: Windows$Windows$Security.Credentials.PasswordCredential): void,
remove(credential: Windows$Windows$Security.Credentials.PasswordCredential): void,
retrieve(
resource: string,
userName: string): Windows$Windows$Security.Credentials.PasswordCredential,
findAllByResource(
resource: string): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Security.Credentials.PasswordCredential>,
findAllByUserName(
userName: string): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Security.Credentials.PasswordCredential>,
retrieveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Security.Credentials.PasswordCredential>
} 
	declare export class PasswordVault mixins undefined.IPasswordVault {
add(credential: Windows$Windows$Security.Credentials.PasswordCredential): void;
remove(credential: Windows$Windows$Security.Credentials.PasswordCredential): void;
retrieve(
resource: string,
userName: string): Windows$Windows$Security.Credentials.PasswordCredential;
findAllByResource(
resource: string): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Security.Credentials.PasswordCredential>;
findAllByUserName(
userName: string): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Security.Credentials.PasswordCredential>;
retrieveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Security.Credentials.PasswordCredential>
}
	declare export class PasswordCredentialPropertyStore mixins undefined.IPropertySet, undefined.IObservableMap<string, any>, undefined.IMap<string, any>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>> {
size: number;
onmapchanged: any;
lookup(key: string): any;
hasKey(key: string): boolean;
getView(): Windows$Windows$Foundation.Collections.IMapView<string, any>;
insert(key: string, value: any): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>
}
    }

	declare module 'Cryptography' {
        declare module 'Certificates' {
        declare export  class EnrollKeyUsages {
  constructor(...args: empty): mixed;
static +none: Class<EnrollKeyUsages__none> & EnrollKeyUsages__none & 0;// 0
static +decryption: Class<EnrollKeyUsages__decryption> & EnrollKeyUsages__decryption & 1;// 1
static +signing: Class<EnrollKeyUsages__signing> & EnrollKeyUsages__signing & 2;// 2
static +keyAgreement: Class<EnrollKeyUsages__keyAgreement> & EnrollKeyUsages__keyAgreement & 3;// 3
static +all: Class<EnrollKeyUsages__all> & EnrollKeyUsages__all & 4;// 4

}

declare class EnrollKeyUsages__none mixins EnrollKeyUsages {}
declare class EnrollKeyUsages__decryption mixins EnrollKeyUsages {}
declare class EnrollKeyUsages__signing mixins EnrollKeyUsages {}
declare class EnrollKeyUsages__keyAgreement mixins EnrollKeyUsages {}
declare class EnrollKeyUsages__all mixins EnrollKeyUsages {}

	declare export  class KeyProtectionLevel {
  constructor(...args: empty): mixed;
static +noConsent: Class<KeyProtectionLevel__noConsent> & KeyProtectionLevel__noConsent & 0;// 0
static +consentOnly: Class<KeyProtectionLevel__consentOnly> & KeyProtectionLevel__consentOnly & 1;// 1
static +consentWithPassword: Class<KeyProtectionLevel__consentWithPassword> & KeyProtectionLevel__consentWithPassword & 2;// 2

}

declare class KeyProtectionLevel__noConsent mixins KeyProtectionLevel {}
declare class KeyProtectionLevel__consentOnly mixins KeyProtectionLevel {}
declare class KeyProtectionLevel__consentWithPassword mixins KeyProtectionLevel {}

	declare export  class ExportOption {
  constructor(...args: empty): mixed;
static +notExportable: Class<ExportOption__notExportable> & ExportOption__notExportable & 0;// 0
static +exportable: Class<ExportOption__exportable> & ExportOption__exportable & 1;// 1

}

declare class ExportOption__notExportable mixins ExportOption {}
declare class ExportOption__exportable mixins ExportOption {}

	declare export  class KeySize {
  constructor(...args: empty): mixed;
static +invalid: Class<KeySize__invalid> & KeySize__invalid & 0;// 0
static +rsa2048: Class<KeySize__rsa2048> & KeySize__rsa2048 & 1;// 1
static +rsa4096: Class<KeySize__rsa4096> & KeySize__rsa4096 & 2;// 2

}

declare class KeySize__invalid mixins KeySize {}
declare class KeySize__rsa2048 mixins KeySize {}
declare class KeySize__rsa4096 mixins KeySize {}

	declare export  class InstallOptions {
  constructor(...args: empty): mixed;
static +none: Class<InstallOptions__none> & InstallOptions__none & 0;// 0
static +deleteExpired: Class<InstallOptions__deleteExpired> & InstallOptions__deleteExpired & 1;// 1

}

declare class InstallOptions__none mixins InstallOptions {}
declare class InstallOptions__deleteExpired mixins InstallOptions {}

	declare export interface ICertificateRequestProperties {
exportable: Windows$Windows$Security.Cryptography.Certificates.ExportOption,
friendlyName: string,
hashAlgorithmName: string,
keyAlgorithmName: string,
keyProtectionLevel: Windows$Windows$Security.Cryptography.Certificates.KeyProtectionLevel,
keySize: number,
keyStorageProviderName: string,
keyUsages: Windows$Windows$Security.Cryptography.Certificates.EnrollKeyUsages,
subject: string
} 
	declare export class CertificateRequestProperties mixins undefined.ICertificateRequestProperties {
exportable: Windows$Windows$Security.Cryptography.Certificates.ExportOption;
friendlyName: string;
hashAlgorithmName: string;
keyAlgorithmName: string;
keyProtectionLevel: Windows$Windows$Security.Cryptography.Certificates.KeyProtectionLevel;
keySize: number;
keyStorageProviderName: string;
keyUsages: Windows$Windows$Security.Cryptography.Certificates.EnrollKeyUsages;
subject: string
}
	declare export interface ICertificateEnrollmentManagerStatics {
createRequestAsync(
request: Windows$Windows$Security.Cryptography.Certificates.CertificateRequestProperties): Windows$Windows$Foundation.IAsyncOperation<string>,
installCertificateAsync(
certificate: string,
installOption: Windows$Windows$Security.Cryptography.Certificates.InstallOptions): Windows$Windows$Foundation.IAsyncAction,
importPfxDataAsync(
pfxData: string,
password: string,
exportable: Windows$Windows$Security.Cryptography.Certificates.ExportOption,
keyProtectionLevel: Windows$Windows$Security.Cryptography.Certificates.KeyProtectionLevel,
installOption: Windows$Windows$Security.Cryptography.Certificates.InstallOptions,
friendlyName: string): Windows$Windows$Foundation.IAsyncAction
} 
	declare export class CertificateEnrollmentManager  {
static createRequestAsync(
request: Windows$Windows$Security.Cryptography.Certificates.CertificateRequestProperties): Windows$Windows$Foundation.IAsyncOperation<string>;
static installCertificateAsync(
certificate: string,
installOption: Windows$Windows$Security.Cryptography.Certificates.InstallOptions): Windows$Windows$Foundation.IAsyncAction;
static importPfxDataAsync(
pfxData: string,
password: string,
exportable: Windows$Windows$Security.Cryptography.Certificates.ExportOption,
keyProtectionLevel: Windows$Windows$Security.Cryptography.Certificates.KeyProtectionLevel,
installOption: Windows$Windows$Security.Cryptography.Certificates.InstallOptions,
friendlyName: string): Windows$Windows$Foundation.IAsyncAction
}
	declare export interface IKeyAlgorithmNamesStatics {
dsa: string,
ecdh256: string,
ecdh384: string,
ecdh521: string,
ecdsa256: string,
ecdsa384: string,
ecdsa521: string,
rsa: string
} 
	declare export class KeyAlgorithmNames  {
static dsa: string;
static ecdh256: string;
static ecdh384: string;
static ecdh521: string;
static ecdsa256: string;
static ecdsa384: string;
static ecdsa521: string;
static rsa: string
}
	declare export interface IKeyStorageProviderNamesStatics {
platformKeyStorageProvider: string,
smartcardKeyStorageProvider: string,
softwareKeyStorageProvider: string
} 
	declare export class KeyStorageProviderNames  {
static platformKeyStorageProvider: string;
static smartcardKeyStorageProvider: string;
static softwareKeyStorageProvider: string
}
    }

	declare module 'Core' {
        declare export class CoreApplication  {
static mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>;
static id: string;
static properties: Windows$Windows$Foundation.Collections.IPropertySet;
static incrementApplicationUseCount(): void;
static decrementApplicationUseCount(): void;
static createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static exit(): void;
static onexiting: any;
static onsuspending: any;
static onresuming: any;
static getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void;
static runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
}
	declare export class CoreApplicationView mixins undefined.ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow;
isHosted: boolean;
isMain: boolean;
onactivated: any
}
	declare export interface IFrameworkView {
initialize(
applicationView: Windows$Windows$ApplicationModel.Core.CoreApplicationView): void,
setWindow(window: Windows$Windows$UI.Core.CoreWindow): void,
load(entryPoint: string): void,
run(): void,
uninitialize(): void
} 
	declare export interface IFrameworkViewSource {
createView(): Windows$Windows$ApplicationModel.Core.IFrameworkView
} 
	declare export interface ICoreApplication {
id: string,
properties: Windows$Windows$Foundation.Collections.IPropertySet,
onsuspending: any,
onresuming: any,
getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView,
run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void,
runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
} 
	declare export interface ICoreApplicationUseCount {
incrementApplicationUseCount(): void,
decrementApplicationUseCount(): void
} 
	declare export interface ICoreApplicationExit {
exit(): void,
onexiting: any
} 
	declare export interface ICoreImmersiveApplication {
mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView,
views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>,
createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView
} 
	declare export interface ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow,
isHosted: boolean,
isMain: boolean,
onactivated: any
} 
	declare export interface IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext,
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap,
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void,
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void
} 
	declare export class ResourceMap mixins undefined.IResourceMap, undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
uri: Windows$Windows$Foundation.Uri;
size: number;
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.NamedResource;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>
}
	declare export class ResourceContext mixins undefined.IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>;
reset(): void;
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void;
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void;
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
static createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
}
	declare export interface IResourceManagerStatics {
current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager,
isResourceReference(resourceReference: string): boolean
} 
	declare export class ResourceManager mixins undefined.IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
static current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager;
static isResourceReference(resourceReference: string): boolean
}
	declare export interface IResourceQualifier {
isDefault: boolean,
isMatch: boolean,
qualifierName: string,
qualifierValue: string,
score: number
} 
	declare export class ResourceQualifier mixins undefined.IResourceQualifier {
isDefault: boolean;
isMatch: boolean;
qualifierName: string;
qualifierValue: string;
score: number
}
	declare export interface IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>,
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>,
reset(): void,
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void,
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void,
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceContextStatics {
createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceCandidate {
isDefault: boolean,
isMatch: boolean,
isMatchAsDefault: boolean,
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>,
valueAsString: string,
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
getQualifierValue(qualifierName: string): string
} 
	declare export class ResourceCandidate mixins undefined.IResourceCandidate {
isDefault: boolean;
isMatch: boolean;
isMatchAsDefault: boolean;
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
valueAsString: string;
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
getQualifierValue(qualifierName: string): string
}
	declare export interface INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
uri: Windows$Windows$Foundation.Uri,
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
} 
	declare export class NamedResource mixins undefined.INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
uri: Windows$Windows$Foundation.Uri;
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
}
	declare export type IResourceMap = {
uri: Windows$Windows$Foundation.Uri,
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap
} & undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource> & undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>

	declare export class ResourceMapIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>[],
returnValue: number
}
}
	declare export class ResourceMapMapView mixins undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
size: number;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>>
}
	declare export class ResourceMapMapViewIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>[],
returnValue: number
}
}
	declare export class ResourceQualifierObservableMap mixins undefined.IObservableMap<string, string>, undefined.IMap<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
onmapchanged: any;
lookup(key: string): string;
hasKey(key: string): boolean;
getView(): Windows$Windows$Foundation.Collections.IMapView<string, string>;
insert(key: string, value: string): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierMapView mixins undefined.IMapView<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
lookup(key: string): string;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, string>,
second: Windows$Windows$Foundation.Collections.IMapView<string, string>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceCandidateVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceContextLanguagesVectorView mixins undefined.IVectorView<string>, undefined.IIterable<string> {
size: number;
getAt(index: number): string;
indexOf(value: string): {
index: number,
returnValue: boolean
};
getMany(startIndex: number): {
items: string[],
returnValue: number
};
first(): Windows$Windows$Foundation.Collections.IIterator<string>;
toString(): string;
toLocaleString(): string;
concat(...items: string[][]): string[];
join(seperator: string): string;
pop(): string;
push(...items: string[]): void;
reverse(): string[];
shift(): string;
slice(start: number): string[];
slice(start: number, end: number): string[];
sort(): string[];
sort(compareFn: (a: string, b: string) => number): string[];
splice(start: number): string[];
splice(start: number, deleteCount: number, ...items: string[]): string[];
unshift(...items: string[]): number;
lastIndexOf(searchElement: string): number;
lastIndexOf(searchElement: string, fromIndex: number): number;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
forEach(callbackfn: (value: string, index: number, array: string[]) => void): void;
forEach(
callbackfn: (value: string, index: number, array: string[]) => void,
thisArg: any): void;
map(callbackfn: (value: string, index: number, array: string[]) => any): any[];
map(
callbackfn: (value: string, index: number, array: string[]) => any,
thisArg: any): any[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean): string[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): string[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
length: number
}
	declare export interface IApplicationDataManagerStatics {
createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
} 
	declare export interface IApplicationDataManager {} 
	declare export class ApplicationDataManager mixins undefined.IApplicationDataManager {
static createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
}
	declare export  class CryptographicPrivateKeyBlobType {
  constructor(...args: empty): mixed;
static +pkcs8RawPrivateKeyInfo: Class<CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo> & CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo & 0;// 0
static +pkcs1RsaPrivateKey: Class<CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey> & CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey & 1;// 1
static +bCryptPrivateKey: Class<CryptographicPrivateKeyBlobType__bCryptPrivateKey> & CryptographicPrivateKeyBlobType__bCryptPrivateKey & 2;// 2
static +capi1PrivateKey: Class<CryptographicPrivateKeyBlobType__capi1PrivateKey> & CryptographicPrivateKeyBlobType__capi1PrivateKey & 3;// 3

}

declare class CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__bCryptPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__capi1PrivateKey mixins CryptographicPrivateKeyBlobType {}

	declare export  class CryptographicPublicKeyBlobType {
  constructor(...args: empty): mixed;
static +x509SubjectPublicKeyInfo: Class<CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo> & CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo & 0;// 0
static +pkcs1RsaPublicKey: Class<CryptographicPublicKeyBlobType__pkcs1RsaPublicKey> & CryptographicPublicKeyBlobType__pkcs1RsaPublicKey & 1;// 1
static +bCryptPublicKey: Class<CryptographicPublicKeyBlobType__bCryptPublicKey> & CryptographicPublicKeyBlobType__bCryptPublicKey & 2;// 2
static +capi1PublicKey: Class<CryptographicPublicKeyBlobType__capi1PublicKey> & CryptographicPublicKeyBlobType__capi1PublicKey & 3;// 3

}

declare class CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__pkcs1RsaPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__bCryptPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__capi1PublicKey mixins CryptographicPublicKeyBlobType {}

	declare export interface IKeyDerivationParameters {
iterationCount: number,
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export interface IKeyDerivationParametersStatics {
buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
} 
	declare export class KeyDerivationParameters mixins undefined.IKeyDerivationParameters {
iterationCount: number;
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer;
static buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
}
	declare export interface ICryptographicKey {
keySize: number,
export(): Windows$Windows$Storage.Streams.IBuffer,
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicKey mixins undefined.ICryptographicKey {
keySize: number;
export(): Windows$Windows$Storage.Streams.IBuffer;
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void,
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicHash mixins undefined.IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void;
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProvider {
algorithmName: string,
hashLength: number,
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash
} 
	declare export interface IMacAlgorithmProvider {
algorithmName: string,
macLength: number,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IKeyDerivationAlgorithmProvider {
algorithmName: string,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface ISymmetricKeyAlgorithmProvider {
algorithmName: string,
blockLength: number,
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IAsymmetricKeyAlgorithmProvider {
algorithmName: string,
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
encryptedData: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class EncryptedAndAuthenticatedData mixins undefined.IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer;
encryptedData: Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface ICryptographicEngineStatics {
encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData,
decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean,
deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicEngine  {
static encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData;
static decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean;
static deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
} 
	declare export class HashAlgorithmProvider mixins undefined.IHashAlgorithmProvider {
algorithmName: string;
hashLength: number;
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
}
	declare export interface IMacAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
} 
	declare export class MacAlgorithmProvider mixins undefined.IMacAlgorithmProvider {
algorithmName: string;
macLength: number;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
}
	declare export interface IKeyDerivationAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
} 
	declare export class KeyDerivationAlgorithmProvider mixins undefined.IKeyDerivationAlgorithmProvider {
algorithmName: string;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
}
	declare export interface ISymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
} 
	declare export class SymmetricKeyAlgorithmProvider mixins undefined.ISymmetricKeyAlgorithmProvider {
algorithmName: string;
blockLength: number;
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
}
	declare export interface IAsymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
} 
	declare export class AsymmetricKeyAlgorithmProvider mixins undefined.IAsymmetricKeyAlgorithmProvider {
algorithmName: string;
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
}
	declare export interface IHashAlgorithmNamesStatics {
md5: string,
sha1: string,
sha256: string,
sha384: string,
sha512: string
} 
	declare export class HashAlgorithmNames  {
static md5: string;
static sha1: string;
static sha256: string;
static sha384: string;
static sha512: string
}
	declare export interface IMacAlgorithmNamesStatics {
aesCmac: string,
hmacMd5: string,
hmacSha1: string,
hmacSha256: string,
hmacSha384: string,
hmacSha512: string
} 
	declare export class MacAlgorithmNames  {
static aesCmac: string;
static hmacMd5: string;
static hmacSha1: string;
static hmacSha256: string;
static hmacSha384: string;
static hmacSha512: string
}
	declare export interface ISymmetricAlgorithmNamesStatics {
aesCbc: string,
aesCbcPkcs7: string,
aesCcm: string,
aesEcb: string,
aesEcbPkcs7: string,
aesGcm: string,
desCbc: string,
desCbcPkcs7: string,
desEcb: string,
desEcbPkcs7: string,
rc2Cbc: string,
rc2CbcPkcs7: string,
rc2Ecb: string,
rc2EcbPkcs7: string,
rc4: string,
tripleDesCbc: string,
tripleDesCbcPkcs7: string,
tripleDesEcb: string,
tripleDesEcbPkcs7: string
} 
	declare export class SymmetricAlgorithmNames  {
static aesCbc: string;
static aesCbcPkcs7: string;
static aesCcm: string;
static aesEcb: string;
static aesEcbPkcs7: string;
static aesGcm: string;
static desCbc: string;
static desCbcPkcs7: string;
static desEcb: string;
static desEcbPkcs7: string;
static rc2Cbc: string;
static rc2CbcPkcs7: string;
static rc2Ecb: string;
static rc2EcbPkcs7: string;
static rc4: string;
static tripleDesCbc: string;
static tripleDesCbcPkcs7: string;
static tripleDesEcb: string;
static tripleDesEcbPkcs7: string
}
	declare export interface IAsymmetricAlgorithmNamesStatics {
dsaSha1: string,
dsaSha256: string,
ecdsaP256Sha256: string,
ecdsaP384Sha384: string,
ecdsaP521Sha512: string,
rsaOaepSha1: string,
rsaOaepSha256: string,
rsaOaepSha384: string,
rsaOaepSha512: string,
rsaPkcs1: string,
rsaSignPkcs1Sha1: string,
rsaSignPkcs1Sha256: string,
rsaSignPkcs1Sha384: string,
rsaSignPkcs1Sha512: string,
rsaSignPssSha1: string,
rsaSignPssSha256: string,
rsaSignPssSha384: string,
rsaSignPssSha512: string
} 
	declare export class AsymmetricAlgorithmNames  {
static dsaSha1: string;
static dsaSha256: string;
static ecdsaP256Sha256: string;
static ecdsaP384Sha384: string;
static ecdsaP521Sha512: string;
static rsaOaepSha1: string;
static rsaOaepSha256: string;
static rsaOaepSha384: string;
static rsaOaepSha512: string;
static rsaPkcs1: string;
static rsaSignPkcs1Sha1: string;
static rsaSignPkcs1Sha256: string;
static rsaSignPkcs1Sha384: string;
static rsaSignPkcs1Sha512: string;
static rsaSignPssSha1: string;
static rsaSignPssSha256: string;
static rsaSignPssSha384: string;
static rsaSignPssSha512: string
}
	declare export interface IKeyDerivationAlgorithmNamesStatics {
pbkdf2Md5: string,
pbkdf2Sha1: string,
pbkdf2Sha256: string,
pbkdf2Sha384: string,
pbkdf2Sha512: string,
sp800108CtrHmacMd5: string,
sp800108CtrHmacSha1: string,
sp800108CtrHmacSha256: string,
sp800108CtrHmacSha384: string,
sp800108CtrHmacSha512: string,
sp80056aConcatMd5: string,
sp80056aConcatSha1: string,
sp80056aConcatSha256: string,
sp80056aConcatSha384: string,
sp80056aConcatSha512: string
} 
	declare export class KeyDerivationAlgorithmNames  {
static pbkdf2Md5: string;
static pbkdf2Sha1: string;
static pbkdf2Sha256: string;
static pbkdf2Sha384: string;
static pbkdf2Sha512: string;
static sp800108CtrHmacMd5: string;
static sp800108CtrHmacSha1: string;
static sp800108CtrHmacSha256: string;
static sp800108CtrHmacSha384: string;
static sp800108CtrHmacSha512: string;
static sp80056aConcatMd5: string;
static sp80056aConcatSha1: string;
static sp80056aConcatSha256: string;
static sp80056aConcatSha384: string;
static sp80056aConcatSha512: string
}
	declare export interface SignalHandler {
(signalNotifier: Windows$Windows$System.Threading.Core.SignalNotifier, timedOut: boolean): void
} 
	declare export class SignalNotifier mixins undefined.ISignalNotifier {
enable(): void;
terminate(): void;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
}
	declare export interface ISignalNotifierStatics {
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
} 
	declare export interface IPreallocatedWorkItemFactory {
createWorkItem(
handler: Windows$Windows$System.Threading.WorkItemHandler): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriority(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriorityAndOptions(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority,
options: Windows$Windows$System.Threading.WorkItemOptions): Windows$Windows$System.Threading.Core.PreallocatedWorkItem
} 
	declare export class PreallocatedWorkItem mixins undefined.IPreallocatedWorkItem {
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority, options: Windows$Windows$System.Threading.WorkItemOptions): this;
runAsync(): Windows$Windows$Foundation.IAsyncAction
}
	declare export interface IPreallocatedWorkItem {
runAsync(): Windows$Windows$Foundation.IAsyncAction
} 
	declare export interface ISignalNotifier {
enable(): void,
terminate(): void
} 
	declare module 'AnimationMetrics' {
        declare export  class PropertyAnimationType {
  constructor(...args: empty): mixed;
static +scale: Class<PropertyAnimationType__scale> & PropertyAnimationType__scale & 0;// 0
static +translation: Class<PropertyAnimationType__translation> & PropertyAnimationType__translation & 1;// 1
static +opacity: Class<PropertyAnimationType__opacity> & PropertyAnimationType__opacity & 2;// 2

}

declare class PropertyAnimationType__scale mixins PropertyAnimationType {}
declare class PropertyAnimationType__translation mixins PropertyAnimationType {}
declare class PropertyAnimationType__opacity mixins PropertyAnimationType {}

	declare export interface IPropertyAnimation {
control1: Windows$Windows$Foundation.Point,
control2: Windows$Windows$Foundation.Point,
delay: number,
duration: number,
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
} 
	declare export type IScaleAnimation = {
finalScaleX: number,
finalScaleY: number,
initialScaleX: number,
initialScaleY: number,
normalizedOrigin: Windows$Windows$Foundation.Point
} & undefined.IPropertyAnimation

	declare export type IOpacityAnimation = {
finalOpacity: number,
initialOpacity: number
} & undefined.IPropertyAnimation

	declare export  class AnimationEffect {
  constructor(...args: empty): mixed;
static +expand: Class<AnimationEffect__expand> & AnimationEffect__expand & 0;// 0
static +collapse: Class<AnimationEffect__collapse> & AnimationEffect__collapse & 1;// 1
static +reposition: Class<AnimationEffect__reposition> & AnimationEffect__reposition & 2;// 2
static +fadeIn: Class<AnimationEffect__fadeIn> & AnimationEffect__fadeIn & 3;// 3
static +fadeOut: Class<AnimationEffect__fadeOut> & AnimationEffect__fadeOut & 4;// 4
static +addToList: Class<AnimationEffect__addToList> & AnimationEffect__addToList & 5;// 5
static +deleteFromList: Class<AnimationEffect__deleteFromList> & AnimationEffect__deleteFromList & 6;// 6
static +addToGrid: Class<AnimationEffect__addToGrid> & AnimationEffect__addToGrid & 7;// 7
static +deleteFromGrid: Class<AnimationEffect__deleteFromGrid> & AnimationEffect__deleteFromGrid & 8;// 8
static +addToSearchGrid: Class<AnimationEffect__addToSearchGrid> & AnimationEffect__addToSearchGrid & 9;// 9
static +deleteFromSearchGrid: Class<AnimationEffect__deleteFromSearchGrid> & AnimationEffect__deleteFromSearchGrid & 10;// 10
static +addToSearchList: Class<AnimationEffect__addToSearchList> & AnimationEffect__addToSearchList & 11;// 11
static +deleteFromSearchList: Class<AnimationEffect__deleteFromSearchList> & AnimationEffect__deleteFromSearchList & 12;// 12
static +showEdgeUI: Class<AnimationEffect__showEdgeUI> & AnimationEffect__showEdgeUI & 13;// 13
static +showPanel: Class<AnimationEffect__showPanel> & AnimationEffect__showPanel & 14;// 14
static +hideEdgeUI: Class<AnimationEffect__hideEdgeUI> & AnimationEffect__hideEdgeUI & 15;// 15
static +hidePanel: Class<AnimationEffect__hidePanel> & AnimationEffect__hidePanel & 16;// 16
static +showPopup: Class<AnimationEffect__showPopup> & AnimationEffect__showPopup & 17;// 17
static +hidePopup: Class<AnimationEffect__hidePopup> & AnimationEffect__hidePopup & 18;// 18
static +pointerDown: Class<AnimationEffect__pointerDown> & AnimationEffect__pointerDown & 19;// 19
static +pointerUp: Class<AnimationEffect__pointerUp> & AnimationEffect__pointerUp & 20;// 20
static +dragSourceStart: Class<AnimationEffect__dragSourceStart> & AnimationEffect__dragSourceStart & 21;// 21
static +dragSourceEnd: Class<AnimationEffect__dragSourceEnd> & AnimationEffect__dragSourceEnd & 22;// 22
static +transitionContent: Class<AnimationEffect__transitionContent> & AnimationEffect__transitionContent & 23;// 23
static +reveal: Class<AnimationEffect__reveal> & AnimationEffect__reveal & 24;// 24
static +hide: Class<AnimationEffect__hide> & AnimationEffect__hide & 25;// 25
static +dragBetweenEnter: Class<AnimationEffect__dragBetweenEnter> & AnimationEffect__dragBetweenEnter & 26;// 26
static +dragBetweenLeave: Class<AnimationEffect__dragBetweenLeave> & AnimationEffect__dragBetweenLeave & 27;// 27
static +swipeSelect: Class<AnimationEffect__swipeSelect> & AnimationEffect__swipeSelect & 28;// 28
static +swipeDeselect: Class<AnimationEffect__swipeDeselect> & AnimationEffect__swipeDeselect & 29;// 29
static +swipeReveal: Class<AnimationEffect__swipeReveal> & AnimationEffect__swipeReveal & 30;// 30
static +enterPage: Class<AnimationEffect__enterPage> & AnimationEffect__enterPage & 31;// 31
static +transitionPage: Class<AnimationEffect__transitionPage> & AnimationEffect__transitionPage & 32;// 32
static +crossFade: Class<AnimationEffect__crossFade> & AnimationEffect__crossFade & 33;// 33
static +peek: Class<AnimationEffect__peek> & AnimationEffect__peek & 34;// 34
static +updateBadge: Class<AnimationEffect__updateBadge> & AnimationEffect__updateBadge & 35;// 35

}

declare class AnimationEffect__expand mixins AnimationEffect {}
declare class AnimationEffect__collapse mixins AnimationEffect {}
declare class AnimationEffect__reposition mixins AnimationEffect {}
declare class AnimationEffect__fadeIn mixins AnimationEffect {}
declare class AnimationEffect__fadeOut mixins AnimationEffect {}
declare class AnimationEffect__addToList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromList mixins AnimationEffect {}
declare class AnimationEffect__addToGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchList mixins AnimationEffect {}
declare class AnimationEffect__showEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__showPanel mixins AnimationEffect {}
declare class AnimationEffect__hideEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__hidePanel mixins AnimationEffect {}
declare class AnimationEffect__showPopup mixins AnimationEffect {}
declare class AnimationEffect__hidePopup mixins AnimationEffect {}
declare class AnimationEffect__pointerDown mixins AnimationEffect {}
declare class AnimationEffect__pointerUp mixins AnimationEffect {}
declare class AnimationEffect__dragSourceStart mixins AnimationEffect {}
declare class AnimationEffect__dragSourceEnd mixins AnimationEffect {}
declare class AnimationEffect__transitionContent mixins AnimationEffect {}
declare class AnimationEffect__reveal mixins AnimationEffect {}
declare class AnimationEffect__hide mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenEnter mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenLeave mixins AnimationEffect {}
declare class AnimationEffect__swipeSelect mixins AnimationEffect {}
declare class AnimationEffect__swipeDeselect mixins AnimationEffect {}
declare class AnimationEffect__swipeReveal mixins AnimationEffect {}
declare class AnimationEffect__enterPage mixins AnimationEffect {}
declare class AnimationEffect__transitionPage mixins AnimationEffect {}
declare class AnimationEffect__crossFade mixins AnimationEffect {}
declare class AnimationEffect__peek mixins AnimationEffect {}
declare class AnimationEffect__updateBadge mixins AnimationEffect {}

	declare export  class AnimationEffectTarget {
  constructor(...args: empty): mixed;
static +primary: Class<AnimationEffectTarget__primary> & AnimationEffectTarget__primary & 0;// 0
static +added: Class<AnimationEffectTarget__added> & AnimationEffectTarget__added & 1;// 1
static +affected: Class<AnimationEffectTarget__affected> & AnimationEffectTarget__affected & 2;// 2
static +background: Class<AnimationEffectTarget__background> & AnimationEffectTarget__background & 3;// 3
static +content: Class<AnimationEffectTarget__content> & AnimationEffectTarget__content & 4;// 4
static +deleted: Class<AnimationEffectTarget__deleted> & AnimationEffectTarget__deleted & 5;// 5
static +deselected: Class<AnimationEffectTarget__deselected> & AnimationEffectTarget__deselected & 6;// 6
static +dragSource: Class<AnimationEffectTarget__dragSource> & AnimationEffectTarget__dragSource & 7;// 7
static +hidden: Class<AnimationEffectTarget__hidden> & AnimationEffectTarget__hidden & 8;// 8
static +incoming: Class<AnimationEffectTarget__incoming> & AnimationEffectTarget__incoming & 9;// 9
static +outgoing: Class<AnimationEffectTarget__outgoing> & AnimationEffectTarget__outgoing & 10;// 10
static +outline: Class<AnimationEffectTarget__outline> & AnimationEffectTarget__outline & 11;// 11
static +remaining: Class<AnimationEffectTarget__remaining> & AnimationEffectTarget__remaining & 12;// 12
static +revealed: Class<AnimationEffectTarget__revealed> & AnimationEffectTarget__revealed & 13;// 13
static +rowIn: Class<AnimationEffectTarget__rowIn> & AnimationEffectTarget__rowIn & 14;// 14
static +rowOut: Class<AnimationEffectTarget__rowOut> & AnimationEffectTarget__rowOut & 15;// 15
static +selected: Class<AnimationEffectTarget__selected> & AnimationEffectTarget__selected & 16;// 16
static +selection: Class<AnimationEffectTarget__selection> & AnimationEffectTarget__selection & 17;// 17
static +shown: Class<AnimationEffectTarget__shown> & AnimationEffectTarget__shown & 18;// 18
static +tapped: Class<AnimationEffectTarget__tapped> & AnimationEffectTarget__tapped & 19;// 19

}

declare class AnimationEffectTarget__primary mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__added mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__affected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__background mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__content mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deleted mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deselected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__dragSource mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__hidden mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__incoming mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outgoing mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outline mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__remaining mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__revealed mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowIn mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowOut mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selection mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__shown mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__tapped mixins AnimationEffectTarget {}

	declare export interface IAnimationDescription {
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>,
delayLimit: number,
staggerDelay: number,
staggerDelayFactor: number,
zOrder: number
} 
	declare export interface IAnimationDescriptionFactory {
createInstance(
effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect,
target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): Windows$Windows$UI.Core.AnimationMetrics.AnimationDescription
} 
	declare export class AnimationDescription mixins undefined.IAnimationDescription {
constructor(effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect, target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): this;
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>;
delayLimit: number;
staggerDelay: number;
staggerDelayFactor: number;
zOrder: number
}
	declare export class PropertyAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class ScaleAnimation mixins undefined.IScaleAnimation, undefined.IPropertyAnimation {
finalScaleX: number;
finalScaleY: number;
initialScaleX: number;
initialScaleY: number;
normalizedOrigin: Windows$Windows$Foundation.Point;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class TranslationAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class OpacityAnimation mixins undefined.IOpacityAnimation, undefined.IPropertyAnimation {
finalOpacity: number;
initialOpacity: number;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
    }

	declare export  class CoreWindowActivationState {
  constructor(...args: empty): mixed;
static +codeActivated: Class<CoreWindowActivationState__codeActivated> & CoreWindowActivationState__codeActivated & 0;// 0
static +deactivated: Class<CoreWindowActivationState__deactivated> & CoreWindowActivationState__deactivated & 1;// 1
static +pointerActivated: Class<CoreWindowActivationState__pointerActivated> & CoreWindowActivationState__pointerActivated & 2;// 2

}

declare class CoreWindowActivationState__codeActivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__deactivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__pointerActivated mixins CoreWindowActivationState {}

	declare export  class CoreCursorType {
  constructor(...args: empty): mixed;
static +arrow: Class<CoreCursorType__arrow> & CoreCursorType__arrow & 0;// 0
static +cross: Class<CoreCursorType__cross> & CoreCursorType__cross & 1;// 1
static +custom: Class<CoreCursorType__custom> & CoreCursorType__custom & 2;// 2
static +hand: Class<CoreCursorType__hand> & CoreCursorType__hand & 3;// 3
static +help: Class<CoreCursorType__help> & CoreCursorType__help & 4;// 4
static +iBeam: Class<CoreCursorType__iBeam> & CoreCursorType__iBeam & 5;// 5
static +sizeAll: Class<CoreCursorType__sizeAll> & CoreCursorType__sizeAll & 6;// 6
static +sizeNortheastSouthwest: Class<CoreCursorType__sizeNortheastSouthwest> & CoreCursorType__sizeNortheastSouthwest & 7;// 7
static +sizeNorthSouth: Class<CoreCursorType__sizeNorthSouth> & CoreCursorType__sizeNorthSouth & 8;// 8
static +sizeNorthwestSoutheast: Class<CoreCursorType__sizeNorthwestSoutheast> & CoreCursorType__sizeNorthwestSoutheast & 9;// 9
static +sizeWestEast: Class<CoreCursorType__sizeWestEast> & CoreCursorType__sizeWestEast & 10;// 10
static +universalNo: Class<CoreCursorType__universalNo> & CoreCursorType__universalNo & 11;// 11
static +upArrow: Class<CoreCursorType__upArrow> & CoreCursorType__upArrow & 12;// 12
static +wait: Class<CoreCursorType__wait> & CoreCursorType__wait & 13;// 13

}

declare class CoreCursorType__arrow mixins CoreCursorType {}
declare class CoreCursorType__cross mixins CoreCursorType {}
declare class CoreCursorType__custom mixins CoreCursorType {}
declare class CoreCursorType__hand mixins CoreCursorType {}
declare class CoreCursorType__help mixins CoreCursorType {}
declare class CoreCursorType__iBeam mixins CoreCursorType {}
declare class CoreCursorType__sizeAll mixins CoreCursorType {}
declare class CoreCursorType__sizeNortheastSouthwest mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthSouth mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthwestSoutheast mixins CoreCursorType {}
declare class CoreCursorType__sizeWestEast mixins CoreCursorType {}
declare class CoreCursorType__universalNo mixins CoreCursorType {}
declare class CoreCursorType__upArrow mixins CoreCursorType {}
declare class CoreCursorType__wait mixins CoreCursorType {}

	declare export  class CoreDispatcherPriority {
  constructor(...args: empty): mixed;
static +low: Class<CoreDispatcherPriority__low> & CoreDispatcherPriority__low & 0;// 0
static +normal: Class<CoreDispatcherPriority__normal> & CoreDispatcherPriority__normal & 1;// 1
static +high: Class<CoreDispatcherPriority__high> & CoreDispatcherPriority__high & 2;// 2

}

declare class CoreDispatcherPriority__low mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__normal mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__high mixins CoreDispatcherPriority {}

	declare export  class CoreProcessEventsOption {
  constructor(...args: empty): mixed;
static +processOneAndAllPending: Class<CoreProcessEventsOption__processOneAndAllPending> & CoreProcessEventsOption__processOneAndAllPending & 0;// 0
static +processOneIfPresent: Class<CoreProcessEventsOption__processOneIfPresent> & CoreProcessEventsOption__processOneIfPresent & 1;// 1
static +processUntilQuit: Class<CoreProcessEventsOption__processUntilQuit> & CoreProcessEventsOption__processUntilQuit & 2;// 2
static +processAllIfPresent: Class<CoreProcessEventsOption__processAllIfPresent> & CoreProcessEventsOption__processAllIfPresent & 3;// 3

}

declare class CoreProcessEventsOption__processOneAndAllPending mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processOneIfPresent mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processUntilQuit mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processAllIfPresent mixins CoreProcessEventsOption {}

	declare export  class CoreWindowFlowDirection {
  constructor(...args: empty): mixed;
static +leftToRight: Class<CoreWindowFlowDirection__leftToRight> & CoreWindowFlowDirection__leftToRight & 0;// 0
static +rightToLeft: Class<CoreWindowFlowDirection__rightToLeft> & CoreWindowFlowDirection__rightToLeft & 1;// 1

}

declare class CoreWindowFlowDirection__leftToRight mixins CoreWindowFlowDirection {}
declare class CoreWindowFlowDirection__rightToLeft mixins CoreWindowFlowDirection {}

	declare export  class CoreVirtualKeyStates {
  constructor(...args: empty): mixed;
static +none: Class<CoreVirtualKeyStates__none> & CoreVirtualKeyStates__none & 0;// 0
static +down: Class<CoreVirtualKeyStates__down> & CoreVirtualKeyStates__down & 1;// 1
static +locked: Class<CoreVirtualKeyStates__locked> & CoreVirtualKeyStates__locked & 2;// 2

}

declare class CoreVirtualKeyStates__none mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__down mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__locked mixins CoreVirtualKeyStates {}

	declare export  class CoreAcceleratorKeyEventType {
  constructor(...args: empty): mixed;
static +character: Class<CoreAcceleratorKeyEventType__character> & CoreAcceleratorKeyEventType__character & 0;// 0
static +deadCharacter: Class<CoreAcceleratorKeyEventType__deadCharacter> & CoreAcceleratorKeyEventType__deadCharacter & 1;// 1
static +keyDown: Class<CoreAcceleratorKeyEventType__keyDown> & CoreAcceleratorKeyEventType__keyDown & 2;// 2
static +keyUp: Class<CoreAcceleratorKeyEventType__keyUp> & CoreAcceleratorKeyEventType__keyUp & 3;// 3
static +systemCharacter: Class<CoreAcceleratorKeyEventType__systemCharacter> & CoreAcceleratorKeyEventType__systemCharacter & 4;// 4
static +systemDeadCharacter: Class<CoreAcceleratorKeyEventType__systemDeadCharacter> & CoreAcceleratorKeyEventType__systemDeadCharacter & 5;// 5
static +systemKeyDown: Class<CoreAcceleratorKeyEventType__systemKeyDown> & CoreAcceleratorKeyEventType__systemKeyDown & 6;// 6
static +systemKeyUp: Class<CoreAcceleratorKeyEventType__systemKeyUp> & CoreAcceleratorKeyEventType__systemKeyUp & 7;// 7
static +unicodeCharacter: Class<CoreAcceleratorKeyEventType__unicodeCharacter> & CoreAcceleratorKeyEventType__unicodeCharacter & 8;// 8

}

declare class CoreAcceleratorKeyEventType__character mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__deadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemDeadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__unicodeCharacter mixins CoreAcceleratorKeyEventType {}

	declare export  class CoreProximityEvaluationScore {
  constructor(...args: empty): mixed;
static +closest: Class<CoreProximityEvaluationScore__closest> & CoreProximityEvaluationScore__closest & 0;// 0
static +farthest: Class<CoreProximityEvaluationScore__farthest> & CoreProximityEvaluationScore__farthest & 1;// 1

}

declare class CoreProximityEvaluationScore__closest mixins CoreProximityEvaluationScore {}
declare class CoreProximityEvaluationScore__farthest mixins CoreProximityEvaluationScore {}

	declare export interface CorePhysicalKeyStatus {
repeatCount: number,
scanCode: number,
isExtendedKey: boolean,
isMenuKeyDown: boolean,
wasKeyDown: boolean,
isKeyReleased: boolean
} 
	declare export interface CoreProximityEvaluation {
score: number,
adjustedPoint: Windows$Windows$Foundation.Point
} 
	declare export interface ICoreWindowEventArgs {
handled: boolean
} 
	declare export type IAutomationProviderRequestedEventArgs = {
automationProvider: any
} & undefined.ICoreWindowEventArgs

	declare export type ICharacterReceivedEventArgs = {
keyCode: number,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus
} & undefined.ICoreWindowEventArgs

	declare export type IInputEnabledEventArgs = {
inputEnabled: boolean
} & undefined.ICoreWindowEventArgs

	declare export type IKeyEventArgs = {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export type IPointerEventArgs = {
currentPoint: Windows$Windows$UI.Input.PointerPoint,
keyModifiers: Windows$Windows$System.VirtualKeyModifiers,
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
} & undefined.ICoreWindowEventArgs

	declare export type ITouchHitTestingEventArgs = {
boundingBox: Windows$Windows$Foundation.Rect,
point: Windows$Windows$Foundation.Point,
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
} & undefined.ICoreWindowEventArgs

	declare export type IWindowActivatedEventArgs = {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState
} & undefined.ICoreWindowEventArgs

	declare export type IWindowSizeChangedEventArgs = {
size: Windows$Windows$Foundation.Size
} & undefined.ICoreWindowEventArgs

	declare export type IVisibilityChangedEventArgs = {
visible: boolean
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreWindow {
automationHostProvider: any,
bounds: Windows$Windows$Foundation.Rect,
customProperties: Windows$Windows$Foundation.Collections.IPropertySet,
dispatcher: Windows$Windows$UI.Core.CoreDispatcher,
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection,
isInputEnabled: boolean,
pointerCursor: Windows$Windows$UI.Core.CoreCursor,
pointerPosition: Windows$Windows$Foundation.Point,
visible: boolean,
activate(): void,
close(): void,
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
releasePointerCapture(): void,
setPointerCapture(): void,
onactivated: any,
onautomationproviderrequested: any,
oncharacterreceived: any,
onclosed: any,
oninputenabled: any,
onkeydown: any,
onkeyup: any,
onpointercapturelost: any,
onpointerentered: any,
onpointerexited: any,
onpointermoved: any,
onpointerpressed: any,
onpointerreleased: any,
ontouchhittesting: any,
onpointerwheelchanged: any,
onsizechanged: any,
onvisibilitychanged: any
} 
	declare export class CoreDispatcher mixins undefined.ICoreDispatcher, undefined.ICoreAcceleratorKeys {
hasThreadAccess: boolean;
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void;
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
onacceleratorkeyactivated: any
}
	declare export class CoreCursor mixins undefined.ICoreCursor {
constructor(type: Windows$Windows$UI.Core.CoreCursorType, id: number): this;
id: number;
type: Windows$Windows$UI.Core.CoreCursorType
}
	declare export class CoreWindow mixins undefined.ICoreWindow {
automationHostProvider: any;
bounds: Windows$Windows$Foundation.Rect;
customProperties: Windows$Windows$Foundation.Collections.IPropertySet;
dispatcher: Windows$Windows$UI.Core.CoreDispatcher;
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection;
isInputEnabled: boolean;
pointerCursor: Windows$Windows$UI.Core.CoreCursor;
pointerPosition: Windows$Windows$Foundation.Point;
visible: boolean;
activate(): void;
close(): void;
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
releasePointerCapture(): void;
setPointerCapture(): void;
onactivated: any;
onautomationproviderrequested: any;
oncharacterreceived: any;
onclosed: any;
oninputenabled: any;
onkeydown: any;
onkeyup: any;
onpointercapturelost: any;
onpointerentered: any;
onpointerexited: any;
onpointermoved: any;
onpointerpressed: any;
onpointerreleased: any;
ontouchhittesting: any;
onpointerwheelchanged: any;
onsizechanged: any;
onvisibilitychanged: any;
static getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
}
	declare export class WindowActivatedEventArgs mixins undefined.IWindowActivatedEventArgs, undefined.ICoreWindowEventArgs {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState;
handled: boolean
}
	declare export class AutomationProviderRequestedEventArgs mixins undefined.IAutomationProviderRequestedEventArgs, undefined.ICoreWindowEventArgs {
automationProvider: any;
handled: boolean
}
	declare export class CharacterReceivedEventArgs mixins undefined.ICharacterReceivedEventArgs, undefined.ICoreWindowEventArgs {
keyCode: number;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
handled: boolean
}
	declare export class CoreWindowEventArgs mixins undefined.ICoreWindowEventArgs {
handled: boolean
}
	declare export class InputEnabledEventArgs mixins undefined.IInputEnabledEventArgs, undefined.ICoreWindowEventArgs {
inputEnabled: boolean;
handled: boolean
}
	declare export class KeyEventArgs mixins undefined.IKeyEventArgs, undefined.ICoreWindowEventArgs {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export class PointerEventArgs mixins undefined.IPointerEventArgs, undefined.ICoreWindowEventArgs {
currentPoint: Windows$Windows$UI.Input.PointerPoint;
keyModifiers: Windows$Windows$System.VirtualKeyModifiers;
handled: boolean;
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
}
	declare export class TouchHitTestingEventArgs mixins undefined.ITouchHitTestingEventArgs, undefined.ICoreWindowEventArgs {
boundingBox: Windows$Windows$Foundation.Rect;
point: Windows$Windows$Foundation.Point;
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation;
handled: boolean;
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation;
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
}
	declare export class WindowSizeChangedEventArgs mixins undefined.IWindowSizeChangedEventArgs, undefined.ICoreWindowEventArgs {
size: Windows$Windows$Foundation.Size;
handled: boolean
}
	declare export class VisibilityChangedEventArgs mixins undefined.IVisibilityChangedEventArgs, undefined.ICoreWindowEventArgs {
visible: boolean;
handled: boolean
}
	declare export interface ICoreWindowStatic {
getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
} 
	declare export interface DispatchedHandler {
(): void
} 
	declare export interface IdleDispatchedHandler {
(e: Windows$Windows$UI.Core.IdleDispatchedHandlerArgs): void
} 
	declare export class IdleDispatchedHandlerArgs mixins undefined.IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
}
	declare export type IAcceleratorKeyEventArgs = {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
} 
	declare export class AcceleratorKeyEventArgs mixins undefined.IAcceleratorKeyEventArgs, undefined.ICoreWindowEventArgs {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export type ICoreDispatcher = {
hasThreadAccess: boolean,
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void,
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction,
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction
} & undefined.ICoreAcceleratorKeys

	declare export interface IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
} 
	declare export class CoreAcceleratorKeys mixins undefined.ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
}
	declare export interface ICoreCursor {
id: number,
type: Windows$Windows$UI.Core.CoreCursorType
} 
	declare export interface ICoreCursorFactory {
createCursor(
type: Windows$Windows$UI.Core.CoreCursorType,
id: number): Windows$Windows$UI.Core.CoreCursor
} 
	declare export interface IInitializeWithCoreWindow {
initialize(window: Windows$Windows$UI.Core.CoreWindow): void
} 
	declare export interface ICoreWindowResizeManager {
notifyLayoutCompleted(): void
} 
	declare export interface ICoreWindowResizeManagerStatics {
getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
} 
	declare export class CoreWindowResizeManager mixins undefined.ICoreWindowResizeManager {
notifyLayoutCompleted(): void;
static getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
}
	declare export interface ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
} 
	declare export class CoreWindowPopupShowingEventArgs mixins undefined.ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
}
	declare export interface ICoreWindowDialog {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
cancelCommandIndex: number,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowDialogFactory {
createWithTitle(title: string): Windows$Windows$UI.Core.CoreWindowDialog
} 
	declare export class CoreWindowDialog mixins undefined.ICoreWindowDialog {
constructor(title: string): this;
constructor(): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
cancelCommandIndex: number;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
	declare export interface ICoreWindowFlyout {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowFlyoutFactory {
create(
position: Windows$Windows$Foundation.Point): Windows$Windows$UI.Core.CoreWindowFlyout,
createWithTitle(
position: Windows$Windows$Foundation.Point,
title: string): Windows$Windows$UI.Core.CoreWindowFlyout
} 
	declare export class CoreWindowFlyout mixins undefined.ICoreWindowFlyout {
constructor(position: Windows$Windows$Foundation.Point): this;
constructor(position: Windows$Windows$Foundation.Point, title: string): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
    }

	declare module 'DataProtection' {
        declare export interface IDataProtectionProvider {
protectAsync(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IBuffer>,
unprotectAsync(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IBuffer>,
protectStreamAsync(
src: Windows$Windows$Storage.Streams.IInputStream,
dest: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncAction,
unprotectStreamAsync(
src: Windows$Windows$Storage.Streams.IInputStream,
dest: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncAction
} 
	declare export interface IDataProtectionProviderFactory {
createOverloadExplicit(
protectionDescriptor: string): Windows$Windows$Security.Cryptography.DataProtection.DataProtectionProvider
} 
	declare export class DataProtectionProvider mixins undefined.IDataProtectionProvider {
constructor(protectionDescriptor: string): this;
constructor(): this;
protectAsync(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IBuffer>;
unprotectAsync(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IBuffer>;
protectStreamAsync(
src: Windows$Windows$Storage.Streams.IInputStream,
dest: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncAction;
unprotectStreamAsync(
src: Windows$Windows$Storage.Streams.IInputStream,
dest: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncAction
}
    }

	declare export  class BinaryStringEncoding {
  constructor(...args: empty): mixed;
static +utf8: Class<BinaryStringEncoding__utf8> & BinaryStringEncoding__utf8 & 0;// 0
static +utf16LE: Class<BinaryStringEncoding__utf16LE> & BinaryStringEncoding__utf16LE & 1;// 1
static +utf16BE: Class<BinaryStringEncoding__utf16BE> & BinaryStringEncoding__utf16BE & 2;// 2

}

declare class BinaryStringEncoding__utf8 mixins BinaryStringEncoding {}
declare class BinaryStringEncoding__utf16LE mixins BinaryStringEncoding {}
declare class BinaryStringEncoding__utf16BE mixins BinaryStringEncoding {}

	declare export interface ICryptographicBufferStatics {
compare(
object1: Windows$Windows$Storage.Streams.IBuffer,
object2: Windows$Windows$Storage.Streams.IBuffer): boolean,
generateRandom(length: number): Windows$Windows$Storage.Streams.IBuffer,
generateRandomNumber(): number,
createFromByteArray(value: Uint8Array): Windows$Windows$Storage.Streams.IBuffer,
copyToByteArray(buffer: Windows$Windows$Storage.Streams.IBuffer): Uint8Array,
decodeFromHexString(value: string): Windows$Windows$Storage.Streams.IBuffer,
encodeToHexString(buffer: Windows$Windows$Storage.Streams.IBuffer): string,
decodeFromBase64String(value: string): Windows$Windows$Storage.Streams.IBuffer,
encodeToBase64String(buffer: Windows$Windows$Storage.Streams.IBuffer): string,
convertStringToBinary(
value: string,
encoding: Windows$Windows$Security.Cryptography.BinaryStringEncoding): Windows$Windows$Storage.Streams.IBuffer,
convertBinaryToString(
encoding: Windows$Windows$Security.Cryptography.BinaryStringEncoding,
buffer: Windows$Windows$Storage.Streams.IBuffer): string
} 
	declare export class CryptographicBuffer  {
static compare(
object1: Windows$Windows$Storage.Streams.IBuffer,
object2: Windows$Windows$Storage.Streams.IBuffer): boolean;
static generateRandom(length: number): Windows$Windows$Storage.Streams.IBuffer;
static generateRandomNumber(): number;
static createFromByteArray(value: Uint8Array): Windows$Windows$Storage.Streams.IBuffer;
static copyToByteArray(buffer: Windows$Windows$Storage.Streams.IBuffer): Uint8Array;
static decodeFromHexString(value: string): Windows$Windows$Storage.Streams.IBuffer;
static encodeToHexString(buffer: Windows$Windows$Storage.Streams.IBuffer): string;
static decodeFromBase64String(value: string): Windows$Windows$Storage.Streams.IBuffer;
static encodeToBase64String(buffer: Windows$Windows$Storage.Streams.IBuffer): string;
static convertStringToBinary(
value: string,
encoding: Windows$Windows$Security.Cryptography.BinaryStringEncoding): Windows$Windows$Storage.Streams.IBuffer;
static convertBinaryToString(
encoding: Windows$Windows$Security.Cryptography.BinaryStringEncoding,
buffer: Windows$Windows$Storage.Streams.IBuffer): string
}
    }

	declare module 'ExchangeActiveSyncProvisioning' {
        declare export  class EasRequireEncryptionResult {
  constructor(...args: empty): mixed;
static +notEvaluated: Class<EasRequireEncryptionResult__notEvaluated> & EasRequireEncryptionResult__notEvaluated & 0;// 0
static +compliant: Class<EasRequireEncryptionResult__compliant> & EasRequireEncryptionResult__compliant & 1;// 1
static +canBeCompliant: Class<EasRequireEncryptionResult__canBeCompliant> & EasRequireEncryptionResult__canBeCompliant & 2;// 2
static +notProvisionedOnAllVolumes: Class<EasRequireEncryptionResult__notProvisionedOnAllVolumes> & EasRequireEncryptionResult__notProvisionedOnAllVolumes & 3;// 3
static +deFixedDataNotSupported: Class<EasRequireEncryptionResult__deFixedDataNotSupported> & EasRequireEncryptionResult__deFixedDataNotSupported & 4;// 4
static +deHardwareNotCompliant: Class<EasRequireEncryptionResult__deHardwareNotCompliant> & EasRequireEncryptionResult__deHardwareNotCompliant & 5;// 5
static +deWinReNotConfigured: Class<EasRequireEncryptionResult__deWinReNotConfigured> & EasRequireEncryptionResult__deWinReNotConfigured & 6;// 6
static +deProtectionSuspended: Class<EasRequireEncryptionResult__deProtectionSuspended> & EasRequireEncryptionResult__deProtectionSuspended & 7;// 7
static +deOsVolumeNotProtected: Class<EasRequireEncryptionResult__deOsVolumeNotProtected> & EasRequireEncryptionResult__deOsVolumeNotProtected & 8;// 8
static +deProtectionNotYetEnabled: Class<EasRequireEncryptionResult__deProtectionNotYetEnabled> & EasRequireEncryptionResult__deProtectionNotYetEnabled & 9;// 9
static +noFeatureLicense: Class<EasRequireEncryptionResult__noFeatureLicense> & EasRequireEncryptionResult__noFeatureLicense & 10;// 10
static +osNotProtected: Class<EasRequireEncryptionResult__osNotProtected> & EasRequireEncryptionResult__osNotProtected & 11;// 11

}

declare class EasRequireEncryptionResult__notEvaluated mixins EasRequireEncryptionResult {}
declare class EasRequireEncryptionResult__compliant mixins EasRequireEncryptionResult {}
declare class EasRequireEncryptionResult__canBeCompliant mixins EasRequireEncryptionResult {}
declare class EasRequireEncryptionResult__notProvisionedOnAllVolumes mixins EasRequireEncryptionResult {}
declare class EasRequireEncryptionResult__deFixedDataNotSupported mixins EasRequireEncryptionResult {}
declare class EasRequireEncryptionResult__deHardwareNotCompliant mixins EasRequireEncryptionResult {}
declare class EasRequireEncryptionResult__deWinReNotConfigured mixins EasRequireEncryptionResult {}
declare class EasRequireEncryptionResult__deProtectionSuspended mixins EasRequireEncryptionResult {}
declare class EasRequireEncryptionResult__deOsVolumeNotProtected mixins EasRequireEncryptionResult {}
declare class EasRequireEncryptionResult__deProtectionNotYetEnabled mixins EasRequireEncryptionResult {}
declare class EasRequireEncryptionResult__noFeatureLicense mixins EasRequireEncryptionResult {}
declare class EasRequireEncryptionResult__osNotProtected mixins EasRequireEncryptionResult {}

	declare export  class EasMinPasswordLengthResult {
  constructor(...args: empty): mixed;
static +notEvaluated: Class<EasMinPasswordLengthResult__notEvaluated> & EasMinPasswordLengthResult__notEvaluated & 0;// 0
static +compliant: Class<EasMinPasswordLengthResult__compliant> & EasMinPasswordLengthResult__compliant & 1;// 1
static +canBeCompliant: Class<EasMinPasswordLengthResult__canBeCompliant> & EasMinPasswordLengthResult__canBeCompliant & 2;// 2
static +requestedPolicyIsStricter: Class<EasMinPasswordLengthResult__requestedPolicyIsStricter> & EasMinPasswordLengthResult__requestedPolicyIsStricter & 3;// 3
static +requestedPolicyNotEnforceable: Class<EasMinPasswordLengthResult__requestedPolicyNotEnforceable> & EasMinPasswordLengthResult__requestedPolicyNotEnforceable & 4;// 4
static +invalidParameter: Class<EasMinPasswordLengthResult__invalidParameter> & EasMinPasswordLengthResult__invalidParameter & 5;// 5
static +currentUserHasBlankPassword: Class<EasMinPasswordLengthResult__currentUserHasBlankPassword> & EasMinPasswordLengthResult__currentUserHasBlankPassword & 6;// 6
static +adminsHaveBlankPassword: Class<EasMinPasswordLengthResult__adminsHaveBlankPassword> & EasMinPasswordLengthResult__adminsHaveBlankPassword & 7;// 7
static +userCannotChangePassword: Class<EasMinPasswordLengthResult__userCannotChangePassword> & EasMinPasswordLengthResult__userCannotChangePassword & 8;// 8
static +adminsCannotChangePassword: Class<EasMinPasswordLengthResult__adminsCannotChangePassword> & EasMinPasswordLengthResult__adminsCannotChangePassword & 9;// 9
static +localControlledUsersCannotChangePassword: Class<EasMinPasswordLengthResult__localControlledUsersCannotChangePassword> & EasMinPasswordLengthResult__localControlledUsersCannotChangePassword & 10;// 10
static +connectedAdminsProviderPolicyIsWeak: Class<EasMinPasswordLengthResult__connectedAdminsProviderPolicyIsWeak> & EasMinPasswordLengthResult__connectedAdminsProviderPolicyIsWeak & 11;// 11
static +connectedUserProviderPolicyIsWeak: Class<EasMinPasswordLengthResult__connectedUserProviderPolicyIsWeak> & EasMinPasswordLengthResult__connectedUserProviderPolicyIsWeak & 12;// 12
static +changeConnectedAdminsPassword: Class<EasMinPasswordLengthResult__changeConnectedAdminsPassword> & EasMinPasswordLengthResult__changeConnectedAdminsPassword & 13;// 13
static +changeConnectedUserPassword: Class<EasMinPasswordLengthResult__changeConnectedUserPassword> & EasMinPasswordLengthResult__changeConnectedUserPassword & 14;// 14

}

declare class EasMinPasswordLengthResult__notEvaluated mixins EasMinPasswordLengthResult {}
declare class EasMinPasswordLengthResult__compliant mixins EasMinPasswordLengthResult {}
declare class EasMinPasswordLengthResult__canBeCompliant mixins EasMinPasswordLengthResult {}
declare class EasMinPasswordLengthResult__requestedPolicyIsStricter mixins EasMinPasswordLengthResult {}
declare class EasMinPasswordLengthResult__requestedPolicyNotEnforceable mixins EasMinPasswordLengthResult {}
declare class EasMinPasswordLengthResult__invalidParameter mixins EasMinPasswordLengthResult {}
declare class EasMinPasswordLengthResult__currentUserHasBlankPassword mixins EasMinPasswordLengthResult {}
declare class EasMinPasswordLengthResult__adminsHaveBlankPassword mixins EasMinPasswordLengthResult {}
declare class EasMinPasswordLengthResult__userCannotChangePassword mixins EasMinPasswordLengthResult {}
declare class EasMinPasswordLengthResult__adminsCannotChangePassword mixins EasMinPasswordLengthResult {}
declare class EasMinPasswordLengthResult__localControlledUsersCannotChangePassword mixins EasMinPasswordLengthResult {}
declare class EasMinPasswordLengthResult__connectedAdminsProviderPolicyIsWeak mixins EasMinPasswordLengthResult {}
declare class EasMinPasswordLengthResult__connectedUserProviderPolicyIsWeak mixins EasMinPasswordLengthResult {}
declare class EasMinPasswordLengthResult__changeConnectedAdminsPassword mixins EasMinPasswordLengthResult {}
declare class EasMinPasswordLengthResult__changeConnectedUserPassword mixins EasMinPasswordLengthResult {}

	declare export  class EasDisallowConvenienceLogonResult {
  constructor(...args: empty): mixed;
static +notEvaluated: Class<EasDisallowConvenienceLogonResult__notEvaluated> & EasDisallowConvenienceLogonResult__notEvaluated & 0;// 0
static +compliant: Class<EasDisallowConvenienceLogonResult__compliant> & EasDisallowConvenienceLogonResult__compliant & 1;// 1
static +canBeCompliant: Class<EasDisallowConvenienceLogonResult__canBeCompliant> & EasDisallowConvenienceLogonResult__canBeCompliant & 2;// 2
static +requestedPolicyIsStricter: Class<EasDisallowConvenienceLogonResult__requestedPolicyIsStricter> & EasDisallowConvenienceLogonResult__requestedPolicyIsStricter & 3;// 3

}

declare class EasDisallowConvenienceLogonResult__notEvaluated mixins EasDisallowConvenienceLogonResult {}
declare class EasDisallowConvenienceLogonResult__compliant mixins EasDisallowConvenienceLogonResult {}
declare class EasDisallowConvenienceLogonResult__canBeCompliant mixins EasDisallowConvenienceLogonResult {}
declare class EasDisallowConvenienceLogonResult__requestedPolicyIsStricter mixins EasDisallowConvenienceLogonResult {}

	declare export  class EasMinPasswordComplexCharactersResult {
  constructor(...args: empty): mixed;
static +notEvaluated: Class<EasMinPasswordComplexCharactersResult__notEvaluated> & EasMinPasswordComplexCharactersResult__notEvaluated & 0;// 0
static +compliant: Class<EasMinPasswordComplexCharactersResult__compliant> & EasMinPasswordComplexCharactersResult__compliant & 1;// 1
static +canBeCompliant: Class<EasMinPasswordComplexCharactersResult__canBeCompliant> & EasMinPasswordComplexCharactersResult__canBeCompliant & 2;// 2
static +requestedPolicyIsStricter: Class<EasMinPasswordComplexCharactersResult__requestedPolicyIsStricter> & EasMinPasswordComplexCharactersResult__requestedPolicyIsStricter & 3;// 3
static +requestedPolicyNotEnforceable: Class<EasMinPasswordComplexCharactersResult__requestedPolicyNotEnforceable> & EasMinPasswordComplexCharactersResult__requestedPolicyNotEnforceable & 4;// 4
static +invalidParameter: Class<EasMinPasswordComplexCharactersResult__invalidParameter> & EasMinPasswordComplexCharactersResult__invalidParameter & 5;// 5
static +currentUserHasBlankPassword: Class<EasMinPasswordComplexCharactersResult__currentUserHasBlankPassword> & EasMinPasswordComplexCharactersResult__currentUserHasBlankPassword & 6;// 6
static +adminsHaveBlankPassword: Class<EasMinPasswordComplexCharactersResult__adminsHaveBlankPassword> & EasMinPasswordComplexCharactersResult__adminsHaveBlankPassword & 7;// 7
static +userCannotChangePassword: Class<EasMinPasswordComplexCharactersResult__userCannotChangePassword> & EasMinPasswordComplexCharactersResult__userCannotChangePassword & 8;// 8
static +adminsCannotChangePassword: Class<EasMinPasswordComplexCharactersResult__adminsCannotChangePassword> & EasMinPasswordComplexCharactersResult__adminsCannotChangePassword & 9;// 9
static +localControlledUsersCannotChangePassword: Class<EasMinPasswordComplexCharactersResult__localControlledUsersCannotChangePassword> & EasMinPasswordComplexCharactersResult__localControlledUsersCannotChangePassword & 10;// 10
static +connectedAdminsProviderPolicyIsWeak: Class<EasMinPasswordComplexCharactersResult__connectedAdminsProviderPolicyIsWeak> & EasMinPasswordComplexCharactersResult__connectedAdminsProviderPolicyIsWeak & 11;// 11
static +connectedUserProviderPolicyIsWeak: Class<EasMinPasswordComplexCharactersResult__connectedUserProviderPolicyIsWeak> & EasMinPasswordComplexCharactersResult__connectedUserProviderPolicyIsWeak & 12;// 12
static +changeConnectedAdminsPassword: Class<EasMinPasswordComplexCharactersResult__changeConnectedAdminsPassword> & EasMinPasswordComplexCharactersResult__changeConnectedAdminsPassword & 13;// 13
static +changeConnectedUserPassword: Class<EasMinPasswordComplexCharactersResult__changeConnectedUserPassword> & EasMinPasswordComplexCharactersResult__changeConnectedUserPassword & 14;// 14

}

declare class EasMinPasswordComplexCharactersResult__notEvaluated mixins EasMinPasswordComplexCharactersResult {}
declare class EasMinPasswordComplexCharactersResult__compliant mixins EasMinPasswordComplexCharactersResult {}
declare class EasMinPasswordComplexCharactersResult__canBeCompliant mixins EasMinPasswordComplexCharactersResult {}
declare class EasMinPasswordComplexCharactersResult__requestedPolicyIsStricter mixins EasMinPasswordComplexCharactersResult {}
declare class EasMinPasswordComplexCharactersResult__requestedPolicyNotEnforceable mixins EasMinPasswordComplexCharactersResult {}
declare class EasMinPasswordComplexCharactersResult__invalidParameter mixins EasMinPasswordComplexCharactersResult {}
declare class EasMinPasswordComplexCharactersResult__currentUserHasBlankPassword mixins EasMinPasswordComplexCharactersResult {}
declare class EasMinPasswordComplexCharactersResult__adminsHaveBlankPassword mixins EasMinPasswordComplexCharactersResult {}
declare class EasMinPasswordComplexCharactersResult__userCannotChangePassword mixins EasMinPasswordComplexCharactersResult {}
declare class EasMinPasswordComplexCharactersResult__adminsCannotChangePassword mixins EasMinPasswordComplexCharactersResult {}
declare class EasMinPasswordComplexCharactersResult__localControlledUsersCannotChangePassword mixins EasMinPasswordComplexCharactersResult {}
declare class EasMinPasswordComplexCharactersResult__connectedAdminsProviderPolicyIsWeak mixins EasMinPasswordComplexCharactersResult {}
declare class EasMinPasswordComplexCharactersResult__connectedUserProviderPolicyIsWeak mixins EasMinPasswordComplexCharactersResult {}
declare class EasMinPasswordComplexCharactersResult__changeConnectedAdminsPassword mixins EasMinPasswordComplexCharactersResult {}
declare class EasMinPasswordComplexCharactersResult__changeConnectedUserPassword mixins EasMinPasswordComplexCharactersResult {}

	declare export  class EasPasswordExpirationResult {
  constructor(...args: empty): mixed;
static +notEvaluated: Class<EasPasswordExpirationResult__notEvaluated> & EasPasswordExpirationResult__notEvaluated & 0;// 0
static +compliant: Class<EasPasswordExpirationResult__compliant> & EasPasswordExpirationResult__compliant & 1;// 1
static +canBeCompliant: Class<EasPasswordExpirationResult__canBeCompliant> & EasPasswordExpirationResult__canBeCompliant & 2;// 2
static +requestedPolicyIsStricter: Class<EasPasswordExpirationResult__requestedPolicyIsStricter> & EasPasswordExpirationResult__requestedPolicyIsStricter & 3;// 3
static +requestedExpirationIncompatible: Class<EasPasswordExpirationResult__requestedExpirationIncompatible> & EasPasswordExpirationResult__requestedExpirationIncompatible & 4;// 4
static +invalidParameter: Class<EasPasswordExpirationResult__invalidParameter> & EasPasswordExpirationResult__invalidParameter & 5;// 5
static +userCannotChangePassword: Class<EasPasswordExpirationResult__userCannotChangePassword> & EasPasswordExpirationResult__userCannotChangePassword & 6;// 6
static +adminsCannotChangePassword: Class<EasPasswordExpirationResult__adminsCannotChangePassword> & EasPasswordExpirationResult__adminsCannotChangePassword & 7;// 7
static +localControlledUsersCannotChangePassword: Class<EasPasswordExpirationResult__localControlledUsersCannotChangePassword> & EasPasswordExpirationResult__localControlledUsersCannotChangePassword & 8;// 8

}

declare class EasPasswordExpirationResult__notEvaluated mixins EasPasswordExpirationResult {}
declare class EasPasswordExpirationResult__compliant mixins EasPasswordExpirationResult {}
declare class EasPasswordExpirationResult__canBeCompliant mixins EasPasswordExpirationResult {}
declare class EasPasswordExpirationResult__requestedPolicyIsStricter mixins EasPasswordExpirationResult {}
declare class EasPasswordExpirationResult__requestedExpirationIncompatible mixins EasPasswordExpirationResult {}
declare class EasPasswordExpirationResult__invalidParameter mixins EasPasswordExpirationResult {}
declare class EasPasswordExpirationResult__userCannotChangePassword mixins EasPasswordExpirationResult {}
declare class EasPasswordExpirationResult__adminsCannotChangePassword mixins EasPasswordExpirationResult {}
declare class EasPasswordExpirationResult__localControlledUsersCannotChangePassword mixins EasPasswordExpirationResult {}

	declare export  class EasPasswordHistoryResult {
  constructor(...args: empty): mixed;
static +notEvaluated: Class<EasPasswordHistoryResult__notEvaluated> & EasPasswordHistoryResult__notEvaluated & 0;// 0
static +compliant: Class<EasPasswordHistoryResult__compliant> & EasPasswordHistoryResult__compliant & 1;// 1
static +canBeCompliant: Class<EasPasswordHistoryResult__canBeCompliant> & EasPasswordHistoryResult__canBeCompliant & 2;// 2
static +requestedPolicyIsStricter: Class<EasPasswordHistoryResult__requestedPolicyIsStricter> & EasPasswordHistoryResult__requestedPolicyIsStricter & 3;// 3
static +invalidParameter: Class<EasPasswordHistoryResult__invalidParameter> & EasPasswordHistoryResult__invalidParameter & 4;// 4

}

declare class EasPasswordHistoryResult__notEvaluated mixins EasPasswordHistoryResult {}
declare class EasPasswordHistoryResult__compliant mixins EasPasswordHistoryResult {}
declare class EasPasswordHistoryResult__canBeCompliant mixins EasPasswordHistoryResult {}
declare class EasPasswordHistoryResult__requestedPolicyIsStricter mixins EasPasswordHistoryResult {}
declare class EasPasswordHistoryResult__invalidParameter mixins EasPasswordHistoryResult {}

	declare export  class EasMaxPasswordFailedAttemptsResult {
  constructor(...args: empty): mixed;
static +notEvaluated: Class<EasMaxPasswordFailedAttemptsResult__notEvaluated> & EasMaxPasswordFailedAttemptsResult__notEvaluated & 0;// 0
static +compliant: Class<EasMaxPasswordFailedAttemptsResult__compliant> & EasMaxPasswordFailedAttemptsResult__compliant & 1;// 1
static +canBeCompliant: Class<EasMaxPasswordFailedAttemptsResult__canBeCompliant> & EasMaxPasswordFailedAttemptsResult__canBeCompliant & 2;// 2
static +requestedPolicyIsStricter: Class<EasMaxPasswordFailedAttemptsResult__requestedPolicyIsStricter> & EasMaxPasswordFailedAttemptsResult__requestedPolicyIsStricter & 3;// 3
static +invalidParameter: Class<EasMaxPasswordFailedAttemptsResult__invalidParameter> & EasMaxPasswordFailedAttemptsResult__invalidParameter & 4;// 4

}

declare class EasMaxPasswordFailedAttemptsResult__notEvaluated mixins EasMaxPasswordFailedAttemptsResult {}
declare class EasMaxPasswordFailedAttemptsResult__compliant mixins EasMaxPasswordFailedAttemptsResult {}
declare class EasMaxPasswordFailedAttemptsResult__canBeCompliant mixins EasMaxPasswordFailedAttemptsResult {}
declare class EasMaxPasswordFailedAttemptsResult__requestedPolicyIsStricter mixins EasMaxPasswordFailedAttemptsResult {}
declare class EasMaxPasswordFailedAttemptsResult__invalidParameter mixins EasMaxPasswordFailedAttemptsResult {}

	declare export  class EasMaxInactivityTimeLockResult {
  constructor(...args: empty): mixed;
static +notEvaluated: Class<EasMaxInactivityTimeLockResult__notEvaluated> & EasMaxInactivityTimeLockResult__notEvaluated & 0;// 0
static +compliant: Class<EasMaxInactivityTimeLockResult__compliant> & EasMaxInactivityTimeLockResult__compliant & 1;// 1
static +canBeCompliant: Class<EasMaxInactivityTimeLockResult__canBeCompliant> & EasMaxInactivityTimeLockResult__canBeCompliant & 2;// 2
static +requestedPolicyIsStricter: Class<EasMaxInactivityTimeLockResult__requestedPolicyIsStricter> & EasMaxInactivityTimeLockResult__requestedPolicyIsStricter & 3;// 3
static +invalidParameter: Class<EasMaxInactivityTimeLockResult__invalidParameter> & EasMaxInactivityTimeLockResult__invalidParameter & 4;// 4

}

declare class EasMaxInactivityTimeLockResult__notEvaluated mixins EasMaxInactivityTimeLockResult {}
declare class EasMaxInactivityTimeLockResult__compliant mixins EasMaxInactivityTimeLockResult {}
declare class EasMaxInactivityTimeLockResult__canBeCompliant mixins EasMaxInactivityTimeLockResult {}
declare class EasMaxInactivityTimeLockResult__requestedPolicyIsStricter mixins EasMaxInactivityTimeLockResult {}
declare class EasMaxInactivityTimeLockResult__invalidParameter mixins EasMaxInactivityTimeLockResult {}

	declare export interface IEasClientDeviceInformation {
friendlyName: string,
id: string,
operatingSystem: string,
systemManufacturer: string,
systemProductName: string,
systemSku: string
} 
	declare export interface IEasClientSecurityPolicy {
disallowConvenienceLogon: boolean,
maxInactivityTimeLock: number,
maxPasswordFailedAttempts: number,
minPasswordComplexCharacters: number,
minPasswordLength: number,
passwordExpiration: number,
passwordHistory: number,
requireEncryption: boolean,
checkCompliance(): Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasComplianceResults,
applyAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasComplianceResults>
} 
	declare export class EasComplianceResults mixins undefined.IEasComplianceResults {
compliant: boolean;
disallowConvenienceLogonResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasDisallowConvenienceLogonResult;
maxInactivityTimeLockResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasMaxInactivityTimeLockResult;
maxPasswordFailedAttemptsResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasMaxPasswordFailedAttemptsResult;
minPasswordComplexCharactersResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult;
minPasswordLengthResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult;
passwordExpirationResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult;
passwordHistoryResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasPasswordHistoryResult;
requireEncryptionResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult
}
	declare export interface IEasComplianceResults {
compliant: boolean,
disallowConvenienceLogonResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasDisallowConvenienceLogonResult,
maxInactivityTimeLockResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasMaxInactivityTimeLockResult,
maxPasswordFailedAttemptsResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasMaxPasswordFailedAttemptsResult,
minPasswordComplexCharactersResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult,
minPasswordLengthResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult,
passwordExpirationResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult,
passwordHistoryResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasPasswordHistoryResult,
requireEncryptionResult: Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult
} 
	declare export class EasClientSecurityPolicy mixins undefined.IEasClientSecurityPolicy {
disallowConvenienceLogon: boolean;
maxInactivityTimeLock: number;
maxPasswordFailedAttempts: number;
minPasswordComplexCharacters: number;
minPasswordLength: number;
passwordExpiration: number;
passwordHistory: number;
requireEncryption: boolean;
checkCompliance(): Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasComplianceResults;
applyAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.ExchangeActiveSyncProvisioning.EasComplianceResults>
}
	declare export class EasClientDeviceInformation mixins undefined.IEasClientDeviceInformation {
friendlyName: string;
id: string;
operatingSystem: string;
systemManufacturer: string;
systemProductName: string;
systemSku: string
}
    }

    }


declare module 'Storage' {
        declare module 'Streams' {
        declare export  class ByteOrder {
  constructor(...args: empty): mixed;
static +littleEndian: Class<ByteOrder__littleEndian> & ByteOrder__littleEndian & 0;// 0
static +bigEndian: Class<ByteOrder__bigEndian> & ByteOrder__bigEndian & 1;// 1

}

declare class ByteOrder__littleEndian mixins ByteOrder {}
declare class ByteOrder__bigEndian mixins ByteOrder {}

	declare export  class UnicodeEncoding {
  constructor(...args: empty): mixed;
static +utf8: Class<UnicodeEncoding__utf8> & UnicodeEncoding__utf8 & 0;// 0
static +utf16LE: Class<UnicodeEncoding__utf16LE> & UnicodeEncoding__utf16LE & 1;// 1
static +utf16BE: Class<UnicodeEncoding__utf16BE> & UnicodeEncoding__utf16BE & 2;// 2

}

declare class UnicodeEncoding__utf8 mixins UnicodeEncoding {}
declare class UnicodeEncoding__utf16LE mixins UnicodeEncoding {}
declare class UnicodeEncoding__utf16BE mixins UnicodeEncoding {}

	declare export class DataReaderLoadOperation mixins undefined.IAsyncOperation<number>, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<number>;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(): number;
cancel(): void;
close(): void;
then<U>(
success?: (value: number) => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: number) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: number) => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: number) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: (value: number) => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<number>,
getResults(): number
}
}
	declare export interface IDataReader {
byteOrder: Windows$Windows$Storage.Streams.ByteOrder,
inputStreamOptions: Windows$Windows$Storage.Streams.InputStreamOptions,
unconsumedBufferLength: number,
unicodeEncoding: Windows$Windows$Storage.Streams.UnicodeEncoding,
readByte(): number,
readBytes(value: number[]): void,
readBytes(value: Uint8Array): void,
readBuffer(length: number): Windows$Windows$Storage.Streams.IBuffer,
readBoolean(): boolean,
readGuid(): string,
readInt16(): number,
readInt32(): number,
readInt64(): number,
readUInt16(): number,
readUInt32(): number,
readUInt64(): number,
readSingle(): number,
readDouble(): number,
readString(codeUnitCount: number): string,
readDateTime(): Date,
readTimeSpan(): number,
loadAsync(count: number): Windows$Windows$Storage.Streams.DataReaderLoadOperation,
detachBuffer(): Windows$Windows$Storage.Streams.IBuffer,
detachStream(): Windows$Windows$Storage.Streams.IInputStream
} 
	declare export interface IDataReaderFactory {
createDataReader(
inputStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Storage.Streams.DataReader
} 
	declare export class DataReader mixins undefined.IDataReader, undefined.IClosable {
constructor(inputStream: Windows$Windows$Storage.Streams.IInputStream): this;
byteOrder: Windows$Windows$Storage.Streams.ByteOrder;
inputStreamOptions: Windows$Windows$Storage.Streams.InputStreamOptions;
unconsumedBufferLength: number;
unicodeEncoding: Windows$Windows$Storage.Streams.UnicodeEncoding;
readByte(): number;
readBytes(value: number[]): void;
readBytes(value: Uint8Array): void;
readBuffer(length: number): Windows$Windows$Storage.Streams.IBuffer;
readBoolean(): boolean;
readGuid(): string;
readInt16(): number;
readInt32(): number;
readInt64(): number;
readUInt16(): number;
readUInt32(): number;
readUInt64(): number;
readSingle(): number;
readDouble(): number;
readString(codeUnitCount: number): string;
readDateTime(): Date;
readTimeSpan(): number;
loadAsync(count: number): Windows$Windows$Storage.Streams.DataReaderLoadOperation;
detachBuffer(): Windows$Windows$Storage.Streams.IBuffer;
detachStream(): Windows$Windows$Storage.Streams.IInputStream;
dispose(): void;
static fromBuffer(
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.DataReader;
close(): void
}
	declare export interface IDataReaderStatics {
fromBuffer(
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.DataReader
} 
	declare export class DataWriterStoreOperation mixins undefined.IAsyncOperation<number>, undefined.IAsyncInfo {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<number>;
errorCode: number;
id: number;
status: Windows$Windows$Foundation.AsyncStatus;
getResults(): number;
cancel(): void;
close(): void;
then<U>(
success?: (value: number) => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: number) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: number) => U,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
then<U>(
success?: (value: number) => Windows$Windows$Foundation.Foundation$IPromise<U>,
error?: (error: any) => Windows$Windows$Foundation.Foundation$IPromise<U>,
progress?: (progress: any) => void): Windows$Windows$Foundation.Foundation$IPromise<U>;
done<U>(
success?: (value: number) => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void;
operation: {
completed: Windows$Windows$Foundation.AsyncOperationCompletedHandler<number>,
getResults(): number
}
}
	declare export interface IDataWriter {
byteOrder: Windows$Windows$Storage.Streams.ByteOrder,
unicodeEncoding: Windows$Windows$Storage.Streams.UnicodeEncoding,
unstoredBufferLength: number,
writeByte(value: number): void,
writeBytes(value: number[]): void,
writeBytes(value: Uint8Array): void,
writeBuffer(buffer: Windows$Windows$Storage.Streams.IBuffer): void,
writeBuffer(
buffer: Windows$Windows$Storage.Streams.IBuffer,
start: number,
count: number): void,
writeBoolean(value: boolean): void,
writeGuid(value: string): void,
writeInt16(value: number): void,
writeInt32(value: number): void,
writeInt64(value: number): void,
writeUInt16(value: number): void,
writeUInt32(value: number): void,
writeUInt64(value: number): void,
writeSingle(value: number): void,
writeDouble(value: number): void,
writeDateTime(value: Date): void,
writeTimeSpan(value: number): void,
writeString(value: string): number,
measureString(value: string): number,
storeAsync(): Windows$Windows$Storage.Streams.DataWriterStoreOperation,
flushAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>,
detachBuffer(): Windows$Windows$Storage.Streams.IBuffer,
detachStream(): Windows$Windows$Storage.Streams.IOutputStream
} 
	declare export interface IDataWriterFactory {
createDataWriter(
outputStream: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Storage.Streams.DataWriter
} 
	declare export class DataWriter mixins undefined.IDataWriter, undefined.IClosable {
constructor(outputStream: Windows$Windows$Storage.Streams.IOutputStream): this;
constructor(): this;
byteOrder: Windows$Windows$Storage.Streams.ByteOrder;
unicodeEncoding: Windows$Windows$Storage.Streams.UnicodeEncoding;
unstoredBufferLength: number;
writeByte(value: number): void;
writeBytes(value: number[]): void;
writeBytes(value: Uint8Array): void;
writeBuffer(buffer: Windows$Windows$Storage.Streams.IBuffer): void;
writeBuffer(
buffer: Windows$Windows$Storage.Streams.IBuffer,
start: number,
count: number): void;
writeBoolean(value: boolean): void;
writeGuid(value: string): void;
writeInt16(value: number): void;
writeInt32(value: number): void;
writeInt64(value: number): void;
writeUInt16(value: number): void;
writeUInt32(value: number): void;
writeUInt64(value: number): void;
writeSingle(value: number): void;
writeDouble(value: number): void;
writeDateTime(value: Date): void;
writeTimeSpan(value: number): void;
writeString(value: string): number;
measureString(value: string): number;
storeAsync(): Windows$Windows$Storage.Streams.DataWriterStoreOperation;
flushAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
detachBuffer(): Windows$Windows$Storage.Streams.IBuffer;
detachStream(): Windows$Windows$Storage.Streams.IOutputStream;
dispose(): void;
close(): void
}
	declare export interface IRandomAccessStreamStatics {
copyAsync(
source: Windows$Windows$Storage.Streams.IInputStream,
destination: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>,
copyAsync(
source: Windows$Windows$Storage.Streams.IInputStream,
destination: Windows$Windows$Storage.Streams.IOutputStream,
bytesToCopy: number): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>,
copyAndCloseAsync(
source: Windows$Windows$Storage.Streams.IInputStream,
destination: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>
} 
	declare export class RandomAccessStream  {
static copyAsync(
source: Windows$Windows$Storage.Streams.IInputStream,
destination: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
static copyAsync(
source: Windows$Windows$Storage.Streams.IInputStream,
destination: Windows$Windows$Storage.Streams.IOutputStream,
bytesToCopy: number): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
static copyAndCloseAsync(
source: Windows$Windows$Storage.Streams.IInputStream,
destination: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>
}
	declare export interface IBufferFactory {
create(capacity: number): Windows$Windows$Storage.Streams.Buffer
} 
	declare export class Buffer mixins undefined.IBuffer {
constructor(capacity: number): this;
capacity: number;
length: number
}
	declare export interface IBuffer {
capacity: number,
length: number
} 
	declare export  class InputStreamOptions {
  constructor(...args: empty): mixed;
static +none: Class<InputStreamOptions__none> & InputStreamOptions__none & 0;// 0
static +partial: Class<InputStreamOptions__partial> & InputStreamOptions__partial & 1;// 1
static +readAhead: Class<InputStreamOptions__readAhead> & InputStreamOptions__readAhead & 2;// 2

}

declare class InputStreamOptions__none mixins InputStreamOptions {}
declare class InputStreamOptions__partial mixins InputStreamOptions {}
declare class InputStreamOptions__readAhead mixins InputStreamOptions {}

	declare export interface IContentTypeProvider {
contentType: string
} 
	declare export interface IRandomAccessStreamReference {
openReadAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IRandomAccessStreamWithContentType>
} 
	declare export interface IInputStreamReference {
openSequentialReadAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IInputStream>
} 
	declare export interface IRandomAccessStreamReferenceStatics {
createFromFile(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Storage.Streams.RandomAccessStreamReference,
createFromUri(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Storage.Streams.RandomAccessStreamReference,
createFromStream(
stream: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Storage.Streams.RandomAccessStreamReference
} 
	declare export class RandomAccessStreamReference mixins undefined.IRandomAccessStreamReference {
openReadAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IRandomAccessStreamWithContentType>;
static createFromFile(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Storage.Streams.RandomAccessStreamReference;
static createFromUri(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Storage.Streams.RandomAccessStreamReference;
static createFromStream(
stream: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Storage.Streams.RandomAccessStreamReference
}
	declare export class FileRandomAccessStream mixins undefined.IRandomAccessStream, undefined.IClosable, undefined.IInputStream, undefined.IOutputStream {
canRead: boolean;
canWrite: boolean;
position: number;
size: number;
getInputStreamAt(position: number): Windows$Windows$Storage.Streams.IInputStream;
getOutputStreamAt(position: number): Windows$Windows$Storage.Streams.IOutputStream;
seek(position: number): void;
cloneStream(): Windows$Windows$Storage.Streams.IRandomAccessStream;
dispose(): void;
readAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer,
count: number,
options: Windows$Windows$Storage.Streams.InputStreamOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Storage.Streams.IBuffer, number>;
writeAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
flushAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
close(): void
}
	declare export class FileInputStream mixins undefined.IInputStream, undefined.IClosable {
readAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer,
count: number,
options: Windows$Windows$Storage.Streams.InputStreamOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Storage.Streams.IBuffer, number>;
dispose(): void;
close(): void
}
	declare export class FileOutputStream mixins undefined.IOutputStream, undefined.IClosable {
writeAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
flushAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
dispose(): void;
close(): void
}
	declare export class RandomAccessStreamOverStream mixins undefined.IRandomAccessStream, undefined.IClosable, undefined.IInputStream, undefined.IOutputStream {
canRead: boolean;
canWrite: boolean;
position: number;
size: number;
getInputStreamAt(position: number): Windows$Windows$Storage.Streams.IInputStream;
getOutputStreamAt(position: number): Windows$Windows$Storage.Streams.IOutputStream;
seek(position: number): void;
cloneStream(): Windows$Windows$Storage.Streams.IRandomAccessStream;
dispose(): void;
readAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer,
count: number,
options: Windows$Windows$Storage.Streams.InputStreamOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Storage.Streams.IBuffer, number>;
writeAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
flushAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
close(): void
}
	declare export class InputStreamOverStream mixins undefined.IInputStream, undefined.IClosable {
readAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer,
count: number,
options: Windows$Windows$Storage.Streams.InputStreamOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Storage.Streams.IBuffer, number>;
dispose(): void;
close(): void
}
	declare export class OutputStreamOverStream mixins undefined.IOutputStream, undefined.IClosable {
writeAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
flushAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
dispose(): void;
close(): void
}
	declare export class InMemoryRandomAccessStream mixins undefined.IRandomAccessStream, undefined.IClosable, undefined.IInputStream, undefined.IOutputStream {
canRead: boolean;
canWrite: boolean;
position: number;
size: number;
getInputStreamAt(position: number): Windows$Windows$Storage.Streams.IInputStream;
getOutputStreamAt(position: number): Windows$Windows$Storage.Streams.IOutputStream;
seek(position: number): void;
cloneStream(): Windows$Windows$Storage.Streams.IRandomAccessStream;
dispose(): void;
readAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer,
count: number,
options: Windows$Windows$Storage.Streams.InputStreamOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Storage.Streams.IBuffer, number>;
writeAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
flushAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
close(): void
}
	declare export type IInputStream = {
readAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer,
count: number,
options: Windows$Windows$Storage.Streams.InputStreamOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Storage.Streams.IBuffer, number>
} & undefined.IClosable

	declare export type IOutputStream = {
writeAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>,
flushAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>
} & undefined.IClosable

	declare export type IRandomAccessStream = {
canRead: boolean,
canWrite: boolean,
position: number,
size: number,
getInputStreamAt(position: number): Windows$Windows$Storage.Streams.IInputStream,
getOutputStreamAt(position: number): Windows$Windows$Storage.Streams.IOutputStream,
seek(position: number): void,
cloneStream(): Windows$Windows$Storage.Streams.IRandomAccessStream
} & undefined.IClosable & undefined.IInputStream & undefined.IOutputStream

	declare export type IRandomAccessStreamWithContentType = {} & undefined.IRandomAccessStream & undefined.IClosable & undefined.IInputStream & undefined.IOutputStream & undefined.IContentTypeProvider

    }

	declare module 'Pickers' {
        declare module 'Provider' {
        declare export interface IContactRemovedEventArgs {
id: string
} 
	declare export class ContactRemovedEventArgs mixins undefined.IContactRemovedEventArgs {
id: string
}
	declare export  class AddContactResult {
  constructor(...args: empty): mixed;
static +added: Class<AddContactResult__added> & AddContactResult__added & 0;// 0
static +alreadyAdded: Class<AddContactResult__alreadyAdded> & AddContactResult__alreadyAdded & 1;// 1
static +unavailable: Class<AddContactResult__unavailable> & AddContactResult__unavailable & 2;// 2

}

declare class AddContactResult__added mixins AddContactResult {}
declare class AddContactResult__alreadyAdded mixins AddContactResult {}
declare class AddContactResult__unavailable mixins AddContactResult {}

	declare export interface IContactPickerUI {
desiredFields: Windows$Windows$Foundation.Collections.IVectorView<string>,
selectionMode: Windows$Windows$ApplicationModel.Contacts.ContactSelectionMode,
addContact(
id: string,
contact: Windows$Windows$ApplicationModel.Contacts.Contact): Windows$Windows$ApplicationModel.Contacts.Provider.AddContactResult,
removeContact(id: string): void,
containsContact(id: string): boolean,
oncontactremoved: any
} 
	declare export class ContactPickerUI mixins undefined.IContactPickerUI {
desiredFields: Windows$Windows$Foundation.Collections.IVectorView<string>;
selectionMode: Windows$Windows$ApplicationModel.Contacts.ContactSelectionMode;
addContact(
id: string,
contact: Windows$Windows$ApplicationModel.Contacts.Contact): Windows$Windows$ApplicationModel.Contacts.Provider.AddContactResult;
removeContact(id: string): void;
containsContact(id: string): boolean;
oncontactremoved: any
}
	declare export interface IFileRemovedEventArgs {
id: string
} 
	declare export class FileRemovedEventArgs mixins undefined.IFileRemovedEventArgs {
id: string
}
	declare export  class AddFileResult {
  constructor(...args: empty): mixed;
static +added: Class<AddFileResult__added> & AddFileResult__added & 0;// 0
static +alreadyAdded: Class<AddFileResult__alreadyAdded> & AddFileResult__alreadyAdded & 1;// 1
static +notAllowed: Class<AddFileResult__notAllowed> & AddFileResult__notAllowed & 2;// 2
static +unavailable: Class<AddFileResult__unavailable> & AddFileResult__unavailable & 3;// 3

}

declare class AddFileResult__added mixins AddFileResult {}
declare class AddFileResult__alreadyAdded mixins AddFileResult {}
declare class AddFileResult__notAllowed mixins AddFileResult {}
declare class AddFileResult__unavailable mixins AddFileResult {}

	declare export  class FileSelectionMode {
  constructor(...args: empty): mixed;
static +single: Class<FileSelectionMode__single> & FileSelectionMode__single & 0;// 0
static +multiple: Class<FileSelectionMode__multiple> & FileSelectionMode__multiple & 1;// 1

}

declare class FileSelectionMode__single mixins FileSelectionMode {}
declare class FileSelectionMode__multiple mixins FileSelectionMode {}

	declare export interface IFileOpenPickerUI {
allowedFileTypes: Windows$Windows$Foundation.Collections.IVectorView<string>,
selectionMode: Windows$Windows$Storage.Pickers.Provider.FileSelectionMode,
settingsIdentifier: string,
title: string,
addFile(
id: string,
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Storage.Pickers.Provider.AddFileResult,
removeFile(id: string): void,
containsFile(id: string): boolean,
canAddFile(file: Windows$Windows$Storage.IStorageFile): boolean,
onfileremoved: any,
onclosing: any
} 
	declare export class FileOpenPickerUI mixins undefined.IFileOpenPickerUI {
allowedFileTypes: Windows$Windows$Foundation.Collections.IVectorView<string>;
selectionMode: Windows$Windows$Storage.Pickers.Provider.FileSelectionMode;
settingsIdentifier: string;
title: string;
addFile(
id: string,
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Storage.Pickers.Provider.AddFileResult;
removeFile(id: string): void;
containsFile(id: string): boolean;
canAddFile(file: Windows$Windows$Storage.IStorageFile): boolean;
onfileremoved: any;
onclosing: any
}
	declare export class PickerClosingEventArgs mixins undefined.IPickerClosingEventArgs {
closingOperation: Windows$Windows$Storage.Pickers.Provider.PickerClosingOperation;
isCanceled: boolean
}
	declare export interface IPickerClosingEventArgs {
closingOperation: Windows$Windows$Storage.Pickers.Provider.PickerClosingOperation,
isCanceled: boolean
} 
	declare export class PickerClosingOperation mixins undefined.IPickerClosingOperation {
deadline: Date;
getDeferral(): Windows$Windows$Storage.Pickers.Provider.PickerClosingDeferral
}
	declare export interface IPickerClosingOperation {
deadline: Date,
getDeferral(): Windows$Windows$Storage.Pickers.Provider.PickerClosingDeferral
} 
	declare export class PickerClosingDeferral mixins undefined.IPickerClosingDeferral {
complete(): void
}
	declare export interface IPickerClosingDeferral {
complete(): void
} 
	declare export  class SetFileNameResult {
  constructor(...args: empty): mixed;
static +succeeded: Class<SetFileNameResult__succeeded> & SetFileNameResult__succeeded & 0;// 0
static +notAllowed: Class<SetFileNameResult__notAllowed> & SetFileNameResult__notAllowed & 1;// 1
static +unavailable: Class<SetFileNameResult__unavailable> & SetFileNameResult__unavailable & 2;// 2

}

declare class SetFileNameResult__succeeded mixins SetFileNameResult {}
declare class SetFileNameResult__notAllowed mixins SetFileNameResult {}
declare class SetFileNameResult__unavailable mixins SetFileNameResult {}

	declare export interface IFileSavePickerUI {
allowedFileTypes: Windows$Windows$Foundation.Collections.IVectorView<string>,
fileName: string,
settingsIdentifier: string,
title: string,
trySetFileName(value: string): Windows$Windows$Storage.Pickers.Provider.SetFileNameResult,
onfilenamechanged: any,
ontargetfilerequested: any
} 
	declare export class FileSavePickerUI mixins undefined.IFileSavePickerUI {
allowedFileTypes: Windows$Windows$Foundation.Collections.IVectorView<string>;
fileName: string;
settingsIdentifier: string;
title: string;
trySetFileName(value: string): Windows$Windows$Storage.Pickers.Provider.SetFileNameResult;
onfilenamechanged: any;
ontargetfilerequested: any
}
	declare export class TargetFileRequestedEventArgs mixins undefined.ITargetFileRequestedEventArgs {
request: Windows$Windows$Storage.Pickers.Provider.TargetFileRequest
}
	declare export interface ITargetFileRequestedEventArgs {
request: Windows$Windows$Storage.Pickers.Provider.TargetFileRequest
} 
	declare export class TargetFileRequest mixins undefined.ITargetFileRequest {
targetFile: Windows$Windows$Storage.IStorageFile;
getDeferral(): Windows$Windows$Storage.Pickers.Provider.TargetFileRequestDeferral
}
	declare export interface ITargetFileRequest {
targetFile: Windows$Windows$Storage.IStorageFile,
getDeferral(): Windows$Windows$Storage.Pickers.Provider.TargetFileRequestDeferral
} 
	declare export class TargetFileRequestDeferral mixins undefined.ITargetFileRequestDeferral {
complete(): void
}
	declare export interface ITargetFileRequestDeferral {
complete(): void
} 
	declare export  class CachedFileTarget {
  constructor(...args: empty): mixed;
static +local: Class<CachedFileTarget__local> & CachedFileTarget__local & 0;// 0
static +remote: Class<CachedFileTarget__remote> & CachedFileTarget__remote & 1;// 1

}

declare class CachedFileTarget__local mixins CachedFileTarget {}
declare class CachedFileTarget__remote mixins CachedFileTarget {}

	declare export  class UIStatus {
  constructor(...args: empty): mixed;
static +unavailable: Class<UIStatus__unavailable> & UIStatus__unavailable & 0;// 0
static +hidden: Class<UIStatus__hidden> & UIStatus__hidden & 1;// 1
static +visible: Class<UIStatus__visible> & UIStatus__visible & 2;// 2
static +complete: Class<UIStatus__complete> & UIStatus__complete & 3;// 3

}

declare class UIStatus__unavailable mixins UIStatus {}
declare class UIStatus__hidden mixins UIStatus {}
declare class UIStatus__visible mixins UIStatus {}
declare class UIStatus__complete mixins UIStatus {}

	declare export interface ICachedFileUpdaterUI {
title: string,
uIStatus: Windows$Windows$Storage.Provider.UIStatus,
updateTarget: Windows$Windows$Storage.Provider.CachedFileTarget,
onfileupdaterequested: any,
onuirequested: any
} 
	declare export class CachedFileUpdaterUI mixins undefined.ICachedFileUpdaterUI {
title: string;
uIStatus: Windows$Windows$Storage.Provider.UIStatus;
updateTarget: Windows$Windows$Storage.Provider.CachedFileTarget;
onfileupdaterequested: any;
onuirequested: any
}
	declare export class FileUpdateRequestedEventArgs mixins undefined.IFileUpdateRequestedEventArgs {
request: Windows$Windows$Storage.Provider.FileUpdateRequest
}
	declare export interface IFileUpdateRequestedEventArgs {
request: Windows$Windows$Storage.Provider.FileUpdateRequest
} 
	declare export class FileUpdateRequest mixins undefined.IFileUpdateRequest {
contentId: string;
file: Windows$Windows$Storage.StorageFile;
status: Windows$Windows$Storage.Provider.FileUpdateStatus;
getDeferral(): Windows$Windows$Storage.Provider.FileUpdateRequestDeferral;
updateLocalFile(value: Windows$Windows$Storage.IStorageFile): void
}
	declare export interface IFileUpdateRequest {
contentId: string,
file: Windows$Windows$Storage.StorageFile,
status: Windows$Windows$Storage.Provider.FileUpdateStatus,
getDeferral(): Windows$Windows$Storage.Provider.FileUpdateRequestDeferral,
updateLocalFile(value: Windows$Windows$Storage.IStorageFile): void
} 
	declare export class FileUpdateRequestDeferral mixins undefined.IFileUpdateRequestDeferral {
complete(): void
}
	declare export interface IFileUpdateRequestDeferral {
complete(): void
} 
	declare export  class FileUpdateStatus {
  constructor(...args: empty): mixed;
static +incomplete: Class<FileUpdateStatus__incomplete> & FileUpdateStatus__incomplete & 0;// 0
static +complete: Class<FileUpdateStatus__complete> & FileUpdateStatus__complete & 1;// 1
static +userInputNeeded: Class<FileUpdateStatus__userInputNeeded> & FileUpdateStatus__userInputNeeded & 2;// 2
static +currentlyUnavailable: Class<FileUpdateStatus__currentlyUnavailable> & FileUpdateStatus__currentlyUnavailable & 3;// 3
static +failed: Class<FileUpdateStatus__failed> & FileUpdateStatus__failed & 4;// 4
static +completeAndRenamed: Class<FileUpdateStatus__completeAndRenamed> & FileUpdateStatus__completeAndRenamed & 5;// 5

}

declare class FileUpdateStatus__incomplete mixins FileUpdateStatus {}
declare class FileUpdateStatus__complete mixins FileUpdateStatus {}
declare class FileUpdateStatus__userInputNeeded mixins FileUpdateStatus {}
declare class FileUpdateStatus__currentlyUnavailable mixins FileUpdateStatus {}
declare class FileUpdateStatus__failed mixins FileUpdateStatus {}
declare class FileUpdateStatus__completeAndRenamed mixins FileUpdateStatus {}

	declare export  class CachedFileOptions {
  constructor(...args: empty): mixed;
static +none: Class<CachedFileOptions__none> & CachedFileOptions__none & 0;// 0
static +requireUpdateOnAccess: Class<CachedFileOptions__requireUpdateOnAccess> & CachedFileOptions__requireUpdateOnAccess & 1;// 1
static +useCachedFileWhenOffline: Class<CachedFileOptions__useCachedFileWhenOffline> & CachedFileOptions__useCachedFileWhenOffline & 2;// 2
static +denyAccessWhenOffline: Class<CachedFileOptions__denyAccessWhenOffline> & CachedFileOptions__denyAccessWhenOffline & 3;// 3

}

declare class CachedFileOptions__none mixins CachedFileOptions {}
declare class CachedFileOptions__requireUpdateOnAccess mixins CachedFileOptions {}
declare class CachedFileOptions__useCachedFileWhenOffline mixins CachedFileOptions {}
declare class CachedFileOptions__denyAccessWhenOffline mixins CachedFileOptions {}

	declare export  class ReadActivationMode {
  constructor(...args: empty): mixed;
static +notNeeded: Class<ReadActivationMode__notNeeded> & ReadActivationMode__notNeeded & 0;// 0
static +beforeAccess: Class<ReadActivationMode__beforeAccess> & ReadActivationMode__beforeAccess & 1;// 1

}

declare class ReadActivationMode__notNeeded mixins ReadActivationMode {}
declare class ReadActivationMode__beforeAccess mixins ReadActivationMode {}

	declare export  class WriteActivationMode {
  constructor(...args: empty): mixed;
static +readOnly: Class<WriteActivationMode__readOnly> & WriteActivationMode__readOnly & 0;// 0
static +notNeeded: Class<WriteActivationMode__notNeeded> & WriteActivationMode__notNeeded & 1;// 1
static +afterWrite: Class<WriteActivationMode__afterWrite> & WriteActivationMode__afterWrite & 2;// 2

}

declare class WriteActivationMode__readOnly mixins WriteActivationMode {}
declare class WriteActivationMode__notNeeded mixins WriteActivationMode {}
declare class WriteActivationMode__afterWrite mixins WriteActivationMode {}

	declare export interface ICachedFileUpdaterStatics {
setUpdateInformation(
file: Windows$Windows$Storage.IStorageFile,
contentId: string,
readMode: Windows$Windows$Storage.Provider.ReadActivationMode,
writeMode: Windows$Windows$Storage.Provider.WriteActivationMode,
options: Windows$Windows$Storage.Provider.CachedFileOptions): void
} 
	declare export class CachedFileUpdater  {
static setUpdateInformation(
file: Windows$Windows$Storage.IStorageFile,
contentId: string,
readMode: Windows$Windows$Storage.Provider.ReadActivationMode,
writeMode: Windows$Windows$Storage.Provider.WriteActivationMode,
options: Windows$Windows$Storage.Provider.CachedFileOptions): void
}
    }

	declare export  class PickerViewMode {
  constructor(...args: empty): mixed;
static +list: Class<PickerViewMode__list> & PickerViewMode__list & 0;// 0
static +thumbnail: Class<PickerViewMode__thumbnail> & PickerViewMode__thumbnail & 1;// 1

}

declare class PickerViewMode__list mixins PickerViewMode {}
declare class PickerViewMode__thumbnail mixins PickerViewMode {}

	declare export  class PickerLocationId {
  constructor(...args: empty): mixed;
static +documentsLibrary: Class<PickerLocationId__documentsLibrary> & PickerLocationId__documentsLibrary & 0;// 0
static +computerFolder: Class<PickerLocationId__computerFolder> & PickerLocationId__computerFolder & 1;// 1
static +desktop: Class<PickerLocationId__desktop> & PickerLocationId__desktop & 2;// 2
static +downloads: Class<PickerLocationId__downloads> & PickerLocationId__downloads & 3;// 3
static +homeGroup: Class<PickerLocationId__homeGroup> & PickerLocationId__homeGroup & 4;// 4
static +musicLibrary: Class<PickerLocationId__musicLibrary> & PickerLocationId__musicLibrary & 5;// 5
static +picturesLibrary: Class<PickerLocationId__picturesLibrary> & PickerLocationId__picturesLibrary & 6;// 6
static +videosLibrary: Class<PickerLocationId__videosLibrary> & PickerLocationId__videosLibrary & 7;// 7

}

declare class PickerLocationId__documentsLibrary mixins PickerLocationId {}
declare class PickerLocationId__computerFolder mixins PickerLocationId {}
declare class PickerLocationId__desktop mixins PickerLocationId {}
declare class PickerLocationId__downloads mixins PickerLocationId {}
declare class PickerLocationId__homeGroup mixins PickerLocationId {}
declare class PickerLocationId__musicLibrary mixins PickerLocationId {}
declare class PickerLocationId__picturesLibrary mixins PickerLocationId {}
declare class PickerLocationId__videosLibrary mixins PickerLocationId {}

	declare export class FilePickerSelectedFilesArray mixins undefined.IVectorView<Windows$Windows$Storage.StorageFile>, undefined.IIterable<Windows$Windows$Storage.StorageFile> {
size: number;
getAt(index: number): Windows$Windows$Storage.StorageFile;
indexOf(
value: Windows$Windows$Storage.StorageFile): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$Storage.StorageFile[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Storage.StorageFile>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$Storage.StorageFile[][]): Windows$Windows$Storage.StorageFile[];
join(seperator: string): string;
pop(): Windows$Windows$Storage.StorageFile;
push(...items: Windows$Windows$Storage.StorageFile[]): void;
reverse(): Windows$Windows$Storage.StorageFile[];
shift(): Windows$Windows$Storage.StorageFile;
slice(start: number): Windows$Windows$Storage.StorageFile[];
slice(start: number, end: number): Windows$Windows$Storage.StorageFile[];
sort(): Windows$Windows$Storage.StorageFile[];
sort(
compareFn: (
a: Windows$Windows$Storage.StorageFile,
b: Windows$Windows$Storage.StorageFile) => number): Windows$Windows$Storage.StorageFile[];
splice(start: number): Windows$Windows$Storage.StorageFile[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$Storage.StorageFile[]): Windows$Windows$Storage.StorageFile[];
unshift(...items: Windows$Windows$Storage.StorageFile[]): number;
lastIndexOf(searchElement: Windows$Windows$Storage.StorageFile): number;
lastIndexOf(searchElement: Windows$Windows$Storage.StorageFile, fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$Storage.StorageFile,
index: number,
array: Windows$Windows$Storage.StorageFile[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$Storage.StorageFile,
index: number,
array: Windows$Windows$Storage.StorageFile[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$Storage.StorageFile,
index: number,
array: Windows$Windows$Storage.StorageFile[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$Storage.StorageFile,
index: number,
array: Windows$Windows$Storage.StorageFile[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$Storage.StorageFile,
index: number,
array: Windows$Windows$Storage.StorageFile[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$Storage.StorageFile,
index: number,
array: Windows$Windows$Storage.StorageFile[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$Storage.StorageFile,
index: number,
array: Windows$Windows$Storage.StorageFile[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$Storage.StorageFile,
index: number,
array: Windows$Windows$Storage.StorageFile[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$Storage.StorageFile,
index: number,
array: Windows$Windows$Storage.StorageFile[]) => boolean): Windows$Windows$Storage.StorageFile[];
filter(
callbackfn: (
value: Windows$Windows$Storage.StorageFile,
index: number,
array: Windows$Windows$Storage.StorageFile[]) => boolean,
thisArg: any): Windows$Windows$Storage.StorageFile[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.StorageFile[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.StorageFile[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.StorageFile[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.StorageFile[]) => any,
initialValue: any): any;
length: number
}
	declare export class FilePickerFileTypesOrderedMap mixins undefined.IMap<string, Windows$Windows$Foundation.Collections.IVector<string>>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$Foundation.Collections.IVector<string>>> {
size: number;
lookup(key: string): Windows$Windows$Foundation.Collections.IVector<string>;
hasKey(key: string): boolean;
getView(
): Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$Foundation.Collections.IVector<string>>;
insert(
key: string,
value: Windows$Windows$Foundation.Collections.IVector<string>): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$Foundation.Collections.IVector<string>>>
}
	declare export class FileExtensionVector mixins undefined.IVector<string>, undefined.IIterable<string> {
size: number;
getAt(index: number): string;
getView(): Windows$Windows$Foundation.Collections.IVectorView<string>;
indexOf(value: string): {
index: number,
returnValue: boolean
};
setAt(index: number, value: string): void;
insertAt(index: number, value: string): void;
removeAt(index: number): void;
append(value: string): void;
removeAtEnd(): void;
clear(): void;
getMany(startIndex: number): {
items: string[],
returnValue: number
};
replaceAll(items: string[]): void;
first(): Windows$Windows$Foundation.Collections.IIterator<string>;
toString(): string;
toLocaleString(): string;
concat(...items: string[][]): string[];
join(seperator: string): string;
pop(): string;
push(...items: string[]): void;
reverse(): string[];
shift(): string;
slice(start: number): string[];
slice(start: number, end: number): string[];
sort(): string[];
sort(compareFn: (a: string, b: string) => number): string[];
splice(start: number): string[];
splice(start: number, deleteCount: number, ...items: string[]): string[];
unshift(...items: string[]): number;
lastIndexOf(searchElement: string): number;
lastIndexOf(searchElement: string, fromIndex: number): number;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
forEach(callbackfn: (value: string, index: number, array: string[]) => void): void;
forEach(
callbackfn: (value: string, index: number, array: string[]) => void,
thisArg: any): void;
map(callbackfn: (value: string, index: number, array: string[]) => any): any[];
map(
callbackfn: (value: string, index: number, array: string[]) => any,
thisArg: any): any[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean): string[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): string[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
length: number
}
	declare export interface IFileOpenPicker {
commitButtonText: string,
continuationData: Windows$Windows$Foundation.Collections.ValueSet,
fileTypeFilter: Windows$Windows$Foundation.Collections.IVector<string>,
settingsIdentifier: string,
suggestedStartLocation: Windows$Windows$Storage.Pickers.PickerLocationId,
viewMode: Windows$Windows$Storage.Pickers.PickerViewMode,
pickMultipleFilesAndContinue(): void,
pickMultipleFilesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>,
pickSingleFileAndContinue(): void,
pickSingleFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>
} 
	declare export interface IFileSavePicker {
commitButtonText: string,
continuationData: Windows$Windows$Foundation.Collections.ValueSet,
defaultFileExtension: string,
fileTypeChoices: Windows$Windows$Foundation.Collections.IMap<string, Windows$Windows$Foundation.Collections.IVector<string>>,
settingsIdentifier: string,
suggestedFileName: string,
suggestedSaveFile: Windows$Windows$Storage.StorageFile,
suggestedStartLocation: Windows$Windows$Storage.Pickers.PickerLocationId,
pickSaveFileAndContinue(): void,
pickSaveFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>
} 
	declare export interface IFolderPicker {
commitButtonText: string,
continuationData: Windows$Windows$Foundation.Collections.ValueSet,
fileTypeFilter: Windows$Windows$Foundation.Collections.IVector<string>,
settingsIdentifier: string,
suggestedStartLocation: Windows$Windows$Storage.Pickers.PickerLocationId,
viewMode: Windows$Windows$Storage.Pickers.PickerViewMode,
pickFolderAndContinue(): void,
pickSingleFolderAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>
} 
	declare export class FileOpenPicker mixins undefined.IFileOpenPicker {
commitButtonText: string;
fileTypeFilter: Windows$Windows$Foundation.Collections.IVector<string>;
settingsIdentifier: string;
suggestedStartLocation: Windows$Windows$Storage.Pickers.PickerLocationId;
viewMode: Windows$Windows$Storage.Pickers.PickerViewMode;
continuationData: Windows$Windows$Foundation.Collections.ValueSet;
pickSingleFileAndContinue(): void;
pickSingleFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
pickMultipleFilesAndContinue(): void;
pickMultipleFilesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>
}
	declare export class FileSavePicker mixins undefined.IFileSavePicker {
commitButtonText: string;
defaultFileExtension: string;
fileTypeChoices: Windows$Windows$Foundation.Collections.IMap<string, Windows$Windows$Foundation.Collections.IVector<string>>;
settingsIdentifier: string;
suggestedFileName: string;
suggestedSaveFile: Windows$Windows$Storage.StorageFile;
suggestedStartLocation: Windows$Windows$Storage.Pickers.PickerLocationId;
continuationData: Windows$Windows$Foundation.Collections.ValueSet;
pickSaveFileAndContinue(): void;
pickSaveFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>
}
	declare export class FolderPicker mixins undefined.IFolderPicker {
commitButtonText: string;
fileTypeFilter: Windows$Windows$Foundation.Collections.IVector<string>;
settingsIdentifier: string;
suggestedStartLocation: Windows$Windows$Storage.Pickers.PickerLocationId;
viewMode: Windows$Windows$Storage.Pickers.PickerViewMode;
continuationData: Windows$Windows$Foundation.Collections.ValueSet;
pickFolderAndContinue(): void;
pickSingleFolderAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>
}
    }

	declare module 'Provider' {
        declare export interface IContactRemovedEventArgs {
id: string
} 
	declare export class ContactRemovedEventArgs mixins undefined.IContactRemovedEventArgs {
id: string
}
	declare export  class AddContactResult {
  constructor(...args: empty): mixed;
static +added: Class<AddContactResult__added> & AddContactResult__added & 0;// 0
static +alreadyAdded: Class<AddContactResult__alreadyAdded> & AddContactResult__alreadyAdded & 1;// 1
static +unavailable: Class<AddContactResult__unavailable> & AddContactResult__unavailable & 2;// 2

}

declare class AddContactResult__added mixins AddContactResult {}
declare class AddContactResult__alreadyAdded mixins AddContactResult {}
declare class AddContactResult__unavailable mixins AddContactResult {}

	declare export interface IContactPickerUI {
desiredFields: Windows$Windows$Foundation.Collections.IVectorView<string>,
selectionMode: Windows$Windows$ApplicationModel.Contacts.ContactSelectionMode,
addContact(
id: string,
contact: Windows$Windows$ApplicationModel.Contacts.Contact): Windows$Windows$ApplicationModel.Contacts.Provider.AddContactResult,
removeContact(id: string): void,
containsContact(id: string): boolean,
oncontactremoved: any
} 
	declare export class ContactPickerUI mixins undefined.IContactPickerUI {
desiredFields: Windows$Windows$Foundation.Collections.IVectorView<string>;
selectionMode: Windows$Windows$ApplicationModel.Contacts.ContactSelectionMode;
addContact(
id: string,
contact: Windows$Windows$ApplicationModel.Contacts.Contact): Windows$Windows$ApplicationModel.Contacts.Provider.AddContactResult;
removeContact(id: string): void;
containsContact(id: string): boolean;
oncontactremoved: any
}
	declare export interface IFileRemovedEventArgs {
id: string
} 
	declare export class FileRemovedEventArgs mixins undefined.IFileRemovedEventArgs {
id: string
}
	declare export  class AddFileResult {
  constructor(...args: empty): mixed;
static +added: Class<AddFileResult__added> & AddFileResult__added & 0;// 0
static +alreadyAdded: Class<AddFileResult__alreadyAdded> & AddFileResult__alreadyAdded & 1;// 1
static +notAllowed: Class<AddFileResult__notAllowed> & AddFileResult__notAllowed & 2;// 2
static +unavailable: Class<AddFileResult__unavailable> & AddFileResult__unavailable & 3;// 3

}

declare class AddFileResult__added mixins AddFileResult {}
declare class AddFileResult__alreadyAdded mixins AddFileResult {}
declare class AddFileResult__notAllowed mixins AddFileResult {}
declare class AddFileResult__unavailable mixins AddFileResult {}

	declare export  class FileSelectionMode {
  constructor(...args: empty): mixed;
static +single: Class<FileSelectionMode__single> & FileSelectionMode__single & 0;// 0
static +multiple: Class<FileSelectionMode__multiple> & FileSelectionMode__multiple & 1;// 1

}

declare class FileSelectionMode__single mixins FileSelectionMode {}
declare class FileSelectionMode__multiple mixins FileSelectionMode {}

	declare export interface IFileOpenPickerUI {
allowedFileTypes: Windows$Windows$Foundation.Collections.IVectorView<string>,
selectionMode: Windows$Windows$Storage.Pickers.Provider.FileSelectionMode,
settingsIdentifier: string,
title: string,
addFile(
id: string,
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Storage.Pickers.Provider.AddFileResult,
removeFile(id: string): void,
containsFile(id: string): boolean,
canAddFile(file: Windows$Windows$Storage.IStorageFile): boolean,
onfileremoved: any,
onclosing: any
} 
	declare export class FileOpenPickerUI mixins undefined.IFileOpenPickerUI {
allowedFileTypes: Windows$Windows$Foundation.Collections.IVectorView<string>;
selectionMode: Windows$Windows$Storage.Pickers.Provider.FileSelectionMode;
settingsIdentifier: string;
title: string;
addFile(
id: string,
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Storage.Pickers.Provider.AddFileResult;
removeFile(id: string): void;
containsFile(id: string): boolean;
canAddFile(file: Windows$Windows$Storage.IStorageFile): boolean;
onfileremoved: any;
onclosing: any
}
	declare export class PickerClosingEventArgs mixins undefined.IPickerClosingEventArgs {
closingOperation: Windows$Windows$Storage.Pickers.Provider.PickerClosingOperation;
isCanceled: boolean
}
	declare export interface IPickerClosingEventArgs {
closingOperation: Windows$Windows$Storage.Pickers.Provider.PickerClosingOperation,
isCanceled: boolean
} 
	declare export class PickerClosingOperation mixins undefined.IPickerClosingOperation {
deadline: Date;
getDeferral(): Windows$Windows$Storage.Pickers.Provider.PickerClosingDeferral
}
	declare export interface IPickerClosingOperation {
deadline: Date,
getDeferral(): Windows$Windows$Storage.Pickers.Provider.PickerClosingDeferral
} 
	declare export class PickerClosingDeferral mixins undefined.IPickerClosingDeferral {
complete(): void
}
	declare export interface IPickerClosingDeferral {
complete(): void
} 
	declare export  class SetFileNameResult {
  constructor(...args: empty): mixed;
static +succeeded: Class<SetFileNameResult__succeeded> & SetFileNameResult__succeeded & 0;// 0
static +notAllowed: Class<SetFileNameResult__notAllowed> & SetFileNameResult__notAllowed & 1;// 1
static +unavailable: Class<SetFileNameResult__unavailable> & SetFileNameResult__unavailable & 2;// 2

}

declare class SetFileNameResult__succeeded mixins SetFileNameResult {}
declare class SetFileNameResult__notAllowed mixins SetFileNameResult {}
declare class SetFileNameResult__unavailable mixins SetFileNameResult {}

	declare export interface IFileSavePickerUI {
allowedFileTypes: Windows$Windows$Foundation.Collections.IVectorView<string>,
fileName: string,
settingsIdentifier: string,
title: string,
trySetFileName(value: string): Windows$Windows$Storage.Pickers.Provider.SetFileNameResult,
onfilenamechanged: any,
ontargetfilerequested: any
} 
	declare export class FileSavePickerUI mixins undefined.IFileSavePickerUI {
allowedFileTypes: Windows$Windows$Foundation.Collections.IVectorView<string>;
fileName: string;
settingsIdentifier: string;
title: string;
trySetFileName(value: string): Windows$Windows$Storage.Pickers.Provider.SetFileNameResult;
onfilenamechanged: any;
ontargetfilerequested: any
}
	declare export class TargetFileRequestedEventArgs mixins undefined.ITargetFileRequestedEventArgs {
request: Windows$Windows$Storage.Pickers.Provider.TargetFileRequest
}
	declare export interface ITargetFileRequestedEventArgs {
request: Windows$Windows$Storage.Pickers.Provider.TargetFileRequest
} 
	declare export class TargetFileRequest mixins undefined.ITargetFileRequest {
targetFile: Windows$Windows$Storage.IStorageFile;
getDeferral(): Windows$Windows$Storage.Pickers.Provider.TargetFileRequestDeferral
}
	declare export interface ITargetFileRequest {
targetFile: Windows$Windows$Storage.IStorageFile,
getDeferral(): Windows$Windows$Storage.Pickers.Provider.TargetFileRequestDeferral
} 
	declare export class TargetFileRequestDeferral mixins undefined.ITargetFileRequestDeferral {
complete(): void
}
	declare export interface ITargetFileRequestDeferral {
complete(): void
} 
	declare export  class CachedFileTarget {
  constructor(...args: empty): mixed;
static +local: Class<CachedFileTarget__local> & CachedFileTarget__local & 0;// 0
static +remote: Class<CachedFileTarget__remote> & CachedFileTarget__remote & 1;// 1

}

declare class CachedFileTarget__local mixins CachedFileTarget {}
declare class CachedFileTarget__remote mixins CachedFileTarget {}

	declare export  class UIStatus {
  constructor(...args: empty): mixed;
static +unavailable: Class<UIStatus__unavailable> & UIStatus__unavailable & 0;// 0
static +hidden: Class<UIStatus__hidden> & UIStatus__hidden & 1;// 1
static +visible: Class<UIStatus__visible> & UIStatus__visible & 2;// 2
static +complete: Class<UIStatus__complete> & UIStatus__complete & 3;// 3

}

declare class UIStatus__unavailable mixins UIStatus {}
declare class UIStatus__hidden mixins UIStatus {}
declare class UIStatus__visible mixins UIStatus {}
declare class UIStatus__complete mixins UIStatus {}

	declare export interface ICachedFileUpdaterUI {
title: string,
uIStatus: Windows$Windows$Storage.Provider.UIStatus,
updateTarget: Windows$Windows$Storage.Provider.CachedFileTarget,
onfileupdaterequested: any,
onuirequested: any
} 
	declare export class CachedFileUpdaterUI mixins undefined.ICachedFileUpdaterUI {
title: string;
uIStatus: Windows$Windows$Storage.Provider.UIStatus;
updateTarget: Windows$Windows$Storage.Provider.CachedFileTarget;
onfileupdaterequested: any;
onuirequested: any
}
	declare export class FileUpdateRequestedEventArgs mixins undefined.IFileUpdateRequestedEventArgs {
request: Windows$Windows$Storage.Provider.FileUpdateRequest
}
	declare export interface IFileUpdateRequestedEventArgs {
request: Windows$Windows$Storage.Provider.FileUpdateRequest
} 
	declare export class FileUpdateRequest mixins undefined.IFileUpdateRequest {
contentId: string;
file: Windows$Windows$Storage.StorageFile;
status: Windows$Windows$Storage.Provider.FileUpdateStatus;
getDeferral(): Windows$Windows$Storage.Provider.FileUpdateRequestDeferral;
updateLocalFile(value: Windows$Windows$Storage.IStorageFile): void
}
	declare export interface IFileUpdateRequest {
contentId: string,
file: Windows$Windows$Storage.StorageFile,
status: Windows$Windows$Storage.Provider.FileUpdateStatus,
getDeferral(): Windows$Windows$Storage.Provider.FileUpdateRequestDeferral,
updateLocalFile(value: Windows$Windows$Storage.IStorageFile): void
} 
	declare export class FileUpdateRequestDeferral mixins undefined.IFileUpdateRequestDeferral {
complete(): void
}
	declare export interface IFileUpdateRequestDeferral {
complete(): void
} 
	declare export  class FileUpdateStatus {
  constructor(...args: empty): mixed;
static +incomplete: Class<FileUpdateStatus__incomplete> & FileUpdateStatus__incomplete & 0;// 0
static +complete: Class<FileUpdateStatus__complete> & FileUpdateStatus__complete & 1;// 1
static +userInputNeeded: Class<FileUpdateStatus__userInputNeeded> & FileUpdateStatus__userInputNeeded & 2;// 2
static +currentlyUnavailable: Class<FileUpdateStatus__currentlyUnavailable> & FileUpdateStatus__currentlyUnavailable & 3;// 3
static +failed: Class<FileUpdateStatus__failed> & FileUpdateStatus__failed & 4;// 4
static +completeAndRenamed: Class<FileUpdateStatus__completeAndRenamed> & FileUpdateStatus__completeAndRenamed & 5;// 5

}

declare class FileUpdateStatus__incomplete mixins FileUpdateStatus {}
declare class FileUpdateStatus__complete mixins FileUpdateStatus {}
declare class FileUpdateStatus__userInputNeeded mixins FileUpdateStatus {}
declare class FileUpdateStatus__currentlyUnavailable mixins FileUpdateStatus {}
declare class FileUpdateStatus__failed mixins FileUpdateStatus {}
declare class FileUpdateStatus__completeAndRenamed mixins FileUpdateStatus {}

	declare export  class CachedFileOptions {
  constructor(...args: empty): mixed;
static +none: Class<CachedFileOptions__none> & CachedFileOptions__none & 0;// 0
static +requireUpdateOnAccess: Class<CachedFileOptions__requireUpdateOnAccess> & CachedFileOptions__requireUpdateOnAccess & 1;// 1
static +useCachedFileWhenOffline: Class<CachedFileOptions__useCachedFileWhenOffline> & CachedFileOptions__useCachedFileWhenOffline & 2;// 2
static +denyAccessWhenOffline: Class<CachedFileOptions__denyAccessWhenOffline> & CachedFileOptions__denyAccessWhenOffline & 3;// 3

}

declare class CachedFileOptions__none mixins CachedFileOptions {}
declare class CachedFileOptions__requireUpdateOnAccess mixins CachedFileOptions {}
declare class CachedFileOptions__useCachedFileWhenOffline mixins CachedFileOptions {}
declare class CachedFileOptions__denyAccessWhenOffline mixins CachedFileOptions {}

	declare export  class ReadActivationMode {
  constructor(...args: empty): mixed;
static +notNeeded: Class<ReadActivationMode__notNeeded> & ReadActivationMode__notNeeded & 0;// 0
static +beforeAccess: Class<ReadActivationMode__beforeAccess> & ReadActivationMode__beforeAccess & 1;// 1

}

declare class ReadActivationMode__notNeeded mixins ReadActivationMode {}
declare class ReadActivationMode__beforeAccess mixins ReadActivationMode {}

	declare export  class WriteActivationMode {
  constructor(...args: empty): mixed;
static +readOnly: Class<WriteActivationMode__readOnly> & WriteActivationMode__readOnly & 0;// 0
static +notNeeded: Class<WriteActivationMode__notNeeded> & WriteActivationMode__notNeeded & 1;// 1
static +afterWrite: Class<WriteActivationMode__afterWrite> & WriteActivationMode__afterWrite & 2;// 2

}

declare class WriteActivationMode__readOnly mixins WriteActivationMode {}
declare class WriteActivationMode__notNeeded mixins WriteActivationMode {}
declare class WriteActivationMode__afterWrite mixins WriteActivationMode {}

	declare export interface ICachedFileUpdaterStatics {
setUpdateInformation(
file: Windows$Windows$Storage.IStorageFile,
contentId: string,
readMode: Windows$Windows$Storage.Provider.ReadActivationMode,
writeMode: Windows$Windows$Storage.Provider.WriteActivationMode,
options: Windows$Windows$Storage.Provider.CachedFileOptions): void
} 
	declare export class CachedFileUpdater  {
static setUpdateInformation(
file: Windows$Windows$Storage.IStorageFile,
contentId: string,
readMode: Windows$Windows$Storage.Provider.ReadActivationMode,
writeMode: Windows$Windows$Storage.Provider.WriteActivationMode,
options: Windows$Windows$Storage.Provider.CachedFileOptions): void
}
    }

	declare module 'FileProperties' {
        declare export  class PropertyPrefetchOptions {
  constructor(...args: empty): mixed;
static +none: Class<PropertyPrefetchOptions__none> & PropertyPrefetchOptions__none & 0;// 0
static +musicProperties: Class<PropertyPrefetchOptions__musicProperties> & PropertyPrefetchOptions__musicProperties & 1;// 1
static +videoProperties: Class<PropertyPrefetchOptions__videoProperties> & PropertyPrefetchOptions__videoProperties & 2;// 2
static +imageProperties: Class<PropertyPrefetchOptions__imageProperties> & PropertyPrefetchOptions__imageProperties & 3;// 3
static +documentProperties: Class<PropertyPrefetchOptions__documentProperties> & PropertyPrefetchOptions__documentProperties & 4;// 4
static +basicProperties: Class<PropertyPrefetchOptions__basicProperties> & PropertyPrefetchOptions__basicProperties & 5;// 5

}

declare class PropertyPrefetchOptions__none mixins PropertyPrefetchOptions {}
declare class PropertyPrefetchOptions__musicProperties mixins PropertyPrefetchOptions {}
declare class PropertyPrefetchOptions__videoProperties mixins PropertyPrefetchOptions {}
declare class PropertyPrefetchOptions__imageProperties mixins PropertyPrefetchOptions {}
declare class PropertyPrefetchOptions__documentProperties mixins PropertyPrefetchOptions {}
declare class PropertyPrefetchOptions__basicProperties mixins PropertyPrefetchOptions {}

	declare export  class ThumbnailType {
  constructor(...args: empty): mixed;
static +image: Class<ThumbnailType__image> & ThumbnailType__image & 0;// 0
static +icon: Class<ThumbnailType__icon> & ThumbnailType__icon & 1;// 1

}

declare class ThumbnailType__image mixins ThumbnailType {}
declare class ThumbnailType__icon mixins ThumbnailType {}

	declare export interface IThumbnailProperties {
originalHeight: number,
originalWidth: number,
returnedSmallerCachedSize: boolean,
type: Windows$Windows$Storage.FileProperties.ThumbnailType
} 
	declare export class StorageItemThumbnail mixins undefined.IRandomAccessStreamWithContentType, undefined.IRandomAccessStream, undefined.IClosable, undefined.IInputStream, undefined.IOutputStream, undefined.IContentTypeProvider, undefined.IThumbnailProperties {
canRead: boolean;
canWrite: boolean;
position: number;
size: number;
contentType: string;
originalHeight: number;
originalWidth: number;
returnedSmallerCachedSize: boolean;
type: Windows$Windows$Storage.FileProperties.ThumbnailType;
getInputStreamAt(position: number): Windows$Windows$Storage.Streams.IInputStream;
getOutputStreamAt(position: number): Windows$Windows$Storage.Streams.IOutputStream;
seek(position: number): void;
cloneStream(): Windows$Windows$Storage.Streams.IRandomAccessStream;
dispose(): void;
readAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer,
count: number,
options: Windows$Windows$Storage.Streams.InputStreamOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Storage.Streams.IBuffer, number>;
writeAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
flushAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
close(): void
}
	declare export  class ThumbnailMode {
  constructor(...args: empty): mixed;
static +picturesView: Class<ThumbnailMode__picturesView> & ThumbnailMode__picturesView & 0;// 0
static +videosView: Class<ThumbnailMode__videosView> & ThumbnailMode__videosView & 1;// 1
static +musicView: Class<ThumbnailMode__musicView> & ThumbnailMode__musicView & 2;// 2
static +documentsView: Class<ThumbnailMode__documentsView> & ThumbnailMode__documentsView & 3;// 3
static +listView: Class<ThumbnailMode__listView> & ThumbnailMode__listView & 4;// 4
static +singleItem: Class<ThumbnailMode__singleItem> & ThumbnailMode__singleItem & 5;// 5

}

declare class ThumbnailMode__picturesView mixins ThumbnailMode {}
declare class ThumbnailMode__videosView mixins ThumbnailMode {}
declare class ThumbnailMode__musicView mixins ThumbnailMode {}
declare class ThumbnailMode__documentsView mixins ThumbnailMode {}
declare class ThumbnailMode__listView mixins ThumbnailMode {}
declare class ThumbnailMode__singleItem mixins ThumbnailMode {}

	declare export  class ThumbnailOptions {
  constructor(...args: empty): mixed;
static +none: Class<ThumbnailOptions__none> & ThumbnailOptions__none & 0;// 0
static +returnOnlyIfCached: Class<ThumbnailOptions__returnOnlyIfCached> & ThumbnailOptions__returnOnlyIfCached & 1;// 1
static +resizeThumbnail: Class<ThumbnailOptions__resizeThumbnail> & ThumbnailOptions__resizeThumbnail & 2;// 2
static +useCurrentScale: Class<ThumbnailOptions__useCurrentScale> & ThumbnailOptions__useCurrentScale & 3;// 3

}

declare class ThumbnailOptions__none mixins ThumbnailOptions {}
declare class ThumbnailOptions__returnOnlyIfCached mixins ThumbnailOptions {}
declare class ThumbnailOptions__resizeThumbnail mixins ThumbnailOptions {}
declare class ThumbnailOptions__useCurrentScale mixins ThumbnailOptions {}

	declare export  class PhotoOrientation {
  constructor(...args: empty): mixed;
static +unspecified: Class<PhotoOrientation__unspecified> & PhotoOrientation__unspecified & 0;// 0
static +normal: Class<PhotoOrientation__normal> & PhotoOrientation__normal & 1;// 1
static +flipHorizontal: Class<PhotoOrientation__flipHorizontal> & PhotoOrientation__flipHorizontal & 2;// 2
static +rotate180: Class<PhotoOrientation__rotate180> & PhotoOrientation__rotate180 & 3;// 3
static +flipVertical: Class<PhotoOrientation__flipVertical> & PhotoOrientation__flipVertical & 4;// 4
static +transpose: Class<PhotoOrientation__transpose> & PhotoOrientation__transpose & 5;// 5
static +rotate270: Class<PhotoOrientation__rotate270> & PhotoOrientation__rotate270 & 6;// 6
static +transverse: Class<PhotoOrientation__transverse> & PhotoOrientation__transverse & 7;// 7
static +rotate90: Class<PhotoOrientation__rotate90> & PhotoOrientation__rotate90 & 8;// 8

}

declare class PhotoOrientation__unspecified mixins PhotoOrientation {}
declare class PhotoOrientation__normal mixins PhotoOrientation {}
declare class PhotoOrientation__flipHorizontal mixins PhotoOrientation {}
declare class PhotoOrientation__rotate180 mixins PhotoOrientation {}
declare class PhotoOrientation__flipVertical mixins PhotoOrientation {}
declare class PhotoOrientation__transpose mixins PhotoOrientation {}
declare class PhotoOrientation__rotate270 mixins PhotoOrientation {}
declare class PhotoOrientation__transverse mixins PhotoOrientation {}
declare class PhotoOrientation__rotate90 mixins PhotoOrientation {}

	declare export  class VideoOrientation {
  constructor(...args: empty): mixed;
static +normal: Class<VideoOrientation__normal> & VideoOrientation__normal & 0;// 0
static +rotate90: Class<VideoOrientation__rotate90> & VideoOrientation__rotate90 & 1;// 1
static +rotate180: Class<VideoOrientation__rotate180> & VideoOrientation__rotate180 & 2;// 2
static +rotate270: Class<VideoOrientation__rotate270> & VideoOrientation__rotate270 & 3;// 3

}

declare class VideoOrientation__normal mixins VideoOrientation {}
declare class VideoOrientation__rotate90 mixins VideoOrientation {}
declare class VideoOrientation__rotate180 mixins VideoOrientation {}
declare class VideoOrientation__rotate270 mixins VideoOrientation {}

	declare export interface IStorageItemExtraProperties {
retrievePropertiesAsync(
propertiesToRetrieve: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IMap<string, any>>,
savePropertiesAsync(
propertiesToSave: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>): Windows$Windows$Foundation.IAsyncAction,
savePropertiesAsync(): Windows$Windows$Foundation.IAsyncAction
} 
	declare export type IStorageItemContentProperties = {
getMusicPropertiesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.MusicProperties>,
getVideoPropertiesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.VideoProperties>,
getImagePropertiesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.ImageProperties>,
getDocumentPropertiesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.DocumentProperties>
} & undefined.IStorageItemExtraProperties

	declare export class MusicProperties mixins undefined.IMusicProperties, undefined.IStorageItemExtraProperties {
album: string;
albumArtist: string;
artist: string;
bitrate: number;
composers: Windows$Windows$Foundation.Collections.IVector<string>;
conductors: Windows$Windows$Foundation.Collections.IVector<string>;
duration: number;
genre: Windows$Windows$Foundation.Collections.IVector<string>;
producers: Windows$Windows$Foundation.Collections.IVector<string>;
publisher: string;
rating: number;
subtitle: string;
title: string;
trackNumber: number;
writers: Windows$Windows$Foundation.Collections.IVector<string>;
year: number;
retrievePropertiesAsync(
propertiesToRetrieve: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IMap<string, any>>;
savePropertiesAsync(
propertiesToSave: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>): Windows$Windows$Foundation.IAsyncAction;
savePropertiesAsync(): Windows$Windows$Foundation.IAsyncAction
}
	declare export class VideoProperties mixins undefined.IVideoProperties, undefined.IStorageItemExtraProperties {
bitrate: number;
directors: Windows$Windows$Foundation.Collections.IVector<string>;
duration: number;
height: number;
keywords: Windows$Windows$Foundation.Collections.IVector<string>;
latitude: number;
longitude: number;
orientation: Windows$Windows$Storage.FileProperties.VideoOrientation;
producers: Windows$Windows$Foundation.Collections.IVector<string>;
publisher: string;
rating: number;
subtitle: string;
title: string;
width: number;
writers: Windows$Windows$Foundation.Collections.IVector<string>;
year: number;
retrievePropertiesAsync(
propertiesToRetrieve: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IMap<string, any>>;
savePropertiesAsync(
propertiesToSave: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>): Windows$Windows$Foundation.IAsyncAction;
savePropertiesAsync(): Windows$Windows$Foundation.IAsyncAction
}
	declare export class ImageProperties mixins undefined.IImageProperties, undefined.IStorageItemExtraProperties {
cameraManufacturer: string;
cameraModel: string;
dateTaken: Date;
height: number;
keywords: Windows$Windows$Foundation.Collections.IVector<string>;
latitude: number;
longitude: number;
orientation: Windows$Windows$Storage.FileProperties.PhotoOrientation;
peopleNames: Windows$Windows$Foundation.Collections.IVectorView<string>;
rating: number;
title: string;
width: number;
retrievePropertiesAsync(
propertiesToRetrieve: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IMap<string, any>>;
savePropertiesAsync(
propertiesToSave: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>): Windows$Windows$Foundation.IAsyncAction;
savePropertiesAsync(): Windows$Windows$Foundation.IAsyncAction
}
	declare export class DocumentProperties mixins undefined.IDocumentProperties, undefined.IStorageItemExtraProperties {
author: Windows$Windows$Foundation.Collections.IVector<string>;
comment: string;
keywords: Windows$Windows$Foundation.Collections.IVector<string>;
title: string;
retrievePropertiesAsync(
propertiesToRetrieve: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IMap<string, any>>;
savePropertiesAsync(
propertiesToSave: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>): Windows$Windows$Foundation.IAsyncAction;
savePropertiesAsync(): Windows$Windows$Foundation.IAsyncAction
}
	declare export type IMusicProperties = {
album: string,
albumArtist: string,
artist: string,
bitrate: number,
composers: Windows$Windows$Foundation.Collections.IVector<string>,
conductors: Windows$Windows$Foundation.Collections.IVector<string>,
duration: number,
genre: Windows$Windows$Foundation.Collections.IVector<string>,
producers: Windows$Windows$Foundation.Collections.IVector<string>,
publisher: string,
rating: number,
subtitle: string,
title: string,
trackNumber: number,
writers: Windows$Windows$Foundation.Collections.IVector<string>,
year: number
} & undefined.IStorageItemExtraProperties

	declare export type IImageProperties = {
cameraManufacturer: string,
cameraModel: string,
dateTaken: Date,
height: number,
keywords: Windows$Windows$Foundation.Collections.IVector<string>,
latitude: number,
longitude: number,
orientation: Windows$Windows$Storage.FileProperties.PhotoOrientation,
peopleNames: Windows$Windows$Foundation.Collections.IVectorView<string>,
rating: number,
title: string,
width: number
} & undefined.IStorageItemExtraProperties

	declare export type IVideoProperties = {
bitrate: number,
directors: Windows$Windows$Foundation.Collections.IVector<string>,
duration: number,
height: number,
keywords: Windows$Windows$Foundation.Collections.IVector<string>,
latitude: number,
longitude: number,
orientation: Windows$Windows$Storage.FileProperties.VideoOrientation,
producers: Windows$Windows$Foundation.Collections.IVector<string>,
publisher: string,
rating: number,
subtitle: string,
title: string,
width: number,
writers: Windows$Windows$Foundation.Collections.IVector<string>,
year: number
} & undefined.IStorageItemExtraProperties

	declare export type IDocumentProperties = {
author: Windows$Windows$Foundation.Collections.IVector<string>,
comment: string,
keywords: Windows$Windows$Foundation.Collections.IVector<string>,
title: string
} & undefined.IStorageItemExtraProperties

	declare export interface IBasicProperties {
dateModified: Date,
itemDate: Date,
size: number
} 
	declare export class StorageItemContentProperties mixins undefined.IStorageItemContentProperties, undefined.IStorageItemExtraProperties {
getMusicPropertiesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.MusicProperties>;
getVideoPropertiesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.VideoProperties>;
getImagePropertiesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.ImageProperties>;
getDocumentPropertiesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.DocumentProperties>;
retrievePropertiesAsync(
propertiesToRetrieve: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IMap<string, any>>;
savePropertiesAsync(
propertiesToSave: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>): Windows$Windows$Foundation.IAsyncAction;
savePropertiesAsync(): Windows$Windows$Foundation.IAsyncAction
}
	declare export class BasicProperties mixins undefined.IBasicProperties, undefined.IStorageItemExtraProperties {
dateModified: Date;
itemDate: Date;
size: number;
retrievePropertiesAsync(
propertiesToRetrieve: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IMap<string, any>>;
savePropertiesAsync(
propertiesToSave: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>): Windows$Windows$Foundation.IAsyncAction;
savePropertiesAsync(): Windows$Windows$Foundation.IAsyncAction
}
    }

	declare export interface IKnownFoldersStatics {
documentsLibrary: Windows$Windows$Storage.StorageFolder,
homeGroup: Windows$Windows$Storage.StorageFolder,
mediaServerDevices: Windows$Windows$Storage.StorageFolder,
musicLibrary: Windows$Windows$Storage.StorageFolder,
picturesLibrary: Windows$Windows$Storage.StorageFolder,
removableDevices: Windows$Windows$Storage.StorageFolder,
videosLibrary: Windows$Windows$Storage.StorageFolder
} 
	declare export class StorageFolder mixins undefined.IStorageFolder, undefined.IStorageFolder2, undefined.IStorageItem, undefined.IStorageFolderQueryOperations, undefined.IStorageItemProperties {
attributes: Windows$Windows$Storage.FileAttributes;
dateCreated: Date;
name: string;
path: string;
displayName: string;
displayType: string;
folderRelativeId: string;
properties: Windows$Windows$Storage.FileProperties.StorageItemContentProperties;
createFileAsync(
desiredName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
createFileAsync(
desiredName: string,
options: Windows$Windows$Storage.CreationCollisionOption): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
createFolderAsync(
desiredName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>;
createFolderAsync(
desiredName: string,
options: Windows$Windows$Storage.CreationCollisionOption): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>;
getFileAsync(
name: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
getFolderAsync(
name: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>;
getItemAsync(
name: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.IStorageItem>;
getFilesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>;
getFoldersAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>;
getItemsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>;
renameAsync(desiredName: string): Windows$Windows$Foundation.IAsyncAction;
renameAsync(
desiredName: string,
option: Windows$Windows$Storage.NameCollisionOption): Windows$Windows$Foundation.IAsyncAction;
deleteAsync(): Windows$Windows$Foundation.IAsyncAction;
deleteAsync(
option: Windows$Windows$Storage.StorageDeleteOption): Windows$Windows$Foundation.IAsyncAction;
getBasicPropertiesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.BasicProperties>;
isOfType(type: Windows$Windows$Storage.StorageItemTypes): boolean;
getIndexedStateAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Search.IndexedState>;
createFileQuery(): Windows$Windows$Storage.Search.StorageFileQueryResult;
createFileQuery(
query: Windows$Windows$Storage.Search.CommonFileQuery): Windows$Windows$Storage.Search.StorageFileQueryResult;
createFileQueryWithOptions(
queryOptions: Windows$Windows$Storage.Search.QueryOptions): Windows$Windows$Storage.Search.StorageFileQueryResult;
createFolderQuery(): Windows$Windows$Storage.Search.StorageFolderQueryResult;
createFolderQuery(
query: Windows$Windows$Storage.Search.CommonFolderQuery): Windows$Windows$Storage.Search.StorageFolderQueryResult;
createFolderQueryWithOptions(
queryOptions: Windows$Windows$Storage.Search.QueryOptions): Windows$Windows$Storage.Search.StorageFolderQueryResult;
createItemQuery(): Windows$Windows$Storage.Search.StorageItemQueryResult;
createItemQueryWithOptions(
queryOptions: Windows$Windows$Storage.Search.QueryOptions): Windows$Windows$Storage.Search.StorageItemQueryResult;
getFilesAsync(
query: Windows$Windows$Storage.Search.CommonFileQuery,
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>;
getFilesAsync(
query: Windows$Windows$Storage.Search.CommonFileQuery): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>;
getFoldersAsync(
query: Windows$Windows$Storage.Search.CommonFolderQuery,
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>;
getFoldersAsync(
query: Windows$Windows$Storage.Search.CommonFolderQuery): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>;
getItemsAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>;
areQueryOptionsSupported(queryOptions: Windows$Windows$Storage.Search.QueryOptions): boolean;
isCommonFolderQuerySupported(query: Windows$Windows$Storage.Search.CommonFolderQuery): boolean;
isCommonFileQuerySupported(query: Windows$Windows$Storage.Search.CommonFileQuery): boolean;
getThumbnailAsync(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.StorageItemThumbnail>;
getThumbnailAsync(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedSize: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.StorageItemThumbnail>;
getThumbnailAsync(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedSize: number,
options: Windows$Windows$Storage.FileProperties.ThumbnailOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.StorageItemThumbnail>;
static getFolderFromPathAsync(
path: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>;
tryGetItemAsync(name: string): Windows$Windows$Foundation.IAsyncOperation<IStorageItem>
}
	declare export class KnownFolders  {
static documentsLibrary: Windows$Windows$Storage.StorageFolder;
static homeGroup: Windows$Windows$Storage.StorageFolder;
static mediaServerDevices: Windows$Windows$Storage.StorageFolder;
static musicLibrary: Windows$Windows$Storage.StorageFolder;
static picturesLibrary: Windows$Windows$Storage.StorageFolder;
static removableDevices: Windows$Windows$Storage.StorageFolder;
static videosLibrary: Windows$Windows$Storage.StorageFolder
}
	declare export  class CreationCollisionOption {
  constructor(...args: empty): mixed;
static +generateUniqueName: Class<CreationCollisionOption__generateUniqueName> & CreationCollisionOption__generateUniqueName & 0;// 0
static +replaceExisting: Class<CreationCollisionOption__replaceExisting> & CreationCollisionOption__replaceExisting & 1;// 1
static +failIfExists: Class<CreationCollisionOption__failIfExists> & CreationCollisionOption__failIfExists & 2;// 2
static +openIfExists: Class<CreationCollisionOption__openIfExists> & CreationCollisionOption__openIfExists & 3;// 3

}

declare class CreationCollisionOption__generateUniqueName mixins CreationCollisionOption {}
declare class CreationCollisionOption__replaceExisting mixins CreationCollisionOption {}
declare class CreationCollisionOption__failIfExists mixins CreationCollisionOption {}
declare class CreationCollisionOption__openIfExists mixins CreationCollisionOption {}

	declare export interface IDownloadsFolderStatics {
createFileAsync(
desiredName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
createFolderAsync(
desiredName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>,
createFileAsync(
desiredName: string,
option: Windows$Windows$Storage.CreationCollisionOption): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
createFolderAsync(
desiredName: string,
option: Windows$Windows$Storage.CreationCollisionOption): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>
} 
	declare export class StorageFile mixins undefined.IStorageFile, undefined.IStorageItem, undefined.IRandomAccessStreamReference, undefined.IInputStreamReference, undefined.IStorageItemProperties {
contentType: string;
fileType: string;
attributes: Windows$Windows$Storage.FileAttributes;
dateCreated: Date;
name: string;
path: string;
displayName: string;
displayType: string;
folderRelativeId: string;
properties: Windows$Windows$Storage.FileProperties.StorageItemContentProperties;
openAsync(
accessMode: Windows$Windows$Storage.FileAccessMode): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IRandomAccessStream>;
openTransactedWriteAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageStreamTransaction>;
copyAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
copyAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder,
desiredNewName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
copyAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder,
desiredNewName: string,
option: Windows$Windows$Storage.NameCollisionOption): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
copyAndReplaceAsync(
fileToReplace: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncAction;
moveAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder): Windows$Windows$Foundation.IAsyncAction;
moveAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder,
desiredNewName: string): Windows$Windows$Foundation.IAsyncAction;
moveAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder,
desiredNewName: string,
option: Windows$Windows$Storage.NameCollisionOption): Windows$Windows$Foundation.IAsyncAction;
moveAndReplaceAsync(
fileToReplace: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncAction;
renameAsync(desiredName: string): Windows$Windows$Foundation.IAsyncAction;
renameAsync(
desiredName: string,
option: Windows$Windows$Storage.NameCollisionOption): Windows$Windows$Foundation.IAsyncAction;
deleteAsync(): Windows$Windows$Foundation.IAsyncAction;
deleteAsync(
option: Windows$Windows$Storage.StorageDeleteOption): Windows$Windows$Foundation.IAsyncAction;
getBasicPropertiesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.BasicProperties>;
isOfType(type: Windows$Windows$Storage.StorageItemTypes): boolean;
openReadAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IRandomAccessStreamWithContentType>;
openSequentialReadAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IInputStream>;
getThumbnailAsync(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.StorageItemThumbnail>;
getThumbnailAsync(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedSize: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.StorageItemThumbnail>;
getThumbnailAsync(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedSize: number,
options: Windows$Windows$Storage.FileProperties.ThumbnailOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.StorageItemThumbnail>;
static getFileFromPathAsync(
path: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
static getFileFromApplicationUriAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
static createStreamedFileAsync(
displayNameWithExtension: string,
dataRequested: Windows$Windows$Storage.StreamedFileDataRequestedHandler,
thumbnail: Windows$Windows$Storage.Streams.IRandomAccessStreamReference): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
static replaceWithStreamedFileAsync(
fileToReplace: Windows$Windows$Storage.IStorageFile,
dataRequested: Windows$Windows$Storage.StreamedFileDataRequestedHandler,
thumbnail: Windows$Windows$Storage.Streams.IRandomAccessStreamReference): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
static createStreamedFileFromUriAsync(
displayNameWithExtension: string,
uri: Windows$Windows$Foundation.Uri,
thumbnail: Windows$Windows$Storage.Streams.IRandomAccessStreamReference): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
static replaceWithStreamedFileFromUriAsync(
fileToReplace: Windows$Windows$Storage.IStorageFile,
uri: Windows$Windows$Foundation.Uri,
thumbnail: Windows$Windows$Storage.Streams.IRandomAccessStreamReference): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>
}
	declare export class DownloadsFolder  {
static createFileAsync(
desiredName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
static createFolderAsync(
desiredName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>;
static createFileAsync(
desiredName: string,
option: Windows$Windows$Storage.CreationCollisionOption): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
static createFolderAsync(
desiredName: string,
option: Windows$Windows$Storage.CreationCollisionOption): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>
}
	declare export  class NameCollisionOption {
  constructor(...args: empty): mixed;
static +generateUniqueName: Class<NameCollisionOption__generateUniqueName> & NameCollisionOption__generateUniqueName & 0;// 0
static +replaceExisting: Class<NameCollisionOption__replaceExisting> & NameCollisionOption__replaceExisting & 1;// 1
static +failIfExists: Class<NameCollisionOption__failIfExists> & NameCollisionOption__failIfExists & 2;// 2

}

declare class NameCollisionOption__generateUniqueName mixins NameCollisionOption {}
declare class NameCollisionOption__replaceExisting mixins NameCollisionOption {}
declare class NameCollisionOption__failIfExists mixins NameCollisionOption {}

	declare export  class StorageDeleteOption {
  constructor(...args: empty): mixed;
static +default: Class<StorageDeleteOption__default> & StorageDeleteOption__default & 0;// 0
static +permanentDelete: Class<StorageDeleteOption__permanentDelete> & StorageDeleteOption__permanentDelete & 1;// 1

}

declare class StorageDeleteOption__default mixins StorageDeleteOption {}
declare class StorageDeleteOption__permanentDelete mixins StorageDeleteOption {}

	declare export  class StorageItemTypes {
  constructor(...args: empty): mixed;
static +none: Class<StorageItemTypes__none> & StorageItemTypes__none & 0;// 0
static +file: Class<StorageItemTypes__file> & StorageItemTypes__file & 1;// 1
static +folder: Class<StorageItemTypes__folder> & StorageItemTypes__folder & 2;// 2

}

declare class StorageItemTypes__none mixins StorageItemTypes {}
declare class StorageItemTypes__file mixins StorageItemTypes {}
declare class StorageItemTypes__folder mixins StorageItemTypes {}

	declare export  class FileAttributes {
  constructor(...args: empty): mixed;
static +normal: Class<FileAttributes__normal> & FileAttributes__normal & 0;// 0
static +readOnly: Class<FileAttributes__readOnly> & FileAttributes__readOnly & 1;// 1
static +directory: Class<FileAttributes__directory> & FileAttributes__directory & 2;// 2
static +archive: Class<FileAttributes__archive> & FileAttributes__archive & 3;// 3
static +temporary: Class<FileAttributes__temporary> & FileAttributes__temporary & 4;// 4

}

declare class FileAttributes__normal mixins FileAttributes {}
declare class FileAttributes__readOnly mixins FileAttributes {}
declare class FileAttributes__directory mixins FileAttributes {}
declare class FileAttributes__archive mixins FileAttributes {}
declare class FileAttributes__temporary mixins FileAttributes {}

	declare export  class FileAccessMode {
  constructor(...args: empty): mixed;
static +read: Class<FileAccessMode__read> & FileAccessMode__read & 0;// 0
static +readWrite: Class<FileAccessMode__readWrite> & FileAccessMode__readWrite & 1;// 1

}

declare class FileAccessMode__read mixins FileAccessMode {}
declare class FileAccessMode__readWrite mixins FileAccessMode {}

	declare export  class StreamedFileFailureMode {
  constructor(...args: empty): mixed;
static +failed: Class<StreamedFileFailureMode__failed> & StreamedFileFailureMode__failed & 0;// 0
static +currentlyUnavailable: Class<StreamedFileFailureMode__currentlyUnavailable> & StreamedFileFailureMode__currentlyUnavailable & 1;// 1
static +incomplete: Class<StreamedFileFailureMode__incomplete> & StreamedFileFailureMode__incomplete & 2;// 2

}

declare class StreamedFileFailureMode__failed mixins StreamedFileFailureMode {}
declare class StreamedFileFailureMode__currentlyUnavailable mixins StreamedFileFailureMode {}
declare class StreamedFileFailureMode__incomplete mixins StreamedFileFailureMode {}

	declare export interface IStreamedFileDataRequest {
failAndClose(failureMode: Windows$Windows$Storage.StreamedFileFailureMode): void
} 
	declare export class StreamedFileDataRequest mixins undefined.IOutputStream, undefined.IClosable, undefined.IStreamedFileDataRequest {
writeAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
flushAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
dispose(): void;
failAndClose(failureMode: Windows$Windows$Storage.StreamedFileFailureMode): void;
close(): void
}
	declare export interface StreamedFileDataRequestedHandler {
(stream: Windows$Windows$Storage.StreamedFileDataRequest): void
} 
	declare export interface IStorageFileStatics {
getFileFromPathAsync(
path: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
getFileFromApplicationUriAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
createStreamedFileAsync(
displayNameWithExtension: string,
dataRequested: Windows$Windows$Storage.StreamedFileDataRequestedHandler,
thumbnail: Windows$Windows$Storage.Streams.IRandomAccessStreamReference): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
replaceWithStreamedFileAsync(
fileToReplace: Windows$Windows$Storage.IStorageFile,
dataRequested: Windows$Windows$Storage.StreamedFileDataRequestedHandler,
thumbnail: Windows$Windows$Storage.Streams.IRandomAccessStreamReference): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
createStreamedFileFromUriAsync(
displayNameWithExtension: string,
uri: Windows$Windows$Foundation.Uri,
thumbnail: Windows$Windows$Storage.Streams.IRandomAccessStreamReference): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
replaceWithStreamedFileFromUriAsync(
fileToReplace: Windows$Windows$Storage.IStorageFile,
uri: Windows$Windows$Foundation.Uri,
thumbnail: Windows$Windows$Storage.Streams.IRandomAccessStreamReference): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>
} 
	declare export class StorageStreamTransaction mixins undefined.IStorageStreamTransaction, undefined.IClosable {
stream: Windows$Windows$Storage.Streams.IRandomAccessStream;
commitAsync(): Windows$Windows$Foundation.IAsyncAction;
dispose(): void;
close(): void
}
	declare export interface IStorageItem {
attributes: Windows$Windows$Storage.FileAttributes,
dateCreated: Date,
name: string,
path: string,
renameAsync(desiredName: string): Windows$Windows$Foundation.IAsyncAction,
renameAsync(
desiredName: string,
option: Windows$Windows$Storage.NameCollisionOption): Windows$Windows$Foundation.IAsyncAction,
deleteAsync(): Windows$Windows$Foundation.IAsyncAction,
deleteAsync(
option: Windows$Windows$Storage.StorageDeleteOption): Windows$Windows$Foundation.IAsyncAction,
getBasicPropertiesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.BasicProperties>,
isOfType(type: Windows$Windows$Storage.StorageItemTypes): boolean
} 
	declare export type IStorageFolder = {
createFileAsync(
desiredName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
createFileAsync(
desiredName: string,
options: Windows$Windows$Storage.CreationCollisionOption): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
createFolderAsync(
desiredName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>,
createFolderAsync(
desiredName: string,
options: Windows$Windows$Storage.CreationCollisionOption): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>,
getFileAsync(
name: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
getFolderAsync(
name: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>,
getItemAsync(
name: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.IStorageItem>,
getFilesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>,
getFoldersAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>,
getItemsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>,
getItemsAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>
} & undefined.IStorageItem

	declare export interface IStorageFolder2 {
tryGetItemAsync(name: string): Windows$Windows$Foundation.IAsyncOperation<IStorageItem>
} 
	declare export type IStorageFile = {
contentType: string,
fileType: string,
openAsync(
accessMode: Windows$Windows$Storage.FileAccessMode): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IRandomAccessStream>,
openTransactedWriteAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageStreamTransaction>,
copyAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
copyAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder,
desiredNewName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
copyAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder,
desiredNewName: string,
option: Windows$Windows$Storage.NameCollisionOption): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
copyAndReplaceAsync(
fileToReplace: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncAction,
moveAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder): Windows$Windows$Foundation.IAsyncAction,
moveAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder,
desiredNewName: string): Windows$Windows$Foundation.IAsyncAction,
moveAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder,
desiredNewName: string,
option: Windows$Windows$Storage.NameCollisionOption): Windows$Windows$Foundation.IAsyncAction,
moveAndReplaceAsync(
fileToReplace: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncAction
} & undefined.IStorageItem & undefined.IRandomAccessStreamReference & undefined.IInputStreamReference

	declare export interface IStorageFolderStatics {
getFolderFromPathAsync(
path: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>
} 
	declare export interface IStorageItemProperties {
displayName: string,
displayType: string,
folderRelativeId: string,
properties: Windows$Windows$Storage.FileProperties.StorageItemContentProperties,
getThumbnailAsync(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.StorageItemThumbnail>,
getThumbnailAsync(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedSize: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.StorageItemThumbnail>,
getThumbnailAsync(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedSize: number,
options: Windows$Windows$Storage.FileProperties.ThumbnailOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.StorageItemThumbnail>
} 
	declare export interface IFileIOStatics {
readTextAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<string>,
readTextAsync(
file: Windows$Windows$Storage.IStorageFile,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncOperation<string>,
writeTextAsync(
file: Windows$Windows$Storage.IStorageFile,
contents: string): Windows$Windows$Foundation.IAsyncAction,
writeTextAsync(
file: Windows$Windows$Storage.IStorageFile,
contents: string,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction,
appendTextAsync(
file: Windows$Windows$Storage.IStorageFile,
contents: string): Windows$Windows$Foundation.IAsyncAction,
appendTextAsync(
file: Windows$Windows$Storage.IStorageFile,
contents: string,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction,
readLinesAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVector<string>>,
readLinesAsync(
file: Windows$Windows$Storage.IStorageFile,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVector<string>>,
writeLinesAsync(
file: Windows$Windows$Storage.IStorageFile,
lines: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncAction,
writeLinesAsync(
file: Windows$Windows$Storage.IStorageFile,
lines: Windows$Windows$Foundation.Collections.IIterable<string>,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction,
appendLinesAsync(
file: Windows$Windows$Storage.IStorageFile,
lines: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncAction,
appendLinesAsync(
file: Windows$Windows$Storage.IStorageFile,
lines: Windows$Windows$Foundation.Collections.IIterable<string>,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction,
readBufferAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IBuffer>,
writeBufferAsync(
file: Windows$Windows$Storage.IStorageFile,
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncAction,
writeBytesAsync(
file: Windows$Windows$Storage.IStorageFile,
buffer: Uint8Array): Windows$Windows$Foundation.IAsyncAction
} 
	declare export class FileIO  {
static readTextAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<string>;
static readTextAsync(
file: Windows$Windows$Storage.IStorageFile,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncOperation<string>;
static writeTextAsync(
file: Windows$Windows$Storage.IStorageFile,
contents: string): Windows$Windows$Foundation.IAsyncAction;
static writeTextAsync(
file: Windows$Windows$Storage.IStorageFile,
contents: string,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction;
static appendTextAsync(
file: Windows$Windows$Storage.IStorageFile,
contents: string): Windows$Windows$Foundation.IAsyncAction;
static appendTextAsync(
file: Windows$Windows$Storage.IStorageFile,
contents: string,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction;
static readLinesAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVector<string>>;
static readLinesAsync(
file: Windows$Windows$Storage.IStorageFile,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVector<string>>;
static writeLinesAsync(
file: Windows$Windows$Storage.IStorageFile,
lines: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncAction;
static writeLinesAsync(
file: Windows$Windows$Storage.IStorageFile,
lines: Windows$Windows$Foundation.Collections.IIterable<string>,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction;
static appendLinesAsync(
file: Windows$Windows$Storage.IStorageFile,
lines: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncAction;
static appendLinesAsync(
file: Windows$Windows$Storage.IStorageFile,
lines: Windows$Windows$Foundation.Collections.IIterable<string>,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction;
static readBufferAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IBuffer>;
static writeBufferAsync(
file: Windows$Windows$Storage.IStorageFile,
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncAction;
static writeBytesAsync(
file: Windows$Windows$Storage.IStorageFile,
buffer: Uint8Array): Windows$Windows$Foundation.IAsyncAction
}
	declare export interface IPathIOStatics {
readTextAsync(absolutePath: string): Windows$Windows$Foundation.IAsyncOperation<string>,
readTextAsync(
absolutePath: string,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncOperation<string>,
writeTextAsync(
absolutePath: string,
contents: string): Windows$Windows$Foundation.IAsyncAction,
writeTextAsync(
absolutePath: string,
contents: string,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction,
appendTextAsync(
absolutePath: string,
contents: string): Windows$Windows$Foundation.IAsyncAction,
appendTextAsync(
absolutePath: string,
contents: string,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction,
readLinesAsync(
absolutePath: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVector<string>>,
readLinesAsync(
absolutePath: string,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVector<string>>,
writeLinesAsync(
absolutePath: string,
lines: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncAction,
writeLinesAsync(
absolutePath: string,
lines: Windows$Windows$Foundation.Collections.IIterable<string>,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction,
appendLinesAsync(
absolutePath: string,
lines: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncAction,
appendLinesAsync(
absolutePath: string,
lines: Windows$Windows$Foundation.Collections.IIterable<string>,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction,
readBufferAsync(
absolutePath: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IBuffer>,
writeBufferAsync(
absolutePath: string,
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncAction,
writeBytesAsync(
absolutePath: string,
buffer: Uint8Array): Windows$Windows$Foundation.IAsyncAction
} 
	declare export class PathIO  {
static readTextAsync(absolutePath: string): Windows$Windows$Foundation.IAsyncOperation<string>;
static readTextAsync(
absolutePath: string,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncOperation<string>;
static writeTextAsync(
absolutePath: string,
contents: string): Windows$Windows$Foundation.IAsyncAction;
static writeTextAsync(
absolutePath: string,
contents: string,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction;
static appendTextAsync(
absolutePath: string,
contents: string): Windows$Windows$Foundation.IAsyncAction;
static appendTextAsync(
absolutePath: string,
contents: string,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction;
static readLinesAsync(
absolutePath: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVector<string>>;
static readLinesAsync(
absolutePath: string,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVector<string>>;
static writeLinesAsync(
absolutePath: string,
lines: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncAction;
static writeLinesAsync(
absolutePath: string,
lines: Windows$Windows$Foundation.Collections.IIterable<string>,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction;
static appendLinesAsync(
absolutePath: string,
lines: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Foundation.IAsyncAction;
static appendLinesAsync(
absolutePath: string,
lines: Windows$Windows$Foundation.Collections.IIterable<string>,
encoding: Windows$Windows$Storage.Streams.UnicodeEncoding): Windows$Windows$Foundation.IAsyncAction;
static readBufferAsync(
absolutePath: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IBuffer>;
static writeBufferAsync(
absolutePath: string,
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncAction;
static writeBytesAsync(
absolutePath: string,
buffer: Uint8Array): Windows$Windows$Foundation.IAsyncAction
}
	declare export interface ICachedFileManagerStatics {
deferUpdates(file: Windows$Windows$Storage.IStorageFile): void,
completeUpdatesAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Provider.FileUpdateStatus>
} 
	declare export class CachedFileManager  {
static deferUpdates(file: Windows$Windows$Storage.IStorageFile): void;
static completeUpdatesAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Provider.FileUpdateStatus>
}
	declare export type IStorageStreamTransaction = {
stream: Windows$Windows$Storage.Streams.IRandomAccessStream,
commitAsync(): Windows$Windows$Foundation.IAsyncAction
} & undefined.IClosable

	declare export  class ApplicationDataLocality {
  constructor(...args: empty): mixed;
static +local: Class<ApplicationDataLocality__local> & ApplicationDataLocality__local & 0;// 0
static +roaming: Class<ApplicationDataLocality__roaming> & ApplicationDataLocality__roaming & 1;// 1
static +temporary: Class<ApplicationDataLocality__temporary> & ApplicationDataLocality__temporary & 2;// 2

}

declare class ApplicationDataLocality__local mixins ApplicationDataLocality {}
declare class ApplicationDataLocality__roaming mixins ApplicationDataLocality {}
declare class ApplicationDataLocality__temporary mixins ApplicationDataLocality {}

	declare export  class ApplicationDataCreateDisposition {
  constructor(...args: empty): mixed;
static +always: Class<ApplicationDataCreateDisposition__always> & ApplicationDataCreateDisposition__always & 0;// 0
static +existing: Class<ApplicationDataCreateDisposition__existing> & ApplicationDataCreateDisposition__existing & 1;// 1

}

declare class ApplicationDataCreateDisposition__always mixins ApplicationDataCreateDisposition {}
declare class ApplicationDataCreateDisposition__existing mixins ApplicationDataCreateDisposition {}

	declare export interface IApplicationDataStatics {
current: Windows$Windows$Storage.ApplicationData
} 
	declare export class ApplicationData mixins undefined.IApplicationData {
localFolder: Windows$Windows$Storage.StorageFolder;
localSettings: Windows$Windows$Storage.ApplicationDataContainer;
roamingFolder: Windows$Windows$Storage.StorageFolder;
roamingSettings: Windows$Windows$Storage.ApplicationDataContainer;
roamingStorageQuota: number;
temporaryFolder: Windows$Windows$Storage.StorageFolder;
version: number;
setVersionAsync(
desiredVersion: number,
handler: Windows$Windows$Storage.ApplicationDataSetVersionHandler): Windows$Windows$Foundation.IAsyncAction;
clearAsync(): Windows$Windows$Foundation.IAsyncAction;
clearAsync(
locality: Windows$Windows$Storage.ApplicationDataLocality): Windows$Windows$Foundation.IAsyncAction;
ondatachanged: any;
signalDataChanged(): void;
static current: Windows$Windows$Storage.ApplicationData
}
	declare export interface IApplicationData {
localFolder: Windows$Windows$Storage.StorageFolder,
localSettings: Windows$Windows$Storage.ApplicationDataContainer,
roamingFolder: Windows$Windows$Storage.StorageFolder,
roamingSettings: Windows$Windows$Storage.ApplicationDataContainer,
roamingStorageQuota: number,
temporaryFolder: Windows$Windows$Storage.StorageFolder,
version: number,
setVersionAsync(
desiredVersion: number,
handler: Windows$Windows$Storage.ApplicationDataSetVersionHandler): Windows$Windows$Foundation.IAsyncAction,
clearAsync(): Windows$Windows$Foundation.IAsyncAction,
clearAsync(
locality: Windows$Windows$Storage.ApplicationDataLocality): Windows$Windows$Foundation.IAsyncAction,
ondatachanged: any,
signalDataChanged(): void
} 
	declare export interface ApplicationDataSetVersionHandler {
(setVersionRequest: Windows$Windows$Storage.SetVersionRequest): void
} 
	declare export class SetVersionRequest mixins undefined.ISetVersionRequest {
currentVersion: number;
desiredVersion: number;
getDeferral(): Windows$Windows$Storage.SetVersionDeferral
}
	declare export class ApplicationDataContainer mixins undefined.IApplicationDataContainer {
containers: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$Storage.ApplicationDataContainer>;
locality: Windows$Windows$Storage.ApplicationDataLocality;
name: string;
values: Windows$Windows$Foundation.Collections.IPropertySet;
createContainer(
name: string,
disposition: Windows$Windows$Storage.ApplicationDataCreateDisposition): Windows$Windows$Storage.ApplicationDataContainer;
deleteContainer(name: string): void
}
	declare export interface ISetVersionRequest {
currentVersion: number,
desiredVersion: number,
getDeferral(): Windows$Windows$Storage.SetVersionDeferral
} 
	declare export class SetVersionDeferral mixins undefined.ISetVersionDeferral {
complete(): void
}
	declare export interface ISetVersionDeferral {
complete(): void
} 
	declare export interface IApplicationDataContainer {
containers: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$Storage.ApplicationDataContainer>,
locality: Windows$Windows$Storage.ApplicationDataLocality,
name: string,
values: Windows$Windows$Foundation.Collections.IPropertySet,
createContainer(
name: string,
disposition: Windows$Windows$Storage.ApplicationDataCreateDisposition): Windows$Windows$Storage.ApplicationDataContainer,
deleteContainer(name: string): void
} 
	declare export class ApplicationDataContainerSettings mixins undefined.IPropertySet, undefined.IObservableMap<string, any>, undefined.IMap<string, any>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>> {
size: number;
onmapchanged: any;
lookup(key: string): any;
hasKey(key: string): boolean;
getView(): Windows$Windows$Foundation.Collections.IMapView<string, any>;
insert(key: string, value: any): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>
}
	declare export class ApplicationDataCompositeValue mixins undefined.IPropertySet, undefined.IObservableMap<string, any>, undefined.IMap<string, any>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>> {
size: number;
onmapchanged: any;
lookup(key: string): any;
hasKey(key: string): boolean;
getView(): Windows$Windows$Foundation.Collections.IMapView<string, any>;
insert(key: string, value: any): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, any>>
}
	declare module 'Search' {
        declare export interface ISearchPaneQueryLinguisticDetails {
queryTextAlternatives: Windows$Windows$Foundation.Collections.IVectorView<string>,
queryTextCompositionLength: number,
queryTextCompositionStart: number
} 
	declare export class SearchPaneQueryLinguisticDetails mixins undefined.ISearchPaneQueryLinguisticDetails {
queryTextAlternatives: Windows$Windows$Foundation.Collections.IVectorView<string>;
queryTextCompositionLength: number;
queryTextCompositionStart: number
}
	declare export interface ISearchPaneVisibilityChangedEventArgs {
visible: boolean
} 
	declare export class SearchPaneVisibilityChangedEventArgs mixins undefined.ISearchPaneVisibilityChangedEventArgs {
visible: boolean
}
	declare export interface ISearchPaneQueryChangedEventArgs {
language: string,
linguisticDetails: Windows$Windows$ApplicationModel.Search.SearchPaneQueryLinguisticDetails,
queryText: string
} 
	declare export class SearchPaneQueryChangedEventArgs mixins undefined.ISearchPaneQueryChangedEventArgs {
language: string;
linguisticDetails: Windows$Windows$ApplicationModel.Search.SearchPaneQueryLinguisticDetails;
queryText: string
}
	declare export interface ISearchPaneQuerySubmittedEventArgs {
language: string,
queryText: string
} 
	declare export class SearchPaneQuerySubmittedEventArgs mixins undefined.ISearchPaneQuerySubmittedEventArgs {
language: string;
queryText: string
}
	declare export interface ISearchPaneResultSuggestionChosenEventArgs {
tag: string
} 
	declare export class SearchPaneResultSuggestionChosenEventArgs mixins undefined.ISearchPaneResultSuggestionChosenEventArgs {
tag: string
}
	declare export interface ISearchSuggestionCollection {
size: number,
appendQuerySuggestion(text: string): void,
appendQuerySuggestions(suggestions: Windows$Windows$Foundation.Collections.IIterable<string>): void,
appendResultSuggestion(
text: string,
detailText: string,
tag: string,
image: Windows$Windows$Storage.Streams.IRandomAccessStreamReference,
imageAlternateText: string): void,
appendSearchSeparator(label: string): void
} 
	declare export class SearchSuggestionCollection mixins undefined.ISearchSuggestionCollection {
size: number;
appendQuerySuggestion(text: string): void;
appendQuerySuggestions(suggestions: Windows$Windows$Foundation.Collections.IIterable<string>): void;
appendResultSuggestion(
text: string,
detailText: string,
tag: string,
image: Windows$Windows$Storage.Streams.IRandomAccessStreamReference,
imageAlternateText: string): void;
appendSearchSeparator(label: string): void
}
	declare export interface ISearchPaneSuggestionsRequestDeferral {
complete(): void
} 
	declare export interface ISearchPaneSuggestionsRequest {
isCanceled: boolean,
searchSuggestionCollection: Windows$Windows$ApplicationModel.Search.SearchSuggestionCollection,
getDeferral(): Windows$Windows$ApplicationModel.Search.SearchPaneSuggestionsRequestDeferral
} 
	declare export class SearchPaneSuggestionsRequestDeferral mixins undefined.ISearchPaneSuggestionsRequestDeferral {
complete(): void
}
	declare export class SearchPaneSuggestionsRequest mixins undefined.ISearchPaneSuggestionsRequest {
isCanceled: boolean;
searchSuggestionCollection: Windows$Windows$ApplicationModel.Search.SearchSuggestionCollection;
getDeferral(): Windows$Windows$ApplicationModel.Search.SearchPaneSuggestionsRequestDeferral
}
	declare export type ISearchPaneSuggestionsRequestedEventArgs = {
request: Windows$Windows$ApplicationModel.Search.SearchPaneSuggestionsRequest
} & undefined.ISearchPaneQueryChangedEventArgs

	declare export class SearchPaneSuggestionsRequestedEventArgs mixins undefined.ISearchPaneSuggestionsRequestedEventArgs, undefined.ISearchPaneQueryChangedEventArgs {
request: Windows$Windows$ApplicationModel.Search.SearchPaneSuggestionsRequest;
language: string;
linguisticDetails: Windows$Windows$ApplicationModel.Search.SearchPaneQueryLinguisticDetails;
queryText: string
}
	declare export interface ILocalContentSuggestionSettings {
aqsFilter: string,
enabled: boolean,
locations: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Storage.StorageFolder>,
propertiesToMatch: Windows$Windows$Foundation.Collections.IVector<string>
} 
	declare export class LocalContentSuggestionSettings mixins undefined.ILocalContentSuggestionSettings {
aqsFilter: string;
enabled: boolean;
locations: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Storage.StorageFolder>;
propertiesToMatch: Windows$Windows$Foundation.Collections.IVector<string>
}
	declare export interface ISearchPaneStatics {
getForCurrentView(): Windows$Windows$ApplicationModel.Search.SearchPane
} 
	declare export class SearchPane mixins undefined.ISearchPane {
language: string;
placeholderText: string;
queryText: string;
searchHistoryContext: string;
searchHistoryEnabled: boolean;
showOnKeyboardInput: boolean;
visible: boolean;
onvisibilitychanged: any;
onquerychanged: any;
onsuggestionsrequested: any;
onquerysubmitted: any;
onresultsuggestionchosen: any;
setLocalContentSuggestionSettings(
settings: Windows$Windows$ApplicationModel.Search.LocalContentSuggestionSettings): void;
show(): void;
show(query: string): void;
trySetQueryText(query: string): boolean;
static getForCurrentView(): Windows$Windows$ApplicationModel.Search.SearchPane
}
	declare export interface ISearchPane {
language: string,
placeholderText: string,
queryText: string,
searchHistoryContext: string,
searchHistoryEnabled: boolean,
showOnKeyboardInput: boolean,
visible: boolean,
onvisibilitychanged: any,
onquerychanged: any,
onsuggestionsrequested: any,
onquerysubmitted: any,
onresultsuggestionchosen: any,
setLocalContentSuggestionSettings(
settings: Windows$Windows$ApplicationModel.Search.LocalContentSuggestionSettings): void,
show(): void,
show(query: string): void,
trySetQueryText(query: string): boolean
} 
	declare export interface SortEntry {
propertyName: string,
ascendingOrder: boolean
} 
	declare export  class DateStackOption {
  constructor(...args: empty): mixed;
static +none: Class<DateStackOption__none> & DateStackOption__none & 0;// 0
static +year: Class<DateStackOption__year> & DateStackOption__year & 1;// 1
static +month: Class<DateStackOption__month> & DateStackOption__month & 2;// 2

}

declare class DateStackOption__none mixins DateStackOption {}
declare class DateStackOption__year mixins DateStackOption {}
declare class DateStackOption__month mixins DateStackOption {}

	declare export  class IndexerOption {
  constructor(...args: empty): mixed;
static +useIndexerWhenAvailable: Class<IndexerOption__useIndexerWhenAvailable> & IndexerOption__useIndexerWhenAvailable & 0;// 0
static +onlyUseIndexer: Class<IndexerOption__onlyUseIndexer> & IndexerOption__onlyUseIndexer & 1;// 1
static +doNotUseIndexer: Class<IndexerOption__doNotUseIndexer> & IndexerOption__doNotUseIndexer & 2;// 2

}

declare class IndexerOption__useIndexerWhenAvailable mixins IndexerOption {}
declare class IndexerOption__onlyUseIndexer mixins IndexerOption {}
declare class IndexerOption__doNotUseIndexer mixins IndexerOption {}

	declare export  class FolderDepth {
  constructor(...args: empty): mixed;
static +shallow: Class<FolderDepth__shallow> & FolderDepth__shallow & 0;// 0
static +deep: Class<FolderDepth__deep> & FolderDepth__deep & 1;// 1

}

declare class FolderDepth__shallow mixins FolderDepth {}
declare class FolderDepth__deep mixins FolderDepth {}

	declare export  class CommonFileQuery {
  constructor(...args: empty): mixed;
static +defaultQuery: Class<CommonFileQuery__defaultQuery> & CommonFileQuery__defaultQuery & 0;// 0
static +orderByName: Class<CommonFileQuery__orderByName> & CommonFileQuery__orderByName & 1;// 1
static +orderByTitle: Class<CommonFileQuery__orderByTitle> & CommonFileQuery__orderByTitle & 2;// 2
static +orderByMusicProperties: Class<CommonFileQuery__orderByMusicProperties> & CommonFileQuery__orderByMusicProperties & 3;// 3
static +orderBySearchRank: Class<CommonFileQuery__orderBySearchRank> & CommonFileQuery__orderBySearchRank & 4;// 4
static +orderByDate: Class<CommonFileQuery__orderByDate> & CommonFileQuery__orderByDate & 5;// 5

}

declare class CommonFileQuery__defaultQuery mixins CommonFileQuery {}
declare class CommonFileQuery__orderByName mixins CommonFileQuery {}
declare class CommonFileQuery__orderByTitle mixins CommonFileQuery {}
declare class CommonFileQuery__orderByMusicProperties mixins CommonFileQuery {}
declare class CommonFileQuery__orderBySearchRank mixins CommonFileQuery {}
declare class CommonFileQuery__orderByDate mixins CommonFileQuery {}

	declare export  class CommonFolderQuery {
  constructor(...args: empty): mixed;
static +defaultQuery: Class<CommonFolderQuery__defaultQuery> & CommonFolderQuery__defaultQuery & 0;// 0
static +groupByYear: Class<CommonFolderQuery__groupByYear> & CommonFolderQuery__groupByYear & 1;// 1
static +groupByMonth: Class<CommonFolderQuery__groupByMonth> & CommonFolderQuery__groupByMonth & 2;// 2
static +groupByArtist: Class<CommonFolderQuery__groupByArtist> & CommonFolderQuery__groupByArtist & 3;// 3
static +groupByAlbum: Class<CommonFolderQuery__groupByAlbum> & CommonFolderQuery__groupByAlbum & 4;// 4
static +groupByAlbumArtist: Class<CommonFolderQuery__groupByAlbumArtist> & CommonFolderQuery__groupByAlbumArtist & 5;// 5
static +groupByComposer: Class<CommonFolderQuery__groupByComposer> & CommonFolderQuery__groupByComposer & 6;// 6
static +groupByGenre: Class<CommonFolderQuery__groupByGenre> & CommonFolderQuery__groupByGenre & 7;// 7
static +groupByPublishedYear: Class<CommonFolderQuery__groupByPublishedYear> & CommonFolderQuery__groupByPublishedYear & 8;// 8
static +groupByRating: Class<CommonFolderQuery__groupByRating> & CommonFolderQuery__groupByRating & 9;// 9
static +groupByTag: Class<CommonFolderQuery__groupByTag> & CommonFolderQuery__groupByTag & 10;// 10
static +groupByAuthor: Class<CommonFolderQuery__groupByAuthor> & CommonFolderQuery__groupByAuthor & 11;// 11
static +groupByType: Class<CommonFolderQuery__groupByType> & CommonFolderQuery__groupByType & 12;// 12

}

declare class CommonFolderQuery__defaultQuery mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByYear mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByMonth mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByArtist mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByAlbum mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByAlbumArtist mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByComposer mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByGenre mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByPublishedYear mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByRating mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByTag mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByAuthor mixins CommonFolderQuery {}
declare class CommonFolderQuery__groupByType mixins CommonFolderQuery {}

	declare export  class IndexedState {
  constructor(...args: empty): mixed;
static +unknown: Class<IndexedState__unknown> & IndexedState__unknown & 0;// 0
static +notIndexed: Class<IndexedState__notIndexed> & IndexedState__notIndexed & 1;// 1
static +partiallyIndexed: Class<IndexedState__partiallyIndexed> & IndexedState__partiallyIndexed & 2;// 2
static +fullyIndexed: Class<IndexedState__fullyIndexed> & IndexedState__fullyIndexed & 3;// 3

}

declare class IndexedState__unknown mixins IndexedState {}
declare class IndexedState__notIndexed mixins IndexedState {}
declare class IndexedState__partiallyIndexed mixins IndexedState {}
declare class IndexedState__fullyIndexed mixins IndexedState {}

	declare export interface IQueryOptions {
applicationSearchFilter: string,
dateStackOption: Windows$Windows$Storage.Search.DateStackOption,
fileTypeFilter: Windows$Windows$Foundation.Collections.IVector<string>,
folderDepth: Windows$Windows$Storage.Search.FolderDepth,
groupPropertyName: string,
indexerOption: Windows$Windows$Storage.Search.IndexerOption,
language: string,
sortOrder: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Storage.Search.SortEntry>,
userSearchFilter: string,
saveToString(): string,
loadFromString(value: string): void,
setThumbnailPrefetch(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedSize: number,
options: Windows$Windows$Storage.FileProperties.ThumbnailOptions): void,
setPropertyPrefetch(
options: Windows$Windows$Storage.FileProperties.PropertyPrefetchOptions,
propertiesToRetrieve: Windows$Windows$Foundation.Collections.IIterable<string>): void
} 
	declare export interface IQueryOptionsFactory {
createCommonFileQuery(
query: Windows$Windows$Storage.Search.CommonFileQuery,
fileTypeFilter: Windows$Windows$Foundation.Collections.IIterable<string>): Windows$Windows$Storage.Search.QueryOptions,
createCommonFolderQuery(
query: Windows$Windows$Storage.Search.CommonFolderQuery): Windows$Windows$Storage.Search.QueryOptions
} 
	declare export class QueryOptions mixins undefined.IQueryOptions {
constructor(query: Windows$Windows$Storage.Search.CommonFileQuery, fileTypeFilter: Windows$Windows$Foundation.Collections.IIterable<string>): this;
constructor(query: Windows$Windows$Storage.Search.CommonFolderQuery): this;
constructor(): this;
applicationSearchFilter: string;
dateStackOption: Windows$Windows$Storage.Search.DateStackOption;
fileTypeFilter: Windows$Windows$Foundation.Collections.IVector<string>;
folderDepth: Windows$Windows$Storage.Search.FolderDepth;
groupPropertyName: string;
indexerOption: Windows$Windows$Storage.Search.IndexerOption;
language: string;
sortOrder: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Storage.Search.SortEntry>;
userSearchFilter: string;
saveToString(): string;
loadFromString(value: string): void;
setThumbnailPrefetch(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedSize: number,
options: Windows$Windows$Storage.FileProperties.ThumbnailOptions): void;
setPropertyPrefetch(
options: Windows$Windows$Storage.FileProperties.PropertyPrefetchOptions,
propertiesToRetrieve: Windows$Windows$Foundation.Collections.IIterable<string>): void
}
	declare export interface IStorageQueryResultBase {
folder: Windows$Windows$Storage.StorageFolder,
getItemCountAsync(): Windows$Windows$Foundation.IAsyncOperation<number>,
oncontentschanged: any,
onoptionschanged: any,
findStartIndexAsync(value: any): Windows$Windows$Foundation.IAsyncOperation<number>,
getCurrentQueryOptions(): Windows$Windows$Storage.Search.QueryOptions,
applyNewQueryOptions(newQueryOptions: Windows$Windows$Storage.Search.QueryOptions): void
} 
	declare export type IStorageFileQueryResult = {
getFilesAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>,
getFilesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>
} & undefined.IStorageQueryResultBase

	declare export type IStorageFolderQueryResult = {
getFoldersAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>,
getFoldersAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>
} & undefined.IStorageQueryResultBase

	declare export type IStorageItemQueryResult = {
getItemsAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>,
getItemsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>
} & undefined.IStorageQueryResultBase

	declare export interface IStorageFolderQueryOperations {
getIndexedStateAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Search.IndexedState>,
createFileQuery(): Windows$Windows$Storage.Search.StorageFileQueryResult,
createFileQuery(
query: Windows$Windows$Storage.Search.CommonFileQuery): Windows$Windows$Storage.Search.StorageFileQueryResult,
createFileQueryWithOptions(
queryOptions: Windows$Windows$Storage.Search.QueryOptions): Windows$Windows$Storage.Search.StorageFileQueryResult,
createFolderQuery(): Windows$Windows$Storage.Search.StorageFolderQueryResult,
createFolderQuery(
query: Windows$Windows$Storage.Search.CommonFolderQuery): Windows$Windows$Storage.Search.StorageFolderQueryResult,
createFolderQueryWithOptions(
queryOptions: Windows$Windows$Storage.Search.QueryOptions): Windows$Windows$Storage.Search.StorageFolderQueryResult,
createItemQuery(): Windows$Windows$Storage.Search.StorageItemQueryResult,
createItemQueryWithOptions(
queryOptions: Windows$Windows$Storage.Search.QueryOptions): Windows$Windows$Storage.Search.StorageItemQueryResult,
getFilesAsync(
query: Windows$Windows$Storage.Search.CommonFileQuery,
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>,
getFilesAsync(
query: Windows$Windows$Storage.Search.CommonFileQuery): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>,
getFoldersAsync(
query: Windows$Windows$Storage.Search.CommonFolderQuery,
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>,
getFoldersAsync(
query: Windows$Windows$Storage.Search.CommonFolderQuery): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>,
getItemsAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>,
areQueryOptionsSupported(queryOptions: Windows$Windows$Storage.Search.QueryOptions): boolean,
isCommonFolderQuerySupported(query: Windows$Windows$Storage.Search.CommonFolderQuery): boolean,
isCommonFileQuerySupported(query: Windows$Windows$Storage.Search.CommonFileQuery): boolean
} 
	declare export class StorageFileQueryResult mixins undefined.IStorageFileQueryResult, undefined.IStorageQueryResultBase {
folder: Windows$Windows$Storage.StorageFolder;
getFilesAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>;
getFilesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>;
getItemCountAsync(): Windows$Windows$Foundation.IAsyncOperation<number>;
oncontentschanged: any;
onoptionschanged: any;
findStartIndexAsync(value: any): Windows$Windows$Foundation.IAsyncOperation<number>;
getCurrentQueryOptions(): Windows$Windows$Storage.Search.QueryOptions;
applyNewQueryOptions(newQueryOptions: Windows$Windows$Storage.Search.QueryOptions): void
}
	declare export class StorageFolderQueryResult mixins undefined.IStorageFolderQueryResult, undefined.IStorageQueryResultBase {
folder: Windows$Windows$Storage.StorageFolder;
getFoldersAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>;
getFoldersAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>;
getItemCountAsync(): Windows$Windows$Foundation.IAsyncOperation<number>;
oncontentschanged: any;
onoptionschanged: any;
findStartIndexAsync(value: any): Windows$Windows$Foundation.IAsyncOperation<number>;
getCurrentQueryOptions(): Windows$Windows$Storage.Search.QueryOptions;
applyNewQueryOptions(newQueryOptions: Windows$Windows$Storage.Search.QueryOptions): void
}
	declare export class StorageItemQueryResult mixins undefined.IStorageItemQueryResult, undefined.IStorageQueryResultBase {
folder: Windows$Windows$Storage.StorageFolder;
getItemsAsync(
startIndex: number,
maxNumberOfItems: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>;
getItemsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>;
getItemCountAsync(): Windows$Windows$Foundation.IAsyncOperation<number>;
oncontentschanged: any;
onoptionschanged: any;
findStartIndexAsync(value: any): Windows$Windows$Foundation.IAsyncOperation<number>;
getCurrentQueryOptions(): Windows$Windows$Storage.Search.QueryOptions;
applyNewQueryOptions(newQueryOptions: Windows$Windows$Storage.Search.QueryOptions): void
}
	declare export class SortEntryVector mixins undefined.IVector<Windows$Windows$Storage.Search.SortEntry>, undefined.IIterable<Windows$Windows$Storage.Search.SortEntry> {
size: number;
getAt(index: number): Windows$Windows$Storage.Search.SortEntry;
getView(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.Search.SortEntry>;
indexOf(
value: Windows$Windows$Storage.Search.SortEntry): {
index: number,
returnValue: boolean
};
setAt(index: number, value: Windows$Windows$Storage.Search.SortEntry): void;
insertAt(index: number, value: Windows$Windows$Storage.Search.SortEntry): void;
removeAt(index: number): void;
append(value: Windows$Windows$Storage.Search.SortEntry): void;
removeAtEnd(): void;
clear(): void;
getMany(
startIndex: number): {
items: Windows$Windows$Storage.Search.SortEntry[],
returnValue: number
};
replaceAll(items: Windows$Windows$Storage.Search.SortEntry[]): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Storage.Search.SortEntry>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$Storage.Search.SortEntry[][]): Windows$Windows$Storage.Search.SortEntry[];
join(seperator: string): string;
pop(): Windows$Windows$Storage.Search.SortEntry;
push(...items: Windows$Windows$Storage.Search.SortEntry[]): void;
reverse(): Windows$Windows$Storage.Search.SortEntry[];
shift(): Windows$Windows$Storage.Search.SortEntry;
slice(start: number): Windows$Windows$Storage.Search.SortEntry[];
slice(start: number, end: number): Windows$Windows$Storage.Search.SortEntry[];
sort(): Windows$Windows$Storage.Search.SortEntry[];
sort(
compareFn: (
a: Windows$Windows$Storage.Search.SortEntry,
b: Windows$Windows$Storage.Search.SortEntry) => number): Windows$Windows$Storage.Search.SortEntry[];
splice(start: number): Windows$Windows$Storage.Search.SortEntry[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$Storage.Search.SortEntry[]): Windows$Windows$Storage.Search.SortEntry[];
unshift(...items: Windows$Windows$Storage.Search.SortEntry[]): number;
lastIndexOf(searchElement: Windows$Windows$Storage.Search.SortEntry): number;
lastIndexOf(
searchElement: Windows$Windows$Storage.Search.SortEntry,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => boolean): Windows$Windows$Storage.Search.SortEntry[];
filter(
callbackfn: (
value: Windows$Windows$Storage.Search.SortEntry,
index: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => boolean,
thisArg: any): Windows$Windows$Storage.Search.SortEntry[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.Search.SortEntry[]) => any,
initialValue: any): any;
length: number
}
    }

	declare module 'AccessCache' {
        declare export interface AccessListEntry {
token: string,
metadata: string
} 
	declare export interface IItemRemovedEventArgs {
removedEntry: Windows$Windows$Storage.AccessCache.AccessListEntry
} 
	declare export class AccessListEntryView mixins undefined.IVectorView<Windows$Windows$Storage.AccessCache.AccessListEntry>, undefined.IIterable<Windows$Windows$Storage.AccessCache.AccessListEntry> {
size: number;
getAt(index: number): Windows$Windows$Storage.AccessCache.AccessListEntry;
indexOf(
value: Windows$Windows$Storage.AccessCache.AccessListEntry): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$Storage.AccessCache.AccessListEntry[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Storage.AccessCache.AccessListEntry>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$Storage.AccessCache.AccessListEntry[][]): Windows$Windows$Storage.AccessCache.AccessListEntry[];
join(seperator: string): string;
pop(): Windows$Windows$Storage.AccessCache.AccessListEntry;
push(...items: Windows$Windows$Storage.AccessCache.AccessListEntry[]): void;
reverse(): Windows$Windows$Storage.AccessCache.AccessListEntry[];
shift(): Windows$Windows$Storage.AccessCache.AccessListEntry;
slice(start: number): Windows$Windows$Storage.AccessCache.AccessListEntry[];
slice(
start: number,
end: number): Windows$Windows$Storage.AccessCache.AccessListEntry[];
sort(): Windows$Windows$Storage.AccessCache.AccessListEntry[];
sort(
compareFn: (
a: Windows$Windows$Storage.AccessCache.AccessListEntry,
b: Windows$Windows$Storage.AccessCache.AccessListEntry) => number): Windows$Windows$Storage.AccessCache.AccessListEntry[];
splice(start: number): Windows$Windows$Storage.AccessCache.AccessListEntry[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$Storage.AccessCache.AccessListEntry[]): Windows$Windows$Storage.AccessCache.AccessListEntry[];
unshift(...items: Windows$Windows$Storage.AccessCache.AccessListEntry[]): number;
lastIndexOf(searchElement: Windows$Windows$Storage.AccessCache.AccessListEntry): number;
lastIndexOf(
searchElement: Windows$Windows$Storage.AccessCache.AccessListEntry,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$Storage.AccessCache.AccessListEntry,
index: number,
array: Windows$Windows$Storage.AccessCache.AccessListEntry[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$Storage.AccessCache.AccessListEntry,
index: number,
array: Windows$Windows$Storage.AccessCache.AccessListEntry[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$Storage.AccessCache.AccessListEntry,
index: number,
array: Windows$Windows$Storage.AccessCache.AccessListEntry[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$Storage.AccessCache.AccessListEntry,
index: number,
array: Windows$Windows$Storage.AccessCache.AccessListEntry[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$Storage.AccessCache.AccessListEntry,
index: number,
array: Windows$Windows$Storage.AccessCache.AccessListEntry[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$Storage.AccessCache.AccessListEntry,
index: number,
array: Windows$Windows$Storage.AccessCache.AccessListEntry[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$Storage.AccessCache.AccessListEntry,
index: number,
array: Windows$Windows$Storage.AccessCache.AccessListEntry[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$Storage.AccessCache.AccessListEntry,
index: number,
array: Windows$Windows$Storage.AccessCache.AccessListEntry[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$Storage.AccessCache.AccessListEntry,
index: number,
array: Windows$Windows$Storage.AccessCache.AccessListEntry[]) => boolean): Windows$Windows$Storage.AccessCache.AccessListEntry[];
filter(
callbackfn: (
value: Windows$Windows$Storage.AccessCache.AccessListEntry,
index: number,
array: Windows$Windows$Storage.AccessCache.AccessListEntry[]) => boolean,
thisArg: any): Windows$Windows$Storage.AccessCache.AccessListEntry[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.AccessCache.AccessListEntry[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.AccessCache.AccessListEntry[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.AccessCache.AccessListEntry[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$Storage.AccessCache.AccessListEntry[]) => any,
initialValue: any): any;
length: number
}
	declare export  class AccessCacheOptions {
  constructor(...args: empty): mixed;
static +none: Class<AccessCacheOptions__none> & AccessCacheOptions__none & 0;// 0
static +disallowUserInput: Class<AccessCacheOptions__disallowUserInput> & AccessCacheOptions__disallowUserInput & 1;// 1
static +fastLocationsOnly: Class<AccessCacheOptions__fastLocationsOnly> & AccessCacheOptions__fastLocationsOnly & 2;// 2
static +useReadOnlyCachedCopy: Class<AccessCacheOptions__useReadOnlyCachedCopy> & AccessCacheOptions__useReadOnlyCachedCopy & 3;// 3
static +suppressAccessTimeUpdate: Class<AccessCacheOptions__suppressAccessTimeUpdate> & AccessCacheOptions__suppressAccessTimeUpdate & 4;// 4

}

declare class AccessCacheOptions__none mixins AccessCacheOptions {}
declare class AccessCacheOptions__disallowUserInput mixins AccessCacheOptions {}
declare class AccessCacheOptions__fastLocationsOnly mixins AccessCacheOptions {}
declare class AccessCacheOptions__useReadOnlyCachedCopy mixins AccessCacheOptions {}
declare class AccessCacheOptions__suppressAccessTimeUpdate mixins AccessCacheOptions {}

	declare export interface IStorageItemAccessList {
entries: Windows$Windows$Storage.AccessCache.AccessListEntryView,
maximumItemsAllowed: number,
add(file: Windows$Windows$Storage.IStorageItem): string,
add(file: Windows$Windows$Storage.IStorageItem, metadata: string): string,
addOrReplace(token: string, file: Windows$Windows$Storage.IStorageItem): void,
addOrReplace(
token: string,
file: Windows$Windows$Storage.IStorageItem,
metadata: string): void,
getItemAsync(
token: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.IStorageItem>,
getFileAsync(
token: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
getFolderAsync(
token: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>,
getItemAsync(
token: string,
options: Windows$Windows$Storage.AccessCache.AccessCacheOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.IStorageItem>,
getFileAsync(
token: string,
options: Windows$Windows$Storage.AccessCache.AccessCacheOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
getFolderAsync(
token: string,
options: Windows$Windows$Storage.AccessCache.AccessCacheOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>,
remove(token: string): void,
containsItem(token: string): boolean,
clear(): void,
checkAccess(file: Windows$Windows$Storage.IStorageItem): boolean
} 
	declare export type IStorageItemMostRecentlyUsedList = {
onitemremoved: any
} & undefined.IStorageItemAccessList

	declare export class StorageItemMostRecentlyUsedList mixins undefined.IStorageItemMostRecentlyUsedList, undefined.IStorageItemAccessList {
entries: Windows$Windows$Storage.AccessCache.AccessListEntryView;
maximumItemsAllowed: number;
onitemremoved: any;
add(file: Windows$Windows$Storage.IStorageItem): string;
add(file: Windows$Windows$Storage.IStorageItem, metadata: string): string;
addOrReplace(token: string, file: Windows$Windows$Storage.IStorageItem): void;
addOrReplace(
token: string,
file: Windows$Windows$Storage.IStorageItem,
metadata: string): void;
getItemAsync(
token: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.IStorageItem>;
getFileAsync(
token: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
getFolderAsync(
token: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>;
getItemAsync(
token: string,
options: Windows$Windows$Storage.AccessCache.AccessCacheOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.IStorageItem>;
getFileAsync(
token: string,
options: Windows$Windows$Storage.AccessCache.AccessCacheOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
getFolderAsync(
token: string,
options: Windows$Windows$Storage.AccessCache.AccessCacheOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>;
remove(token: string): void;
containsItem(token: string): boolean;
clear(): void;
checkAccess(file: Windows$Windows$Storage.IStorageItem): boolean
}
	declare export class ItemRemovedEventArgs mixins undefined.IItemRemovedEventArgs {
removedEntry: Windows$Windows$Storage.AccessCache.AccessListEntry
}
	declare export interface IStorageApplicationPermissionsStatics {
futureAccessList: Windows$Windows$Storage.AccessCache.StorageItemAccessList,
mostRecentlyUsedList: Windows$Windows$Storage.AccessCache.StorageItemMostRecentlyUsedList
} 
	declare export class StorageItemAccessList mixins undefined.IStorageItemAccessList {
entries: Windows$Windows$Storage.AccessCache.AccessListEntryView;
maximumItemsAllowed: number;
add(file: Windows$Windows$Storage.IStorageItem): string;
add(file: Windows$Windows$Storage.IStorageItem, metadata: string): string;
addOrReplace(token: string, file: Windows$Windows$Storage.IStorageItem): void;
addOrReplace(
token: string,
file: Windows$Windows$Storage.IStorageItem,
metadata: string): void;
getItemAsync(
token: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.IStorageItem>;
getFileAsync(
token: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
getFolderAsync(
token: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>;
getItemAsync(
token: string,
options: Windows$Windows$Storage.AccessCache.AccessCacheOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.IStorageItem>;
getFileAsync(
token: string,
options: Windows$Windows$Storage.AccessCache.AccessCacheOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
getFolderAsync(
token: string,
options: Windows$Windows$Storage.AccessCache.AccessCacheOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>;
remove(token: string): void;
containsItem(token: string): boolean;
clear(): void;
checkAccess(file: Windows$Windows$Storage.IStorageItem): boolean
}
	declare export class StorageApplicationPermissions  {
static futureAccessList: Windows$Windows$Storage.AccessCache.StorageItemAccessList;
static mostRecentlyUsedList: Windows$Windows$Storage.AccessCache.StorageItemMostRecentlyUsedList
}
    }

	declare module 'BulkAccess' {
        declare export interface IStorageItemInformation {
basicProperties: Windows$Windows$Storage.FileProperties.BasicProperties,
documentProperties: Windows$Windows$Storage.FileProperties.DocumentProperties,
imageProperties: Windows$Windows$Storage.FileProperties.ImageProperties,
musicProperties: Windows$Windows$Storage.FileProperties.MusicProperties,
thumbnail: Windows$Windows$Storage.FileProperties.StorageItemThumbnail,
videoProperties: Windows$Windows$Storage.FileProperties.VideoProperties,
onthumbnailupdated: any,
onpropertiesupdated: any
} 
	declare export interface IFileInformationFactoryFactory {
createWithMode(
queryResult: Windows$Windows$Storage.Search.IStorageQueryResultBase,
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode): Windows$Windows$Storage.BulkAccess.FileInformationFactory,
createWithModeAndSize(
queryResult: Windows$Windows$Storage.Search.IStorageQueryResultBase,
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedThumbnailSize: number): Windows$Windows$Storage.BulkAccess.FileInformationFactory,
createWithModeAndSizeAndOptions(
queryResult: Windows$Windows$Storage.Search.IStorageQueryResultBase,
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedThumbnailSize: number,
thumbnailOptions: Windows$Windows$Storage.FileProperties.ThumbnailOptions): Windows$Windows$Storage.BulkAccess.FileInformationFactory,
createWithModeAndSizeAndOptionsAndFlags(
queryResult: Windows$Windows$Storage.Search.IStorageQueryResultBase,
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedThumbnailSize: number,
thumbnailOptions: Windows$Windows$Storage.FileProperties.ThumbnailOptions,
delayLoad: boolean): Windows$Windows$Storage.BulkAccess.FileInformationFactory
} 
	declare export class FileInformationFactory mixins undefined.IFileInformationFactory {
constructor(queryResult: Windows$Windows$Storage.Search.IStorageQueryResultBase, mode: Windows$Windows$Storage.FileProperties.ThumbnailMode): this;
constructor(queryResult: Windows$Windows$Storage.Search.IStorageQueryResultBase, mode: Windows$Windows$Storage.FileProperties.ThumbnailMode, requestedThumbnailSize: number): this;
constructor(queryResult: Windows$Windows$Storage.Search.IStorageQueryResultBase, mode: Windows$Windows$Storage.FileProperties.ThumbnailMode, requestedThumbnailSize: number, thumbnailOptions: Windows$Windows$Storage.FileProperties.ThumbnailOptions): this;
constructor(queryResult: Windows$Windows$Storage.Search.IStorageQueryResultBase, mode: Windows$Windows$Storage.FileProperties.ThumbnailMode, requestedThumbnailSize: number, thumbnailOptions: Windows$Windows$Storage.FileProperties.ThumbnailOptions, delayLoad: boolean): this;
getItemsAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.BulkAccess.IStorageItemInformation>>;
getItemsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.BulkAccess.IStorageItemInformation>>;
getFilesAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.BulkAccess.FileInformation>>;
getFilesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.BulkAccess.FileInformation>>;
getFoldersAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.BulkAccess.FolderInformation>>;
getFoldersAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.BulkAccess.FolderInformation>>;
getVirtualizedItemsVector(): any;
getVirtualizedFilesVector(): any;
getVirtualizedFoldersVector(): any
}
	declare export interface IFileInformationFactory {
getItemsAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.BulkAccess.IStorageItemInformation>>,
getItemsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.BulkAccess.IStorageItemInformation>>,
getFilesAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.BulkAccess.FileInformation>>,
getFilesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.BulkAccess.FileInformation>>,
getFoldersAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.BulkAccess.FolderInformation>>,
getFoldersAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.BulkAccess.FolderInformation>>,
getVirtualizedItemsVector(): any,
getVirtualizedFilesVector(): any,
getVirtualizedFoldersVector(): any
} 
	declare export class FileInformation mixins undefined.IStorageItemInformation, undefined.IStorageFile, undefined.IStorageItem, undefined.IRandomAccessStreamReference, undefined.IInputStreamReference, undefined.IStorageItemProperties {
basicProperties: Windows$Windows$Storage.FileProperties.BasicProperties;
documentProperties: Windows$Windows$Storage.FileProperties.DocumentProperties;
imageProperties: Windows$Windows$Storage.FileProperties.ImageProperties;
musicProperties: Windows$Windows$Storage.FileProperties.MusicProperties;
thumbnail: Windows$Windows$Storage.FileProperties.StorageItemThumbnail;
videoProperties: Windows$Windows$Storage.FileProperties.VideoProperties;
contentType: string;
fileType: string;
attributes: Windows$Windows$Storage.FileAttributes;
dateCreated: Date;
name: string;
path: string;
displayName: string;
displayType: string;
folderRelativeId: string;
properties: Windows$Windows$Storage.FileProperties.StorageItemContentProperties;
onthumbnailupdated: any;
onpropertiesupdated: any;
openAsync(
accessMode: Windows$Windows$Storage.FileAccessMode): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IRandomAccessStream>;
openTransactedWriteAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageStreamTransaction>;
copyAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
copyAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder,
desiredNewName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
copyAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder,
desiredNewName: string,
option: Windows$Windows$Storage.NameCollisionOption): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
copyAndReplaceAsync(
fileToReplace: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncAction;
moveAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder): Windows$Windows$Foundation.IAsyncAction;
moveAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder,
desiredNewName: string): Windows$Windows$Foundation.IAsyncAction;
moveAsync(
destinationFolder: Windows$Windows$Storage.IStorageFolder,
desiredNewName: string,
option: Windows$Windows$Storage.NameCollisionOption): Windows$Windows$Foundation.IAsyncAction;
moveAndReplaceAsync(
fileToReplace: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncAction;
renameAsync(desiredName: string): Windows$Windows$Foundation.IAsyncAction;
renameAsync(
desiredName: string,
option: Windows$Windows$Storage.NameCollisionOption): Windows$Windows$Foundation.IAsyncAction;
deleteAsync(): Windows$Windows$Foundation.IAsyncAction;
deleteAsync(
option: Windows$Windows$Storage.StorageDeleteOption): Windows$Windows$Foundation.IAsyncAction;
getBasicPropertiesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.BasicProperties>;
isOfType(type: Windows$Windows$Storage.StorageItemTypes): boolean;
openReadAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IRandomAccessStreamWithContentType>;
openSequentialReadAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IInputStream>;
getThumbnailAsync(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.StorageItemThumbnail>;
getThumbnailAsync(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedSize: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.StorageItemThumbnail>;
getThumbnailAsync(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedSize: number,
options: Windows$Windows$Storage.FileProperties.ThumbnailOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.StorageItemThumbnail>
}
	declare export class FolderInformation mixins undefined.IStorageItemInformation, undefined.IStorageFolder, undefined.IStorageItem, undefined.IStorageItemProperties, undefined.IStorageFolderQueryOperations {
basicProperties: Windows$Windows$Storage.FileProperties.BasicProperties;
documentProperties: Windows$Windows$Storage.FileProperties.DocumentProperties;
imageProperties: Windows$Windows$Storage.FileProperties.ImageProperties;
musicProperties: Windows$Windows$Storage.FileProperties.MusicProperties;
thumbnail: Windows$Windows$Storage.FileProperties.StorageItemThumbnail;
videoProperties: Windows$Windows$Storage.FileProperties.VideoProperties;
attributes: Windows$Windows$Storage.FileAttributes;
dateCreated: Date;
name: string;
path: string;
displayName: string;
displayType: string;
folderRelativeId: string;
properties: Windows$Windows$Storage.FileProperties.StorageItemContentProperties;
onthumbnailupdated: any;
onpropertiesupdated: any;
createFileAsync(
desiredName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
createFileAsync(
desiredName: string,
options: Windows$Windows$Storage.CreationCollisionOption): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
createFolderAsync(
desiredName: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>;
createFolderAsync(
desiredName: string,
options: Windows$Windows$Storage.CreationCollisionOption): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>;
getFileAsync(
name: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
getFolderAsync(
name: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFolder>;
getItemAsync(
name: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.IStorageItem>;
getFilesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>;
getFoldersAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>;
getItemsAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>;
renameAsync(desiredName: string): Windows$Windows$Foundation.IAsyncAction;
renameAsync(
desiredName: string,
option: Windows$Windows$Storage.NameCollisionOption): Windows$Windows$Foundation.IAsyncAction;
deleteAsync(): Windows$Windows$Foundation.IAsyncAction;
deleteAsync(
option: Windows$Windows$Storage.StorageDeleteOption): Windows$Windows$Foundation.IAsyncAction;
getBasicPropertiesAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.BasicProperties>;
isOfType(type: Windows$Windows$Storage.StorageItemTypes): boolean;
getThumbnailAsync(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.StorageItemThumbnail>;
getThumbnailAsync(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedSize: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.StorageItemThumbnail>;
getThumbnailAsync(
mode: Windows$Windows$Storage.FileProperties.ThumbnailMode,
requestedSize: number,
options: Windows$Windows$Storage.FileProperties.ThumbnailOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.FileProperties.StorageItemThumbnail>;
getIndexedStateAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Search.IndexedState>;
createFileQuery(): Windows$Windows$Storage.Search.StorageFileQueryResult;
createFileQuery(
query: Windows$Windows$Storage.Search.CommonFileQuery): Windows$Windows$Storage.Search.StorageFileQueryResult;
createFileQueryWithOptions(
queryOptions: Windows$Windows$Storage.Search.QueryOptions): Windows$Windows$Storage.Search.StorageFileQueryResult;
createFolderQuery(): Windows$Windows$Storage.Search.StorageFolderQueryResult;
createFolderQuery(
query: Windows$Windows$Storage.Search.CommonFolderQuery): Windows$Windows$Storage.Search.StorageFolderQueryResult;
createFolderQueryWithOptions(
queryOptions: Windows$Windows$Storage.Search.QueryOptions): Windows$Windows$Storage.Search.StorageFolderQueryResult;
createItemQuery(): Windows$Windows$Storage.Search.StorageItemQueryResult;
createItemQueryWithOptions(
queryOptions: Windows$Windows$Storage.Search.QueryOptions): Windows$Windows$Storage.Search.StorageItemQueryResult;
getFilesAsync(
query: Windows$Windows$Storage.Search.CommonFileQuery,
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>;
getFilesAsync(
query: Windows$Windows$Storage.Search.CommonFileQuery): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFile>>;
getFoldersAsync(
query: Windows$Windows$Storage.Search.CommonFolderQuery,
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>;
getFoldersAsync(
query: Windows$Windows$Storage.Search.CommonFolderQuery): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.StorageFolder>>;
getItemsAsync(
startIndex: number,
maxItemsToRetrieve: number): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>>;
areQueryOptionsSupported(queryOptions: Windows$Windows$Storage.Search.QueryOptions): boolean;
isCommonFolderQuerySupported(query: Windows$Windows$Storage.Search.CommonFolderQuery): boolean;
isCommonFileQuerySupported(query: Windows$Windows$Storage.Search.CommonFileQuery): boolean
}
    }

	declare module 'Compression' {
        declare export  class CompressAlgorithm {
  constructor(...args: empty): mixed;
static +invalidAlgorithm: Class<CompressAlgorithm__invalidAlgorithm> & CompressAlgorithm__invalidAlgorithm & 0;// 0
static +nullAlgorithm: Class<CompressAlgorithm__nullAlgorithm> & CompressAlgorithm__nullAlgorithm & 1;// 1
static +mszip: Class<CompressAlgorithm__mszip> & CompressAlgorithm__mszip & 2;// 2
static +xpress: Class<CompressAlgorithm__xpress> & CompressAlgorithm__xpress & 3;// 3
static +xpressHuff: Class<CompressAlgorithm__xpressHuff> & CompressAlgorithm__xpressHuff & 4;// 4
static +lzms: Class<CompressAlgorithm__lzms> & CompressAlgorithm__lzms & 5;// 5

}

declare class CompressAlgorithm__invalidAlgorithm mixins CompressAlgorithm {}
declare class CompressAlgorithm__nullAlgorithm mixins CompressAlgorithm {}
declare class CompressAlgorithm__mszip mixins CompressAlgorithm {}
declare class CompressAlgorithm__xpress mixins CompressAlgorithm {}
declare class CompressAlgorithm__xpressHuff mixins CompressAlgorithm {}
declare class CompressAlgorithm__lzms mixins CompressAlgorithm {}

	declare export type ICompressor = {
finishAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>,
detachStream(): Windows$Windows$Storage.Streams.IOutputStream
} & undefined.IOutputStream & undefined.IClosable

	declare export class Compressor mixins undefined.ICompressor, undefined.IOutputStream, undefined.IClosable {
constructor(underlyingStream: Windows$Windows$Storage.Streams.IOutputStream): this;
constructor(underlyingStream: Windows$Windows$Storage.Streams.IOutputStream, algorithm: Windows$Windows$Storage.Compression.CompressAlgorithm, blockSize: number): this;
finishAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
detachStream(): Windows$Windows$Storage.Streams.IOutputStream;
writeAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
flushAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
dispose(): void;
close(): void
}
	declare export type IDecompressor = {
detachStream(): Windows$Windows$Storage.Streams.IInputStream
} & undefined.IInputStream & undefined.IClosable

	declare export class Decompressor mixins undefined.IDecompressor, undefined.IInputStream, undefined.IClosable {
constructor(underlyingStream: Windows$Windows$Storage.Streams.IInputStream): this;
detachStream(): Windows$Windows$Storage.Streams.IInputStream;
readAsync(
buffer: Windows$Windows$Storage.Streams.IBuffer,
count: number,
options: Windows$Windows$Storage.Streams.InputStreamOptions): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Storage.Streams.IBuffer, number>;
dispose(): void;
close(): void
}
	declare export interface ICompressorFactory {
createCompressor(
underlyingStream: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Storage.Compression.Compressor,
createCompressorEx(
underlyingStream: Windows$Windows$Storage.Streams.IOutputStream,
algorithm: Windows$Windows$Storage.Compression.CompressAlgorithm,
blockSize: number): Windows$Windows$Storage.Compression.Compressor
} 
	declare export interface IDecompressorFactory {
createDecompressor(
underlyingStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Storage.Compression.Decompressor
} 
    }

    }


declare module 'System' {
        declare module 'Profile' {
        declare export interface IHardwareToken {
certificate: Windows$Windows$Storage.Streams.IBuffer,
id: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class HardwareToken mixins undefined.IHardwareToken {
certificate: Windows$Windows$Storage.Streams.IBuffer;
id: Windows$Windows$Storage.Streams.IBuffer;
signature: Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHardwareIdentificationStatics {
getPackageSpecificToken(
nonce: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$System.Profile.HardwareToken
} 
	declare export class HardwareIdentification  {
static getPackageSpecificToken(
nonce: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$System.Profile.HardwareToken
}
    }

	declare module 'Threading' {
        declare export  class WorkItemPriority {
  constructor(...args: empty): mixed;
static +low: Class<WorkItemPriority__low> & WorkItemPriority__low & 0;// 0
static +normal: Class<WorkItemPriority__normal> & WorkItemPriority__normal & 1;// 1
static +high: Class<WorkItemPriority__high> & WorkItemPriority__high & 2;// 2

}

declare class WorkItemPriority__low mixins WorkItemPriority {}
declare class WorkItemPriority__normal mixins WorkItemPriority {}
declare class WorkItemPriority__high mixins WorkItemPriority {}

	declare export  class WorkItemOptions {
  constructor(...args: empty): mixed;
static +none: Class<WorkItemOptions__none> & WorkItemOptions__none & 0;// 0
static +timeSliced: Class<WorkItemOptions__timeSliced> & WorkItemOptions__timeSliced & 1;// 1

}

declare class WorkItemOptions__none mixins WorkItemOptions {}
declare class WorkItemOptions__timeSliced mixins WorkItemOptions {}

	declare export interface TimerElapsedHandler {
(timer: Windows$Windows$System.Threading.ThreadPoolTimer): void
} 
	declare export class ThreadPoolTimer mixins undefined.IThreadPoolTimer {
delay: number;
period: number;
cancel(): void;
static createPeriodicTimer(
handler: Windows$Windows$System.Threading.TimerElapsedHandler,
period: number): Windows$Windows$System.Threading.ThreadPoolTimer;
static createTimer(
handler: Windows$Windows$System.Threading.TimerElapsedHandler,
delay: number): Windows$Windows$System.Threading.ThreadPoolTimer;
static createPeriodicTimer(
handler: Windows$Windows$System.Threading.TimerElapsedHandler,
period: number,
destroyed: Windows$Windows$System.Threading.TimerDestroyedHandler): Windows$Windows$System.Threading.ThreadPoolTimer;
static createTimer(
handler: Windows$Windows$System.Threading.TimerElapsedHandler,
delay: number,
destroyed: Windows$Windows$System.Threading.TimerDestroyedHandler): Windows$Windows$System.Threading.ThreadPoolTimer
}
	declare export interface TimerDestroyedHandler {
(timer: Windows$Windows$System.Threading.ThreadPoolTimer): void
} 
	declare export interface WorkItemHandler {
(operation: Windows$Windows$Foundation.IAsyncAction): void
} 
	declare export interface IThreadPoolStatics {
runAsync(
handler: Windows$Windows$System.Threading.WorkItemHandler): Windows$Windows$Foundation.IAsyncAction,
runAsync(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority): Windows$Windows$Foundation.IAsyncAction,
runAsync(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority,
options: Windows$Windows$System.Threading.WorkItemOptions): Windows$Windows$Foundation.IAsyncAction
} 
	declare export interface IThreadPoolTimer {
delay: number,
period: number,
cancel(): void
} 
	declare export interface IThreadPoolTimerStatics {
createPeriodicTimer(
handler: Windows$Windows$System.Threading.TimerElapsedHandler,
period: number): Windows$Windows$System.Threading.ThreadPoolTimer,
createTimer(
handler: Windows$Windows$System.Threading.TimerElapsedHandler,
delay: number): Windows$Windows$System.Threading.ThreadPoolTimer,
createPeriodicTimer(
handler: Windows$Windows$System.Threading.TimerElapsedHandler,
period: number,
destroyed: Windows$Windows$System.Threading.TimerDestroyedHandler): Windows$Windows$System.Threading.ThreadPoolTimer,
createTimer(
handler: Windows$Windows$System.Threading.TimerElapsedHandler,
delay: number,
destroyed: Windows$Windows$System.Threading.TimerDestroyedHandler): Windows$Windows$System.Threading.ThreadPoolTimer
} 
	declare export class ThreadPool  {
static runAsync(
handler: Windows$Windows$System.Threading.WorkItemHandler): Windows$Windows$Foundation.IAsyncAction;
static runAsync(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority): Windows$Windows$Foundation.IAsyncAction;
static runAsync(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority,
options: Windows$Windows$System.Threading.WorkItemOptions): Windows$Windows$Foundation.IAsyncAction
}
	declare module 'Core' {
        declare export class CoreApplication  {
static mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>;
static id: string;
static properties: Windows$Windows$Foundation.Collections.IPropertySet;
static incrementApplicationUseCount(): void;
static decrementApplicationUseCount(): void;
static createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static exit(): void;
static onexiting: any;
static onsuspending: any;
static onresuming: any;
static getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void;
static runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
}
	declare export class CoreApplicationView mixins undefined.ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow;
isHosted: boolean;
isMain: boolean;
onactivated: any
}
	declare export interface IFrameworkView {
initialize(
applicationView: Windows$Windows$ApplicationModel.Core.CoreApplicationView): void,
setWindow(window: Windows$Windows$UI.Core.CoreWindow): void,
load(entryPoint: string): void,
run(): void,
uninitialize(): void
} 
	declare export interface IFrameworkViewSource {
createView(): Windows$Windows$ApplicationModel.Core.IFrameworkView
} 
	declare export interface ICoreApplication {
id: string,
properties: Windows$Windows$Foundation.Collections.IPropertySet,
onsuspending: any,
onresuming: any,
getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView,
run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void,
runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
} 
	declare export interface ICoreApplicationUseCount {
incrementApplicationUseCount(): void,
decrementApplicationUseCount(): void
} 
	declare export interface ICoreApplicationExit {
exit(): void,
onexiting: any
} 
	declare export interface ICoreImmersiveApplication {
mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView,
views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>,
createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView
} 
	declare export interface ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow,
isHosted: boolean,
isMain: boolean,
onactivated: any
} 
	declare export interface IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext,
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap,
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void,
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void
} 
	declare export class ResourceMap mixins undefined.IResourceMap, undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
uri: Windows$Windows$Foundation.Uri;
size: number;
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.NamedResource;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>
}
	declare export class ResourceContext mixins undefined.IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>;
reset(): void;
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void;
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void;
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
static createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
}
	declare export interface IResourceManagerStatics {
current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager,
isResourceReference(resourceReference: string): boolean
} 
	declare export class ResourceManager mixins undefined.IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
static current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager;
static isResourceReference(resourceReference: string): boolean
}
	declare export interface IResourceQualifier {
isDefault: boolean,
isMatch: boolean,
qualifierName: string,
qualifierValue: string,
score: number
} 
	declare export class ResourceQualifier mixins undefined.IResourceQualifier {
isDefault: boolean;
isMatch: boolean;
qualifierName: string;
qualifierValue: string;
score: number
}
	declare export interface IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>,
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>,
reset(): void,
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void,
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void,
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceContextStatics {
createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceCandidate {
isDefault: boolean,
isMatch: boolean,
isMatchAsDefault: boolean,
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>,
valueAsString: string,
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
getQualifierValue(qualifierName: string): string
} 
	declare export class ResourceCandidate mixins undefined.IResourceCandidate {
isDefault: boolean;
isMatch: boolean;
isMatchAsDefault: boolean;
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
valueAsString: string;
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
getQualifierValue(qualifierName: string): string
}
	declare export interface INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
uri: Windows$Windows$Foundation.Uri,
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
} 
	declare export class NamedResource mixins undefined.INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
uri: Windows$Windows$Foundation.Uri;
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
}
	declare export type IResourceMap = {
uri: Windows$Windows$Foundation.Uri,
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap
} & undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource> & undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>

	declare export class ResourceMapIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>[],
returnValue: number
}
}
	declare export class ResourceMapMapView mixins undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
size: number;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>>
}
	declare export class ResourceMapMapViewIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>[],
returnValue: number
}
}
	declare export class ResourceQualifierObservableMap mixins undefined.IObservableMap<string, string>, undefined.IMap<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
onmapchanged: any;
lookup(key: string): string;
hasKey(key: string): boolean;
getView(): Windows$Windows$Foundation.Collections.IMapView<string, string>;
insert(key: string, value: string): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierMapView mixins undefined.IMapView<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
lookup(key: string): string;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, string>,
second: Windows$Windows$Foundation.Collections.IMapView<string, string>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceCandidateVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceContextLanguagesVectorView mixins undefined.IVectorView<string>, undefined.IIterable<string> {
size: number;
getAt(index: number): string;
indexOf(value: string): {
index: number,
returnValue: boolean
};
getMany(startIndex: number): {
items: string[],
returnValue: number
};
first(): Windows$Windows$Foundation.Collections.IIterator<string>;
toString(): string;
toLocaleString(): string;
concat(...items: string[][]): string[];
join(seperator: string): string;
pop(): string;
push(...items: string[]): void;
reverse(): string[];
shift(): string;
slice(start: number): string[];
slice(start: number, end: number): string[];
sort(): string[];
sort(compareFn: (a: string, b: string) => number): string[];
splice(start: number): string[];
splice(start: number, deleteCount: number, ...items: string[]): string[];
unshift(...items: string[]): number;
lastIndexOf(searchElement: string): number;
lastIndexOf(searchElement: string, fromIndex: number): number;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
forEach(callbackfn: (value: string, index: number, array: string[]) => void): void;
forEach(
callbackfn: (value: string, index: number, array: string[]) => void,
thisArg: any): void;
map(callbackfn: (value: string, index: number, array: string[]) => any): any[];
map(
callbackfn: (value: string, index: number, array: string[]) => any,
thisArg: any): any[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean): string[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): string[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
length: number
}
	declare export interface IApplicationDataManagerStatics {
createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
} 
	declare export interface IApplicationDataManager {} 
	declare export class ApplicationDataManager mixins undefined.IApplicationDataManager {
static createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
}
	declare export  class CryptographicPrivateKeyBlobType {
  constructor(...args: empty): mixed;
static +pkcs8RawPrivateKeyInfo: Class<CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo> & CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo & 0;// 0
static +pkcs1RsaPrivateKey: Class<CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey> & CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey & 1;// 1
static +bCryptPrivateKey: Class<CryptographicPrivateKeyBlobType__bCryptPrivateKey> & CryptographicPrivateKeyBlobType__bCryptPrivateKey & 2;// 2
static +capi1PrivateKey: Class<CryptographicPrivateKeyBlobType__capi1PrivateKey> & CryptographicPrivateKeyBlobType__capi1PrivateKey & 3;// 3

}

declare class CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__bCryptPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__capi1PrivateKey mixins CryptographicPrivateKeyBlobType {}

	declare export  class CryptographicPublicKeyBlobType {
  constructor(...args: empty): mixed;
static +x509SubjectPublicKeyInfo: Class<CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo> & CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo & 0;// 0
static +pkcs1RsaPublicKey: Class<CryptographicPublicKeyBlobType__pkcs1RsaPublicKey> & CryptographicPublicKeyBlobType__pkcs1RsaPublicKey & 1;// 1
static +bCryptPublicKey: Class<CryptographicPublicKeyBlobType__bCryptPublicKey> & CryptographicPublicKeyBlobType__bCryptPublicKey & 2;// 2
static +capi1PublicKey: Class<CryptographicPublicKeyBlobType__capi1PublicKey> & CryptographicPublicKeyBlobType__capi1PublicKey & 3;// 3

}

declare class CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__pkcs1RsaPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__bCryptPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__capi1PublicKey mixins CryptographicPublicKeyBlobType {}

	declare export interface IKeyDerivationParameters {
iterationCount: number,
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export interface IKeyDerivationParametersStatics {
buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
} 
	declare export class KeyDerivationParameters mixins undefined.IKeyDerivationParameters {
iterationCount: number;
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer;
static buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
}
	declare export interface ICryptographicKey {
keySize: number,
export(): Windows$Windows$Storage.Streams.IBuffer,
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicKey mixins undefined.ICryptographicKey {
keySize: number;
export(): Windows$Windows$Storage.Streams.IBuffer;
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void,
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicHash mixins undefined.IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void;
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProvider {
algorithmName: string,
hashLength: number,
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash
} 
	declare export interface IMacAlgorithmProvider {
algorithmName: string,
macLength: number,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IKeyDerivationAlgorithmProvider {
algorithmName: string,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface ISymmetricKeyAlgorithmProvider {
algorithmName: string,
blockLength: number,
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IAsymmetricKeyAlgorithmProvider {
algorithmName: string,
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
encryptedData: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class EncryptedAndAuthenticatedData mixins undefined.IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer;
encryptedData: Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface ICryptographicEngineStatics {
encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData,
decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean,
deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicEngine  {
static encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData;
static decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean;
static deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
} 
	declare export class HashAlgorithmProvider mixins undefined.IHashAlgorithmProvider {
algorithmName: string;
hashLength: number;
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
}
	declare export interface IMacAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
} 
	declare export class MacAlgorithmProvider mixins undefined.IMacAlgorithmProvider {
algorithmName: string;
macLength: number;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
}
	declare export interface IKeyDerivationAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
} 
	declare export class KeyDerivationAlgorithmProvider mixins undefined.IKeyDerivationAlgorithmProvider {
algorithmName: string;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
}
	declare export interface ISymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
} 
	declare export class SymmetricKeyAlgorithmProvider mixins undefined.ISymmetricKeyAlgorithmProvider {
algorithmName: string;
blockLength: number;
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
}
	declare export interface IAsymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
} 
	declare export class AsymmetricKeyAlgorithmProvider mixins undefined.IAsymmetricKeyAlgorithmProvider {
algorithmName: string;
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
}
	declare export interface IHashAlgorithmNamesStatics {
md5: string,
sha1: string,
sha256: string,
sha384: string,
sha512: string
} 
	declare export class HashAlgorithmNames  {
static md5: string;
static sha1: string;
static sha256: string;
static sha384: string;
static sha512: string
}
	declare export interface IMacAlgorithmNamesStatics {
aesCmac: string,
hmacMd5: string,
hmacSha1: string,
hmacSha256: string,
hmacSha384: string,
hmacSha512: string
} 
	declare export class MacAlgorithmNames  {
static aesCmac: string;
static hmacMd5: string;
static hmacSha1: string;
static hmacSha256: string;
static hmacSha384: string;
static hmacSha512: string
}
	declare export interface ISymmetricAlgorithmNamesStatics {
aesCbc: string,
aesCbcPkcs7: string,
aesCcm: string,
aesEcb: string,
aesEcbPkcs7: string,
aesGcm: string,
desCbc: string,
desCbcPkcs7: string,
desEcb: string,
desEcbPkcs7: string,
rc2Cbc: string,
rc2CbcPkcs7: string,
rc2Ecb: string,
rc2EcbPkcs7: string,
rc4: string,
tripleDesCbc: string,
tripleDesCbcPkcs7: string,
tripleDesEcb: string,
tripleDesEcbPkcs7: string
} 
	declare export class SymmetricAlgorithmNames  {
static aesCbc: string;
static aesCbcPkcs7: string;
static aesCcm: string;
static aesEcb: string;
static aesEcbPkcs7: string;
static aesGcm: string;
static desCbc: string;
static desCbcPkcs7: string;
static desEcb: string;
static desEcbPkcs7: string;
static rc2Cbc: string;
static rc2CbcPkcs7: string;
static rc2Ecb: string;
static rc2EcbPkcs7: string;
static rc4: string;
static tripleDesCbc: string;
static tripleDesCbcPkcs7: string;
static tripleDesEcb: string;
static tripleDesEcbPkcs7: string
}
	declare export interface IAsymmetricAlgorithmNamesStatics {
dsaSha1: string,
dsaSha256: string,
ecdsaP256Sha256: string,
ecdsaP384Sha384: string,
ecdsaP521Sha512: string,
rsaOaepSha1: string,
rsaOaepSha256: string,
rsaOaepSha384: string,
rsaOaepSha512: string,
rsaPkcs1: string,
rsaSignPkcs1Sha1: string,
rsaSignPkcs1Sha256: string,
rsaSignPkcs1Sha384: string,
rsaSignPkcs1Sha512: string,
rsaSignPssSha1: string,
rsaSignPssSha256: string,
rsaSignPssSha384: string,
rsaSignPssSha512: string
} 
	declare export class AsymmetricAlgorithmNames  {
static dsaSha1: string;
static dsaSha256: string;
static ecdsaP256Sha256: string;
static ecdsaP384Sha384: string;
static ecdsaP521Sha512: string;
static rsaOaepSha1: string;
static rsaOaepSha256: string;
static rsaOaepSha384: string;
static rsaOaepSha512: string;
static rsaPkcs1: string;
static rsaSignPkcs1Sha1: string;
static rsaSignPkcs1Sha256: string;
static rsaSignPkcs1Sha384: string;
static rsaSignPkcs1Sha512: string;
static rsaSignPssSha1: string;
static rsaSignPssSha256: string;
static rsaSignPssSha384: string;
static rsaSignPssSha512: string
}
	declare export interface IKeyDerivationAlgorithmNamesStatics {
pbkdf2Md5: string,
pbkdf2Sha1: string,
pbkdf2Sha256: string,
pbkdf2Sha384: string,
pbkdf2Sha512: string,
sp800108CtrHmacMd5: string,
sp800108CtrHmacSha1: string,
sp800108CtrHmacSha256: string,
sp800108CtrHmacSha384: string,
sp800108CtrHmacSha512: string,
sp80056aConcatMd5: string,
sp80056aConcatSha1: string,
sp80056aConcatSha256: string,
sp80056aConcatSha384: string,
sp80056aConcatSha512: string
} 
	declare export class KeyDerivationAlgorithmNames  {
static pbkdf2Md5: string;
static pbkdf2Sha1: string;
static pbkdf2Sha256: string;
static pbkdf2Sha384: string;
static pbkdf2Sha512: string;
static sp800108CtrHmacMd5: string;
static sp800108CtrHmacSha1: string;
static sp800108CtrHmacSha256: string;
static sp800108CtrHmacSha384: string;
static sp800108CtrHmacSha512: string;
static sp80056aConcatMd5: string;
static sp80056aConcatSha1: string;
static sp80056aConcatSha256: string;
static sp80056aConcatSha384: string;
static sp80056aConcatSha512: string
}
	declare export interface SignalHandler {
(signalNotifier: Windows$Windows$System.Threading.Core.SignalNotifier, timedOut: boolean): void
} 
	declare export class SignalNotifier mixins undefined.ISignalNotifier {
enable(): void;
terminate(): void;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
}
	declare export interface ISignalNotifierStatics {
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
} 
	declare export interface IPreallocatedWorkItemFactory {
createWorkItem(
handler: Windows$Windows$System.Threading.WorkItemHandler): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriority(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriorityAndOptions(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority,
options: Windows$Windows$System.Threading.WorkItemOptions): Windows$Windows$System.Threading.Core.PreallocatedWorkItem
} 
	declare export class PreallocatedWorkItem mixins undefined.IPreallocatedWorkItem {
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority, options: Windows$Windows$System.Threading.WorkItemOptions): this;
runAsync(): Windows$Windows$Foundation.IAsyncAction
}
	declare export interface IPreallocatedWorkItem {
runAsync(): Windows$Windows$Foundation.IAsyncAction
} 
	declare export interface ISignalNotifier {
enable(): void,
terminate(): void
} 
	declare module 'AnimationMetrics' {
        declare export  class PropertyAnimationType {
  constructor(...args: empty): mixed;
static +scale: Class<PropertyAnimationType__scale> & PropertyAnimationType__scale & 0;// 0
static +translation: Class<PropertyAnimationType__translation> & PropertyAnimationType__translation & 1;// 1
static +opacity: Class<PropertyAnimationType__opacity> & PropertyAnimationType__opacity & 2;// 2

}

declare class PropertyAnimationType__scale mixins PropertyAnimationType {}
declare class PropertyAnimationType__translation mixins PropertyAnimationType {}
declare class PropertyAnimationType__opacity mixins PropertyAnimationType {}

	declare export interface IPropertyAnimation {
control1: Windows$Windows$Foundation.Point,
control2: Windows$Windows$Foundation.Point,
delay: number,
duration: number,
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
} 
	declare export type IScaleAnimation = {
finalScaleX: number,
finalScaleY: number,
initialScaleX: number,
initialScaleY: number,
normalizedOrigin: Windows$Windows$Foundation.Point
} & undefined.IPropertyAnimation

	declare export type IOpacityAnimation = {
finalOpacity: number,
initialOpacity: number
} & undefined.IPropertyAnimation

	declare export  class AnimationEffect {
  constructor(...args: empty): mixed;
static +expand: Class<AnimationEffect__expand> & AnimationEffect__expand & 0;// 0
static +collapse: Class<AnimationEffect__collapse> & AnimationEffect__collapse & 1;// 1
static +reposition: Class<AnimationEffect__reposition> & AnimationEffect__reposition & 2;// 2
static +fadeIn: Class<AnimationEffect__fadeIn> & AnimationEffect__fadeIn & 3;// 3
static +fadeOut: Class<AnimationEffect__fadeOut> & AnimationEffect__fadeOut & 4;// 4
static +addToList: Class<AnimationEffect__addToList> & AnimationEffect__addToList & 5;// 5
static +deleteFromList: Class<AnimationEffect__deleteFromList> & AnimationEffect__deleteFromList & 6;// 6
static +addToGrid: Class<AnimationEffect__addToGrid> & AnimationEffect__addToGrid & 7;// 7
static +deleteFromGrid: Class<AnimationEffect__deleteFromGrid> & AnimationEffect__deleteFromGrid & 8;// 8
static +addToSearchGrid: Class<AnimationEffect__addToSearchGrid> & AnimationEffect__addToSearchGrid & 9;// 9
static +deleteFromSearchGrid: Class<AnimationEffect__deleteFromSearchGrid> & AnimationEffect__deleteFromSearchGrid & 10;// 10
static +addToSearchList: Class<AnimationEffect__addToSearchList> & AnimationEffect__addToSearchList & 11;// 11
static +deleteFromSearchList: Class<AnimationEffect__deleteFromSearchList> & AnimationEffect__deleteFromSearchList & 12;// 12
static +showEdgeUI: Class<AnimationEffect__showEdgeUI> & AnimationEffect__showEdgeUI & 13;// 13
static +showPanel: Class<AnimationEffect__showPanel> & AnimationEffect__showPanel & 14;// 14
static +hideEdgeUI: Class<AnimationEffect__hideEdgeUI> & AnimationEffect__hideEdgeUI & 15;// 15
static +hidePanel: Class<AnimationEffect__hidePanel> & AnimationEffect__hidePanel & 16;// 16
static +showPopup: Class<AnimationEffect__showPopup> & AnimationEffect__showPopup & 17;// 17
static +hidePopup: Class<AnimationEffect__hidePopup> & AnimationEffect__hidePopup & 18;// 18
static +pointerDown: Class<AnimationEffect__pointerDown> & AnimationEffect__pointerDown & 19;// 19
static +pointerUp: Class<AnimationEffect__pointerUp> & AnimationEffect__pointerUp & 20;// 20
static +dragSourceStart: Class<AnimationEffect__dragSourceStart> & AnimationEffect__dragSourceStart & 21;// 21
static +dragSourceEnd: Class<AnimationEffect__dragSourceEnd> & AnimationEffect__dragSourceEnd & 22;// 22
static +transitionContent: Class<AnimationEffect__transitionContent> & AnimationEffect__transitionContent & 23;// 23
static +reveal: Class<AnimationEffect__reveal> & AnimationEffect__reveal & 24;// 24
static +hide: Class<AnimationEffect__hide> & AnimationEffect__hide & 25;// 25
static +dragBetweenEnter: Class<AnimationEffect__dragBetweenEnter> & AnimationEffect__dragBetweenEnter & 26;// 26
static +dragBetweenLeave: Class<AnimationEffect__dragBetweenLeave> & AnimationEffect__dragBetweenLeave & 27;// 27
static +swipeSelect: Class<AnimationEffect__swipeSelect> & AnimationEffect__swipeSelect & 28;// 28
static +swipeDeselect: Class<AnimationEffect__swipeDeselect> & AnimationEffect__swipeDeselect & 29;// 29
static +swipeReveal: Class<AnimationEffect__swipeReveal> & AnimationEffect__swipeReveal & 30;// 30
static +enterPage: Class<AnimationEffect__enterPage> & AnimationEffect__enterPage & 31;// 31
static +transitionPage: Class<AnimationEffect__transitionPage> & AnimationEffect__transitionPage & 32;// 32
static +crossFade: Class<AnimationEffect__crossFade> & AnimationEffect__crossFade & 33;// 33
static +peek: Class<AnimationEffect__peek> & AnimationEffect__peek & 34;// 34
static +updateBadge: Class<AnimationEffect__updateBadge> & AnimationEffect__updateBadge & 35;// 35

}

declare class AnimationEffect__expand mixins AnimationEffect {}
declare class AnimationEffect__collapse mixins AnimationEffect {}
declare class AnimationEffect__reposition mixins AnimationEffect {}
declare class AnimationEffect__fadeIn mixins AnimationEffect {}
declare class AnimationEffect__fadeOut mixins AnimationEffect {}
declare class AnimationEffect__addToList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromList mixins AnimationEffect {}
declare class AnimationEffect__addToGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchList mixins AnimationEffect {}
declare class AnimationEffect__showEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__showPanel mixins AnimationEffect {}
declare class AnimationEffect__hideEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__hidePanel mixins AnimationEffect {}
declare class AnimationEffect__showPopup mixins AnimationEffect {}
declare class AnimationEffect__hidePopup mixins AnimationEffect {}
declare class AnimationEffect__pointerDown mixins AnimationEffect {}
declare class AnimationEffect__pointerUp mixins AnimationEffect {}
declare class AnimationEffect__dragSourceStart mixins AnimationEffect {}
declare class AnimationEffect__dragSourceEnd mixins AnimationEffect {}
declare class AnimationEffect__transitionContent mixins AnimationEffect {}
declare class AnimationEffect__reveal mixins AnimationEffect {}
declare class AnimationEffect__hide mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenEnter mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenLeave mixins AnimationEffect {}
declare class AnimationEffect__swipeSelect mixins AnimationEffect {}
declare class AnimationEffect__swipeDeselect mixins AnimationEffect {}
declare class AnimationEffect__swipeReveal mixins AnimationEffect {}
declare class AnimationEffect__enterPage mixins AnimationEffect {}
declare class AnimationEffect__transitionPage mixins AnimationEffect {}
declare class AnimationEffect__crossFade mixins AnimationEffect {}
declare class AnimationEffect__peek mixins AnimationEffect {}
declare class AnimationEffect__updateBadge mixins AnimationEffect {}

	declare export  class AnimationEffectTarget {
  constructor(...args: empty): mixed;
static +primary: Class<AnimationEffectTarget__primary> & AnimationEffectTarget__primary & 0;// 0
static +added: Class<AnimationEffectTarget__added> & AnimationEffectTarget__added & 1;// 1
static +affected: Class<AnimationEffectTarget__affected> & AnimationEffectTarget__affected & 2;// 2
static +background: Class<AnimationEffectTarget__background> & AnimationEffectTarget__background & 3;// 3
static +content: Class<AnimationEffectTarget__content> & AnimationEffectTarget__content & 4;// 4
static +deleted: Class<AnimationEffectTarget__deleted> & AnimationEffectTarget__deleted & 5;// 5
static +deselected: Class<AnimationEffectTarget__deselected> & AnimationEffectTarget__deselected & 6;// 6
static +dragSource: Class<AnimationEffectTarget__dragSource> & AnimationEffectTarget__dragSource & 7;// 7
static +hidden: Class<AnimationEffectTarget__hidden> & AnimationEffectTarget__hidden & 8;// 8
static +incoming: Class<AnimationEffectTarget__incoming> & AnimationEffectTarget__incoming & 9;// 9
static +outgoing: Class<AnimationEffectTarget__outgoing> & AnimationEffectTarget__outgoing & 10;// 10
static +outline: Class<AnimationEffectTarget__outline> & AnimationEffectTarget__outline & 11;// 11
static +remaining: Class<AnimationEffectTarget__remaining> & AnimationEffectTarget__remaining & 12;// 12
static +revealed: Class<AnimationEffectTarget__revealed> & AnimationEffectTarget__revealed & 13;// 13
static +rowIn: Class<AnimationEffectTarget__rowIn> & AnimationEffectTarget__rowIn & 14;// 14
static +rowOut: Class<AnimationEffectTarget__rowOut> & AnimationEffectTarget__rowOut & 15;// 15
static +selected: Class<AnimationEffectTarget__selected> & AnimationEffectTarget__selected & 16;// 16
static +selection: Class<AnimationEffectTarget__selection> & AnimationEffectTarget__selection & 17;// 17
static +shown: Class<AnimationEffectTarget__shown> & AnimationEffectTarget__shown & 18;// 18
static +tapped: Class<AnimationEffectTarget__tapped> & AnimationEffectTarget__tapped & 19;// 19

}

declare class AnimationEffectTarget__primary mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__added mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__affected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__background mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__content mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deleted mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deselected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__dragSource mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__hidden mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__incoming mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outgoing mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outline mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__remaining mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__revealed mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowIn mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowOut mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selection mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__shown mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__tapped mixins AnimationEffectTarget {}

	declare export interface IAnimationDescription {
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>,
delayLimit: number,
staggerDelay: number,
staggerDelayFactor: number,
zOrder: number
} 
	declare export interface IAnimationDescriptionFactory {
createInstance(
effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect,
target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): Windows$Windows$UI.Core.AnimationMetrics.AnimationDescription
} 
	declare export class AnimationDescription mixins undefined.IAnimationDescription {
constructor(effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect, target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): this;
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>;
delayLimit: number;
staggerDelay: number;
staggerDelayFactor: number;
zOrder: number
}
	declare export class PropertyAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class ScaleAnimation mixins undefined.IScaleAnimation, undefined.IPropertyAnimation {
finalScaleX: number;
finalScaleY: number;
initialScaleX: number;
initialScaleY: number;
normalizedOrigin: Windows$Windows$Foundation.Point;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class TranslationAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class OpacityAnimation mixins undefined.IOpacityAnimation, undefined.IPropertyAnimation {
finalOpacity: number;
initialOpacity: number;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
    }

	declare export  class CoreWindowActivationState {
  constructor(...args: empty): mixed;
static +codeActivated: Class<CoreWindowActivationState__codeActivated> & CoreWindowActivationState__codeActivated & 0;// 0
static +deactivated: Class<CoreWindowActivationState__deactivated> & CoreWindowActivationState__deactivated & 1;// 1
static +pointerActivated: Class<CoreWindowActivationState__pointerActivated> & CoreWindowActivationState__pointerActivated & 2;// 2

}

declare class CoreWindowActivationState__codeActivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__deactivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__pointerActivated mixins CoreWindowActivationState {}

	declare export  class CoreCursorType {
  constructor(...args: empty): mixed;
static +arrow: Class<CoreCursorType__arrow> & CoreCursorType__arrow & 0;// 0
static +cross: Class<CoreCursorType__cross> & CoreCursorType__cross & 1;// 1
static +custom: Class<CoreCursorType__custom> & CoreCursorType__custom & 2;// 2
static +hand: Class<CoreCursorType__hand> & CoreCursorType__hand & 3;// 3
static +help: Class<CoreCursorType__help> & CoreCursorType__help & 4;// 4
static +iBeam: Class<CoreCursorType__iBeam> & CoreCursorType__iBeam & 5;// 5
static +sizeAll: Class<CoreCursorType__sizeAll> & CoreCursorType__sizeAll & 6;// 6
static +sizeNortheastSouthwest: Class<CoreCursorType__sizeNortheastSouthwest> & CoreCursorType__sizeNortheastSouthwest & 7;// 7
static +sizeNorthSouth: Class<CoreCursorType__sizeNorthSouth> & CoreCursorType__sizeNorthSouth & 8;// 8
static +sizeNorthwestSoutheast: Class<CoreCursorType__sizeNorthwestSoutheast> & CoreCursorType__sizeNorthwestSoutheast & 9;// 9
static +sizeWestEast: Class<CoreCursorType__sizeWestEast> & CoreCursorType__sizeWestEast & 10;// 10
static +universalNo: Class<CoreCursorType__universalNo> & CoreCursorType__universalNo & 11;// 11
static +upArrow: Class<CoreCursorType__upArrow> & CoreCursorType__upArrow & 12;// 12
static +wait: Class<CoreCursorType__wait> & CoreCursorType__wait & 13;// 13

}

declare class CoreCursorType__arrow mixins CoreCursorType {}
declare class CoreCursorType__cross mixins CoreCursorType {}
declare class CoreCursorType__custom mixins CoreCursorType {}
declare class CoreCursorType__hand mixins CoreCursorType {}
declare class CoreCursorType__help mixins CoreCursorType {}
declare class CoreCursorType__iBeam mixins CoreCursorType {}
declare class CoreCursorType__sizeAll mixins CoreCursorType {}
declare class CoreCursorType__sizeNortheastSouthwest mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthSouth mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthwestSoutheast mixins CoreCursorType {}
declare class CoreCursorType__sizeWestEast mixins CoreCursorType {}
declare class CoreCursorType__universalNo mixins CoreCursorType {}
declare class CoreCursorType__upArrow mixins CoreCursorType {}
declare class CoreCursorType__wait mixins CoreCursorType {}

	declare export  class CoreDispatcherPriority {
  constructor(...args: empty): mixed;
static +low: Class<CoreDispatcherPriority__low> & CoreDispatcherPriority__low & 0;// 0
static +normal: Class<CoreDispatcherPriority__normal> & CoreDispatcherPriority__normal & 1;// 1
static +high: Class<CoreDispatcherPriority__high> & CoreDispatcherPriority__high & 2;// 2

}

declare class CoreDispatcherPriority__low mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__normal mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__high mixins CoreDispatcherPriority {}

	declare export  class CoreProcessEventsOption {
  constructor(...args: empty): mixed;
static +processOneAndAllPending: Class<CoreProcessEventsOption__processOneAndAllPending> & CoreProcessEventsOption__processOneAndAllPending & 0;// 0
static +processOneIfPresent: Class<CoreProcessEventsOption__processOneIfPresent> & CoreProcessEventsOption__processOneIfPresent & 1;// 1
static +processUntilQuit: Class<CoreProcessEventsOption__processUntilQuit> & CoreProcessEventsOption__processUntilQuit & 2;// 2
static +processAllIfPresent: Class<CoreProcessEventsOption__processAllIfPresent> & CoreProcessEventsOption__processAllIfPresent & 3;// 3

}

declare class CoreProcessEventsOption__processOneAndAllPending mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processOneIfPresent mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processUntilQuit mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processAllIfPresent mixins CoreProcessEventsOption {}

	declare export  class CoreWindowFlowDirection {
  constructor(...args: empty): mixed;
static +leftToRight: Class<CoreWindowFlowDirection__leftToRight> & CoreWindowFlowDirection__leftToRight & 0;// 0
static +rightToLeft: Class<CoreWindowFlowDirection__rightToLeft> & CoreWindowFlowDirection__rightToLeft & 1;// 1

}

declare class CoreWindowFlowDirection__leftToRight mixins CoreWindowFlowDirection {}
declare class CoreWindowFlowDirection__rightToLeft mixins CoreWindowFlowDirection {}

	declare export  class CoreVirtualKeyStates {
  constructor(...args: empty): mixed;
static +none: Class<CoreVirtualKeyStates__none> & CoreVirtualKeyStates__none & 0;// 0
static +down: Class<CoreVirtualKeyStates__down> & CoreVirtualKeyStates__down & 1;// 1
static +locked: Class<CoreVirtualKeyStates__locked> & CoreVirtualKeyStates__locked & 2;// 2

}

declare class CoreVirtualKeyStates__none mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__down mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__locked mixins CoreVirtualKeyStates {}

	declare export  class CoreAcceleratorKeyEventType {
  constructor(...args: empty): mixed;
static +character: Class<CoreAcceleratorKeyEventType__character> & CoreAcceleratorKeyEventType__character & 0;// 0
static +deadCharacter: Class<CoreAcceleratorKeyEventType__deadCharacter> & CoreAcceleratorKeyEventType__deadCharacter & 1;// 1
static +keyDown: Class<CoreAcceleratorKeyEventType__keyDown> & CoreAcceleratorKeyEventType__keyDown & 2;// 2
static +keyUp: Class<CoreAcceleratorKeyEventType__keyUp> & CoreAcceleratorKeyEventType__keyUp & 3;// 3
static +systemCharacter: Class<CoreAcceleratorKeyEventType__systemCharacter> & CoreAcceleratorKeyEventType__systemCharacter & 4;// 4
static +systemDeadCharacter: Class<CoreAcceleratorKeyEventType__systemDeadCharacter> & CoreAcceleratorKeyEventType__systemDeadCharacter & 5;// 5
static +systemKeyDown: Class<CoreAcceleratorKeyEventType__systemKeyDown> & CoreAcceleratorKeyEventType__systemKeyDown & 6;// 6
static +systemKeyUp: Class<CoreAcceleratorKeyEventType__systemKeyUp> & CoreAcceleratorKeyEventType__systemKeyUp & 7;// 7
static +unicodeCharacter: Class<CoreAcceleratorKeyEventType__unicodeCharacter> & CoreAcceleratorKeyEventType__unicodeCharacter & 8;// 8

}

declare class CoreAcceleratorKeyEventType__character mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__deadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemDeadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__unicodeCharacter mixins CoreAcceleratorKeyEventType {}

	declare export  class CoreProximityEvaluationScore {
  constructor(...args: empty): mixed;
static +closest: Class<CoreProximityEvaluationScore__closest> & CoreProximityEvaluationScore__closest & 0;// 0
static +farthest: Class<CoreProximityEvaluationScore__farthest> & CoreProximityEvaluationScore__farthest & 1;// 1

}

declare class CoreProximityEvaluationScore__closest mixins CoreProximityEvaluationScore {}
declare class CoreProximityEvaluationScore__farthest mixins CoreProximityEvaluationScore {}

	declare export interface CorePhysicalKeyStatus {
repeatCount: number,
scanCode: number,
isExtendedKey: boolean,
isMenuKeyDown: boolean,
wasKeyDown: boolean,
isKeyReleased: boolean
} 
	declare export interface CoreProximityEvaluation {
score: number,
adjustedPoint: Windows$Windows$Foundation.Point
} 
	declare export interface ICoreWindowEventArgs {
handled: boolean
} 
	declare export type IAutomationProviderRequestedEventArgs = {
automationProvider: any
} & undefined.ICoreWindowEventArgs

	declare export type ICharacterReceivedEventArgs = {
keyCode: number,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus
} & undefined.ICoreWindowEventArgs

	declare export type IInputEnabledEventArgs = {
inputEnabled: boolean
} & undefined.ICoreWindowEventArgs

	declare export type IKeyEventArgs = {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export type IPointerEventArgs = {
currentPoint: Windows$Windows$UI.Input.PointerPoint,
keyModifiers: Windows$Windows$System.VirtualKeyModifiers,
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
} & undefined.ICoreWindowEventArgs

	declare export type ITouchHitTestingEventArgs = {
boundingBox: Windows$Windows$Foundation.Rect,
point: Windows$Windows$Foundation.Point,
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
} & undefined.ICoreWindowEventArgs

	declare export type IWindowActivatedEventArgs = {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState
} & undefined.ICoreWindowEventArgs

	declare export type IWindowSizeChangedEventArgs = {
size: Windows$Windows$Foundation.Size
} & undefined.ICoreWindowEventArgs

	declare export type IVisibilityChangedEventArgs = {
visible: boolean
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreWindow {
automationHostProvider: any,
bounds: Windows$Windows$Foundation.Rect,
customProperties: Windows$Windows$Foundation.Collections.IPropertySet,
dispatcher: Windows$Windows$UI.Core.CoreDispatcher,
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection,
isInputEnabled: boolean,
pointerCursor: Windows$Windows$UI.Core.CoreCursor,
pointerPosition: Windows$Windows$Foundation.Point,
visible: boolean,
activate(): void,
close(): void,
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
releasePointerCapture(): void,
setPointerCapture(): void,
onactivated: any,
onautomationproviderrequested: any,
oncharacterreceived: any,
onclosed: any,
oninputenabled: any,
onkeydown: any,
onkeyup: any,
onpointercapturelost: any,
onpointerentered: any,
onpointerexited: any,
onpointermoved: any,
onpointerpressed: any,
onpointerreleased: any,
ontouchhittesting: any,
onpointerwheelchanged: any,
onsizechanged: any,
onvisibilitychanged: any
} 
	declare export class CoreDispatcher mixins undefined.ICoreDispatcher, undefined.ICoreAcceleratorKeys {
hasThreadAccess: boolean;
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void;
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
onacceleratorkeyactivated: any
}
	declare export class CoreCursor mixins undefined.ICoreCursor {
constructor(type: Windows$Windows$UI.Core.CoreCursorType, id: number): this;
id: number;
type: Windows$Windows$UI.Core.CoreCursorType
}
	declare export class CoreWindow mixins undefined.ICoreWindow {
automationHostProvider: any;
bounds: Windows$Windows$Foundation.Rect;
customProperties: Windows$Windows$Foundation.Collections.IPropertySet;
dispatcher: Windows$Windows$UI.Core.CoreDispatcher;
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection;
isInputEnabled: boolean;
pointerCursor: Windows$Windows$UI.Core.CoreCursor;
pointerPosition: Windows$Windows$Foundation.Point;
visible: boolean;
activate(): void;
close(): void;
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
releasePointerCapture(): void;
setPointerCapture(): void;
onactivated: any;
onautomationproviderrequested: any;
oncharacterreceived: any;
onclosed: any;
oninputenabled: any;
onkeydown: any;
onkeyup: any;
onpointercapturelost: any;
onpointerentered: any;
onpointerexited: any;
onpointermoved: any;
onpointerpressed: any;
onpointerreleased: any;
ontouchhittesting: any;
onpointerwheelchanged: any;
onsizechanged: any;
onvisibilitychanged: any;
static getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
}
	declare export class WindowActivatedEventArgs mixins undefined.IWindowActivatedEventArgs, undefined.ICoreWindowEventArgs {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState;
handled: boolean
}
	declare export class AutomationProviderRequestedEventArgs mixins undefined.IAutomationProviderRequestedEventArgs, undefined.ICoreWindowEventArgs {
automationProvider: any;
handled: boolean
}
	declare export class CharacterReceivedEventArgs mixins undefined.ICharacterReceivedEventArgs, undefined.ICoreWindowEventArgs {
keyCode: number;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
handled: boolean
}
	declare export class CoreWindowEventArgs mixins undefined.ICoreWindowEventArgs {
handled: boolean
}
	declare export class InputEnabledEventArgs mixins undefined.IInputEnabledEventArgs, undefined.ICoreWindowEventArgs {
inputEnabled: boolean;
handled: boolean
}
	declare export class KeyEventArgs mixins undefined.IKeyEventArgs, undefined.ICoreWindowEventArgs {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export class PointerEventArgs mixins undefined.IPointerEventArgs, undefined.ICoreWindowEventArgs {
currentPoint: Windows$Windows$UI.Input.PointerPoint;
keyModifiers: Windows$Windows$System.VirtualKeyModifiers;
handled: boolean;
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
}
	declare export class TouchHitTestingEventArgs mixins undefined.ITouchHitTestingEventArgs, undefined.ICoreWindowEventArgs {
boundingBox: Windows$Windows$Foundation.Rect;
point: Windows$Windows$Foundation.Point;
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation;
handled: boolean;
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation;
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
}
	declare export class WindowSizeChangedEventArgs mixins undefined.IWindowSizeChangedEventArgs, undefined.ICoreWindowEventArgs {
size: Windows$Windows$Foundation.Size;
handled: boolean
}
	declare export class VisibilityChangedEventArgs mixins undefined.IVisibilityChangedEventArgs, undefined.ICoreWindowEventArgs {
visible: boolean;
handled: boolean
}
	declare export interface ICoreWindowStatic {
getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
} 
	declare export interface DispatchedHandler {
(): void
} 
	declare export interface IdleDispatchedHandler {
(e: Windows$Windows$UI.Core.IdleDispatchedHandlerArgs): void
} 
	declare export class IdleDispatchedHandlerArgs mixins undefined.IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
}
	declare export type IAcceleratorKeyEventArgs = {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
} 
	declare export class AcceleratorKeyEventArgs mixins undefined.IAcceleratorKeyEventArgs, undefined.ICoreWindowEventArgs {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export type ICoreDispatcher = {
hasThreadAccess: boolean,
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void,
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction,
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction
} & undefined.ICoreAcceleratorKeys

	declare export interface IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
} 
	declare export class CoreAcceleratorKeys mixins undefined.ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
}
	declare export interface ICoreCursor {
id: number,
type: Windows$Windows$UI.Core.CoreCursorType
} 
	declare export interface ICoreCursorFactory {
createCursor(
type: Windows$Windows$UI.Core.CoreCursorType,
id: number): Windows$Windows$UI.Core.CoreCursor
} 
	declare export interface IInitializeWithCoreWindow {
initialize(window: Windows$Windows$UI.Core.CoreWindow): void
} 
	declare export interface ICoreWindowResizeManager {
notifyLayoutCompleted(): void
} 
	declare export interface ICoreWindowResizeManagerStatics {
getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
} 
	declare export class CoreWindowResizeManager mixins undefined.ICoreWindowResizeManager {
notifyLayoutCompleted(): void;
static getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
}
	declare export interface ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
} 
	declare export class CoreWindowPopupShowingEventArgs mixins undefined.ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
}
	declare export interface ICoreWindowDialog {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
cancelCommandIndex: number,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowDialogFactory {
createWithTitle(title: string): Windows$Windows$UI.Core.CoreWindowDialog
} 
	declare export class CoreWindowDialog mixins undefined.ICoreWindowDialog {
constructor(title: string): this;
constructor(): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
cancelCommandIndex: number;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
	declare export interface ICoreWindowFlyout {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowFlyoutFactory {
create(
position: Windows$Windows$Foundation.Point): Windows$Windows$UI.Core.CoreWindowFlyout,
createWithTitle(
position: Windows$Windows$Foundation.Point,
title: string): Windows$Windows$UI.Core.CoreWindowFlyout
} 
	declare export class CoreWindowFlyout mixins undefined.ICoreWindowFlyout {
constructor(position: Windows$Windows$Foundation.Point): this;
constructor(position: Windows$Windows$Foundation.Point, title: string): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
    }

    }

	declare module 'UserProfile' {
        declare export  class AccountPictureKind {
  constructor(...args: empty): mixed;
static +smallImage: Class<AccountPictureKind__smallImage> & AccountPictureKind__smallImage & 0;// 0
static +largeImage: Class<AccountPictureKind__largeImage> & AccountPictureKind__largeImage & 1;// 1
static +video: Class<AccountPictureKind__video> & AccountPictureKind__video & 2;// 2

}

declare class AccountPictureKind__smallImage mixins AccountPictureKind {}
declare class AccountPictureKind__largeImage mixins AccountPictureKind {}
declare class AccountPictureKind__video mixins AccountPictureKind {}

	declare export  class SetAccountPictureResult {
  constructor(...args: empty): mixed;
static +success: Class<SetAccountPictureResult__success> & SetAccountPictureResult__success & 0;// 0
static +changeDisabled: Class<SetAccountPictureResult__changeDisabled> & SetAccountPictureResult__changeDisabled & 1;// 1
static +largeOrDynamicError: Class<SetAccountPictureResult__largeOrDynamicError> & SetAccountPictureResult__largeOrDynamicError & 2;// 2
static +videoFrameSizeError: Class<SetAccountPictureResult__videoFrameSizeError> & SetAccountPictureResult__videoFrameSizeError & 3;// 3
static +fileSizeError: Class<SetAccountPictureResult__fileSizeError> & SetAccountPictureResult__fileSizeError & 4;// 4
static +failure: Class<SetAccountPictureResult__failure> & SetAccountPictureResult__failure & 5;// 5

}

declare class SetAccountPictureResult__success mixins SetAccountPictureResult {}
declare class SetAccountPictureResult__changeDisabled mixins SetAccountPictureResult {}
declare class SetAccountPictureResult__largeOrDynamicError mixins SetAccountPictureResult {}
declare class SetAccountPictureResult__videoFrameSizeError mixins SetAccountPictureResult {}
declare class SetAccountPictureResult__fileSizeError mixins SetAccountPictureResult {}
declare class SetAccountPictureResult__failure mixins SetAccountPictureResult {}

	declare export interface IUserInformationStatics {
accountPictureChangeEnabled: boolean,
nameAccessAllowed: boolean,
getAccountPicture(
kind: Windows$Windows$System.UserProfile.AccountPictureKind): Windows$Windows$Storage.IStorageFile,
setAccountPictureAsync(
image: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$System.UserProfile.SetAccountPictureResult>,
setAccountPicturesAsync(
smallImage: Windows$Windows$Storage.IStorageFile,
largeImage: Windows$Windows$Storage.IStorageFile,
video: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$System.UserProfile.SetAccountPictureResult>,
setAccountPictureFromStreamAsync(
image: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$System.UserProfile.SetAccountPictureResult>,
setAccountPicturesFromStreamsAsync(
smallImage: Windows$Windows$Storage.Streams.IRandomAccessStream,
largeImage: Windows$Windows$Storage.Streams.IRandomAccessStream,
video: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$System.UserProfile.SetAccountPictureResult>,
onaccountpicturechanged: any,
getDisplayNameAsync(): Windows$Windows$Foundation.IAsyncOperation<string>,
getFirstNameAsync(): Windows$Windows$Foundation.IAsyncOperation<string>,
getLastNameAsync(): Windows$Windows$Foundation.IAsyncOperation<string>,
getPrincipalNameAsync(): Windows$Windows$Foundation.IAsyncOperation<string>,
getSessionInitiationProtocolUriAsync(): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Uri>,
getDomainNameAsync(): Windows$Windows$Foundation.IAsyncOperation<string>
} 
	declare export class UserInformation  {
static accountPictureChangeEnabled: boolean;
static nameAccessAllowed: boolean;
static getAccountPicture(
kind: Windows$Windows$System.UserProfile.AccountPictureKind): Windows$Windows$Storage.IStorageFile;
static setAccountPictureAsync(
image: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$System.UserProfile.SetAccountPictureResult>;
static setAccountPicturesAsync(
smallImage: Windows$Windows$Storage.IStorageFile,
largeImage: Windows$Windows$Storage.IStorageFile,
video: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$System.UserProfile.SetAccountPictureResult>;
static setAccountPictureFromStreamAsync(
image: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$System.UserProfile.SetAccountPictureResult>;
static setAccountPicturesFromStreamsAsync(
smallImage: Windows$Windows$Storage.Streams.IRandomAccessStream,
largeImage: Windows$Windows$Storage.Streams.IRandomAccessStream,
video: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$System.UserProfile.SetAccountPictureResult>;
static onaccountpicturechanged: any;
static getDisplayNameAsync(): Windows$Windows$Foundation.IAsyncOperation<string>;
static getFirstNameAsync(): Windows$Windows$Foundation.IAsyncOperation<string>;
static getLastNameAsync(): Windows$Windows$Foundation.IAsyncOperation<string>;
static getPrincipalNameAsync(): Windows$Windows$Foundation.IAsyncOperation<string>;
static getSessionInitiationProtocolUriAsync(): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Uri>;
static getDomainNameAsync(): Windows$Windows$Foundation.IAsyncOperation<string>
}
	declare export interface ILockScreenStatics {
originalImageFile: Windows$Windows$Foundation.Uri,
getImageStream(): Windows$Windows$Storage.Streams.IRandomAccessStream,
setImageFileAsync(
value: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncAction,
setImageStreamAsync(
value: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncAction
} 
	declare export class LockScreen  {
static originalImageFile: Windows$Windows$Foundation.Uri;
static getImageStream(): Windows$Windows$Storage.Streams.IRandomAccessStream;
static setImageFileAsync(
value: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncAction;
static setImageStreamAsync(
value: Windows$Windows$Storage.Streams.IRandomAccessStream): Windows$Windows$Foundation.IAsyncAction
}
	declare export interface IGlobalizationPreferencesStatics {
calendars: Windows$Windows$Foundation.Collections.IVectorView<string>,
clocks: Windows$Windows$Foundation.Collections.IVectorView<string>,
currencies: Windows$Windows$Foundation.Collections.IVectorView<string>,
homeGeographicRegion: string,
languages: Windows$Windows$Foundation.Collections.IVectorView<string>,
weekStartsOn: Windows$Windows$Globalization.DayOfWeek
} 
	declare export class GlobalizationPreferences  {
static calendars: Windows$Windows$Foundation.Collections.IVectorView<string>;
static clocks: Windows$Windows$Foundation.Collections.IVectorView<string>;
static currencies: Windows$Windows$Foundation.Collections.IVectorView<string>;
static homeGeographicRegion: string;
static languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
static weekStartsOn: Windows$Windows$Globalization.DayOfWeek
}
    }

	declare export interface ILauncherUIOptions {
invocationPoint: Windows$Windows$Foundation.Point,
preferredPlacement: Windows$Windows$UI.Popups.Placement,
selectionRect: Windows$Windows$Foundation.Rect
} 
	declare export class LauncherUIOptions mixins undefined.ILauncherUIOptions {
invocationPoint: Windows$Windows$Foundation.Point;
preferredPlacement: Windows$Windows$UI.Popups.Placement;
selectionRect: Windows$Windows$Foundation.Rect
}
	declare export interface ILauncherOptions {
contentType: string,
desiredRemainingView: Windows$Windows$UI.ViewManagement.ViewSizePreference,
displayApplicationPicker: boolean,
fallbackUri: Windows$Windows$Foundation.Uri,
preferredApplicationDisplayName: string,
preferredApplicationPackageFamilyName: string,
treatAsUntrusted: boolean,
uI: Windows$Windows$System.LauncherUIOptions
} 
	declare export class LauncherOptions mixins undefined.ILauncherOptions {
contentType: string;
desiredRemainingView: Windows$Windows$UI.ViewManagement.ViewSizePreference;
displayApplicationPicker: boolean;
fallbackUri: Windows$Windows$Foundation.Uri;
preferredApplicationDisplayName: string;
preferredApplicationPackageFamilyName: string;
treatAsUntrusted: boolean;
uI: Windows$Windows$System.LauncherUIOptions
}
	declare export interface ILauncherStatics {
launchFileAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<boolean>,
launchFileAsync(
file: Windows$Windows$Storage.IStorageFile,
options: Windows$Windows$System.LauncherOptions): Windows$Windows$Foundation.IAsyncOperation<boolean>,
launchUriAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<boolean>,
launchUriAsync(
uri: Windows$Windows$Foundation.Uri,
options: Windows$Windows$System.LauncherOptions): Windows$Windows$Foundation.IAsyncOperation<boolean>
} 
	declare export class Launcher  {
static launchFileAsync(
file: Windows$Windows$Storage.IStorageFile): Windows$Windows$Foundation.IAsyncOperation<boolean>;
static launchFileAsync(
file: Windows$Windows$Storage.IStorageFile,
options: Windows$Windows$System.LauncherOptions): Windows$Windows$Foundation.IAsyncOperation<boolean>;
static launchUriAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<boolean>;
static launchUriAsync(
uri: Windows$Windows$Foundation.Uri,
options: Windows$Windows$System.LauncherOptions): Windows$Windows$Foundation.IAsyncOperation<boolean>
}
	declare export  class ProcessorArchitecture {
  constructor(...args: empty): mixed;
static +x86: Class<ProcessorArchitecture__x86> & ProcessorArchitecture__x86 & 0;// 0
static +arm: Class<ProcessorArchitecture__arm> & ProcessorArchitecture__arm & 1;// 1
static +x64: Class<ProcessorArchitecture__x64> & ProcessorArchitecture__x64 & 2;// 2
static +neutral: Class<ProcessorArchitecture__neutral> & ProcessorArchitecture__neutral & 3;// 3
static +unknown: Class<ProcessorArchitecture__unknown> & ProcessorArchitecture__unknown & 4;// 4

}

declare class ProcessorArchitecture__x86 mixins ProcessorArchitecture {}
declare class ProcessorArchitecture__arm mixins ProcessorArchitecture {}
declare class ProcessorArchitecture__x64 mixins ProcessorArchitecture {}
declare class ProcessorArchitecture__neutral mixins ProcessorArchitecture {}
declare class ProcessorArchitecture__unknown mixins ProcessorArchitecture {}

	declare export  class VirtualKeyModifiers {
  constructor(...args: empty): mixed;
static +none: Class<VirtualKeyModifiers__none> & VirtualKeyModifiers__none & 0;// 0
static +control: Class<VirtualKeyModifiers__control> & VirtualKeyModifiers__control & 1;// 1
static +menu: Class<VirtualKeyModifiers__menu> & VirtualKeyModifiers__menu & 2;// 2
static +shift: Class<VirtualKeyModifiers__shift> & VirtualKeyModifiers__shift & 3;// 3
static +windows: Class<VirtualKeyModifiers__windows> & VirtualKeyModifiers__windows & 4;// 4

}

declare class VirtualKeyModifiers__none mixins VirtualKeyModifiers {}
declare class VirtualKeyModifiers__control mixins VirtualKeyModifiers {}
declare class VirtualKeyModifiers__menu mixins VirtualKeyModifiers {}
declare class VirtualKeyModifiers__shift mixins VirtualKeyModifiers {}
declare class VirtualKeyModifiers__windows mixins VirtualKeyModifiers {}

	declare export  class VirtualKey {
  constructor(...args: empty): mixed;
static +none: Class<VirtualKey__none> & VirtualKey__none & 0;// 0
static +leftButton: Class<VirtualKey__leftButton> & VirtualKey__leftButton & 1;// 1
static +rightButton: Class<VirtualKey__rightButton> & VirtualKey__rightButton & 2;// 2
static +cancel: Class<VirtualKey__cancel> & VirtualKey__cancel & 3;// 3
static +middleButton: Class<VirtualKey__middleButton> & VirtualKey__middleButton & 4;// 4
static +xButton1: Class<VirtualKey__xButton1> & VirtualKey__xButton1 & 5;// 5
static +xButton2: Class<VirtualKey__xButton2> & VirtualKey__xButton2 & 6;// 6
static +back: Class<VirtualKey__back> & VirtualKey__back & 7;// 7
static +tab: Class<VirtualKey__tab> & VirtualKey__tab & 8;// 8
static +clear: Class<VirtualKey__clear> & VirtualKey__clear & 9;// 9
static +enter: Class<VirtualKey__enter> & VirtualKey__enter & 10;// 10
static +shift: Class<VirtualKey__shift> & VirtualKey__shift & 11;// 11
static +control: Class<VirtualKey__control> & VirtualKey__control & 12;// 12
static +menu: Class<VirtualKey__menu> & VirtualKey__menu & 13;// 13
static +pause: Class<VirtualKey__pause> & VirtualKey__pause & 14;// 14
static +capitalLock: Class<VirtualKey__capitalLock> & VirtualKey__capitalLock & 15;// 15
static +kana: Class<VirtualKey__kana> & VirtualKey__kana & 16;// 16
static +hangul: Class<VirtualKey__hangul> & VirtualKey__hangul & 17;// 17
static +junja: Class<VirtualKey__junja> & VirtualKey__junja & 18;// 18
static +final: Class<VirtualKey__final> & VirtualKey__final & 19;// 19
static +hanja: Class<VirtualKey__hanja> & VirtualKey__hanja & 20;// 20
static +kanji: Class<VirtualKey__kanji> & VirtualKey__kanji & 21;// 21
static +escape: Class<VirtualKey__escape> & VirtualKey__escape & 22;// 22
static +convert: Class<VirtualKey__convert> & VirtualKey__convert & 23;// 23
static +nonConvert: Class<VirtualKey__nonConvert> & VirtualKey__nonConvert & 24;// 24
static +accept: Class<VirtualKey__accept> & VirtualKey__accept & 25;// 25
static +modeChange: Class<VirtualKey__modeChange> & VirtualKey__modeChange & 26;// 26
static +space: Class<VirtualKey__space> & VirtualKey__space & 27;// 27
static +pageUp: Class<VirtualKey__pageUp> & VirtualKey__pageUp & 28;// 28
static +pageDown: Class<VirtualKey__pageDown> & VirtualKey__pageDown & 29;// 29
static +end: Class<VirtualKey__end> & VirtualKey__end & 30;// 30
static +home: Class<VirtualKey__home> & VirtualKey__home & 31;// 31
static +left: Class<VirtualKey__left> & VirtualKey__left & 32;// 32
static +up: Class<VirtualKey__up> & VirtualKey__up & 33;// 33
static +right: Class<VirtualKey__right> & VirtualKey__right & 34;// 34
static +down: Class<VirtualKey__down> & VirtualKey__down & 35;// 35
static +select: Class<VirtualKey__select> & VirtualKey__select & 36;// 36
static +print: Class<VirtualKey__print> & VirtualKey__print & 37;// 37
static +execute: Class<VirtualKey__execute> & VirtualKey__execute & 38;// 38
static +snapshot: Class<VirtualKey__snapshot> & VirtualKey__snapshot & 39;// 39
static +insert: Class<VirtualKey__insert> & VirtualKey__insert & 40;// 40
static +delete_: Class<VirtualKey__delete_> & VirtualKey__delete_ & 41;// 41
static +help: Class<VirtualKey__help> & VirtualKey__help & 42;// 42
static +number0: Class<VirtualKey__number0> & VirtualKey__number0 & 43;// 43
static +number1: Class<VirtualKey__number1> & VirtualKey__number1 & 44;// 44
static +number2: Class<VirtualKey__number2> & VirtualKey__number2 & 45;// 45
static +number3: Class<VirtualKey__number3> & VirtualKey__number3 & 46;// 46
static +number4: Class<VirtualKey__number4> & VirtualKey__number4 & 47;// 47
static +number5: Class<VirtualKey__number5> & VirtualKey__number5 & 48;// 48
static +number6: Class<VirtualKey__number6> & VirtualKey__number6 & 49;// 49
static +number7: Class<VirtualKey__number7> & VirtualKey__number7 & 50;// 50
static +number8: Class<VirtualKey__number8> & VirtualKey__number8 & 51;// 51
static +number9: Class<VirtualKey__number9> & VirtualKey__number9 & 52;// 52
static +a: Class<VirtualKey__a> & VirtualKey__a & 53;// 53
static +b: Class<VirtualKey__b> & VirtualKey__b & 54;// 54
static +c: Class<VirtualKey__c> & VirtualKey__c & 55;// 55
static +d: Class<VirtualKey__d> & VirtualKey__d & 56;// 56
static +e: Class<VirtualKey__e> & VirtualKey__e & 57;// 57
static +f: Class<VirtualKey__f> & VirtualKey__f & 58;// 58
static +g: Class<VirtualKey__g> & VirtualKey__g & 59;// 59
static +h: Class<VirtualKey__h> & VirtualKey__h & 60;// 60
static +i: Class<VirtualKey__i> & VirtualKey__i & 61;// 61
static +j: Class<VirtualKey__j> & VirtualKey__j & 62;// 62
static +k: Class<VirtualKey__k> & VirtualKey__k & 63;// 63
static +l: Class<VirtualKey__l> & VirtualKey__l & 64;// 64
static +m: Class<VirtualKey__m> & VirtualKey__m & 65;// 65
static +n: Class<VirtualKey__n> & VirtualKey__n & 66;// 66
static +o: Class<VirtualKey__o> & VirtualKey__o & 67;// 67
static +p: Class<VirtualKey__p> & VirtualKey__p & 68;// 68
static +q: Class<VirtualKey__q> & VirtualKey__q & 69;// 69
static +r: Class<VirtualKey__r> & VirtualKey__r & 70;// 70
static +s: Class<VirtualKey__s> & VirtualKey__s & 71;// 71
static +t: Class<VirtualKey__t> & VirtualKey__t & 72;// 72
static +u: Class<VirtualKey__u> & VirtualKey__u & 73;// 73
static +v: Class<VirtualKey__v> & VirtualKey__v & 74;// 74
static +w: Class<VirtualKey__w> & VirtualKey__w & 75;// 75
static +x: Class<VirtualKey__x> & VirtualKey__x & 76;// 76
static +y: Class<VirtualKey__y> & VirtualKey__y & 77;// 77
static +z: Class<VirtualKey__z> & VirtualKey__z & 78;// 78
static +leftWindows: Class<VirtualKey__leftWindows> & VirtualKey__leftWindows & 79;// 79
static +rightWindows: Class<VirtualKey__rightWindows> & VirtualKey__rightWindows & 80;// 80
static +application: Class<VirtualKey__application> & VirtualKey__application & 81;// 81
static +sleep: Class<VirtualKey__sleep> & VirtualKey__sleep & 82;// 82
static +numberPad0: Class<VirtualKey__numberPad0> & VirtualKey__numberPad0 & 83;// 83
static +numberPad1: Class<VirtualKey__numberPad1> & VirtualKey__numberPad1 & 84;// 84
static +numberPad2: Class<VirtualKey__numberPad2> & VirtualKey__numberPad2 & 85;// 85
static +numberPad3: Class<VirtualKey__numberPad3> & VirtualKey__numberPad3 & 86;// 86
static +numberPad4: Class<VirtualKey__numberPad4> & VirtualKey__numberPad4 & 87;// 87
static +numberPad5: Class<VirtualKey__numberPad5> & VirtualKey__numberPad5 & 88;// 88
static +numberPad6: Class<VirtualKey__numberPad6> & VirtualKey__numberPad6 & 89;// 89
static +numberPad7: Class<VirtualKey__numberPad7> & VirtualKey__numberPad7 & 90;// 90
static +numberPad8: Class<VirtualKey__numberPad8> & VirtualKey__numberPad8 & 91;// 91
static +numberPad9: Class<VirtualKey__numberPad9> & VirtualKey__numberPad9 & 92;// 92
static +multiply: Class<VirtualKey__multiply> & VirtualKey__multiply & 93;// 93
static +add: Class<VirtualKey__add> & VirtualKey__add & 94;// 94
static +separator: Class<VirtualKey__separator> & VirtualKey__separator & 95;// 95
static +subtract: Class<VirtualKey__subtract> & VirtualKey__subtract & 96;// 96
static +decimal: Class<VirtualKey__decimal> & VirtualKey__decimal & 97;// 97
static +divide: Class<VirtualKey__divide> & VirtualKey__divide & 98;// 98
static +f1: Class<VirtualKey__f1> & VirtualKey__f1 & 99;// 99
static +f2: Class<VirtualKey__f2> & VirtualKey__f2 & 100;// 100
static +f3: Class<VirtualKey__f3> & VirtualKey__f3 & 101;// 101
static +f4: Class<VirtualKey__f4> & VirtualKey__f4 & 102;// 102
static +f5: Class<VirtualKey__f5> & VirtualKey__f5 & 103;// 103
static +f6: Class<VirtualKey__f6> & VirtualKey__f6 & 104;// 104
static +f7: Class<VirtualKey__f7> & VirtualKey__f7 & 105;// 105
static +f8: Class<VirtualKey__f8> & VirtualKey__f8 & 106;// 106
static +f9: Class<VirtualKey__f9> & VirtualKey__f9 & 107;// 107
static +f10: Class<VirtualKey__f10> & VirtualKey__f10 & 108;// 108
static +f11: Class<VirtualKey__f11> & VirtualKey__f11 & 109;// 109
static +f12: Class<VirtualKey__f12> & VirtualKey__f12 & 110;// 110
static +f13: Class<VirtualKey__f13> & VirtualKey__f13 & 111;// 111
static +f14: Class<VirtualKey__f14> & VirtualKey__f14 & 112;// 112
static +f15: Class<VirtualKey__f15> & VirtualKey__f15 & 113;// 113
static +f16: Class<VirtualKey__f16> & VirtualKey__f16 & 114;// 114
static +f17: Class<VirtualKey__f17> & VirtualKey__f17 & 115;// 115
static +f18: Class<VirtualKey__f18> & VirtualKey__f18 & 116;// 116
static +f19: Class<VirtualKey__f19> & VirtualKey__f19 & 117;// 117
static +f20: Class<VirtualKey__f20> & VirtualKey__f20 & 118;// 118
static +f21: Class<VirtualKey__f21> & VirtualKey__f21 & 119;// 119
static +f22: Class<VirtualKey__f22> & VirtualKey__f22 & 120;// 120
static +f23: Class<VirtualKey__f23> & VirtualKey__f23 & 121;// 121
static +f24: Class<VirtualKey__f24> & VirtualKey__f24 & 122;// 122
static +numberKeyLock: Class<VirtualKey__numberKeyLock> & VirtualKey__numberKeyLock & 123;// 123
static +scroll: Class<VirtualKey__scroll> & VirtualKey__scroll & 124;// 124
static +leftShift: Class<VirtualKey__leftShift> & VirtualKey__leftShift & 125;// 125
static +rightShift: Class<VirtualKey__rightShift> & VirtualKey__rightShift & 126;// 126
static +leftControl: Class<VirtualKey__leftControl> & VirtualKey__leftControl & 127;// 127
static +rightControl: Class<VirtualKey__rightControl> & VirtualKey__rightControl & 128;// 128
static +leftMenu: Class<VirtualKey__leftMenu> & VirtualKey__leftMenu & 129;// 129
static +rightMenu: Class<VirtualKey__rightMenu> & VirtualKey__rightMenu & 130;// 130

}

declare class VirtualKey__none mixins VirtualKey {}
declare class VirtualKey__leftButton mixins VirtualKey {}
declare class VirtualKey__rightButton mixins VirtualKey {}
declare class VirtualKey__cancel mixins VirtualKey {}
declare class VirtualKey__middleButton mixins VirtualKey {}
declare class VirtualKey__xButton1 mixins VirtualKey {}
declare class VirtualKey__xButton2 mixins VirtualKey {}
declare class VirtualKey__back mixins VirtualKey {}
declare class VirtualKey__tab mixins VirtualKey {}
declare class VirtualKey__clear mixins VirtualKey {}
declare class VirtualKey__enter mixins VirtualKey {}
declare class VirtualKey__shift mixins VirtualKey {}
declare class VirtualKey__control mixins VirtualKey {}
declare class VirtualKey__menu mixins VirtualKey {}
declare class VirtualKey__pause mixins VirtualKey {}
declare class VirtualKey__capitalLock mixins VirtualKey {}
declare class VirtualKey__kana mixins VirtualKey {}
declare class VirtualKey__hangul mixins VirtualKey {}
declare class VirtualKey__junja mixins VirtualKey {}
declare class VirtualKey__final mixins VirtualKey {}
declare class VirtualKey__hanja mixins VirtualKey {}
declare class VirtualKey__kanji mixins VirtualKey {}
declare class VirtualKey__escape mixins VirtualKey {}
declare class VirtualKey__convert mixins VirtualKey {}
declare class VirtualKey__nonConvert mixins VirtualKey {}
declare class VirtualKey__accept mixins VirtualKey {}
declare class VirtualKey__modeChange mixins VirtualKey {}
declare class VirtualKey__space mixins VirtualKey {}
declare class VirtualKey__pageUp mixins VirtualKey {}
declare class VirtualKey__pageDown mixins VirtualKey {}
declare class VirtualKey__end mixins VirtualKey {}
declare class VirtualKey__home mixins VirtualKey {}
declare class VirtualKey__left mixins VirtualKey {}
declare class VirtualKey__up mixins VirtualKey {}
declare class VirtualKey__right mixins VirtualKey {}
declare class VirtualKey__down mixins VirtualKey {}
declare class VirtualKey__select mixins VirtualKey {}
declare class VirtualKey__print mixins VirtualKey {}
declare class VirtualKey__execute mixins VirtualKey {}
declare class VirtualKey__snapshot mixins VirtualKey {}
declare class VirtualKey__insert mixins VirtualKey {}
declare class VirtualKey__delete_ mixins VirtualKey {}
declare class VirtualKey__help mixins VirtualKey {}
declare class VirtualKey__number0 mixins VirtualKey {}
declare class VirtualKey__number1 mixins VirtualKey {}
declare class VirtualKey__number2 mixins VirtualKey {}
declare class VirtualKey__number3 mixins VirtualKey {}
declare class VirtualKey__number4 mixins VirtualKey {}
declare class VirtualKey__number5 mixins VirtualKey {}
declare class VirtualKey__number6 mixins VirtualKey {}
declare class VirtualKey__number7 mixins VirtualKey {}
declare class VirtualKey__number8 mixins VirtualKey {}
declare class VirtualKey__number9 mixins VirtualKey {}
declare class VirtualKey__a mixins VirtualKey {}
declare class VirtualKey__b mixins VirtualKey {}
declare class VirtualKey__c mixins VirtualKey {}
declare class VirtualKey__d mixins VirtualKey {}
declare class VirtualKey__e mixins VirtualKey {}
declare class VirtualKey__f mixins VirtualKey {}
declare class VirtualKey__g mixins VirtualKey {}
declare class VirtualKey__h mixins VirtualKey {}
declare class VirtualKey__i mixins VirtualKey {}
declare class VirtualKey__j mixins VirtualKey {}
declare class VirtualKey__k mixins VirtualKey {}
declare class VirtualKey__l mixins VirtualKey {}
declare class VirtualKey__m mixins VirtualKey {}
declare class VirtualKey__n mixins VirtualKey {}
declare class VirtualKey__o mixins VirtualKey {}
declare class VirtualKey__p mixins VirtualKey {}
declare class VirtualKey__q mixins VirtualKey {}
declare class VirtualKey__r mixins VirtualKey {}
declare class VirtualKey__s mixins VirtualKey {}
declare class VirtualKey__t mixins VirtualKey {}
declare class VirtualKey__u mixins VirtualKey {}
declare class VirtualKey__v mixins VirtualKey {}
declare class VirtualKey__w mixins VirtualKey {}
declare class VirtualKey__x mixins VirtualKey {}
declare class VirtualKey__y mixins VirtualKey {}
declare class VirtualKey__z mixins VirtualKey {}
declare class VirtualKey__leftWindows mixins VirtualKey {}
declare class VirtualKey__rightWindows mixins VirtualKey {}
declare class VirtualKey__application mixins VirtualKey {}
declare class VirtualKey__sleep mixins VirtualKey {}
declare class VirtualKey__numberPad0 mixins VirtualKey {}
declare class VirtualKey__numberPad1 mixins VirtualKey {}
declare class VirtualKey__numberPad2 mixins VirtualKey {}
declare class VirtualKey__numberPad3 mixins VirtualKey {}
declare class VirtualKey__numberPad4 mixins VirtualKey {}
declare class VirtualKey__numberPad5 mixins VirtualKey {}
declare class VirtualKey__numberPad6 mixins VirtualKey {}
declare class VirtualKey__numberPad7 mixins VirtualKey {}
declare class VirtualKey__numberPad8 mixins VirtualKey {}
declare class VirtualKey__numberPad9 mixins VirtualKey {}
declare class VirtualKey__multiply mixins VirtualKey {}
declare class VirtualKey__add mixins VirtualKey {}
declare class VirtualKey__separator mixins VirtualKey {}
declare class VirtualKey__subtract mixins VirtualKey {}
declare class VirtualKey__decimal mixins VirtualKey {}
declare class VirtualKey__divide mixins VirtualKey {}
declare class VirtualKey__f1 mixins VirtualKey {}
declare class VirtualKey__f2 mixins VirtualKey {}
declare class VirtualKey__f3 mixins VirtualKey {}
declare class VirtualKey__f4 mixins VirtualKey {}
declare class VirtualKey__f5 mixins VirtualKey {}
declare class VirtualKey__f6 mixins VirtualKey {}
declare class VirtualKey__f7 mixins VirtualKey {}
declare class VirtualKey__f8 mixins VirtualKey {}
declare class VirtualKey__f9 mixins VirtualKey {}
declare class VirtualKey__f10 mixins VirtualKey {}
declare class VirtualKey__f11 mixins VirtualKey {}
declare class VirtualKey__f12 mixins VirtualKey {}
declare class VirtualKey__f13 mixins VirtualKey {}
declare class VirtualKey__f14 mixins VirtualKey {}
declare class VirtualKey__f15 mixins VirtualKey {}
declare class VirtualKey__f16 mixins VirtualKey {}
declare class VirtualKey__f17 mixins VirtualKey {}
declare class VirtualKey__f18 mixins VirtualKey {}
declare class VirtualKey__f19 mixins VirtualKey {}
declare class VirtualKey__f20 mixins VirtualKey {}
declare class VirtualKey__f21 mixins VirtualKey {}
declare class VirtualKey__f22 mixins VirtualKey {}
declare class VirtualKey__f23 mixins VirtualKey {}
declare class VirtualKey__f24 mixins VirtualKey {}
declare class VirtualKey__numberKeyLock mixins VirtualKey {}
declare class VirtualKey__scroll mixins VirtualKey {}
declare class VirtualKey__leftShift mixins VirtualKey {}
declare class VirtualKey__rightShift mixins VirtualKey {}
declare class VirtualKey__leftControl mixins VirtualKey {}
declare class VirtualKey__rightControl mixins VirtualKey {}
declare class VirtualKey__leftMenu mixins VirtualKey {}
declare class VirtualKey__rightMenu mixins VirtualKey {}

	declare module 'Display' {
        declare export interface DisplayPropertiesEventHandler {
(sender: any): void
} 
	declare export  class DisplayOrientations {
  constructor(...args: empty): mixed;
static +none: Class<DisplayOrientations__none> & DisplayOrientations__none & 0;// 0
static +landscape: Class<DisplayOrientations__landscape> & DisplayOrientations__landscape & 1;// 1
static +portrait: Class<DisplayOrientations__portrait> & DisplayOrientations__portrait & 2;// 2
static +landscapeFlipped: Class<DisplayOrientations__landscapeFlipped> & DisplayOrientations__landscapeFlipped & 3;// 3
static +portraitFlipped: Class<DisplayOrientations__portraitFlipped> & DisplayOrientations__portraitFlipped & 4;// 4

}

declare class DisplayOrientations__none mixins DisplayOrientations {}
declare class DisplayOrientations__landscape mixins DisplayOrientations {}
declare class DisplayOrientations__portrait mixins DisplayOrientations {}
declare class DisplayOrientations__landscapeFlipped mixins DisplayOrientations {}
declare class DisplayOrientations__portraitFlipped mixins DisplayOrientations {}

	declare export  class ResolutionScale {
  constructor(...args: empty): mixed;
static +invalid: Class<ResolutionScale__invalid> & ResolutionScale__invalid & 0;// 0
static +scale100Percent: Class<ResolutionScale__scale100Percent> & ResolutionScale__scale100Percent & 1;// 1
static +scale140Percent: Class<ResolutionScale__scale140Percent> & ResolutionScale__scale140Percent & 2;// 2
static +scale180Percent: Class<ResolutionScale__scale180Percent> & ResolutionScale__scale180Percent & 3;// 3

}

declare class ResolutionScale__invalid mixins ResolutionScale {}
declare class ResolutionScale__scale100Percent mixins ResolutionScale {}
declare class ResolutionScale__scale140Percent mixins ResolutionScale {}
declare class ResolutionScale__scale180Percent mixins ResolutionScale {}

	declare export interface IDisplayPropertiesStatics {
autoRotationPreferences: Windows$Windows$Graphics.Display.DisplayOrientations,
currentOrientation: Windows$Windows$Graphics.Display.DisplayOrientations,
logicalDpi: number,
nativeOrientation: Windows$Windows$Graphics.Display.DisplayOrientations,
resolutionScale: Windows$Windows$Graphics.Display.ResolutionScale,
stereoEnabled: boolean,
onorientationchanged: any,
onlogicaldpichanged: any,
onstereoenabledchanged: any,
getColorProfileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IRandomAccessStream>,
oncolorprofilechanged: any,
ondisplaycontentsinvalidated: any
} 
	declare export class DisplayProperties  {
static autoRotationPreferences: Windows$Windows$Graphics.Display.DisplayOrientations;
static currentOrientation: Windows$Windows$Graphics.Display.DisplayOrientations;
static logicalDpi: number;
static nativeOrientation: Windows$Windows$Graphics.Display.DisplayOrientations;
static resolutionScale: Windows$Windows$Graphics.Display.ResolutionScale;
static stereoEnabled: boolean;
static onorientationchanged: any;
static onlogicaldpichanged: any;
static onstereoenabledchanged: any;
static getColorProfileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.Streams.IRandomAccessStream>;
static oncolorprofilechanged: any;
static ondisplaycontentsinvalidated: any
}
	declare export interface IDisplayRequest {
requestActive(): void,
requestRelease(): void
} 
	declare export class DisplayRequest mixins undefined.IDisplayRequest {
requestActive(): void;
requestRelease(): void
}
    }

	declare module 'RemoteDesktop' {
        declare export interface IInteractiveSessionStatics {
isRemote: boolean
} 
	declare export class InteractiveSession  {
static isRemote: boolean
}
    }

    }


declare module 'UI' {
        declare export  class AuthenticationProtocol {
  constructor(...args: empty): mixed;
static +basic: Class<AuthenticationProtocol__basic> & AuthenticationProtocol__basic & 0;// 0
static +digest: Class<AuthenticationProtocol__digest> & AuthenticationProtocol__digest & 1;// 1
static +ntlm: Class<AuthenticationProtocol__ntlm> & AuthenticationProtocol__ntlm & 2;// 2
static +kerberos: Class<AuthenticationProtocol__kerberos> & AuthenticationProtocol__kerberos & 3;// 3
static +negotiate: Class<AuthenticationProtocol__negotiate> & AuthenticationProtocol__negotiate & 4;// 4
static +credSsp: Class<AuthenticationProtocol__credSsp> & AuthenticationProtocol__credSsp & 5;// 5
static +custom: Class<AuthenticationProtocol__custom> & AuthenticationProtocol__custom & 6;// 6

}

declare class AuthenticationProtocol__basic mixins AuthenticationProtocol {}
declare class AuthenticationProtocol__digest mixins AuthenticationProtocol {}
declare class AuthenticationProtocol__ntlm mixins AuthenticationProtocol {}
declare class AuthenticationProtocol__kerberos mixins AuthenticationProtocol {}
declare class AuthenticationProtocol__negotiate mixins AuthenticationProtocol {}
declare class AuthenticationProtocol__credSsp mixins AuthenticationProtocol {}
declare class AuthenticationProtocol__custom mixins AuthenticationProtocol {}

	declare export  class CredentialSaveOption {
  constructor(...args: empty): mixed;
static +unselected: Class<CredentialSaveOption__unselected> & CredentialSaveOption__unselected & 0;// 0
static +selected: Class<CredentialSaveOption__selected> & CredentialSaveOption__selected & 1;// 1
static +hidden: Class<CredentialSaveOption__hidden> & CredentialSaveOption__hidden & 2;// 2

}

declare class CredentialSaveOption__unselected mixins CredentialSaveOption {}
declare class CredentialSaveOption__selected mixins CredentialSaveOption {}
declare class CredentialSaveOption__hidden mixins CredentialSaveOption {}

	declare export interface ICredentialPickerOptions {
alwaysDisplayDialog: boolean,
authenticationProtocol: Windows$Windows$Security.Credentials.Windows$UI.AuthenticationProtocol,
callerSavesCredential: boolean,
caption: string,
credentialSaveOption: Windows$Windows$Security.Credentials.Windows$UI.CredentialSaveOption,
customAuthenticationProtocol: string,
errorCode: number,
message: string,
previousCredential: Windows$Windows$Storage.Streams.IBuffer,
targetName: string
} 
	declare export class CredentialPickerOptions mixins undefined.ICredentialPickerOptions {
alwaysDisplayDialog: boolean;
authenticationProtocol: Windows$Windows$Security.Credentials.Windows$UI.AuthenticationProtocol;
callerSavesCredential: boolean;
caption: string;
credentialSaveOption: Windows$Windows$Security.Credentials.Windows$UI.CredentialSaveOption;
customAuthenticationProtocol: string;
errorCode: number;
message: string;
previousCredential: Windows$Windows$Storage.Streams.IBuffer;
targetName: string
}
	declare export interface ICredentialPickerStatics {
pickAsync(
options: Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerResults>,
pickAsync(
targetName: string,
message: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerResults>,
pickAsync(
targetName: string,
message: string,
caption: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerResults>
} 
	declare export class CredentialPickerResults mixins undefined.ICredentialPickerResults {
credential: Windows$Windows$Storage.Streams.IBuffer;
credentialDomainName: string;
credentialPassword: string;
credentialSaveOption: Windows$Windows$Security.Credentials.Windows$UI.CredentialSaveOption;
credentialSaved: boolean;
credentialUserName: string;
errorCode: number
}
	declare export class CredentialPicker  {
static pickAsync(
options: Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerOptions): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerResults>;
static pickAsync(
targetName: string,
message: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerResults>;
static pickAsync(
targetName: string,
message: string,
caption: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Credentials.Windows$UI.CredentialPickerResults>
}
	declare export interface ICredentialPickerResults {
credential: Windows$Windows$Storage.Streams.IBuffer,
credentialDomainName: string,
credentialPassword: string,
credentialSaveOption: Windows$Windows$Security.Credentials.Windows$UI.CredentialSaveOption,
credentialSaved: boolean,
credentialUserName: string,
errorCode: number
} 
	declare module 'ApplicationSettings' {
        declare export interface ISettingsCommandFactory {
create(
settingsCommandId: any,
label: string,
handler: Windows$Windows$UI.Popups.UICommandInvokedHandler): Windows$Windows$UI.ApplicationSettings.SettingsCommand
} 
	declare export class SettingsCommand mixins undefined.IUICommand {
constructor(settingsCommandId: any, label: string, handler: Windows$Windows$UI.Popups.UICommandInvokedHandler): this;
id: any;
invoked: Windows$Windows$UI.Popups.UICommandInvokedHandler;
label: string
}
	declare export interface ISettingsPaneCommandsRequest {
applicationCommands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.ApplicationSettings.SettingsCommand>
} 
	declare export class SettingsPaneCommandsRequest mixins undefined.ISettingsPaneCommandsRequest {
applicationCommands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.ApplicationSettings.SettingsCommand>
}
	declare export interface ISettingsPaneCommandsRequestedEventArgs {
request: Windows$Windows$UI.ApplicationSettings.SettingsPaneCommandsRequest
} 
	declare export class SettingsPaneCommandsRequestedEventArgs mixins undefined.ISettingsPaneCommandsRequestedEventArgs {
request: Windows$Windows$UI.ApplicationSettings.SettingsPaneCommandsRequest
}
	declare export  class SettingsEdgeLocation {
  constructor(...args: empty): mixed;
static +right: Class<SettingsEdgeLocation__right> & SettingsEdgeLocation__right & 0;// 0
static +left: Class<SettingsEdgeLocation__left> & SettingsEdgeLocation__left & 1;// 1

}

declare class SettingsEdgeLocation__right mixins SettingsEdgeLocation {}
declare class SettingsEdgeLocation__left mixins SettingsEdgeLocation {}

	declare export interface ISettingsPaneStatics {
edge: Windows$Windows$UI.ApplicationSettings.SettingsEdgeLocation,
getForCurrentView(): Windows$Windows$UI.ApplicationSettings.SettingsPane,
show(): void
} 
	declare export class SettingsPane mixins undefined.ISettingsPane {
oncommandsrequested: any;
static edge: Windows$Windows$UI.ApplicationSettings.SettingsEdgeLocation;
static getForCurrentView(): Windows$Windows$UI.ApplicationSettings.SettingsPane;
static show(): void
}
	declare export interface ISettingsPane {
oncommandsrequested: any
} 
    }

	declare module 'ViewManagement' {
        declare export  class ViewSizePreference {
  constructor(...args: empty): mixed;
static +default: Class<ViewSizePreference__default> & ViewSizePreference__default & 0;// 0
static +useLess: Class<ViewSizePreference__useLess> & ViewSizePreference__useLess & 1;// 1
static +useHalf: Class<ViewSizePreference__useHalf> & ViewSizePreference__useHalf & 2;// 2
static +useMore: Class<ViewSizePreference__useMore> & ViewSizePreference__useMore & 3;// 3
static +useMinimum: Class<ViewSizePreference__useMinimum> & ViewSizePreference__useMinimum & 4;// 4
static +useNone: Class<ViewSizePreference__useNone> & ViewSizePreference__useNone & 5;// 5

}

declare class ViewSizePreference__default mixins ViewSizePreference {}
declare class ViewSizePreference__useLess mixins ViewSizePreference {}
declare class ViewSizePreference__useHalf mixins ViewSizePreference {}
declare class ViewSizePreference__useMore mixins ViewSizePreference {}
declare class ViewSizePreference__useMinimum mixins ViewSizePreference {}
declare class ViewSizePreference__useNone mixins ViewSizePreference {}

	declare export  class ApplicationViewState {
  constructor(...args: empty): mixed;
static +fullScreenLandscape: Class<ApplicationViewState__fullScreenLandscape> & ApplicationViewState__fullScreenLandscape & 0;// 0
static +filled: Class<ApplicationViewState__filled> & ApplicationViewState__filled & 1;// 1
static +snapped: Class<ApplicationViewState__snapped> & ApplicationViewState__snapped & 2;// 2
static +fullScreenPortrait: Class<ApplicationViewState__fullScreenPortrait> & ApplicationViewState__fullScreenPortrait & 3;// 3

}

declare class ApplicationViewState__fullScreenLandscape mixins ApplicationViewState {}
declare class ApplicationViewState__filled mixins ApplicationViewState {}
declare class ApplicationViewState__snapped mixins ApplicationViewState {}
declare class ApplicationViewState__fullScreenPortrait mixins ApplicationViewState {}

	
/**
 * Defines an instance of a window (app view) and the information that describes it.
 */
declare export class ApplicationView  {

/**
 * Gets the window (app view) for the current app.
 */
static getForCurrentView(): ApplicationView;

/**
 * Attempts to unsnap a previously snapped app. This call will only succeed when the app is running in the foreground.
 */
static tryUnsnap(): boolean;

/**
 * Gets the state of the current app view.
 */
static value: Windows$Windows$UI.ViewManagement.ApplicationViewState;

/**
 * Indicates whether the app terminates when the last window is closed.
 */
static terminateAppOnFinalViewClose: boolean;

/**
 * Gets the current orientation of the window (app view) with respect to the display.
 */
orientation: ApplicationViewOrientation;

/**
 * Gets or sets the displayed title of the window.
 */
title: string;

/**
 * Gets or sets whether screen capture is enabled for the window (app view).
 */
isScreenCaptureEnabled: boolean;

/**
 * Gets whether the window (app view) is on the Windows lock screen.
 */
isOnLockScreen: boolean;

/**
 * Gets whether the window(app view) is full screen or not.
 */
isFullScreen: boolean;

/**
 * Gets the current ID of the window (app view) .
 */
id: number;

/**
 * Gets whether the current window (app view) is adjacent to the right edge of the screen.
 */
adjacentToRightDisplayEdge: boolean;

/**
 * Gets whether the current window (app view) is adjacent to the left edge of the screen.
 */
adjacentToLeftDisplayEdge: number;

/**
 * Gets the title bar of the app.
 */
titleBar: ViewManagement$ApplicationViewTitleBar
}
	
/**
 * Defines the set of display orientation modes for a window (app view).
 */
declare export  class ApplicationViewOrientation {
  constructor(...args: empty): mixed;
static +landscape: Class<ApplicationViewOrientation__landscape> & ApplicationViewOrientation__landscape & 0;// 0
static +portrait: Class<ApplicationViewOrientation__portrait> & ApplicationViewOrientation__portrait & 1;// 1

}

declare class ApplicationViewOrientation__landscape mixins ApplicationViewOrientation {}
declare class ApplicationViewOrientation__portrait mixins ApplicationViewOrientation {}

	declare export interface IInputPaneVisibilityEventArgs {
ensuredFocusedElementInView: boolean,
occludedRect: Windows$Windows$Foundation.Rect
} 
	declare export class InputPaneVisibilityEventArgs mixins undefined.IInputPaneVisibilityEventArgs {
ensuredFocusedElementInView: boolean;
occludedRect: Windows$Windows$Foundation.Rect
}
	declare export interface IInputPane {
occludedRect: Windows$Windows$Foundation.Rect,
onshowing: any,
onhiding: any
} 
	declare export class InputPane mixins undefined.IInputPane {
occludedRect: Windows$Windows$Foundation.Rect;
onshowing: any;
onhiding: any;
static getForCurrentView(): Windows$Windows$UI.ViewManagement.InputPane
}
	declare export interface IInputPaneStatics {
getForCurrentView(): Windows$Windows$UI.ViewManagement.InputPane
} 
	declare export  class HandPreference {
  constructor(...args: empty): mixed;
static +leftHanded: Class<HandPreference__leftHanded> & HandPreference__leftHanded & 0;// 0
static +rightHanded: Class<HandPreference__rightHanded> & HandPreference__rightHanded & 1;// 1

}

declare class HandPreference__leftHanded mixins HandPreference {}
declare class HandPreference__rightHanded mixins HandPreference {}

	declare export  class UIElementType {
  constructor(...args: empty): mixed;
static +activeCaption: Class<UIElementType__activeCaption> & UIElementType__activeCaption & 0;// 0
static +background: Class<UIElementType__background> & UIElementType__background & 1;// 1
static +buttonFace: Class<UIElementType__buttonFace> & UIElementType__buttonFace & 2;// 2
static +buttonText: Class<UIElementType__buttonText> & UIElementType__buttonText & 3;// 3
static +captionText: Class<UIElementType__captionText> & UIElementType__captionText & 4;// 4
static +grayText: Class<UIElementType__grayText> & UIElementType__grayText & 5;// 5
static +highlight: Class<UIElementType__highlight> & UIElementType__highlight & 6;// 6
static +highlightText: Class<UIElementType__highlightText> & UIElementType__highlightText & 7;// 7
static +hotlight: Class<UIElementType__hotlight> & UIElementType__hotlight & 8;// 8
static +inactiveCaption: Class<UIElementType__inactiveCaption> & UIElementType__inactiveCaption & 9;// 9
static +inactiveCaptionText: Class<UIElementType__inactiveCaptionText> & UIElementType__inactiveCaptionText & 10;// 10
static +window: Class<UIElementType__window> & UIElementType__window & 11;// 11
static +windowText: Class<UIElementType__windowText> & UIElementType__windowText & 12;// 12

}

declare class UIElementType__activeCaption mixins UIElementType {}
declare class UIElementType__background mixins UIElementType {}
declare class UIElementType__buttonFace mixins UIElementType {}
declare class UIElementType__buttonText mixins UIElementType {}
declare class UIElementType__captionText mixins UIElementType {}
declare class UIElementType__grayText mixins UIElementType {}
declare class UIElementType__highlight mixins UIElementType {}
declare class UIElementType__highlightText mixins UIElementType {}
declare class UIElementType__hotlight mixins UIElementType {}
declare class UIElementType__inactiveCaption mixins UIElementType {}
declare class UIElementType__inactiveCaptionText mixins UIElementType {}
declare class UIElementType__window mixins UIElementType {}
declare class UIElementType__windowText mixins UIElementType {}

	declare export interface IAccessibilitySettings {
highContrast: boolean,
highContrastScheme: string,
onhighcontrastchanged: any
} 
	declare export class AccessibilitySettings mixins undefined.IAccessibilitySettings {
highContrast: boolean;
highContrastScheme: string;
onhighcontrastchanged: any
}
	declare export interface IUISettings {
animationsEnabled: boolean,
caretBlinkRate: number,
caretBrowsingEnabled: boolean,
caretWidth: number,
cursorSize: Windows$Windows$Foundation.Size,
doubleClickTime: number,
handPreference: Windows$Windows$UI.ViewManagement.HandPreference,
messageDuration: number,
mouseHoverTime: number,
scrollBarArrowSize: Windows$Windows$Foundation.Size,
scrollBarSize: Windows$Windows$Foundation.Size,
scrollBarThumbBoxSize: Windows$Windows$Foundation.Size,
uIElementColor(
desiredElement: Windows$Windows$UI.ViewManagement.UIElementType): Windows$Windows$UI.Color
} 
	declare export class UISettings mixins undefined.IUISettings {
animationsEnabled: boolean;
caretBlinkRate: number;
caretBrowsingEnabled: boolean;
caretWidth: number;
cursorSize: Windows$Windows$Foundation.Size;
doubleClickTime: number;
handPreference: Windows$Windows$UI.ViewManagement.HandPreference;
messageDuration: number;
mouseHoverTime: number;
scrollBarArrowSize: Windows$Windows$Foundation.Size;
scrollBarSize: Windows$Windows$Foundation.Size;
scrollBarThumbBoxSize: Windows$Windows$Foundation.Size;
uIElementColor(
desiredElement: Windows$Windows$UI.ViewManagement.UIElementType): Windows$Windows$UI.Color
}
    }

	declare module 'Input' {
        declare export  class PointerDeviceType {
  constructor(...args: empty): mixed;
static +touch: Class<PointerDeviceType__touch> & PointerDeviceType__touch & 0;// 0
static +pen: Class<PointerDeviceType__pen> & PointerDeviceType__pen & 1;// 1
static +mouse: Class<PointerDeviceType__mouse> & PointerDeviceType__mouse & 2;// 2

}

declare class PointerDeviceType__touch mixins PointerDeviceType {}
declare class PointerDeviceType__pen mixins PointerDeviceType {}
declare class PointerDeviceType__mouse mixins PointerDeviceType {}

	declare export interface PointerDeviceUsage {
usagePage: number,
usage: number,
minLogical: number,
maxLogical: number,
minPhysical: number,
maxPhysical: number,
unit: number,
physicalMultiplier: number
} 
	declare export interface MouseDelta {
x: number,
y: number
} 
	declare export interface IMouseCapabilities {
horizontalWheelPresent: number,
mousePresent: number,
numberOfButtons: number,
swapButtons: number,
verticalWheelPresent: number
} 
	declare export interface IKeyboardCapabilities {
keyboardPresent: number
} 
	declare export interface ITouchCapabilities {
contacts: number,
touchPresent: number
} 
	declare export interface IPointerDeviceStatics {
getPointerDevice(pointerId: number): Windows$Windows$Devices.Input.PointerDevice,
getPointerDevices(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDevice>
} 
	declare export class PointerDevice mixins undefined.IPointerDevice {
isIntegrated: boolean;
maxContacts: number;
physicalDeviceRect: Windows$Windows$Foundation.Rect;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
screenRect: Windows$Windows$Foundation.Rect;
supportedUsages: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDeviceUsage>;
static getPointerDevice(pointerId: number): Windows$Windows$Devices.Input.PointerDevice;
static getPointerDevices(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDevice>
}
	declare export interface IPointerDevice {
isIntegrated: boolean,
maxContacts: number,
physicalDeviceRect: Windows$Windows$Foundation.Rect,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
screenRect: Windows$Windows$Foundation.Rect,
supportedUsages: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Devices.Input.PointerDeviceUsage>
} 
	declare export interface IMouseEventArgs {
mouseDelta: Windows$Windows$Devices.Input.MouseDelta
} 
	declare export interface IMouseDevice {
onmousemoved: any
} 
	declare export class MouseDevice mixins undefined.IMouseDevice {
onmousemoved: any;
static getForCurrentView(): Windows$Windows$Devices.Input.MouseDevice
}
	declare export class MouseEventArgs mixins undefined.IMouseEventArgs {
mouseDelta: Windows$Windows$Devices.Input.MouseDelta
}
	declare export interface IMouseDeviceStatics {
getForCurrentView(): Windows$Windows$Devices.Input.MouseDevice
} 
	declare export class MouseCapabilities mixins undefined.IMouseCapabilities {
horizontalWheelPresent: number;
mousePresent: number;
numberOfButtons: number;
swapButtons: number;
verticalWheelPresent: number
}
	declare export class KeyboardCapabilities mixins undefined.IKeyboardCapabilities {
keyboardPresent: number
}
	declare export class TouchCapabilities mixins undefined.ITouchCapabilities {
contacts: number;
touchPresent: number
}
	declare export  class EdgeGestureKind {
  constructor(...args: empty): mixed;
static +touch: Class<EdgeGestureKind__touch> & EdgeGestureKind__touch & 0;// 0
static +keyboard: Class<EdgeGestureKind__keyboard> & EdgeGestureKind__keyboard & 1;// 1
static +mouse: Class<EdgeGestureKind__mouse> & EdgeGestureKind__mouse & 2;// 2

}

declare class EdgeGestureKind__touch mixins EdgeGestureKind {}
declare class EdgeGestureKind__keyboard mixins EdgeGestureKind {}
declare class EdgeGestureKind__mouse mixins EdgeGestureKind {}

	declare export interface IEdgeGestureEventArgs {
kind: Windows$Windows$UI.Input.EdgeGestureKind
} 
	declare export class EdgeGestureEventArgs mixins undefined.IEdgeGestureEventArgs {
kind: Windows$Windows$UI.Input.EdgeGestureKind
}
	declare export interface IEdgeGestureStatics {
getForCurrentView(): Windows$Windows$UI.Input.EdgeGesture
} 
	declare export class EdgeGesture mixins undefined.IEdgeGesture {
onstarting: any;
oncompleted: any;
oncanceled: any;
static getForCurrentView(): Windows$Windows$UI.Input.EdgeGesture
}
	declare export interface IEdgeGesture {
onstarting: any,
oncompleted: any,
oncanceled: any
} 
	declare export  class HoldingState {
  constructor(...args: empty): mixed;
static +started: Class<HoldingState__started> & HoldingState__started & 0;// 0
static +completed: Class<HoldingState__completed> & HoldingState__completed & 1;// 1
static +canceled: Class<HoldingState__canceled> & HoldingState__canceled & 2;// 2

}

declare class HoldingState__started mixins HoldingState {}
declare class HoldingState__completed mixins HoldingState {}
declare class HoldingState__canceled mixins HoldingState {}

	declare export  class DraggingState {
  constructor(...args: empty): mixed;
static +started: Class<DraggingState__started> & DraggingState__started & 0;// 0
static +continuing: Class<DraggingState__continuing> & DraggingState__continuing & 1;// 1
static +completed: Class<DraggingState__completed> & DraggingState__completed & 2;// 2

}

declare class DraggingState__started mixins DraggingState {}
declare class DraggingState__continuing mixins DraggingState {}
declare class DraggingState__completed mixins DraggingState {}

	declare export  class CrossSlidingState {
  constructor(...args: empty): mixed;
static +started: Class<CrossSlidingState__started> & CrossSlidingState__started & 0;// 0
static +dragging: Class<CrossSlidingState__dragging> & CrossSlidingState__dragging & 1;// 1
static +selecting: Class<CrossSlidingState__selecting> & CrossSlidingState__selecting & 2;// 2
static +selectSpeedBumping: Class<CrossSlidingState__selectSpeedBumping> & CrossSlidingState__selectSpeedBumping & 3;// 3
static +speedBumping: Class<CrossSlidingState__speedBumping> & CrossSlidingState__speedBumping & 4;// 4
static +rearranging: Class<CrossSlidingState__rearranging> & CrossSlidingState__rearranging & 5;// 5
static +completed: Class<CrossSlidingState__completed> & CrossSlidingState__completed & 6;// 6

}

declare class CrossSlidingState__started mixins CrossSlidingState {}
declare class CrossSlidingState__dragging mixins CrossSlidingState {}
declare class CrossSlidingState__selecting mixins CrossSlidingState {}
declare class CrossSlidingState__selectSpeedBumping mixins CrossSlidingState {}
declare class CrossSlidingState__speedBumping mixins CrossSlidingState {}
declare class CrossSlidingState__rearranging mixins CrossSlidingState {}
declare class CrossSlidingState__completed mixins CrossSlidingState {}

	declare export  class GestureSettings {
  constructor(...args: empty): mixed;
static +none: Class<GestureSettings__none> & GestureSettings__none & 0;// 0
static +tap: Class<GestureSettings__tap> & GestureSettings__tap & 1;// 1
static +doubleTap: Class<GestureSettings__doubleTap> & GestureSettings__doubleTap & 2;// 2
static +hold: Class<GestureSettings__hold> & GestureSettings__hold & 3;// 3
static +holdWithMouse: Class<GestureSettings__holdWithMouse> & GestureSettings__holdWithMouse & 4;// 4
static +rightTap: Class<GestureSettings__rightTap> & GestureSettings__rightTap & 5;// 5
static +drag: Class<GestureSettings__drag> & GestureSettings__drag & 6;// 6
static +manipulationTranslateX: Class<GestureSettings__manipulationTranslateX> & GestureSettings__manipulationTranslateX & 7;// 7
static +manipulationTranslateY: Class<GestureSettings__manipulationTranslateY> & GestureSettings__manipulationTranslateY & 8;// 8
static +manipulationTranslateRailsX: Class<GestureSettings__manipulationTranslateRailsX> & GestureSettings__manipulationTranslateRailsX & 9;// 9
static +manipulationTranslateRailsY: Class<GestureSettings__manipulationTranslateRailsY> & GestureSettings__manipulationTranslateRailsY & 10;// 10
static +manipulationRotate: Class<GestureSettings__manipulationRotate> & GestureSettings__manipulationRotate & 11;// 11
static +manipulationScale: Class<GestureSettings__manipulationScale> & GestureSettings__manipulationScale & 12;// 12
static +manipulationTranslateInertia: Class<GestureSettings__manipulationTranslateInertia> & GestureSettings__manipulationTranslateInertia & 13;// 13
static +manipulationRotateInertia: Class<GestureSettings__manipulationRotateInertia> & GestureSettings__manipulationRotateInertia & 14;// 14
static +manipulationScaleInertia: Class<GestureSettings__manipulationScaleInertia> & GestureSettings__manipulationScaleInertia & 15;// 15
static +crossSlide: Class<GestureSettings__crossSlide> & GestureSettings__crossSlide & 16;// 16

}

declare class GestureSettings__none mixins GestureSettings {}
declare class GestureSettings__tap mixins GestureSettings {}
declare class GestureSettings__doubleTap mixins GestureSettings {}
declare class GestureSettings__hold mixins GestureSettings {}
declare class GestureSettings__holdWithMouse mixins GestureSettings {}
declare class GestureSettings__rightTap mixins GestureSettings {}
declare class GestureSettings__drag mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateX mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateY mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateRailsX mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateRailsY mixins GestureSettings {}
declare class GestureSettings__manipulationRotate mixins GestureSettings {}
declare class GestureSettings__manipulationScale mixins GestureSettings {}
declare class GestureSettings__manipulationTranslateInertia mixins GestureSettings {}
declare class GestureSettings__manipulationRotateInertia mixins GestureSettings {}
declare class GestureSettings__manipulationScaleInertia mixins GestureSettings {}
declare class GestureSettings__crossSlide mixins GestureSettings {}

	declare export interface ManipulationDelta {
translation: Windows$Windows$Foundation.Point,
scale: number,
rotation: number,
expansion: number
} 
	declare export interface ManipulationVelocities {
linear: Windows$Windows$Foundation.Point,
angular: number,
expansion: number
} 
	declare export interface CrossSlideThresholds {
selectionStart: number,
speedBumpStart: number,
speedBumpEnd: number,
rearrangeStart: number
} 
	declare export interface ITappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
tapCount: number
} 
	declare export interface IRightTappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IHoldingEventArgs {
holdingState: Windows$Windows$UI.Input.HoldingState,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IDraggingEventArgs {
draggingState: Windows$Windows$UI.Input.DraggingState,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IManipulationStartedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IManipulationUpdatedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
delta: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
velocities: Windows$Windows$UI.Input.ManipulationVelocities
} 
	declare export interface IManipulationInertiaStartingEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
delta: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
velocities: Windows$Windows$UI.Input.ManipulationVelocities
} 
	declare export interface IManipulationCompletedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point,
velocities: Windows$Windows$UI.Input.ManipulationVelocities
} 
	declare export interface ICrossSlidingEventArgs {
crossSlidingState: Windows$Windows$UI.Input.CrossSlidingState,
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType,
position: Windows$Windows$Foundation.Point
} 
	declare export interface IMouseWheelParameters {
charTranslation: Windows$Windows$Foundation.Point,
deltaRotationAngle: number,
deltaScale: number,
pageTranslation: Windows$Windows$Foundation.Point
} 
	declare export interface IGestureRecognizer {
autoProcessInertia: boolean,
crossSlideExact: boolean,
crossSlideHorizontally: boolean,
crossSlideThresholds: Windows$Windows$UI.Input.CrossSlideThresholds,
gestureSettings: Windows$Windows$UI.Input.GestureSettings,
inertiaExpansion: number,
inertiaExpansionDeceleration: number,
inertiaRotationAngle: number,
inertiaRotationDeceleration: number,
inertiaTranslationDeceleration: number,
inertiaTranslationDisplacement: number,
isActive: boolean,
isInertial: boolean,
manipulationExact: boolean,
mouseWheelParameters: Windows$Windows$UI.Input.MouseWheelParameters,
pivotCenter: Windows$Windows$Foundation.Point,
pivotRadius: number,
showGestureFeedback: boolean,
canBeDoubleTap(value: Windows$Windows$UI.Input.PointerPoint): boolean,
processDownEvent(value: Windows$Windows$UI.Input.PointerPoint): void,
processMoveEvents(
value: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>): void,
processUpEvent(value: Windows$Windows$UI.Input.PointerPoint): void,
processMouseWheelEvent(
value: Windows$Windows$UI.Input.PointerPoint,
isShiftKeyDown: boolean,
isControlKeyDown: boolean): void,
processInertia(): void,
completeGesture(): void,
ontapped: any,
onrighttapped: any,
onholding: any,
ondragging: any,
onmanipulationstarted: any,
onmanipulationupdated: any,
onmanipulationinertiastarting: any,
onmanipulationcompleted: any,
oncrosssliding: any
} 
	declare export class MouseWheelParameters mixins undefined.IMouseWheelParameters {
charTranslation: Windows$Windows$Foundation.Point;
deltaRotationAngle: number;
deltaScale: number;
pageTranslation: Windows$Windows$Foundation.Point
}
	declare export class GestureRecognizer mixins undefined.IGestureRecognizer {
autoProcessInertia: boolean;
crossSlideExact: boolean;
crossSlideHorizontally: boolean;
crossSlideThresholds: Windows$Windows$UI.Input.CrossSlideThresholds;
gestureSettings: Windows$Windows$UI.Input.GestureSettings;
inertiaExpansion: number;
inertiaExpansionDeceleration: number;
inertiaRotationAngle: number;
inertiaRotationDeceleration: number;
inertiaTranslationDeceleration: number;
inertiaTranslationDisplacement: number;
isActive: boolean;
isInertial: boolean;
manipulationExact: boolean;
mouseWheelParameters: Windows$Windows$UI.Input.MouseWheelParameters;
pivotCenter: Windows$Windows$Foundation.Point;
pivotRadius: number;
showGestureFeedback: boolean;
canBeDoubleTap(value: Windows$Windows$UI.Input.PointerPoint): boolean;
processDownEvent(value: Windows$Windows$UI.Input.PointerPoint): void;
processMoveEvents(
value: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>): void;
processUpEvent(value: Windows$Windows$UI.Input.PointerPoint): void;
processMouseWheelEvent(
value: Windows$Windows$UI.Input.PointerPoint,
isShiftKeyDown: boolean,
isControlKeyDown: boolean): void;
processInertia(): void;
completeGesture(): void;
ontapped: any;
onrighttapped: any;
onholding: any;
ondragging: any;
onmanipulationstarted: any;
onmanipulationupdated: any;
onmanipulationinertiastarting: any;
onmanipulationcompleted: any;
oncrosssliding: any
}
	declare export class TappedEventArgs mixins undefined.ITappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
tapCount: number
}
	declare export class RightTappedEventArgs mixins undefined.IRightTappedEventArgs {
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class HoldingEventArgs mixins undefined.IHoldingEventArgs {
holdingState: Windows$Windows$UI.Input.HoldingState;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class DraggingEventArgs mixins undefined.IDraggingEventArgs {
draggingState: Windows$Windows$UI.Input.DraggingState;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class ManipulationStartedEventArgs mixins undefined.IManipulationStartedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export class ManipulationUpdatedEventArgs mixins undefined.IManipulationUpdatedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
delta: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
velocities: Windows$Windows$UI.Input.ManipulationVelocities
}
	declare export class ManipulationInertiaStartingEventArgs mixins undefined.IManipulationInertiaStartingEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
delta: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
velocities: Windows$Windows$UI.Input.ManipulationVelocities
}
	declare export class ManipulationCompletedEventArgs mixins undefined.IManipulationCompletedEventArgs {
cumulative: Windows$Windows$UI.Input.ManipulationDelta;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point;
velocities: Windows$Windows$UI.Input.ManipulationVelocities
}
	declare export class CrossSlidingEventArgs mixins undefined.ICrossSlidingEventArgs {
crossSlidingState: Windows$Windows$UI.Input.CrossSlidingState;
pointerDeviceType: Windows$Windows$Devices.Input.PointerDeviceType;
position: Windows$Windows$Foundation.Point
}
	declare export interface IPointerPointStatics {
getCurrentPoint(pointerId: number): Windows$Windows$UI.Input.PointerPoint,
getIntermediatePoints(
pointerId: number): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>,
getCurrentPoint(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$UI.Input.PointerPoint,
getIntermediatePoints(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
} 
	declare export class PointerPoint mixins undefined.IPointerPoint {
frameId: number;
isInContact: boolean;
pointerDevice: Windows$Windows$Devices.Input.PointerDevice;
pointerId: number;
position: Windows$Windows$Foundation.Point;
properties: Windows$Windows$UI.Input.PointerPointProperties;
rawPosition: Windows$Windows$Foundation.Point;
timestamp: number;
static getCurrentPoint(pointerId: number): Windows$Windows$UI.Input.PointerPoint;
static getIntermediatePoints(
pointerId: number): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>;
static getCurrentPoint(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$UI.Input.PointerPoint;
static getIntermediatePoints(
pointerId: number,
transform: Windows$Windows$UI.Input.IPointerPointTransform): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
}
	declare export interface IPointerPointTransform {
inverse: Windows$Windows$UI.Input.IPointerPointTransform,
tryTransform(
inPoint: Windows$Windows$Foundation.Point): {
outPoint: Windows$Windows$Foundation.Point,
returnValue: boolean
},
transformBounds(rect: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.Rect
} 
	declare export interface IPointerPoint {
frameId: number,
isInContact: boolean,
pointerDevice: Windows$Windows$Devices.Input.PointerDevice,
pointerId: number,
position: Windows$Windows$Foundation.Point,
properties: Windows$Windows$UI.Input.PointerPointProperties,
rawPosition: Windows$Windows$Foundation.Point,
timestamp: number
} 
	declare export class PointerPointProperties mixins undefined.IPointerPointProperties {
contactRect: Windows$Windows$Foundation.Rect;
contactRectRaw: Windows$Windows$Foundation.Rect;
isBarrelButtonPressed: boolean;
isCanceled: boolean;
isEraser: boolean;
isHorizontalMouseWheel: boolean;
isInRange: boolean;
isInverted: boolean;
isLeftButtonPressed: boolean;
isMiddleButtonPressed: boolean;
isPrimary: boolean;
isRightButtonPressed: boolean;
isXButton1Pressed: boolean;
isXButton2Pressed: boolean;
mouseWheelDelta: number;
orientation: number;
pointerUpdateKind: Windows$Windows$UI.Input.PointerUpdateKind;
pressure: number;
touchConfidence: boolean;
twist: number;
xTilt: number;
yTilt: number;
hasUsage(usagePage: number, usageId: number): boolean;
getUsageValue(usagePage: number, usageId: number): number
}
	declare export  class PointerUpdateKind {
  constructor(...args: empty): mixed;
static +other: Class<PointerUpdateKind__other> & PointerUpdateKind__other & 0;// 0
static +leftButtonPressed: Class<PointerUpdateKind__leftButtonPressed> & PointerUpdateKind__leftButtonPressed & 1;// 1
static +leftButtonReleased: Class<PointerUpdateKind__leftButtonReleased> & PointerUpdateKind__leftButtonReleased & 2;// 2
static +rightButtonPressed: Class<PointerUpdateKind__rightButtonPressed> & PointerUpdateKind__rightButtonPressed & 3;// 3
static +rightButtonReleased: Class<PointerUpdateKind__rightButtonReleased> & PointerUpdateKind__rightButtonReleased & 4;// 4
static +middleButtonPressed: Class<PointerUpdateKind__middleButtonPressed> & PointerUpdateKind__middleButtonPressed & 5;// 5
static +middleButtonReleased: Class<PointerUpdateKind__middleButtonReleased> & PointerUpdateKind__middleButtonReleased & 6;// 6
static +xButton1Pressed: Class<PointerUpdateKind__xButton1Pressed> & PointerUpdateKind__xButton1Pressed & 7;// 7
static +xButton1Released: Class<PointerUpdateKind__xButton1Released> & PointerUpdateKind__xButton1Released & 8;// 8
static +xButton2Pressed: Class<PointerUpdateKind__xButton2Pressed> & PointerUpdateKind__xButton2Pressed & 9;// 9
static +xButton2Released: Class<PointerUpdateKind__xButton2Released> & PointerUpdateKind__xButton2Released & 10;// 10

}

declare class PointerUpdateKind__other mixins PointerUpdateKind {}
declare class PointerUpdateKind__leftButtonPressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__leftButtonReleased mixins PointerUpdateKind {}
declare class PointerUpdateKind__rightButtonPressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__rightButtonReleased mixins PointerUpdateKind {}
declare class PointerUpdateKind__middleButtonPressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__middleButtonReleased mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton1Pressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton1Released mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton2Pressed mixins PointerUpdateKind {}
declare class PointerUpdateKind__xButton2Released mixins PointerUpdateKind {}

	declare export interface IPointerPointProperties {
contactRect: Windows$Windows$Foundation.Rect,
contactRectRaw: Windows$Windows$Foundation.Rect,
isBarrelButtonPressed: boolean,
isCanceled: boolean,
isEraser: boolean,
isHorizontalMouseWheel: boolean,
isInRange: boolean,
isInverted: boolean,
isLeftButtonPressed: boolean,
isMiddleButtonPressed: boolean,
isPrimary: boolean,
isRightButtonPressed: boolean,
isXButton1Pressed: boolean,
isXButton2Pressed: boolean,
mouseWheelDelta: number,
orientation: number,
pointerUpdateKind: Windows$Windows$UI.Input.PointerUpdateKind,
pressure: number,
touchConfidence: boolean,
twist: number,
xTilt: number,
yTilt: number,
hasUsage(usagePage: number, usageId: number): boolean,
getUsageValue(usagePage: number, usageId: number): number
} 
	declare export interface IPointerVisualizationSettings {
isBarrelButtonFeedbackEnabled: boolean,
isContactFeedbackEnabled: boolean
} 
	declare export interface IPointerVisualizationSettingsStatics {
getForCurrentView(): Windows$Windows$UI.Input.PointerVisualizationSettings
} 
	declare export class PointerVisualizationSettings mixins undefined.IPointerVisualizationSettings {
isBarrelButtonFeedbackEnabled: boolean;
isContactFeedbackEnabled: boolean;
static getForCurrentView(): Windows$Windows$UI.Input.PointerVisualizationSettings
}
	declare module 'Inking' {
        declare export  class InkManipulationMode {
  constructor(...args: empty): mixed;
static +inking: Class<InkManipulationMode__inking> & InkManipulationMode__inking & 0;// 0
static +erasing: Class<InkManipulationMode__erasing> & InkManipulationMode__erasing & 1;// 1
static +selecting: Class<InkManipulationMode__selecting> & InkManipulationMode__selecting & 2;// 2

}

declare class InkManipulationMode__inking mixins InkManipulationMode {}
declare class InkManipulationMode__erasing mixins InkManipulationMode {}
declare class InkManipulationMode__selecting mixins InkManipulationMode {}

	declare export  class InkRecognitionTarget {
  constructor(...args: empty): mixed;
static +all: Class<InkRecognitionTarget__all> & InkRecognitionTarget__all & 0;// 0
static +selected: Class<InkRecognitionTarget__selected> & InkRecognitionTarget__selected & 1;// 1
static +recent: Class<InkRecognitionTarget__recent> & InkRecognitionTarget__recent & 2;// 2

}

declare class InkRecognitionTarget__all mixins InkRecognitionTarget {}
declare class InkRecognitionTarget__selected mixins InkRecognitionTarget {}
declare class InkRecognitionTarget__recent mixins InkRecognitionTarget {}

	declare export  class PenTipShape {
  constructor(...args: empty): mixed;
static +circle: Class<PenTipShape__circle> & PenTipShape__circle & 0;// 0
static +rectangle: Class<PenTipShape__rectangle> & PenTipShape__rectangle & 1;// 1

}

declare class PenTipShape__circle mixins PenTipShape {}
declare class PenTipShape__rectangle mixins PenTipShape {}

	declare export interface IInkDrawingAttributes {
color: Windows$Windows$UI.Color,
fitToCurve: boolean,
ignorePressure: boolean,
penTip: Windows$Windows$UI.Input.Inking.PenTipShape,
size: Windows$Windows$Foundation.Size
} 
	declare export class InkDrawingAttributes mixins undefined.IInkDrawingAttributes {
color: Windows$Windows$UI.Color;
fitToCurve: boolean;
ignorePressure: boolean;
penTip: Windows$Windows$UI.Input.Inking.PenTipShape;
size: Windows$Windows$Foundation.Size
}
	declare export interface IInkStrokeRenderingSegment {
bezierControlPoint1: Windows$Windows$Foundation.Point,
bezierControlPoint2: Windows$Windows$Foundation.Point,
position: Windows$Windows$Foundation.Point,
pressure: number,
tiltX: number,
tiltY: number,
twist: number
} 
	declare export class InkStrokeRenderingSegment mixins undefined.IInkStrokeRenderingSegment {
bezierControlPoint1: Windows$Windows$Foundation.Point;
bezierControlPoint2: Windows$Windows$Foundation.Point;
position: Windows$Windows$Foundation.Point;
pressure: number;
tiltX: number;
tiltY: number;
twist: number
}
	declare export interface IInkStroke {
boundingRect: Windows$Windows$Foundation.Rect,
drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes,
recognized: boolean,
selected: boolean,
getRenderingSegments(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStrokeRenderingSegment>,
clone(): Windows$Windows$UI.Input.Inking.InkStroke
} 
	declare export class InkStroke mixins undefined.IInkStroke {
boundingRect: Windows$Windows$Foundation.Rect;
drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes;
recognized: boolean;
selected: boolean;
getRenderingSegments(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStrokeRenderingSegment>;
clone(): Windows$Windows$UI.Input.Inking.InkStroke
}
	declare export interface IInkStrokeBuilder {
beginStroke(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void,
appendToStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.PointerPoint,
endStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.Inking.InkStroke,
createStroke(
points: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$UI.Input.Inking.InkStroke,
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void
} 
	declare export class InkStrokeBuilder mixins undefined.IInkStrokeBuilder {
beginStroke(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void;
appendToStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.PointerPoint;
endStroke(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$UI.Input.Inking.InkStroke;
createStroke(
points: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$UI.Input.Inking.InkStroke;
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void
}
	declare export interface IInkRecognitionResult {
boundingRect: Windows$Windows$Foundation.Rect,
getTextCandidates(): Windows$Windows$Foundation.Collections.IVectorView<string>,
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>
} 
	declare export class InkRecognitionResult mixins undefined.IInkRecognitionResult {
boundingRect: Windows$Windows$Foundation.Rect;
getTextCandidates(): Windows$Windows$Foundation.Collections.IVectorView<string>;
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>
}
	declare export interface IInkStrokeContainer {
boundingRect: Windows$Windows$Foundation.Rect,
addStroke(stroke: Windows$Windows$UI.Input.Inking.InkStroke): void,
deleteSelected(): Windows$Windows$Foundation.Rect,
moveSelected(translation: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect,
selectWithPolyLine(
polyline: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$Foundation.Rect,
selectWithLine(
from: Windows$Windows$Foundation.Point,
to: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect,
copySelectedToClipboard(): void,
pasteFromClipboard(position: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect,
canPasteFromClipboard(): boolean,
loadAsync(
inputStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<number>,
saveAsync(
outputStream: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>,
updateRecognitionResults(
recognitionResults: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>): void,
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>,
getRecognitionResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>
} 
	declare export class InkStrokeContainer mixins undefined.IInkStrokeContainer {
boundingRect: Windows$Windows$Foundation.Rect;
addStroke(stroke: Windows$Windows$UI.Input.Inking.InkStroke): void;
deleteSelected(): Windows$Windows$Foundation.Rect;
moveSelected(translation: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
selectWithPolyLine(
polyline: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$Foundation.Rect;
selectWithLine(
from: Windows$Windows$Foundation.Point,
to: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
copySelectedToClipboard(): void;
pasteFromClipboard(position: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
canPasteFromClipboard(): boolean;
loadAsync(
inputStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<number>;
saveAsync(
outputStream: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
updateRecognitionResults(
recognitionResults: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>): void;
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>;
getRecognitionResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>
}
	declare export interface IInkRecognizer {
name: string
} 
	declare export class InkRecognizer mixins undefined.IInkRecognizer {
name: string
}
	declare export interface IInkRecognizerContainer {
setDefaultRecognizer(recognizer: Windows$Windows$UI.Input.Inking.InkRecognizer): void,
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>,
getRecognizers(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognizer>
} 
	declare export class InkRecognizerContainer mixins undefined.IInkRecognizerContainer {
setDefaultRecognizer(recognizer: Windows$Windows$UI.Input.Inking.InkRecognizer): void;
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>;
getRecognizers(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognizer>
}
	declare export type IInkManager = {
mode: Windows$Windows$UI.Input.Inking.InkManipulationMode,
processPointerDown(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void,
processPointerUpdate(pointerPoint: Windows$Windows$UI.Input.PointerPoint): any,
processPointerUp(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$Foundation.Rect,
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void,
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>,
recognizeAsync(
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>
} & undefined.IInkStrokeContainer & undefined.IInkRecognizerContainer

	declare export class InkManager mixins undefined.IInkManager, undefined.IInkStrokeContainer, undefined.IInkRecognizerContainer {
mode: Windows$Windows$UI.Input.Inking.InkManipulationMode;
boundingRect: Windows$Windows$Foundation.Rect;
processPointerDown(pointerPoint: Windows$Windows$UI.Input.PointerPoint): void;
processPointerUpdate(pointerPoint: Windows$Windows$UI.Input.PointerPoint): any;
processPointerUp(
pointerPoint: Windows$Windows$UI.Input.PointerPoint): Windows$Windows$Foundation.Rect;
setDefaultDrawingAttributes(drawingAttributes: Windows$Windows$UI.Input.Inking.InkDrawingAttributes): void;
recognizeAsync(
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>;
addStroke(stroke: Windows$Windows$UI.Input.Inking.InkStroke): void;
deleteSelected(): Windows$Windows$Foundation.Rect;
moveSelected(translation: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
selectWithPolyLine(
polyline: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Point>): Windows$Windows$Foundation.Rect;
selectWithLine(
from: Windows$Windows$Foundation.Point,
to: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
copySelectedToClipboard(): void;
pasteFromClipboard(position: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.Rect;
canPasteFromClipboard(): boolean;
loadAsync(
inputStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<number>;
saveAsync(
outputStream: Windows$Windows$Storage.Streams.IOutputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<number, number>;
updateRecognitionResults(
recognitionResults: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>): void;
getStrokes(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkStroke>;
getRecognitionResults(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>;
setDefaultRecognizer(recognizer: Windows$Windows$UI.Input.Inking.InkRecognizer): void;
recognizeAsync(
strokeCollection: Windows$Windows$UI.Input.Inking.InkStrokeContainer,
recognitionTarget: Windows$Windows$UI.Input.Inking.InkRecognitionTarget): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognitionResult>>;
getRecognizers(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Input.Inking.InkRecognizer>
}
    }

    }

	declare module 'Popups' {
        declare export  class MessageDialogOptions {
  constructor(...args: empty): mixed;
static +none: Class<MessageDialogOptions__none> & MessageDialogOptions__none & 0;// 0
static +acceptUserInputAfterDelay: Class<MessageDialogOptions__acceptUserInputAfterDelay> & MessageDialogOptions__acceptUserInputAfterDelay & 1;// 1

}

declare class MessageDialogOptions__none mixins MessageDialogOptions {}
declare class MessageDialogOptions__acceptUserInputAfterDelay mixins MessageDialogOptions {}

	declare export interface IMessageDialog {
cancelCommandIndex: number,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
content: string,
defaultCommandIndex: number,
options: Windows$Windows$UI.Popups.MessageDialogOptions,
title: string,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface IMessageDialogFactory {
create(content: string): Windows$Windows$UI.Popups.MessageDialog,
createWithTitle(content: string, title: string): Windows$Windows$UI.Popups.MessageDialog
} 
	declare export class MessageDialog mixins undefined.IMessageDialog {
constructor(content: string): this;
constructor(content: string, title: string): this;
cancelCommandIndex: number;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
content: string;
defaultCommandIndex: number;
options: Windows$Windows$UI.Popups.MessageDialogOptions;
title: string;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
	declare export  class Placement {
  constructor(...args: empty): mixed;
static +default: Class<Placement__default> & Placement__default & 0;// 0
static +above: Class<Placement__above> & Placement__above & 1;// 1
static +below: Class<Placement__below> & Placement__below & 2;// 2
static +left: Class<Placement__left> & Placement__left & 3;// 3
static +right: Class<Placement__right> & Placement__right & 4;// 4

}

declare class Placement__default mixins Placement {}
declare class Placement__above mixins Placement {}
declare class Placement__below mixins Placement {}
declare class Placement__left mixins Placement {}
declare class Placement__right mixins Placement {}

	declare export interface UICommandInvokedHandler {
(command: Windows$Windows$UI.Popups.IUICommand): void
} 
	declare export interface IUICommand {
id: any,
invoked: Windows$Windows$UI.Popups.UICommandInvokedHandler,
label: string
} 
	declare export interface IUICommandFactory {
create(label: string): Windows$Windows$UI.Popups.UICommand,
createWithHandler(
label: string,
action: Windows$Windows$UI.Popups.UICommandInvokedHandler): Windows$Windows$UI.Popups.UICommand,
createWithHandlerAndId(
label: string,
action: Windows$Windows$UI.Popups.UICommandInvokedHandler,
commandId: any): Windows$Windows$UI.Popups.UICommand
} 
	declare export class UICommand mixins undefined.IUICommand {
constructor(label: string): this;
constructor(label: string, action: Windows$Windows$UI.Popups.UICommandInvokedHandler): this;
constructor(label: string, action: Windows$Windows$UI.Popups.UICommandInvokedHandler, commandId: any): this;
constructor(): this;
id: any;
invoked: Windows$Windows$UI.Popups.UICommandInvokedHandler;
label: string
}
	declare export class UICommandSeparator mixins undefined.IUICommand {
id: any;
invoked: Windows$Windows$UI.Popups.UICommandInvokedHandler;
label: string
}
	declare export interface IPopupMenu {
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
showAsync(
invocationPoint: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>,
showForSelectionAsync(
selection: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>,
showForSelectionAsync(
selection: Windows$Windows$Foundation.Rect,
preferredPlacement: Windows$Windows$UI.Popups.Placement): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export class PopupMenu mixins undefined.IPopupMenu {
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
showAsync(
invocationPoint: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>;
showForSelectionAsync(
selection: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>;
showForSelectionAsync(
selection: Windows$Windows$Foundation.Rect,
preferredPlacement: Windows$Windows$UI.Popups.Placement): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
    }

	declare module 'StartScreen' {
        declare export  class TileOptions {
  constructor(...args: empty): mixed;
static +none: Class<TileOptions__none> & TileOptions__none & 0;// 0
static +showNameOnLogo: Class<TileOptions__showNameOnLogo> & TileOptions__showNameOnLogo & 1;// 1
static +showNameOnWideLogo: Class<TileOptions__showNameOnWideLogo> & TileOptions__showNameOnWideLogo & 2;// 2
static +copyOnDeployment: Class<TileOptions__copyOnDeployment> & TileOptions__copyOnDeployment & 3;// 3

}

declare class TileOptions__none mixins TileOptions {}
declare class TileOptions__showNameOnLogo mixins TileOptions {}
declare class TileOptions__showNameOnWideLogo mixins TileOptions {}
declare class TileOptions__copyOnDeployment mixins TileOptions {}

	declare export  class ForegroundText {
  constructor(...args: empty): mixed;
static +dark: Class<ForegroundText__dark> & ForegroundText__dark & 0;// 0
static +light: Class<ForegroundText__light> & ForegroundText__light & 1;// 1

}

declare class ForegroundText__dark mixins ForegroundText {}
declare class ForegroundText__light mixins ForegroundText {}

	declare export interface ISecondaryTile {
arguments: string,
backgroundColor: Windows$Windows$UI.Color,
displayName: string,
foregroundText: Windows$Windows$UI.StartScreen.ForegroundText,
lockScreenBadgeLogo: Windows$Windows$Foundation.Uri,
lockScreenDisplayBadgeAndTileText: boolean,
logo: Windows$Windows$Foundation.Uri,
shortName: string,
smallLogo: Windows$Windows$Foundation.Uri,
tileId: string,
tileOptions: Windows$Windows$UI.StartScreen.TileOptions,
wideLogo: Windows$Windows$Foundation.Uri,
requestCreateAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>,
requestCreateAsync(
invocationPoint: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.IAsyncOperation<boolean>,
requestCreateForSelectionAsync(
selection: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.IAsyncOperation<boolean>,
requestCreateForSelectionAsync(
selection: Windows$Windows$Foundation.Rect,
preferredPlacement: Windows$Windows$UI.Popups.Placement): Windows$Windows$Foundation.IAsyncOperation<boolean>,
requestDeleteAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>,
requestDeleteAsync(
invocationPoint: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.IAsyncOperation<boolean>,
requestDeleteForSelectionAsync(
selection: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.IAsyncOperation<boolean>,
requestDeleteForSelectionAsync(
selection: Windows$Windows$Foundation.Rect,
preferredPlacement: Windows$Windows$UI.Popups.Placement): Windows$Windows$Foundation.IAsyncOperation<boolean>,
updateAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>
} 
	declare export interface ISecondaryTileFactory {
createTile(
tileId: string,
shortName: string,
displayName: string,
arguments: string,
tileOptions: Windows$Windows$UI.StartScreen.TileOptions,
logoReference: Windows$Windows$Foundation.Uri): Windows$Windows$UI.StartScreen.SecondaryTile,
createWideTile(
tileId: string,
shortName: string,
displayName: string,
arguments: string,
tileOptions: Windows$Windows$UI.StartScreen.TileOptions,
logoReference: Windows$Windows$Foundation.Uri,
wideLogoReference: Windows$Windows$Foundation.Uri): Windows$Windows$UI.StartScreen.SecondaryTile,
createWithId(tileId: string): Windows$Windows$UI.StartScreen.SecondaryTile
} 
	declare export class SecondaryTile mixins undefined.ISecondaryTile {
constructor(tileId: string, shortName: string, displayName: string, args: string, tileOptions: Windows$Windows$UI.StartScreen.TileOptions, logoReference: Windows$Windows$Foundation.Uri): this;
constructor(tileId: string, shortName: string, displayName: string, args: string, tileOptions: Windows$Windows$UI.StartScreen.TileOptions, logoReference: Windows$Windows$Foundation.Uri, wideLogoReference: Windows$Windows$Foundation.Uri): this;
constructor(tileId: string): this;
constructor(): this;
arguments: string;
backgroundColor: Windows$Windows$UI.Color;
displayName: string;
foregroundText: Windows$Windows$UI.StartScreen.ForegroundText;
lockScreenBadgeLogo: Windows$Windows$Foundation.Uri;
lockScreenDisplayBadgeAndTileText: boolean;
logo: Windows$Windows$Foundation.Uri;
shortName: string;
smallLogo: Windows$Windows$Foundation.Uri;
tileId: string;
tileOptions: Windows$Windows$UI.StartScreen.TileOptions;
wideLogo: Windows$Windows$Foundation.Uri;
requestCreateAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
requestCreateAsync(
invocationPoint: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.IAsyncOperation<boolean>;
requestCreateForSelectionAsync(
selection: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.IAsyncOperation<boolean>;
requestCreateForSelectionAsync(
selection: Windows$Windows$Foundation.Rect,
preferredPlacement: Windows$Windows$UI.Popups.Placement): Windows$Windows$Foundation.IAsyncOperation<boolean>;
requestDeleteAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
requestDeleteAsync(
invocationPoint: Windows$Windows$Foundation.Point): Windows$Windows$Foundation.IAsyncOperation<boolean>;
requestDeleteForSelectionAsync(
selection: Windows$Windows$Foundation.Rect): Windows$Windows$Foundation.IAsyncOperation<boolean>;
requestDeleteForSelectionAsync(
selection: Windows$Windows$Foundation.Rect,
preferredPlacement: Windows$Windows$UI.Popups.Placement): Windows$Windows$Foundation.IAsyncOperation<boolean>;
updateAsync(): Windows$Windows$Foundation.IAsyncOperation<boolean>;
static exists(tileId: string): boolean;
static findAllAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.StartScreen.SecondaryTile>>;
static findAllAsync(
applicationId: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.StartScreen.SecondaryTile>>;
static findAllForPackageAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.StartScreen.SecondaryTile>>
}
	declare export interface ISecondaryTileStatics {
exists(tileId: string): boolean,
findAllAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.StartScreen.SecondaryTile>>,
findAllAsync(
applicationId: string): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.StartScreen.SecondaryTile>>,
findAllForPackageAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.StartScreen.SecondaryTile>>
} 
    }

	declare module 'Text' {
        declare export  class CaretType {
  constructor(...args: empty): mixed;
static +normal: Class<CaretType__normal> & CaretType__normal & 0;// 0
static +null_: Class<CaretType__null_> & CaretType__null_ & 1;// 1

}

declare class CaretType__normal mixins CaretType {}
declare class CaretType__null_ mixins CaretType {}

	declare export  class FindOptions {
  constructor(...args: empty): mixed;
static +none: Class<FindOptions__none> & FindOptions__none & 0;// 0
static +word: Class<FindOptions__word> & FindOptions__word & 1;// 1
static +case_: Class<FindOptions__case_> & FindOptions__case_ & 2;// 2

}

declare class FindOptions__none mixins FindOptions {}
declare class FindOptions__word mixins FindOptions {}
declare class FindOptions__case_ mixins FindOptions {}

	declare export  class FormatEffect {
  constructor(...args: empty): mixed;
static +off: Class<FormatEffect__off> & FormatEffect__off & 0;// 0
static +on: Class<FormatEffect__on> & FormatEffect__on & 1;// 1
static +toggle: Class<FormatEffect__toggle> & FormatEffect__toggle & 2;// 2
static +undefined: Class<FormatEffect__undefined> & FormatEffect__undefined & 3;// 3

}

declare class FormatEffect__off mixins FormatEffect {}
declare class FormatEffect__on mixins FormatEffect {}
declare class FormatEffect__toggle mixins FormatEffect {}
declare class FormatEffect__undefined mixins FormatEffect {}

	declare export  class HorizontalCharacterAlignment {
  constructor(...args: empty): mixed;
static +left: Class<HorizontalCharacterAlignment__left> & HorizontalCharacterAlignment__left & 0;// 0
static +right: Class<HorizontalCharacterAlignment__right> & HorizontalCharacterAlignment__right & 1;// 1
static +center: Class<HorizontalCharacterAlignment__center> & HorizontalCharacterAlignment__center & 2;// 2

}

declare class HorizontalCharacterAlignment__left mixins HorizontalCharacterAlignment {}
declare class HorizontalCharacterAlignment__right mixins HorizontalCharacterAlignment {}
declare class HorizontalCharacterAlignment__center mixins HorizontalCharacterAlignment {}

	declare export  class LetterCase {
  constructor(...args: empty): mixed;
static +lower: Class<LetterCase__lower> & LetterCase__lower & 0;// 0
static +upper: Class<LetterCase__upper> & LetterCase__upper & 1;// 1

}

declare class LetterCase__lower mixins LetterCase {}
declare class LetterCase__upper mixins LetterCase {}

	declare export  class LineSpacingRule {
  constructor(...args: empty): mixed;
static +undefined: Class<LineSpacingRule__undefined> & LineSpacingRule__undefined & 0;// 0
static +single: Class<LineSpacingRule__single> & LineSpacingRule__single & 1;// 1
static +oneAndHalf: Class<LineSpacingRule__oneAndHalf> & LineSpacingRule__oneAndHalf & 2;// 2
static +double: Class<LineSpacingRule__double> & LineSpacingRule__double & 3;// 3
static +atLeast: Class<LineSpacingRule__atLeast> & LineSpacingRule__atLeast & 4;// 4
static +exactly: Class<LineSpacingRule__exactly> & LineSpacingRule__exactly & 5;// 5
static +multiple: Class<LineSpacingRule__multiple> & LineSpacingRule__multiple & 6;// 6
static +percent: Class<LineSpacingRule__percent> & LineSpacingRule__percent & 7;// 7

}

declare class LineSpacingRule__undefined mixins LineSpacingRule {}
declare class LineSpacingRule__single mixins LineSpacingRule {}
declare class LineSpacingRule__oneAndHalf mixins LineSpacingRule {}
declare class LineSpacingRule__double mixins LineSpacingRule {}
declare class LineSpacingRule__atLeast mixins LineSpacingRule {}
declare class LineSpacingRule__exactly mixins LineSpacingRule {}
declare class LineSpacingRule__multiple mixins LineSpacingRule {}
declare class LineSpacingRule__percent mixins LineSpacingRule {}

	declare export  class LinkType {
  constructor(...args: empty): mixed;
static +undefined: Class<LinkType__undefined> & LinkType__undefined & 0;// 0
static +notALink: Class<LinkType__notALink> & LinkType__notALink & 1;// 1
static +clientLink: Class<LinkType__clientLink> & LinkType__clientLink & 2;// 2
static +friendlyLinkName: Class<LinkType__friendlyLinkName> & LinkType__friendlyLinkName & 3;// 3
static +friendlyLinkAddress: Class<LinkType__friendlyLinkAddress> & LinkType__friendlyLinkAddress & 4;// 4
static +autoLink: Class<LinkType__autoLink> & LinkType__autoLink & 5;// 5
static +autoLinkEmail: Class<LinkType__autoLinkEmail> & LinkType__autoLinkEmail & 6;// 6
static +autoLinkPhone: Class<LinkType__autoLinkPhone> & LinkType__autoLinkPhone & 7;// 7
static +autoLinkPath: Class<LinkType__autoLinkPath> & LinkType__autoLinkPath & 8;// 8

}

declare class LinkType__undefined mixins LinkType {}
declare class LinkType__notALink mixins LinkType {}
declare class LinkType__clientLink mixins LinkType {}
declare class LinkType__friendlyLinkName mixins LinkType {}
declare class LinkType__friendlyLinkAddress mixins LinkType {}
declare class LinkType__autoLink mixins LinkType {}
declare class LinkType__autoLinkEmail mixins LinkType {}
declare class LinkType__autoLinkPhone mixins LinkType {}
declare class LinkType__autoLinkPath mixins LinkType {}

	declare export  class MarkerAlignment {
  constructor(...args: empty): mixed;
static +undefined: Class<MarkerAlignment__undefined> & MarkerAlignment__undefined & 0;// 0
static +left: Class<MarkerAlignment__left> & MarkerAlignment__left & 1;// 1
static +center: Class<MarkerAlignment__center> & MarkerAlignment__center & 2;// 2
static +right: Class<MarkerAlignment__right> & MarkerAlignment__right & 3;// 3

}

declare class MarkerAlignment__undefined mixins MarkerAlignment {}
declare class MarkerAlignment__left mixins MarkerAlignment {}
declare class MarkerAlignment__center mixins MarkerAlignment {}
declare class MarkerAlignment__right mixins MarkerAlignment {}

	declare export  class MarkerStyle {
  constructor(...args: empty): mixed;
static +undefined: Class<MarkerStyle__undefined> & MarkerStyle__undefined & 0;// 0
static +parenthesis: Class<MarkerStyle__parenthesis> & MarkerStyle__parenthesis & 1;// 1
static +parentheses: Class<MarkerStyle__parentheses> & MarkerStyle__parentheses & 2;// 2
static +period: Class<MarkerStyle__period> & MarkerStyle__period & 3;// 3
static +plain: Class<MarkerStyle__plain> & MarkerStyle__plain & 4;// 4
static +minus: Class<MarkerStyle__minus> & MarkerStyle__minus & 5;// 5
static +noNumber: Class<MarkerStyle__noNumber> & MarkerStyle__noNumber & 6;// 6

}

declare class MarkerStyle__undefined mixins MarkerStyle {}
declare class MarkerStyle__parenthesis mixins MarkerStyle {}
declare class MarkerStyle__parentheses mixins MarkerStyle {}
declare class MarkerStyle__period mixins MarkerStyle {}
declare class MarkerStyle__plain mixins MarkerStyle {}
declare class MarkerStyle__minus mixins MarkerStyle {}
declare class MarkerStyle__noNumber mixins MarkerStyle {}

	declare export  class MarkerType {
  constructor(...args: empty): mixed;
static +undefined: Class<MarkerType__undefined> & MarkerType__undefined & 0;// 0
static +none: Class<MarkerType__none> & MarkerType__none & 1;// 1
static +bullet: Class<MarkerType__bullet> & MarkerType__bullet & 2;// 2
static +arabic: Class<MarkerType__arabic> & MarkerType__arabic & 3;// 3
static +lowercaseEnglishLetter: Class<MarkerType__lowercaseEnglishLetter> & MarkerType__lowercaseEnglishLetter & 4;// 4
static +uppercaseEnglishLetter: Class<MarkerType__uppercaseEnglishLetter> & MarkerType__uppercaseEnglishLetter & 5;// 5
static +lowercaseRoman: Class<MarkerType__lowercaseRoman> & MarkerType__lowercaseRoman & 6;// 6
static +uppercaseRoman: Class<MarkerType__uppercaseRoman> & MarkerType__uppercaseRoman & 7;// 7
static +unicodeSequence: Class<MarkerType__unicodeSequence> & MarkerType__unicodeSequence & 8;// 8
static +circledNumber: Class<MarkerType__circledNumber> & MarkerType__circledNumber & 9;// 9
static +blackCircleWingding: Class<MarkerType__blackCircleWingding> & MarkerType__blackCircleWingding & 10;// 10
static +whiteCircleWingding: Class<MarkerType__whiteCircleWingding> & MarkerType__whiteCircleWingding & 11;// 11
static +arabicWide: Class<MarkerType__arabicWide> & MarkerType__arabicWide & 12;// 12
static +simplifiedChinese: Class<MarkerType__simplifiedChinese> & MarkerType__simplifiedChinese & 13;// 13
static +traditionalChinese: Class<MarkerType__traditionalChinese> & MarkerType__traditionalChinese & 14;// 14
static +japanSimplifiedChinese: Class<MarkerType__japanSimplifiedChinese> & MarkerType__japanSimplifiedChinese & 15;// 15
static +japanKorea: Class<MarkerType__japanKorea> & MarkerType__japanKorea & 16;// 16
static +arabicDictionary: Class<MarkerType__arabicDictionary> & MarkerType__arabicDictionary & 17;// 17
static +arabicAbjad: Class<MarkerType__arabicAbjad> & MarkerType__arabicAbjad & 18;// 18
static +hebrew: Class<MarkerType__hebrew> & MarkerType__hebrew & 19;// 19
static +thaiAlphabetic: Class<MarkerType__thaiAlphabetic> & MarkerType__thaiAlphabetic & 20;// 20
static +thaiNumeric: Class<MarkerType__thaiNumeric> & MarkerType__thaiNumeric & 21;// 21
static +devanagariVowel: Class<MarkerType__devanagariVowel> & MarkerType__devanagariVowel & 22;// 22
static +devanagariConsonant: Class<MarkerType__devanagariConsonant> & MarkerType__devanagariConsonant & 23;// 23
static +devanagariNumeric: Class<MarkerType__devanagariNumeric> & MarkerType__devanagariNumeric & 24;// 24

}

declare class MarkerType__undefined mixins MarkerType {}
declare class MarkerType__none mixins MarkerType {}
declare class MarkerType__bullet mixins MarkerType {}
declare class MarkerType__arabic mixins MarkerType {}
declare class MarkerType__lowercaseEnglishLetter mixins MarkerType {}
declare class MarkerType__uppercaseEnglishLetter mixins MarkerType {}
declare class MarkerType__lowercaseRoman mixins MarkerType {}
declare class MarkerType__uppercaseRoman mixins MarkerType {}
declare class MarkerType__unicodeSequence mixins MarkerType {}
declare class MarkerType__circledNumber mixins MarkerType {}
declare class MarkerType__blackCircleWingding mixins MarkerType {}
declare class MarkerType__whiteCircleWingding mixins MarkerType {}
declare class MarkerType__arabicWide mixins MarkerType {}
declare class MarkerType__simplifiedChinese mixins MarkerType {}
declare class MarkerType__traditionalChinese mixins MarkerType {}
declare class MarkerType__japanSimplifiedChinese mixins MarkerType {}
declare class MarkerType__japanKorea mixins MarkerType {}
declare class MarkerType__arabicDictionary mixins MarkerType {}
declare class MarkerType__arabicAbjad mixins MarkerType {}
declare class MarkerType__hebrew mixins MarkerType {}
declare class MarkerType__thaiAlphabetic mixins MarkerType {}
declare class MarkerType__thaiNumeric mixins MarkerType {}
declare class MarkerType__devanagariVowel mixins MarkerType {}
declare class MarkerType__devanagariConsonant mixins MarkerType {}
declare class MarkerType__devanagariNumeric mixins MarkerType {}

	declare export  class ParagraphAlignment {
  constructor(...args: empty): mixed;
static +undefined: Class<ParagraphAlignment__undefined> & ParagraphAlignment__undefined & 0;// 0
static +left: Class<ParagraphAlignment__left> & ParagraphAlignment__left & 1;// 1
static +center: Class<ParagraphAlignment__center> & ParagraphAlignment__center & 2;// 2
static +right: Class<ParagraphAlignment__right> & ParagraphAlignment__right & 3;// 3
static +justify: Class<ParagraphAlignment__justify> & ParagraphAlignment__justify & 4;// 4

}

declare class ParagraphAlignment__undefined mixins ParagraphAlignment {}
declare class ParagraphAlignment__left mixins ParagraphAlignment {}
declare class ParagraphAlignment__center mixins ParagraphAlignment {}
declare class ParagraphAlignment__right mixins ParagraphAlignment {}
declare class ParagraphAlignment__justify mixins ParagraphAlignment {}

	declare export  class ParagraphStyle {
  constructor(...args: empty): mixed;
static +undefined: Class<ParagraphStyle__undefined> & ParagraphStyle__undefined & 0;// 0
static +none: Class<ParagraphStyle__none> & ParagraphStyle__none & 1;// 1
static +normal: Class<ParagraphStyle__normal> & ParagraphStyle__normal & 2;// 2
static +heading1: Class<ParagraphStyle__heading1> & ParagraphStyle__heading1 & 3;// 3
static +heading2: Class<ParagraphStyle__heading2> & ParagraphStyle__heading2 & 4;// 4
static +heading3: Class<ParagraphStyle__heading3> & ParagraphStyle__heading3 & 5;// 5
static +heading4: Class<ParagraphStyle__heading4> & ParagraphStyle__heading4 & 6;// 6
static +heading5: Class<ParagraphStyle__heading5> & ParagraphStyle__heading5 & 7;// 7
static +heading6: Class<ParagraphStyle__heading6> & ParagraphStyle__heading6 & 8;// 8
static +heading7: Class<ParagraphStyle__heading7> & ParagraphStyle__heading7 & 9;// 9
static +heading8: Class<ParagraphStyle__heading8> & ParagraphStyle__heading8 & 10;// 10
static +heading9: Class<ParagraphStyle__heading9> & ParagraphStyle__heading9 & 11;// 11

}

declare class ParagraphStyle__undefined mixins ParagraphStyle {}
declare class ParagraphStyle__none mixins ParagraphStyle {}
declare class ParagraphStyle__normal mixins ParagraphStyle {}
declare class ParagraphStyle__heading1 mixins ParagraphStyle {}
declare class ParagraphStyle__heading2 mixins ParagraphStyle {}
declare class ParagraphStyle__heading3 mixins ParagraphStyle {}
declare class ParagraphStyle__heading4 mixins ParagraphStyle {}
declare class ParagraphStyle__heading5 mixins ParagraphStyle {}
declare class ParagraphStyle__heading6 mixins ParagraphStyle {}
declare class ParagraphStyle__heading7 mixins ParagraphStyle {}
declare class ParagraphStyle__heading8 mixins ParagraphStyle {}
declare class ParagraphStyle__heading9 mixins ParagraphStyle {}

	declare export  class PointOptions {
  constructor(...args: empty): mixed;
static +none: Class<PointOptions__none> & PointOptions__none & 0;// 0
static +includeInset: Class<PointOptions__includeInset> & PointOptions__includeInset & 1;// 1
static +start: Class<PointOptions__start> & PointOptions__start & 2;// 2
static +clientCoordinates: Class<PointOptions__clientCoordinates> & PointOptions__clientCoordinates & 3;// 3
static +allowOffClient: Class<PointOptions__allowOffClient> & PointOptions__allowOffClient & 4;// 4
static +transform: Class<PointOptions__transform> & PointOptions__transform & 5;// 5
static +noHorizontalScroll: Class<PointOptions__noHorizontalScroll> & PointOptions__noHorizontalScroll & 6;// 6
static +noVerticalScroll: Class<PointOptions__noVerticalScroll> & PointOptions__noVerticalScroll & 7;// 7

}

declare class PointOptions__none mixins PointOptions {}
declare class PointOptions__includeInset mixins PointOptions {}
declare class PointOptions__start mixins PointOptions {}
declare class PointOptions__clientCoordinates mixins PointOptions {}
declare class PointOptions__allowOffClient mixins PointOptions {}
declare class PointOptions__transform mixins PointOptions {}
declare class PointOptions__noHorizontalScroll mixins PointOptions {}
declare class PointOptions__noVerticalScroll mixins PointOptions {}

	declare export  class RangeGravity {
  constructor(...args: empty): mixed;
static +uIBehavior: Class<RangeGravity__uIBehavior> & RangeGravity__uIBehavior & 0;// 0
static +backward: Class<RangeGravity__backward> & RangeGravity__backward & 1;// 1
static +forward: Class<RangeGravity__forward> & RangeGravity__forward & 2;// 2
static +inward: Class<RangeGravity__inward> & RangeGravity__inward & 3;// 3
static +outward: Class<RangeGravity__outward> & RangeGravity__outward & 4;// 4

}

declare class RangeGravity__uIBehavior mixins RangeGravity {}
declare class RangeGravity__backward mixins RangeGravity {}
declare class RangeGravity__forward mixins RangeGravity {}
declare class RangeGravity__inward mixins RangeGravity {}
declare class RangeGravity__outward mixins RangeGravity {}

	declare export  class SelectionOptions {
  constructor(...args: empty): mixed;
static +startActive: Class<SelectionOptions__startActive> & SelectionOptions__startActive & 0;// 0
static +atEndOfLine: Class<SelectionOptions__atEndOfLine> & SelectionOptions__atEndOfLine & 1;// 1
static +overtype: Class<SelectionOptions__overtype> & SelectionOptions__overtype & 2;// 2
static +active: Class<SelectionOptions__active> & SelectionOptions__active & 3;// 3
static +replace: Class<SelectionOptions__replace> & SelectionOptions__replace & 4;// 4

}

declare class SelectionOptions__startActive mixins SelectionOptions {}
declare class SelectionOptions__atEndOfLine mixins SelectionOptions {}
declare class SelectionOptions__overtype mixins SelectionOptions {}
declare class SelectionOptions__active mixins SelectionOptions {}
declare class SelectionOptions__replace mixins SelectionOptions {}

	declare export  class SelectionType {
  constructor(...args: empty): mixed;
static +none: Class<SelectionType__none> & SelectionType__none & 0;// 0
static +insertionPoint: Class<SelectionType__insertionPoint> & SelectionType__insertionPoint & 1;// 1
static +normal: Class<SelectionType__normal> & SelectionType__normal & 2;// 2
static +inlineShape: Class<SelectionType__inlineShape> & SelectionType__inlineShape & 3;// 3
static +shape: Class<SelectionType__shape> & SelectionType__shape & 4;// 4

}

declare class SelectionType__none mixins SelectionType {}
declare class SelectionType__insertionPoint mixins SelectionType {}
declare class SelectionType__normal mixins SelectionType {}
declare class SelectionType__inlineShape mixins SelectionType {}
declare class SelectionType__shape mixins SelectionType {}

	declare export  class TabAlignment {
  constructor(...args: empty): mixed;
static +left: Class<TabAlignment__left> & TabAlignment__left & 0;// 0
static +center: Class<TabAlignment__center> & TabAlignment__center & 1;// 1
static +right: Class<TabAlignment__right> & TabAlignment__right & 2;// 2
static +decimal: Class<TabAlignment__decimal> & TabAlignment__decimal & 3;// 3
static +bar: Class<TabAlignment__bar> & TabAlignment__bar & 4;// 4

}

declare class TabAlignment__left mixins TabAlignment {}
declare class TabAlignment__center mixins TabAlignment {}
declare class TabAlignment__right mixins TabAlignment {}
declare class TabAlignment__decimal mixins TabAlignment {}
declare class TabAlignment__bar mixins TabAlignment {}

	declare export  class TabLeader {
  constructor(...args: empty): mixed;
static +spaces: Class<TabLeader__spaces> & TabLeader__spaces & 0;// 0
static +dots: Class<TabLeader__dots> & TabLeader__dots & 1;// 1
static +dashes: Class<TabLeader__dashes> & TabLeader__dashes & 2;// 2
static +lines: Class<TabLeader__lines> & TabLeader__lines & 3;// 3
static +thickLines: Class<TabLeader__thickLines> & TabLeader__thickLines & 4;// 4
static +equals: Class<TabLeader__equals> & TabLeader__equals & 5;// 5

}

declare class TabLeader__spaces mixins TabLeader {}
declare class TabLeader__dots mixins TabLeader {}
declare class TabLeader__dashes mixins TabLeader {}
declare class TabLeader__lines mixins TabLeader {}
declare class TabLeader__thickLines mixins TabLeader {}
declare class TabLeader__equals mixins TabLeader {}

	declare export  class TextGetOptions {
  constructor(...args: empty): mixed;
static +none: Class<TextGetOptions__none> & TextGetOptions__none & 0;// 0
static +adjustCrlf: Class<TextGetOptions__adjustCrlf> & TextGetOptions__adjustCrlf & 1;// 1
static +useCrlf: Class<TextGetOptions__useCrlf> & TextGetOptions__useCrlf & 2;// 2
static +useObjectText: Class<TextGetOptions__useObjectText> & TextGetOptions__useObjectText & 3;// 3
static +allowFinalEop: Class<TextGetOptions__allowFinalEop> & TextGetOptions__allowFinalEop & 4;// 4
static +noHidden: Class<TextGetOptions__noHidden> & TextGetOptions__noHidden & 5;// 5
static +includeNumbering: Class<TextGetOptions__includeNumbering> & TextGetOptions__includeNumbering & 6;// 6
static +formatRtf: Class<TextGetOptions__formatRtf> & TextGetOptions__formatRtf & 7;// 7

}

declare class TextGetOptions__none mixins TextGetOptions {}
declare class TextGetOptions__adjustCrlf mixins TextGetOptions {}
declare class TextGetOptions__useCrlf mixins TextGetOptions {}
declare class TextGetOptions__useObjectText mixins TextGetOptions {}
declare class TextGetOptions__allowFinalEop mixins TextGetOptions {}
declare class TextGetOptions__noHidden mixins TextGetOptions {}
declare class TextGetOptions__includeNumbering mixins TextGetOptions {}
declare class TextGetOptions__formatRtf mixins TextGetOptions {}

	declare export  class TextSetOptions {
  constructor(...args: empty): mixed;
static +none: Class<TextSetOptions__none> & TextSetOptions__none & 0;// 0
static +unicodeBidi: Class<TextSetOptions__unicodeBidi> & TextSetOptions__unicodeBidi & 1;// 1
static +unlink: Class<TextSetOptions__unlink> & TextSetOptions__unlink & 2;// 2
static +unhide: Class<TextSetOptions__unhide> & TextSetOptions__unhide & 3;// 3
static +checkTextLimit: Class<TextSetOptions__checkTextLimit> & TextSetOptions__checkTextLimit & 4;// 4
static +formatRtf: Class<TextSetOptions__formatRtf> & TextSetOptions__formatRtf & 5;// 5
static +applyRtfDocumentDefaults: Class<TextSetOptions__applyRtfDocumentDefaults> & TextSetOptions__applyRtfDocumentDefaults & 6;// 6

}

declare class TextSetOptions__none mixins TextSetOptions {}
declare class TextSetOptions__unicodeBidi mixins TextSetOptions {}
declare class TextSetOptions__unlink mixins TextSetOptions {}
declare class TextSetOptions__unhide mixins TextSetOptions {}
declare class TextSetOptions__checkTextLimit mixins TextSetOptions {}
declare class TextSetOptions__formatRtf mixins TextSetOptions {}
declare class TextSetOptions__applyRtfDocumentDefaults mixins TextSetOptions {}

	declare export  class TextRangeUnit {
  constructor(...args: empty): mixed;
static +character: Class<TextRangeUnit__character> & TextRangeUnit__character & 0;// 0
static +word: Class<TextRangeUnit__word> & TextRangeUnit__word & 1;// 1
static +sentence: Class<TextRangeUnit__sentence> & TextRangeUnit__sentence & 2;// 2
static +paragraph: Class<TextRangeUnit__paragraph> & TextRangeUnit__paragraph & 3;// 3
static +line: Class<TextRangeUnit__line> & TextRangeUnit__line & 4;// 4
static +story: Class<TextRangeUnit__story> & TextRangeUnit__story & 5;// 5
static +screen: Class<TextRangeUnit__screen> & TextRangeUnit__screen & 6;// 6
static +section: Class<TextRangeUnit__section> & TextRangeUnit__section & 7;// 7
static +window: Class<TextRangeUnit__window> & TextRangeUnit__window & 8;// 8
static +characterFormat: Class<TextRangeUnit__characterFormat> & TextRangeUnit__characterFormat & 9;// 9
static +paragraphFormat: Class<TextRangeUnit__paragraphFormat> & TextRangeUnit__paragraphFormat & 10;// 10
static +object: Class<TextRangeUnit__object> & TextRangeUnit__object & 11;// 11
static +hardParagraph: Class<TextRangeUnit__hardParagraph> & TextRangeUnit__hardParagraph & 12;// 12
static +cluster: Class<TextRangeUnit__cluster> & TextRangeUnit__cluster & 13;// 13
static +bold: Class<TextRangeUnit__bold> & TextRangeUnit__bold & 14;// 14
static +italic: Class<TextRangeUnit__italic> & TextRangeUnit__italic & 15;// 15
static +underline: Class<TextRangeUnit__underline> & TextRangeUnit__underline & 16;// 16
static +strikethrough: Class<TextRangeUnit__strikethrough> & TextRangeUnit__strikethrough & 17;// 17
static +protectedText: Class<TextRangeUnit__protectedText> & TextRangeUnit__protectedText & 18;// 18
static +link: Class<TextRangeUnit__link> & TextRangeUnit__link & 19;// 19
static +smallCaps: Class<TextRangeUnit__smallCaps> & TextRangeUnit__smallCaps & 20;// 20
static +allCaps: Class<TextRangeUnit__allCaps> & TextRangeUnit__allCaps & 21;// 21
static +hidden: Class<TextRangeUnit__hidden> & TextRangeUnit__hidden & 22;// 22
static +outline: Class<TextRangeUnit__outline> & TextRangeUnit__outline & 23;// 23
static +shadow: Class<TextRangeUnit__shadow> & TextRangeUnit__shadow & 24;// 24
static +imprint: Class<TextRangeUnit__imprint> & TextRangeUnit__imprint & 25;// 25
static +disabled: Class<TextRangeUnit__disabled> & TextRangeUnit__disabled & 26;// 26
static +revised: Class<TextRangeUnit__revised> & TextRangeUnit__revised & 27;// 27
static +subscript: Class<TextRangeUnit__subscript> & TextRangeUnit__subscript & 28;// 28
static +superscript: Class<TextRangeUnit__superscript> & TextRangeUnit__superscript & 29;// 29
static +fontBound: Class<TextRangeUnit__fontBound> & TextRangeUnit__fontBound & 30;// 30
static +linkProtected: Class<TextRangeUnit__linkProtected> & TextRangeUnit__linkProtected & 31;// 31

}

declare class TextRangeUnit__character mixins TextRangeUnit {}
declare class TextRangeUnit__word mixins TextRangeUnit {}
declare class TextRangeUnit__sentence mixins TextRangeUnit {}
declare class TextRangeUnit__paragraph mixins TextRangeUnit {}
declare class TextRangeUnit__line mixins TextRangeUnit {}
declare class TextRangeUnit__story mixins TextRangeUnit {}
declare class TextRangeUnit__screen mixins TextRangeUnit {}
declare class TextRangeUnit__section mixins TextRangeUnit {}
declare class TextRangeUnit__window mixins TextRangeUnit {}
declare class TextRangeUnit__characterFormat mixins TextRangeUnit {}
declare class TextRangeUnit__paragraphFormat mixins TextRangeUnit {}
declare class TextRangeUnit__object mixins TextRangeUnit {}
declare class TextRangeUnit__hardParagraph mixins TextRangeUnit {}
declare class TextRangeUnit__cluster mixins TextRangeUnit {}
declare class TextRangeUnit__bold mixins TextRangeUnit {}
declare class TextRangeUnit__italic mixins TextRangeUnit {}
declare class TextRangeUnit__underline mixins TextRangeUnit {}
declare class TextRangeUnit__strikethrough mixins TextRangeUnit {}
declare class TextRangeUnit__protectedText mixins TextRangeUnit {}
declare class TextRangeUnit__link mixins TextRangeUnit {}
declare class TextRangeUnit__smallCaps mixins TextRangeUnit {}
declare class TextRangeUnit__allCaps mixins TextRangeUnit {}
declare class TextRangeUnit__hidden mixins TextRangeUnit {}
declare class TextRangeUnit__outline mixins TextRangeUnit {}
declare class TextRangeUnit__shadow mixins TextRangeUnit {}
declare class TextRangeUnit__imprint mixins TextRangeUnit {}
declare class TextRangeUnit__disabled mixins TextRangeUnit {}
declare class TextRangeUnit__revised mixins TextRangeUnit {}
declare class TextRangeUnit__subscript mixins TextRangeUnit {}
declare class TextRangeUnit__superscript mixins TextRangeUnit {}
declare class TextRangeUnit__fontBound mixins TextRangeUnit {}
declare class TextRangeUnit__linkProtected mixins TextRangeUnit {}

	declare export  class TextScript {
  constructor(...args: empty): mixed;
static +undefined: Class<TextScript__undefined> & TextScript__undefined & 0;// 0
static +ansi: Class<TextScript__ansi> & TextScript__ansi & 1;// 1
static +eastEurope: Class<TextScript__eastEurope> & TextScript__eastEurope & 2;// 2
static +cyrillic: Class<TextScript__cyrillic> & TextScript__cyrillic & 3;// 3
static +greek: Class<TextScript__greek> & TextScript__greek & 4;// 4
static +turkish: Class<TextScript__turkish> & TextScript__turkish & 5;// 5
static +hebrew: Class<TextScript__hebrew> & TextScript__hebrew & 6;// 6
static +arabic: Class<TextScript__arabic> & TextScript__arabic & 7;// 7
static +baltic: Class<TextScript__baltic> & TextScript__baltic & 8;// 8
static +vietnamese: Class<TextScript__vietnamese> & TextScript__vietnamese & 9;// 9
static +default: Class<TextScript__default> & TextScript__default & 10;// 10
static +symbol: Class<TextScript__symbol> & TextScript__symbol & 11;// 11
static +thai: Class<TextScript__thai> & TextScript__thai & 12;// 12
static +shiftJis: Class<TextScript__shiftJis> & TextScript__shiftJis & 13;// 13
static +gB2312: Class<TextScript__gB2312> & TextScript__gB2312 & 14;// 14
static +hangul: Class<TextScript__hangul> & TextScript__hangul & 15;// 15
static +big5: Class<TextScript__big5> & TextScript__big5 & 16;// 16
static +pC437: Class<TextScript__pC437> & TextScript__pC437 & 17;// 17
static +oem: Class<TextScript__oem> & TextScript__oem & 18;// 18
static +mac: Class<TextScript__mac> & TextScript__mac & 19;// 19
static +armenian: Class<TextScript__armenian> & TextScript__armenian & 20;// 20
static +syriac: Class<TextScript__syriac> & TextScript__syriac & 21;// 21
static +thaana: Class<TextScript__thaana> & TextScript__thaana & 22;// 22
static +devanagari: Class<TextScript__devanagari> & TextScript__devanagari & 23;// 23
static +bengali: Class<TextScript__bengali> & TextScript__bengali & 24;// 24
static +gurmukhi: Class<TextScript__gurmukhi> & TextScript__gurmukhi & 25;// 25
static +gujarati: Class<TextScript__gujarati> & TextScript__gujarati & 26;// 26
static +oriya: Class<TextScript__oriya> & TextScript__oriya & 27;// 27
static +tamil: Class<TextScript__tamil> & TextScript__tamil & 28;// 28
static +telugu: Class<TextScript__telugu> & TextScript__telugu & 29;// 29
static +kannada: Class<TextScript__kannada> & TextScript__kannada & 30;// 30
static +malayalam: Class<TextScript__malayalam> & TextScript__malayalam & 31;// 31
static +sinhala: Class<TextScript__sinhala> & TextScript__sinhala & 32;// 32
static +lao: Class<TextScript__lao> & TextScript__lao & 33;// 33
static +tibetan: Class<TextScript__tibetan> & TextScript__tibetan & 34;// 34
static +myanmar: Class<TextScript__myanmar> & TextScript__myanmar & 35;// 35
static +georgian: Class<TextScript__georgian> & TextScript__georgian & 36;// 36
static +jamo: Class<TextScript__jamo> & TextScript__jamo & 37;// 37
static +ethiopic: Class<TextScript__ethiopic> & TextScript__ethiopic & 38;// 38
static +cherokee: Class<TextScript__cherokee> & TextScript__cherokee & 39;// 39
static +aboriginal: Class<TextScript__aboriginal> & TextScript__aboriginal & 40;// 40
static +ogham: Class<TextScript__ogham> & TextScript__ogham & 41;// 41
static +runic: Class<TextScript__runic> & TextScript__runic & 42;// 42
static +khmer: Class<TextScript__khmer> & TextScript__khmer & 43;// 43
static +mongolian: Class<TextScript__mongolian> & TextScript__mongolian & 44;// 44
static +braille: Class<TextScript__braille> & TextScript__braille & 45;// 45
static +yi: Class<TextScript__yi> & TextScript__yi & 46;// 46
static +limbu: Class<TextScript__limbu> & TextScript__limbu & 47;// 47
static +taiLe: Class<TextScript__taiLe> & TextScript__taiLe & 48;// 48
static +newTaiLue: Class<TextScript__newTaiLue> & TextScript__newTaiLue & 49;// 49
static +sylotiNagri: Class<TextScript__sylotiNagri> & TextScript__sylotiNagri & 50;// 50
static +kharoshthi: Class<TextScript__kharoshthi> & TextScript__kharoshthi & 51;// 51
static +kayahli: Class<TextScript__kayahli> & TextScript__kayahli & 52;// 52
static +unicodeSymbol: Class<TextScript__unicodeSymbol> & TextScript__unicodeSymbol & 53;// 53
static +emoji: Class<TextScript__emoji> & TextScript__emoji & 54;// 54
static +glagolitic: Class<TextScript__glagolitic> & TextScript__glagolitic & 55;// 55
static +lisu: Class<TextScript__lisu> & TextScript__lisu & 56;// 56
static +vai: Class<TextScript__vai> & TextScript__vai & 57;// 57
static +nKo: Class<TextScript__nKo> & TextScript__nKo & 58;// 58
static +osmanya: Class<TextScript__osmanya> & TextScript__osmanya & 59;// 59
static +phagsPa: Class<TextScript__phagsPa> & TextScript__phagsPa & 60;// 60
static +gothic: Class<TextScript__gothic> & TextScript__gothic & 61;// 61
static +deseret: Class<TextScript__deseret> & TextScript__deseret & 62;// 62
static +tifinagh: Class<TextScript__tifinagh> & TextScript__tifinagh & 63;// 63

}

declare class TextScript__undefined mixins TextScript {}
declare class TextScript__ansi mixins TextScript {}
declare class TextScript__eastEurope mixins TextScript {}
declare class TextScript__cyrillic mixins TextScript {}
declare class TextScript__greek mixins TextScript {}
declare class TextScript__turkish mixins TextScript {}
declare class TextScript__hebrew mixins TextScript {}
declare class TextScript__arabic mixins TextScript {}
declare class TextScript__baltic mixins TextScript {}
declare class TextScript__vietnamese mixins TextScript {}
declare class TextScript__default mixins TextScript {}
declare class TextScript__symbol mixins TextScript {}
declare class TextScript__thai mixins TextScript {}
declare class TextScript__shiftJis mixins TextScript {}
declare class TextScript__gB2312 mixins TextScript {}
declare class TextScript__hangul mixins TextScript {}
declare class TextScript__big5 mixins TextScript {}
declare class TextScript__pC437 mixins TextScript {}
declare class TextScript__oem mixins TextScript {}
declare class TextScript__mac mixins TextScript {}
declare class TextScript__armenian mixins TextScript {}
declare class TextScript__syriac mixins TextScript {}
declare class TextScript__thaana mixins TextScript {}
declare class TextScript__devanagari mixins TextScript {}
declare class TextScript__bengali mixins TextScript {}
declare class TextScript__gurmukhi mixins TextScript {}
declare class TextScript__gujarati mixins TextScript {}
declare class TextScript__oriya mixins TextScript {}
declare class TextScript__tamil mixins TextScript {}
declare class TextScript__telugu mixins TextScript {}
declare class TextScript__kannada mixins TextScript {}
declare class TextScript__malayalam mixins TextScript {}
declare class TextScript__sinhala mixins TextScript {}
declare class TextScript__lao mixins TextScript {}
declare class TextScript__tibetan mixins TextScript {}
declare class TextScript__myanmar mixins TextScript {}
declare class TextScript__georgian mixins TextScript {}
declare class TextScript__jamo mixins TextScript {}
declare class TextScript__ethiopic mixins TextScript {}
declare class TextScript__cherokee mixins TextScript {}
declare class TextScript__aboriginal mixins TextScript {}
declare class TextScript__ogham mixins TextScript {}
declare class TextScript__runic mixins TextScript {}
declare class TextScript__khmer mixins TextScript {}
declare class TextScript__mongolian mixins TextScript {}
declare class TextScript__braille mixins TextScript {}
declare class TextScript__yi mixins TextScript {}
declare class TextScript__limbu mixins TextScript {}
declare class TextScript__taiLe mixins TextScript {}
declare class TextScript__newTaiLue mixins TextScript {}
declare class TextScript__sylotiNagri mixins TextScript {}
declare class TextScript__kharoshthi mixins TextScript {}
declare class TextScript__kayahli mixins TextScript {}
declare class TextScript__unicodeSymbol mixins TextScript {}
declare class TextScript__emoji mixins TextScript {}
declare class TextScript__glagolitic mixins TextScript {}
declare class TextScript__lisu mixins TextScript {}
declare class TextScript__vai mixins TextScript {}
declare class TextScript__nKo mixins TextScript {}
declare class TextScript__osmanya mixins TextScript {}
declare class TextScript__phagsPa mixins TextScript {}
declare class TextScript__gothic mixins TextScript {}
declare class TextScript__deseret mixins TextScript {}
declare class TextScript__tifinagh mixins TextScript {}

	declare export  class UnderlineType {
  constructor(...args: empty): mixed;
static +undefined: Class<UnderlineType__undefined> & UnderlineType__undefined & 0;// 0
static +none: Class<UnderlineType__none> & UnderlineType__none & 1;// 1
static +single: Class<UnderlineType__single> & UnderlineType__single & 2;// 2
static +words: Class<UnderlineType__words> & UnderlineType__words & 3;// 3
static +double: Class<UnderlineType__double> & UnderlineType__double & 4;// 4
static +dotted: Class<UnderlineType__dotted> & UnderlineType__dotted & 5;// 5
static +dash: Class<UnderlineType__dash> & UnderlineType__dash & 6;// 6
static +dashDot: Class<UnderlineType__dashDot> & UnderlineType__dashDot & 7;// 7
static +dashDotDot: Class<UnderlineType__dashDotDot> & UnderlineType__dashDotDot & 8;// 8
static +wave: Class<UnderlineType__wave> & UnderlineType__wave & 9;// 9
static +thick: Class<UnderlineType__thick> & UnderlineType__thick & 10;// 10
static +thin: Class<UnderlineType__thin> & UnderlineType__thin & 11;// 11
static +doubleWave: Class<UnderlineType__doubleWave> & UnderlineType__doubleWave & 12;// 12
static +heavyWave: Class<UnderlineType__heavyWave> & UnderlineType__heavyWave & 13;// 13
static +longDash: Class<UnderlineType__longDash> & UnderlineType__longDash & 14;// 14
static +thickDash: Class<UnderlineType__thickDash> & UnderlineType__thickDash & 15;// 15
static +thickDashDot: Class<UnderlineType__thickDashDot> & UnderlineType__thickDashDot & 16;// 16
static +thickDashDotDot: Class<UnderlineType__thickDashDotDot> & UnderlineType__thickDashDotDot & 17;// 17
static +thickDotted: Class<UnderlineType__thickDotted> & UnderlineType__thickDotted & 18;// 18
static +thickLongDash: Class<UnderlineType__thickLongDash> & UnderlineType__thickLongDash & 19;// 19

}

declare class UnderlineType__undefined mixins UnderlineType {}
declare class UnderlineType__none mixins UnderlineType {}
declare class UnderlineType__single mixins UnderlineType {}
declare class UnderlineType__words mixins UnderlineType {}
declare class UnderlineType__double mixins UnderlineType {}
declare class UnderlineType__dotted mixins UnderlineType {}
declare class UnderlineType__dash mixins UnderlineType {}
declare class UnderlineType__dashDot mixins UnderlineType {}
declare class UnderlineType__dashDotDot mixins UnderlineType {}
declare class UnderlineType__wave mixins UnderlineType {}
declare class UnderlineType__thick mixins UnderlineType {}
declare class UnderlineType__thin mixins UnderlineType {}
declare class UnderlineType__doubleWave mixins UnderlineType {}
declare class UnderlineType__heavyWave mixins UnderlineType {}
declare class UnderlineType__longDash mixins UnderlineType {}
declare class UnderlineType__thickDash mixins UnderlineType {}
declare class UnderlineType__thickDashDot mixins UnderlineType {}
declare class UnderlineType__thickDashDotDot mixins UnderlineType {}
declare class UnderlineType__thickDotted mixins UnderlineType {}
declare class UnderlineType__thickLongDash mixins UnderlineType {}

	declare export  class VerticalCharacterAlignment {
  constructor(...args: empty): mixed;
static +top: Class<VerticalCharacterAlignment__top> & VerticalCharacterAlignment__top & 0;// 0
static +baseline: Class<VerticalCharacterAlignment__baseline> & VerticalCharacterAlignment__baseline & 1;// 1
static +bottom: Class<VerticalCharacterAlignment__bottom> & VerticalCharacterAlignment__bottom & 2;// 2

}

declare class VerticalCharacterAlignment__top mixins VerticalCharacterAlignment {}
declare class VerticalCharacterAlignment__baseline mixins VerticalCharacterAlignment {}
declare class VerticalCharacterAlignment__bottom mixins VerticalCharacterAlignment {}

	declare export class TextConstants  {
static autoColor: Windows$Windows$UI.Color;
static maxUnitCount: number;
static minUnitCount: number;
static undefinedColor: Windows$Windows$UI.Color;
static undefinedFloatValue: number;
static undefinedFontStretch: Windows$Windows$UI.Text.FontStretch;
static undefinedFontStyle: Windows$Windows$UI.Text.FontStyle;
static undefinedInt32Value: number
}
	declare export interface ITextConstantsStatics {
autoColor: Windows$Windows$UI.Color,
maxUnitCount: number,
minUnitCount: number,
undefinedColor: Windows$Windows$UI.Color,
undefinedFloatValue: number,
undefinedFontStretch: Windows$Windows$UI.Text.FontStretch,
undefinedFontStyle: Windows$Windows$UI.Text.FontStyle,
undefinedInt32Value: number
} 
	declare export interface ITextDocument {
caretType: Windows$Windows$UI.Text.CaretType,
defaultTabStop: number,
selection: Windows$Windows$UI.Text.ITextSelection,
undoLimit: number,
canCopy(): boolean,
canPaste(): boolean,
canRedo(): boolean,
canUndo(): boolean,
applyDisplayUpdates(): number,
batchDisplayUpdates(): number,
beginUndoGroup(): void,
endUndoGroup(): void,
getDefaultCharacterFormat(): Windows$Windows$UI.Text.ITextCharacterFormat,
getDefaultParagraphFormat(): Windows$Windows$UI.Text.ITextParagraphFormat,
getRange(startPosition: number, endPosition: number): Windows$Windows$UI.Text.ITextRange,
getRangeFromPoint(
point: Windows$Windows$Foundation.Point,
options: Windows$Windows$UI.Text.PointOptions): Windows$Windows$UI.Text.ITextRange,
getText(options: Windows$Windows$UI.Text.TextGetOptions): string,
loadFromStream(
options: Windows$Windows$UI.Text.TextSetOptions,
value: Windows$Windows$Storage.Streams.IRandomAccessStream): void,
redo(): void,
saveToStream(
options: Windows$Windows$UI.Text.TextGetOptions,
value: Windows$Windows$Storage.Streams.IRandomAccessStream): void,
setDefaultCharacterFormat(value: Windows$Windows$UI.Text.ITextCharacterFormat): void,
setDefaultParagraphFormat(value: Windows$Windows$UI.Text.ITextParagraphFormat): void,
setText(options: Windows$Windows$UI.Text.TextSetOptions, value: string): void,
undo(): void
} 
	declare export interface ITextRange {
character: string,
characterFormat: Windows$Windows$UI.Text.ITextCharacterFormat,
endPosition: number,
formattedText: Windows$Windows$UI.Text.ITextRange,
gravity: Windows$Windows$UI.Text.RangeGravity,
length: number,
link: string,
paragraphFormat: Windows$Windows$UI.Text.ITextParagraphFormat,
startPosition: number,
storyLength: number,
text: string,
canPaste(format: number): boolean,
changeCase(value: Windows$Windows$UI.Text.LetterCase): void,
collapse(value: boolean): void,
copy(): void,
cut(): void,
delete_(unit: Windows$Windows$UI.Text.TextRangeUnit, count: number): number,
endOf(unit: Windows$Windows$UI.Text.TextRangeUnit, extend: boolean): number,
expand(unit: Windows$Windows$UI.Text.TextRangeUnit): number,
findText(
value: string,
scanLength: number,
options: Windows$Windows$UI.Text.FindOptions): number,
getCharacterUtf32(offset: number): number,
getClone(): Windows$Windows$UI.Text.ITextRange,
getIndex(unit: Windows$Windows$UI.Text.TextRangeUnit): number,
getPoint(
horizontalAlign: Windows$Windows$UI.Text.HorizontalCharacterAlignment,
verticalAlign: Windows$Windows$UI.Text.VerticalCharacterAlignment,
options: Windows$Windows$UI.Text.PointOptions): Windows$Windows$Foundation.Point,
getRect(
options: Windows$Windows$UI.Text.PointOptions): {
rect: Windows$Windows$Foundation.Rect,
hit: number
},
getText(options: Windows$Windows$UI.Text.TextGetOptions): string,
getTextViaStream(
options: Windows$Windows$UI.Text.TextGetOptions,
value: Windows$Windows$Storage.Streams.IRandomAccessStream): void,
inRange(range: Windows$Windows$UI.Text.ITextRange): boolean,
insertImage(
width: number,
height: number,
ascent: number,
verticalAlign: Windows$Windows$UI.Text.VerticalCharacterAlignment,
alternateText: string,
value: Windows$Windows$Storage.Streams.IRandomAccessStream): void,
inStory(range: Windows$Windows$UI.Text.ITextRange): boolean,
isEqual(range: Windows$Windows$UI.Text.ITextRange): boolean,
move(unit: Windows$Windows$UI.Text.TextRangeUnit, count: number): number,
moveEnd(unit: Windows$Windows$UI.Text.TextRangeUnit, count: number): number,
moveStart(unit: Windows$Windows$UI.Text.TextRangeUnit, count: number): number,
paste(format: number): void,
scrollIntoView(value: Windows$Windows$UI.Text.PointOptions): void,
matchSelection(): void,
setIndex(
unit: Windows$Windows$UI.Text.TextRangeUnit,
index: number,
extend: boolean): void,
setPoint(
point: Windows$Windows$Foundation.Point,
options: Windows$Windows$UI.Text.PointOptions,
extend: boolean): void,
setRange(startPosition: number, endPosition: number): void,
setText(options: Windows$Windows$UI.Text.TextSetOptions, value: string): void,
setTextViaStream(
options: Windows$Windows$UI.Text.TextSetOptions,
value: Windows$Windows$Storage.Streams.IRandomAccessStream): void,
startOf(unit: Windows$Windows$UI.Text.TextRangeUnit, extend: boolean): number
} 
	declare export type ITextSelection = {
options: Windows$Windows$UI.Text.SelectionOptions,
type: Windows$Windows$UI.Text.SelectionType,
endKey(unit: Windows$Windows$UI.Text.TextRangeUnit, extend: boolean): number,
homeKey(unit: Windows$Windows$UI.Text.TextRangeUnit, extend: boolean): number,
moveDown(
unit: Windows$Windows$UI.Text.TextRangeUnit,
count: number,
extend: boolean): number,
moveLeft(
unit: Windows$Windows$UI.Text.TextRangeUnit,
count: number,
extend: boolean): number,
moveRight(
unit: Windows$Windows$UI.Text.TextRangeUnit,
count: number,
extend: boolean): number,
moveUp(
unit: Windows$Windows$UI.Text.TextRangeUnit,
count: number,
extend: boolean): number,
typeText(value: string): void
} & undefined.ITextRange

	declare export interface ITextCharacterFormat {
allCaps: Windows$Windows$UI.Text.FormatEffect,
backgroundColor: Windows$Windows$UI.Color,
bold: Windows$Windows$UI.Text.FormatEffect,
fontStretch: Windows$Windows$UI.Text.FontStretch,
fontStyle: Windows$Windows$UI.Text.FontStyle,
foregroundColor: Windows$Windows$UI.Color,
hidden: Windows$Windows$UI.Text.FormatEffect,
italic: Windows$Windows$UI.Text.FormatEffect,
kerning: number,
languageTag: string,
linkType: Windows$Windows$UI.Text.LinkType,
name: string,
outline: Windows$Windows$UI.Text.FormatEffect,
position: number,
protectedText: Windows$Windows$UI.Text.FormatEffect,
size: number,
smallCaps: Windows$Windows$UI.Text.FormatEffect,
spacing: number,
strikethrough: Windows$Windows$UI.Text.FormatEffect,
subscript: Windows$Windows$UI.Text.FormatEffect,
superscript: Windows$Windows$UI.Text.FormatEffect,
textScript: Windows$Windows$UI.Text.TextScript,
underline: Windows$Windows$UI.Text.UnderlineType,
weight: number,
setClone(value: Windows$Windows$UI.Text.ITextCharacterFormat): void,
getClone(): Windows$Windows$UI.Text.ITextCharacterFormat,
isEqual(format: Windows$Windows$UI.Text.ITextCharacterFormat): boolean
} 
	declare export interface ITextParagraphFormat {
alignment: Windows$Windows$UI.Text.ParagraphAlignment,
firstLineIndent: number,
keepTogether: Windows$Windows$UI.Text.FormatEffect,
keepWithNext: Windows$Windows$UI.Text.FormatEffect,
leftIndent: number,
lineSpacing: number,
lineSpacingRule: Windows$Windows$UI.Text.LineSpacingRule,
listAlignment: Windows$Windows$UI.Text.MarkerAlignment,
listLevelIndex: number,
listStart: number,
listStyle: Windows$Windows$UI.Text.MarkerStyle,
listTab: number,
listType: Windows$Windows$UI.Text.MarkerType,
noLineNumber: Windows$Windows$UI.Text.FormatEffect,
pageBreakBefore: Windows$Windows$UI.Text.FormatEffect,
rightIndent: number,
rightToLeft: Windows$Windows$UI.Text.FormatEffect,
spaceAfter: number,
spaceBefore: number,
style: Windows$Windows$UI.Text.ParagraphStyle,
tabCount: number,
widowControl: Windows$Windows$UI.Text.FormatEffect,
addTab(
position: number,
align: Windows$Windows$UI.Text.TabAlignment,
leader: Windows$Windows$UI.Text.TabLeader): void,
clearAllTabs(): void,
deleteTab(position: number): void,
getClone(): Windows$Windows$UI.Text.ITextParagraphFormat,
getTab(
index: number): {
position: number,
align: Windows$Windows$UI.Text.TabAlignment,
leader: Windows$Windows$UI.Text.TabLeader
},
isEqual(format: Windows$Windows$UI.Text.ITextParagraphFormat): boolean,
setClone(format: Windows$Windows$UI.Text.ITextParagraphFormat): void,
setIndents(start: number, left: number, right: number): void,
setLineSpacing(rule: Windows$Windows$UI.Text.LineSpacingRule, spacing: number): void
} 
	declare export  class FontStyle {
  constructor(...args: empty): mixed;
static +normal: Class<FontStyle__normal> & FontStyle__normal & 0;// 0
static +oblique: Class<FontStyle__oblique> & FontStyle__oblique & 1;// 1
static +italic: Class<FontStyle__italic> & FontStyle__italic & 2;// 2

}

declare class FontStyle__normal mixins FontStyle {}
declare class FontStyle__oblique mixins FontStyle {}
declare class FontStyle__italic mixins FontStyle {}

	declare export  class FontStretch {
  constructor(...args: empty): mixed;
static +undefined: Class<FontStretch__undefined> & FontStretch__undefined & 0;// 0
static +ultraCondensed: Class<FontStretch__ultraCondensed> & FontStretch__ultraCondensed & 1;// 1
static +extraCondensed: Class<FontStretch__extraCondensed> & FontStretch__extraCondensed & 2;// 2
static +condensed: Class<FontStretch__condensed> & FontStretch__condensed & 3;// 3
static +semiCondensed: Class<FontStretch__semiCondensed> & FontStretch__semiCondensed & 4;// 4
static +normal: Class<FontStretch__normal> & FontStretch__normal & 5;// 5
static +semiExpanded: Class<FontStretch__semiExpanded> & FontStretch__semiExpanded & 6;// 6
static +expanded: Class<FontStretch__expanded> & FontStretch__expanded & 7;// 7
static +extraExpanded: Class<FontStretch__extraExpanded> & FontStretch__extraExpanded & 8;// 8
static +ultraExpanded: Class<FontStretch__ultraExpanded> & FontStretch__ultraExpanded & 9;// 9

}

declare class FontStretch__undefined mixins FontStretch {}
declare class FontStretch__ultraCondensed mixins FontStretch {}
declare class FontStretch__extraCondensed mixins FontStretch {}
declare class FontStretch__condensed mixins FontStretch {}
declare class FontStretch__semiCondensed mixins FontStretch {}
declare class FontStretch__normal mixins FontStretch {}
declare class FontStretch__semiExpanded mixins FontStretch {}
declare class FontStretch__expanded mixins FontStretch {}
declare class FontStretch__extraExpanded mixins FontStretch {}
declare class FontStretch__ultraExpanded mixins FontStretch {}

	declare export interface FontWeight {
weight: number
} 
	declare export interface IFontWeights {} 
	declare export interface IFontWeightsStatics {
black: Windows$Windows$UI.Text.FontWeight,
bold: Windows$Windows$UI.Text.FontWeight,
extraBlack: Windows$Windows$UI.Text.FontWeight,
extraBold: Windows$Windows$UI.Text.FontWeight,
extraLight: Windows$Windows$UI.Text.FontWeight,
light: Windows$Windows$UI.Text.FontWeight,
medium: Windows$Windows$UI.Text.FontWeight,
normal: Windows$Windows$UI.Text.FontWeight,
semiBold: Windows$Windows$UI.Text.FontWeight,
semiLight: Windows$Windows$UI.Text.FontWeight,
thin: Windows$Windows$UI.Text.FontWeight
} 
	declare export class FontWeights mixins undefined.IFontWeights {
static black: Windows$Windows$UI.Text.FontWeight;
static bold: Windows$Windows$UI.Text.FontWeight;
static extraBlack: Windows$Windows$UI.Text.FontWeight;
static extraBold: Windows$Windows$UI.Text.FontWeight;
static extraLight: Windows$Windows$UI.Text.FontWeight;
static light: Windows$Windows$UI.Text.FontWeight;
static medium: Windows$Windows$UI.Text.FontWeight;
static normal: Windows$Windows$UI.Text.FontWeight;
static semiBold: Windows$Windows$UI.Text.FontWeight;
static semiLight: Windows$Windows$UI.Text.FontWeight;
static thin: Windows$Windows$UI.Text.FontWeight
}
    }

	declare module 'Core' {
        declare export class CoreApplication  {
static mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>;
static id: string;
static properties: Windows$Windows$Foundation.Collections.IPropertySet;
static incrementApplicationUseCount(): void;
static decrementApplicationUseCount(): void;
static createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static exit(): void;
static onexiting: any;
static onsuspending: any;
static onresuming: any;
static getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView;
static run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void;
static runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
}
	declare export class CoreApplicationView mixins undefined.ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow;
isHosted: boolean;
isMain: boolean;
onactivated: any
}
	declare export interface IFrameworkView {
initialize(
applicationView: Windows$Windows$ApplicationModel.Core.CoreApplicationView): void,
setWindow(window: Windows$Windows$UI.Core.CoreWindow): void,
load(entryPoint: string): void,
run(): void,
uninitialize(): void
} 
	declare export interface IFrameworkViewSource {
createView(): Windows$Windows$ApplicationModel.Core.IFrameworkView
} 
	declare export interface ICoreApplication {
id: string,
properties: Windows$Windows$Foundation.Collections.IPropertySet,
onsuspending: any,
onresuming: any,
getCurrentView(): Windows$Windows$ApplicationModel.Core.CoreApplicationView,
run(viewSource: Windows$Windows$ApplicationModel.Core.IFrameworkViewSource): void,
runWithActivationFactories(
activationFactoryCallback: Windows$Windows$Foundation.IGetActivationFactory): void
} 
	declare export interface ICoreApplicationUseCount {
incrementApplicationUseCount(): void,
decrementApplicationUseCount(): void
} 
	declare export interface ICoreApplicationExit {
exit(): void,
onexiting: any
} 
	declare export interface ICoreImmersiveApplication {
mainView: Windows$Windows$ApplicationModel.Core.CoreApplicationView,
views: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Core.CoreApplicationView>,
createNewView(
runtimeType: string,
entryPoint: string): Windows$Windows$ApplicationModel.Core.CoreApplicationView
} 
	declare export interface ICoreApplicationView {
coreWindow: Windows$Windows$UI.Core.CoreWindow,
isHosted: boolean,
isMain: boolean,
onactivated: any
} 
	declare export interface IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext,
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap,
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void,
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void
} 
	declare export class ResourceMap mixins undefined.IResourceMap, undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
uri: Windows$Windows$Foundation.Uri;
size: number;
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.NamedResource;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>
}
	declare export class ResourceContext mixins undefined.IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>;
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>;
reset(): void;
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void;
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void;
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
static createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
}
	declare export interface IResourceManagerStatics {
current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager,
isResourceReference(resourceReference: string): boolean
} 
	declare export class ResourceManager mixins undefined.IResourceManager {
allResourceMaps: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
defaultContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext;
mainResourceMap: Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
loadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
unloadPriFiles(
files: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Storage.IStorageFile>): void;
static current: Windows$Windows$ApplicationModel.Resources.Core.ResourceManager;
static isResourceReference(resourceReference: string): boolean
}
	declare export interface IResourceQualifier {
isDefault: boolean,
isMatch: boolean,
qualifierName: string,
qualifierValue: string,
score: number
} 
	declare export class ResourceQualifier mixins undefined.IResourceQualifier {
isDefault: boolean;
isMatch: boolean;
qualifierName: string;
qualifierValue: string;
score: number
}
	declare export interface IResourceContext {
languages: Windows$Windows$Foundation.Collections.IVectorView<string>,
qualifierValues: Windows$Windows$Foundation.Collections.IObservableMap<string, string>,
reset(): void,
reset(qualifierNames: Windows$Windows$Foundation.Collections.IIterable<string>): void,
overrideToMatch(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): void,
clone(): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceContextStatics {
createMatchingContext(
result: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>): Windows$Windows$ApplicationModel.Resources.Core.ResourceContext
} 
	declare export interface IResourceCandidate {
isDefault: boolean,
isMatch: boolean,
isMatchAsDefault: boolean,
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>,
valueAsString: string,
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>,
getQualifierValue(qualifierName: string): string
} 
	declare export class ResourceCandidate mixins undefined.IResourceCandidate {
isDefault: boolean;
isMatch: boolean;
isMatchAsDefault: boolean;
qualifiers: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
valueAsString: string;
getValueAsFileAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Storage.StorageFile>;
getQualifierValue(qualifierName: string): string
}
	declare export interface INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
uri: Windows$Windows$Foundation.Uri,
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>,
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
} 
	declare export class NamedResource mixins undefined.INamedResource {
candidates: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
uri: Windows$Windows$Foundation.Uri;
resolve(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolve(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
resolveAll(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
resolveAll(
resourceContext: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>
}
	declare export type IResourceMap = {
uri: Windows$Windows$Foundation.Uri,
getValue(
resource: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getValue(
resource: string,
context: Windows$Windows$ApplicationModel.Resources.Core.ResourceContext): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
getSubtree(reference: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap
} & undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource> & undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>>

	declare export class ResourceMapIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.NamedResource>[],
returnValue: number
}
}
	declare export class ResourceMapMapView mixins undefined.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
size: number;
lookup(key: string): Windows$Windows$ApplicationModel.Resources.Core.ResourceMap;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>,
second: Windows$Windows$Foundation.Collections.IMapView<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>>
}
	declare export class ResourceMapMapViewIterator mixins undefined.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>> {
current: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>;
hasCurrent: boolean;
moveNext(): boolean;
getMany(
): {
items: Windows$Windows$Foundation.Collections.IKeyValuePair<string, Windows$Windows$ApplicationModel.Resources.Core.ResourceMap>[],
returnValue: number
}
}
	declare export class ResourceQualifierObservableMap mixins undefined.IObservableMap<string, string>, undefined.IMap<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
onmapchanged: any;
lookup(key: string): string;
hasKey(key: string): boolean;
getView(): Windows$Windows$Foundation.Collections.IMapView<string, string>;
insert(key: string, value: string): boolean;
remove(key: string): void;
clear(): void;
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierMapView mixins undefined.IMapView<string, string>, undefined.IIterable<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>> {
size: number;
lookup(key: string): string;
hasKey(key: string): boolean;
split(
): {
first: Windows$Windows$Foundation.Collections.IMapView<string, string>,
second: Windows$Windows$Foundation.Collections.IMapView<string, string>
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$Foundation.Collections.IKeyValuePair<string, string>>
}
	declare export class ResourceQualifierVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceQualifier[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceCandidateVectorView mixins undefined.IVectorView<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>, undefined.IIterable<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate> {
size: number;
getAt(
index: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
indexOf(
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): {
index: number,
returnValue: boolean
};
getMany(
startIndex: number): {
items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[],
returnValue: number
};
first(
): Windows$Windows$Foundation.Collections.IIterator<Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate>;
toString(): string;
toLocaleString(): string;
concat(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[][]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
join(seperator: string): string;
pop(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
push(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): void;
reverse(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
shift(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate;
slice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
slice(
start: number,
end: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
sort(
compareFn: (
a: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
b: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate) => number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
splice(
start: number,
deleteCount: number,
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
unshift(
...items: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate): number;
lastIndexOf(
searchElement: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
fromIndex: number): number;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
every(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): boolean;
some(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): boolean;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void): void;
forEach(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => void,
thisArg: any): void;
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any[];
map(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
thisArg: any): any[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
filter(
callbackfn: (
value: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate,
index: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => boolean,
thisArg: any): Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: Windows$Windows$ApplicationModel.Resources.Core.ResourceCandidate[]) => any,
initialValue: any): any;
length: number
}
	declare export class ResourceContextLanguagesVectorView mixins undefined.IVectorView<string>, undefined.IIterable<string> {
size: number;
getAt(index: number): string;
indexOf(value: string): {
index: number,
returnValue: boolean
};
getMany(startIndex: number): {
items: string[],
returnValue: number
};
first(): Windows$Windows$Foundation.Collections.IIterator<string>;
toString(): string;
toLocaleString(): string;
concat(...items: string[][]): string[];
join(seperator: string): string;
pop(): string;
push(...items: string[]): void;
reverse(): string[];
shift(): string;
slice(start: number): string[];
slice(start: number, end: number): string[];
sort(): string[];
sort(compareFn: (a: string, b: string) => number): string[];
splice(start: number): string[];
splice(start: number, deleteCount: number, ...items: string[]): string[];
unshift(...items: string[]): number;
lastIndexOf(searchElement: string): number;
lastIndexOf(searchElement: string, fromIndex: number): number;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
every(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean): boolean;
some(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): boolean;
forEach(callbackfn: (value: string, index: number, array: string[]) => void): void;
forEach(
callbackfn: (value: string, index: number, array: string[]) => void,
thisArg: any): void;
map(callbackfn: (value: string, index: number, array: string[]) => any): any[];
map(
callbackfn: (value: string, index: number, array: string[]) => any,
thisArg: any): any[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean): string[];
filter(
callbackfn: (value: string, index: number, array: string[]) => boolean,
thisArg: any): string[];
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduce(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any): any;
reduceRight(
callbackfn: (
previousValue: any,
currentValue: any,
currentIndex: number,
array: string[]) => any,
initialValue: any): any;
length: number
}
	declare export interface IApplicationDataManagerStatics {
createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
} 
	declare export interface IApplicationDataManager {} 
	declare export class ApplicationDataManager mixins undefined.IApplicationDataManager {
static createForPackageFamily(packageFamilyName: string): Windows$Windows$Storage.ApplicationData
}
	declare export  class CryptographicPrivateKeyBlobType {
  constructor(...args: empty): mixed;
static +pkcs8RawPrivateKeyInfo: Class<CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo> & CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo & 0;// 0
static +pkcs1RsaPrivateKey: Class<CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey> & CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey & 1;// 1
static +bCryptPrivateKey: Class<CryptographicPrivateKeyBlobType__bCryptPrivateKey> & CryptographicPrivateKeyBlobType__bCryptPrivateKey & 2;// 2
static +capi1PrivateKey: Class<CryptographicPrivateKeyBlobType__capi1PrivateKey> & CryptographicPrivateKeyBlobType__capi1PrivateKey & 3;// 3

}

declare class CryptographicPrivateKeyBlobType__pkcs8RawPrivateKeyInfo mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__pkcs1RsaPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__bCryptPrivateKey mixins CryptographicPrivateKeyBlobType {}
declare class CryptographicPrivateKeyBlobType__capi1PrivateKey mixins CryptographicPrivateKeyBlobType {}

	declare export  class CryptographicPublicKeyBlobType {
  constructor(...args: empty): mixed;
static +x509SubjectPublicKeyInfo: Class<CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo> & CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo & 0;// 0
static +pkcs1RsaPublicKey: Class<CryptographicPublicKeyBlobType__pkcs1RsaPublicKey> & CryptographicPublicKeyBlobType__pkcs1RsaPublicKey & 1;// 1
static +bCryptPublicKey: Class<CryptographicPublicKeyBlobType__bCryptPublicKey> & CryptographicPublicKeyBlobType__bCryptPublicKey & 2;// 2
static +capi1PublicKey: Class<CryptographicPublicKeyBlobType__capi1PublicKey> & CryptographicPublicKeyBlobType__capi1PublicKey & 3;// 3

}

declare class CryptographicPublicKeyBlobType__x509SubjectPublicKeyInfo mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__pkcs1RsaPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__bCryptPublicKey mixins CryptographicPublicKeyBlobType {}
declare class CryptographicPublicKeyBlobType__capi1PublicKey mixins CryptographicPublicKeyBlobType {}

	declare export interface IKeyDerivationParameters {
iterationCount: number,
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export interface IKeyDerivationParametersStatics {
buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
} 
	declare export class KeyDerivationParameters mixins undefined.IKeyDerivationParameters {
iterationCount: number;
kdfGenericBinary: Windows$Windows$Storage.Streams.IBuffer;
static buildForPbkdf2(
pbkdf2Salt: Windows$Windows$Storage.Streams.IBuffer,
iterationCount: number): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP800108(
label: Windows$Windows$Storage.Streams.IBuffer,
context: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters;
static buildForSP80056a(
algorithmId: Windows$Windows$Storage.Streams.IBuffer,
partyUInfo: Windows$Windows$Storage.Streams.IBuffer,
partyVInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPubInfo: Windows$Windows$Storage.Streams.IBuffer,
suppPrivInfo: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters
}
	declare export interface ICryptographicKey {
keySize: number,
export(): Windows$Windows$Storage.Streams.IBuffer,
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer,
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicKey mixins undefined.ICryptographicKey {
keySize: number;
export(): Windows$Windows$Storage.Streams.IBuffer;
export(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(): Windows$Windows$Storage.Streams.IBuffer;
exportPublicKey(
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void,
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicHash mixins undefined.IHashComputation {
append(data: Windows$Windows$Storage.Streams.IBuffer): void;
getValueAndReset(): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProvider {
algorithmName: string,
hashLength: number,
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash
} 
	declare export interface IMacAlgorithmProvider {
algorithmName: string,
macLength: number,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IKeyDerivationAlgorithmProvider {
algorithmName: string,
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface ISymmetricKeyAlgorithmProvider {
algorithmName: string,
blockLength: number,
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IAsymmetricKeyAlgorithmProvider {
algorithmName: string,
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey,
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey
} 
	declare export interface IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
encryptedData: Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class EncryptedAndAuthenticatedData mixins undefined.IEncryptedAndAuthenticatedData {
authenticationTag: Windows$Windows$Storage.Streams.IBuffer;
encryptedData: Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface ICryptographicEngineStatics {
encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData,
decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer,
verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean,
deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
} 
	declare export class CryptographicEngine  {
static encrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static decrypt(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
iv: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static encryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.EncryptedAndAuthenticatedData;
static decryptAndAuthenticate(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
nonce: Windows$Windows$Storage.Streams.IBuffer,
authenticationTag: Windows$Windows$Storage.Streams.IBuffer,
authenticatedData: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static sign(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
static verifySignature(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
data: Windows$Windows$Storage.Streams.IBuffer,
signature: Windows$Windows$Storage.Streams.IBuffer): boolean;
static deriveKeyMaterial(
key: Windows$Windows$Security.Cryptography.Core.CryptographicKey,
parameters: Windows$Windows$Security.Cryptography.Core.KeyDerivationParameters,
desiredKeySize: number): Windows$Windows$Storage.Streams.IBuffer
}
	declare export interface IHashAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
} 
	declare export class HashAlgorithmProvider mixins undefined.IHashAlgorithmProvider {
algorithmName: string;
hashLength: number;
hashData(
data: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Storage.Streams.IBuffer;
createHash(): Windows$Windows$Security.Cryptography.Core.CryptographicHash;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.HashAlgorithmProvider
}
	declare export interface IMacAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
} 
	declare export class MacAlgorithmProvider mixins undefined.IMacAlgorithmProvider {
algorithmName: string;
macLength: number;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.MacAlgorithmProvider
}
	declare export interface IKeyDerivationAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
} 
	declare export class KeyDerivationAlgorithmProvider mixins undefined.IKeyDerivationAlgorithmProvider {
algorithmName: string;
createKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.KeyDerivationAlgorithmProvider
}
	declare export interface ISymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
} 
	declare export class SymmetricKeyAlgorithmProvider mixins undefined.ISymmetricKeyAlgorithmProvider {
algorithmName: string;
blockLength: number;
createSymmetricKey(
keyMaterial: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.SymmetricKeyAlgorithmProvider
}
	declare export interface IAsymmetricKeyAlgorithmProviderStatics {
openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
} 
	declare export class AsymmetricKeyAlgorithmProvider mixins undefined.IAsymmetricKeyAlgorithmProvider {
algorithmName: string;
createKeyPair(keySize: number): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importKeyPair(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
importPublicKey(
keyBlob: Windows$Windows$Storage.Streams.IBuffer,
BlobType: Windows$Windows$Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows$Windows$Security.Cryptography.Core.CryptographicKey;
static openAlgorithm(
algorithm: string): Windows$Windows$Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider
}
	declare export interface IHashAlgorithmNamesStatics {
md5: string,
sha1: string,
sha256: string,
sha384: string,
sha512: string
} 
	declare export class HashAlgorithmNames  {
static md5: string;
static sha1: string;
static sha256: string;
static sha384: string;
static sha512: string
}
	declare export interface IMacAlgorithmNamesStatics {
aesCmac: string,
hmacMd5: string,
hmacSha1: string,
hmacSha256: string,
hmacSha384: string,
hmacSha512: string
} 
	declare export class MacAlgorithmNames  {
static aesCmac: string;
static hmacMd5: string;
static hmacSha1: string;
static hmacSha256: string;
static hmacSha384: string;
static hmacSha512: string
}
	declare export interface ISymmetricAlgorithmNamesStatics {
aesCbc: string,
aesCbcPkcs7: string,
aesCcm: string,
aesEcb: string,
aesEcbPkcs7: string,
aesGcm: string,
desCbc: string,
desCbcPkcs7: string,
desEcb: string,
desEcbPkcs7: string,
rc2Cbc: string,
rc2CbcPkcs7: string,
rc2Ecb: string,
rc2EcbPkcs7: string,
rc4: string,
tripleDesCbc: string,
tripleDesCbcPkcs7: string,
tripleDesEcb: string,
tripleDesEcbPkcs7: string
} 
	declare export class SymmetricAlgorithmNames  {
static aesCbc: string;
static aesCbcPkcs7: string;
static aesCcm: string;
static aesEcb: string;
static aesEcbPkcs7: string;
static aesGcm: string;
static desCbc: string;
static desCbcPkcs7: string;
static desEcb: string;
static desEcbPkcs7: string;
static rc2Cbc: string;
static rc2CbcPkcs7: string;
static rc2Ecb: string;
static rc2EcbPkcs7: string;
static rc4: string;
static tripleDesCbc: string;
static tripleDesCbcPkcs7: string;
static tripleDesEcb: string;
static tripleDesEcbPkcs7: string
}
	declare export interface IAsymmetricAlgorithmNamesStatics {
dsaSha1: string,
dsaSha256: string,
ecdsaP256Sha256: string,
ecdsaP384Sha384: string,
ecdsaP521Sha512: string,
rsaOaepSha1: string,
rsaOaepSha256: string,
rsaOaepSha384: string,
rsaOaepSha512: string,
rsaPkcs1: string,
rsaSignPkcs1Sha1: string,
rsaSignPkcs1Sha256: string,
rsaSignPkcs1Sha384: string,
rsaSignPkcs1Sha512: string,
rsaSignPssSha1: string,
rsaSignPssSha256: string,
rsaSignPssSha384: string,
rsaSignPssSha512: string
} 
	declare export class AsymmetricAlgorithmNames  {
static dsaSha1: string;
static dsaSha256: string;
static ecdsaP256Sha256: string;
static ecdsaP384Sha384: string;
static ecdsaP521Sha512: string;
static rsaOaepSha1: string;
static rsaOaepSha256: string;
static rsaOaepSha384: string;
static rsaOaepSha512: string;
static rsaPkcs1: string;
static rsaSignPkcs1Sha1: string;
static rsaSignPkcs1Sha256: string;
static rsaSignPkcs1Sha384: string;
static rsaSignPkcs1Sha512: string;
static rsaSignPssSha1: string;
static rsaSignPssSha256: string;
static rsaSignPssSha384: string;
static rsaSignPssSha512: string
}
	declare export interface IKeyDerivationAlgorithmNamesStatics {
pbkdf2Md5: string,
pbkdf2Sha1: string,
pbkdf2Sha256: string,
pbkdf2Sha384: string,
pbkdf2Sha512: string,
sp800108CtrHmacMd5: string,
sp800108CtrHmacSha1: string,
sp800108CtrHmacSha256: string,
sp800108CtrHmacSha384: string,
sp800108CtrHmacSha512: string,
sp80056aConcatMd5: string,
sp80056aConcatSha1: string,
sp80056aConcatSha256: string,
sp80056aConcatSha384: string,
sp80056aConcatSha512: string
} 
	declare export class KeyDerivationAlgorithmNames  {
static pbkdf2Md5: string;
static pbkdf2Sha1: string;
static pbkdf2Sha256: string;
static pbkdf2Sha384: string;
static pbkdf2Sha512: string;
static sp800108CtrHmacMd5: string;
static sp800108CtrHmacSha1: string;
static sp800108CtrHmacSha256: string;
static sp800108CtrHmacSha384: string;
static sp800108CtrHmacSha512: string;
static sp80056aConcatMd5: string;
static sp80056aConcatSha1: string;
static sp80056aConcatSha256: string;
static sp80056aConcatSha384: string;
static sp80056aConcatSha512: string
}
	declare export interface SignalHandler {
(signalNotifier: Windows$Windows$System.Threading.Core.SignalNotifier, timedOut: boolean): void
} 
	declare export class SignalNotifier mixins undefined.ISignalNotifier {
enable(): void;
terminate(): void;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier;
static attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
}
	declare export interface ISignalNotifierStatics {
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToEvent(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler): Windows$Windows$System.Threading.Core.SignalNotifier,
attachToSemaphore(
name: string,
handler: Windows$Windows$System.Threading.Core.SignalHandler,
timeout: number): Windows$Windows$System.Threading.Core.SignalNotifier
} 
	declare export interface IPreallocatedWorkItemFactory {
createWorkItem(
handler: Windows$Windows$System.Threading.WorkItemHandler): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriority(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority): Windows$Windows$System.Threading.Core.PreallocatedWorkItem,
createWorkItemWithPriorityAndOptions(
handler: Windows$Windows$System.Threading.WorkItemHandler,
priority: Windows$Windows$System.Threading.WorkItemPriority,
options: Windows$Windows$System.Threading.WorkItemOptions): Windows$Windows$System.Threading.Core.PreallocatedWorkItem
} 
	declare export class PreallocatedWorkItem mixins undefined.IPreallocatedWorkItem {
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority): this;
constructor(handler: Windows$Windows$System.Threading.WorkItemHandler, priority: Windows$Windows$System.Threading.WorkItemPriority, options: Windows$Windows$System.Threading.WorkItemOptions): this;
runAsync(): Windows$Windows$Foundation.IAsyncAction
}
	declare export interface IPreallocatedWorkItem {
runAsync(): Windows$Windows$Foundation.IAsyncAction
} 
	declare export interface ISignalNotifier {
enable(): void,
terminate(): void
} 
	declare module 'AnimationMetrics' {
        declare export  class PropertyAnimationType {
  constructor(...args: empty): mixed;
static +scale: Class<PropertyAnimationType__scale> & PropertyAnimationType__scale & 0;// 0
static +translation: Class<PropertyAnimationType__translation> & PropertyAnimationType__translation & 1;// 1
static +opacity: Class<PropertyAnimationType__opacity> & PropertyAnimationType__opacity & 2;// 2

}

declare class PropertyAnimationType__scale mixins PropertyAnimationType {}
declare class PropertyAnimationType__translation mixins PropertyAnimationType {}
declare class PropertyAnimationType__opacity mixins PropertyAnimationType {}

	declare export interface IPropertyAnimation {
control1: Windows$Windows$Foundation.Point,
control2: Windows$Windows$Foundation.Point,
delay: number,
duration: number,
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
} 
	declare export type IScaleAnimation = {
finalScaleX: number,
finalScaleY: number,
initialScaleX: number,
initialScaleY: number,
normalizedOrigin: Windows$Windows$Foundation.Point
} & undefined.IPropertyAnimation

	declare export type IOpacityAnimation = {
finalOpacity: number,
initialOpacity: number
} & undefined.IPropertyAnimation

	declare export  class AnimationEffect {
  constructor(...args: empty): mixed;
static +expand: Class<AnimationEffect__expand> & AnimationEffect__expand & 0;// 0
static +collapse: Class<AnimationEffect__collapse> & AnimationEffect__collapse & 1;// 1
static +reposition: Class<AnimationEffect__reposition> & AnimationEffect__reposition & 2;// 2
static +fadeIn: Class<AnimationEffect__fadeIn> & AnimationEffect__fadeIn & 3;// 3
static +fadeOut: Class<AnimationEffect__fadeOut> & AnimationEffect__fadeOut & 4;// 4
static +addToList: Class<AnimationEffect__addToList> & AnimationEffect__addToList & 5;// 5
static +deleteFromList: Class<AnimationEffect__deleteFromList> & AnimationEffect__deleteFromList & 6;// 6
static +addToGrid: Class<AnimationEffect__addToGrid> & AnimationEffect__addToGrid & 7;// 7
static +deleteFromGrid: Class<AnimationEffect__deleteFromGrid> & AnimationEffect__deleteFromGrid & 8;// 8
static +addToSearchGrid: Class<AnimationEffect__addToSearchGrid> & AnimationEffect__addToSearchGrid & 9;// 9
static +deleteFromSearchGrid: Class<AnimationEffect__deleteFromSearchGrid> & AnimationEffect__deleteFromSearchGrid & 10;// 10
static +addToSearchList: Class<AnimationEffect__addToSearchList> & AnimationEffect__addToSearchList & 11;// 11
static +deleteFromSearchList: Class<AnimationEffect__deleteFromSearchList> & AnimationEffect__deleteFromSearchList & 12;// 12
static +showEdgeUI: Class<AnimationEffect__showEdgeUI> & AnimationEffect__showEdgeUI & 13;// 13
static +showPanel: Class<AnimationEffect__showPanel> & AnimationEffect__showPanel & 14;// 14
static +hideEdgeUI: Class<AnimationEffect__hideEdgeUI> & AnimationEffect__hideEdgeUI & 15;// 15
static +hidePanel: Class<AnimationEffect__hidePanel> & AnimationEffect__hidePanel & 16;// 16
static +showPopup: Class<AnimationEffect__showPopup> & AnimationEffect__showPopup & 17;// 17
static +hidePopup: Class<AnimationEffect__hidePopup> & AnimationEffect__hidePopup & 18;// 18
static +pointerDown: Class<AnimationEffect__pointerDown> & AnimationEffect__pointerDown & 19;// 19
static +pointerUp: Class<AnimationEffect__pointerUp> & AnimationEffect__pointerUp & 20;// 20
static +dragSourceStart: Class<AnimationEffect__dragSourceStart> & AnimationEffect__dragSourceStart & 21;// 21
static +dragSourceEnd: Class<AnimationEffect__dragSourceEnd> & AnimationEffect__dragSourceEnd & 22;// 22
static +transitionContent: Class<AnimationEffect__transitionContent> & AnimationEffect__transitionContent & 23;// 23
static +reveal: Class<AnimationEffect__reveal> & AnimationEffect__reveal & 24;// 24
static +hide: Class<AnimationEffect__hide> & AnimationEffect__hide & 25;// 25
static +dragBetweenEnter: Class<AnimationEffect__dragBetweenEnter> & AnimationEffect__dragBetweenEnter & 26;// 26
static +dragBetweenLeave: Class<AnimationEffect__dragBetweenLeave> & AnimationEffect__dragBetweenLeave & 27;// 27
static +swipeSelect: Class<AnimationEffect__swipeSelect> & AnimationEffect__swipeSelect & 28;// 28
static +swipeDeselect: Class<AnimationEffect__swipeDeselect> & AnimationEffect__swipeDeselect & 29;// 29
static +swipeReveal: Class<AnimationEffect__swipeReveal> & AnimationEffect__swipeReveal & 30;// 30
static +enterPage: Class<AnimationEffect__enterPage> & AnimationEffect__enterPage & 31;// 31
static +transitionPage: Class<AnimationEffect__transitionPage> & AnimationEffect__transitionPage & 32;// 32
static +crossFade: Class<AnimationEffect__crossFade> & AnimationEffect__crossFade & 33;// 33
static +peek: Class<AnimationEffect__peek> & AnimationEffect__peek & 34;// 34
static +updateBadge: Class<AnimationEffect__updateBadge> & AnimationEffect__updateBadge & 35;// 35

}

declare class AnimationEffect__expand mixins AnimationEffect {}
declare class AnimationEffect__collapse mixins AnimationEffect {}
declare class AnimationEffect__reposition mixins AnimationEffect {}
declare class AnimationEffect__fadeIn mixins AnimationEffect {}
declare class AnimationEffect__fadeOut mixins AnimationEffect {}
declare class AnimationEffect__addToList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromList mixins AnimationEffect {}
declare class AnimationEffect__addToGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchGrid mixins AnimationEffect {}
declare class AnimationEffect__addToSearchList mixins AnimationEffect {}
declare class AnimationEffect__deleteFromSearchList mixins AnimationEffect {}
declare class AnimationEffect__showEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__showPanel mixins AnimationEffect {}
declare class AnimationEffect__hideEdgeUI mixins AnimationEffect {}
declare class AnimationEffect__hidePanel mixins AnimationEffect {}
declare class AnimationEffect__showPopup mixins AnimationEffect {}
declare class AnimationEffect__hidePopup mixins AnimationEffect {}
declare class AnimationEffect__pointerDown mixins AnimationEffect {}
declare class AnimationEffect__pointerUp mixins AnimationEffect {}
declare class AnimationEffect__dragSourceStart mixins AnimationEffect {}
declare class AnimationEffect__dragSourceEnd mixins AnimationEffect {}
declare class AnimationEffect__transitionContent mixins AnimationEffect {}
declare class AnimationEffect__reveal mixins AnimationEffect {}
declare class AnimationEffect__hide mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenEnter mixins AnimationEffect {}
declare class AnimationEffect__dragBetweenLeave mixins AnimationEffect {}
declare class AnimationEffect__swipeSelect mixins AnimationEffect {}
declare class AnimationEffect__swipeDeselect mixins AnimationEffect {}
declare class AnimationEffect__swipeReveal mixins AnimationEffect {}
declare class AnimationEffect__enterPage mixins AnimationEffect {}
declare class AnimationEffect__transitionPage mixins AnimationEffect {}
declare class AnimationEffect__crossFade mixins AnimationEffect {}
declare class AnimationEffect__peek mixins AnimationEffect {}
declare class AnimationEffect__updateBadge mixins AnimationEffect {}

	declare export  class AnimationEffectTarget {
  constructor(...args: empty): mixed;
static +primary: Class<AnimationEffectTarget__primary> & AnimationEffectTarget__primary & 0;// 0
static +added: Class<AnimationEffectTarget__added> & AnimationEffectTarget__added & 1;// 1
static +affected: Class<AnimationEffectTarget__affected> & AnimationEffectTarget__affected & 2;// 2
static +background: Class<AnimationEffectTarget__background> & AnimationEffectTarget__background & 3;// 3
static +content: Class<AnimationEffectTarget__content> & AnimationEffectTarget__content & 4;// 4
static +deleted: Class<AnimationEffectTarget__deleted> & AnimationEffectTarget__deleted & 5;// 5
static +deselected: Class<AnimationEffectTarget__deselected> & AnimationEffectTarget__deselected & 6;// 6
static +dragSource: Class<AnimationEffectTarget__dragSource> & AnimationEffectTarget__dragSource & 7;// 7
static +hidden: Class<AnimationEffectTarget__hidden> & AnimationEffectTarget__hidden & 8;// 8
static +incoming: Class<AnimationEffectTarget__incoming> & AnimationEffectTarget__incoming & 9;// 9
static +outgoing: Class<AnimationEffectTarget__outgoing> & AnimationEffectTarget__outgoing & 10;// 10
static +outline: Class<AnimationEffectTarget__outline> & AnimationEffectTarget__outline & 11;// 11
static +remaining: Class<AnimationEffectTarget__remaining> & AnimationEffectTarget__remaining & 12;// 12
static +revealed: Class<AnimationEffectTarget__revealed> & AnimationEffectTarget__revealed & 13;// 13
static +rowIn: Class<AnimationEffectTarget__rowIn> & AnimationEffectTarget__rowIn & 14;// 14
static +rowOut: Class<AnimationEffectTarget__rowOut> & AnimationEffectTarget__rowOut & 15;// 15
static +selected: Class<AnimationEffectTarget__selected> & AnimationEffectTarget__selected & 16;// 16
static +selection: Class<AnimationEffectTarget__selection> & AnimationEffectTarget__selection & 17;// 17
static +shown: Class<AnimationEffectTarget__shown> & AnimationEffectTarget__shown & 18;// 18
static +tapped: Class<AnimationEffectTarget__tapped> & AnimationEffectTarget__tapped & 19;// 19

}

declare class AnimationEffectTarget__primary mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__added mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__affected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__background mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__content mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deleted mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__deselected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__dragSource mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__hidden mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__incoming mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outgoing mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__outline mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__remaining mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__revealed mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowIn mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__rowOut mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selected mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__selection mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__shown mixins AnimationEffectTarget {}
declare class AnimationEffectTarget__tapped mixins AnimationEffectTarget {}

	declare export interface IAnimationDescription {
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>,
delayLimit: number,
staggerDelay: number,
staggerDelayFactor: number,
zOrder: number
} 
	declare export interface IAnimationDescriptionFactory {
createInstance(
effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect,
target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): Windows$Windows$UI.Core.AnimationMetrics.AnimationDescription
} 
	declare export class AnimationDescription mixins undefined.IAnimationDescription {
constructor(effect: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffect, target: Windows$Windows$UI.Core.AnimationMetrics.AnimationEffectTarget): this;
animations: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Core.AnimationMetrics.IPropertyAnimation>;
delayLimit: number;
staggerDelay: number;
staggerDelayFactor: number;
zOrder: number
}
	declare export class PropertyAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class ScaleAnimation mixins undefined.IScaleAnimation, undefined.IPropertyAnimation {
finalScaleX: number;
finalScaleY: number;
initialScaleX: number;
initialScaleY: number;
normalizedOrigin: Windows$Windows$Foundation.Point;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class TranslationAnimation mixins undefined.IPropertyAnimation {
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
	declare export class OpacityAnimation mixins undefined.IOpacityAnimation, undefined.IPropertyAnimation {
finalOpacity: number;
initialOpacity: number;
control1: Windows$Windows$Foundation.Point;
control2: Windows$Windows$Foundation.Point;
delay: number;
duration: number;
type: Windows$Windows$UI.Core.AnimationMetrics.PropertyAnimationType
}
    }

	declare export  class CoreWindowActivationState {
  constructor(...args: empty): mixed;
static +codeActivated: Class<CoreWindowActivationState__codeActivated> & CoreWindowActivationState__codeActivated & 0;// 0
static +deactivated: Class<CoreWindowActivationState__deactivated> & CoreWindowActivationState__deactivated & 1;// 1
static +pointerActivated: Class<CoreWindowActivationState__pointerActivated> & CoreWindowActivationState__pointerActivated & 2;// 2

}

declare class CoreWindowActivationState__codeActivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__deactivated mixins CoreWindowActivationState {}
declare class CoreWindowActivationState__pointerActivated mixins CoreWindowActivationState {}

	declare export  class CoreCursorType {
  constructor(...args: empty): mixed;
static +arrow: Class<CoreCursorType__arrow> & CoreCursorType__arrow & 0;// 0
static +cross: Class<CoreCursorType__cross> & CoreCursorType__cross & 1;// 1
static +custom: Class<CoreCursorType__custom> & CoreCursorType__custom & 2;// 2
static +hand: Class<CoreCursorType__hand> & CoreCursorType__hand & 3;// 3
static +help: Class<CoreCursorType__help> & CoreCursorType__help & 4;// 4
static +iBeam: Class<CoreCursorType__iBeam> & CoreCursorType__iBeam & 5;// 5
static +sizeAll: Class<CoreCursorType__sizeAll> & CoreCursorType__sizeAll & 6;// 6
static +sizeNortheastSouthwest: Class<CoreCursorType__sizeNortheastSouthwest> & CoreCursorType__sizeNortheastSouthwest & 7;// 7
static +sizeNorthSouth: Class<CoreCursorType__sizeNorthSouth> & CoreCursorType__sizeNorthSouth & 8;// 8
static +sizeNorthwestSoutheast: Class<CoreCursorType__sizeNorthwestSoutheast> & CoreCursorType__sizeNorthwestSoutheast & 9;// 9
static +sizeWestEast: Class<CoreCursorType__sizeWestEast> & CoreCursorType__sizeWestEast & 10;// 10
static +universalNo: Class<CoreCursorType__universalNo> & CoreCursorType__universalNo & 11;// 11
static +upArrow: Class<CoreCursorType__upArrow> & CoreCursorType__upArrow & 12;// 12
static +wait: Class<CoreCursorType__wait> & CoreCursorType__wait & 13;// 13

}

declare class CoreCursorType__arrow mixins CoreCursorType {}
declare class CoreCursorType__cross mixins CoreCursorType {}
declare class CoreCursorType__custom mixins CoreCursorType {}
declare class CoreCursorType__hand mixins CoreCursorType {}
declare class CoreCursorType__help mixins CoreCursorType {}
declare class CoreCursorType__iBeam mixins CoreCursorType {}
declare class CoreCursorType__sizeAll mixins CoreCursorType {}
declare class CoreCursorType__sizeNortheastSouthwest mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthSouth mixins CoreCursorType {}
declare class CoreCursorType__sizeNorthwestSoutheast mixins CoreCursorType {}
declare class CoreCursorType__sizeWestEast mixins CoreCursorType {}
declare class CoreCursorType__universalNo mixins CoreCursorType {}
declare class CoreCursorType__upArrow mixins CoreCursorType {}
declare class CoreCursorType__wait mixins CoreCursorType {}

	declare export  class CoreDispatcherPriority {
  constructor(...args: empty): mixed;
static +low: Class<CoreDispatcherPriority__low> & CoreDispatcherPriority__low & 0;// 0
static +normal: Class<CoreDispatcherPriority__normal> & CoreDispatcherPriority__normal & 1;// 1
static +high: Class<CoreDispatcherPriority__high> & CoreDispatcherPriority__high & 2;// 2

}

declare class CoreDispatcherPriority__low mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__normal mixins CoreDispatcherPriority {}
declare class CoreDispatcherPriority__high mixins CoreDispatcherPriority {}

	declare export  class CoreProcessEventsOption {
  constructor(...args: empty): mixed;
static +processOneAndAllPending: Class<CoreProcessEventsOption__processOneAndAllPending> & CoreProcessEventsOption__processOneAndAllPending & 0;// 0
static +processOneIfPresent: Class<CoreProcessEventsOption__processOneIfPresent> & CoreProcessEventsOption__processOneIfPresent & 1;// 1
static +processUntilQuit: Class<CoreProcessEventsOption__processUntilQuit> & CoreProcessEventsOption__processUntilQuit & 2;// 2
static +processAllIfPresent: Class<CoreProcessEventsOption__processAllIfPresent> & CoreProcessEventsOption__processAllIfPresent & 3;// 3

}

declare class CoreProcessEventsOption__processOneAndAllPending mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processOneIfPresent mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processUntilQuit mixins CoreProcessEventsOption {}
declare class CoreProcessEventsOption__processAllIfPresent mixins CoreProcessEventsOption {}

	declare export  class CoreWindowFlowDirection {
  constructor(...args: empty): mixed;
static +leftToRight: Class<CoreWindowFlowDirection__leftToRight> & CoreWindowFlowDirection__leftToRight & 0;// 0
static +rightToLeft: Class<CoreWindowFlowDirection__rightToLeft> & CoreWindowFlowDirection__rightToLeft & 1;// 1

}

declare class CoreWindowFlowDirection__leftToRight mixins CoreWindowFlowDirection {}
declare class CoreWindowFlowDirection__rightToLeft mixins CoreWindowFlowDirection {}

	declare export  class CoreVirtualKeyStates {
  constructor(...args: empty): mixed;
static +none: Class<CoreVirtualKeyStates__none> & CoreVirtualKeyStates__none & 0;// 0
static +down: Class<CoreVirtualKeyStates__down> & CoreVirtualKeyStates__down & 1;// 1
static +locked: Class<CoreVirtualKeyStates__locked> & CoreVirtualKeyStates__locked & 2;// 2

}

declare class CoreVirtualKeyStates__none mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__down mixins CoreVirtualKeyStates {}
declare class CoreVirtualKeyStates__locked mixins CoreVirtualKeyStates {}

	declare export  class CoreAcceleratorKeyEventType {
  constructor(...args: empty): mixed;
static +character: Class<CoreAcceleratorKeyEventType__character> & CoreAcceleratorKeyEventType__character & 0;// 0
static +deadCharacter: Class<CoreAcceleratorKeyEventType__deadCharacter> & CoreAcceleratorKeyEventType__deadCharacter & 1;// 1
static +keyDown: Class<CoreAcceleratorKeyEventType__keyDown> & CoreAcceleratorKeyEventType__keyDown & 2;// 2
static +keyUp: Class<CoreAcceleratorKeyEventType__keyUp> & CoreAcceleratorKeyEventType__keyUp & 3;// 3
static +systemCharacter: Class<CoreAcceleratorKeyEventType__systemCharacter> & CoreAcceleratorKeyEventType__systemCharacter & 4;// 4
static +systemDeadCharacter: Class<CoreAcceleratorKeyEventType__systemDeadCharacter> & CoreAcceleratorKeyEventType__systemDeadCharacter & 5;// 5
static +systemKeyDown: Class<CoreAcceleratorKeyEventType__systemKeyDown> & CoreAcceleratorKeyEventType__systemKeyDown & 6;// 6
static +systemKeyUp: Class<CoreAcceleratorKeyEventType__systemKeyUp> & CoreAcceleratorKeyEventType__systemKeyUp & 7;// 7
static +unicodeCharacter: Class<CoreAcceleratorKeyEventType__unicodeCharacter> & CoreAcceleratorKeyEventType__unicodeCharacter & 8;// 8

}

declare class CoreAcceleratorKeyEventType__character mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__deadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__keyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemDeadCharacter mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyDown mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__systemKeyUp mixins CoreAcceleratorKeyEventType {}
declare class CoreAcceleratorKeyEventType__unicodeCharacter mixins CoreAcceleratorKeyEventType {}

	declare export  class CoreProximityEvaluationScore {
  constructor(...args: empty): mixed;
static +closest: Class<CoreProximityEvaluationScore__closest> & CoreProximityEvaluationScore__closest & 0;// 0
static +farthest: Class<CoreProximityEvaluationScore__farthest> & CoreProximityEvaluationScore__farthest & 1;// 1

}

declare class CoreProximityEvaluationScore__closest mixins CoreProximityEvaluationScore {}
declare class CoreProximityEvaluationScore__farthest mixins CoreProximityEvaluationScore {}

	declare export interface CorePhysicalKeyStatus {
repeatCount: number,
scanCode: number,
isExtendedKey: boolean,
isMenuKeyDown: boolean,
wasKeyDown: boolean,
isKeyReleased: boolean
} 
	declare export interface CoreProximityEvaluation {
score: number,
adjustedPoint: Windows$Windows$Foundation.Point
} 
	declare export interface ICoreWindowEventArgs {
handled: boolean
} 
	declare export type IAutomationProviderRequestedEventArgs = {
automationProvider: any
} & undefined.ICoreWindowEventArgs

	declare export type ICharacterReceivedEventArgs = {
keyCode: number,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus
} & undefined.ICoreWindowEventArgs

	declare export type IInputEnabledEventArgs = {
inputEnabled: boolean
} & undefined.ICoreWindowEventArgs

	declare export type IKeyEventArgs = {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export type IPointerEventArgs = {
currentPoint: Windows$Windows$UI.Input.PointerPoint,
keyModifiers: Windows$Windows$System.VirtualKeyModifiers,
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
} & undefined.ICoreWindowEventArgs

	declare export type ITouchHitTestingEventArgs = {
boundingBox: Windows$Windows$Foundation.Rect,
point: Windows$Windows$Foundation.Point,
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation,
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
} & undefined.ICoreWindowEventArgs

	declare export type IWindowActivatedEventArgs = {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState
} & undefined.ICoreWindowEventArgs

	declare export type IWindowSizeChangedEventArgs = {
size: Windows$Windows$Foundation.Size
} & undefined.ICoreWindowEventArgs

	declare export type IVisibilityChangedEventArgs = {
visible: boolean
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreWindow {
automationHostProvider: any,
bounds: Windows$Windows$Foundation.Rect,
customProperties: Windows$Windows$Foundation.Collections.IPropertySet,
dispatcher: Windows$Windows$UI.Core.CoreDispatcher,
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection,
isInputEnabled: boolean,
pointerCursor: Windows$Windows$UI.Core.CoreCursor,
pointerPosition: Windows$Windows$Foundation.Point,
visible: boolean,
activate(): void,
close(): void,
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates,
releasePointerCapture(): void,
setPointerCapture(): void,
onactivated: any,
onautomationproviderrequested: any,
oncharacterreceived: any,
onclosed: any,
oninputenabled: any,
onkeydown: any,
onkeyup: any,
onpointercapturelost: any,
onpointerentered: any,
onpointerexited: any,
onpointermoved: any,
onpointerpressed: any,
onpointerreleased: any,
ontouchhittesting: any,
onpointerwheelchanged: any,
onsizechanged: any,
onvisibilitychanged: any
} 
	declare export class CoreDispatcher mixins undefined.ICoreDispatcher, undefined.ICoreAcceleratorKeys {
hasThreadAccess: boolean;
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void;
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction;
onacceleratorkeyactivated: any
}
	declare export class CoreCursor mixins undefined.ICoreCursor {
constructor(type: Windows$Windows$UI.Core.CoreCursorType, id: number): this;
id: number;
type: Windows$Windows$UI.Core.CoreCursorType
}
	declare export class CoreWindow mixins undefined.ICoreWindow {
automationHostProvider: any;
bounds: Windows$Windows$Foundation.Rect;
customProperties: Windows$Windows$Foundation.Collections.IPropertySet;
dispatcher: Windows$Windows$UI.Core.CoreDispatcher;
flowDirection: Windows$Windows$UI.Core.CoreWindowFlowDirection;
isInputEnabled: boolean;
pointerCursor: Windows$Windows$UI.Core.CoreCursor;
pointerPosition: Windows$Windows$Foundation.Point;
visible: boolean;
activate(): void;
close(): void;
getAsyncKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
getKeyState(
virtualKey: Windows$Windows$System.VirtualKey): Windows$Windows$UI.Core.CoreVirtualKeyStates;
releasePointerCapture(): void;
setPointerCapture(): void;
onactivated: any;
onautomationproviderrequested: any;
oncharacterreceived: any;
onclosed: any;
oninputenabled: any;
onkeydown: any;
onkeyup: any;
onpointercapturelost: any;
onpointerentered: any;
onpointerexited: any;
onpointermoved: any;
onpointerpressed: any;
onpointerreleased: any;
ontouchhittesting: any;
onpointerwheelchanged: any;
onsizechanged: any;
onvisibilitychanged: any;
static getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
}
	declare export class WindowActivatedEventArgs mixins undefined.IWindowActivatedEventArgs, undefined.ICoreWindowEventArgs {
windowActivationState: Windows$Windows$UI.Core.CoreWindowActivationState;
handled: boolean
}
	declare export class AutomationProviderRequestedEventArgs mixins undefined.IAutomationProviderRequestedEventArgs, undefined.ICoreWindowEventArgs {
automationProvider: any;
handled: boolean
}
	declare export class CharacterReceivedEventArgs mixins undefined.ICharacterReceivedEventArgs, undefined.ICoreWindowEventArgs {
keyCode: number;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
handled: boolean
}
	declare export class CoreWindowEventArgs mixins undefined.ICoreWindowEventArgs {
handled: boolean
}
	declare export class InputEnabledEventArgs mixins undefined.IInputEnabledEventArgs, undefined.ICoreWindowEventArgs {
inputEnabled: boolean;
handled: boolean
}
	declare export class KeyEventArgs mixins undefined.IKeyEventArgs, undefined.ICoreWindowEventArgs {
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export class PointerEventArgs mixins undefined.IPointerEventArgs, undefined.ICoreWindowEventArgs {
currentPoint: Windows$Windows$UI.Input.PointerPoint;
keyModifiers: Windows$Windows$System.VirtualKeyModifiers;
handled: boolean;
getIntermediatePoints(
): Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Input.PointerPoint>
}
	declare export class TouchHitTestingEventArgs mixins undefined.ITouchHitTestingEventArgs, undefined.ICoreWindowEventArgs {
boundingBox: Windows$Windows$Foundation.Rect;
point: Windows$Windows$Foundation.Point;
proximityEvaluation: Windows$Windows$UI.Core.CoreProximityEvaluation;
handled: boolean;
evaluateProximity(
controlBoundingBox: Windows$Windows$Foundation.Rect): Windows$Windows$UI.Core.CoreProximityEvaluation;
evaluateProximity(
controlVertices: Windows$Windows$Foundation.Point[]): Windows$Windows$UI.Core.CoreProximityEvaluation
}
	declare export class WindowSizeChangedEventArgs mixins undefined.IWindowSizeChangedEventArgs, undefined.ICoreWindowEventArgs {
size: Windows$Windows$Foundation.Size;
handled: boolean
}
	declare export class VisibilityChangedEventArgs mixins undefined.IVisibilityChangedEventArgs, undefined.ICoreWindowEventArgs {
visible: boolean;
handled: boolean
}
	declare export interface ICoreWindowStatic {
getForCurrentThread(): Windows$Windows$UI.Core.CoreWindow
} 
	declare export interface DispatchedHandler {
(): void
} 
	declare export interface IdleDispatchedHandler {
(e: Windows$Windows$UI.Core.IdleDispatchedHandlerArgs): void
} 
	declare export class IdleDispatchedHandlerArgs mixins undefined.IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
}
	declare export type IAcceleratorKeyEventArgs = {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType,
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus,
virtualKey: Windows$Windows$System.VirtualKey
} & undefined.ICoreWindowEventArgs

	declare export interface ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
} 
	declare export class AcceleratorKeyEventArgs mixins undefined.IAcceleratorKeyEventArgs, undefined.ICoreWindowEventArgs {
eventType: Windows$Windows$UI.Core.CoreAcceleratorKeyEventType;
keyStatus: Windows$Windows$UI.Core.CorePhysicalKeyStatus;
virtualKey: Windows$Windows$System.VirtualKey;
handled: boolean
}
	declare export type ICoreDispatcher = {
hasThreadAccess: boolean,
processEvents(options: Windows$Windows$UI.Core.CoreProcessEventsOption): void,
runAsync(
priority: Windows$Windows$UI.Core.CoreDispatcherPriority,
agileCallback: Windows$Windows$UI.Core.DispatchedHandler): Windows$Windows$Foundation.IAsyncAction,
runIdleAsync(
agileCallback: Windows$Windows$UI.Core.IdleDispatchedHandler): Windows$Windows$Foundation.IAsyncAction
} & undefined.ICoreAcceleratorKeys

	declare export interface IIdleDispatchedHandlerArgs {
isDispatcherIdle: boolean
} 
	declare export class CoreAcceleratorKeys mixins undefined.ICoreAcceleratorKeys {
onacceleratorkeyactivated: any
}
	declare export interface ICoreCursor {
id: number,
type: Windows$Windows$UI.Core.CoreCursorType
} 
	declare export interface ICoreCursorFactory {
createCursor(
type: Windows$Windows$UI.Core.CoreCursorType,
id: number): Windows$Windows$UI.Core.CoreCursor
} 
	declare export interface IInitializeWithCoreWindow {
initialize(window: Windows$Windows$UI.Core.CoreWindow): void
} 
	declare export interface ICoreWindowResizeManager {
notifyLayoutCompleted(): void
} 
	declare export interface ICoreWindowResizeManagerStatics {
getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
} 
	declare export class CoreWindowResizeManager mixins undefined.ICoreWindowResizeManager {
notifyLayoutCompleted(): void;
static getForCurrentView(): Windows$Windows$UI.Core.CoreWindowResizeManager
}
	declare export interface ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
} 
	declare export class CoreWindowPopupShowingEventArgs mixins undefined.ICoreWindowPopupShowingEventArgs {
setDesiredSize(value: Windows$Windows$Foundation.Size): void
}
	declare export interface ICoreWindowDialog {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
cancelCommandIndex: number,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowDialogFactory {
createWithTitle(title: string): Windows$Windows$UI.Core.CoreWindowDialog
} 
	declare export class CoreWindowDialog mixins undefined.ICoreWindowDialog {
constructor(title: string): this;
constructor(): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
cancelCommandIndex: number;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
	declare export interface ICoreWindowFlyout {
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler,
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>,
defaultCommandIndex: number,
isInteractionDelayed: number,
maxSize: Windows$Windows$Foundation.Size,
minSize: Windows$Windows$Foundation.Size,
title: string,
onshowing: any,
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
} 
	declare export interface ICoreWindowFlyoutFactory {
create(
position: Windows$Windows$Foundation.Point): Windows$Windows$UI.Core.CoreWindowFlyout,
createWithTitle(
position: Windows$Windows$Foundation.Point,
title: string): Windows$Windows$UI.Core.CoreWindowFlyout
} 
	declare export class CoreWindowFlyout mixins undefined.ICoreWindowFlyout {
constructor(position: Windows$Windows$Foundation.Point): this;
constructor(position: Windows$Windows$Foundation.Point, title: string): this;
backButtonCommand: Windows$Windows$UI.Popups.UICommandInvokedHandler;
commands: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$UI.Popups.IUICommand>;
defaultCommandIndex: number;
isInteractionDelayed: number;
maxSize: Windows$Windows$Foundation.Size;
minSize: Windows$Windows$Foundation.Size;
title: string;
onshowing: any;
showAsync(
): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$UI.Popups.IUICommand>
}
    }

	declare module 'WebUI' {
        declare export interface IActivatedDeferral {
complete(): void
} 
	declare export class ActivatedDeferral mixins undefined.IActivatedDeferral {
complete(): void
}
	declare export interface IActivatedOperation {
getDeferral(): Windows$Windows$UI.WebUI.ActivatedDeferral
} 
	declare export class ActivatedOperation mixins undefined.IActivatedOperation {
getDeferral(): Windows$Windows$UI.WebUI.ActivatedDeferral
}
	declare export interface IActivatedEventArgsDeferral {
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
} 
	declare export class WebUILaunchActivatedEventArgs mixins undefined.ILaunchActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
arguments: string;
tileId: string;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUISearchActivatedEventArgs mixins undefined.ISearchActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
language: string;
queryText: string;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIShareTargetActivatedEventArgs mixins undefined.IShareTargetActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
shareOperation: Windows$Windows$ApplicationModel.DataTransfer.ShareTarget.ShareOperation;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIFileActivatedEventArgs mixins undefined.IFileActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
files: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Storage.IStorageItem>;
verb: string;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIProtocolActivatedEventArgs mixins undefined.IProtocolActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
uri: Windows$Windows$Foundation.Uri;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIFileOpenPickerActivatedEventArgs mixins undefined.IFileOpenPickerActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
fileOpenPickerUI: Windows$Windows$Storage.Pickers.Provider.FileOpenPickerUI;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIFileSavePickerActivatedEventArgs mixins undefined.IFileSavePickerActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
fileSavePickerUI: Windows$Windows$Storage.Pickers.Provider.FileSavePickerUI;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUICachedFileUpdaterActivatedEventArgs mixins undefined.ICachedFileUpdaterActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
cachedFileUpdaterUI: Windows$Windows$Storage.Provider.CachedFileUpdaterUI;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIContactPickerActivatedEventArgs mixins undefined.IContactPickerActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
contactPickerUI: Windows$Windows$ApplicationModel.Contacts.Provider.ContactPickerUI;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIDeviceActivatedEventArgs mixins undefined.IDeviceActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
deviceInformationId: string;
verb: string;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUIPrintTaskSettingsActivatedEventArgs mixins undefined.IPrintTaskSettingsActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
configuration: Windows$Windows$Devices.Printers.Extensions.PrintTaskConfiguration;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export class WebUICameraSettingsActivatedEventArgs mixins undefined.ICameraSettingsActivatedEventArgs, undefined.IActivatedEventArgs, undefined.IActivatedEventArgsDeferral {
videoDeviceController: any;
videoDeviceExtension: any;
kind: Windows$Windows$ApplicationModel.Activation.ActivationKind;
previousExecutionState: Windows$Windows$ApplicationModel.Activation.ApplicationExecutionState;
splashScreen: Windows$Windows$ApplicationModel.Activation.SplashScreen;
activatedOperation: Windows$Windows$UI.WebUI.ActivatedOperation
}
	declare export interface ActivatedEventHandler {
(sender: any, eventArgs: Windows$Windows$ApplicationModel.Activation.IActivatedEventArgs): void
} 
	declare export interface ResumingEventHandler {
(sender: any): void
} 
	declare export interface SuspendingEventHandler {
(sender: any, e: Windows$Windows$ApplicationModel.ISuspendingEventArgs): void
} 
	declare export interface NavigatedEventHandler {
(sender: any, e: Windows$Windows$UI.WebUI.IWebUINavigatedEventArgs): void
} 
	declare export interface IWebUINavigatedEventArgs {
navigatedOperation: Windows$Windows$UI.WebUI.WebUINavigatedOperation
} 
	declare export class WebUINavigatedOperation mixins undefined.IWebUINavigatedOperation {
getDeferral(): Windows$Windows$UI.WebUI.WebUINavigatedDeferral
}
	declare export class SuspendingDeferral mixins undefined.ISuspendingDeferral {
complete(): void
}
	declare export class SuspendingOperation mixins undefined.ISuspendingOperation {
deadline: Date;
getDeferral(): Windows$Windows$ApplicationModel.SuspendingDeferral
}
	declare export class SuspendingEventArgs mixins undefined.ISuspendingEventArgs {
suspendingOperation: Windows$Windows$ApplicationModel.SuspendingOperation
}
	declare export interface IWebUIBackgroundTaskInstance {
succeeded: boolean
} 
	declare export interface IWebUIBackgroundTaskInstanceStatics {
current: Windows$Windows$UI.WebUI.IWebUIBackgroundTaskInstance
} 
	declare export class WebUIBackgroundTaskInstanceRuntimeClass mixins undefined.IWebUIBackgroundTaskInstance, undefined.IBackgroundTaskInstance {
succeeded: boolean;
instanceId: string;
progress: number;
suspendedCount: number;
task: Windows$Windows$ApplicationModel.Background.BackgroundTaskRegistration;
triggerDetails: any;
oncanceled: any;
getDeferral(): Windows$Windows$ApplicationModel.Background.BackgroundTaskDeferral
}
	declare export class WebUIBackgroundTaskInstance  {
static current: Windows$Windows$UI.WebUI.IWebUIBackgroundTaskInstance
}
	declare export interface IWebUINavigatedDeferral {
complete(): void
} 
	declare export class WebUINavigatedDeferral mixins undefined.IWebUINavigatedDeferral {
complete(): void
}
	declare export interface IWebUINavigatedOperation {
getDeferral(): Windows$Windows$UI.WebUI.WebUINavigatedDeferral
} 
	declare export class WebUINavigatedEventArgs mixins undefined.IWebUINavigatedEventArgs {
navigatedOperation: Windows$Windows$UI.WebUI.WebUINavigatedOperation
}
	declare export interface IWebUIActivationStatics {
onactivated: any,
onsuspending: any,
onresuming: any,
onnavigated: any
} 
	declare export class WebUIApplication  {
static onactivated: any;
static onsuspending: any;
static onresuming: any;
static onnavigated: any
}
    }

	declare export interface IColors {} 
	declare export interface IColorsStatics {
aliceBlue: Windows$Windows$UI.Color,
antiqueWhite: Windows$Windows$UI.Color,
aqua: Windows$Windows$UI.Color,
aquamarine: Windows$Windows$UI.Color,
azure: Windows$Windows$UI.Color,
beige: Windows$Windows$UI.Color,
bisque: Windows$Windows$UI.Color,
black: Windows$Windows$UI.Color,
blanchedAlmond: Windows$Windows$UI.Color,
blue: Windows$Windows$UI.Color,
blueViolet: Windows$Windows$UI.Color,
brown: Windows$Windows$UI.Color,
burlyWood: Windows$Windows$UI.Color,
cadetBlue: Windows$Windows$UI.Color,
chartreuse: Windows$Windows$UI.Color,
chocolate: Windows$Windows$UI.Color,
coral: Windows$Windows$UI.Color,
cornflowerBlue: Windows$Windows$UI.Color,
cornsilk: Windows$Windows$UI.Color,
crimson: Windows$Windows$UI.Color,
cyan: Windows$Windows$UI.Color,
darkBlue: Windows$Windows$UI.Color,
darkCyan: Windows$Windows$UI.Color,
darkGoldenrod: Windows$Windows$UI.Color,
darkGray: Windows$Windows$UI.Color,
darkGreen: Windows$Windows$UI.Color,
darkKhaki: Windows$Windows$UI.Color,
darkMagenta: Windows$Windows$UI.Color,
darkOliveGreen: Windows$Windows$UI.Color,
darkOrange: Windows$Windows$UI.Color,
darkOrchid: Windows$Windows$UI.Color,
darkRed: Windows$Windows$UI.Color,
darkSalmon: Windows$Windows$UI.Color,
darkSeaGreen: Windows$Windows$UI.Color,
darkSlateBlue: Windows$Windows$UI.Color,
darkSlateGray: Windows$Windows$UI.Color,
darkTurquoise: Windows$Windows$UI.Color,
darkViolet: Windows$Windows$UI.Color,
deepPink: Windows$Windows$UI.Color,
deepSkyBlue: Windows$Windows$UI.Color,
dimGray: Windows$Windows$UI.Color,
dodgerBlue: Windows$Windows$UI.Color,
firebrick: Windows$Windows$UI.Color,
floralWhite: Windows$Windows$UI.Color,
forestGreen: Windows$Windows$UI.Color,
fuchsia: Windows$Windows$UI.Color,
gainsboro: Windows$Windows$UI.Color,
ghostWhite: Windows$Windows$UI.Color,
gold: Windows$Windows$UI.Color,
goldenrod: Windows$Windows$UI.Color,
gray: Windows$Windows$UI.Color,
green: Windows$Windows$UI.Color,
greenYellow: Windows$Windows$UI.Color,
honeydew: Windows$Windows$UI.Color,
hotPink: Windows$Windows$UI.Color,
indianRed: Windows$Windows$UI.Color,
indigo: Windows$Windows$UI.Color,
ivory: Windows$Windows$UI.Color,
khaki: Windows$Windows$UI.Color,
lavender: Windows$Windows$UI.Color,
lavenderBlush: Windows$Windows$UI.Color,
lawnGreen: Windows$Windows$UI.Color,
lemonChiffon: Windows$Windows$UI.Color,
lightBlue: Windows$Windows$UI.Color,
lightCoral: Windows$Windows$UI.Color,
lightCyan: Windows$Windows$UI.Color,
lightGoldenrodYellow: Windows$Windows$UI.Color,
lightGray: Windows$Windows$UI.Color,
lightGreen: Windows$Windows$UI.Color,
lightPink: Windows$Windows$UI.Color,
lightSalmon: Windows$Windows$UI.Color,
lightSeaGreen: Windows$Windows$UI.Color,
lightSkyBlue: Windows$Windows$UI.Color,
lightSlateGray: Windows$Windows$UI.Color,
lightSteelBlue: Windows$Windows$UI.Color,
lightYellow: Windows$Windows$UI.Color,
lime: Windows$Windows$UI.Color,
limeGreen: Windows$Windows$UI.Color,
linen: Windows$Windows$UI.Color,
magenta: Windows$Windows$UI.Color,
maroon: Windows$Windows$UI.Color,
mediumAquamarine: Windows$Windows$UI.Color,
mediumBlue: Windows$Windows$UI.Color,
mediumOrchid: Windows$Windows$UI.Color,
mediumPurple: Windows$Windows$UI.Color,
mediumSeaGreen: Windows$Windows$UI.Color,
mediumSlateBlue: Windows$Windows$UI.Color,
mediumSpringGreen: Windows$Windows$UI.Color,
mediumTurquoise: Windows$Windows$UI.Color,
mediumVioletRed: Windows$Windows$UI.Color,
midnightBlue: Windows$Windows$UI.Color,
mintCream: Windows$Windows$UI.Color,
mistyRose: Windows$Windows$UI.Color,
moccasin: Windows$Windows$UI.Color,
navajoWhite: Windows$Windows$UI.Color,
navy: Windows$Windows$UI.Color,
oldLace: Windows$Windows$UI.Color,
olive: Windows$Windows$UI.Color,
oliveDrab: Windows$Windows$UI.Color,
orange: Windows$Windows$UI.Color,
orangeRed: Windows$Windows$UI.Color,
orchid: Windows$Windows$UI.Color,
paleGoldenrod: Windows$Windows$UI.Color,
paleGreen: Windows$Windows$UI.Color,
paleTurquoise: Windows$Windows$UI.Color,
paleVioletRed: Windows$Windows$UI.Color,
papayaWhip: Windows$Windows$UI.Color,
peachPuff: Windows$Windows$UI.Color,
peru: Windows$Windows$UI.Color,
pink: Windows$Windows$UI.Color,
plum: Windows$Windows$UI.Color,
powderBlue: Windows$Windows$UI.Color,
purple: Windows$Windows$UI.Color,
red: Windows$Windows$UI.Color,
rosyBrown: Windows$Windows$UI.Color,
royalBlue: Windows$Windows$UI.Color,
saddleBrown: Windows$Windows$UI.Color,
salmon: Windows$Windows$UI.Color,
sandyBrown: Windows$Windows$UI.Color,
seaGreen: Windows$Windows$UI.Color,
seaShell: Windows$Windows$UI.Color,
sienna: Windows$Windows$UI.Color,
silver: Windows$Windows$UI.Color,
skyBlue: Windows$Windows$UI.Color,
slateBlue: Windows$Windows$UI.Color,
slateGray: Windows$Windows$UI.Color,
snow: Windows$Windows$UI.Color,
springGreen: Windows$Windows$UI.Color,
steelBlue: Windows$Windows$UI.Color,
tan: Windows$Windows$UI.Color,
teal: Windows$Windows$UI.Color,
thistle: Windows$Windows$UI.Color,
tomato: Windows$Windows$UI.Color,
transparent: Windows$Windows$UI.Color,
turquoise: Windows$Windows$UI.Color,
violet: Windows$Windows$UI.Color,
wheat: Windows$Windows$UI.Color,
white: Windows$Windows$UI.Color,
whiteSmoke: Windows$Windows$UI.Color,
yellow: Windows$Windows$UI.Color,
yellowGreen: Windows$Windows$UI.Color
} 
	declare export class Colors mixins undefined.IColors {
static aliceBlue: Windows$Windows$UI.Color;
static antiqueWhite: Windows$Windows$UI.Color;
static aqua: Windows$Windows$UI.Color;
static aquamarine: Windows$Windows$UI.Color;
static azure: Windows$Windows$UI.Color;
static beige: Windows$Windows$UI.Color;
static bisque: Windows$Windows$UI.Color;
static black: Windows$Windows$UI.Color;
static blanchedAlmond: Windows$Windows$UI.Color;
static blue: Windows$Windows$UI.Color;
static blueViolet: Windows$Windows$UI.Color;
static brown: Windows$Windows$UI.Color;
static burlyWood: Windows$Windows$UI.Color;
static cadetBlue: Windows$Windows$UI.Color;
static chartreuse: Windows$Windows$UI.Color;
static chocolate: Windows$Windows$UI.Color;
static coral: Windows$Windows$UI.Color;
static cornflowerBlue: Windows$Windows$UI.Color;
static cornsilk: Windows$Windows$UI.Color;
static crimson: Windows$Windows$UI.Color;
static cyan: Windows$Windows$UI.Color;
static darkBlue: Windows$Windows$UI.Color;
static darkCyan: Windows$Windows$UI.Color;
static darkGoldenrod: Windows$Windows$UI.Color;
static darkGray: Windows$Windows$UI.Color;
static darkGreen: Windows$Windows$UI.Color;
static darkKhaki: Windows$Windows$UI.Color;
static darkMagenta: Windows$Windows$UI.Color;
static darkOliveGreen: Windows$Windows$UI.Color;
static darkOrange: Windows$Windows$UI.Color;
static darkOrchid: Windows$Windows$UI.Color;
static darkRed: Windows$Windows$UI.Color;
static darkSalmon: Windows$Windows$UI.Color;
static darkSeaGreen: Windows$Windows$UI.Color;
static darkSlateBlue: Windows$Windows$UI.Color;
static darkSlateGray: Windows$Windows$UI.Color;
static darkTurquoise: Windows$Windows$UI.Color;
static darkViolet: Windows$Windows$UI.Color;
static deepPink: Windows$Windows$UI.Color;
static deepSkyBlue: Windows$Windows$UI.Color;
static dimGray: Windows$Windows$UI.Color;
static dodgerBlue: Windows$Windows$UI.Color;
static firebrick: Windows$Windows$UI.Color;
static floralWhite: Windows$Windows$UI.Color;
static forestGreen: Windows$Windows$UI.Color;
static fuchsia: Windows$Windows$UI.Color;
static gainsboro: Windows$Windows$UI.Color;
static ghostWhite: Windows$Windows$UI.Color;
static gold: Windows$Windows$UI.Color;
static goldenrod: Windows$Windows$UI.Color;
static gray: Windows$Windows$UI.Color;
static green: Windows$Windows$UI.Color;
static greenYellow: Windows$Windows$UI.Color;
static honeydew: Windows$Windows$UI.Color;
static hotPink: Windows$Windows$UI.Color;
static indianRed: Windows$Windows$UI.Color;
static indigo: Windows$Windows$UI.Color;
static ivory: Windows$Windows$UI.Color;
static khaki: Windows$Windows$UI.Color;
static lavender: Windows$Windows$UI.Color;
static lavenderBlush: Windows$Windows$UI.Color;
static lawnGreen: Windows$Windows$UI.Color;
static lemonChiffon: Windows$Windows$UI.Color;
static lightBlue: Windows$Windows$UI.Color;
static lightCoral: Windows$Windows$UI.Color;
static lightCyan: Windows$Windows$UI.Color;
static lightGoldenrodYellow: Windows$Windows$UI.Color;
static lightGray: Windows$Windows$UI.Color;
static lightGreen: Windows$Windows$UI.Color;
static lightPink: Windows$Windows$UI.Color;
static lightSalmon: Windows$Windows$UI.Color;
static lightSeaGreen: Windows$Windows$UI.Color;
static lightSkyBlue: Windows$Windows$UI.Color;
static lightSlateGray: Windows$Windows$UI.Color;
static lightSteelBlue: Windows$Windows$UI.Color;
static lightYellow: Windows$Windows$UI.Color;
static lime: Windows$Windows$UI.Color;
static limeGreen: Windows$Windows$UI.Color;
static linen: Windows$Windows$UI.Color;
static magenta: Windows$Windows$UI.Color;
static maroon: Windows$Windows$UI.Color;
static mediumAquamarine: Windows$Windows$UI.Color;
static mediumBlue: Windows$Windows$UI.Color;
static mediumOrchid: Windows$Windows$UI.Color;
static mediumPurple: Windows$Windows$UI.Color;
static mediumSeaGreen: Windows$Windows$UI.Color;
static mediumSlateBlue: Windows$Windows$UI.Color;
static mediumSpringGreen: Windows$Windows$UI.Color;
static mediumTurquoise: Windows$Windows$UI.Color;
static mediumVioletRed: Windows$Windows$UI.Color;
static midnightBlue: Windows$Windows$UI.Color;
static mintCream: Windows$Windows$UI.Color;
static mistyRose: Windows$Windows$UI.Color;
static moccasin: Windows$Windows$UI.Color;
static navajoWhite: Windows$Windows$UI.Color;
static navy: Windows$Windows$UI.Color;
static oldLace: Windows$Windows$UI.Color;
static olive: Windows$Windows$UI.Color;
static oliveDrab: Windows$Windows$UI.Color;
static orange: Windows$Windows$UI.Color;
static orangeRed: Windows$Windows$UI.Color;
static orchid: Windows$Windows$UI.Color;
static paleGoldenrod: Windows$Windows$UI.Color;
static paleGreen: Windows$Windows$UI.Color;
static paleTurquoise: Windows$Windows$UI.Color;
static paleVioletRed: Windows$Windows$UI.Color;
static papayaWhip: Windows$Windows$UI.Color;
static peachPuff: Windows$Windows$UI.Color;
static peru: Windows$Windows$UI.Color;
static pink: Windows$Windows$UI.Color;
static plum: Windows$Windows$UI.Color;
static powderBlue: Windows$Windows$UI.Color;
static purple: Windows$Windows$UI.Color;
static red: Windows$Windows$UI.Color;
static rosyBrown: Windows$Windows$UI.Color;
static royalBlue: Windows$Windows$UI.Color;
static saddleBrown: Windows$Windows$UI.Color;
static salmon: Windows$Windows$UI.Color;
static sandyBrown: Windows$Windows$UI.Color;
static seaGreen: Windows$Windows$UI.Color;
static seaShell: Windows$Windows$UI.Color;
static sienna: Windows$Windows$UI.Color;
static silver: Windows$Windows$UI.Color;
static skyBlue: Windows$Windows$UI.Color;
static slateBlue: Windows$Windows$UI.Color;
static slateGray: Windows$Windows$UI.Color;
static snow: Windows$Windows$UI.Color;
static springGreen: Windows$Windows$UI.Color;
static steelBlue: Windows$Windows$UI.Color;
static tan: Windows$Windows$UI.Color;
static teal: Windows$Windows$UI.Color;
static thistle: Windows$Windows$UI.Color;
static tomato: Windows$Windows$UI.Color;
static transparent: Windows$Windows$UI.Color;
static turquoise: Windows$Windows$UI.Color;
static violet: Windows$Windows$UI.Color;
static wheat: Windows$Windows$UI.Color;
static white: Windows$Windows$UI.Color;
static whiteSmoke: Windows$Windows$UI.Color;
static yellow: Windows$Windows$UI.Color;
static yellowGreen: Windows$Windows$UI.Color
}
	declare export interface Color {
a: number,
r: number,
g: number,
b: number
} 
	declare export interface IColorHelper {} 
	declare export interface IColorHelperStatics {
fromArgb(a: number, r: number, g: number, b: number): Windows$Windows$UI.Color
} 
	declare export class ColorHelper mixins undefined.IColorHelper {
static fromArgb(a: number, r: number, g: number, b: number): Windows$Windows$UI.Color
}
	declare module 'Notifications' {
        declare export  class NotificationSetting {
  constructor(...args: empty): mixed;
static +enabled: Class<NotificationSetting__enabled> & NotificationSetting__enabled & 0;// 0
static +disabledForApplication: Class<NotificationSetting__disabledForApplication> & NotificationSetting__disabledForApplication & 1;// 1
static +disabledForUser: Class<NotificationSetting__disabledForUser> & NotificationSetting__disabledForUser & 2;// 2
static +disabledByGroupPolicy: Class<NotificationSetting__disabledByGroupPolicy> & NotificationSetting__disabledByGroupPolicy & 3;// 3
static +disabledByManifest: Class<NotificationSetting__disabledByManifest> & NotificationSetting__disabledByManifest & 4;// 4

}

declare class NotificationSetting__enabled mixins NotificationSetting {}
declare class NotificationSetting__disabledForApplication mixins NotificationSetting {}
declare class NotificationSetting__disabledForUser mixins NotificationSetting {}
declare class NotificationSetting__disabledByGroupPolicy mixins NotificationSetting {}
declare class NotificationSetting__disabledByManifest mixins NotificationSetting {}

	declare export  class ToastDismissalReason {
  constructor(...args: empty): mixed;
static +userCanceled: Class<ToastDismissalReason__userCanceled> & ToastDismissalReason__userCanceled & 0;// 0
static +applicationHidden: Class<ToastDismissalReason__applicationHidden> & ToastDismissalReason__applicationHidden & 1;// 1
static +timedOut: Class<ToastDismissalReason__timedOut> & ToastDismissalReason__timedOut & 2;// 2

}

declare class ToastDismissalReason__userCanceled mixins ToastDismissalReason {}
declare class ToastDismissalReason__applicationHidden mixins ToastDismissalReason {}
declare class ToastDismissalReason__timedOut mixins ToastDismissalReason {}

	declare export  class BadgeTemplateType {
  constructor(...args: empty): mixed;
static +badgeGlyph: Class<BadgeTemplateType__badgeGlyph> & BadgeTemplateType__badgeGlyph & 0;// 0
static +badgeNumber: Class<BadgeTemplateType__badgeNumber> & BadgeTemplateType__badgeNumber & 1;// 1

}

declare class BadgeTemplateType__badgeGlyph mixins BadgeTemplateType {}
declare class BadgeTemplateType__badgeNumber mixins BadgeTemplateType {}

	declare export  class TileTemplateType {
  constructor(...args: empty): mixed;
static +tileSquareImage: Class<TileTemplateType__tileSquareImage> & TileTemplateType__tileSquareImage & 0;// 0
static +tileSquareBlock: Class<TileTemplateType__tileSquareBlock> & TileTemplateType__tileSquareBlock & 1;// 1
static +tileSquareText01: Class<TileTemplateType__tileSquareText01> & TileTemplateType__tileSquareText01 & 2;// 2
static +tileSquareText02: Class<TileTemplateType__tileSquareText02> & TileTemplateType__tileSquareText02 & 3;// 3
static +tileSquareText03: Class<TileTemplateType__tileSquareText03> & TileTemplateType__tileSquareText03 & 4;// 4
static +tileSquareText04: Class<TileTemplateType__tileSquareText04> & TileTemplateType__tileSquareText04 & 5;// 5
static +tileSquarePeekImageAndText01: Class<TileTemplateType__tileSquarePeekImageAndText01> & TileTemplateType__tileSquarePeekImageAndText01 & 6;// 6
static +tileSquarePeekImageAndText02: Class<TileTemplateType__tileSquarePeekImageAndText02> & TileTemplateType__tileSquarePeekImageAndText02 & 7;// 7
static +tileSquarePeekImageAndText03: Class<TileTemplateType__tileSquarePeekImageAndText03> & TileTemplateType__tileSquarePeekImageAndText03 & 8;// 8
static +tileSquarePeekImageAndText04: Class<TileTemplateType__tileSquarePeekImageAndText04> & TileTemplateType__tileSquarePeekImageAndText04 & 9;// 9
static +tileWideImage: Class<TileTemplateType__tileWideImage> & TileTemplateType__tileWideImage & 10;// 10
static +tileWideImageCollection: Class<TileTemplateType__tileWideImageCollection> & TileTemplateType__tileWideImageCollection & 11;// 11
static +tileWideImageAndText01: Class<TileTemplateType__tileWideImageAndText01> & TileTemplateType__tileWideImageAndText01 & 12;// 12
static +tileWideImageAndText02: Class<TileTemplateType__tileWideImageAndText02> & TileTemplateType__tileWideImageAndText02 & 13;// 13
static +tileWideBlockAndText01: Class<TileTemplateType__tileWideBlockAndText01> & TileTemplateType__tileWideBlockAndText01 & 14;// 14
static +tileWideBlockAndText02: Class<TileTemplateType__tileWideBlockAndText02> & TileTemplateType__tileWideBlockAndText02 & 15;// 15
static +tileWidePeekImageCollection01: Class<TileTemplateType__tileWidePeekImageCollection01> & TileTemplateType__tileWidePeekImageCollection01 & 16;// 16
static +tileWidePeekImageCollection02: Class<TileTemplateType__tileWidePeekImageCollection02> & TileTemplateType__tileWidePeekImageCollection02 & 17;// 17
static +tileWidePeekImageCollection03: Class<TileTemplateType__tileWidePeekImageCollection03> & TileTemplateType__tileWidePeekImageCollection03 & 18;// 18
static +tileWidePeekImageCollection04: Class<TileTemplateType__tileWidePeekImageCollection04> & TileTemplateType__tileWidePeekImageCollection04 & 19;// 19
static +tileWidePeekImageCollection05: Class<TileTemplateType__tileWidePeekImageCollection05> & TileTemplateType__tileWidePeekImageCollection05 & 20;// 20
static +tileWidePeekImageCollection06: Class<TileTemplateType__tileWidePeekImageCollection06> & TileTemplateType__tileWidePeekImageCollection06 & 21;// 21
static +tileWidePeekImageAndText01: Class<TileTemplateType__tileWidePeekImageAndText01> & TileTemplateType__tileWidePeekImageAndText01 & 22;// 22
static +tileWidePeekImageAndText02: Class<TileTemplateType__tileWidePeekImageAndText02> & TileTemplateType__tileWidePeekImageAndText02 & 23;// 23
static +tileWidePeekImage01: Class<TileTemplateType__tileWidePeekImage01> & TileTemplateType__tileWidePeekImage01 & 24;// 24
static +tileWidePeekImage02: Class<TileTemplateType__tileWidePeekImage02> & TileTemplateType__tileWidePeekImage02 & 25;// 25
static +tileWidePeekImage03: Class<TileTemplateType__tileWidePeekImage03> & TileTemplateType__tileWidePeekImage03 & 26;// 26
static +tileWidePeekImage04: Class<TileTemplateType__tileWidePeekImage04> & TileTemplateType__tileWidePeekImage04 & 27;// 27
static +tileWidePeekImage05: Class<TileTemplateType__tileWidePeekImage05> & TileTemplateType__tileWidePeekImage05 & 28;// 28
static +tileWidePeekImage06: Class<TileTemplateType__tileWidePeekImage06> & TileTemplateType__tileWidePeekImage06 & 29;// 29
static +tileWideSmallImageAndText01: Class<TileTemplateType__tileWideSmallImageAndText01> & TileTemplateType__tileWideSmallImageAndText01 & 30;// 30
static +tileWideSmallImageAndText02: Class<TileTemplateType__tileWideSmallImageAndText02> & TileTemplateType__tileWideSmallImageAndText02 & 31;// 31
static +tileWideSmallImageAndText03: Class<TileTemplateType__tileWideSmallImageAndText03> & TileTemplateType__tileWideSmallImageAndText03 & 32;// 32
static +tileWideSmallImageAndText04: Class<TileTemplateType__tileWideSmallImageAndText04> & TileTemplateType__tileWideSmallImageAndText04 & 33;// 33
static +tileWideSmallImageAndText05: Class<TileTemplateType__tileWideSmallImageAndText05> & TileTemplateType__tileWideSmallImageAndText05 & 34;// 34
static +tileWideText01: Class<TileTemplateType__tileWideText01> & TileTemplateType__tileWideText01 & 35;// 35
static +tileWideText02: Class<TileTemplateType__tileWideText02> & TileTemplateType__tileWideText02 & 36;// 36
static +tileWideText03: Class<TileTemplateType__tileWideText03> & TileTemplateType__tileWideText03 & 37;// 37
static +tileWideText04: Class<TileTemplateType__tileWideText04> & TileTemplateType__tileWideText04 & 38;// 38
static +tileWideText05: Class<TileTemplateType__tileWideText05> & TileTemplateType__tileWideText05 & 39;// 39
static +tileWideText06: Class<TileTemplateType__tileWideText06> & TileTemplateType__tileWideText06 & 40;// 40
static +tileWideText07: Class<TileTemplateType__tileWideText07> & TileTemplateType__tileWideText07 & 41;// 41
static +tileWideText08: Class<TileTemplateType__tileWideText08> & TileTemplateType__tileWideText08 & 42;// 42
static +tileWideText09: Class<TileTemplateType__tileWideText09> & TileTemplateType__tileWideText09 & 43;// 43
static +tileWideText10: Class<TileTemplateType__tileWideText10> & TileTemplateType__tileWideText10 & 44;// 44
static +tileWideText11: Class<TileTemplateType__tileWideText11> & TileTemplateType__tileWideText11 & 45;// 45

}

declare class TileTemplateType__tileSquareImage mixins TileTemplateType {}
declare class TileTemplateType__tileSquareBlock mixins TileTemplateType {}
declare class TileTemplateType__tileSquareText01 mixins TileTemplateType {}
declare class TileTemplateType__tileSquareText02 mixins TileTemplateType {}
declare class TileTemplateType__tileSquareText03 mixins TileTemplateType {}
declare class TileTemplateType__tileSquareText04 mixins TileTemplateType {}
declare class TileTemplateType__tileSquarePeekImageAndText01 mixins TileTemplateType {}
declare class TileTemplateType__tileSquarePeekImageAndText02 mixins TileTemplateType {}
declare class TileTemplateType__tileSquarePeekImageAndText03 mixins TileTemplateType {}
declare class TileTemplateType__tileSquarePeekImageAndText04 mixins TileTemplateType {}
declare class TileTemplateType__tileWideImage mixins TileTemplateType {}
declare class TileTemplateType__tileWideImageCollection mixins TileTemplateType {}
declare class TileTemplateType__tileWideImageAndText01 mixins TileTemplateType {}
declare class TileTemplateType__tileWideImageAndText02 mixins TileTemplateType {}
declare class TileTemplateType__tileWideBlockAndText01 mixins TileTemplateType {}
declare class TileTemplateType__tileWideBlockAndText02 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageCollection01 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageCollection02 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageCollection03 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageCollection04 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageCollection05 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageCollection06 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageAndText01 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImageAndText02 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImage01 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImage02 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImage03 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImage04 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImage05 mixins TileTemplateType {}
declare class TileTemplateType__tileWidePeekImage06 mixins TileTemplateType {}
declare class TileTemplateType__tileWideSmallImageAndText01 mixins TileTemplateType {}
declare class TileTemplateType__tileWideSmallImageAndText02 mixins TileTemplateType {}
declare class TileTemplateType__tileWideSmallImageAndText03 mixins TileTemplateType {}
declare class TileTemplateType__tileWideSmallImageAndText04 mixins TileTemplateType {}
declare class TileTemplateType__tileWideSmallImageAndText05 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText01 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText02 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText03 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText04 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText05 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText06 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText07 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText08 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText09 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText10 mixins TileTemplateType {}
declare class TileTemplateType__tileWideText11 mixins TileTemplateType {}

	declare export  class ToastTemplateType {
  constructor(...args: empty): mixed;
static +toastImageAndText01: Class<ToastTemplateType__toastImageAndText01> & ToastTemplateType__toastImageAndText01 & 0;// 0
static +toastImageAndText02: Class<ToastTemplateType__toastImageAndText02> & ToastTemplateType__toastImageAndText02 & 1;// 1
static +toastImageAndText03: Class<ToastTemplateType__toastImageAndText03> & ToastTemplateType__toastImageAndText03 & 2;// 2
static +toastImageAndText04: Class<ToastTemplateType__toastImageAndText04> & ToastTemplateType__toastImageAndText04 & 3;// 3
static +toastText01: Class<ToastTemplateType__toastText01> & ToastTemplateType__toastText01 & 4;// 4
static +toastText02: Class<ToastTemplateType__toastText02> & ToastTemplateType__toastText02 & 5;// 5
static +toastText03: Class<ToastTemplateType__toastText03> & ToastTemplateType__toastText03 & 6;// 6
static +toastText04: Class<ToastTemplateType__toastText04> & ToastTemplateType__toastText04 & 7;// 7

}

declare class ToastTemplateType__toastImageAndText01 mixins ToastTemplateType {}
declare class ToastTemplateType__toastImageAndText02 mixins ToastTemplateType {}
declare class ToastTemplateType__toastImageAndText03 mixins ToastTemplateType {}
declare class ToastTemplateType__toastImageAndText04 mixins ToastTemplateType {}
declare class ToastTemplateType__toastText01 mixins ToastTemplateType {}
declare class ToastTemplateType__toastText02 mixins ToastTemplateType {}
declare class ToastTemplateType__toastText03 mixins ToastTemplateType {}
declare class ToastTemplateType__toastText04 mixins ToastTemplateType {}

	declare export  class PeriodicUpdateRecurrence {
  constructor(...args: empty): mixed;
static +halfHour: Class<PeriodicUpdateRecurrence__halfHour> & PeriodicUpdateRecurrence__halfHour & 0;// 0
static +hour: Class<PeriodicUpdateRecurrence__hour> & PeriodicUpdateRecurrence__hour & 1;// 1
static +sixHours: Class<PeriodicUpdateRecurrence__sixHours> & PeriodicUpdateRecurrence__sixHours & 2;// 2
static +twelveHours: Class<PeriodicUpdateRecurrence__twelveHours> & PeriodicUpdateRecurrence__twelveHours & 3;// 3
static +daily: Class<PeriodicUpdateRecurrence__daily> & PeriodicUpdateRecurrence__daily & 4;// 4

}

declare class PeriodicUpdateRecurrence__halfHour mixins PeriodicUpdateRecurrence {}
declare class PeriodicUpdateRecurrence__hour mixins PeriodicUpdateRecurrence {}
declare class PeriodicUpdateRecurrence__sixHours mixins PeriodicUpdateRecurrence {}
declare class PeriodicUpdateRecurrence__twelveHours mixins PeriodicUpdateRecurrence {}
declare class PeriodicUpdateRecurrence__daily mixins PeriodicUpdateRecurrence {}

	declare export interface IToastDismissedEventArgs {
reason: Windows$Windows$UI.Notifications.ToastDismissalReason
} 
	declare export interface IToastFailedEventArgs {
errorCode: number
} 
	declare export interface ITileUpdateManagerStatics {
createTileUpdaterForApplication(): Windows$Windows$UI.Notifications.TileUpdater,
createTileUpdaterForApplication(applicationId: string): Windows$Windows$UI.Notifications.TileUpdater,
createTileUpdaterForSecondaryTile(tileId: string): Windows$Windows$UI.Notifications.TileUpdater,
getTemplateContent(
type: Windows$Windows$UI.Notifications.TileTemplateType): Windows$Windows$Data.Xml.Dom.XmlDocument
} 
	declare export class TileUpdater mixins undefined.ITileUpdater {
setting: Windows$Windows$UI.Notifications.NotificationSetting;
update(notification: Windows$Windows$UI.Notifications.TileNotification): void;
clear(): void;
enableNotificationQueue(enable: boolean): void;
addToSchedule(
scheduledTile: Windows$Windows$UI.Notifications.ScheduledTileNotification): void;
removeFromSchedule(
scheduledTile: Windows$Windows$UI.Notifications.ScheduledTileNotification): void;
getScheduledTileNotifications(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Notifications.ScheduledTileNotification>;
startPeriodicUpdate(
tileContent: Windows$Windows$Foundation.Uri,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void;
startPeriodicUpdate(
tileContent: Windows$Windows$Foundation.Uri,
startTime: Date,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void;
stopPeriodicUpdate(): void;
startPeriodicUpdateBatch(
tileContents: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void;
startPeriodicUpdateBatch(
tileContents: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
startTime: Date,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void
}
	declare export interface ITileUpdater {
setting: Windows$Windows$UI.Notifications.NotificationSetting,
update(notification: Windows$Windows$UI.Notifications.TileNotification): void,
clear(): void,
enableNotificationQueue(enable: boolean): void,
addToSchedule(
scheduledTile: Windows$Windows$UI.Notifications.ScheduledTileNotification): void,
removeFromSchedule(
scheduledTile: Windows$Windows$UI.Notifications.ScheduledTileNotification): void,
getScheduledTileNotifications(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Notifications.ScheduledTileNotification>,
startPeriodicUpdate(
tileContent: Windows$Windows$Foundation.Uri,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void,
startPeriodicUpdate(
tileContent: Windows$Windows$Foundation.Uri,
startTime: Date,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void,
stopPeriodicUpdate(): void,
startPeriodicUpdateBatch(
tileContents: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void,
startPeriodicUpdateBatch(
tileContents: Windows$Windows$Foundation.Collections.IIterable<Windows$Windows$Foundation.Uri>,
startTime: Date,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void
} 
	declare export class TileNotification mixins undefined.ITileNotification {
constructor(content: Windows$Windows$Data.Xml.Dom.XmlDocument): this;
content: Windows$Windows$Data.Xml.Dom.XmlDocument;
expirationTime: Date;
tag: string
}
	declare export class ScheduledTileNotification mixins undefined.IScheduledTileNotification {
constructor(content: Windows$Windows$Data.Xml.Dom.XmlDocument, deliveryTime: Date): this;
content: Windows$Windows$Data.Xml.Dom.XmlDocument;
deliveryTime: Date;
expirationTime: Date;
id: string;
tag: string
}
	declare export interface IBadgeUpdateManagerStatics {
createBadgeUpdaterForApplication(): Windows$Windows$UI.Notifications.BadgeUpdater,
createBadgeUpdaterForApplication(applicationId: string): Windows$Windows$UI.Notifications.BadgeUpdater,
createBadgeUpdaterForSecondaryTile(tileId: string): Windows$Windows$UI.Notifications.BadgeUpdater,
getTemplateContent(
type: Windows$Windows$UI.Notifications.BadgeTemplateType): Windows$Windows$Data.Xml.Dom.XmlDocument
} 
	declare export class BadgeUpdater mixins undefined.IBadgeUpdater {
update(notification: Windows$Windows$UI.Notifications.BadgeNotification): void;
clear(): void;
startPeriodicUpdate(
badgeContent: Windows$Windows$Foundation.Uri,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void;
startPeriodicUpdate(
badgeContent: Windows$Windows$Foundation.Uri,
startTime: Date,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void;
stopPeriodicUpdate(): void
}
	declare export interface IBadgeUpdater {
update(notification: Windows$Windows$UI.Notifications.BadgeNotification): void,
clear(): void,
startPeriodicUpdate(
badgeContent: Windows$Windows$Foundation.Uri,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void,
startPeriodicUpdate(
badgeContent: Windows$Windows$Foundation.Uri,
startTime: Date,
requestedInterval: Windows$Windows$UI.Notifications.PeriodicUpdateRecurrence): void,
stopPeriodicUpdate(): void
} 
	declare export class BadgeNotification mixins undefined.IBadgeNotification {
constructor(content: Windows$Windows$Data.Xml.Dom.XmlDocument): this;
content: Windows$Windows$Data.Xml.Dom.XmlDocument;
expirationTime: Date
}
	declare export interface IToastNotificationManagerStatics {
createToastNotifier(): Windows$Windows$UI.Notifications.ToastNotifier,
createToastNotifier(applicationId: string): Windows$Windows$UI.Notifications.ToastNotifier,
getTemplateContent(
type: Windows$Windows$UI.Notifications.ToastTemplateType): Windows$Windows$Data.Xml.Dom.XmlDocument
} 
	declare export class ToastNotifier mixins undefined.IToastNotifier {
setting: Windows$Windows$UI.Notifications.NotificationSetting;
show(notification: Windows$Windows$UI.Notifications.ToastNotification): void;
hide(notification: Windows$Windows$UI.Notifications.ToastNotification): void;
addToSchedule(
scheduledToast: Windows$Windows$UI.Notifications.ScheduledToastNotification): void;
removeFromSchedule(
scheduledToast: Windows$Windows$UI.Notifications.ScheduledToastNotification): void;
getScheduledToastNotifications(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Notifications.ScheduledToastNotification>
}
	declare export interface IToastNotifier {
setting: Windows$Windows$UI.Notifications.NotificationSetting,
show(notification: Windows$Windows$UI.Notifications.ToastNotification): void,
hide(notification: Windows$Windows$UI.Notifications.ToastNotification): void,
addToSchedule(
scheduledToast: Windows$Windows$UI.Notifications.ScheduledToastNotification): void,
removeFromSchedule(
scheduledToast: Windows$Windows$UI.Notifications.ScheduledToastNotification): void,
getScheduledToastNotifications(
): Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$UI.Notifications.ScheduledToastNotification>
} 
	declare export class ToastNotification mixins undefined.IToastNotification {
constructor(content: Windows$Windows$Data.Xml.Dom.XmlDocument): this;
content: Windows$Windows$Data.Xml.Dom.XmlDocument;
expirationTime: Date;
ondismissed: any;
onactivated: any;
onfailed: any
}
	declare export class ScheduledToastNotification mixins undefined.IScheduledToastNotification {
constructor(content: Windows$Windows$Data.Xml.Dom.XmlDocument, deliveryTime: Date): this;
constructor(content: Windows$Windows$Data.Xml.Dom.XmlDocument, deliveryTime: Date, snoozeInterval: number, maximumSnoozeCount: number): this;
content: Windows$Windows$Data.Xml.Dom.XmlDocument;
deliveryTime: Date;
id: string;
maximumSnoozeCount: number;
snoozeInterval: number
}
	declare export interface ITileNotificationFactory {
createTileNotification(
content: Windows$Windows$Data.Xml.Dom.XmlDocument): Windows$Windows$UI.Notifications.TileNotification
} 
	declare export interface ITileNotification {
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
expirationTime: Date,
tag: string
} 
	declare export interface IBadgeNotificationFactory {
createBadgeNotification(
content: Windows$Windows$Data.Xml.Dom.XmlDocument): Windows$Windows$UI.Notifications.BadgeNotification
} 
	declare export interface IBadgeNotification {
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
expirationTime: Date
} 
	declare export interface IToastNotificationFactory {
createToastNotification(
content: Windows$Windows$Data.Xml.Dom.XmlDocument): Windows$Windows$UI.Notifications.ToastNotification
} 
	declare export interface IToastNotification {
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
expirationTime: Date,
ondismissed: any,
onactivated: any,
onfailed: any
} 
	declare export class ToastDismissedEventArgs mixins undefined.IToastDismissedEventArgs {
reason: Windows$Windows$UI.Notifications.ToastDismissalReason
}
	declare export class ToastFailedEventArgs mixins undefined.IToastFailedEventArgs {
errorCode: number
}
	declare export interface IScheduledToastNotificationFactory {
createScheduledToastNotification(
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
deliveryTime: Date): Windows$Windows$UI.Notifications.ScheduledToastNotification,
createScheduledToastNotification(
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
deliveryTime: Date,
snoozeInterval: number,
maximumSnoozeCount: number): Windows$Windows$UI.Notifications.ScheduledToastNotification
} 
	declare export interface IScheduledToastNotification {
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
deliveryTime: Date,
id: string,
maximumSnoozeCount: number,
snoozeInterval: number
} 
	declare export interface IScheduledTileNotificationFactory {
createScheduledTileNotification(
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
deliveryTime: Date): Windows$Windows$UI.Notifications.ScheduledTileNotification
} 
	declare export interface IScheduledTileNotification {
content: Windows$Windows$Data.Xml.Dom.XmlDocument,
deliveryTime: Date,
expirationTime: Date,
id: string,
tag: string
} 
	declare export class TileUpdateManager  {
static createTileUpdaterForApplication(): Windows$Windows$UI.Notifications.TileUpdater;
static createTileUpdaterForApplication(applicationId: string): Windows$Windows$UI.Notifications.TileUpdater;
static createTileUpdaterForSecondaryTile(tileId: string): Windows$Windows$UI.Notifications.TileUpdater;
static getTemplateContent(
type: Windows$Windows$UI.Notifications.TileTemplateType): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export class BadgeUpdateManager  {
static createBadgeUpdaterForApplication(): Windows$Windows$UI.Notifications.BadgeUpdater;
static createBadgeUpdaterForApplication(applicationId: string): Windows$Windows$UI.Notifications.BadgeUpdater;
static createBadgeUpdaterForSecondaryTile(tileId: string): Windows$Windows$UI.Notifications.BadgeUpdater;
static getTemplateContent(
type: Windows$Windows$UI.Notifications.BadgeTemplateType): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export class ToastNotificationManager  {
static createToastNotifier(): Windows$Windows$UI.Notifications.ToastNotifier;
static createToastNotifier(applicationId: string): Windows$Windows$UI.Notifications.ToastNotifier;
static getTemplateContent(
type: Windows$Windows$UI.Notifications.ToastTemplateType): Windows$Windows$Data.Xml.Dom.XmlDocument
}
    }

    }


declare module 'Web' {
        declare export  class WebAuthenticationStatus {
  constructor(...args: empty): mixed;
static +success: Class<WebAuthenticationStatus__success> & WebAuthenticationStatus__success & 0;// 0
static +userCancel: Class<WebAuthenticationStatus__userCancel> & WebAuthenticationStatus__userCancel & 1;// 1
static +errorHttp: Class<WebAuthenticationStatus__errorHttp> & WebAuthenticationStatus__errorHttp & 2;// 2

}

declare class WebAuthenticationStatus__success mixins WebAuthenticationStatus {}
declare class WebAuthenticationStatus__userCancel mixins WebAuthenticationStatus {}
declare class WebAuthenticationStatus__errorHttp mixins WebAuthenticationStatus {}

	declare export  class WebAuthenticationOptions {
  constructor(...args: empty): mixed;
static +none: Class<WebAuthenticationOptions__none> & WebAuthenticationOptions__none & 0;// 0
static +silentMode: Class<WebAuthenticationOptions__silentMode> & WebAuthenticationOptions__silentMode & 1;// 1
static +useTitle: Class<WebAuthenticationOptions__useTitle> & WebAuthenticationOptions__useTitle & 2;// 2
static +useHttpPost: Class<WebAuthenticationOptions__useHttpPost> & WebAuthenticationOptions__useHttpPost & 3;// 3
static +useCorporateNetwork: Class<WebAuthenticationOptions__useCorporateNetwork> & WebAuthenticationOptions__useCorporateNetwork & 4;// 4

}

declare class WebAuthenticationOptions__none mixins WebAuthenticationOptions {}
declare class WebAuthenticationOptions__silentMode mixins WebAuthenticationOptions {}
declare class WebAuthenticationOptions__useTitle mixins WebAuthenticationOptions {}
declare class WebAuthenticationOptions__useHttpPost mixins WebAuthenticationOptions {}
declare class WebAuthenticationOptions__useCorporateNetwork mixins WebAuthenticationOptions {}

	declare export interface IWebAuthenticationResult {
responseData: string,
responseErrorDetail: number,
responseStatus: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationStatus
} 
	declare export class WebAuthenticationResult mixins undefined.IWebAuthenticationResult {
responseData: string;
responseErrorDetail: number;
responseStatus: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationStatus
}
	declare export interface IWebAuthenticationBrokerStatics {
authenticateAsync(
options: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationOptions,
requestUri: Windows$Windows$Foundation.Uri,
callbackUri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationResult>,
authenticateAsync(
options: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationOptions,
requestUri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationResult>,
authenticateAndContinue(requestUri: Windows$Windows$Foundation.Uri): void,
authenticateAndContinue(
requestUri: Windows$Windows$Foundation.Uri,
callbackUri: Windows$Windows$Foundation.Uri): void,
authenticateAndContinue(
requestUri: Windows$Windows$Foundation.Uri,
callbackUri: Windows$Windows$Foundation.Uri,
continuationData: Windows$Windows$Foundation.Collections.ValueSet,
options: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationOptions): void,
getCurrentApplicationCallbackUri(): Windows$Windows$Foundation.Uri
} 
	declare export class WebAuthenticationBroker  {
static authenticateAsync(
options: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationOptions,
requestUri: Windows$Windows$Foundation.Uri,
callbackUri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationResult>;
static authenticateAsync(
options: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationOptions,
requestUri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperation<Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationResult>;
static authenticateAndContinue(requestUri: Windows$Windows$Foundation.Uri): void;
static authenticateAndContinue(
requestUri: Windows$Windows$Foundation.Uri,
callbackUri: Windows$Windows$Foundation.Uri): void;
static authenticateAndContinue(
requestUri: Windows$Windows$Foundation.Uri,
callbackUri: Windows$Windows$Foundation.Uri,
continuationData: Windows$Windows$Foundation.Collections.ValueSet,
options: Windows$Windows$Security.Authentication.Windows$Web.WebAuthenticationOptions): void;
static getCurrentApplicationCallbackUri(): Windows$Windows$Foundation.Uri
}
	declare export  class WebErrorStatus {
  constructor(...args: empty): mixed;
static +unknown: Class<WebErrorStatus__unknown> & WebErrorStatus__unknown & 0;// 0
static +certificateCommonNameIsIncorrect: Class<WebErrorStatus__certificateCommonNameIsIncorrect> & WebErrorStatus__certificateCommonNameIsIncorrect & 1;// 1
static +certificateExpired: Class<WebErrorStatus__certificateExpired> & WebErrorStatus__certificateExpired & 2;// 2
static +certificateContainsErrors: Class<WebErrorStatus__certificateContainsErrors> & WebErrorStatus__certificateContainsErrors & 3;// 3
static +certificateRevoked: Class<WebErrorStatus__certificateRevoked> & WebErrorStatus__certificateRevoked & 4;// 4
static +certificateIsInvalid: Class<WebErrorStatus__certificateIsInvalid> & WebErrorStatus__certificateIsInvalid & 5;// 5
static +serverUnreachable: Class<WebErrorStatus__serverUnreachable> & WebErrorStatus__serverUnreachable & 6;// 6
static +timeout: Class<WebErrorStatus__timeout> & WebErrorStatus__timeout & 7;// 7
static +errorHttpInvalidServerResponse: Class<WebErrorStatus__errorHttpInvalidServerResponse> & WebErrorStatus__errorHttpInvalidServerResponse & 8;// 8
static +connectionAborted: Class<WebErrorStatus__connectionAborted> & WebErrorStatus__connectionAborted & 9;// 9
static +connectionReset: Class<WebErrorStatus__connectionReset> & WebErrorStatus__connectionReset & 10;// 10
static +disconnected: Class<WebErrorStatus__disconnected> & WebErrorStatus__disconnected & 11;// 11
static +httpToHttpsOnRedirection: Class<WebErrorStatus__httpToHttpsOnRedirection> & WebErrorStatus__httpToHttpsOnRedirection & 12;// 12
static +httpsToHttpOnRedirection: Class<WebErrorStatus__httpsToHttpOnRedirection> & WebErrorStatus__httpsToHttpOnRedirection & 13;// 13
static +cannotConnect: Class<WebErrorStatus__cannotConnect> & WebErrorStatus__cannotConnect & 14;// 14
static +hostNameNotResolved: Class<WebErrorStatus__hostNameNotResolved> & WebErrorStatus__hostNameNotResolved & 15;// 15
static +operationCanceled: Class<WebErrorStatus__operationCanceled> & WebErrorStatus__operationCanceled & 16;// 16
static +redirectFailed: Class<WebErrorStatus__redirectFailed> & WebErrorStatus__redirectFailed & 17;// 17
static +unexpectedStatusCode: Class<WebErrorStatus__unexpectedStatusCode> & WebErrorStatus__unexpectedStatusCode & 18;// 18
static +unexpectedRedirection: Class<WebErrorStatus__unexpectedRedirection> & WebErrorStatus__unexpectedRedirection & 19;// 19
static +unexpectedClientError: Class<WebErrorStatus__unexpectedClientError> & WebErrorStatus__unexpectedClientError & 20;// 20
static +unexpectedServerError: Class<WebErrorStatus__unexpectedServerError> & WebErrorStatus__unexpectedServerError & 21;// 21
static +multipleChoices: Class<WebErrorStatus__multipleChoices> & WebErrorStatus__multipleChoices & 22;// 22
static +movedPermanently: Class<WebErrorStatus__movedPermanently> & WebErrorStatus__movedPermanently & 23;// 23
static +found: Class<WebErrorStatus__found> & WebErrorStatus__found & 24;// 24
static +seeOther: Class<WebErrorStatus__seeOther> & WebErrorStatus__seeOther & 25;// 25
static +notModified: Class<WebErrorStatus__notModified> & WebErrorStatus__notModified & 26;// 26
static +useProxy: Class<WebErrorStatus__useProxy> & WebErrorStatus__useProxy & 27;// 27
static +temporaryRedirect: Class<WebErrorStatus__temporaryRedirect> & WebErrorStatus__temporaryRedirect & 28;// 28
static +badRequest: Class<WebErrorStatus__badRequest> & WebErrorStatus__badRequest & 29;// 29
static +unauthorized: Class<WebErrorStatus__unauthorized> & WebErrorStatus__unauthorized & 30;// 30
static +paymentRequired: Class<WebErrorStatus__paymentRequired> & WebErrorStatus__paymentRequired & 31;// 31
static +forbidden: Class<WebErrorStatus__forbidden> & WebErrorStatus__forbidden & 32;// 32
static +notFound: Class<WebErrorStatus__notFound> & WebErrorStatus__notFound & 33;// 33
static +methodNotAllowed: Class<WebErrorStatus__methodNotAllowed> & WebErrorStatus__methodNotAllowed & 34;// 34
static +notAcceptable: Class<WebErrorStatus__notAcceptable> & WebErrorStatus__notAcceptable & 35;// 35
static +proxyAuthenticationRequired: Class<WebErrorStatus__proxyAuthenticationRequired> & WebErrorStatus__proxyAuthenticationRequired & 36;// 36
static +requestTimeout: Class<WebErrorStatus__requestTimeout> & WebErrorStatus__requestTimeout & 37;// 37
static +conflict: Class<WebErrorStatus__conflict> & WebErrorStatus__conflict & 38;// 38
static +gone: Class<WebErrorStatus__gone> & WebErrorStatus__gone & 39;// 39
static +lengthRequired: Class<WebErrorStatus__lengthRequired> & WebErrorStatus__lengthRequired & 40;// 40
static +preconditionFailed: Class<WebErrorStatus__preconditionFailed> & WebErrorStatus__preconditionFailed & 41;// 41
static +requestEntityTooLarge: Class<WebErrorStatus__requestEntityTooLarge> & WebErrorStatus__requestEntityTooLarge & 42;// 42
static +requestUriTooLong: Class<WebErrorStatus__requestUriTooLong> & WebErrorStatus__requestUriTooLong & 43;// 43
static +unsupportedMediaType: Class<WebErrorStatus__unsupportedMediaType> & WebErrorStatus__unsupportedMediaType & 44;// 44
static +requestedRangeNotSatisfiable: Class<WebErrorStatus__requestedRangeNotSatisfiable> & WebErrorStatus__requestedRangeNotSatisfiable & 45;// 45
static +expectationFailed: Class<WebErrorStatus__expectationFailed> & WebErrorStatus__expectationFailed & 46;// 46
static +internalServerError: Class<WebErrorStatus__internalServerError> & WebErrorStatus__internalServerError & 47;// 47
static +notImplemented: Class<WebErrorStatus__notImplemented> & WebErrorStatus__notImplemented & 48;// 48
static +badGateway: Class<WebErrorStatus__badGateway> & WebErrorStatus__badGateway & 49;// 49
static +serviceUnavailable: Class<WebErrorStatus__serviceUnavailable> & WebErrorStatus__serviceUnavailable & 50;// 50
static +gatewayTimeout: Class<WebErrorStatus__gatewayTimeout> & WebErrorStatus__gatewayTimeout & 51;// 51
static +httpVersionNotSupported: Class<WebErrorStatus__httpVersionNotSupported> & WebErrorStatus__httpVersionNotSupported & 52;// 52

}

declare class WebErrorStatus__unknown mixins WebErrorStatus {}
declare class WebErrorStatus__certificateCommonNameIsIncorrect mixins WebErrorStatus {}
declare class WebErrorStatus__certificateExpired mixins WebErrorStatus {}
declare class WebErrorStatus__certificateContainsErrors mixins WebErrorStatus {}
declare class WebErrorStatus__certificateRevoked mixins WebErrorStatus {}
declare class WebErrorStatus__certificateIsInvalid mixins WebErrorStatus {}
declare class WebErrorStatus__serverUnreachable mixins WebErrorStatus {}
declare class WebErrorStatus__timeout mixins WebErrorStatus {}
declare class WebErrorStatus__errorHttpInvalidServerResponse mixins WebErrorStatus {}
declare class WebErrorStatus__connectionAborted mixins WebErrorStatus {}
declare class WebErrorStatus__connectionReset mixins WebErrorStatus {}
declare class WebErrorStatus__disconnected mixins WebErrorStatus {}
declare class WebErrorStatus__httpToHttpsOnRedirection mixins WebErrorStatus {}
declare class WebErrorStatus__httpsToHttpOnRedirection mixins WebErrorStatus {}
declare class WebErrorStatus__cannotConnect mixins WebErrorStatus {}
declare class WebErrorStatus__hostNameNotResolved mixins WebErrorStatus {}
declare class WebErrorStatus__operationCanceled mixins WebErrorStatus {}
declare class WebErrorStatus__redirectFailed mixins WebErrorStatus {}
declare class WebErrorStatus__unexpectedStatusCode mixins WebErrorStatus {}
declare class WebErrorStatus__unexpectedRedirection mixins WebErrorStatus {}
declare class WebErrorStatus__unexpectedClientError mixins WebErrorStatus {}
declare class WebErrorStatus__unexpectedServerError mixins WebErrorStatus {}
declare class WebErrorStatus__multipleChoices mixins WebErrorStatus {}
declare class WebErrorStatus__movedPermanently mixins WebErrorStatus {}
declare class WebErrorStatus__found mixins WebErrorStatus {}
declare class WebErrorStatus__seeOther mixins WebErrorStatus {}
declare class WebErrorStatus__notModified mixins WebErrorStatus {}
declare class WebErrorStatus__useProxy mixins WebErrorStatus {}
declare class WebErrorStatus__temporaryRedirect mixins WebErrorStatus {}
declare class WebErrorStatus__badRequest mixins WebErrorStatus {}
declare class WebErrorStatus__unauthorized mixins WebErrorStatus {}
declare class WebErrorStatus__paymentRequired mixins WebErrorStatus {}
declare class WebErrorStatus__forbidden mixins WebErrorStatus {}
declare class WebErrorStatus__notFound mixins WebErrorStatus {}
declare class WebErrorStatus__methodNotAllowed mixins WebErrorStatus {}
declare class WebErrorStatus__notAcceptable mixins WebErrorStatus {}
declare class WebErrorStatus__proxyAuthenticationRequired mixins WebErrorStatus {}
declare class WebErrorStatus__requestTimeout mixins WebErrorStatus {}
declare class WebErrorStatus__conflict mixins WebErrorStatus {}
declare class WebErrorStatus__gone mixins WebErrorStatus {}
declare class WebErrorStatus__lengthRequired mixins WebErrorStatus {}
declare class WebErrorStatus__preconditionFailed mixins WebErrorStatus {}
declare class WebErrorStatus__requestEntityTooLarge mixins WebErrorStatus {}
declare class WebErrorStatus__requestUriTooLong mixins WebErrorStatus {}
declare class WebErrorStatus__unsupportedMediaType mixins WebErrorStatus {}
declare class WebErrorStatus__requestedRangeNotSatisfiable mixins WebErrorStatus {}
declare class WebErrorStatus__expectationFailed mixins WebErrorStatus {}
declare class WebErrorStatus__internalServerError mixins WebErrorStatus {}
declare class WebErrorStatus__notImplemented mixins WebErrorStatus {}
declare class WebErrorStatus__badGateway mixins WebErrorStatus {}
declare class WebErrorStatus__serviceUnavailable mixins WebErrorStatus {}
declare class WebErrorStatus__gatewayTimeout mixins WebErrorStatus {}
declare class WebErrorStatus__httpVersionNotSupported mixins WebErrorStatus {}

	declare export interface IWebErrorStatics {
getStatus(hresult: number): Windows$Windows$Web.WebErrorStatus
} 
	declare export class WebError  {
static getStatus(hresult: number): Windows$Windows$Web.WebErrorStatus
}
	declare module 'Syndication' {
        declare export interface RetrievalProgress {
bytesRetrieved: number,
totalBytesToRetrieve: number
} 
	declare export interface TransferProgress {
bytesSent: number,
totalBytesToSend: number,
bytesRetrieved: number,
totalBytesToRetrieve: number
} 
	declare export  class SyndicationFormat {
  constructor(...args: empty): mixed;
static +atom10: Class<SyndicationFormat__atom10> & SyndicationFormat__atom10 & 0;// 0
static +rss20: Class<SyndicationFormat__rss20> & SyndicationFormat__rss20 & 1;// 1
static +rss10: Class<SyndicationFormat__rss10> & SyndicationFormat__rss10 & 2;// 2
static +rss092: Class<SyndicationFormat__rss092> & SyndicationFormat__rss092 & 3;// 3
static +rss091: Class<SyndicationFormat__rss091> & SyndicationFormat__rss091 & 4;// 4
static +atom03: Class<SyndicationFormat__atom03> & SyndicationFormat__atom03 & 5;// 5

}

declare class SyndicationFormat__atom10 mixins SyndicationFormat {}
declare class SyndicationFormat__rss20 mixins SyndicationFormat {}
declare class SyndicationFormat__rss10 mixins SyndicationFormat {}
declare class SyndicationFormat__rss092 mixins SyndicationFormat {}
declare class SyndicationFormat__rss091 mixins SyndicationFormat {}
declare class SyndicationFormat__atom03 mixins SyndicationFormat {}

	declare export  class SyndicationErrorStatus {
  constructor(...args: empty): mixed;
static +unknown: Class<SyndicationErrorStatus__unknown> & SyndicationErrorStatus__unknown & 0;// 0
static +missingRequiredElement: Class<SyndicationErrorStatus__missingRequiredElement> & SyndicationErrorStatus__missingRequiredElement & 1;// 1
static +missingRequiredAttribute: Class<SyndicationErrorStatus__missingRequiredAttribute> & SyndicationErrorStatus__missingRequiredAttribute & 2;// 2
static +invalidXml: Class<SyndicationErrorStatus__invalidXml> & SyndicationErrorStatus__invalidXml & 3;// 3
static +unexpectedContent: Class<SyndicationErrorStatus__unexpectedContent> & SyndicationErrorStatus__unexpectedContent & 4;// 4
static +unsupportedFormat: Class<SyndicationErrorStatus__unsupportedFormat> & SyndicationErrorStatus__unsupportedFormat & 5;// 5

}

declare class SyndicationErrorStatus__unknown mixins SyndicationErrorStatus {}
declare class SyndicationErrorStatus__missingRequiredElement mixins SyndicationErrorStatus {}
declare class SyndicationErrorStatus__missingRequiredAttribute mixins SyndicationErrorStatus {}
declare class SyndicationErrorStatus__invalidXml mixins SyndicationErrorStatus {}
declare class SyndicationErrorStatus__unexpectedContent mixins SyndicationErrorStatus {}
declare class SyndicationErrorStatus__unsupportedFormat mixins SyndicationErrorStatus {}

	declare export interface ISyndicationAttribute {
name: string,
namespace: string,
value: string
} 
	declare export class SyndicationAttribute mixins undefined.ISyndicationAttribute {
constructor(attributeName: string, attributeNamespace: string, attributeValue: string): this;
constructor(): this;
name: string;
namespace: string;
value: string
}
	declare export interface ISyndicationAttributeFactory {
createSyndicationAttribute(
attributeName: string,
attributeNamespace: string,
attributeValue: string): Windows$Windows$Web.Syndication.SyndicationAttribute
} 
	declare export interface ISyndicationNode {
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>,
baseUri: Windows$Windows$Foundation.Uri,
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>,
language: string,
nodeName: string,
nodeNamespace: string,
nodeValue: string,
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
} 
	declare export class SyndicationNode mixins undefined.ISyndicationNode {
constructor(nodeName: string, nodeNamespace: string, nodeValue: string): this;
constructor(): this;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export interface ISyndicationNodeFactory {
createSyndicationNode(
nodeName: string,
nodeNamespace: string,
nodeValue: string): Windows$Windows$Web.Syndication.SyndicationNode
} 
	declare export interface ISyndicationGenerator {
text: string,
uri: Windows$Windows$Foundation.Uri,
version: string
} 
	declare export class SyndicationGenerator mixins undefined.ISyndicationGenerator, undefined.ISyndicationNode {
constructor(text: string): this;
constructor(): this;
text: string;
uri: Windows$Windows$Foundation.Uri;
version: string;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export interface ISyndicationGeneratorFactory {
createSyndicationGenerator(text: string): Windows$Windows$Web.Syndication.SyndicationGenerator
} 
	declare export type ISyndicationText = {
text: string,
type: string,
xml: Windows$Windows$Data.Xml.Dom.XmlDocument
} & undefined.ISyndicationNode

	declare export class SyndicationText mixins undefined.ISyndicationText, undefined.ISyndicationNode {
constructor(text: string): this;
constructor(text: string, type: Windows$Windows$Web.Syndication.SyndicationTextType): this;
constructor(): this;
text: string;
type: string;
xml: Windows$Windows$Data.Xml.Dom.XmlDocument;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export  class SyndicationTextType {
  constructor(...args: empty): mixed;
static +text: Class<SyndicationTextType__text> & SyndicationTextType__text & 0;// 0
static +html: Class<SyndicationTextType__html> & SyndicationTextType__html & 1;// 1
static +xhtml: Class<SyndicationTextType__xhtml> & SyndicationTextType__xhtml & 2;// 2

}

declare class SyndicationTextType__text mixins SyndicationTextType {}
declare class SyndicationTextType__html mixins SyndicationTextType {}
declare class SyndicationTextType__xhtml mixins SyndicationTextType {}

	declare export interface ISyndicationTextFactory {
createSyndicationText(text: string): Windows$Windows$Web.Syndication.SyndicationText,
createSyndicationText(
text: string,
type: Windows$Windows$Web.Syndication.SyndicationTextType): Windows$Windows$Web.Syndication.SyndicationText
} 
	declare export type ISyndicationContent = {
sourceUri: Windows$Windows$Foundation.Uri
} & undefined.ISyndicationText & undefined.ISyndicationNode

	declare export class SyndicationContent mixins undefined.ISyndicationText, undefined.ISyndicationNode, undefined.ISyndicationContent {
constructor(text: string, type: Windows$Windows$Web.Syndication.SyndicationTextType): this;
constructor(sourceUri: Windows$Windows$Foundation.Uri): this;
constructor(): this;
text: string;
type: string;
xml: Windows$Windows$Data.Xml.Dom.XmlDocument;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
sourceUri: Windows$Windows$Foundation.Uri;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export interface ISyndicationContentFactory {
createSyndicationContent(
text: string,
type: Windows$Windows$Web.Syndication.SyndicationTextType): Windows$Windows$Web.Syndication.SyndicationContent,
createSyndicationContent(
sourceUri: Windows$Windows$Foundation.Uri): Windows$Windows$Web.Syndication.SyndicationContent
} 
	declare export type ISyndicationLink = {
length: number,
mediaType: string,
relationship: string,
resourceLanguage: string,
title: string,
uri: Windows$Windows$Foundation.Uri
} & undefined.ISyndicationNode

	declare export class SyndicationLink mixins undefined.ISyndicationLink, undefined.ISyndicationNode {
constructor(uri: Windows$Windows$Foundation.Uri): this;
constructor(uri: Windows$Windows$Foundation.Uri, relationship: string, title: string, mediaType: string, length: number): this;
constructor(): this;
length: number;
mediaType: string;
relationship: string;
resourceLanguage: string;
title: string;
uri: Windows$Windows$Foundation.Uri;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export interface ISyndicationLinkFactory {
createSyndicationLink(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Web.Syndication.SyndicationLink,
createSyndicationLink(
uri: Windows$Windows$Foundation.Uri,
relationship: string,
title: string,
mediaType: string,
length: number): Windows$Windows$Web.Syndication.SyndicationLink
} 
	declare export type ISyndicationPerson = {
email: string,
name: string,
uri: Windows$Windows$Foundation.Uri
} & undefined.ISyndicationNode

	declare export class SyndicationPerson mixins undefined.ISyndicationPerson, undefined.ISyndicationNode {
constructor(name: string): this;
constructor(name: string, email: string, uri: Windows$Windows$Foundation.Uri): this;
constructor(): this;
email: string;
name: string;
uri: Windows$Windows$Foundation.Uri;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export interface ISyndicationPersonFactory {
createSyndicationPerson(name: string): Windows$Windows$Web.Syndication.SyndicationPerson,
createSyndicationPerson(
name: string,
email: string,
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Web.Syndication.SyndicationPerson
} 
	declare export type ISyndicationCategory = {
label: string,
scheme: string,
term: string
} & undefined.ISyndicationNode

	declare export class SyndicationCategory mixins undefined.ISyndicationCategory, undefined.ISyndicationNode {
constructor(term: string): this;
constructor(term: string, scheme: string, label: string): this;
constructor(): this;
label: string;
scheme: string;
term: string;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export interface ISyndicationCategoryFactory {
createSyndicationCategory(term: string): Windows$Windows$Web.Syndication.SyndicationCategory,
createSyndicationCategory(
term: string,
scheme: string,
label: string): Windows$Windows$Web.Syndication.SyndicationCategory
} 
	declare export type ISyndicationItem = {
authors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>,
categories: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationCategory>,
commentsUri: Windows$Windows$Foundation.Uri,
content: Windows$Windows$Web.Syndication.SyndicationContent,
contributors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>,
eTag: string,
editMediaUri: Windows$Windows$Foundation.Uri,
editUri: Windows$Windows$Foundation.Uri,
id: string,
itemUri: Windows$Windows$Foundation.Uri,
lastUpdatedTime: Date,
links: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationLink>,
publishedDate: Date,
rights: Windows$Windows$Web.Syndication.ISyndicationText,
source: Windows$Windows$Web.Syndication.SyndicationFeed,
summary: Windows$Windows$Web.Syndication.ISyndicationText,
title: Windows$Windows$Web.Syndication.ISyndicationText,
load(item: string): void,
loadFromXml(itemDocument: Windows$Windows$Data.Xml.Dom.XmlDocument): void
} & undefined.ISyndicationNode

	declare export class SyndicationFeed mixins undefined.ISyndicationFeed, undefined.ISyndicationNode {
constructor(title: string, subtitle: string, uri: Windows$Windows$Foundation.Uri): this;
constructor(): this;
authors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>;
categories: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationCategory>;
contributors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>;
firstUri: Windows$Windows$Foundation.Uri;
generator: Windows$Windows$Web.Syndication.SyndicationGenerator;
iconUri: Windows$Windows$Foundation.Uri;
id: string;
imageUri: Windows$Windows$Foundation.Uri;
items: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationItem>;
lastUpdatedTime: Date;
lastUri: Windows$Windows$Foundation.Uri;
links: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationLink>;
nextUri: Windows$Windows$Foundation.Uri;
previousUri: Windows$Windows$Foundation.Uri;
rights: Windows$Windows$Web.Syndication.ISyndicationText;
sourceFormat: Windows$Windows$Web.Syndication.SyndicationFormat;
subtitle: Windows$Windows$Web.Syndication.ISyndicationText;
title: Windows$Windows$Web.Syndication.ISyndicationText;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
load(feed: string): void;
loadFromXml(feedDocument: Windows$Windows$Data.Xml.Dom.XmlDocument): void;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export class SyndicationItem mixins undefined.ISyndicationItem, undefined.ISyndicationNode {
constructor(title: string, content: Windows$Windows$Web.Syndication.SyndicationContent, uri: Windows$Windows$Foundation.Uri): this;
constructor(): this;
authors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>;
categories: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationCategory>;
commentsUri: Windows$Windows$Foundation.Uri;
content: Windows$Windows$Web.Syndication.SyndicationContent;
contributors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>;
eTag: string;
editMediaUri: Windows$Windows$Foundation.Uri;
editUri: Windows$Windows$Foundation.Uri;
id: string;
itemUri: Windows$Windows$Foundation.Uri;
lastUpdatedTime: Date;
links: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationLink>;
publishedDate: Date;
rights: Windows$Windows$Web.Syndication.ISyndicationText;
source: Windows$Windows$Web.Syndication.SyndicationFeed;
summary: Windows$Windows$Web.Syndication.ISyndicationText;
title: Windows$Windows$Web.Syndication.ISyndicationText;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
load(item: string): void;
loadFromXml(itemDocument: Windows$Windows$Data.Xml.Dom.XmlDocument): void;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export interface ISyndicationItemFactory {
createSyndicationItem(
title: string,
content: Windows$Windows$Web.Syndication.SyndicationContent,
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Web.Syndication.SyndicationItem
} 
	declare export type ISyndicationFeed = {
authors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>,
categories: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationCategory>,
contributors: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationPerson>,
firstUri: Windows$Windows$Foundation.Uri,
generator: Windows$Windows$Web.Syndication.SyndicationGenerator,
iconUri: Windows$Windows$Foundation.Uri,
id: string,
imageUri: Windows$Windows$Foundation.Uri,
items: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationItem>,
lastUpdatedTime: Date,
lastUri: Windows$Windows$Foundation.Uri,
links: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationLink>,
nextUri: Windows$Windows$Foundation.Uri,
previousUri: Windows$Windows$Foundation.Uri,
rights: Windows$Windows$Web.Syndication.ISyndicationText,
sourceFormat: Windows$Windows$Web.Syndication.SyndicationFormat,
subtitle: Windows$Windows$Web.Syndication.ISyndicationText,
title: Windows$Windows$Web.Syndication.ISyndicationText,
load(feed: string): void,
loadFromXml(feedDocument: Windows$Windows$Data.Xml.Dom.XmlDocument): void
} & undefined.ISyndicationNode

	declare export interface ISyndicationFeedFactory {
createSyndicationFeed(
title: string,
subtitle: string,
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Web.Syndication.SyndicationFeed
} 
	declare export interface ISyndicationClient {
bypassCacheOnRetrieve: boolean,
maxResponseBufferSize: number,
proxyCredential: Windows$Windows$Security.Credentials.PasswordCredential,
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential,
timeout: number,
setRequestHeader(name: string, value: string): void,
retrieveFeedAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationFeed, Windows$Windows$Web.Syndication.RetrievalProgress>
} 
	declare export class SyndicationClient mixins undefined.ISyndicationClient {
constructor(serverCredential: Windows$Windows$Security.Credentials.PasswordCredential): this;
constructor(): this;
bypassCacheOnRetrieve: boolean;
maxResponseBufferSize: number;
proxyCredential: Windows$Windows$Security.Credentials.PasswordCredential;
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential;
timeout: number;
setRequestHeader(name: string, value: string): void;
retrieveFeedAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationFeed, Windows$Windows$Web.Syndication.RetrievalProgress>
}
	declare export interface ISyndicationClientFactory {
createSyndicationClient(
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential): Windows$Windows$Web.Syndication.SyndicationClient
} 
	declare export interface ISyndicationErrorStatics {
getStatus(hresult: number): Windows$Windows$Web.Syndication.SyndicationErrorStatus
} 
	declare export class SyndicationError  {
static getStatus(hresult: number): Windows$Windows$Web.Syndication.SyndicationErrorStatus
}
    }

	declare module 'AtomPub' {
        declare export type IResourceCollection = {
accepts: Windows$Windows$Foundation.Collections.IVectorView<string>,
categories: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Web.Syndication.SyndicationCategory>,
title: Windows$Windows$Web.Syndication.ISyndicationText,
uri: Windows$Windows$Foundation.Uri
} & undefined.ISyndicationNode

	declare export class ResourceCollection mixins undefined.IResourceCollection, undefined.ISyndicationNode {
accepts: Windows$Windows$Foundation.Collections.IVectorView<string>;
categories: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Web.Syndication.SyndicationCategory>;
title: Windows$Windows$Web.Syndication.ISyndicationText;
uri: Windows$Windows$Foundation.Uri;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export type IWorkspace = {
collections: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Web.AtomPub.ResourceCollection>,
title: Windows$Windows$Web.Syndication.ISyndicationText
} & undefined.ISyndicationNode

	declare export class Workspace mixins undefined.IWorkspace, undefined.ISyndicationNode {
collections: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Web.AtomPub.ResourceCollection>;
title: Windows$Windows$Web.Syndication.ISyndicationText;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export type IServiceDocument = {
workspaces: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Web.AtomPub.Workspace>
} & undefined.ISyndicationNode

	declare export class ServiceDocument mixins undefined.IServiceDocument, undefined.ISyndicationNode {
workspaces: Windows$Windows$Foundation.Collections.IVectorView<Windows$Windows$Web.AtomPub.Workspace>;
attributeExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.SyndicationAttribute>;
baseUri: Windows$Windows$Foundation.Uri;
elementExtensions: Windows$Windows$Foundation.Collections.IVector<Windows$Windows$Web.Syndication.ISyndicationNode>;
language: string;
nodeName: string;
nodeNamespace: string;
nodeValue: string;
getXmlDocument(
format: Windows$Windows$Web.Syndication.SyndicationFormat): Windows$Windows$Data.Xml.Dom.XmlDocument
}
	declare export type IAtomPubClient = {
retrieveServiceDocumentAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.AtomPub.ServiceDocument, Windows$Windows$Web.Syndication.RetrievalProgress>,
retrieveMediaResourceAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Storage.Streams.IInputStream, Windows$Windows$Web.Syndication.RetrievalProgress>,
retrieveResourceAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationItem, Windows$Windows$Web.Syndication.RetrievalProgress>,
createResourceAsync(
uri: Windows$Windows$Foundation.Uri,
description: string,
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationItem, Windows$Windows$Web.Syndication.TransferProgress>,
createMediaResourceAsync(
uri: Windows$Windows$Foundation.Uri,
mediaType: string,
description: string,
mediaStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationItem, Windows$Windows$Web.Syndication.TransferProgress>,
updateMediaResourceAsync(
uri: Windows$Windows$Foundation.Uri,
mediaType: string,
mediaStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>,
updateResourceAsync(
uri: Windows$Windows$Foundation.Uri,
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>,
updateResourceItemAsync(
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>,
deleteResourceAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>,
deleteResourceItemAsync(
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>,
cancelAsyncOperations(): void
} & undefined.ISyndicationClient

	declare export class AtomPubClient mixins undefined.IAtomPubClient, undefined.ISyndicationClient {
constructor(serverCredential: Windows$Windows$Security.Credentials.PasswordCredential): this;
constructor(): this;
bypassCacheOnRetrieve: boolean;
maxResponseBufferSize: number;
proxyCredential: Windows$Windows$Security.Credentials.PasswordCredential;
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential;
timeout: number;
retrieveServiceDocumentAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.AtomPub.ServiceDocument, Windows$Windows$Web.Syndication.RetrievalProgress>;
retrieveMediaResourceAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Storage.Streams.IInputStream, Windows$Windows$Web.Syndication.RetrievalProgress>;
retrieveResourceAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationItem, Windows$Windows$Web.Syndication.RetrievalProgress>;
createResourceAsync(
uri: Windows$Windows$Foundation.Uri,
description: string,
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationItem, Windows$Windows$Web.Syndication.TransferProgress>;
createMediaResourceAsync(
uri: Windows$Windows$Foundation.Uri,
mediaType: string,
description: string,
mediaStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationItem, Windows$Windows$Web.Syndication.TransferProgress>;
updateMediaResourceAsync(
uri: Windows$Windows$Foundation.Uri,
mediaType: string,
mediaStream: Windows$Windows$Storage.Streams.IInputStream): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>;
updateResourceAsync(
uri: Windows$Windows$Foundation.Uri,
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>;
updateResourceItemAsync(
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>;
deleteResourceAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>;
deleteResourceItemAsync(
item: Windows$Windows$Web.Syndication.SyndicationItem): Windows$Windows$Foundation.IAsyncActionWithProgress<Windows$Windows$Web.Syndication.TransferProgress>;
cancelAsyncOperations(): void;
setRequestHeader(name: string, value: string): void;
retrieveFeedAsync(
uri: Windows$Windows$Foundation.Uri): Windows$Windows$Foundation.IAsyncOperationWithProgress<Windows$Windows$Web.Syndication.SyndicationFeed, Windows$Windows$Web.Syndication.RetrievalProgress>
}
	declare export interface IAtomPubClientFactory {
createAtomPubClientWithCredentials(
serverCredential: Windows$Windows$Security.Credentials.PasswordCredential): Windows$Windows$Web.AtomPub.AtomPubClient
} 
    }

    }


declare export interface Foundation$IPromise<T> {
then<U>(
success?: (value: T) => Foundation$IPromise<U>,
error?: (error: any) => Foundation$IPromise<U>,
progress?: (progress: any) => void): Foundation$IPromise<U>,
then<U>(
success?: (value: T) => Foundation$IPromise<U>,
error?: (error: any) => U,
progress?: (progress: any) => void): Foundation$IPromise<U>,
then<U>(
success?: (value: T) => U,
error?: (error: any) => Foundation$IPromise<U>,
progress?: (progress: any) => void): Foundation$IPromise<U>,
then<U>(
success?: (value: T) => U,
error?: (error: any) => U,
progress?: (progress: any) => void): Foundation$IPromise<U>,
done<U>(
success?: (value: T) => any,
error?: (error: any) => any,
progress?: (progress: any) => void): void,
cancel(): void,
onerror?: (eventInfo: CustomEvent) => void,
addEventListener?: (type: string, listener: Function, capture?: boolean) => void,
dispatchEvent?: (type: string, details: any) => boolean,
removeEventListener?: (eventType: string, listener: Function, capture?: boolean) => void
} 

declare export class ViewManagement$ApplicationViewTitleBar  {

/**
 * Gets or sets the color of the title bar background.
 */
backgroundColor: Color;

/**
 * Gets or sets the background color of the title bar buttons.
 */
buttonBackgroundColor: Color;

/**
 * Gets or sets the foreground color of the title bar buttons.
 */
buttonForegroundColor: Color;

/**
 * Gets or sets the background color of a title bar button when the pointer is over it.
 */
buttonHoverBackgroundColor: Color;

/**
 * Gets or sets the foreground color of a title bar button when the pointer is over it.
 */
buttonHoverForegroundColor: Color;

/**
 * Gets or sets the background color of a title bar button when it's inactive.
 */
buttonInactiveBackgroundColor: Color;

/**
 * Gets or sets the foreground color of a title bar button when it's inactive.
 */
buttonInactiveForegroundColor: Color;

/**
 * Gets or sets the background color of a title bar button when it's pressed.
 */
buttonPressedBackgroundColor: Color;

/**
 * Gets or sets the foreground color of a title bar button when it's pressed.
 */
buttonPressedForegroundColor: Color;

/**
 * Gets or sets the color of the title bar foreground.
 */
foregroundColor: Color;

/**
 * Gets or sets the color of the title bar background when it's inactive.
 */
inactiveBackgroundColor: Color;

/**
 * Gets or sets the color of the title bar foreground when it's inactive.
 */
inactiveForegroundColor: Color
}
    }

declare module "showdown" {
  declare export default typeof Showdown;

  declare var npm$namespace$Showdown: {
    setOption: typeof Showdown$setOption,
    getOption: typeof Showdown$getOption,
    getOptions: typeof Showdown$getOptions,
    resetOptions: typeof Showdown$resetOptions,
    getDefaultOptions: typeof Showdown$getDefaultOptions,
    extension: typeof Showdown$extension,
    resetExtensions: typeof Showdown$resetExtensions,
    getAllExtensions: typeof Showdown$getAllExtensions,
    removeExtension: typeof Showdown$removeExtension,
    setFlavor: typeof Showdown$setFlavor,
    Converter: typeof Showdown$Converter,
    helper: typeof Showdown$helper,
    extensions: typeof Showdown$extensions
  };
  declare interface Showdown$Extension {
    /**
     * Property defines the nature of said sub-extensions and can assume 2 values:
     *
     * * `lang` - Language extensions add new markdown syntax to showdown.
     * * `output` - Output extensions (or modifiers) alter the HTML output generated by showdown
     */
    type: string;
  }

  /**
   * Regex/replace style extensions are very similar to javascript's string.replace function.
   * Two properties are given, `regex` and `replace`.
   */
  declare type Showdown$RegexReplaceExtension = {
    /**
     * Should be either a string or a RegExp object.
     *
     * Keep in mind that, if a string is used, it will automatically be given a g modifier,
     * that is, it is assumed to be a global replacement.
     */
    regex?: string | RegExp,

    /**
     * Can be either a string or a function. If replace is a string,
     * it can use the $1 syntax for group substitution,
     * exactly as if it were making use of string.replace (internally it does this actually).
     */
    replace?: any
  } & Extension;

  /**
   * If you'd just like to do everything yourself,you can specify a filter property.
   * The filter property should be a function that acts as a callback.
   */
  declare type Showdown$FilterExtension = {
    filter?: (
      text: string,
      converter: Showdown$Converter,
      options?: Showdown$ConverterOptions
    ) => string
  } & Extension;

  /**
   * Defines a plugin/extension
   * Each single extension can be one of two types:
   *
   * + Language Extension -- Language extensions are ones that that add new markdown syntax to showdown. For example, say you wanted ^^youtube http://www.youtube.com/watch?v=oHg5SJYRHA0 to automatically render as an embedded YouTube video, that would be a language extension.
   * + Output Modifiers -- After showdown has run, and generated HTML, an output modifier would change that HTML. For example, say you wanted to change <div class="header"> to be <header>, that would be an output modifier.
   *
   * Each extension can provide two combinations of interfaces for showdown.
   */
  declare type Showdown$ShowdownExtension = {} & RegexReplaceExtension &
    FilterExtension;

  declare interface Showdown$ConverterExtensions {
    language: Showdown$ShowdownExtension[];
    output: Showdown$ShowdownExtension[];
  }

  declare interface Showdown$Metadata {
    [meta: string]: string;
  }

  declare interface Showdown$ShowdownOptions {
    /**
     * Omit the trailing newline in a code block. Ex:
     *
     * This:
     *    <code><pre>var foo = 'bar';
     *    </pre></code>
     *
     * Becomes this:
     *    <code><pre>var foo = 'bar';</pre></code>
     * @default false
     */
    omitExtraWLInCodeBlocks?: boolean;

    /**
     * Disable the automatic generation of header ids. Setting to true overrides <strong>prefixHeaderId</strong>.
     * @default false
     */
    noHeaderId?: boolean;

    /**
     * Use text in curly braces as header id.
     * @default false
     */
    customizedHeaderId?: boolean;

    /**
     * Generate header ids compatible with github style (spaces are replaced
     * with dashes and a bunch of non alphanumeric chars are removed).
     * @default false
     */
    ghCompatibleHeaderId?: boolean;

    /**
     * Add a prefix to the generated header ids.
     * Passing a string will prefix that string to the header id.
     * Setting to true will add a generic 'section' prefix.
     * @default false
     */
    prefixHeaderId?: string | boolean;

    /**
     * Enable support for setting image dimensions from within markdown syntax.
     * Examples:
     *
     *    ![foo](foo.jpg =100x80)     simple, assumes units are in px
     *    ![bar](bar.jpg =100x*)      sets the height to "auto"
     *    ![baz](baz.jpg =80%x5em)  Image with width of 80% and height of 5em
     * @default false
     */
    parseImgDimensions?: boolean;

    /**
     * Set the header starting level. For instance, setting this to 3 means that
     *
     *    # foo
     *
     * will be parsed as
     *
     *    <h3>foo</h3>
     * @default 1
     */
    headerLevelStart?: number;

    /**
     * Turning this option on will enable automatic linking to urls.
     * @default false
     */
    simplifiedAutoLink?: boolean;

    /**
     * This option excludes trailing punctuation from autolinking urls.
     * Punctuation excluded: . ! ? ( ). Only applies if simplifiedAutoLink option is set to true.
     * @default false
     */
    excludeTrailingPunctuationFromURLs?: boolean;

    /**
     * Turning this on will stop showdown from interpreting underscores in the middle of
     * words as <em> and <strong> and instead treat them as literal underscores.
     *
     * Example:
     *
     *    some text with__underscores__in middle
     *
     * will be parsed as
     *
     *    <p>some text with__underscores__in middle</p>
     * @default false
     */
    literalMidWordUnderscores?: boolean;

    /**
     * Enable support for strikethrough syntax.
     * `~~strikethrough~~` as `<del>strikethrough</del>`.
     * @default false
     */
    strikethrough?: boolean;

    /**
     * Enable support for tables syntax. Example:
     *
     *    | h1    |    h2   |      h3 |
     *    |:------|:-------:|--------:|
     *    | 100   | [a][1]  | ![b][2] |
     *    | *foo* | **bar** | ~~baz~~ |
     *
     * See the wiki for more info
     * @default false
     */
    tables?: boolean;

    /**
     * If enabled adds an id property to table headers tags.
     * @default false
     */
    tablesHeaderId?: boolean;

    /**
     * Enable support for GFM code block style.
     * @default true
     */
    ghCodeBlocks?: boolean;

    /**
     * Enable support for GFM takslists. Example:
     *
     *    - [x] This task is done
     *    - [ ] This is still pending
     * @default false
     */
    tasklists?: boolean;

    /**
     * Prevents weird effects in live previews due to incomplete input.
     * @default false
     */
    smoothLivePreview?: boolean;

    /**
     * Tries to smartly fix indentation problems related to es6 template
     * strings in the midst of indented code.
     * @default false
     */
    smartIndentationFix?: boolean;

    /**
     * Disables the requirement of indenting sublists by 4 spaces for them to be nested,
     * effectively reverting to the old behavior where 2 or 3 spaces were enough.
     * @default false
     */
    disableForced4SpacesIndentedSublists?: boolean;

    /**
     * Parses line breaks as like GitHub does, without needing 2 spaces at the end of the line.
     * @default false
     */
    simpleLineBreaks?: boolean;

    /**
     * Makes adding a space between # and the header text mandatory.
     * @default false
     */
    requireSpaceBeforeHeadingText?: boolean;

    /**
     * Enables github @mentions, which link to the username mentioned
     * @default false
     */
    ghMentions?: boolean;

    /**
     * Changes the link generated by @mentions. Showdown will replace {u}
     * with the username. Only applies if ghMentions option is enabled.
     * Example: @tivie with ghMentionsOption set to //mysite.com/{u}/profile will
     * result in <a href="//mysite.com/tivie/profile">@tivie</a>
     * @default https://github.com/{u}
     */
    ghMentionsLink?: string;

    /**
     * Open all links in new windows (by adding the attribute target="_blank" to <a> tags).
     * @default false
     */
    openLinksInNewWindow?: boolean;

    /**
     * Support for HTML Tag escaping. ex: \<div>foo\</div>.
     * @default false
     */
    backslashEscapesHTMLTags?: boolean;

    /**
     * Enable emoji support. Ex: `this is a :smile: emoji.
     *          *
     *          * @default false
     *          *
     */
    emoji?: boolean;

    /**
     * Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled,
     * underscores no longer parses into `<em>` and `<strong>`
     * @default false
     */
    underline?: boolean;

    /**
     * Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags
     * @default false
     */
    completeHTMLDocument?: boolean;

    /**
     * Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags
     * @default false
     */
    metadata?: boolean;

    /**
     * Split adjacent blockquote blocks
     * @default false
     */
    splitAdjacentBlockquotes?: boolean;
  }

  declare type Showdown$ConverterOptions = {
    extensions?: string | string[]
  } & ShowdownOptions;

  declare interface Showdown$Converter {
    /**
     * @param text The input text (markdown)
     * @return The output HTML
     */
    makeHtml(text: string): string;

    /**
     * Converts an HTML string into a markdown string
     * @param src The input text (HTML)
     * @param HTMLParser A WHATWG DOM and HTML parser, such as JSDOM. If none is supplied, window.document will be used.
     * @returns The output markdown
     */
    makeMarkdown(src: string, HTMLParser?: HTMLDocument): string;

    /**
     * Setting a "local" option only affects the specified Converter object.
     * @param optionKey
     * @param value
     */
    setOption(optionKey: string, value: any): void;

    /**
     * Get the option of this Converter instance.
     * @param optionKey
     */
    getOption(optionKey: string): any;

    /**
     * Get the options of this Converter instance.
     */
    getOptions(): Showdown$ShowdownOptions;

    /**
     * Add extension to THIS converter.
     * @param extension
     * @param name
     */
    addExtension(extension: Showdown$ShowdownExtension, name: string): void;
    addExtension(extension: Showdown$ShowdownExtension[], name: string): void;

    /**
     * Use a global registered extension with THIS converter
     * @param extensionName Name of the previously registered extension.
     */
    useExtension(extensionName: string): void;

    /**
     * Get all extensions.
     * @return all extensions.
     */
    getAllExtensions(): Showdown$ConverterExtensions;

    /**
     * Remove an extension from THIS converter.
     *
     * Note: This is a costly operation. It's better to initialize a new converter
     * and specify the extensions you wish to use.
     * @param extensions
     */
    removeExtension(
      extensions: Showdown$ShowdownExtension[] | Showdown$ShowdownExtension
    ): void;

    /**
     * Set a "local" flavor for THIS Converter instance
     * @param flavor name
     */
    setFlavor(
      name: "github" | "original" | "ghost" | "vanilla" | "allOn"
    ): void;

    /**
     * Get the metadata of the previously parsed document
     * @param raw
     * @returns {string | {}}
     */
    getMetadata(raw?: boolean): string | Showdown$Metadata;

    /**
     * Get the metadata format of the previously parsed document
     * @returns {string}
     */
    getMetadataFormat(): string;
  }

  declare interface Showdown$ConverterStatic {
    /**
     * @constructor
     * @param converterOptions Configuration object, describes which extensions to apply
     */
    new(converterOptions?: Showdown$ConverterOptions): Showdown$Converter;
  }

  /**
   * Helper Interface
   */
  declare interface Showdown$Helper {
    replaceRecursiveRegExp(...args: any[]): string;
  }

  /**
   * Constructor function for a Converter
   */
  declare var Showdown$Converter: Showdown$ConverterStatic;

  /**
   * Showdown helper
   */
  declare var Showdown$helper: Showdown$Helper;

  /**
   * Setting a "global" option affects all instances of showdown
   * @param optionKey
   * @param value
   */
  declare function Showdown$setOption(optionKey: string, value: any): void;

  /**
   * Retrieve previous set global option.
   * @param optionKey
   */
  declare function Showdown$getOption(optionKey: string): any;

  /**
   * Retrieve previous set global options.
   */
  declare function Showdown$getOptions(): Showdown$ShowdownOptions;

  /**
   * Reset options.
   */
  declare function Showdown$resetOptions(): void;

  /**
   * Retrieve the default options.
   */
  declare function Showdown$getDefaultOptions(): Showdown$ShowdownOptions;

  /**
   * Registered extensions
   * @prarm name
   * @param extenstion
   */
  declare function Showdown$extension(
    name: string,
    extension:
      | (() => Showdown$ShowdownExtension)
      | (() => Showdown$ShowdownExtension[])
      | Showdown$ShowdownExtension
  ): void;

  /**
   * @return The extensions array.
   */
  declare function Showdown$getOption(optionKey: string): any;

  declare var Showdown$extensions: {
    [name: string]: Showdown$ShowdownExtension
  };

  /**
   * Retrieve previous set global options.
   */
  declare function Showdown$getOptions(): Showdown$ShowdownOptions;

  /**
   * Retrieve the default options.
   */
  declare function Showdown$getDefaultOptions(): Showdown$ShowdownOptions;

  /**
   * @param obj An array of items
   * @param extenstion
   */
  declare function Showdown$extension(
    name: string,
    extension:
      | (() => Showdown$ShowdownExtension)
      | (() => Showdown$ShowdownExtension[])
      | Showdown$ShowdownExtension
  ): void;

  /**
   * Get an extension.
   * @param name
   * @return The extensions array.
   */
  declare function Showdown$resetExtensions(): void;

  /**
   * @return all extensions.
   */
  declare function Showdown$getAllExtensions(): {
    [name: string]: Showdown$ShowdownExtension[]
  };

  /**
   * Remove an extension.
   * @param name
   */
  declare function Showdown$removeExtension(name: string): void;

  /**
   * Reset extensions.
   */
  declare function Showdown$resetExtensions(): void;

  /**
   * Setting a "global" flavor affects all instances of showdown
   * @param name
   */
  declare function Showdown$setFlavor(
    name: "github" | "original" | "ghost" | "vanilla" | "allOn"
  ): void;
}

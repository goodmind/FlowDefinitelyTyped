declare module "cytoscape" {
  declare export default typeof cytoscape;

  declare function cytoscape(
    options?: cytoscape$CytoscapeOptions
  ): cytoscape$Core;

  declare function cytoscape(
    extensionName: string,
    foo: string,
    bar: any
  ): cytoscape$Core;

  declare var npm$namespace$cytoscape: {
    use: typeof cytoscape$use
  };
  declare interface cytoscape$Position {
    x: number;
    y: number;
  }

  declare type cytoscape$CssStyleDeclaration = any;

  declare interface cytoscape$ElementDefinition {
    group?: cytoscape$ElementGroup;
    data: cytoscape$NodeDataDefinition | cytoscape$EdgeDataDefinition;

    /**
     * Scratchpad data (usually temp or nonserialisable data)
     */
    scatch?: cytoscape$Scratchpad;

    /**
     * The model position of the node (optional on init, mandatory after)
     */
    position?: cytoscape$Position;

    /**
     * can alternatively specify position in rendered on-screen pixels
     */
    renderedPosition?: cytoscape$Position;

    /**
     * Whether the element is selected (default false)
     */
    selected?: boolean;

    /**
     * Whether the selection state is mutable (default true)
     */
    selectable?: boolean;

    /**
     * When locked a node's position is immutable (default false)
     */
    locked?: boolean;

    /**
     * Wether the node can be grabbed and moved by the user
     */
    grabbable?: boolean;

    /**
     * a space separated list of class names that the element has
     */
    classes?: string;

    /**
     * CssStyleDeclaration;
     */
    style?: cytoscape$CssStyleDeclaration;

    /**
     * you should only use `style`/`css` for very special cases; use classes instead
     */
    css?: Css$Node | Css$Edge;
  }

  declare interface cytoscape$ElementDataDefinition {
    /**
     * elided id => autogenerated id
     */
    id?: string;
    position?: cytoscape$Position;
  }

  declare type cytoscape$EdgeDefinition = {
    data: cytoscape$EdgeDataDefinition
  } & ElementDefinition;

  declare type cytoscape$EdgeDataDefinition = {
    id?: string,

    /**
     * the source node id (edge comes from this node)
     */
    source: string,

    /**
     * the target node id (edge goes to this node)
     */
    target: string,
    [key: string]: any
  } & ElementDataDefinition;

  declare type cytoscape$NodeDefinition = {
    data: cytoscape$NodeDataDefinition
  } & ElementDefinition;

  declare type cytoscape$NodeDataDefinition = {
    id?: string,
    parent?: string,
    [key: string]: any
  } & ElementDataDefinition;

  declare interface cytoscape$CytoscapeOptions {
    /**
     * A HTML DOM element in which the graph should be rendered.
     * This is optional if Cytoscape.js is run headlessly or if you initialise using jQuery (in which case your jQuery object already has an associated DOM element).
     *
     * The default is undefined.
     */
    container?: HTMLElement | null;

    /**
     * An array of [[Elements]] specified as plain objects. For convenience, this option can alternatively be specified as a promise that resolves to the elements JSON.
     */
    elements?:
      | cytoscape$ElementsDefinition
      | cytoscape$ElementDefinition[]
      | Promise<cytoscape$ElementsDefinition>
      | Promise<cytoscape$ElementDefinition[]>;

    /**
     * The [[Stylesheet]] used to style the graph. For convenience, this option can alternatively be specified as a promise that resolves to the stylesheet.
     */
    style?: cytoscape$Stylesheet[] | Promise<cytoscape$Stylesheet[]>;

    /**
     * A plain object that specifies layout options.
     * Which layout is initially run is specified by the name field.
     * Refer to a layout's documentation for the options it supports.
     * If you want to specify your node positions yourself in your elements JSON,
     * you can use the preset layout — by default it does not set any positions,
     * leaving your nodes in their current positions
     * (e.g. specified in options.elements at initialisation time)
     */
    layout?: cytoscape$LayoutOptions;

    /**
     * The initial zoom level of the graph.
     * Make sure to disable viewport manipulation options, such as fit, in your layout so that it is not overridden when the layout is applied.
     * You can set options.minZoom and options.maxZoom to set restrictions on the zoom level.
     *
     * The default value is 1.
     */
    zoom?: number;

    /**
     * The initial panning position of the graph. Make sure to disable viewport manipulation options, such as fit,
     * in your layout so that it is not overridden when the layout is applied.
     */
    pan?: cytoscape$Position;

    /**
     * A minimum bound on the zoom level of the graph. The viewport can not be scaled smaller than this zoom level.
     *
     * The default value is 1e-50.
     */
    minZoom?: number;

    /**
     * A maximum bound on the zoom level of the graph. The viewport can not be scaled larger than this zoom level.
     *
     * The default value is 1e50.
     */
    maxZoom?: number;

    /**
     * Whether zooming the graph is enabled, both by user events and programmatically.
     *
     * The default value is true.
     */
    zoomingEnabled?: boolean;

    /**
     * Whether user events (e.g. mouse wheel, pinch-to-zoom) are allowed to zoom the graph. Programmatic changes to zoom are unaffected by this option.
     *
     * The default value is true.
     */
    userZoomingEnabled?: boolean;

    /**
     * Whether panning the graph is enabled, both by user events and programmatically.
     *
     * The default value is true.
     */
    panningEnabled?: boolean;

    /**
     * Whether user events (e.g. dragging the graph background) are allowed to pan the graph. Programmatic changes to pan are unaffected by this option.
     *
     * The default value is true.
     */
    userPanningEnabled?: boolean;

    /**
     * Whether box selection (i.e. drag a box overlay around, and release it to select) is enabled. If enabled, the user must taphold to pan the graph.
     *
     * The default value is false.
     */
    boxSelectionEnabled?: boolean;

    /**
     * A string indicating the selection behaviour from user input.
     * By default, this is set automatically for you based on the type of input device detected.
     * On touch devices, 'additive' is default — a new selection made by the user adds to the set of currenly selected elements.
     * On mouse-input devices, 'single' is default — a new selection made by the user becomes the entire set of currently selected elements (i.e. the previous elements are unselected).
     *
     * The default value is (isTouchDevice ? 'additive' : 'single').
     */
    selectionType?: cytoscape$SelectionType;

    /**
     * A nonnegative integer that indicates the maximum allowable distance that a user may move during a tap gesture,
     * on touch devices and desktop devices respectively.
     *
     * This makes tapping easier for users.
     * These values have sane defaults, so it is not advised to change these options unless you have very good reason for doing so.
     * Larger values will almost certainly have undesirable consequences.
     *
     * The default value is is 8.
     */
    touchTapThreshold?: number;

    /**
     * A nonnegative integer that indicates the maximum allowable distance that a user may move during a tap gesture,
     * on touch devices and desktop devices respectively.
     *
     * This makes tapping easier for users.
     * These values have sane defaults,
     * so it is not advised to change these options unless you have very good reason for doing so.
     * Larger values will almost certainly have undesirable consequences.
     *
     * The default value is 4.
     */
    desktopTapThreshold?: number;

    /**
     * Whether nodes should be locked (not draggable at all) by default (if true, overrides individual node state).
     *
     * The default value is false.
     */
    autolock?: boolean;

    /**
     * Whether nodes should be ungrabified (not grabbable by user) by default (if true, overrides individual node state).
     *
     * The default value is false.
     */
    autoungrabify?: boolean;

    /**
     * Whether nodes should be unselectified (immutable selection state) by default (if true, overrides individual element state).
     *
     * The default value is false.
     */
    autounselectify?: boolean;

    /**
     * A convenience option that initialises the Core to run headlessly.
     * You do not need to set this in environments that are implicitly headless (e.g. Node.js).
     * However, it is handy to set headless: true if you want a headless Core in a browser.
     *
     * The default value is false.
     */
    headless?: boolean;

    /**
     * A boolean that indicates whether styling should be used.
     * For headless (i.e. outside the browser) environments,
     * display is not necessary and so neither is styling necessary — thereby speeding up your code.
     * You can manually enable styling in headless environments if you require it for a special case.
     * Note that it does not make sense to disable style if you plan on rendering the graph.
     *
     * The default value is true.
     */
    styleEnabled?: boolean;

    /**
     * When set to true, the renderer does not render edges while the viewport is being manipulated.
     * This makes panning, zooming, dragging, et cetera more responsive for large graphs.
     *
     * The default value is false.
     */
    hideEdgesOnViewport?: boolean;

    /**
     * when set to true, the renderer does not render labels while the viewport is being manipulated.
     * This makes panning, zooming, dragging, et cetera more responsive for large graphs.
     *
     * The default value is false.
     */
    hideLabelsOnViewport?: boolean;

    /**
     * When set to true, the renderer uses a texture (if supported) during panning and zooming instead of drawing the elements,
     * making large graphs more responsive.
     *
     * The default value is false.
     */
    textureOnViewport?: boolean;

    /**
     * When set to true, the renderer will use a motion blur effect to make the transition between frames seem smoother.
     * This can significantly increase the perceived performance for a large graphs.
     *
     * The default value is false.
     */
    motionBlur?: boolean;

    /**
     * When motionBlur: true, this value controls the opacity of motion blur frames.
     * Higher values make the motion blur effect more pronounced.
     *
     * The default value is 0.2.
     */
    motionBlurOpacity?: number;

    /**
     * Changes the scroll wheel sensitivity when zooming. This is a multiplicative modifier.
     * So, a value between 0 and 1 reduces the sensitivity (zooms slower), and a value greater than 1 increases the sensitivity (zooms faster).
     *
     * The default value is 1.
     */
    wheelSensitivity?: number;

    /**
     * Overrides the screen pixel ratio with a manually set value (1.0 or 0.666 recommended, if set).
     * This can be used to increase performance on high density displays by reducing the effective area that needs to be rendered.
     * If you want to use the hardware's actual pixel ratio at the expense of performance, you can set pixelRatio: 'auto'.
     *
     * The default value is 1.
     */
    pixelRatio?: number | "auto";
  }

  /**
   * cy   --> Cy.Core
   *   The core object is your interface to a graph.
   *
   * It is your entry point to Cytoscape.js:
   * All of the library’s features are accessed through this object.
   * http://js.cytoscape.org/#core
   */
  declare type cytoscape$Core = {
    /**
     * Indicator:
     * The colour of the indicator shown when the background is grabbed by the user.
     */
    "active-bg-color": Css$Colour,

    /**
     * The opacity of the active background indicator.
     */
    "active-bg-opacity": number,

    /**
     * The size of the active background indicator.
     */
    "active-bg-size": number,

    /**
     * Selection box:
     * The background colour of the selection box used for drag selection.
     */
    "selection-box-color": Css$Colour,

    /**
     * The colour of the border on the selection box.
     */
    "selection-box-border-color": Css$Colour,

    /**
     * The size of the border on the selection box.
     */
    "selection-box-border-width": number,

    /**
     * The opacity of the selection box.
     */
    "selection-box-opacity": number,

    /**
     * Texture during viewport gestures:
     * The colour of the area outside the viewport texture when initOptions.textureOnViewport === true.
     */
    "outside-texture-bg-color": Css$Colour,

    /**
     * The opacity of the area outside the viewport texture.
     */
    "outside-texture-bg-opacity": number
  } & CoreGraphManipulation &
    CoreGraphManipulationExt &
    CoreEvents &
    CoreViewportManipulation &
    CoreAnimation &
    CoreLayout &
    CoreStyle &
    CoreExport;

  /**
   * These are the principle functions used to interact with the graph model.
   *
   * http://js.cytoscape.org/#core/graph-manipulation
   */
  declare interface cytoscape$CoreGraphManipulation {
    /**
     * Add elements to the graph and return them.
     */
    add(
      eles:
        | cytoscape$ElementDefinition
        | cytoscape$ElementDefinition[]
        | cytoscape$CollectionArgument
    ): cytoscape$CollectionReturnValue;

    /**
     * Remove elements in collecion or match the selector from the graph and return them.
     */
    remove(
      eles: cytoscape$CollectionArgument | cytoscape$Selector
    ): cytoscape$CollectionReturnValue;

    /**
     * Get a collection from elements in the graph matching the specified selector or from an array of elements.
     * If no parameter specified, an empty collection will be returned
     */
    collection(
      eles?: cytoscape$Selector | cytoscape$CollectionArgument[]
    ): cytoscape$CollectionReturnValue;

    /**
     * Get an element from its ID in a very performant way.
     * http://js.cytoscape.org/#cy.getElementById
     */
    getElementById(id: string): cytoscape$CollectionReturnValue;

    /**
     * Get an element from its ID in a very performant way.
     * http://js.cytoscape.org/#cy.getElementById
     */
    $id(id: string): cytoscape$CollectionReturnValue;

    /**
     * Get elements in the graph matching the specified selector.
     * http://js.cytoscape.org/#cy.$
     */
    $(selector: cytoscape$Selector): cytoscape$CollectionReturnValue;

    /**
     * Get elements in the graph matching the specified selector.
     * http://js.cytoscape.org/#cy.$
     */
    elements(selector?: cytoscape$Selector): cytoscape$CollectionReturnValue;

    /**
     * Get nodes in the graph matching the specified selector.
     */
    nodes(selector?: cytoscape$Selector): cytoscape$NodeCollection;

    /**
     * Get edges in the graph matching the specified selector.
     */
    edges(selector?: cytoscape$Selector): cytoscape$EdgeCollection;

    /**
     * Get elements in the graph matching the specified selector or filter function.
     */
    filter(
      selector:
        | cytoscape$Selector
        | ((
            ele: cytoscape$Singular,
            i: number,
            eles: cytoscape$CollectionArgument
          ) => boolean)
    ): cytoscape$CollectionReturnValue;

    /**
     * Allow for manipulation of elements without triggering multiple style calculations or multiple redraws.
     * http://js.cytoscape.org/#cy.batch
     *   A callback within which you can make batch updates to elements.
     */
    batch(callback: () => void): void;

    /**
     * Allow for manipulation of elements without triggering multiple style calculations or multiple redraws.
     * http://js.cytoscape.org/#cy.batch
     *
     * Starts batching manually (useful for asynchronous cases).
     */
    startBatch(): void;

    /**
     * Allow for manipulation of elements without triggering multiple style calculations or multiple redraws.
     * http://js.cytoscape.org/#cy.batch
     *
     * Ends batching manually (useful for asynchronous cases).
     */
    endBatch(): void;

    /**
     * A convenience function to explicitly destroy the Core.
     * http://js.cytoscape.org/#cy.destroy
     */
    destroy(): void;
  }

  /**
   * http://js.cytoscape.org/#core/graph-manipulation
   * http://js.cytoscape.org/#extensions
   * These functions are intended for use in extensions.
   */
  declare interface cytoscape$CoreGraphManipulationExt {
    /**
     * Set the scratchpad at a particular namespace,
     * where temporary or non-JSON data can be stored.
     * App-level scratchpad data should use namespaces prefixed with underscore, like '_foo'.
     *
     * If no parameter provided, the entire scratchpad will be returned.
     * If only namespace provided, the scratchpad with the namespace will be returned.
     * @param namespace A namespace string.
     * @param value The value to set at the specified namespace.
     */
    scratch(namespace?: string): cytoscape$Scratchpad;
    scratch(namespace: string, value: any): this;

    /**
     * Remove scratchpad data. You should remove scratchpad data only at your own namespaces.
     * http://js.cytoscape.org/#cy.removeScratch
     * @param namespace A namespace string.
     */
    removeScratch(namespace: string): this;
  }

  /**
   * The principle events from the graph model.
   *   http://js.cytoscape.org/#core/events
   */
  declare interface cytoscape$CoreEvents {
    /**
     * Bind to events that occur in the graph.
     * @param events A space separated list of event names.
     * @param handler The handler function that is called when one of the specified events occurs.
     * @param selector A selector to specify elements for which the handler is triggered.
     * @param data A plain object which is passed to the handler in the event object argument.
     * @param eventsMap A map of event names to handler functions.
     */
    on(events: cytoscape$EventNames, handler: cytoscape$EventHandler): this;
    on(
      events: cytoscape$EventNames,
      selector: cytoscape$Selector,
      handler: cytoscape$EventHandler
    ): this;
    on(
      events: cytoscape$EventNames,
      selector: cytoscape$Selector,
      data: any,
      handler: cytoscape$EventHandler
    ): this;
    on(
      eventsMap: {
        [value: string]: cytoscape$EventHandler
      },
      selector?: cytoscape$Selector,
      data?: any
    ): this;
    bind(events: cytoscape$EventNames, handler: cytoscape$EventHandler): this;
    bind(
      events: cytoscape$EventNames,
      selector: cytoscape$Selector,
      handler: cytoscape$EventHandler
    ): this;
    bind(
      events: cytoscape$EventNames,
      selector: cytoscape$Selector,
      data: any,
      handler: cytoscape$EventHandler
    ): this;
    bind(
      eventsMap: {
        [value: string]: cytoscape$EventHandler
      },
      selector?: cytoscape$Selector,
      data?: any
    ): this;
    listen(events: cytoscape$EventNames, handler: cytoscape$EventHandler): this;
    listen(
      events: cytoscape$EventNames,
      selector: cytoscape$Selector,
      handler: cytoscape$EventHandler
    ): this;
    listen(
      events: cytoscape$EventNames,
      selector: cytoscape$Selector,
      data: any,
      handler: cytoscape$EventHandler
    ): this;
    listen(
      eventsMap: {
        [value: string]: cytoscape$EventHandler
      },
      selector?: cytoscape$Selector,
      data?: any
    ): this;
    addListener(
      events: cytoscape$EventNames,
      handler: cytoscape$EventHandler
    ): this;
    addListener(
      events: cytoscape$EventNames,
      selector: cytoscape$Selector,
      handler: cytoscape$EventHandler
    ): this;
    addListener(
      events: cytoscape$EventNames,
      selector: cytoscape$Selector,
      data: any,
      handler: cytoscape$EventHandler
    ): this;
    addListener(
      eventsMap: {
        [value: string]: cytoscape$EventHandler
      },
      selector?: cytoscape$Selector,
      data?: any
    ): this;

    /**
     * Get a promise that is resolved with the first
     * of any of the specified events triggered on the graph.
     * @param events A space separated list of event names.
     * @param selector [optional] A selector to specify elements for which the handler is triggered.
     */
    promiseOn(
      events: cytoscape$EventNames,
      selector?: cytoscape$Selector
    ): Promise<cytoscape$EventHandler>;
    pon(
      events: cytoscape$EventNames,
      selector?: cytoscape$Selector
    ): Promise<cytoscape$EventHandler>;

    /**
     * Bind to events that occur in the graph, and trigger the handler only once.
     * @param events A space separated list of event names.
     * @param handler The handler function that is called when one of the specified events occurs.
     */
    one(events: cytoscape$EventNames, handler: cytoscape$EventHandler): this;

    /**
     * Bind to events that occur in the graph, and trigger the handler only once.
     * @param events A space separated list of event names.
     * @param handler The handler function that is called when one of the specified events occurs.
     * @param selector A selector to specify elements for which the handler is triggered.
     */
    one(
      events: cytoscape$EventNames,
      selector: cytoscape$Selector,
      handler: cytoscape$EventHandler
    ): this;

    /**
     * Bind to events that occur in the graph, and trigger the handler only once.
     * @param events A space separated list of event names.
     * @param handler The handler function that is called when one of the specified events occurs.
     * @param selector A selector to specify elements for which the handler is triggered.
     * @param data A plain object which is passed to the handler in the event object argument.
     */
    one(
      events: cytoscape$EventNames,
      selector: cytoscape$Selector,
      data: any,
      handler: cytoscape$EventHandler
    ): this;

    /**
     * Bind to events that occur in the graph, and trigger the handler only once.
     * @param eventsMap A map of event names to handler functions.
     * @param selector A selector to specify elements for which the handler is triggered.
     * @param data A plain object which is passed to the handler in the event object argument.
     */
    one(
      eventsMap: {
        [value: string]: cytoscape$EventHandler
      },
      selector?: cytoscape$Selector,
      data?: any
    ): this;

    /**
     * Remove event handlers.
     *   http://js.cytoscape.org/#cy.off
     * @param events A space separated list of event names.
     * @param selector [optional] The same selector used to bind to the events.
     * @param handler [optional] A reference to the handler function to remove.
     * @param eventsMap A map of event names to handler functions to remove.
     */
    off(
      events: cytoscape$EventNames,
      selector?: cytoscape$Selector,
      handler?: cytoscape$EventHandler
    ): this;
    off(
      eventsMap: {
        [value: string]: cytoscape$EventHandler
      },
      selector?: cytoscape$Selector
    ): this;
    unbind(
      events: cytoscape$EventNames,
      selector?: cytoscape$Selector,
      handler?: cytoscape$EventHandler
    ): this;
    unbind(
      eventsMap: {
        [value: string]: cytoscape$EventHandler
      },
      selector?: cytoscape$Selector
    ): this;
    unlisten(
      events: cytoscape$EventNames,
      selector?: cytoscape$Selector,
      handler?: cytoscape$EventHandler
    ): this;
    unlisten(
      eventsMap: {
        [value: string]: cytoscape$EventHandler
      },
      selector?: cytoscape$Selector
    ): this;
    removeListener(
      events: cytoscape$EventNames,
      selector?: cytoscape$Selector,
      handler?: cytoscape$EventHandler
    ): this;
    removeListener(
      eventsMap: {
        [value: string]: cytoscape$EventHandler
      },
      selector?: cytoscape$Selector
    ): this;

    /**
     * Trigger one or more events.
     * @param events A space separated list of event names to trigger.
     * @param extraParams [optional] An array of additional parameters to pass to the handler.
     */
    trigger(events: cytoscape$EventNames, extraParams?: any[]): this;
    emit(events: cytoscape$EventNames, extraParams?: any[]): this;

    /**
     * Run a callback as soon as the graph becomes ready. If the graph is already ready, then the callback is called immediately.
     * @param fn The callback run as soon as the graph is ready, inside which this refers to the core (cy).
     */
    ready(fn: cytoscape$EventHandler): this;
  }

  declare interface cytoscape$ZoomOptionsModel {
    /**
     * The position about which to zoom.
     */
    position: cytoscape$Position;
  }

  declare interface cytoscape$ZoomOptionsRendered {
    /**
     * The rendered position about which to zoom.
     */
    renderedPosition: cytoscape$Position;
  }

  declare interface cytoscape$ZoomOptionsLevel {
    /**
     * The zoom level to set.
     */
    level: number;
  }

  declare type cytoscape$ZoomOptions = cytoscape$ZoomOptionsLevel &
    (cytoscape$ZoomOptionsModel | cytoscape$ZoomOptionsRendered);

  /**
   * http://js.cytoscape.org/#core/viewport-manipulation
   */
  declare interface cytoscape$CoreViewportManipulation {
    /**
     * Get the HTML DOM element in which the graph is visualised.
     * A null value is returned if the Core is headless.
     */
    container(): Element | null;

    /**
     * Pan the graph to the centre of a collection.
     * @param eles The collection to centre upon.
     */
    center(eles?: cytoscape$CollectionArgument): this;

    /**
     * Pan the graph to the centre of a collection.
     * @param eles The collection to centre upon.
     */
    centre(eles?: cytoscape$CollectionArgument): this;

    /**
     * Pan and zooms the graph to fit to a collection.
     * http://js.cytoscape.org/#cy.fit
     * @param eles [optional] The collection to fit to.
     * @param padding [optional] An amount of padding (in pixels) to have around the graph
     */
    fit(eles?: cytoscape$CollectionArgument, padding?: number): this;

    /**
     * Reset the graph to the default zoom level and panning position.
     * http://js.cytoscape.org/#cy.reset
     */
    reset(): this;

    /**
     * Get the panning position of the graph.
     * http://js.cytoscape.org/#cy.pan
     */
    pan(): cytoscape$Position;

    /**
     * Set the panning position of the graph.
     * http://js.cytoscape.org/#cy.pan
     * @param renderedPosition The rendered position to pan the graph to.
     */
    pan(renderedPosition?: cytoscape$Position): this;

    /**
     * Relatively pan the graph by a specified rendered position vector.
     * http://js.cytoscape.org/#cy.panBy
     * @param renderedPosition The rendered position vector to pan the graph by.
     */
    panBy(renderedPosition: cytoscape$Position): this;

    /**
     * Get whether panning is enabled.
     * If cy.boxSelectionEnabled() === true, then the user
     * must taphold to initiate panning.
     * http://js.cytoscape.org/#cy.panningEnabled
     */
    panningEnabled(): boolean;

    /**
     * Set whether panning is enabled. If cy.boxSelectionEnabled() === true, then the user must taphold to initiate panning.
     * http://js.cytoscape.org/#cy.panningEnabled
     * @param bool A truthy value enables panning; a falsey value disables it.
     */
    panningEnabled(bool: boolean): this;

    /**
     * Get whether panning by user events (e.g. dragging the graph background) is enabled. If cy.boxSelectionEnabled() === true, then the user must taphold to initiate panning.
     * http://js.cytoscape.org/#cy.userPanningEnabled
     */
    userPanningEnabled(): boolean;

    /**
     * Set whether panning by user events (e.g. dragging the graph background) is enabled. If cy.boxSelectionEnabled() === true, then the user must taphold to initiate panning.
     * http://js.cytoscape.org/#cy.userPanningEnabled
     * @param bool A truthy value enables user panning; a falsey value disables it.
     */
    userPanningEnabled(bool: boolean): this;

    /**
     * Get the zoom level.
     * http://js.cytoscape.org/#cy.zoom
     */
    zoom(): number;

    /**
     * Set the zoom level.
     * http://js.cytoscape.org/#cy.zoom
     * @param level The zoom level to set.
     * @param options The options for zooming.
     */
    zoom(level?: number | cytoscape$ZoomOptions): this;

    /**
     * Set or get whether zooming is enabled. Get if no parameter provided.
     * http://js.cytoscape.org/#cy.zoomingEnabled
     * @param bool A truthy value enables zooming; a falsey value disables it.
     */
    zoomingEnabled(bool?: boolean): this;

    /**
     * Get whether zooming by user events (e.g. mouse wheel, pinch-to-zoom)
     * is enabled.
     * http://js.cytoscape.org/#cy.userZoomingEnabled
     */
    userZoomingEnabled(): boolean;

    /**
     * Get or set whether zooming by user events get if no parameter provided
     * (e.g. mouse wheel, pinch-to-zoom) is enabled.
     * http://js.cytoscape.org/#cy.userZoomingEnabled
     * @param bool A truthy value enables user zooming; a falsey value disables it.
     */
    userZoomingEnabled(bool?: boolean): this;

    /**
     * Get the minimum zoom level.
     * http://js.cytoscape.org/#cy.minZoom
     */
    minZoom(): number;

    /**
     * Set the minimum zoom level.
     * http://js.cytoscape.org/#cy.minZoom
     * @param zoom The new minimum zoom level to use.
     */
    minZoom(zoom: number): this;

    /**
     * Get the maximum zoom level.
     * http://js.cytoscape.org/#cy.maxZoom
     */
    maxZoom(): number;

    /**
     * Set the maximum zoom level.
     * http://js.cytoscape.org/#cy.maxZoom
     * @param zoom The new maximum zoom level to use.
     */
    maxZoom(zoom: number): this;

    /**
     * Set the viewport state (pan & zoom) in one call.
     * http://js.cytoscape.org/#cy.viewport
     * @param zoom The zoom level to set.
     * @param pan The pan to set (a rendered position).
     */
    viewport(zoom: number, pan: cytoscape$Position): this;

    /**
     * Get whether box selection is enabled.
     * If enabled, the user must hold left-click to initiate panning.
     * http://js.cytoscape.org/#cy.boxSelectionEnabled
     */
    boxSelectionEnabled(): boolean;

    /**
     * Set whether box selection is enabled.
     * If enabled, the user must hold left-click to initiate panning.
     * http://js.cytoscape.org/#cy.boxSelectionEnabled
     * @param bool A truthy value enables box selection; a falsey value disables it.
     */
    boxSelectionEnabled(bool: boolean): this;

    /**
     * Get the on-screen width of the viewport in pixels.
     * http://js.cytoscape.org/#cy.width
     */
    width(): number;

    /**
     * Get the on-screen height of the viewport in pixels.
     * http://js.cytoscape.org/#cy.height
     */
    height(): number;

    /**
     * Get the extent of the viewport, a bounding box in model
     * coordinates that lets you know what model
     * positions are visible in the viewport.
     * http://js.cytoscape.org/#cy.extent
     */
    extent(): {
      x1: number,
      y1: number,
      x2: number,
      y2: number,
      w: number,
      h: number
    };

    /**
     * Get whether nodes are automatically locked
     * (i.e. if true, nodes are locked despite their individual state).
     * http://js.cytoscape.org/#cy.autolock
     */
    autolock(): boolean;

    /**
     * Set whether nodes are automatically locked
     * (i.e. if true, nodes are locked despite their individual state).
     * http://js.cytoscape.org/#cy.autolock
     * @param bool A truthy value enables autolocking; a falsey value disables it.
     */
    autolock(bool: boolean): this;

    /**
     * Get whether nodes are automatically ungrabified
     * (i.e. if true, nodes are ungrabbale despite their individual state).
     * http://js.cytoscape.org/#cy.autoungrabify
     */
    autoungrabify(): boolean;

    /**
     * Set whether nodes are automatically ungrabified
     * (i.e. if true, nodes are ungrabbale despite their individual state).
     * http://js.cytoscape.org/#cy.autoungrabify
     * @param bool A truthy value enables autolocking; a falsey value disables it.
     */
    autoungrabify(bool: boolean): this;

    /**
     * Get whether nodes are automatically unselectified
     * (i.e. if true, nodes are unselectable despite their individual state).
     * http://js.cytoscape.org/#cy.autounselectify
     */
    autounselectify(): boolean;

    /**
     * Set whether nodes are automatically unselectified
     * (i.e. if true, nodes are unselectable despite their individual state).
     * http://js.cytoscape.org/#cy.autounselectify
     * @param bool A truthy value enables autolocking; a falsey value disables it.
     */
    autounselectify(bool: boolean): this;

    /**
     * Force the renderer to redraw (i.e. draw a new frame).
     *
     * This function forces the renderer to draw a new frame.
     * It is useful for very specific edgecases, such as in certain UI plugins,
     * but it should not be needed for most developers.
     * http://js.cytoscape.org/#cy.forceRender
     */
    forceRender(): this;

    /**
     * Force the renderer to recalculate the viewport bounds.
     *
     * If your code resizes the graph's dimensions or position
     * (i.e. by changing the style of the HTML DOM element that holds the graph),
     * you will want to call cy.resize() to have the graph resize and redraw itself.
     *
     * Cytoscape.js can not automatically monitor the bounding box of the viewport,
     * as querying the DOM for those dimensions can be expensive.
     * Although cy.resize() is automatically called for you on the window's resize event,
     * there is no resize or style event for arbitrary DOM elements.
     * http://js.cytoscape.org/#cy.resize
     */
    resize(): this;
    invalidateDimensions(): this;
  }

  /**
   * http://js.cytoscape.org/#core/animation
   */
  declare interface cytoscape$AnimationFitOptions {
    eles: cytoscape$CollectionArgument | cytoscape$Selector;
    padding: number;
  }

  declare interface cytoscape$CenterOptions {
    eles: cytoscape$CollectionArgument | cytoscape$Selector;
  }

  declare interface cytoscape$AnimationOptions {
    /**
     * A zoom level to which the graph will be animated.
     */
    zoom?: cytoscape$ZoomOptions;

    /**
     * A panning position to which the graph will be animated.
     */
    pan?: cytoscape$Position;

    /**
     * A relative panning position to which the graph will be animated.
     */
    panBy?: cytoscape$Position;

    /**
     * An object containing fitting options from which the graph will be animated.
     */
    fit?: cytoscape$AnimationFitOptions;

    /**
     * An object containing centring options from which the graph will be animated.
     */
    center?: cytoscape$CenterOptions;

    /**
     * easing - A transition-timing-function easing style string that shapes the animation progress curve.
     */
    easing?: Css$TransitionTimingFunction;

    /**
     * duration - The duration of the animation in milliseconds.
     */
    duration?: number;
  }

  declare type cytoscape$AnimateOptions = {
    /**
     * queue - A boolean indicating whether to queue the animation.
     */
    queue?: boolean,

    /**
     * complete - A function to call when the animation is done.
     */
    complete?: () => void,

    /**
     * step - A function to call each time the animation steps.
     */
    step?: () => void
  } & AnimationOptions;

  declare interface cytoscape$CoreAnimation {
    /**
     * Get whether the viewport is currently being animated.
     * http://js.cytoscape.org/#cy.animated
     */
    animated(): boolean;

    /**
     * Animate the viewport.
     * http://js.cytoscape.org/#cy.animate
     * @param anis An object containing the details of the animation.
     * @param options An object containing animation options.
     */
    animate(
      anis: cytoscape$AnimateOptions,
      options?: cytoscape$AnimateOptions
    ): cytoscape$Core;

    /**
     * Get an animation of the viewport.
     * http://js.cytoscape.org/#cy.animation
     */
    animation(
      options: cytoscape$AnimationOptions
    ): cytoscape$AnimationManipulation;

    /**
     * Add a delay between animations for the viewport.
     * @param duration How long the delay should be in milliseconds.
     * @param complete A function to call when the delay is complete.
     */
    delay(duration: number, complete?: () => void): cytoscape$Core;

    /**
     * Get a delay animation of the viewport.
     * http://js.cytoscape.org/#cy.delayAnimation
     */
    delayAnimation(duration: number): cytoscape$AnimationManipulation;

    /**
     * Stop all viewport animations that are currently running.
     * http://js.cytoscape.org/#cy.stop
     * @param clearQueue A boolean, indicating whether the queue of animations should be emptied.
     * @param jumpToEnd A boolean, indicating whether the currently-running animations should jump to their ends rather than just stopping midway.
     */
    stop(clearQueue?: boolean, jumpToEnd?: boolean): cytoscape$Core;

    /**
     * Remove all queued animations for the viewport.
     * http://js.cytoscape.org/#cy.clearQueue
     */
    clearQueue(): cytoscape$Core;
  }

  /**
   * http://js.cytoscape.org/#core/layout
   */
  declare interface cytoscape$CoreLayout {
    /**
     * Run a layout, which algorithmically positions the nodes in the graph.
     * For layouts included with Cytoscape.js, you can find their
     * options documented in the Layouts section.
     * For external layouts, please refer to their accompanying documentation.
     *
     * An analogue to run a layout on a subset of the graph exists as eles.layout().
     * http://js.cytoscape.org/#cy.layout
     */
    layout(layout: cytoscape$LayoutOptions): cytoscape$Layouts;

    /**
     * Get a new layout, which can be used to algorithmically
     * position the nodes in the graph.
     *
     * You must specify options.name with the name of the layout you wish to use.
     *
     * This function creates and returns a layout object.
     * You may want to keep a reference to the layout for more advanced usecases,
     * such as running multiple layouts simultaneously.
     * Note that you must call layout.run() in order for it to affect the graph.
     * An analogue to make a layout on a subset of the graph exists as eles.makeLayout().
     */
    makeLayout(options: cytoscape$LayoutOptions): cytoscape$Layouts;
    createLayout(options: cytoscape$LayoutOptions): cytoscape$Layouts;
  }

  /**
   * Get the entry point to modify the visual style of the graph after initialisation.
   * http://js.cytoscape.org/#core/style
   */
  declare type cytoscape$ElementStylesheetStyle = {
    json(): any
  } & StylesheetStyle;

  declare type cytoscape$ElementStylesheetCSS = {
    json(): any
  } & StylesheetCSS;

  declare interface cytoscape$CoreStyle {
    /**
     * Get the current style object.
     */
    style(): cytoscape$ElementStylesheetStyle | cytoscape$ElementStylesheetCSS;

    /**
     * Assign a new stylesheet to replace the existing one.
     */
    style(
      sheet: cytoscape$Stylesheet | cytoscape$Stylesheet[] | string
    ): cytoscape$Stylesheet;
  }

  /**
   * http://js.cytoscape.org/#cy.style
   */
  declare type cytoscape$Stylesheet =
    | cytoscape$StylesheetStyle
    | cytoscape$StylesheetCSS;

  declare interface cytoscape$StylesheetStyle {
    selector: string;
    style: Css$Node | Css$Edge;
  }

  /**
   * http://js.cytoscape.org/#cy.style
   */
  declare interface cytoscape$StylesheetCSS {
    selector: string;
    css: Css$Node | Css$Edge;
  }

  /**
   * http://js.cytoscape.org/#core/export
   */
  declare interface cytoscape$ExportOptions {
    /**
     * The background colour of the image (transparent by default).
     */
    bg?: string;

    /**
     * Whether to export the current viewport view (false, default) or the entire graph (true).
     */
    full?: boolean;

    /**
     * This value specifies a positive number that scales the size of the resultant image.
     */
    scale?: number;

    /**
     * Specifies the scale automatically in combination with maxHeight such that the resultant image is no wider than maxWidth.
     */
    maxWidth?: number;

    /**
     * Specifies the scale automatically in combination with maxWidth such that the resultant image is no taller than maxHeight.
     */
    maxHeight?: number;
  }

  declare type cytoscape$ExportStringOptions = {
    /**
     * output Whether the output should be 'base64uri' (default), 'base64', or 'blob'.
     */
    output?: "base64uri" | "base64"
  } & ExportOptions;

  declare type cytoscape$ExportBlobOptions = {
    /**
     * output Whether the output should be 'base64uri' (default), 'base64', or 'blob'.
     */
    output?: "blob"
  } & ExportOptions;

  declare type cytoscape$ExportJpgOptions = {
    /**
     * quality Specifies the quality of the image from 0
     * (low quality, low filesize) to 1 (high quality, high filesize).
     * If not set, the browser's default quality value is used.
     */
    quality?: number
  } & ExportOptions;

  declare type cytoscape$ExportJpgStringOptions = {} & ExportJpgOptions &
    ExportStringOptions;

  declare type cytoscape$ExportJpgBlobOptions = {} & ExportJpgOptions &
    ExportBlobOptions;

  declare interface cytoscape$CoreExport {
    /**
     * Export the current graph view as a PNG image in Base64 representation.
     */
    png(options?: cytoscape$ExportStringOptions): string;
    png(options?: cytoscape$ExportBlobOptions): Blob;

    /**
     * Export the current graph view as a JPG image in Base64 representation.
     */
    jpg(options?: cytoscape$ExportJpgStringOptions): string;
    jpg(options?: cytoscape$ExportJpgBlobOptions): Blob;

    /**
     * Export the current graph view as a JPG image in Base64 representation.
     */
    jpeg(options?: cytoscape$ExportJpgStringOptions): string;
    jpeg(options?: cytoscape$ExportJpgBlobOptions): Blob;

    /**
     * Export the graph as JSON, the same format used at initialisation.
     */
    json(): { [key: string]: any };
    json(json: { [key: string]: any }): this;
  }

  /**
   * eles --> Cy.Collection
   *   a collection of one or more elements (nodes and edges)
   *
   * The input can be any element (node and edge) collection.
   * http://js.cytoscape.org/#collection
   */
  declare type cytoscape$Collection<
    TOut = cytoscape$SingularElementReturnValue,
    TIn = cytoscape$SingularElementArgument
  > = {} & CollectionGraphManipulation &
    CollectionEvents &
    CollectionData &
    CollectionPosition &
    CollectionTraversing &
    CollectionLayout &
    CollectionSelection &
    CollectionStyle &
    CollectionAnimation &
    CollectionComparision &
    CollectionIteration<TIn, TOut> &
    CollectionBuildingFiltering<TIn, TOut> &
    CollectionAlgorithms;

  /**
   * ele  --> Cy.Singular
   * a collection of a single element (node or edge)
   * NB: every singular collection is a general collection too (but not vice versa)!
   */
  declare type cytoscape$Singular<
    TOut = cytoscape$SingularElementReturnValue,
    TIn = cytoscape$SingularElementArgument
  > = {} & Collection<TOut, TIn> &
    SingularGraphManipulation &
    SingularData &
    SingularPosition &
    SingularSelection &
    SingularStyle &
    SingularAnimation;

  declare interface cytoscape$ElementsDefinition {
    nodes: cytoscape$NodeDefinition[];
    edges: cytoscape$EdgeDefinition[];
  }

  declare type cytoscape$EventHandler = (event: cytoscape$EventObject) => void;

  /**
   * The output is a collection of node and edge elements OR single element.
   */
  declare type cytoscape$CollectionArgument =
    | cytoscape$Collection
    | cytoscape$EdgeCollection
    | cytoscape$NodeCollection
    | cytoscape$SingularElementArgument;

  declare type cytoscape$CollectionReturnValue = cytoscape$Collection &
    cytoscape$EdgeCollection &
    cytoscape$NodeCollection &
    cytoscape$SingularElementReturnValue;

  /**
   * edges -> Cy.EdgeCollection
   *   a collection of one or more edges
   *
   * The output is a collection of edge elements OR single edge.
   */
  declare type cytoscape$EdgeCollection = {} & Collection<
    cytoscape$EdgeSingular,
    cytoscape$EdgeSingular
  > &
    EdgeCollectionTraversing;

  /**
   * nodes -> Cy.NodeCollection
   * a collection of one or more nodes
   *
   * The output is a collection of node elements OR single node.
   */
  declare type cytoscape$NodeCollection = {} & Collection<
    cytoscape$NodeSingular,
    cytoscape$NodeSingular
  > &
    NodeCollectionMetadata &
    NodeCollectionPosition &
    NodeCollectionTraversing &
    NodeCollectionCompound;

  declare type cytoscape$SingularElementArgument =
    | cytoscape$EdgeSingular
    | cytoscape$NodeSingular;

  declare type cytoscape$SingularElementReturnValue = cytoscape$EdgeSingular &
    cytoscape$NodeSingular;

  /**
   * edge --> Cy.EdgeSingular
   * a collection of a single edge
   */
  declare type cytoscape$EdgeSingular = {} & Singular<
    cytoscape$EdgeSingular,
    cytoscape$EdgeSingular
  > &
    EdgeCollection &
    EdgeSingularData &
    EdgeSingularPoints &
    EdgeSingularTraversing;

  /**
   * node --> Cy.NodeSingular
   * a collection of a single node
   */
  declare type cytoscape$NodeSingular = {} & Singular<
    cytoscape$NodeSingular,
    cytoscape$NodeSingular
  > &
    NodeCollection &
    NodeSingularMetadata &
    NodeSingularPosition &
    NodeSingularCompound;

  /**
   * http://js.cytoscape.org/#collection/graph-manipulation
   */
  declare interface cytoscape$CollectionGraphManipulation {
    /**
     * Remove the elements from the graph.
     * http://js.cytoscape.org/#eles.remove
     */
    remove(): cytoscape$CollectionReturnValue;

    /**
     * Put removed elements back into the graph.
     * http://js.cytoscape.org/#eles.restore
     */
    restore(): cytoscape$CollectionReturnValue;

    /**
     * Get a new collection containing clones (i.e. copies) of the elements in the calling collection.
     * http://js.cytoscape.org/#eles.clone
     */
    clone(): cytoscape$CollectionReturnValue;

    /**
     * Get a new collection containing clones (i.e. copies) of the elements in the calling collection.
     * http://js.cytoscape.org/#eles.clone
     */
    copy(): cytoscape$CollectionReturnValue;

    /**
     * Effectively move edges to different nodes. The modified (actually new) elements are returned.
     * http://js.cytoscape.org/#eles.move
     */
    move(location: {
      source?: string,
      target?: string
    }): cytoscape$EdgeCollection;

    /**
     * Effectively move nodes to different parent node. The modified (actually new) elements are returned.
     * http://js.cytoscape.org/#eles.move
     */
    move(location: {
      parent: string
    }): cytoscape$NodeCollection;
  }

  /**
   * http://js.cytoscape.org/#collection/graph-manipulation
   */
  declare interface cytoscape$SingularGraphManipulation {
    /**
     * Get the core instance that owns the element.
     */
    cy(): cytoscape$Core;

    /**
     * Get whether the element has been removed from the graph.
     * http://js.cytoscape.org/#ele.removed
     */
    removed(): boolean;

    /**
     * Get whether the element is inside the graph (i.e. not removed).
     * http://js.cytoscape.org/#ele.inside
     */
    inside(): boolean;
  }

  /**
   * http://js.cytoscape.org/#collection/events
   */
  declare interface cytoscape$CollectionEvents {
    /**
     * http://js.cytoscape.org/#eles.on
     */
    on(
      events: cytoscape$EventNames,
      selector: string,
      data: any,
      handler: cytoscape$EventHandler
    ): this;
    on(
      events: cytoscape$EventNames,
      selector: string,
      handler: cytoscape$EventHandler
    ): this;
    on(events: cytoscape$EventNames, handler: cytoscape$EventHandler): this;
    bind(
      events: cytoscape$EventNames,
      selector: string,
      data: any,
      handler: cytoscape$EventHandler
    ): this;
    bind(
      events: cytoscape$EventNames,
      selector: string,
      handler: cytoscape$EventHandler
    ): this;
    bind(events: cytoscape$EventNames, handler: cytoscape$EventHandler): this;
    listen(
      events: cytoscape$EventNames,
      selector: string,
      data: any,
      handler: cytoscape$EventHandler
    ): this;
    listen(
      events: cytoscape$EventNames,
      selector: string,
      handler: cytoscape$EventHandler
    ): this;
    listen(events: cytoscape$EventNames, handler: cytoscape$EventHandler): this;
    addListener(
      events: cytoscape$EventNames,
      selector: string,
      data: any,
      handler: cytoscape$EventHandler
    ): this;
    addListener(
      events: cytoscape$EventNames,
      selector: string,
      handler: cytoscape$EventHandler
    ): this;
    addListener(
      events: cytoscape$EventNames,
      handler: cytoscape$EventHandler
    ): this;

    /**
     * http://js.cytoscape.org/#eles.promiseOn
     * alias: pon
     */
    promiseOn(
      events: cytoscape$EventNames,
      selector?: string
    ): Promise<cytoscape$EventHandler>;
    pon(
      events: cytoscape$EventNames,
      selector?: string
    ): Promise<cytoscape$EventHandler>;

    /**
     * @param events A space separated list of event names.
     * @param selector [optional] A delegate selector to specify child elements for which the handler is triggered.
     * @param data [optional] A plain object which is passed to the handler in the event object argument.
     * @param function (event) The handler function that is called when one of the specified events occurs.
     * @param event The event object.
     * http://js.cytoscape.org/#eles.one
     */
    one(
      events: cytoscape$EventNames,
      selector: string,
      data: any,
      handler: cytoscape$EventHandler
    ): this;
    one(
      events: cytoscape$EventNames,
      selector: string,
      handler: cytoscape$EventHandler
    ): this;
    one(events: cytoscape$EventNames, handler: cytoscape$EventHandler): this;

    /**
     * http://js.cytoscape.org/#eles.once
     */
    once(
      events: cytoscape$EventNames,
      selector: string,
      data: any,
      handler: cytoscape$EventHandler
    ): this;
    once(
      events: cytoscape$EventNames,
      selector: string,
      handler: cytoscape$EventHandler
    ): this;
    once(events: cytoscape$EventNames, handler: cytoscape$EventHandler): this;

    /**
     * http://js.cytoscape.org/#eles.off
     * alias unbind, unlisten, removeListener
     */
    off(
      events: cytoscape$EventNames,
      selector?: string,
      handler?: cytoscape$EventHandler
    ): this;
    unbind(
      events: cytoscape$EventNames,
      selector?: string,
      handler?: cytoscape$EventHandler
    ): this;
    unlisten(
      events: cytoscape$EventNames,
      selector?: string,
      handler?: cytoscape$EventHandler
    ): this;
    removeListener(
      events: cytoscape$EventNames,
      selector?: string,
      handler?: cytoscape$EventHandler
    ): this;

    /**
     * http://js.cytoscape.org/#eles.trigger
     * alias: emit
     */
    trigger(events: cytoscape$EventNames, extra?: string[]): this;
    emit(events: cytoscape$EventNames, extra?: string[]): this;
  }

  /**
   * http://js.cytoscape.org/#collection/data
   *
   * The following fields are immutable:
   * id: The id field is used to uniquely identify an element in the graph.
   * source & target : These fields define an edge's relationship to nodes, and this relationship can not be changed after creation.
   * parent: The parent field defines the parent (compound) node.
   */
  declare interface cytoscape$CollectionData {
    /**
     * Remove developer-defined data associated with the elements.
     * http://js.cytoscape.org/#eles.removeData
     * @param names A space-separated list of fields to delete.
     */
    removeData(names?: string): cytoscape$CollectionReturnValue;
    removeAttr(names?: string): cytoscape$CollectionReturnValue;

    /**
     * Get an array of the plain JavaScript object
     * representation of all elements in the collection.
     */
    jsons(): string[];
  }

  /**
   * http://js.cytoscape.org/#collection/data
   */
  declare interface cytoscape$SingularData {
    /**
     * Read and write developer-defined data associated with the elements
     * http://js.cytoscape.org/#eles.data
     * Get a particular data field for the element.
     * @param name The name of the field to get.
     */
    data(name?: string): any;

    /**
     * Set a particular data field for the element.
     * @param name The name of the field to set.
     * @param value The value to set for the field.
     */
    data(name: string, value: any): this;

    /**
     * Update multiple data fields at once via an object.
     * @param obj The object containing name- value pairs to update data fields.
     */
    data(obj: any): this;

    /**
     * Get a particular data field for the element.
     * @param name The name of the field to get.
     */
    attr(name?: string): any;

    /**
     * Set a particular data field for the element.
     * @param name The name of the field to set.
     * @param value The value to set for the field.
     */
    attr(name: string, value: any): this;

    /**
     * Update multiple data fields at once via an object.
     * @param obj The object containing name- value pairs to update data fields.
     */
    attr(obj: any): this;

    /**
     * Get or set the scratchpad at a particular namespace,
     * where temporary or non-JSON data can be stored.
     * Get scratchpad if one or no parameter provided.
     * App-level scratchpad data should use namespaces
     * prefixed with underscore, like '_foo'.
     * http://js.cytoscape.org/#ele.scratch
     * @param namespace A namespace string.
     * @param value The value to set at the specified namespace.
     */
    scratch(namespace?: string): cytoscape$Scratchpad;
    scratch(namespace: string, value: any): this;

    /**
     * Remove scratchpad data.
     * You should remove scratchpad data only at your own namespaces.
     * http://js.cytoscape.org/#ele.removeScratch
     * @param namespace A namespace string.
     */
    removeScratch(namespace: string): this;

    /**
     * A shortcut to get the ID of an element.
     * http://js.cytoscape.org/#ele.id
     */
    id(): string;

    /**
     * Get the element's plain JavaScript object representation.
     * http://js.cytoscape.org/#ele.json
     */
    json(): string;

    /**
     * Get the group string that defines the type of the element.
     *
     * The group strings are 'nodes' for nodes and 'edges' for edges.
     * In general, you should be using ele.isEdge()
     * and ele.isNode() instead of ele.group().
     * http://js.cytoscape.org/#ele.group
     */
    group(): cytoscape$ElementGroup;

    /**
     * Get whether the element is a node.
     * http://js.cytoscape.org/#ele.isNode
     */
    isNode(): boolean;

    /**
     * Get whether the element is an edge.
     * http://js.cytoscape.org/#ele.isEdge
     */
    isEdge(): boolean;
  }

  /**
   * http://js.cytoscape.org/#collection/data
   */
  declare interface cytoscape$EdgeSingularData {
    /**
     * Get whether the edge is a loop (i.e. source same as target).
     * http://js.cytoscape.org/#edge.isLoop
     */
    isLoop(): boolean;

    /**
     * Get whether the edge is simple (i.e. source different than target).
     * http://js.cytoscape.org/#edge.isSimple
     */
    isSimple(): boolean;
  }

  /**
   * http://js.cytoscape.org/#collection/metadata
   */
  declare interface cytoscape$NodeSingularMetadata {
    /**
     * Get the degree of a node.
     * @param includeLoops A boolean, indicating whether loops are to be included in degree calculations.
     */
    degree(includeLoops: boolean): number;

    /**
     * Get the indegree of a node.
     * @param includeLoops A boolean, indicating whether loops are to be included in degree calculations.
     */
    indegree(includeLoops: boolean): number;

    /**
     * Get the outdegree of a node.
     * @param includeLoops A boolean, indicating whether loops are to be included in degree calculations.
     */
    outdegree(includeLoops: boolean): number;
  }

  /**
   * http://js.cytoscape.org/#collection/metadata
   */
  declare interface cytoscape$NodeCollectionMetadata {
    /**
     * Get the total degree of a collection of nodes.
     * @param includeLoops A boolean, indicating whether loops are to be included in degree calculations.
     */
    totalDegree(includeLoops: boolean): number;

    /**
     * Get the minimum degree of the nodes in the collection.
     * @param includeLoops A boolean, indicating whether loops are to be included in degree calculations.
     */
    minDegree(includeLoops: boolean): number;

    /**
     * Get the maximum degree of the nodes in the collection.
     * @param includeLoops A boolean, indicating whether loops are to be included in degree calculations.
     */
    maxDegree(includeLoops: boolean): number;

    /**
     * Get the minimum indegree of the nodes in the collection.
     * @param includeLoops A boolean, indicating whether loops are to be included in degree calculations.
     */
    minIndegree(includeLoops: boolean): number;

    /**
     * Get the maximum indegree of the nodes in the collection.
     * @param includeLoops A boolean, indicating whether loops are to be included in degree calculations.
     */
    maxIndegree(includeLoops: boolean): number;

    /**
     * Get the minimum outdegree of the nodes in the collection.
     * @param includeLoops A boolean, indicating whether loops are to be included in degree calculations.
     */
    minOutdegree(includeLoops: boolean): number;

    /**
     * Get the maximum outdegree of the nodes in the collection.
     * @param includeLoops A boolean, indicating whether loops are to be included in degree calculations.
     */
    maxOutdegree(includeLoops: boolean): number;
  }

  /**
   * http://js.cytoscape.org/#collection/position--dimensions
   */
  declare interface cytoscape$NodeSingularPosition {
    /**
     * Get the (model) position of a node.
     */
    position(): cytoscape$Position;

    /**
     * Get the value of a specified position dimension.
     * @param dimension The position dimension to set.
     * @param value The value to set to the dimension.
     */
    position(dimension: cytoscape$PositionDimension): number;

    /**
     * Set the value of a specified position dimension.
     * @param dimension The position dimension to set.
     * @param value The value to set to the dimension.
     */
    position(dimension: cytoscape$PositionDimension, value: number): this;

    /**
     * Set the position using name-value pairs in the specified object.
     * @param pos An object specifying name-value pairs representing dimensions to set.
     */
    position(pos: cytoscape$Position): this;

    /**
     * Get the (model) position of a node.
     */
    modelPosition(): cytoscape$Position;

    /**
     * Get the value of a specified position dimension.
     * @param dimension The position dimension to set.
     * @param value The value to set to the dimension.
     */
    modelPosition(dimension: cytoscape$PositionDimension): number;

    /**
     * Set the value of a specified position dimension.
     * @param dimension The position dimension to set.
     * @param value The value to set to the dimension.
     */
    modelPosition(dimension: cytoscape$PositionDimension, value: number): this;

    /**
     * Set the position using name-value pairs in the specified object.
     * @param pos An object specifying name-value pairs representing dimensions to set.
     */
    modelPosition(pos: cytoscape$Position): this;

    /**
     * Get the (model) position of a node.
     */
    point(): cytoscape$Position;

    /**
     * Get the value of a specified position dimension.
     * @param dimension The position dimension to set.
     * @param value The value to set to the dimension.
     */
    point(dimension: cytoscape$PositionDimension): number;

    /**
     * Set the value of a specified position dimension.
     * @param dimension The position dimension to set.
     * @param value The value to set to the dimension.
     */
    point(dimension: cytoscape$PositionDimension, value: number): this;

    /**
     * Set the position using name-value pairs in the specified object.
     * @param pos An object specifying name-value pairs representing dimensions to set.
     */
    point(pos: cytoscape$Position): this;

    /**
     * Get or set the rendered (on-screen) position of a node.
     * http://js.cytoscape.org/#node.renderedPosition
     * Get the value of a specified rendered position dimension.
     * @param dimension The position dimension to get.
     * @param value The value to set to the dimension.
     * @param pos An object specifying name-value pairs representing dimensions to set.
     */
    renderedPosition(
      dimension?: cytoscape$PositionDimension
    ): cytoscape$Position;
    renderedPosition(
      dimension: cytoscape$PositionDimension,
      value: cytoscape$Position
    ): this;
    renderedPosition(pos: {
      [name: string]: number
    }): this;

    /**
     * Set the value of a specified rendered position dimension.
     * @param dimension The position dimension to set.
     * @param value The value to set to the dimension.
     * @param pos An object specifying name-value pairs representing dimensions to set.
     */
    renderedPoint(dimension?: cytoscape$PositionDimension): cytoscape$Position;
    renderedPoint(
      dimension: cytoscape$PositionDimension,
      value: cytoscape$Position
    ): this;
    renderedPoint(pos: {
      [name: string]: number
    }): this;

    /**
     * http://js.cytoscape.org/#node.relativePosition
     * Get the value of a specified relative position dimension.
     * @param dimension The position dimension to get.
     * @param value The value to set to the dimension.
     * @param pos An object specifying name-value pairs representing dimensions to set.
     */
    relativePosition(
      dimension?: cytoscape$PositionDimension
    ): cytoscape$Position;
    relativePosition(
      dimension: cytoscape$PositionDimension,
      value: cytoscape$Position
    ): this;
    relativePosition(pos: {
      [name: string]: number
    }): this;

    /**
     * Get the value of a specified relative position dimension.
     * @param dimension The position dimension to get.
     * @param value The value to set to the dimension.
     * @param pos An object specifying name-value pairs representing dimensions to set.
     */
    relativePoint(dimension?: cytoscape$PositionDimension): cytoscape$Position;
    relativePoint(
      dimension: cytoscape$PositionDimension,
      value: cytoscape$Position
    ): this;
    relativePoint(pos: {
      [name: string]: number
    }): this;

    /**
     * Get whether a node is currently grabbed, meaning the user has hold of the node.
     * http://js.cytoscape.org/#node.grabbed
     */
    grabbed(): boolean;

    /**
     * Get whether the user can grab a node.
     * http://js.cytoscape.org/#node.grabbable
     */
    grabbable(): boolean;

    /**
     * Get whether a node is locked, meaning that its position can not be changed.
     * http://js.cytoscape.org/#node.locked
     */
    locked(): boolean;
  }

  /**
   * @param ele The element being iterated over for which the function should return a position to set.
   * @param ix The index of the element when iterating over the elements in the collection.
   */
  declare type cytoscape$ElementPositionFunction = (
    ele: cytoscape$NodeSingular,
    ix: number
  ) => cytoscape$Position;

  declare type cytoscape$ElementCollectionFunction = (
    ele: cytoscape$NodeSingular,
    ix: number,
    eles: cytoscape$CollectionArgument
  ) => cytoscape$Position;

  /**
   * http://js.cytoscape.org/#collection/position--dimensions
   */
  declare interface cytoscape$NodeCollectionPosition {
    /**
     * Shift the positions of the nodes by a given model position vector.
     * @param dimension The position dimension to shift.
     * @param value The value to shift the dimension.
     */
    shift(dimension: cytoscape$PositionDimension, value?: number): this;

    /**
     * Shift the positions of the nodes by a given model position vector.
     * @param pos An object specifying name-value pairs representing dimensions to shift.
     */
    shift(pos: cytoscape$Position): this;

    /**
     * Set the positions via a function.
     * @param handler A callback function that returns the position to set for each element.
     * @param pos An object specifying name-value pairs representing dimensions to set.
     * http://js.cytoscape.org/#nodes.positions
     */
    positions(
      handler: cytoscape$ElementPositionFunction | cytoscape$Position
    ): this;
    modelPositions(
      handler: cytoscape$ElementPositionFunction | cytoscape$Position
    ): this;
    points(
      handler: cytoscape$ElementPositionFunction | cytoscape$Position
    ): this;

    /**
     * Allow the user to grab the nodes.
     * http://js.cytoscape.org/#nodes.grabify
     */
    grabify(): this;

    /**
     * Disallow the user to grab the nodes.
     * http://js.cytoscape.org/#nodes.ungrabify
     */
    ungrabify(): this;

    /**
     * Lock the nodes such that their positions can not be changed.
     * http://js.cytoscape.org/#nodes.lock
     */
    lock(): this;

    /**
     * Unlock the nodes such that their positions can be changed.
     * http://js.cytoscape.org/#nodes.unlock
     */
    unlock(): this;
  }

  /**
   * http://js.cytoscape.org/#collection/position--dimensions
   */
  declare interface cytoscape$SingularPosition {
    /**
     * Get the width of the element.
     */
    width(): number;

    /**
     * Get the outer width of the element (includes width, padding, & border).
     */
    outerWidth(): number;

    /**
     * Get the width of the element in rendered dimensions.
     */
    renderedWidth(): number;

    /**
     * Get the outer width of the element (includes width, padding, & border) in rendered dimensions.
     */
    renderedOuterWidth(): number;

    /**
     * Get the height of the element.
     */
    height(): number;

    /**
     * Get the outer height of the element (includes height, padding, & border).
     */
    outerHeight(): number;

    /**
     * Get the height of the element in rendered dimensions.
     */
    renderedHeight(): number;

    /**
     * Get the outer height of the element (includes height, padding, & border) in rendered dimensions.
     */
    renderedOuterHeight(): number;

    /**
     * Gets whether the element is active (e.g. on user tap, grab, etc).
     * http://js.cytoscape.org/#ele.active
     */
    active(): boolean;
  }

  declare interface cytoscape$BoundingBoxOptions {
    /**
     * A boolean indicating whether to include nodes in the bounding box (default true).
     */
    includeNodes?: boolean;

    /**
     * A boolean indicating whether to include edges in the bounding box (default true).
     */
    includeEdges?: boolean;

    /**
     * A boolean indicating whether to include labels in the bounding box (default true).
     */
    includeLabels?: boolean;
  }

  /**
   * http://js.cytoscape.org/#collection/position--dimensions
   */
  declare interface cytoscape$CollectionPosition {
    /**
     * Get the bounding box of the elements in model coordinates.
     * @param options An object containing options for the function.
     * http://js.cytoscape.org/#eles.boundingBox
     */
    boundingBox(
      options: cytoscape$BoundingBoxOptions
    ): cytoscape$BoundingBox12 | cytoscape$BoundingBoxWH;
    boundingbox(
      options: cytoscape$BoundingBoxOptions
    ): cytoscape$BoundingBox12 | cytoscape$BoundingBoxWH;

    /**
     * Get the bounding box of the elements in rendered coordinates.
     * @param options An object containing options for the function.
     */
    renderedBoundingBox(
      options: cytoscape$BoundingBoxOptions
    ): cytoscape$BoundingBox12 | cytoscape$BoundingBoxWH;
    renderedBoundingbox(
      options: cytoscape$BoundingBoxOptions
    ): cytoscape$BoundingBox12 | cytoscape$BoundingBoxWH;
  }

  /**
   * http://js.cytoscape.org/#collection/layout
   */
  declare interface cytoscape$CollectionLayout {
    /**
     * Get a new layout, which can be used to algorithmically position the nodes in the collection.
     * This function is useful for running a layout on a subset of the elements in the graph, perhaps in parallel to other layouts.
     *
     * You must specify options.name with the name of the layout you wish to use.
     *
     * Note: that you must call layout.run() in order for it to affect the graph.
     * @param options The layout options.
     */
    layout(options: cytoscape$LayoutOptions): cytoscape$Layouts;
    makeLayout(options: cytoscape$LayoutOptions): cytoscape$Layouts;
    createLayout(options: cytoscape$LayoutOptions): cytoscape$Layouts;
  }

  /**
   * http://js.cytoscape.org/#collection/layout
   */
  declare interface cytoscape$LayoutPositionOptions {
    animate?: boolean;
    animationDuration?: number;
    animationEasing?: number;
    eles: cytoscape$CollectionArgument;
    fit?: boolean;
    padding?: number;
    pan?: cytoscape$Position;
    ready?: void;
    stop?: void;
    spacingFactor?: number;
    zoom?: number;
  }

  declare interface cytoscape$NodeCollectionLayout {
    /**
     * Position the nodes for a discrete/synchronous layout.
     * http://js.cytoscape.org/#nodes.layoutPositions
     * @param layout The layout.
     * @param options The layout options object.
     */
    layoutPositions(
      layout: string,
      options: cytoscape$LayoutPositionOptions,
      handler: cytoscape$ElementPositionFunction
    ): void;
  }

  /**
   * http://js.cytoscape.org/#collection/layout
   */
  declare interface cytoscape$LayoutDimensionOptions {
    nodeDimensionsIncludeLabels: boolean;
  }

  declare interface cytoscape$NodeSingularLayout {
    /**
     * Returns the node width and height.
     * Meant for use in layout positioning to do overlap detection.
     * @param options The layout options object.
     */
    layoutDimensions(
      options: cytoscape$LayoutDimensionOptions
    ): {
      x: number,
      y: number
    };
  }

  /**
   * http://js.cytoscape.org/#collection/selection
   */
  declare interface cytoscape$SingularSelection {
    /**
     * Get whether the element is selected.
     * http://js.cytoscape.org/#ele.selected
     */
    selected(): boolean;

    /**
     * Get whether the element's selection state is mutable.
     * http://js.cytoscape.org/#ele.selectable
     */
    selectable(): boolean;
  }

  /**
   * http://js.cytoscape.org/#collection/layout
   */
  declare interface cytoscape$CollectionSelection {
    /**
     * Make the elements selected (NB other elements outside the collection are not affected).
     * http://js.cytoscape.org/#eles.select
     */
    select(): this;

    /**
     * Make the elements not selected (NB other elements outside the collection are not affected).
     * http://js.cytoscape.org/#eles.unselect
     */
    unselect(): this;
    deselect(): this;

    /**
     * Make the selection states of the elements mutable.
     * http://js.cytoscape.org/#eles.selectify
     */
    selectify(): this;

    /**
     * Make the selection states of the elements immutable.
     * http://js.cytoscape.org/#eles.unselectify
     */
    unselectify(): this;
  }

  /**
   * http://js.cytoscape.org/#collection/style
   */
  declare type cytoscape$ClassName = string;

  /**
   * A space-separated list of class names
   */
  declare type cytoscape$ClassNames = string;

  declare interface cytoscape$CollectionStyle {
    /**
     * Add classes to elements.
     * http://js.cytoscape.org/#eles.addClass
     * @param classes A space-separated list of class names to add to the elements.
     */
    addClass(classes: cytoscape$ClassNames): this;

    /**
     * Remove classes from elements.
     * @param classes A space-separated list of class names to remove from the elements.
     * http://js.cytoscape.org/#eles.removeClass
     */
    removeClass(classes: cytoscape$ClassNames): this;

    /**
     * Toggle whether the elements have the specified classes.
     * @param classes A space-separated list of class names to toggle on the elements.
     * @param toggle [optional] Instead of automatically toggling, adds the classes on truthy values or removes them on falsey values.
     * http://js.cytoscape.org/#eles.toggleClass
     */
    toggleClass(classes: cytoscape$ClassNames, toggle?: boolean): this;

    /**
     * Replace the current list of classes on the elements with the specified list.
     * @param classes A space-separated list of class names that replaces the current class list.
     * http://js.cytoscape.org/#eles.classes
     * Note: can be used to clear all classes (no arguments).
     */
    classes(classes?: cytoscape$ClassNames): this;

    /**
     * Add classes to the elements, and then remove the classes after a specified duration.
     * @param classes A space-separated list of class names to flash on the elements.
     * @param duration [optional] The duration in milliseconds that the classes should be added on the elements. After the duration, the classes are removed.
     * http://js.cytoscape.org/#eles.flashClass
     */
    flashClass(classes: cytoscape$ClassNames, duration?: number): this;

    /**
     * Set a particular style property value.
     * @param name The name of the visual style property to set.
     * @param value The value to which the property is set.
     */
    style(name: string, value: any): this;

    /**
     * Get a particular style property value.
     * @param name The name of the visual style property to get.
     */
    style(name: string): any;

    /**
     * Set several particular style property values.
     * @param obj An object of style property name-value pairs to set.
     */
    style(obj: { [key: string]: any }): this;

    /**
     * Get a name-value pair object containing visual style properties and their values for the element.
     */
    style(): {
      [index: string]: any
    };

    /**
     * Set a particular style property value.
     * @param name The name of the visual style property to set.
     * @param value The value to which the property is set.
     */
    css(name: string, value: any): this;

    /**
     * Get a particular style property value.
     * @param name The name of the visual style property to get.
     */
    css(name: string): any;

    /**
     * Set several particular style property values.
     * @param obj An object of style property name-value pairs to set.
     */
    css(obj: { [key: string]: any }): this;

    /**
     * Get a name-value pair object containing visual style properties and their values for the element.
     */
    css(): {
      [index: string]: any
    };

    /**
     * Remove all or specific style overrides.
     * @param names A space-separated list of property names to remove overrides
     */
    removeStyle(names?: string): this;
  }

  /**
   * http://js.cytoscape.org/#collection/style
   */
  declare interface cytoscape$SingularStyle {
    /**
     * Get whether an element has a particular class.
     * @param className The name of the class to test for.
     * http://js.cytoscape.org/#ele.hasClass
     */
    hasClass(className: cytoscape$ClassName): boolean;

    /**
     * Get a name-value pair object containing rendered visual
     * style properties and their values for the element.
     * @param name The name of the visual style property to get.
     */
    renderedStyle(): {
      [name: string]: any
    };
    renderedStyle(name: string): any;
    renderedCss(): {
      [name: string]: any
    };
    renderedCss(name: string): any;

    /**
     * Get the numeric value of a style property in
     * preferred units that can be used for calculations.
     * @param name The name of the style property to get.
     * http://js.cytoscape.org/#ele.numericStyle
     */
    numericStyle(name: string): any;

    /**
     * Get the units that ele.numericStyle() is expressed in, for a particular property.
     * @param name The name of the style property to get.
     * http://js.cytoscape.org/#ele.numericStyleUnits
     */
    numericStyleUnits(name: string): any;

    /**
     * Get whether the element is visible.
     * http://js.cytoscape.org/#ele.visible
     */
    visible(): boolean;

    /**
     * Get whether the element is hidden.
     * http://js.cytoscape.org/#ele.visible
     */
    hidden(): boolean;

    /**
     * Get the effective opacity of the element
     *   (i.e. on-screen opacity),
     * which takes into consideration parent node opacity.
     * http://js.cytoscape.org/#ele.effectiveOpacity
     */
    effectiveOpacity(): number;

    /**
     * Get whether the element's effective opacity is completely transparent,
     * which takes into consideration parent node opacity.
     * http://js.cytoscape.org/#ele.transparent
     */
    transparent(): number;
  }

  /**
   * http://js.cytoscape.org/#collection/animation
   */
  declare interface cytoscape$ElementAnimateOptionsBase {
    /**
     * An object containing name-value pairs of style properties to animate.
     */
    style?: {
      [name: string]: any
    };

    /**
     * The duration of the animation in milliseconds.
     */
    duration?: number;

    /**
     * A boolean indicating whether to queue the animation.
     */
    queue?: boolean;

    /**
     * A function to call when the animation is done.
     */
    complete?: () => void;

    /**
     * A function to call each time the animation steps.
     */
    step?: () => void;

    /**
     * A transition-timing-function easing style string that shapes the animation progress curve.
     */
    easing?: Css$TransitionTimingFunction;
  }

  declare type cytoscape$ElementAnimateOptionPos = {
    /**
     * A position to which the elements will be animated.
     */
    position: cytoscape$Position
  } & ElementAnimateOptionsBase;

  declare type cytoscape$ElementAnimateOptionRen = {
    /**
     * A rendered position to which the elements will be animated.
     */
    renderedPosition: cytoscape$Position
  } & ElementAnimateOptionsBase;

  declare interface cytoscape$CollectionAnimation {
    /**
     * Animate the elements.
     * @param options An object containing the details of the animation.
     * http://js.cytoscape.org/#eles.animate
     */
    animate(
      options:
        | cytoscape$ElementAnimateOptionPos
        | cytoscape$ElementAnimateOptionRen,
      params?: cytoscape$ElementAnimateOptionsBase
    ): this;

    /**
     * Add a delay between animations for the elements.
     * @param duration How long the delay should be in milliseconds.
     * @param complete A function to call when the delay is complete.
     * http://js.cytoscape.org/#eles.delay
     */
    delay(duration: number, complete: () => void): this;

    /**
     * Stop all animations that are currently running.
     * @param clearQueue A boolean, indicating whether the queue of animations should be emptied.
     * @param jumpToEnd A boolean, indicating whether the currently-running animations should jump to their ends rather than just stopping midway.
     * http://js.cytoscape.org/#eles.stop
     */
    stop(clearQueue: boolean, jumpToEnd: boolean): this;

    /**
     * Remove all queued animations for the elements.
     * http://js.cytoscape.org/#eles.clearQueue
     */
    clearQueue(): this;
  }

  declare interface cytoscape$SingularAnimationOptionsBase {
    /**
     * A position to which the elements will be animated.
     */
    position: cytoscape$Position;

    /**
     * A rendered position to which the elements will be animated.
     */
    renderedPosition: cytoscape$Position;

    /**
     * An object containing name-value pairs of style properties to animate.
     */
    style: any;

    /**
     * The duration of the animation in milliseconds.
     */
    duration: number;

    /**
     * A transition-timing-function easing style string that shapes the animation progress curve.
     */
    easing: Css$TransitionTimingFunction;
  }

  declare type cytoscape$SingularAnimationOptionsPos = {
    /**
     * A position to which the elements will be animated.
     */
    position: cytoscape$Position
  } & SingularAnimationOptionsBase;

  declare type cytoscape$SingularAnimationOptionsRen = {
    /**
     * A rendered position to which the elements will be animated.
     */
    renderedPosition: cytoscape$Position
  } & SingularAnimationOptionsBase;

  declare interface cytoscape$SingularAnimation {
    /**
     * Get whether the element is currently being animated.
     */
    animated(): boolean;

    /**
     * Get an animation for the element.
     * @param options An object containing the details of the animation.
     */
    animation(
      options:
        | cytoscape$SingularAnimationOptionsRen
        | cytoscape$SingularAnimationOptionsPos
    ): cytoscape$AnimationManipulation;

    /**
     * Get a delay animation for the element.
     * @param duration How long the delay should be in milliseconds.
     * http://js.cytoscape.org/#ele.delayAnimation
     */
    delayAnimation(duration: number): cytoscape$AnimationManipulation;
  }

  /**
   * http://js.cytoscape.org/#collection/comparison
   */
  declare interface cytoscape$CollectionComparision {
    /**
     * Determine whether this collection contains exactly the same elements as another collection.
     * @param eles The other elements to compare to.
     */
    same(eles: cytoscape$CollectionArgument): boolean;

    /**
     * Determine whether this collection contains any of the same elements as another collection.
     * @param eles The other elements to compare to.
     */
    anySame(eles: cytoscape$CollectionArgument): boolean;

    /**
     * Determine whether this collection contains all of the elements of another collection.
     */
    contains(eles: cytoscape$CollectionArgument): boolean;

    /**
     * Determine whether this collection contains all of the elements of another collection.
     */
    has(eles: cytoscape$CollectionArgument): boolean;

    /**
     * Determine whether all elements in the specified collection are in the neighbourhood of the calling collection.
     * @param eles The other elements to compare to.
     */
    allAreNeighbors(eles: cytoscape$CollectionArgument): boolean;

    /**
     * Determine whether all elements in the specified collection are in the neighbourhood of the calling collection.
     * @param eles The other elements to compare to.
     */
    allAreNeighbours(eles: cytoscape$CollectionArgument): boolean;

    /**
     * Determine whether any element in this collection matches a selector.
     * @param selector The selector to match against.
     */
    is(selector: cytoscape$Selector): boolean;

    /**
     * Determine whether all elements in the collection match a selector.
     * @param selector The selector to match against.
     */
    allAre(selector: cytoscape$Selector): boolean;

    /**
     * Determine whether any element in this collection satisfies the specified test function.
     * @param test The test function that returns truthy values for elements that satisfy the test and falsey values for elements that do not satisfy the test.
     * ele - The current element.
     * i - The index of the current element.
     * eles - The collection of elements being tested.
     * @param thisArg [optional] The value for this within the test function.
     */
    some(
      test: (
        ele: cytoscape$CollectionArgument,
        i: number,
        eles: cytoscape$CollectionArgument
      ) => boolean,
      thisArg?: any
    ): boolean;

    /**
     * Determine whether all elements in this collection satisfy the specified test function.
     * @param test The test function that returns truthy values for elements that satisfy the test and falsey values for elements that do not satisfy the test.
     * ele - The current element.
     * i - The index of the current element.
     * eles - The collection of elements being tested.
     * @param thisArg [optional] The value for this within the test function.
     */
    every(
      test: (
        ele: cytoscape$CollectionArgument,
        i: number,
        eles: cytoscape$CollectionArgument
      ) => boolean,
      thisArg?: any
    ): boolean;
  }

  /**
   * http://js.cytoscape.org/#collection/iteration
   */
  declare interface cytoscape$CollectionIteration<TOut, TIn> {
    /**
     * Get the number of elements in the collection.
     */
    size(): number;

    /**
     * Get the number of elements in the collection.
     */
    length: number;

    /**
     * Get whether the collection is empty, meaning it has no elements.
     */
    empty(): boolean;

    /**
     * Get whether the collection is nonempty, meaning it has elements.
     */
    nonempty(): boolean;

    /**
     * Iterate over the elements in the collection using an implementation like the native array function namesake.
     *
     * This function behaves like Array.prototype.forEach() with minor changes for convenience:
     * You can exit the iteration early by returning false in the iterating function.
     * The Array.prototype.forEach() implementation does not support this, but it is included anyway on account of its utility.
     * @param each The function executed each iteration.
     * ele - The current element.
     * i - The index of the current element.
     * eles - The collection of elements being iterated.
     * @param thisArg [optional] The value for this within the iterating function.
     */
    each(
      each: (ele: TIn, i: number, eles: this) => void | boolean,
      thisArg?: any
    ): this;
    forEach(
      each: (ele: TIn, i: number, eles: this) => void | boolean,
      thisArg?: any
    ): this;

    /**
     * Get an element at a particular index in the collection.
     *
     * You may use eles[i] in place of eles.eq(i) as a more performant alternative.
     * @param index The index of the element to get.
     */
    eq(index: number): TOut;

    /**
     * Get an element at a particular index in the collection.
     * @param index The index of the element to get.
     */
    [index: number]: TOut;

    /**
     * Get the first element in the collection.
     */
    first(): TOut;

    /**
     * Get the last element in the collection.
     */
    last(): TOut;

    /**
     * Get a subset of the elements in the collection based on specified indices.
     * @param start [optional] An integer that specifies where to start the selection.
     * The first element has an index of 0.
     * Use negative numbers to select from the end of an array.
     * @param end [optional] An integer that specifies where to end the selection.
     * If omitted, all elements from the start position and to the end of the array will be selected.
     * Use negative numbers to select from the end of an array.
     */
    slice(start?: number, end?: number): this;

    /**
     * Get the collection as an array, maintaining the order of the elements.
     */
    toArray(): TOut[];
  }

  /**
   * http://js.cytoscape.org/#collection/building--filtering
   * Get a new collection, resulting from adding the collection with another one
   * @param eles The elements or array of elements to add or elements in the graph matching the selector.
   * http://js.cytoscape.org/#eles.union
   */
  declare type cytoscape$CollectionBuildingUnionFunc = (
    eles:
      | cytoscape$CollectionArgument
      | cytoscape$CollectionArgument[]
      | cytoscape$Selector
  ) => cytoscape$CollectionReturnValue;

  /**
   * Get a new collection, resulting from the collection without some specified elements.
   * http://js.cytoscape.org/#eles.difference
   * @param eles The elements that will not be in the resultant collection.
   * Elements from the calling collection matching this selector will not be in the resultant collection.
   */
  declare type cytoscape$CollectionBuildingDifferenceFunc = (
    eles: cytoscape$CollectionArgument | cytoscape$Selector
  ) => cytoscape$CollectionReturnValue;

  /**
   * Get the elements in both this collection and another specified collection.
   * http://js.cytoscape.org/#eles.intersection
   * @param eles The elements to intersect with.
   * A selector representing the elements to intersect with.
   * All elements in the graph matching the selector are used as the passed collection.
   */
  declare type cytoscape$CollectionBuildingIntersectionFunc = (
    eles: cytoscape$CollectionArgument | cytoscape$Selector
  ) => cytoscape$CollectionReturnValue;

  /**
   * Get the elements that are in the calling collection or the passed collection but not in both.
   * http://js.cytoscape.org/#eles.symmetricDifference
   * @param eles The elements to apply the symmetric difference with.
   * A selector representing the elements to apply the symmetric difference with.
   * All elements in the graph matching the selector are used as the passed collection.
   */
  declare type cytoscape$CollectionSymmetricDifferenceFunc = (
    eles: cytoscape$CollectionArgument | cytoscape$Selector
  ) => cytoscape$CollectionReturnValue;

  /**
   * http://js.cytoscape.org/#collection/building--filtering
   */
  declare interface cytoscape$CollectionBuildingFiltering<TIn, TOut> {
    /**
     * Get an element in the collection from its ID in a very performant way.
     * @param id The ID of the element to get.
     */
    getElementById(id: string): TOut;

    /**
     * Get an element in the collection from its ID in a very performant way.
     * @param id The ID of the element to get.
     */
    $id(id: string): TOut;

    /**
     * Get a new collection, resulting from adding the collection with another one
     * http://js.cytoscape.org/#eles.union
     */
    union: cytoscape$CollectionBuildingUnionFunc;
    u: cytoscape$CollectionBuildingUnionFunc;
    add: cytoscape$CollectionBuildingUnionFunc;
    "+": cytoscape$CollectionBuildingUnionFunc;
    or: cytoscape$CollectionBuildingUnionFunc;
    "|": cytoscape$CollectionBuildingUnionFunc;

    /**
     * Get a new collection, resulting from the collection without some specified elements.
     * http://js.cytoscape.org/#eles.difference
     */
    difference: cytoscape$CollectionBuildingDifferenceFunc;
    subtract: cytoscape$CollectionBuildingDifferenceFunc;
    "\\": cytoscape$CollectionBuildingDifferenceFunc;
    not: cytoscape$CollectionBuildingDifferenceFunc;
    "!": cytoscape$CollectionBuildingDifferenceFunc;
    relativeComplement: cytoscape$CollectionBuildingDifferenceFunc;
    "-": cytoscape$CollectionBuildingDifferenceFunc;

    /**
     * Get all elements in the graph that are not in the calling collection.
     * http://js.cytoscape.org/#eles.absoluteComplement
     */
    absoluteComplement(): cytoscape$CollectionReturnValue;
    abscomp(): cytoscape$CollectionReturnValue;
    complement(): cytoscape$CollectionReturnValue;

    /**
     * Get the elements in both this collection and another specified collection.
     * http://js.cytoscape.org/#eles.intersection
     */
    intersection: cytoscape$CollectionBuildingIntersectionFunc;
    intersect: cytoscape$CollectionBuildingIntersectionFunc;
    and: cytoscape$CollectionBuildingIntersectionFunc;
    n: cytoscape$CollectionBuildingIntersectionFunc;
    "&": cytoscape$CollectionBuildingIntersectionFunc;
    ".": cytoscape$CollectionBuildingIntersectionFunc;

    /**
     * Get the elements that are in the calling collection
     * or the passed collection but not in both.
     * http://js.cytoscape.org/#eles.symmetricDifference
     */
    symmetricDifference: cytoscape$CollectionSymmetricDifferenceFunc;
    symdiff: cytoscape$CollectionSymmetricDifferenceFunc;
    xor: cytoscape$CollectionSymmetricDifferenceFunc;
    "^": cytoscape$CollectionSymmetricDifferenceFunc;
    "(+)": cytoscape$CollectionSymmetricDifferenceFunc;
    "(-)": cytoscape$CollectionSymmetricDifferenceFunc;

    /**
     * Perform a traditional left/right diff on the two collections.
     * @param selector A selector representing the elements on the right side of the diff. All elements in the graph matching the selector are used as the passed collection.
     * The elements on the right side of the diff.
     * @return This function returns a plain object of the form { left, right, both } where
     * left - is the set of elements only in the calling (i.e. left) collection,
     * right - is the set of elements only in the passed (i.e. right) collection, and
     * both - is the set of elements in both collections.
     * http://js.cytoscape.org/#eles.diff
     */
    diff(
      selector: cytoscape$Selector | cytoscape$CollectionArgument
    ): {
      left: cytoscape$CollectionReturnValue,
      right: cytoscape$CollectionReturnValue,
      both: cytoscape$CollectionReturnValue
    };

    /**
     * Perform a in-place merge of the given elements into the calling collection.
     * @param eles The elements to merge in-place or a selector representing the elements to merge.
     * All elements in the graph matching the selector are used as the passed collection.
     *
     * This function modifies the calling collection instead of returning a new one.
     * Use of this function should be considered for performance in some cases, but otherwise should be avoided. Consider using eles.union() instead.
     * Use this function only on new collections that you create yourself, using cy.collection().
     * This ensures that you do not unintentionally modify another collection.
     *
     * Examples
     * With a collection:
     * @example var col = cy.collection(); // new, empty collection
     * var j = cy.$('#j');
     * var e = cy.$('#e');
     * col.merge( j ).merge( e );
     *
     * With a selector:
     * @example var col = cy.collection(); // new, empty collection
     * col.merge('#j').merge('#e');
     */
    merge(eles: cytoscape$CollectionArgument | cytoscape$Selector): this;

    /**
     * Perform an in-place operation on the calling collection to remove the given elements.
     * @param eles The elements to remove  in-place or a selector representing the elements to remove .
     * All elements in the graph matching the selector are used as the passed collection.
     *
     * This function modifies the calling collection instead of returning a new one.
     * Use of this function should be considered for performance in some cases, but otherwise should be avoided. Consider using eles.filter() or eles.remove() instead.
     * Use this function only on new collections that you create yourself, using cy.collection().
     * This ensures that you do not unintentionally modify another collection.
     *
     * Examples
     * With a collection:
     * @example var col = cy.collection(); // new, empty collection
     * var e = cy.$('#e');
     * col.merge( cy.nodes() );
     * col.unmerge( e );
     *
     * With a selector:
     * @example var col = cy.collection(); // new, empty collection
     * col.merge( cy.nodes() );
     * col.unmerge('#e');
     */
    unmerge(eles: cytoscape$CollectionArgument | cytoscape$Selector): this;

    /**
     * Get a new collection containing elements that are accepted by the specified filter.
     * @param selector The selector to match against.
     * @param filter selector The filter function that returns true for elements to include.
     * i - The index of the current element being considered.
     * ele - The element being considered.
     * http://js.cytoscape.org/#eles.filter
     */
    filter(
      selector:
        | cytoscape$Selector
        | ((ele: TIn, i: number, eles: cytoscape$CollectionArgument) => boolean)
    ): cytoscape$CollectionReturnValue;

    /**
     * Get the nodes that match the specified selector.
     * @param selector The selector to match against.
     * http://js.cytoscape.org/#eles.filter
     */
    nodes(selector?: cytoscape$Selector): cytoscape$NodeCollection;

    /**
     * Get the edges that match the specified selector.
     * @param selector The selector to match against.
     * http://js.cytoscape.org/#eles.filter
     */
    edges(selector?: cytoscape$Selector): cytoscape$EdgeCollection;

    /**
     * Get a new collection containing the elements sorted by the
     * specified comparison function.
     * @param sort The sorting comparison function that returns a negative number
     * for ele1 before ele2, 0 for ele1 same as ele2,
     * or a positive number for ele1 after ele2.
     *
     * http://js.cytoscape.org/#eles.sort
     */
    sort(
      sort: (ele1: TIn, ele2: TIn) => number
    ): cytoscape$CollectionReturnValue;

    /**
     * Get an array containing values mapped from the collection.
     * @param fn The function that returns the mapped value for each element.
     * ele - The current element.
     * i - The index of the current element.
     * eles - The collection of elements being mapped.
     * @param thisArg [optional] The value for this within the iterating function.
     *
     * http://js.cytoscape.org/#eles.map
     */
    map<T>(
      fn: (ele: TIn, i: number, eles: cytoscape$CollectionArgument) => T,
      thisArg?: any
    ): T[];

    /**
     * Reduce a single value by applying a
     * function against an accumulator and each value of the collection.
     * @param fn The function that returns the accumulated value
     * given the previous value and the current element.
     * prevVal The value accumulated from previous elements.
     * ele The current element.
     * i The index of the current element.
     * eles The collection of elements being reduced.
     * @param initialValue The initial value for reducing
     * It is used also for type inference of output, but the type can be
     * also stated explicitly as generic
     * http://js.cytoscape.org/#eles.reduce
     */
    reduce<T>(
      fn: (
        prevVal: T,
        ele: TIn,
        i: number,
        eles: cytoscape$CollectionArgument
      ) => T,
      initialValue: T
    ): T;

    /**
     * Find a minimum value in a collection.
     * @param fn The function that returns the value to compare for each element.
     * ele - The current element.
     * i - The index of the current element.
     * eles - The collection of elements being mapped.
     * @param thisArg [optional] The value for this within the iterating function.
     *
     * http://js.cytoscape.org/#eles.min
     */
    min<T>(
      fn: (ele: TIn, i: number, eles: cytoscape$CollectionArgument) => T,
      thisArg?: any
    ): {
      /**
       * The minimum value found.
       */
      value: T,

      /**
       * The element that corresponds to the minimum value.
       */
      ele: cytoscape$SingularElementReturnValue
    };

    /**
     * Find a maximum value and the corresponding element.
     * @param fn The function that returns the value to compare for each element.
     * ele - The current element.
     * i - The index of the current element.
     * eles - The collection of elements being mapped.
     * @param thisArg [optional] The value for this within the iterating function.
     *
     * http://js.cytoscape.org/#eles.max
     */
    max<T>(
      fn: (ele: TIn, i: number, eles: cytoscape$CollectionArgument) => T,
      thisArg?: any
    ): {
      /**
       * The minimum value found.
       */
      value: T,

      /**
       * The element that corresponds to the minimum value.
       */
      ele: cytoscape$SingularElementReturnValue
    };
  }

  /**
   * http://js.cytoscape.org/#collection/traversing
   */
  declare type cytoscape$MinumumSpanningTree = any;

  declare interface cytoscape$CollectionTraversing {
    /**
     * Get the open neighbourhood of the elements.
     *
     * The neighbourhood returned by this function is a bit different than the traditional definition of a "neighbourhood":
     * This returned neighbourhood includes the edges connecting the collection to the neighbourhood. This gives you more flexibility.
     * An open neighbourhood is one that does not include the original set of elements. If unspecified, a neighbourhood is open by default.
     * @param selector [optional] An optional selector that is used to filter the resultant collection.
     */
    neighborhood(
      selector?: cytoscape$Selector
    ): cytoscape$CollectionReturnValue;

    /**
     * Get the open neighbourhood of the elements.
     *
     * The neighbourhood returned by this function is a bit different than the traditional definition of a "neighbourhood":
     * This returned neighbourhood includes the edges connecting the collection to the neighbourhood. This gives you more flexibility.
     * An open neighbourhood is one that does not include the original set of elements. If unspecified, a neighbourhood is open by default.
     * @param selector [optional] An optional selector that is used to filter the resultant collection.
     */
    openNeighborhood(
      selector?: cytoscape$Selector
    ): cytoscape$CollectionReturnValue;

    /**
     * Get the closed neighbourhood of the elements.
     *
     * The neighbourhood returned by this function is a bit different than the traditional definition of a "neighbourhood":
     * This returned neighbourhood includes the edges connecting the collection to the neighbourhood. This gives you more flexibility.
     * A closed neighbourhood is one that does include the original set of elements.
     * @param selector [optional] An optional selector that is used to filter the resultant collection.
     */
    closedNeighborhood(
      selector?: cytoscape$Selector
    ): cytoscape$CollectionReturnValue;

    /**
     * Get the connected components, considering only the elements in the calling collection.
     * An array of collections is returned, with each collection representing a component.
     */
    components(): cytoscape$CollectionReturnValue[];
  }

  /**
   * http://js.cytoscape.org/#collection/edge-points
   */
  declare interface cytoscape$EdgeSingularPoints {
    /**
     * Get an array of control point model positions for a {@code curve-style: bezier) or {@code curve-style: unbundled-bezier} edge.
     *
     * While the control points may be specified relatively in the CSS,
     * this function returns the absolute model positions of the control points.
     * The points are specified in the order of source-to-target direction.
     * This function works for bundled beziers, but it is not applicable to the middle, straight-line edge in the bundle.
     */
    controlPoints(): cytoscape$Position[];

    /**
     * Get an array of segment point model positions (i.e. bend points) for a {@code curve-style: segments} edge.
     *
     * While the segment points may be specified relatively in the stylesheet,
     * this function returns the absolute model positions of the segment points.
     * The points are specified in the order of source-to-target direction.
     */
    segmentPoints(): cytoscape$Position[];

    /**
     * Get the model position of where the edge ends, towards the source node.
     */
    sourceEndpoint(): cytoscape$Position;

    /**
     * Get the model position of where the edge ends, towards the target node.
     */
    targetEndpoint(): cytoscape$Position;

    /**
     * Get the model position of the midpoint of the edge.
     *
     * The midpoint is, by default, where the edge’s label is centred. It is also the position towards which mid arrows point.
     * For curve-style: unbundled-bezier edges, the midpoint is the middle extremum if the number of control points is odd.
     * For an even number of control points, the midpoint is where the two middle-most control points meet.
     * This is the middle inflection point for bilaterally symmetric or skew symmetric edges, for example.
     * For curve-style: segments edges, the midpoint is the middle segment point if the number of segment points is odd.
     * For an even number of segment points, the overall midpoint is the midpoint of the middle-most line segment (i.e. the mean of the middle two segment points).
     */
    midpoint(): cytoscape$Position;
  }

  declare interface cytoscape$EdgeSingularTraversing {
    /**
     * Get source node of this edge.
     * @param selector An optional selector that is used to filter the resultant collection.
     * http://js.cytoscape.org/#edge.source
     */
    source(selector?: cytoscape$Selector): cytoscape$NodeSingular;

    /**
     * Get target node of this edge.
     * @param selector An optional selector that is used to filter the resultant collection.
     * http://js.cytoscape.org/#edge.target
     */
    target(selector?: cytoscape$Selector): cytoscape$NodeSingular;
  }

  declare interface cytoscape$EdgeCollectionTraversing {
    /**
     * Get the nodes connected to the edges in the collection
     * @param selector [optional] An optional selector that is used to filter the resultant collection.
     */
    connectedNodes(selector?: cytoscape$Selector): cytoscape$NodeCollection;

    /**
     * Get source nodes connected to the edges in the collection.
     * @param selector [optional] An optional selector that is used to filter the resultant collection.
     */
    sources(selector?: cytoscape$Selector): cytoscape$NodeCollection;

    /**
     * Get target nodes connected to the edges in the collection.
     * @param selector [optional] An optional selector that is used to filter the resultant collection.
     */
    targets(selector?: cytoscape$Selector): cytoscape$NodeCollection;

    /**
     * Get edges parallel to those in the collection.
     *
     * Two edges are said to be parallel if they connect the same two nodes.
     * Any two parallel edges may connect nodes in the same direction, in which case the edges share the same source and target.
     * They may alternatively connect nodes in the opposite direction, in which case the source and target are reversed in the second edge.
     * That is:
     * - edge1.source().id() === edge2.source().id()
     *    && edge1.target().id() === edge2.target().id()
     * OR
     * - edge1.source().id() === edge2.target().id()
     *    && edge1.target().id() === edge2.source().id()
     * @param selector [optional] An optional selector that is used to filter the resultant collection.
     */
    parallelEdges(selector?: cytoscape$Selector): cytoscape$EdgeCollection;

    /**
     * Get edges codirected to those in the collection.
     *
     * Two edges are said to be codirected if they connect the same two nodes in the same direction: The edges have the same source and target.
     * That is:
     * - edge1.source().id() === edge2.source().id()
     *    && edge1.target().id() === edge2.target().id()
     * @param selector [optional] An optional selector that is used to filter the resultant collection.
     */
    codirectedEdges(selector?: cytoscape$Selector): cytoscape$EdgeCollection;
  }

  declare interface cytoscape$NodeCollectionTraversing {
    /**
     * Get the edges connecting the collection to another collection. Direction of the edges does not matter.
     * @param eles The other collection.
     * @param selector The other collection, specified as a selector which is matched against all elements in the graph.
     */
    edgesWith(
      eles: cytoscape$CollectionArgument | cytoscape$Selector
    ): cytoscape$EdgeCollection;

    /**
     * Get the edges coming from the collection (i.e. the source) going to another collection (i.e. the target).
     * @param eles The other collection.
     * @param selector The other collection, specified as a selector which is matched against all elements in the graph.
     */
    edgesTo(
      eles: cytoscape$CollectionArgument | cytoscape$Selector
    ): cytoscape$EdgeCollection;

    /**
     * Get the edges connected to the nodes in the collection.
     * @param selector [optional] An optional selector that is used to filter the resultant collection.
     */
    connectedEdges(selector?: cytoscape$Selector): cytoscape$EdgeCollection;

    /**
     * From the set of calling nodes, get the nodes which are roots (i.e. no incoming edges, as in a directed acyclic graph).
     * @param selector [optional] An optional selector that is used to filter the resultant collection.
     */
    roots(selector?: cytoscape$Selector): cytoscape$NodeCollection;

    /**
     * From the set of calling nodes, get the nodes which are leaves (i.e. no outgoing edges, as in a directed acyclic graph).
     * @param selector [optional] An optional selector that is used to filter the resultant collection.
     */
    leaves(selector?: cytoscape$Selector): cytoscape$NodeCollection;

    /**
     * Get edges (and their targets) coming out of the nodes in the collection.
     * @param selector [optional] An optional selector that is used to filter the resultant collection.
     */
    outgoers(selector?: cytoscape$Selector): cytoscape$CollectionReturnValue;

    /**
     * Recursively get edges (and their targets) coming out of the nodes in the collection (i.e. the outgoers, the outgoers' outgoers, ...).
     * @param selector [optional] An optional selector that is used to filter the resultant collection.
     */
    successors(selector?: cytoscape$Selector): cytoscape$CollectionReturnValue;

    /**
     * Get edges (and their sources) coming into the nodes in the collection.
     * @param selector [optional] An optional selector that is used to filter the resultant collection.
     */
    incomers(selector?: cytoscape$Selector): cytoscape$CollectionReturnValue;

    /**
     * Recursively get edges (and their sources) coming into the nodes in the collection (i.e. the incomers, the incomers' incomers, ...).
     * @param selector [optional] An optional selector that is used to filter the resultant collection.
     */
    predecessors(
      selector?: cytoscape$Selector
    ): cytoscape$CollectionReturnValue;
  }

  /**
   * http://js.cytoscape.org/#collection/algorithms
   */
  declare type cytoscape$WeightFn = (edge: cytoscape$EdgeCollection) => number;

  /**
   * The handler returns true when it finds the desired node, and it returns false to cancel the search.
   * v - The current node.
   * e - The edge connecting the previous node to the current node.
   * u - The previous node.
   * i - The index indicating this node is the ith visited node.
   * depth - How many edge hops away this node is from the root nodes.
   */
  declare type cytoscape$SearchVisitFunction = (
    v: cytoscape$NodeCollection,
    e: cytoscape$EdgeCollection,
    u: cytoscape$NodeCollection,
    i: number,
    depth: number
  ) => boolean | void;

  declare interface cytoscape$SearchFirstOptions {
    /**
     * The root nodes (selector or collection) to start the search from.
     */
    roots: cytoscape$Selector | cytoscape$CollectionArgument;

    /**
     * A handler function that is called when a node is visited in the search.
     */
    visit?: cytoscape$SearchVisitFunction;

    /**
     * A boolean indicating whether the algorithm should only go along edges from source to target (default false).
     */
    directed?: boolean;
  }

  declare interface cytoscape$SearchFirstResult {
    /**
     * The path of the search.
     * - The path returned includes edges such that if path[i] is a node, then path[i - 1] is the edge used to get to that node.
     */
    path: cytoscape$CollectionArgument;

    /**
     * The node found by the search
     * - If no node was found, then found is empty.
     * - If your handler function returns false, then the only the path up to that point is returned.
     */
    found: cytoscape$NodeCollection;
  }

  /**
   * http://js.cytoscape.org/#eles.dijkstra
   */
  declare interface cytoscape$SearchDijkstraOptions {
    /**
     * The root node (selector or collection) where the algorithm starts.
     */
    root: cytoscape$Selector | cytoscape$CollectionArgument;

    /**
     * A function that returns the positive numeric weight for this edge.
     *
     * If no weight function is defined, a constant weight of 1 is used for each edge.
     */
    weight?: cytoscape$WeightFn;

    /**
     * A boolean indicating whether the algorithm should only go along edges from source to target (default false).
     */
    directed?: boolean;
  }

  /**
   * http://js.cytoscape.org/#eles.dijkstra
   */
  declare interface cytoscape$SearchDijkstraResult {
    /**
     * Returns the distance from the source node to node.
     */
    distanceTo(node: cytoscape$NodeSingular): number;

    /**
     * Returns a collection containing the shortest path from the source node to node.
     * The path starts with the source node and includes the edges between the nodes in the path such that if pathTo(node)[i] is an edge,
     * then pathTo(node)[i-1] is the previous node in the path and pathTo(node)[i+1] is the next node in the path.
     */
    pathTo(node: cytoscape$NodeSingular): cytoscape$CollectionReturnValue;
  }

  /**
   * http://js.cytoscape.org/#eles.aStar
   */
  declare interface cytoscape$SearchAStarOptions {
    root: cytoscape$Selector | cytoscape$CollectionArgument;
    goal: cytoscape$Selector | cytoscape$CollectionArgument;
    weight?: cytoscape$WeightFn;
    heuristic?: (node: cytoscape$NodeCollection) => number;
    directed?: boolean;
  }

  /**
   * http://js.cytoscape.org/#eles.aStar
   */
  declare interface cytoscape$SearchAStarResult {
    found: boolean;
    distance: number;
    path: cytoscape$CollectionReturnValue;
  }

  /**
   * http://js.cytoscape.org/#eles.floydWarshall
   */
  declare interface cytoscape$SearchFloydWarshallOptions {
    weight: cytoscape$WeightFn;
    directed?: boolean;
  }

  /**
   * http://js.cytoscape.org/#eles.floydWarshall
   */
  declare interface cytoscape$SearchFloydWarshallResult {
    /**
     * Returns the distance from the source node to node.
     */
    distance(
      fromNode: cytoscape$NodeSingular | cytoscape$CollectionSelection,
      toNode: cytoscape$NodeSingular | cytoscape$Selector
    ): number;

    /**
     * Returns a collection containing the shortest path from the source node to node.
     * The path starts with the source node and includes the edges
     * between the nodes in the path such that if pathTo(node)[i] is an edge,
     * then pathTo(node)[i-1] is the previous node in the path and pathTo(node)[i+1]
     * is the next node in the path.
     */
    path(
      fromNode: cytoscape$NodeSingular | cytoscape$CollectionSelection,
      toNode: cytoscape$NodeSingular | cytoscape$Selector
    ): cytoscape$CollectionReturnValue;
  }

  /**
   * http://js.cytoscape.org/#eles.bellmanFord
   */
  declare interface cytoscape$SearchBellmanFordOptions {
    /**
     * The root node (selector or collection) where the search starts.
     */
    root: any;

    /**
     * A function that returns the positive numeric weight for this edge.
     */
    weight?: cytoscape$WeightFn;

    /**
     * Indicating whether the algorithm should only go along
     * edges from source to target (default false).
     */
    directed: boolean;
  }

  /**
   * http://js.cytoscape.org/#eles.bellmanFord
   */
  declare interface cytoscape$SearchBellmanFordResult {
    /**
     * function that computes the shortest path from root node to the argument node
     * (either objects or selector string)
     */
    pathTo(
      node: cytoscape$NodeSingular | cytoscape$Selector
    ): cytoscape$CollectionReturnValue;

    /**
     * function that computes the shortest distance from root node to argument node
     * (either objects or selector string)
     */
    distanceTo(node: cytoscape$NodeSingular | cytoscape$Selector): number;
    hasNegativeWeightCycle: boolean;
  }

  /**
   * http://js.cytoscape.org/#eles.kruskal
   * trivial so implemented in the function
   * http://js.cytoscape.org/#eles.pageRank
   */
  declare interface cytoscape$SearchPageRankOptions {
    /**
     * Numeric parameter for the algorithm.
     */
    dampingFactor?: number;

    /**
     * Numeric parameter that represents the required precision.
     */
    precision?: number;

    /**
     * Maximum number of iterations to perform.
     */
    iterations?: number;
  }

  /**
   * http://js.cytoscape.org/#eles.pageRank
   */
  declare interface cytoscape$SearchPageRankResult {
    /**
     * function that computes the rank of a given node (either object or selector string)
     */
    rank(node: cytoscape$NodeCollection): number;
  }

  /**
   * http://js.cytoscape.org/#eles.degreeCentrality
   */
  declare interface cytoscape$SearchDegreeCentralityOptions {
    /**
     * The root node (selector or collection) for which the
     * centrality calculation is made.
     */
    root: cytoscape$NodeSingular | cytoscape$Selector;

    /**
     * A function that returns the weight for the edge.
     */
    weight?: (edge: cytoscape$EdgeSingular) => number;

    /**
     * The alpha value for the centrality calculation, ranging on [0, 1].
     * With value 0 (default), disregards edge weights and solely uses
     * number of edges in the centrality calculation. With value 1,
     * disregards number of edges and solely uses the edge weights
     * in the centrality calculation.
     */
    alpha?: number;

    /**
     * Whether the directed indegree and outdegree centrality is calculated (true) or
     * whether the undirected centrality is calculated (false, default).
     */
    directed?: boolean;
  }

  /**
   * http://js.cytoscape.org/#eles.degreeCentrality
   */
  declare interface cytoscape$SearchDegreeCentralityResultUndirected {
    /**
     * the degree centrality of the root node
     */
    degree: number;
  }

  declare interface cytoscape$SearchDegreeCentralityResultDirected {
    indegree: number;
    outdegree: number;
  }

  /**
   * http://js.cytoscape.org/#eles.degreeCentralityNormalized
   */
  declare interface cytoscape$SearchDegreeCentralityNormalizedOptions {
    /**
     * A function that returns the weight for the edge.
     */
    weight(edge: cytoscape$EdgeSingular): number;

    /**
     * The alpha value for the centrality calculation, ranging on [0, 1].
     * With value 0 (default), disregards edge weights and solely uses
     * number of edges in the centrality calculation. With value 1,
     * disregards number of edges and solely uses the edge weights
     * in the centrality calculation.
     */
    alpha?: number;

    /**
     * A boolean indicating whether the directed indegree and outdegree centrality is calculated (true) or
     * whether the undirected centrality is calculated (false, default).
     */
    directed?: boolean;
  }

  /**
   * http://js.cytoscape.org/#eles.degreeCentralityNormalized
   */
  declare interface cytoscape$SearchDegreeCentralityNormalizedResultUndirected {
    /**
     * the normalised degree centrality of the specified node
     */
    degree(node: cytoscape$NodeSingular): any;
  }

  declare interface cytoscape$SearchDegreeCentralityNormalizedResultDirected {
    /**
     * the normalised indegree centrality of the specified node
     */
    indegree(node: cytoscape$NodeSingular): any;

    /**
     * the normalised outdegree centrality of the specified node
     */
    outdegree(node: cytoscape$NodeSingular): any;
  }

  /**
   * http://js.cytoscape.org/#eles.closenessCentrality
   */
  declare interface cytoscape$SearchClosenessCentralityOptions {
    /**
     * The root node (selector or collection) for which the
     * centrality calculation is made.
     */
    root: cytoscape$NodeSingular | cytoscape$Selector;

    /**
     * A function that returns the weight for the edge.
     */
    weight?: (edge: cytoscape$EdgeSingular) => number;

    /**
     * A boolean indicating whether the directed indegree and outdegree centrality is calculated (true) or
     * whether the undirected centrality is calculated (false, default).
     */
    directed?: boolean;

    /**
     * A boolean indicating whether the algorithm calculates the
     * harmonic mean (true, default) or the arithmetic mean (false) of distances.
     * The harmonic mean is very useful for graphs that are not strongly connected.
     */
    harmonic?: boolean;
  }

  /**
   * http://js.cytoscape.org/#eles.closenessCentrality
   * trivial
   * http://js.cytoscape.org/#eles.closenessCentralityNormalized
   */
  declare interface cytoscape$SearchClosenessCentralityNormalizedOptions {
    /**
     * A function that returns the weight for the edge.
     */
    weight?: (edge: cytoscape$EdgeSingular) => number;
    directed?: boolean;

    /**
     * A boolean indicating whether the algorithm calculates the
     * harmonic mean (true, default) or the arithmetic mean (false) of distances.
     * The harmonic mean is very useful for graphs that are not strongly connected.
     */
    harmonic?: boolean;

    /**
     * A function that returns the weight for the edge.
     */
    weight?: (edge: cytoscape$EdgeSingular) => number;
    directed?: boolean;

    /**
     * A boolean indicating whether the algorithm calculates the
     * harmonic mean (true, default) or the arithmetic mean (false) of distances.
     * The harmonic mean is very useful for graphs that are not strongly connected.
     */
    harmonic?: boolean;
  }

  /**
   * http://js.cytoscape.org/#eles.closenessCentralityNormalized
   * trivial
   * http://js.cytoscape.org/#eles.betweennessCentrality
   */
  declare interface cytoscape$SearchBetweennessOptions {
    /**
     * A function that returns the weight for the edge.
     */
    weight?: (edge: cytoscape$EdgeSingular) => number;

    /**
     * A boolean indicating whether the directed indegree and outdegree centrality is calculated (true) or
     * whether the undirected centrality is calculated (false, default).
     */
    directed?: boolean;
  }

  /**
   * http://js.cytoscape.org/#eles.betweennessCentrality
   */
  declare interface cytoscape$SearchBetweennessResult {
    /**
     * returns the betweenness centrality of the specified node
     */
    betweenness(node: cytoscape$NodeSingular): number;

    /**
     * returns the normalised betweenness centrality of the specified node
     */
    betweennessNormalized(node: cytoscape$NodeSingular): number;
    betweennessNormalised(node: cytoscape$NodeSingular): number;
  }

  /**
   * http://js.cytoscape.org/#eles.closenessCentralityNormalized
   * trivial
   */
  declare interface cytoscape$CollectionAlgorithms {
    /**
     * Perform a breadth-first search within the elements in the collection.
     * @param options http://js.cytoscape.org/#eles.breadthFirstSearch
     */
    breadthFirstSearch(
      options: cytoscape$SearchFirstOptions
    ): cytoscape$SearchFirstResult;

    /**
     * Perform a depth-first search within the elements in the collection.
     * http://js.cytoscape.org/#eles.depthFirstSearch
     */
    depthFirstSearch(
      options: cytoscape$SearchFirstOptions
    ): cytoscape$SearchFirstResult;

    /**
     * Perform Dijkstra's algorithm on the elements in the collection.
     * This finds the shortest paths to all other nodes in the collection from the root node.
     * http://js.cytoscape.org/#eles.dijkstra
     */
    dijkstra(
      options: cytoscape$SearchDijkstraOptions
    ): cytoscape$SearchDijkstraResult;

    /**
     * Perform the A* search algorithm on the elements in the collection.
     * This finds the shortest path from the root node to the goal node.
     * http://js.cytoscape.org/#eles.aStar
     */
    aStar(options: cytoscape$SearchAStarOptions): cytoscape$SearchAStarResult;

    /**
     * Perform the Floyd Warshall search algorithm on the elements in the collection.
     * This finds the shortest path between all pairs of nodes.
     * http://js.cytoscape.org/#eles.floydWarshall
     */
    aStar(
      options: cytoscape$SearchFloydWarshallOptions
    ): cytoscape$SearchFloydWarshallResult;

    /**
     * Perform the Bellman-Ford search algorithm on the elements in the collection.
     * This finds the shortest path from the starting node to all other nodes in the collection.
     * http://js.cytoscape.org/#eles.bellmanFord
     */
    bellmanFort(
      options: cytoscape$SearchBellmanFordOptions
    ): cytoscape$SearchBellmanFordResult;

    /**
     * Perform Kruskal's algorithm on the elements in the collection,
     * returning the minimum spanning tree, assuming undirected edges.
     * http://js.cytoscape.org/#eles.kruskal
     */
    kruskal(
      handler: (edge: cytoscape$EdgeCollection) => number
    ): cytoscape$CollectionReturnValue;

    /**
     * Finds the minimum cut in a graph using the Karger-Stein algorithm.
     * The optimal result is found with a high probability, but without guarantee.
     * http://js.cytoscape.org/#eles.kargerStein
     */
    kargerStein(): {
      cut: cytoscape$EdgeCollection,
      partitionFirst: cytoscape$NodeCollection,
      partitionSecond: cytoscape$NodeCollection
    };

    /**
     * Rank the nodes in the collection using the Page Rank algorithm.
     * http://js.cytoscape.org/#eles.pageRank
     */
    pageRank(
      options: cytoscape$SearchPageRankOptions
    ): cytoscape$SearchPageRankResult;

    /**
     * Considering only the elements in the calling collection,
     * calculate the degree centrality of the specified root node.
     * http://js.cytoscape.org/#eles.degreeCentrality
     */
    degreeCentrality(
      options: cytoscape$SearchDegreeCentralityOptions
    ):
      | cytoscape$SearchDegreeCentralityResultDirected
      | cytoscape$SearchDegreeCentralityResultUndirected;

    /**
     * Considering only the elements in the calling collection,
     * calculate the normalised degree centrality of the nodes.
     * http://js.cytoscape.org/#eles.degreeCentralityNormalized
     */
    degreeCentralityNormalized(
      options: cytoscape$SearchDegreeCentralityNormalizedOptions
    ):
      | cytoscape$SearchDegreeCentralityNormalizedResultDirected
      | cytoscape$SearchDegreeCentralityNormalizedResultUndirected;

    /**
     * Considering only the elements in the calling collection,
     * calculate the closeness centrality of the specified root node.
     * http://js.cytoscape.org/#eles.closenessCentrality
     */
    closenessCentrality(
      options: cytoscape$SearchClosenessCentralityOptions
    ): number;

    /**
     * Considering only the elements in the calling collection,
     * calculate the closeness centrality of the nodes.
     * http://js.cytoscape.org/#eles.closenessCentralityNormalized
     */
    closenessCentralityNormalized(
      options: cytoscape$SearchClosenessCentralityNormalizedOptions
    ):
      | cytoscape$SearchDegreeCentralityNormalizedResultDirected
      | cytoscape$SearchDegreeCentralityNormalizedResultUndirected;

    /**
     * Considering only the elements in the calling collection,
     * calculate the betweenness centrality of the nodes.
     * http://js.cytoscape.org/#eles.betweennessCentrality
     */
    betweennessCentrality(
      options: cytoscape$SearchBetweennessOptions
    ): cytoscape$SearchBetweennessResult;
  }

  /**
   * http://js.cytoscape.org/#collection/compound-nodes
   */
  declare interface cytoscape$NodeSingularCompound {
    /**
     * Get whether the node is a compound parent
     * (i.e. a node containing one or more child nodes)
     * http://js.cytoscape.org/#node.isParent
     */
    isParent(): boolean;

    /**
     * Get whether the node is childless (i.e. a node with no child nodes)
     * http://js.cytoscape.org/#node.isChildless
     */
    isChildless(): boolean;

    /**
     * Get whether the node is a compound child (i.e. contained within a node)
     *   http://js.cytoscape.org/#node.isChild
     */
    isChild(): boolean;

    /**
     * Get whether the node is an orphan (i.e. a node with no parent)
     * http://js.cytoscape.org/#node.isOrphan
     */
    isOrphan(): boolean;
  }

  /**
   * http://js.cytoscape.org/#collection/compound-nodes
   */
  declare interface cytoscape$NodeCollectionCompound {
    /**
     * Get the compound parent node of each node in the collection.
     * @param selector A selector used to filter the resultant collection.
     * http://js.cytoscape.org/#nodes.parent
     */
    parent(selector?: cytoscape$Selector): cytoscape$NodeCollection;

    /**
     * Get all compound ancestor nodes
     * (i.e. parents, parents' parents, etc.) of each node in the collection.
     * @param selector A selector used to filter the resultant collection.
     * http://js.cytoscape.org/#nodes.ancestors
     */
    ancestors(selector?: cytoscape$Selector): cytoscape$NodeCollection;
    parents(selector?: cytoscape$Selector): cytoscape$NodeCollection;

    /**
     * Get all compound ancestors common to all the nodes in the collection,
     * starting with the closest and getting progressively farther.
     * @param selector A selector used to filter the resultant collection.
     * http://js.cytoscape.org/#nodes.commonAncestors
     */
    commonAncestors(selector?: cytoscape$Selector): cytoscape$NodeCollection;

    /**
     * Get all orphan (i.e. has no compound parent) nodes in the calling collection.
     * @param selector A selector used to filter the resultant collection.
     * http://js.cytoscape.org/#nodes.orphans
     */
    orphans(selector?: cytoscape$Selector): cytoscape$NodeCollection;

    /**
     * Get all nonorphan (i.e. has a compound parent) nodes in the calling collection.
     * @param selector A selector used to filter the resultant collection.
     * http://js.cytoscape.org/#nodes.nonorphans
     */
    nonorphans(selector?: cytoscape$Selector): cytoscape$NodeCollection;

    /**
     * Get all compound child (i.e. direct descendant) nodes of each node in the collection.
     * @param selector A selector used to filter the resultant collection.
     * http://js.cytoscape.org/#nodes.children
     */
    children(selector?: cytoscape$Selector): cytoscape$NodeCollection;

    /**
     * Get all compound descendant (i.e. children, children's children, etc.)
     * nodes of each node in the collection.
     * @param selector A selector used to filter the resultant collection.
     * http://js.cytoscape.org/#nodes.descendants
     */
    descendants(selector?: cytoscape$Selector): cytoscape$NodeCollection;

    /**
     * Get all sibling (i.e. same compound parent)
     * nodes of each node in the collection.
     * @param selector A selector used to filter the resultant collection.
     * http://js.cytoscape.org/#nodes.siblings
     */
    siblings(selector?: cytoscape$Selector): cytoscape$NodeCollection;
  }

  /**
   * A selector functions similar to a CSS selector on DOM elements,
   * but selectors in Cytoscape.js instead work on
   * collections of graph elements.
   * Note that wherever a selector may be specified
   * as the argument to a function,
   * a eles.filter()-style filter function may be
   * used in place of the selector.
   *
   * See http://js.cytoscape.org/#selectors for
   * details about writing selectors.
   * Selectors are an island grammar.
   */
  declare type cytoscape$Selector = string;

  /**
   * A space separated list of event names.
   * http://js.cytoscape.org/#cy.promiseOn
   */
  declare type cytoscape$EventNames = string;

  /**
   * A string indicating the selection behaviour from user input.
   * http://js.cytoscape.org/#core/initialisation
   *
   * 'additive' : a new selection made by the user adds to the set of currently selected elements.
   * 'single' : a new selection made by the user becomes the entire set of currently
   *             selected elements (i.e. the previous elements are unselected)
   */
  declare type cytoscape$SelectionType = "additive" | "single";

  /**
   * http://js.cytoscape.org/#ele.group
   * http://js.cytoscape.org/#notation/elements-json
   *
   * 'nodes'
   * 'edges'
   */
  declare type cytoscape$ElementGroup = "nodes" | "edges";

  /**
   * 'x' : x coordinate
   * 'y' : y coordinate
   */
  declare type cytoscape$PositionDimension = "x" | "y";

  /**
   * Usually temp or nonserialisable data can be stored.
   * http://js.cytoscape.org/#notation/elements-json
   * http://js.cytoscape.org/#cy.scratch
   * http://js.cytoscape.org/#ele.scratch
   */
  declare type cytoscape$Scratchpad = any;

  declare type cytoscape$Css$Colour = string;

  /**
   * The shape of the node’s body.
   * Note that each shape fits within the specified width and height,
   * and so you may have to adjust width and height
   * if you desire an equilateral shape
   * (i.e. width !== height for several equilateral shapes).
   * 'polygon' is a custom polygon specified via shape-polygon-points.
   */
  declare type cytoscape$Css$NodeShape =
    | "rectangle"
    | "roundrectangle"
    | "ellipse"
    | "triangle"
    | "pentagon"
    | "hexagon"
    | "heptagon"
    | "octagon"
    | "star"
    | "diamond"
    | "vee"
    | "rhomboid"
    | "polygon";

  /**
   * A space-separated list of numbers ranging on [-1, 1],
   * representing alternating x and y values (i.e. x1 y1 x2 y2, x3 y3 ...).
   * This represents the points in the polygon for the node’s shape.
   * The bounding box of the node is given by (-1, -1), (1, -1), (1, 1), (-1, 1).
   */
  declare type cytoscape$Css$ShapePolygonPoints = string;

  /**
   * The line style; may be solid, dotted, dashed, or double
   */
  declare type cytoscape$Css$LineStyle =
    | "solid"
    | "dotted"
    | "dashed"
    | "double";

  /**
   * http://js.cytoscape.org/#style/node-body
   */
  declare type cytoscape$Css$Node = {
    label?: string,

    /**
     * The width of the node’s body.
     * This property can take on the special value label
     * so the width is automatically based on the node’s label.
     */
    width?: number | string,

    /**
     * The height of the node’s body.
     * This property can take on the special value label
     * so the height is automatically based on the node’s label.
     */
    height?: number | string,

    /**
     * The shape of the node’s body.
     */
    shape?: cytoscape$Css$NodeShape,
    "shape-polygon-points"?: cytoscape$Css$ShapePolygonPoints,
    opacity?: number,
    backgroundColor?: cytoscape$Css$Colour,

    /**
     * The colour of the node’s body.
     */
    "background-color"?: cytoscape$Css$Colour,

    /**
     * Blackens the node’s body for values from 0 to 1;
     * whitens the node’s body for values from 0 to -1.
     */
    "background-blacken"?: number,

    /**
     * The opacity level of the node’s background colour.
     */
    "background-opacity"?: number,

    /**
     * The size of the node’s border.
     */
    "border-width"?: number,

    /**
     * The style of the node’s border.
     */
    "border-style"?: cytoscape$Css$LineStyle,

    /**
     * The colour of the node’s border.
     */
    "border-color"?: cytoscape$Css$Colour,

    /**
     * The opacity of the node’s border.
     * A value between [0 1].
     */
    "border-opacity"?: number,
    "text-opacity"?: number
  } & $Shape<Css$Overlay> &
    PaddingNode;

  /**
   * A padding defines an addition to a node’s dimension.
   * For example, padding-left adds to a node’s outer (i.e. total) width.
   * This can be used to add spacing around the label of width: label; height: label; nodes,
   * or it can be used to add spacing between a compound node parent and its children.
   */
  declare interface cytoscape$Css$PaddingNode {
    "padding-left"?: string;
    "padding-right"?: string;
    "padding-top"?: string;
    "padding-bottom"?: string;
  }

  declare interface cytoscape$Css$Dictionary {
    [key: string]: any;
  }

  /**
   * A background image may be applied to a node’s body:
   *
   * http://js.cytoscape.org/#style/background-image
   */
  declare interface cytoscape$Css$BackgroundImage {
    /**
     * The URL that points to the image that should be used as the node’s background.
     * PNG, JPG, and SVG are supported formats.
     * You may use a data URI to use embedded images,
     * thereby saving a HTTP request.
     */
    "background-image"?: string;

    /**
     * The opacity of the background image. [0 1]
     */
    "background-image-opacity"?: number;

    /**
     * Specifies the width of the image.
     * A percent value (e.g. 50%) may be used to set
     * the image width relative to the node width.
     * If used in combination with background- fit,
     * then this value overrides the width of the image
     * in calculating the fitting — thereby overriding the aspect ratio.
     * The auto value is used by default, which uses the width of the image.
     */
    "background-width"?: number | string;

    /**
     * Specifies the height of the image.
     * A percent value (e.g. 50%) may be used to set the image
     * height relative to the node height.
     * If used in combination with background- fit,
     * then this value overrides the height of the image in calculating
     * the fitting — thereby overriding the aspect ratio.
     * The auto value is used by default, which uses the height of the image.
     */
    "background-height"?: number | string;

    /**
     * How the background image is fit to the node;
     * may be none for original size,
     * contain to fit inside node,
     * or cover to cover the node.
     */
    "background-fit"?: "none" | "contain" | "cover";

    /**
     * Whether to repeat the background image;
     * may be no-repeat, repeat-x, repeat-y, or repeat.
     */
    "background-repeat"?: "no-repeat" | "repeat-x" | "repeat-y" | "repeat";

    /**
     * The x position of the background image,
     * measured in percent(e.g. 50%) or pixels (e.g. 10px).
     */
    "background-position-x"?: number | string;

    /**
     * The y position of the background image,
     * measured in percent(e.g. 50%) or pixels (e.g. 10px).
     */
    "background-position-y"?: number | string;

    /**
     * How background image clipping is handled;
     * may be node for clipped to node shape or none for no clipping.
     */
    "background-clip"?: "clipped" | "none";
  }

  /**
   * These properties allow you to create pie chart backgrounds on nodes.
   * Note that 16 slices maximum are supported per node,
   * so in the properties 1 <= i <= 16.
   * Of course, you must specify a numerical value for each property in place of i.
   * Each nonzero sized slice is placed in order of i,
   * starting from the 12 o’clock position and working clockwise.
   *
   * You may find it useful to reserve a number to a particular
   * colour for all nodes in your stylesheet.
   * Then you can specify values for pie-i-background-size
   * accordingly for each node via a mapper.
   * This would allow you to create consistently coloured
   * pie charts in each node of the graph based on element data.
   *
   * http://js.cytoscape.org/#style/pie-chart-background
   */
  declare interface cytoscape$Css$PieChartBackground {
    /**
     * The diameter of the pie, measured as a percent of node size (e.g. 100%) or an absolute length (e.g. 25px).
     */
    "pie-size": string;

    /**
     * The colour of the node’s ith pie chart slice.
     */
    "pie-i-background-color": cytoscape$Css$Colour;

    /**
     * The size of the node’s ith pie chart slice, measured in percent (e.g. 25% or 25).
     */
    "pie-i-background-size": number;

    /**
     * The opacity of the node’s ith pie chart slice.
     */
    "pie-i-background-opacity": number;
  }

  declare type cytoscape$Css$Edge = {} & EdgeLine &
    EdgeArror &
    $Shape<Css$Overlay>;

  /**
   * These properties affect the styling of an edge’s line:
   *
   * http://js.cytoscape.org/#style/edge-line
   */
  declare interface cytoscape$Css$EdgeLine {
    /**
     * The width of an edge’s line.
     */
    width?: number | string;

    /**
     * The curving method used to separate two or more edges between two nodes;
     * may be
     *   - haystack (default, very fast, bundled straight edges for which loops and compounds are unsupported),
     *   - bezier(bundled curved edges),
     *   - unbundled - bezier(curved edges for use with manual control points), or
     *   - segments (a series of straight lines).
     * Note that haystack edges work best with ellipse, rectangle, or similar nodes.
     * Smaller node shapes, like triangle, will not be as aesthetically pleasing.
     * Also note that edge arrows are unsupported for haystack edges.
     */
    "curve-style"?: "haystack" | "bezier" | "unbundled" | "segments";

    /**
     * The colour of the edge’s line.
     */
    "line-color"?: cytoscape$Css$Colour;

    /**
     * The style of the edge’s line.
     */
    "line-style"?: cytoscape$Css$LineStyle;
  }

  /**
   * For automatic, bundled bezier edges (curve - style: bezier):
   *
   * http://js.cytoscape.org/#style/bezier-edges
   */
  declare interface cytoscape$Css$BezierEdges {
    /**
     * From the line perpendicular from source to target,
     * this value specifies the distance between successive bezier edges.
     */
    "control-point-step-size": number;

    /**
     * A single value that overrides "control-point-step-size" with a manual value.
     * Because it overrides the step size, bezier edges with the same value will overlap.
     * Thus, it’s best to use this as a one- off value for particular edges if need be.
     */
    "control-point-distance": number;

    /**
     * A single value that weights control points along the line from source to target.
     * The value usually ranges on [0, 1], with
     * 0 towards the source node and
     * 1 towards the target node —
     * but larger or smaller values can also be used.
     */
    "control-point-weight": number;

    /**
     * With value intersection (default),
     * the line from source to target for "control-point-weight" is
     * from the outside of the source node’s shape to the outside of
     * the target node’s shape.With value node- position,
     * the line is from the source position to the target position.
     * The "node-position" option makes calculating edge points easier
     * — but it should be used carefully because you can create invalid
     * points that intersection would have automatically corrected.
     */
    "edge-distances": number;
  }

  /**
   * Unbundled bezier edges
   * For bezier edges with manual control points (curve - style: unbundled - bezier):
   *
   * http://js.cytoscape.org/#style/unbundled-bezier-edges
   */
  declare interface cytoscape$Css$UnbundledBezierEdges {
    /**
     * A series of values that specify for each control point the
     * distance perpendicular to a line formed
     * from source to target, e.g. -20 20 - 20.
     */
    "control-point-distances": string;

    /**
     * A series of values that weights control points along
     * a line from source to target, e.g. 0.25 0.5 0.75.
     * A value usually ranges on [0, 1], with
     * 0 towards the source node and
     * 1 towards the target node
     * — but larger or smaller values can also be used.
     */
    "control-point-weights": string;

    /**
     * With value intersection (default),
     * the line from source to target for "control-point-weights"
     * is from the outside of the source node’s shape to the
     * outside of the target node’s shape.
     * With value
     * "node-position", the line is from the source position to the target position.
     * The "node-position" option makes calculating edge points easier
     * — but it should be used carefully because you can create
     * invalid points that intersection would have automatically corrected.
     */
    "edge-distances": number;
  }

  /**
   * Haystack edges
   * Loop edges and compound parent nodes are not supported by haystack edges.
   * Haystack edges are a more performant replacement for plain, straight line edges.
   *
   * For fast, straight line edges (curve - style: haystack):
   * http://js.cytoscape.org/#style/haystack-edges
   */
  declare interface cytoscape$Css$HaystackEdges {
    /**
     * A value between 0 and 1 inclusive that indicates the relative radius used to position haystack edges on their connected nodes.
     * The outside of the node is at 1, and the centre of the node is at 0.
     */
    "haystack-radius": number;
  }

  /**
   * Segments edges
   * For edges made of several straight lines (curve - style: segments):
   * http://js.cytoscape.org/#style/segments-edges
   */
  declare interface cytoscape$Css$SegmentsEdges {
    /**
     * A series of values that specify for each segment point the distance perpendicular to a line formed from source to target, e.g. -20 20 - 20.
     */
    "segment-distances": string;

    /**
     * A series of values that weights segment points along a line from source to target,
     * e.g. 0.25 0.5 0.75.A value usually ranges on [0, 1],
     * with 0 towards the source node and 1 towards the target node — but larger or smaller values can also be used.
     */
    "segment-weights": string;

    /**
     * With value
     *   * "intersection" (default), the line from source to target
     *   * for "segment-weights" is from the outside of the source node’s shape to the outside of the target node’s shape.
     *   * With value "node-position", the line is from the source position to the target position.
     * The "node-position" option makes calculating edge points easier
     * — but it should be used carefully because you can create
     * invalid points that intersection would have automatically corrected.
     */
    "edge-distances": "intersection" | "segment-weights" | "node-position";
  }

  declare type cytoscape$Css$ArrowShape =
    | "tee"
    | "triangle"
    | "triangle-tee"
    | "triangle-backcurve"
    | "square"
    | "circle"
    | "diamond"
    | "none";

  declare type cytoscape$Css$ArrowFill = "filled" | "hollow";

  /**
   * Edge arrow
   *   * <pos>-arrow-color : The colour of the edge’s source arrow.
   *   * <pos>-arrow-shape : The shape of the edge’s source arrow.
   *   * <pos>-arrow-fill : The fill state of the edge’s source arrow.
   *
   * For each edge arrow property above, replace <pos> with one of
   *   * source : Pointing towards the source node, at the end of the edge.
   *   * mid-source : Pointing towards the source node, at the middle of the edge.
   *   * target : Pointing towards the target node, at the end of the edge.
   *   * mid-target: Pointing towards the target node, at the middle of the edge.
   *
   * Only mid arrows are supported on haystack edges.
   * http://js.cytoscape.org/#style/edge-arrow
   */
  declare interface cytoscape$Css$EdgeArror {
    /**
     * The colour of the edge’s source arrow.
     */
    "source-arrow-color"?: cytoscape$Css$Colour;

    /**
     * The colour of the edge’s "mid-source" arrow.
     */
    "mid-source-arrow-color"?: cytoscape$Css$Colour;

    /**
     * The colour of the edge’s target arrow.
     */
    "target-arrow-color"?: cytoscape$Css$Colour;

    /**
     * The colour of the edge’s "mid-target" arrow.
     */
    "mid-target-arrow-color"?: cytoscape$Css$Colour;

    /**
     * The shape of the edge’s source arrow.
     */
    "source-arrow-shape"?: cytoscape$Css$ArrowShape;

    /**
     * The shape of the edge’s mid-source arrow.
     */
    "mid-source-arrow-shape"?: cytoscape$Css$ArrowShape;

    /**
     * The shape of the edge’s target arrow.
     */
    "target-arrow-shape"?: cytoscape$Css$ArrowShape;

    /**
     * The shape of the edge’s mid-target arrow.
     */
    "mid-target-arrow-shape"?: cytoscape$Css$ArrowShape;

    /**
     * The fill state of the edge’s source arrow.
     */
    "source-arrow-fill"?: cytoscape$Css$ArrowFill;

    /**
     * The fill state of the edge’s mid-source arrow.
     */
    "mid-source-arrow-fill"?: cytoscape$Css$ArrowFill;

    /**
     * The fill state of the edge’s target arrow.
     */
    "target-arrow-fill"?: cytoscape$Css$ArrowFill;

    /**
     * The fill state of the edge’s mid-target arrow.
     */
    "mid-target-arrow-fill"?: cytoscape$Css$ArrowFill;
  }

  /**
   * http://js.cytoscape.org/#style/visibility
   */
  declare interface cytoscape$Css$Visibility {
    /**
     * Whether to display the element; may be element for displayed or none for not displayed.
     * Note that a "display: none" bezier edge does not take up space in its bundle.
     */
    display: "none" | "displayed";

    /**
     * Whether the element is visible; may be visible or hidden.
     * Note that a "visibility : hidden" bezier edge still takes up space in its bundle.
     */
    visibility: "none" | "visible";

    /**
     * The opacity of the element, ranging from 0 to 1.
     * Note that the opacity of a compound node parent affects the effective opacity of its children.
     */
    opacity: number;

    /**
     * An integer value that affects the relative draw order of elements.
     * In general, an element with a higher "z-index" will be drawn on top of an element with a lower "z-index".
     * Note that edges are under nodes despite "z-index", except when necessary for compound nodes.
     */
    "z-index": number;
  }

  /**
   * https://developer.mozilla.org/en-US/docs/Web/CSS/font-style
   */
  declare type cytoscape$Css$FontStyle = "normal" | "italic" | "oblique";

  /**
   * https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight
   */
  declare type cytoscape$Css$FontWeight =
    | number
    | "normal"
    | "bold"
    | "lighter"
    | "bolder";

  /**
   * http://js.cytoscape.org/#style/labels
   */
  declare type cytoscape$Css$TextTranformation =
    | "none"
    | "uppercase"
    | "lowercase";

  /**
   * Labels
   * Label text:
   *
   * http://js.cytoscape.org/#style/labels
   */
  declare interface cytoscape$Css$Labels {
    /**
     * The text to display for an element’s label.
     */
    label: string;

    /**
     * The text to display for an edge’s source label.
     */
    "source-label": string;

    /**
     * The text to display for an edge’s target label.
     */
    "target-label": string;

    /**
     * Basic font styling:
     * The colour of the element’s label.
     */
    color: cytoscape$Css$Colour;

    /**
     * The opacity of the label text, including its outline.
     */
    "text-opacity": number;

    /**
     * A comma-separated list of font names to use on the label text.
     */
    "font-family": string;

    /**
     * The size of the label text.
     * https://developer.mozilla.org/en-US/docs/Web/CSS/font-family
     */
    "font-size": number;

    /**
     * A CSS font style to be applied to the label text.
     * https://developer.mozilla.org/en-US/docs/Web/CSS/font-style
     */
    "font-style": cytoscape$Css$FontStyle;

    /**
     * A CSS font weight to be applied to the label text.
     */
    "font-weight": cytoscape$Css$FontWeight;

    /**
     * A transformation to apply to the label text.
     */
    "text-transform": cytoscape$Css$TextTranformation;

    /**
     * Wrapping text:
     * A wrapping style to apply to the label text; may be
     *   * "none" for no wrapping (including manual newlines ) or
     *   * "wrap" for manual and/ or autowrapping.
     */
    "text-wrap": "none" | "wrap";

    /**
     * The maximum width for wrapped text,
     * applied when "text-wrap" is set to wrap.
     * For only manual newlines (i.e.\n), set a very large
     * value like 1000px such that only your newline characters would apply.
     */
    "text-max-width": string;

    /**
     * Node label alignment:
     * The vertical alignment of a node’s label.
     */
    "text-halign": "left" | "center" | "right";

    /**
     * The vertical alignment of a node’s label.
     */
    "text-valign": "top" | "center" | "bottom";

    /**
     * Edge label alignment:
     * For the source label of an edge, how far from the source node the label should be placed.
     */
    "source-text-offset": number;

    /**
     * For the target label of an edge, how far from the target node the label should be placed.
     */
    "target-text-offset": number;

    /**
     * Margins:
     * A margin that shifts the label along the x- axis.
     */
    "text-margin-x": number;

    /**
     * A margin that shifts the label along the y- axis.
     */
    "text-margin-y": number;

    /**
     * (For the source label of an edge.)
     */
    "source-text-margin-x": number;

    /**
     * (For the source label of an edge.)
     */
    "source-text-margin-y": number;

    /**
     * (For the target label of an edge.)
     */
    "target-text-margin-x": number;

    /**
     * (For the target label of an edge.)
     */
    "target-text-margin-y": number;

    /**
     * Rotating text:
     * A rotation angle that is applied to the label.
     *   * For edges, the special value autorotate can be used to align the label to the edge.
     *   * For nodes, the label is rotated along its anchor point on the node, so a label margin may help for some usecases.
     *   * The special value none can be used to denote 0deg.
     *   * Rotations works best with left- to - right text.
     */
    "text-rotation": number;

    /**
     * (For the source label of an edge.)
     */
    "source-text-rotation": number;

    /**
     * (For the target label of an edge.)
     */
    "target-text-rotation": number;

    /**
     * Outline:
     * The colour of the outline around the element’s label text.
     */
    "text-outline-color": cytoscape$Css$Colour;

    /**
     * The opacity of the outline on label text.
     */
    "text-outline-opacity": number;

    /**
     * The size of the outline on label text.
     */
    "text-outline-width": number;

    /**
     * Shadow:
     * The shadow blur distance.
     */
    "text-shadow-blur": number;

    /**
     * The colour of the shadow.
     */
    "text-shadow-color": cytoscape$Css$Colour;

    /**
     * The x offset relative to the text where the shadow will be displayed, can be negative.
     * If you set blur to 0, add an offset to view your shadow.
     */
    "text-shadow-offset-x": number;

    /**
     * The y offset relative to the text where the shadow will be displayed, can be negative.
     * If you set blur to 0, add an offset to view your shadow.
     */
    "text-shadow-offset-y": number;

    /**
     * The opacity of the shadow on the text; the shadow is disabled for 0 (default value).
     */
    "text-shadow-opacity": number;

    /**
     * Background:
     * A colour to apply on the text background.
     */
    "text-background-color": cytoscape$Css$Colour;

    /**
     * The opacity of the label background; the background is disabled for 0 (default value).
     */
    "text-background-opacity": number;

    /**
     * The shape to use for the label background.
     */
    "text-background-shape": "ractangle" | "roundrectangle";

    /**
     * Border:
     * The width of the border around the label; the border is disabled for 0 (default value).
     */
    "text-border-opacity": number;

    /**
     * The width of the border around the label.
     */
    "text-border-width": number;

    /**
     * The style of the border around the label.
     */
    "text-border-style": cytoscape$Css$LineStyle;

    /**
     * The colour of the border around the label.
     */
    "text-border-color": cytoscape$Css$Colour;

    /**
     * Interactivity:
     * If zooming makes the effective font size of the label smaller than this,
     * then no label is shown.Note that because of performance optimisations,
     * the label may be shown at font sizes slightly smaller than this value.
     *
     * This effect is more pronounced at larger screen pixel ratios.However,
     * it is guaranteed that the label will be shown at sizes equal to or greater than the value specified.
     */
    "min-zoomed-font-size": number;

    /**
     * Whether events should occur on an element if the label receives an event.
     * You may want a style applied to the text onactive so you know the text is activatable.
     */
    "text-events": "yes" | "no";
  }

  /**
   * http://js.cytoscape.org/#style/events
   */
  declare interface cytoscape$Css$Events {
    /**
     * Whether events should occur on an element (e.g.tap, mouseover, etc.).
     *   * For "no", the element receives no events and events simply pass through to the core/viewport.
     */
    events: "yes" | "no";

    /**
     * Whether events should occur on an element if the label receives an event.
     * You may want a style applied to the text on active so you know the text is activatable.
     */
    "text-events": "yes" | "no";
  }

  /**
   * These properties allow for the creation of overlays on top of nodes or edges,
   * and are often used in the :active state.
   * http://js.cytoscape.org/#style/overlay
   */
  declare interface cytoscape$Css$Overlay {
    /**
     * The colour of the overlay.
     */
    "overlay-color": cytoscape$Css$Colour;

    /**
     * The area outside of the element within which the overlay is shown.
     */
    "overlay-padding": number;

    /**
     * The opacity of the overlay.
     */
    "overlay-opacity": number;
  }

  /**
   * These properties allow for the creation of shadows on nodes or edges.
   * Note that shadow-blur could seriously impact performance on large graph.
   * http://js.cytoscape.org/#style/shadow
   */
  declare interface cytoscape$Css$Shadow {
    /**
     * The shadow blur, note that if greater than 0, this could impact performance.
     */
    "shadow-blur": number;

    /**
     * The colour of the shadow.
     */
    "shadow-color": cytoscape$Css$Colour;

    /**
     * The x offset relative to the node/edge where the shadow will be displayed, can be negative. If you set blur to 0, add an offset to view your shadow.
     */
    "shadow-offset-x": number;

    /**
     * The y offset relative to the node/edge where the shadow will be displayed, can be negative. If you set blur to 0, add an offset to view your shadow.
     */
    "shadow-offset-y": number;

    /**
     * The opacity of the shadow.
     */
    "shadow-opacity": number;
  }

  /**
   * Transition animation
   */
  declare type cytoscape$Css$TransitionTimingFunction =
    | "linear"
    | "spring"
    | "cubic-bezier"
    | "ease"
    | "ease-in"
    | "ease-out"
    | "ease-in-out"
    | "ease-in-sine"
    | "ease-out-sine"
    | "ease-in-out-sine"
    | "ease-in-quad"
    | "ease-out-quad"
    | "ease-in-out-quad"
    | "ease-in-cubic"
    | "ease-out-cubic"
    | "ease-in-out-cubic"
    | "ease-in-quart"
    | "ease-out-quart"
    | "ease-in-out-quart"
    | "ease-in-quint"
    | "ease-out-quint"
    | "ease-in-out-quint"
    | "ease-in-expo"
    | "ease-out-expo"
    | "ease-in-out-expo"
    | "ease-in-circ"
    | "ease-out-circ"
    | "ease-in-out-circ";

  /**
   * http://js.cytoscape.org/#style/transition-animation
   */
  declare interface cytoscape$Css$TransitionAnimation {
    /**
     * A comma separated list of style properties to animate in this state.
     */
    "transition-property": string;

    /**
     * The length of the transition in seconds(e.g. 0.5s).
     */
    "transition-duration": number;

    /**
     * The length of the delay in seconds before the transition occurs (e.g. 250ms).
     */
    "transition-delay": number;

    /**
     * An easing function that controls the animation progress curve (a visualisation of easings serves as a reference).
     */
    "transition-timing-function": cytoscape$Css$TransitionTimingFunction;
  }

  /**
   * cy   --> Cy.Core
   *   The core object is your interface to a graph.
   *
   * It is your entry point to Cytoscape.js:
   * All of the library’s features are accessed through this object.
   * http://js.cytoscape.org/#core
   */
  declare type cytoscape$Css$Core = {
    /**
     * Indicator:
     * The colour of the indicator shown when the background is grabbed by the user.
     */
    "active-bg-color": cytoscape$Css$Colour,

    /**
     * The opacity of the active background indicator.
     */
    "active-bg-opacity": number,

    /**
     * The size of the active background indicator.
     */
    "active-bg-size": number,

    /**
     * Selection box:
     * The background colour of the selection box used for drag selection.
     */
    "selection-box-color": cytoscape$Css$Colour,

    /**
     * The colour of the border on the selection box.
     */
    "selection-box-border-color": cytoscape$Css$Colour,

    /**
     * The size of the border on the selection box.
     */
    "selection-box-border-width": number,

    /**
     * The opacity of the selection box.
     */
    "selection-box-opacity": number,

    /**
     * Texture during viewport gestures:
     * The colour of the area outside the viewport texture when initOptions.textureOnViewport === true.
     */
    "outside-texture-bg-color": cytoscape$Css$Colour,

    /**
     * The opacity of the area outside the viewport texture.
     */
    "outside-texture-bg-opacity": number
  } & CoreGraphManipulation &
    CoreGraphManipulationExt &
    CoreEvents &
    CoreViewportManipulation &
    CoreAnimation &
    CoreLayout &
    CoreStyle &
    CoreExport;

  /**
   * Events passed to handler callbacks are similar to
   * jQuery event objects in that they wrap native event objects,
   * mimicking their API.
   *
   * http://js.cytoscape.org/#events
   */
  declare type cytoscape$EventObject = {} & InputEventObject &
    LayoutEventObject;

  /**
   * http://js.cytoscape.org/#events/event-object
   */
  declare interface cytoscape$AbstractEventObject {
    /**
     * a reference to the corresponding core Core
     */
    cy: cytoscape$Css$Core;

    /**
     * indicates the element or core that first caused the event
     */
    target?: any;

    /**
     * the event type string (e.g. "tap")
     */
    type:
      | cytoscape$UserInputDeviceEventName
      | cytoscape$UserInputDeviceEventNameExt;

    /**
     * the event namespace string (e.g. "foo" for "foo.tap")
     */
    namespace: string;

    /**
     * Unix epoch time of event in milliseconds
     */
    timeStamp: number;
  }

  declare type cytoscape$InputEventObject = {
    /**
     * position : indicates the model position of the event
     */
    position: cytoscape$Position,

    /**
     * renderedPosition : indicates the rendered position of the event
     */
    renderedPosition: cytoscape$Position,

    /**
     * originalEvent : the original user input device event object
     */
    originalEvent: cytoscape$EventObject
  } & AbstractEventObject;

  declare type cytoscape$LayoutEventObject = {
    /**
     * layout : indicates the corresponding layout that triggered the event
     * (useful if running multiple layouts simultaneously)
     */
    layout: any
  } & AbstractEventObject;

  /**
   * These are normal browser events that you can bind to via Cytoscape.js.
   * You can bind these events to the core and to collections.
   * http://js.cytoscape.org/#events/user-input-device-events
   */
  declare type cytoscape$UserInputDeviceEventName =
    | "mousedown"
    | "mouseup"
    | "click"
    | "mouseover"
    | "mouseout"
    | "mousemove"
    | "touchstart"
    | "touchmove"
    | "touchend";

  /**
   * There are also some higher level events that you can use
   * so you don’t have to bind to different events for
   * mouse-input devices and for touch devices.
   * http://js.cytoscape.org/#events/user-input-device-events
   */
  declare type cytoscape$UserInputDeviceEventNameExt =
    | "tapstart"
    | "vmousedown"
    | "tapdrag"
    | "vmousemove"
    | "tapdragover"
    | "tapdragout"
    | "tapend"
    | "vmouseup"
    | "tap"
    | "vclick"
    | "taphold"
    | "cxttapstart"
    | "cxttapend"
    | "cxttap"
    | "cxtdrag"
    | "cxtdragover"
    | "cxtdragout"
    | "boxstart"
    | "boxend"
    | "boxselect"
    | "box";

  /**
   * These events are custom to Cytoscape.js. You can bind to these events for collections.
   * http://js.cytoscape.org/#events/collection-events
   */
  declare type cytoscape$CollectionEventName =
    | "add"
    | "remove"
    | "select"
    | "unselect"
    | "lock"
    | "unlock"
    | "grabon"
    | "grab"
    | "drag"
    | "free"
    | "position"
    | "data"
    | "scratch"
    | "style";

  /**
   * These events are custom to Cytoscape.js, and they occur on the core.
   * http://js.cytoscape.org/#events/graph-events
   */
  declare type cytoscape$GraphEventName =
    | "layoutstart"
    | "layoutready"
    | "layoutstop"
    | "ready"
    | "destroy"
    | "render"
    | "pan"
    | "zoom"
    | "resize";

  /**
   * Layouts
   * http://js.cytoscape.org/#layouts
   *
   * The function of a layout is to set the positions on the nodes in the graph.
   * Layouts are extensions of Cytoscape.js such that it is possible for
   * anyone to write a layout without modifying the library itself.
   * Several layouts are included with Cytoscape.js by default,
   * and their options are described in the sections that follow
   * with the default values specified.
   * Note that you must set options.name to the name of the
   * layout to specify which one you want to run.
   * Each layout has its own algorithm for setting the position for each node.
   * This algorithm influences the overall shape of the graph and the lengths of the edges.
   * A layout’s algorithm can be customised by setting its options.
   * Therefore, edge lengths can be controlled by setting the layout options appropriately.
   * For force-directed (physics) layouts,
   * there is generally an option to set a weight to each edge
   * to affect the relative edge lengths.
   * Edge length can also be affected by options like spacing
   * factors, angles, and overlap avoidance.
   * Setting edge length depends on the particular layout,
   * and some layouts will allow for more precise edge lengths than others.
   */
  declare type cytoscape$Layouts = {} & LayoutManipulation & LayoutEvents;

  declare type cytoscape$LayoutOptions =
    | cytoscape$NullLayoutOptions
    | cytoscape$RandomLayoutOptions
    | cytoscape$PresetLayoutOptions
    | cytoscape$GridLayoutOptions
    | cytoscape$CircleLayoutOptions
    | cytoscape$ConcentricLayoutOptions
    | cytoscape$BreadthFirstLayoutOptions
    | cytoscape$CoseLayoutOptions
    | cytoscape$BaseLayoutOptions;

  declare type cytoscape$LayoutHandler = (
    e: cytoscape$LayoutEventObject
  ) => void;

  declare interface cytoscape$BaseLayoutOptions {
    name: string;
    ready?: cytoscape$LayoutHandler;
    stop?: cytoscape$LayoutHandler;
  }

  /**
   * http://js.cytoscape.org/#layouts/null
   */
  declare interface cytoscape$NullLayoutOptions {
    name: "null";
  }

  declare interface cytoscape$BoundingBox12 {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
  }

  declare interface cytoscape$BoundingBoxWH {
    x1: number;
    y1: number;
    w: number;
    h: number;
  }

  declare interface cytoscape$AnimatedLayoutOptions {
    animate?: boolean;
    animationDuration?: number;
    animationEasing?: boolean;
  }

  /**
   * http://js.cytoscape.org/#layouts/random
   */
  declare type cytoscape$RandomLayoutOptions = {
    name: "random",
    fit: boolean,
    padding?: number,
    boundingBox: void | cytoscape$BoundingBox12 | cytoscape$BoundingBoxWH
  } & BaseLayoutOptions &
    AnimatedLayoutOptions;

  /**
   * http://js.cytoscape.org/#layouts/preset
   */
  declare interface cytoscape$NodePositionMap {
    [nodeid: string]: cytoscape$Position;
  }

  declare type cytoscape$NodePositionFunction = (
    nodeid: string
  ) => cytoscape$Position;

  declare type cytoscape$PresetLayoutOptions = {
    name: "preset",
    positions?: cytoscape$NodePositionMap | cytoscape$NodePositionFunction,
    zoom?: number,
    pan?: number,
    fit?: boolean,
    padding?: number
  } & BaseLayoutOptions &
    AnimatedLayoutOptions;

  declare interface cytoscape$SortableNode {
    data: {
      weight: number
    };
  }

  declare type cytoscape$SortingFunction = (
    a: cytoscape$SortableNode,
    b: cytoscape$SortableNode
  ) => number;

  declare type cytoscape$ShapedLayoutOptions = {
    fit: boolean,
    padding?: number,
    boundingBox?: cytoscape$BoundingBox12 | cytoscape$BoundingBoxWH,
    avoidOverlap?: boolean,
    nodeDimensionsIncludeLabels: boolean,
    spacingFactor?: number,
    sort?: cytoscape$SortingFunction
  } & BaseLayoutOptions &
    AnimatedLayoutOptions;

  /**
   * http://js.cytoscape.org/#layouts/grid
   */
  declare type cytoscape$GridLayoutOptions = {
    name: "grid",
    avoidOverlapPadding?: number,
    condense: boolean,
    rows?: number,
    cols?: number,
    position(
      nodeid: string
    ): {
      row: number,
      col: number
    }
  } & ShapedLayoutOptions;

  /**
   * http://js.cytoscape.org/#layouts/circle
   */
  declare type cytoscape$CircleLayoutOptions = {
    name: "circle",
    radius?: number,
    startAngle: number,
    sweep?: number,
    clockwise?: boolean
  } & ShapedLayoutOptions;

  /**
   * http://js.cytoscape.org/#layouts/concentric
   */
  declare type cytoscape$ConcentricLayoutOptions = {
    name: "concentric",
    startAngle: number,
    sweep?: number,
    clockwise?: boolean,
    equidistant: false,
    minNodeSpacing: 10,
    height: void,
    width: void,
    spacingFactor: void,
    concentric(node: {
      degree(): number
    }): number,
    levelWidth(node: {
      maxDegree(): number
    }): number
  } & ShapedLayoutOptions;

  /**
   * http://js.cytoscape.org/#layouts/breadthfirst
   */
  declare type cytoscape$BreadthFirstLayoutOptions = {
    name: "breadthfirst",
    directed: boolean,
    circle: boolean,
    roots?: string,
    maximalAdjustments: number
  } & ShapedLayoutOptions;

  /**
   * http://js.cytoscape.org/#layouts/cose
   */
  declare type cytoscape$CoseLayoutOptions = {
    name: "cose",
    refresh: number,
    randomize: boolean,
    componentSpacing: number,
    nodeRepulsion(node: any): number,
    nodeOverlap: number,
    idealEdgeLength(edge: any): number,
    edgeElasticity(edge: any): number,
    nestingFactor: number,
    gravity: number,
    numIter: number,
    initialTemp: number,
    coolingFactor: number,
    minTemp: number,
    weaver: boolean
  } & ShapedLayoutOptions;

  /**
   * http://js.cytoscape.org/#layouts/layout-manipulation
   * Layouts have a set of functions available to them,
   * which allow for more complex behaviour than the primary run-one-layout-at-a-time usecase.
   * A new, developer accessible layout can be made via cy.makeLayout().
   */
  declare interface cytoscape$LayoutManipulation {
    /**
     * Start running the layout
     * http://js.cytoscape.org/#layout.run
     */
    run(): this;
    start(): this;

    /**
     * Stop running the (asynchronous/discrete) layout
     * http://js.cytoscape.org/#layout.stop
     */
    stop(): this;
  }

  declare interface cytoscape$LayoutEvents {
    /**
     * http://js.cytoscape.org/#layouts/layout-events
     * @param events A space separated list of event names.
     * @param data [optional] A plain object which is passed to the
     * handler in the event object argument.
     * @param handler The handler function that is called
     * when one of the specified events occurs.
     */
    on(events: cytoscape$EventNames, handler: cytoscape$EventHandler): this;
    on(
      events: cytoscape$EventNames,
      data: any,
      handler: cytoscape$EventHandler
    ): this;
    bind(events: cytoscape$EventNames, handler: cytoscape$EventHandler): this;
    bind(
      events: cytoscape$EventNames,
      data: any,
      handler: cytoscape$EventHandler
    ): this;
    listen(events: cytoscape$EventNames, handler: cytoscape$EventHandler): this;
    listen(
      events: cytoscape$EventNames,
      data: any,
      handler: cytoscape$EventHandler
    ): this;
    addListener(
      events: cytoscape$EventNames,
      handler: cytoscape$EventHandler
    ): this;
    addListener(
      events: cytoscape$EventNames,
      data: any,
      handler: cytoscape$EventHandler
    ): this;

    /**
     * Get a promise that is resolved with the first of any of
     * the specified events triggered on the layout.
     * http://js.cytoscape.org/#layout.promiseOn
     */
    promiseOn(events: cytoscape$EventNames): Promise<cytoscape$EventObject>;
    pon(events: cytoscape$EventNames): Promise<cytoscape$EventObject>;

    /**
     * Bind to events that are emitted by the layout, and trigger the handler only once.
     * @param events A space separated list of event names.
     * @param data [optional] A plain object which is passed to the handler in the event object argument.
     * @param handler The handler function that is called when one of the specified events occurs.
     */
    one(events: cytoscape$EventNames, handler: cytoscape$EventHandler): this;
    one(
      events: cytoscape$EventNames,
      data: any,
      handler: cytoscape$EventHandler
    ): this;

    /**
     * Remove event handlers on the layout.
     * http://js.cytoscape.org/#layout.off
     * @param events A space separated list of event names.
     * @param handler [optional] A reference to the handler function to remove.
     */
    off(events: cytoscape$EventNames, handler?: cytoscape$EventHandler): this;
    unbind(
      events: cytoscape$EventNames,
      handler?: cytoscape$EventHandler
    ): this;
    unlisten(
      events: cytoscape$EventNames,
      handler?: cytoscape$EventHandler
    ): this;
    removeListener(
      events: cytoscape$EventNames,
      handler?: cytoscape$EventHandler
    ): this;

    /**
     * Trigger one or more events on the layout.
     * http://js.cytoscape.org/#layout.trigger
     * @param events A space separated list of event names to trigger.
     * @param extraParams [optional] An array of additional parameters to pass to the handler.
     */
    trigger(events: cytoscape$EventNames, extraParams?: any[]): this;
  }

  /**
   * An animation represents a visible change in state over
   * a duration of time for a single element.
   * Animations can be generated via cy.animation()
   * (for animations on the viewport) and ele.animation()
   * (for animations on graph elements).
   * http://js.cytoscape.org/#animations
   * http://js.cytoscape.org/#animations/animation-manipulation
   */
  declare interface cytoscape$AnimationManipulation {
    /**
     * Requests that the animation be played, starting on the next frame.
     * If the animation is complete, it restarts from the beginning.
     * http://js.cytoscape.org/#ani.play
     */
    play(): this;

    /**
     * Get whether the animation is currently playing.
     * http://js.cytoscape.org/#ani.playing
     */
    playing(): boolean;

    /**
     * Get or set how far along the animation has progressed.
     * http://js.cytoscape.org/#ani.progress
     * Get the progress of the animation in percent.
     */
    progress(): number;

    /**
     * Set the progress of the animation in percent.
     * @param progress The progress in percent (i.e. between 0 and 1 inclusive) to set to the animation.
     */
    progress(progress: number): cytoscape$AnimationManipulation;

    /**
     * Get the progress of the animation in milliseconds.
     */
    time(): number;

    /**
     * Set the progress of the animation in milliseconds.
     * @param time The progress in milliseconds
     * (i.e. between 0 and the duration inclusive) to set to the animation.
     */
    time(time: number): cytoscape$AnimationManipulation;

    /**
     * Rewind the animation to the beginning.
     */
    rewind(): cytoscape$AnimationManipulation;

    /**
     * Fastforward the animation to the end.
     */
    fastforward(): cytoscape$AnimationManipulation;

    /**
     * Pause the animation, maintaining the current progress.
     * http://js.cytoscape.org/#ani.pause
     */
    pause(): cytoscape$AnimationManipulation;

    /**
     * Stop the animation, maintaining the current progress
     * and removing the animation from any associated queues.
     * http://js.cytoscape.org/#ani.stop
     */
    stop(): cytoscape$AnimationManipulation;

    /**
     * Get whether the animation has progressed to the end.
     * http://js.cytoscape.org/#ani.completed
     */
    completed(): cytoscape$AnimationManipulation;
    complete(): cytoscape$AnimationManipulation;

    /**
     * Apply the animation at its current progress.
     * http://js.cytoscape.org/#ani.apply
     */
    apply(): cytoscape$AnimationManipulation;

    /**
     * Get whether the animation is currently applying.
     * http://js.cytoscape.org/#ani.applying
     */
    applying(): cytoscape$AnimationManipulation;

    /**
     * Reverse the animation such that its starting
     * conditions and ending conditions are reversed.
     * http://js.cytoscape.org/#ani.reverse
     */
    reverse(): cytoscape$AnimationManipulation;

    /**
     * Get a promise that is fulfilled with the specified animation event.
     * @param animationEvent A string for the event name; completed or complete for
     * completing the animation or frame for the next frame of the animation.
     * http://js.cytoscape.org/#ani.promise
     */
    promise(
      animationEvent?: "completed" | "complete" | "frame"
    ): Promise<cytoscape$EventObject>;
  }

  /**
   * Cytoscape extension type
   * Definition of an extension would be in following form:
   * @example declare module 'cytoscape-ext' {
   * const ext: cytoscape.Ext;
   * export = ext;
   * }
   */
  declare type cytoscape$Ext = (
    cytoscape: (options?: cytoscape$CytoscapeOptions) => cytoscape$Css$Core
  ) => void;

  /**
   * Register imported extension into cytoscape
   * @param module Entry point for the extension, got by module = require('cy-ext')
   * or by import module from 'cy-ext'
   * http://js.cytoscape.org/#extensions
   */
  declare function cytoscape$use(module: cytoscape$Ext): void;
}

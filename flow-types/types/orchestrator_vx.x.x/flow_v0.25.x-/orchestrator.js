declare module "orchestrator" {
  import typeof * as events from "events";

  import typeof * as stream from "stream";

  import typeof * as Q from "q";

  /**
   * A module for sequencing and executing tasks and dependencies in maximum concurrency
   */
  declare class Orchestrator mixins events.EventEmitter {
    doneCallback: (error?: any) => any;
    isRunning: boolean;
    seq: any[];
    tasks: {
      [name: string]: Orchestrator$Task
    };
    reset(): Orchestrator;

    /**
     * Define a task
     * @param name The name of the task.
     * @param fn The function that performs the task's operations. For asynchronous tasks, you need to provide a hint when the task is complete:
     * - Take in a callback
     * - Return a stream or a promise
     */
    add(name: string, fn?: Orchestrator$TaskFunc): Orchestrator;

    /**
     * Define a task
     * @param name The name of the task.
     * @param deps An array of task names to be executed and completed before your task will run.
     * @param fn The function that performs the task's operations. For asynchronous tasks, you need to provide a hint when the task is complete:
     * - Take in a callback
     * - Return a stream or a promise
     */
    add(
      name: string,
      deps?: string[],
      fn?: Orchestrator$TaskFunc
    ): Orchestrator;
    task(name: string): Orchestrator$Task;
    task(name: string, fn: Orchestrator$TaskFunc): void;
    task(name: string, dep: string[], fn: Orchestrator$TaskFunc): void;

    /**
     * Have you defined a task with this name?
     * @param name The task name to query
     */
    hasTask(name: string): boolean;
    start: Orchestrator$StartMethod;
    stop(err?: any, successfulFinish?: boolean): void;
    sequence: Orchestrator$Sequencify;
    allDone(): boolean;

    /**
     * Listen to orchestrator internals
     * @param event Event name to listen to:
     * - start: from start() method, shows you the task sequence
     * - stop: from stop() method, the queue finished successfully
     * - err: from stop() method, the queue was aborted due to a task error
     * - task_start: from _runTask() method, task was started
     * - task_stop: from _runTask() method, task completed successfully
     * - task_err: from _runTask() method, task errored
     * - task_not_found: from start() method, you're trying to start a task that doesn't exist
     * - task_recursion: from start() method, there are recursive dependencies in your task list
     * @param cb Passes single argument: e: event details
     */
    on(
      event: Orchestrator$EventNames,
      cb: (e: Orchestrator$OnCallbackEvent) => any
    ): this;

    /**
     * Listen to all orchestrator events from one callback
     * @param cb Passes single argument: e: event details
     */
    onAll(cb: (e: Orchestrator$OnAllCallbackEvent) => any): void;
    _resetTask(task: Orchestrator$Task): void;
    _resetAllTasks(): void;
    _resetSpecificTasks(names: string[]): void;
    _runStep(): void;
    _readyToRunTask(task: Orchestrator$Task): boolean;
    _stopTask(task: Orchestrator$Task, meta: Orchestrator$Meta): void;
    _emitTaskDone(task: Orchestrator$Task, message: string, err?: any): void;
    _runTask(task: Orchestrator$Task): void;
  }
  declare type Orchestrator$Strings = string | string[];

  /**
   * The method export generated by orchestrator/lib/runTask.js
   */
  declare type Orchestrator$RunTask = (
    task: Orchestrator$TaskFunc,
    done: (err: any, meta: Orchestrator$Meta) => void
  ) => void;

  /**
   * The module export of the sequencify package: https://www.npmjs.com/package/sequencify
   */
  declare type Orchestrator$Sequencify = (
    tasks: Array<{
      dep: string[]
    }>,
    names: string[]
  ) => {
    sequence: string[],
    missingTasks: string[],
    recursiveDependencies: string[]
  };

  /**
   * A task, can either call a callback to indicate task completion or return a promise or a stream: (task is marked complete when promise.then() resolves/fails or stream ends)
   */
  declare type Orchestrator$TaskFunc = (
    callback: (err?: any) => void
  ) => Q.Promise<any> | stream.Stream | any;

  declare interface Orchestrator$AddMethod {
    /**
     * Define a task
     * @param name The name of the task.
     * @param fn The function that performs the task's operations. For asynchronous tasks, you need to provide a hint when the task is complete:
     * - Take in a callback
     * - Return a stream or a promise
     */
    (name: string, fn?: Orchestrator$TaskFunc): Orchestrator;

    /**
     * Define a task
     * @param name The name of the task.
     * @param deps An array of task names to be executed and completed before your task will run.
     * @param fn The function that performs the task's operations. For asynchronous tasks, you need to provide a hint when the task is complete:
     * - Take in a callback
     * - Return a stream or a promise
     */
    (name: string, deps?: string[], fn?: Orchestrator$TaskFunc): Orchestrator;
  }

  /**
   * Start running the tasks
   */
  declare interface Orchestrator$StartMethod {
    /**
     * Start running the tasks
     * @param tasks Tasks to be executed. You may pass any number of tasks as individual arguments.
     * @param cb Callback to call after run completed.
     */
    (tasks: Orchestrator$Strings, cb?: (error?: any) => any): Orchestrator;

    /**
     * Start running the tasks
     * @param tasks Tasks to be executed. You may pass any number of tasks as individual arguments.
     * @param cb Callback to call after run completed.
     */
    (...tasks: Orchestrator$Strings[]): Orchestrator;
    (
      task1: Orchestrator$Strings,
      task2: Orchestrator$Strings,
      cb?: (error?: any) => any
    ): Orchestrator;
    (
      task1: Orchestrator$Strings,
      task2: Orchestrator$Strings,
      task3: Orchestrator$Strings,
      cb?: (error?: any) => any
    ): Orchestrator;
    (
      task1: Orchestrator$Strings,
      task2: Orchestrator$Strings,
      task3: Orchestrator$Strings,
      task4: Orchestrator$Strings,
      cb?: (error?: any) => any
    ): Orchestrator;
    (
      task1: Orchestrator$Strings,
      task2: Orchestrator$Strings,
      task3: Orchestrator$Strings,
      task4: Orchestrator$Strings,
      task5: Orchestrator$Strings,
      cb?: (error?: any) => any
    ): Orchestrator;
    (
      task1: Orchestrator$Strings,
      task2: Orchestrator$Strings,
      task3: Orchestrator$Strings,
      task4: Orchestrator$Strings,
      task5: Orchestrator$Strings,
      task6: Orchestrator$Strings,
      cb?: (error?: any) => any
    ): Orchestrator;
  }

  declare interface Orchestrator$OnCallbackEvent {
    message: string;
    task: string;
    err: any;
    duration?: number;
  }

  declare type Orchestrator$OnAllCallbackEvent = {
    src: string
  } & OnCallbackEvent;

  declare interface Orchestrator$Task {
    fn: Orchestrator$TaskFunc;
    dep: string[];
    name: string;
    done?: boolean;
    duration?: number;
    hrDuration?: [number, number];
    running?: boolean;
  }

  declare interface Orchestrator$Meta {
    duration: number;
    hrDuration: [number, number];
    runMethod: "callback" | "catch" | "promise" | "stream" | "sync";
  }

  declare type Orchestrator$EventNames =
    | "start"
    | "stop"
    | "err"
    | "task_start"
    | "task_stop"
    | "task_err"
    | "task_not_found"
    | "task_recursion";
  declare export default typeof Orchestrator;
}
